; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

prime8bytes DQ	cf1bbcdcb7a56463H
PUBLIC	ZSTD_ldm_skipSequences
PUBLIC	ZSTD_ldm_getTableSize
PUBLIC	ZSTD_ldm_adjustParameters
PUBLIC	ZSTD_ldm_generateSequences
PUBLIC	ZSTD_ldm_getMaxNbSeq
PUBLIC	ZSTD_ldm_blockCompress
PUBLIC	ZSTD_ldm_fillHashTable
pdata	SEGMENT
$pdata$maybeSplitSequence DD imagerel maybeSplitSequence
	DD	imagerel maybeSplitSequence+130
	DD	imagerel $unwind$maybeSplitSequence
$pdata$ZSTD_ldm_generateSequences_internal DD imagerel ZSTD_ldm_generateSequences_internal
	DD	imagerel ZSTD_ldm_generateSequences_internal+1812
	DD	imagerel $unwind$ZSTD_ldm_generateSequences_internal
$pdata$ZSTD_ldm_fillLdmHashTable DD imagerel ZSTD_ldm_fillLdmHashTable
	DD	imagerel ZSTD_ldm_fillLdmHashTable+34
	DD	imagerel $unwind$ZSTD_ldm_fillLdmHashTable
$pdata$3$ZSTD_ldm_fillLdmHashTable DD imagerel ZSTD_ldm_fillLdmHashTable+34
	DD	imagerel ZSTD_ldm_fillLdmHashTable+218
	DD	imagerel $chain$3$ZSTD_ldm_fillLdmHashTable
$pdata$4$ZSTD_ldm_fillLdmHashTable DD imagerel ZSTD_ldm_fillLdmHashTable+218
	DD	imagerel ZSTD_ldm_fillLdmHashTable+231
	DD	imagerel $chain$4$ZSTD_ldm_fillLdmHashTable
$pdata$ZSTD_ldm_fillFastTables DD imagerel ZSTD_ldm_fillFastTables
	DD	imagerel ZSTD_ldm_fillFastTables+53
	DD	imagerel $unwind$ZSTD_ldm_fillFastTables
$pdata$ZSTD_ldm_makeEntryAndInsertByTag DD imagerel ZSTD_ldm_makeEntryAndInsertByTag
	DD	imagerel ZSTD_ldm_makeEntryAndInsertByTag+235
	DD	imagerel $unwind$ZSTD_ldm_makeEntryAndInsertByTag
$pdata$ZSTD_ldm_insertEntry DD imagerel ZSTD_ldm_insertEntry
	DD	imagerel ZSTD_ldm_insertEntry+74
	DD	imagerel $unwind$ZSTD_ldm_insertEntry
$pdata$ZSTD_matchState_dictMode DD imagerel ZSTD_matchState_dictMode
	DD	imagerel ZSTD_matchState_dictMode+59
	DD	imagerel $unwind$ZSTD_matchState_dictMode
$pdata$ZSTD_count_2segments DD imagerel ZSTD_count_2segments
	DD	imagerel ZSTD_count_2segments+106
	DD	imagerel $unwind$ZSTD_count_2segments
$pdata$ZSTD_storeSeq DD imagerel ZSTD_storeSeq
	DD	imagerel ZSTD_storeSeq+271
	DD	imagerel $unwind$ZSTD_storeSeq
$pdata$ZSTD_ldm_generateSequences DD imagerel $LN52
	DD	imagerel $LN52+501
	DD	imagerel $unwind$ZSTD_ldm_generateSequences
$pdata$ZSTD_ldm_blockCompress DD imagerel $LN117
	DD	imagerel $LN117+24
	DD	imagerel $unwind$ZSTD_ldm_blockCompress
$pdata$0$ZSTD_ldm_blockCompress DD imagerel $LN117+24
	DD	imagerel $LN117+176
	DD	imagerel $chain$0$ZSTD_ldm_blockCompress
$pdata$1$ZSTD_ldm_blockCompress DD imagerel $LN117+176
	DD	imagerel $LN117+766
	DD	imagerel $chain$1$ZSTD_ldm_blockCompress
$pdata$2$ZSTD_ldm_blockCompress DD imagerel $LN117+766
	DD	imagerel $LN117+792
	DD	imagerel $chain$2$ZSTD_ldm_blockCompress
$pdata$3$ZSTD_ldm_blockCompress DD imagerel $LN117+792
	DD	imagerel $LN117+900
	DD	imagerel $chain$3$ZSTD_ldm_blockCompress
$pdata$ZSTD_ldm_fillHashTable DD imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$ZSTD_ldm_fillHashTable
$pdata$0$ZSTD_ldm_fillHashTable DD imagerel $LN18+41
	DD	imagerel $LN18+93
	DD	imagerel $chain$0$ZSTD_ldm_fillHashTable
$pdata$1$ZSTD_ldm_fillHashTable DD imagerel $LN18+93
	DD	imagerel $LN18+162
	DD	imagerel $chain$1$ZSTD_ldm_fillHashTable
xdata	SEGMENT
$unwind$maybeSplitSequence DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTD_ldm_generateSequences_internal DD 0a2601H
	DD	02f0126H
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	030145015H
$unwind$ZSTD_ldm_fillLdmHashTable DD 050c01H
	DD	0e008a20cH
	DD	050057006H
	DD	03004H
$chain$3$ZSTD_ldm_fillLdmHashTable DD 082a21H
	DD	0af42aH
	DD	012d41cH
	DD	011c410H
	DD	0106404H
	DD	imagerel ZSTD_ldm_fillLdmHashTable
	DD	imagerel ZSTD_ldm_fillLdmHashTable+34
	DD	imagerel $unwind$ZSTD_ldm_fillLdmHashTable
$chain$4$ZSTD_ldm_fillLdmHashTable DD 021H
	DD	imagerel ZSTD_ldm_fillLdmHashTable
	DD	imagerel ZSTD_ldm_fillLdmHashTable+34
	DD	imagerel $unwind$ZSTD_ldm_fillLdmHashTable
$unwind$ZSTD_ldm_fillFastTables DD 010401H
	DD	04204H
$unwind$ZSTD_ldm_makeEntryAndInsertByTag DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
$unwind$ZSTD_ldm_insertEntry DD 010401H
	DD	04204H
$unwind$ZSTD_matchState_dictMode DD 010401H
	DD	04204H
$unwind$ZSTD_count_2segments DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$ZSTD_storeSeq DD 020501H
	DD	013405H
$unwind$ZSTD_ldm_generateSequences DD 0a1901H
	DD	0123419H
	DD	0f0159219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$ZSTD_ldm_blockCompress DD 071101H
	DD	0e00dc211H
	DD	07009d00bH
	DD	050076008H
	DD	03006H
$chain$0$ZSTD_ldm_blockCompress DD 020821H
	DD	016c408H
	DD	imagerel $LN117
	DD	imagerel $LN117+24
	DD	imagerel $unwind$ZSTD_ldm_blockCompress
$chain$1$ZSTD_ldm_blockCompress DD 020521H
	DD	0cf405H
	DD	imagerel $LN117+24
	DD	imagerel $LN117+176
	DD	imagerel $chain$0$ZSTD_ldm_blockCompress
$chain$2$ZSTD_ldm_blockCompress DD 021H
	DD	imagerel $LN117+24
	DD	imagerel $LN117+176
	DD	imagerel $chain$0$ZSTD_ldm_blockCompress
$chain$3$ZSTD_ldm_blockCompress DD 021H
	DD	imagerel $LN117
	DD	imagerel $LN117+24
	DD	imagerel $unwind$ZSTD_ldm_blockCompress
$unwind$ZSTD_ldm_fillHashTable DD 020601H
	DD	03002b206H
$chain$0$ZSTD_ldm_fillHashTable DD 020521H
	DD	0e7405H
	DD	imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$ZSTD_ldm_fillHashTable
$chain$1$ZSTD_ldm_fillHashTable DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$ZSTD_ldm_fillHashTable
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
$T1 = 64
state$ = 112
ip$ = 120
iend$ = 128
params$ = 136
ZSTD_ldm_fillHashTable PROC

; 230  : {

$LN18:
	push	rbx
	sub	rsp, 96					; 00000060H

; 231  :     DEBUGLOG(5, "ZSTD_ldm_fillHashTable");
; 232  :     if ((size_t)(iend - ip) >= params->minMatchLength) {

	mov	r11d, DWORD PTR [r9+12]
	mov	rbx, r8
	mov	rax, rbx
	mov	r8, rdx
	sub	rax, rdx
	cmp	rax, r11
	jb	$LN2@ZSTD_ldm_f
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 677  :     return ZSTD_rollingHash_append(0, buf, size);

	xor	edx, edx
	mov	r10d, edx

; 665  :     for (pos = 0; pos < size; ++pos) {

	test	r11, r11
	je	SHORT $LN8@ZSTD_ldm_f
	mov	QWORD PTR [rsp+112], rdi
	mov	rdi, -3523014627327384477		; cf1bbcdcb7a56463H
	npad	8
$LL13@ZSTD_ldm_f:

; 666  :         hash *= prime8bytes;
; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	eax, BYTE PTR [r10+r8]
	inc	r10
	imul	rdx, rdi
	add	rdx, 10
	add	rdx, rax
	cmp	r10, r11
	jb	SHORT $LL13@ZSTD_ldm_f

; 665  :     for (pos = 0; pos < size; ++pos) {

	mov	rdi, QWORD PTR [rsp+112]
$LN8@ZSTD_ldm_f:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 234  :         ZSTD_ldm_fillLdmHashTable(

	mov	eax, DWORD PTR [r9+4]
	sub	rbx, r11
	sub	eax, DWORD PTR [r9+8]
	movups	xmm0, XMMWORD PTR [r9]
	movsd	xmm1, QWORD PTR [r9+16]
	lea	r9, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+48], r9
	mov	r9, rbx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	call	ZSTD_ldm_fillLdmHashTable
$LN2@ZSTD_ldm_f:

; 235  :             state, startingHash, ip, iend - params->minMatchLength, state->window.base,
; 236  :             params->hashLog - params->bucketSizeLog,
; 237  :             *params);
; 238  :     }
; 239  : }

	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
ZSTD_ldm_fillHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
$T1 = 48
minMatch$1$ = 160
rawSeqStore$ = 160
blockCompressor$1$ = 168
ms$ = 168
seqStore$ = 176
rep$ = 184
src$ = 192
srcSize$ = 200
ZSTD_ldm_blockCompress PROC

; 568  : {

$LN117:
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	sub	rsp, 104				; 00000068H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	movups	xmm1, XMMWORD PTR [rdx+16]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 568  : {

	mov	rbx, r9
	mov	QWORD PTR [rsp+176], r12

; 570  :     unsigned const minMatch = cParams->minMatch;

	mov	r9d, DWORD PTR [rdx+200]
	mov	rsi, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	psrldq	xmm1, 8
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 568  : {

	mov	rbp, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	movq	r10, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 570  :     unsigned const minMatch = cParams->minMatch;

	mov	DWORD PTR minMatch$1$[rsp], r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	mov	rax, r10
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 568  : {

	mov	r12, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	shr	rax, 32					; 00000020H
	cmp	eax, r10d

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	jae	SHORT $LN11@ZSTD_ldm_b
	mov	eax, 1
	jmp	SHORT $LN12@ZSTD_ldm_b
$LN11@ZSTD_ldm_b:
	mov	rax, QWORD PTR [rdx+176]
	neg	rax
	sbb	rax, rax
	and	eax, 2
$LN12@ZSTD_ldm_b:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 575  :     BYTE const* const iend = istart + srcSize;

	mov	rdi, QWORD PTR src$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2221 :     selectedCompressor = blockCompressor[(int)dictMode][(int)strat];

	lea	rcx, QWORD PTR [rax+rax*4]
	movsxd	rax, DWORD PTR [rdx+208]
	lea	r14, OFFSET FLAT:?blockCompressor@?1??ZSTD_selectBlockCompressor@@9@9
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 575  :     BYTE const* const iend = istart + srcSize;

	mov	r13, QWORD PTR srcSize$[rsp]

; 583  :     while (rawSeqStore->pos < rawSeqStore->size && ip < iend) {

	mov	r10d, 512				; 00000200H
	mov	r8, QWORD PTR [r12+8]
	add	r13, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2221 :     selectedCompressor = blockCompressor[(int)dictMode][(int)strat];

	lea	rdx, QWORD PTR [rax+rcx*2]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 571  :     ZSTD_blockCompressor const blockCompressor =

	mov	r14, QWORD PTR [r14+rdx*8]
	mov	QWORD PTR blockCompressor$1$[rsp], r14

; 583  :     while (rawSeqStore->pos < rawSeqStore->size && ip < iend) {

	cmp	r8, QWORD PTR [r12+16]
	jae	$LN93@ZSTD_ldm_b
	mov	QWORD PTR [rsp+96], r15
$LL2@ZSTD_ldm_b:
	cmp	rdi, r13
	jae	$LN114@ZSTD_ldm_b

; 544  :     rawSeq sequence = rawSeqStore->seq[rawSeqStore->pos];

	mov	rax, QWORD PTR [r12]
	lea	rcx, QWORD PTR [r8+r8*2]

; 584  :         /* maybeSplitSequence updates rawSeqStore->pos */
; 585  :         rawSeq const sequence = maybeSplitSequence(rawSeqStore,

	mov	edx, r13d
	sub	edx, edi

; 544  :     rawSeq sequence = rawSeqStore->seq[rawSeqStore->pos];

	movsd	xmm0, QWORD PTR [rax+rcx*4]
	mov	r14d, DWORD PTR [rax+rcx*4+8]
	movsd	QWORD PTR $T1[rsp], xmm0

; 545  :     assert(sequence.offset > 0);
; 546  :     /* Likely: No partial sequence */
; 547  :     if (remaining >= sequence.litLength + sequence.matchLength) {

	mov	rcx, QWORD PTR $T1[rsp]
	mov	ebx, DWORD PTR $T1[rsp+4]
	shr	rcx, 32					; 00000020H
	lea	eax, DWORD PTR [r14+rcx]
	cmp	edx, eax
	jb	SHORT $LN18@ZSTD_ldm_b

; 548  :         rawSeqStore->pos++;
; 549  :         return sequence;

	mov	r15d, DWORD PTR $T1[rsp]
	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [r12+8], rax
	jmp	SHORT $LN17@ZSTD_ldm_b
$LN18@ZSTD_ldm_b:

; 550  :     }
; 551  :     /* Cut the sequence short (offset == 0 ==> rest is literals). */
; 552  :     if (remaining <= sequence.litLength) {

	cmp	edx, ecx
	jbe	SHORT $LN112@ZSTD_ldm_b

; 553  :         sequence.offset = 0;
; 554  :     } else if (remaining < sequence.litLength + sequence.matchLength) {

	lea	eax, DWORD PTR [r14+rbx]
	cmp	edx, eax
	jae	SHORT $LN113@ZSTD_ldm_b

; 555  :         sequence.matchLength = remaining - sequence.litLength;

	mov	r14d, edx
	sub	r14d, ebx
	cmp	r14d, r9d

; 556  :         if (sequence.matchLength < minMatch) {

	jb	SHORT $LN112@ZSTD_ldm_b
$LN113@ZSTD_ldm_b:
	mov	r15d, DWORD PTR $T1[rsp]
	jmp	SHORT $LN22@ZSTD_ldm_b
$LN112@ZSTD_ldm_b:

; 557  :             sequence.offset = 0;

	xor	r15d, r15d
$LN22@ZSTD_ldm_b:

; 558  :         }
; 559  :     }
; 560  :     /* Skip past `remaining` bytes for the future sequences. */
; 561  :     ZSTD_ldm_skipSequences(rawSeqStore, remaining, minMatch);

	mov	r8d, r9d
	mov	rcx, r12
	call	ZSTD_ldm_skipSequences
	mov	r10d, 512				; 00000200H
$LN17@ZSTD_ldm_b:

; 586  :                                                    (U32)(iend - ip), minMatch);
; 587  :         int i;
; 588  :         /* End signal */
; 589  :         if (sequence.offset == 0)

	test	r15d, r15d
	je	$LN115@ZSTD_ldm_b

; 250  :     if (current > ms->nextToUpdate + 1024) {

	mov	edx, DWORD PTR [rbp+36]
	mov	ecx, edi
	sub	ecx, DWORD PTR [rbp+8]
	lea	eax, DWORD PTR [rdx+1024]
	cmp	ecx, eax
	jbe	SHORT $LN25@ZSTD_ldm_b

; 251  :         ms->nextToUpdate =

	mov	eax, ecx
	sub	eax, edx
	add	eax, -1024				; fffffc00H
	cmp	eax, r10d
	cmova	eax, r10d
	sub	ecx, eax
	mov	DWORD PTR [rbp+36], ecx
$LN25@ZSTD_ldm_b:

; 176  :     switch(ms->cParams.strategy)

	mov	ecx, DWORD PTR [rbp+208]
	sub	ecx, 1
	je	SHORT $LN32@ZSTD_ldm_b
	cmp	ecx, 1
	jne	SHORT $LN35@ZSTD_ldm_b

; 180  :         break;
; 181  : 
; 182  :     case ZSTD_dfast:
; 183  :         ZSTD_fillDoubleHashTable(ms, iend, ZSTD_dtlm_fast);

	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rbp
	call	ZSTD_fillDoubleHashTable

; 184  :         break;

	jmp	SHORT $LN35@ZSTD_ldm_b
$LN32@ZSTD_ldm_b:

; 177  :     {
; 178  :     case ZSTD_fast:
; 179  :         ZSTD_fillHashTable(ms, iend, ZSTD_dtlm_fast);

	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rbp
	call	ZSTD_fillHashTable
$LN35@ZSTD_ldm_b:

; 590  :             break;
; 591  : 
; 592  :         assert(ip + sequence.litLength + sequence.matchLength <= iend);
; 593  : 
; 594  :         /* Fill tables for block compressor */
; 595  :         ZSTD_ldm_limitTableUpdate(ms, ip);
; 596  :         ZSTD_ldm_fillFastTables(ms, ip);
; 597  :         /* Run the block compressor */
; 598  :         DEBUGLOG(5, "pos %u : calling block compressor on segment of size %u", (unsigned)(ip-istart), sequence.litLength);
; 599  :         {
; 600  :             size_t const newLitLength =

	mov	r8, QWORD PTR rep$[rsp]
	mov	r9, rdi
	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], rbx
	mov	rcx, rbp
	call	QWORD PTR blockCompressor$1$[rsp]

; 601  :                 blockCompressor(ms, seqStore, rep, ip, sequence.litLength);
; 602  :             ip += sequence.litLength;

	add	rdi, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	r9, QWORD PTR [r13-32]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 605  :                 rep[i] = rep[i-1];

	mov	rbx, QWORD PTR rep$[rsp]

; 606  :             rep[0] = sequence.offset;
; 607  :             /* Store the sequence */
; 608  :             ZSTD_storeSeq(seqStore, newLitLength, ip - newLitLength, iend,

	lea	r11d, DWORD PTR [r14-3]
	mov	r10, rax
	mov	ecx, DWORD PTR [rbx+4]
	mov	DWORD PTR [rbx+8], ecx
	mov	ecx, DWORD PTR [rbx]
	mov	DWORD PTR [rbx+4], ecx
	mov	rcx, rdi
	sub	rcx, rax
	mov	DWORD PTR [rbx], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rdx, QWORD PTR [rsi+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdi, r9
	ja	SHORT $LN38@ZSTD_ldm_b
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rdx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rax, 16
	jbe	SHORT $LN60@ZSTD_ldm_b

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
	add	rcx, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, r10
	npad	1
$LL52@ZSTD_ldm_b:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL52@ZSTD_ldm_b
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN60@ZSTD_ldm_b
$LN38@ZSTD_ldm_b:

; 424  :     if (ip <= ilimit_w) {

	cmp	rcx, r9
	ja	SHORT $LN92@ZSTD_ldm_b
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r8, rdx
	sub	r8, rcx
	add	r8, r9
	sub	rcx, rdx
	npad	10
$LL69@ZSTD_ldm_b:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 289  :             COPY16(op, ip);

	add	rdx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdx, r8
	jb	SHORT $LL69@ZSTD_ldm_b
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rdx, r8
	mov	rcx, r9
$LN92@ZSTD_ldm_b:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rcx, rdi
	jae	SHORT $LN60@ZSTD_ldm_b
	sub	rdx, rcx
	npad	2
$LL97@ZSTD_ldm_b:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [rdx+rcx], al
	inc	rcx
	cmp	rcx, rdi
	jb	SHORT $LL97@ZSTD_ldm_b
$LN60@ZSTD_ldm_b:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], r10
	mov	rcx, QWORD PTR [rsi+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r10, 65535				; 0000ffffH
	jbe	SHORT $LN105@ZSTD_ldm_b

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN105@ZSTD_ldm_b:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r10w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r15+3]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r11d, 65535				; 0000ffffH
	jbe	SHORT $LN106@ZSTD_ldm_b

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN106@ZSTD_ldm_b:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 583  :     while (rawSeqStore->pos < rawSeqStore->size && ip < iend) {

	mov	r9d, DWORD PTR minMatch$1$[rsp]
	mov	r10d, 512				; 00000200H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r11w

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 583  :     while (rawSeqStore->pos < rawSeqStore->size && ip < iend) {

	mov	r8, QWORD PTR [r12+8]

; 609  :                           sequence.offset + ZSTD_REP_MOVE,
; 610  :                           sequence.matchLength - MINMATCH);
; 611  :             ip += sequence.matchLength;

	mov	eax, r14d
	add	rdi, rax
	cmp	r8, QWORD PTR [r12+16]
	jb	$LL2@ZSTD_ldm_b

; 586  :                                                    (U32)(iend - ip), minMatch);
; 587  :         int i;
; 588  :         /* End signal */
; 589  :         if (sequence.offset == 0)

	jmp	SHORT $LN114@ZSTD_ldm_b
$LN115@ZSTD_ldm_b:
	mov	rbx, QWORD PTR rep$[rsp]
$LN114@ZSTD_ldm_b:
	mov	r14, QWORD PTR blockCompressor$1$[rsp]
	mov	r10d, 512				; 00000200H
	mov	r15, QWORD PTR [rsp+96]
$LN93@ZSTD_ldm_b:

; 250  :     if (current > ms->nextToUpdate + 1024) {

	mov	edx, DWORD PTR [rbp+36]
	mov	ecx, edi
	sub	ecx, DWORD PTR [rbp+8]
	mov	r12, QWORD PTR [rsp+176]
	lea	eax, DWORD PTR [rdx+1024]
	cmp	ecx, eax
	jbe	SHORT $LN76@ZSTD_ldm_b

; 251  :         ms->nextToUpdate =

	mov	eax, ecx
	sub	eax, edx
	add	eax, -1024				; fffffc00H
	cmp	eax, r10d
	cmova	eax, r10d
	sub	ecx, eax
	mov	DWORD PTR [rbp+36], ecx
$LN76@ZSTD_ldm_b:

; 176  :     switch(ms->cParams.strategy)

	mov	ecx, DWORD PTR [rbp+208]
	sub	ecx, 1
	je	SHORT $LN83@ZSTD_ldm_b
	cmp	ecx, 1
	jne	SHORT $LN86@ZSTD_ldm_b

; 180  :         break;
; 181  : 
; 182  :     case ZSTD_dfast:
; 183  :         ZSTD_fillDoubleHashTable(ms, iend, ZSTD_dtlm_fast);

	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rbp
	call	ZSTD_fillDoubleHashTable

; 184  :         break;

	jmp	SHORT $LN86@ZSTD_ldm_b
$LN83@ZSTD_ldm_b:

; 177  :     {
; 178  :     case ZSTD_fast:
; 179  :         ZSTD_fillHashTable(ms, iend, ZSTD_dtlm_fast);

	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rbp
	call	ZSTD_fillHashTable
$LN86@ZSTD_ldm_b:

; 612  :         }
; 613  :     }
; 614  :     /* Fill the tables for the block compressor */
; 615  :     ZSTD_ldm_limitTableUpdate(ms, ip);
; 616  :     ZSTD_ldm_fillFastTables(ms, ip);
; 617  :     /* Compress the last literals */
; 618  :     return blockCompressor(ms, seqStore, rep, ip, iend - ip);

	sub	r13, rdi
	mov	r9, rdi
	mov	r8, rbx
	mov	QWORD PTR src$[rsp], r13
	mov	rdx, rsi
	mov	rcx, rbp
	mov	rax, r14

; 619  : }

	add	rsp, 104				; 00000068H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 612  :         }
; 613  :     }
; 614  :     /* Fill the tables for the block compressor */
; 615  :     ZSTD_ldm_limitTableUpdate(ms, ip);
; 616  :     ZSTD_ldm_fillFastTables(ms, ip);
; 617  :     /* Compress the last literals */
; 618  :     return blockCompressor(ms, seqStore, rep, ip, iend - ip);

	rex_jmp	rax
ZSTD_ldm_blockCompress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
params$ = 8
maxChunkSize$ = 16
ZSTD_ldm_getMaxNbSeq PROC

; 61   :     return params.enableLdm ? (maxChunkSize / params.minMatchLength) : 0;

	cmp	DWORD PTR [rcx], 0
	mov	rax, rdx
	je	SHORT $LN3@ZSTD_ldm_g
	mov	ecx, DWORD PTR [rcx+12]
	xor	edx, edx
	div	rcx

; 62   : }

	ret	0
$LN3@ZSTD_ldm_g:

; 61   :     return params.enableLdm ? (maxChunkSize / params.minMatchLength) : 0;

	xor	eax, eax

; 62   : }

	ret	0
ZSTD_ldm_getMaxNbSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
ldmState$ = 144
sequences$ = 152
params$ = 160
iend$1$ = 168
src$ = 168
nbChunks$1$ = 176
srcSize$ = 176
ZSTD_ldm_generateSequences PROC

; 432  : {

$LN52:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 433  :     U32 const maxDist = 1U << params->windowLog;

	mov	rax, QWORD PTR srcSize$[rsp]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [r8+20]
	mov	r11d, 1
	mov	r13d, r11d
	mov	rsi, rdx
	shl	r13d, cl

; 434  :     BYTE const* const istart = (BYTE const*)src;
; 435  :     BYTE const* const iend = istart + srcSize;
; 436  :     size_t const kMaxChunkSize = 1 << 20;
; 437  :     size_t const nbChunks = (srcSize / kMaxChunkSize) + ((srcSize % kMaxChunkSize) != 0);
; 438  :     size_t chunk;
; 439  :     size_t leftoverSize = 0;

	mov	r15d, 0
	test	rax, 1048575				; 000fffffH
	lea	rdx, QWORD PTR [r9+rax]
	mov	ecx, 0
	mov	QWORD PTR iend$1$[rsp], rdx
	setne	cl
	mov	rdi, r9
	shr	rax, 20

; 440  : 
; 441  :     assert(ZSTD_CHUNKSIZE_MAX >= kMaxChunkSize);
; 442  :     /* Check that ZSTD_window_update() has been called for this chunk prior
; 443  :      * to passing it to this function.
; 444  :      */
; 445  :     assert(ldmState->window.nextSrc >= (BYTE const*)src + srcSize);
; 446  :     /* The input could be very large (in zstdmt), so it must be broken up into
; 447  :      * chunks to enforce the maximum distance and handle overflow correction.
; 448  :      */
; 449  :     assert(sequences->pos <= sequences->size);
; 450  :     assert(sequences->size <= sequences->capacity);
; 451  :     for (chunk = 0; chunk < nbChunks && sequences->size < sequences->capacity; ++chunk) {

	mov	r12d, r15d
	add	rcx, rax
	mov	QWORD PTR nbChunks$1$[rsp], rcx
	je	$LN3@ZSTD_ldm_g
$LL4@ZSTD_ldm_g:
	mov	r14, QWORD PTR [rsi+16]
	cmp	r14, QWORD PTR [rsi+24]
	jae	$LN3@ZSTD_ldm_g

; 462  :         if (ZSTD_window_needOverflowCorrection(ldmState->window, chunkEnd)) {

	movups	xmm1, XMMWORD PTR [rbx]
	lea	rax, QWORD PTR [rdi+1048576]
	mov	rcx, rdx
	sub	rcx, rdi
	mov	r9, rdx
	cmp	rcx, 1048576				; 00100000H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	psrldq	xmm1, 8
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 456  :         size_t const chunkSize = chunkEnd - chunkStart;

	cmovae	r9, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 456  :         size_t const chunkSize = chunkEnd - chunkStart;

	mov	rbp, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	mov	ecx, r9d
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 456  :         size_t const chunkSize = chunkEnd - chunkStart;

	sub	rbp, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	sub	ecx, eax

; 758  :     return current > ZSTD_CURRENT_MAX;

	cmp	ecx, -536870912				; e0000000H
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 462  :         if (ZSTD_window_needOverflowCorrection(ldmState->window, chunkEnd)) {

	jbe	$LN50@ZSTD_ldm_g

; 463  :             U32 const ldmHSize = 1U << params->hashLog;

	mov	ecx, DWORD PTR [r8+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 799  :     U32 const correction = current - newCurrent;

	mov	r10d, edi
	sub	r10d, DWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 463  :             U32 const ldmHSize = 1U << params->hashLog;

	mov	edx, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 799  :     U32 const correction = current - newCurrent;

	sub	r10d, r13d
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 463  :             U32 const ldmHSize = 1U << params->hashLog;

	shl	edx, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 799  :     U32 const correction = current - newCurrent;

	dec	r10d

; 800  :     assert((maxDist & cycleMask) == 0);
; 801  :     assert(current > newCurrent);
; 802  :     /* Loose bound, should be around 1<<29 (see above) */
; 803  :     assert(correction > 1<<28);
; 804  : 
; 805  :     window->base += correction;

	mov	eax, r10d
	add	QWORD PTR [rbx+8], rax

; 806  :     window->dictBase += correction;

	add	QWORD PTR [rbx+16], rax

; 807  :     if (window->lowLimit <= correction) window->lowLimit = 1;
; 808  :     else window->lowLimit -= correction;

	mov	eax, DWORD PTR [rbx+28]
	sub	eax, r10d
	cmp	DWORD PTR [rbx+28], r10d
	cmovbe	eax, r11d

; 809  :     if (window->dictLimit <= correction) window->dictLimit = 1;

	mov	DWORD PTR [rbx+28], eax

; 810  :     else window->dictLimit -= correction;

	mov	eax, DWORD PTR [rbx+24]
	sub	eax, r10d
	cmp	DWORD PTR [rbx+24], r10d
	cmovbe	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 466  :             ZSTD_ldm_reduceTable(ldmState->hashTable, ldmHSize, correction);

	mov	DWORD PTR [rbx+24], eax
	mov	rax, QWORD PTR [rbx+32]

; 423  :     for (u = 0; u < size; u++) {

	test	edx, edx
	je	SHORT $LN24@ZSTD_ldm_g
	mov	r11d, edx
	npad	3
$LL25@ZSTD_ldm_g:
	mov	edx, DWORD PTR [rax]
	lea	rax, QWORD PTR [rax+8]
	sub	edx, r10d
	xor	ecx, ecx
	cmp	DWORD PTR [rax-8], r10d
	cmovae	ecx, edx
	mov	DWORD PTR [rax-8], ecx
	sub	r11, 1
	jne	SHORT $LL25@ZSTD_ldm_g
	mov	r8, QWORD PTR params$[rsp]
$LN24@ZSTD_ldm_g:

; 467  :             /* invalidate dictionaries on overflow correction */
; 468  :             ldmState->loadedDictEnd = 0;

	mov	DWORD PTR [rbx+40], 0
$LN50@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 854  :     U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);

	sub	r9d, DWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 484  :         ZSTD_window_enforceMaxDist(&ldmState->window, chunkEnd, maxDist, &ldmState->loadedDictEnd, NULL);

	lea	rcx, QWORD PTR [rbx+40]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 855  :     U32 const loadedDictEnd = (loadedDictEndPtr != NULL) ? *loadedDictEndPtr : 0;

	test	rcx, rcx
	je	SHORT $LN36@ZSTD_ldm_g
	mov	eax, DWORD PTR [rcx]
	jmp	SHORT $LN37@ZSTD_ldm_g
$LN36@ZSTD_ldm_g:
	xor	eax, eax
$LN37@ZSTD_ldm_g:

; 856  :     DEBUGLOG(5, "ZSTD_window_enforceMaxDist: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u",
; 857  :                 (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);
; 858  : 
; 859  :     /* - When there is no dictionary : loadedDictEnd == 0.
; 860  :          In which case, the test (blockEndIdx > maxDist) is merely to avoid
; 861  :          overflowing next operation `newLowLimit = blockEndIdx - maxDist`.
; 862  :        - When there is a standard dictionary :
; 863  :          Index referential is copied from the dictionary,
; 864  :          which means it starts from 0.
; 865  :          In which case, loadedDictEnd == dictSize,
; 866  :          and it makes sense to compare `blockEndIdx > maxDist + dictSize`
; 867  :          since `blockEndIdx` also starts from zero.
; 868  :        - When there is an attached dictionary :
; 869  :          loadedDictEnd is expressed within the referential of the context,
; 870  :          so it can be directly compared against blockEndIdx.
; 871  :     */
; 872  :     if (blockEndIdx > maxDist + loadedDictEnd) {

	add	eax, r13d
	cmp	r9d, eax
	jbe	SHORT $LN33@ZSTD_ldm_g

; 873  :         U32 const newLowLimit = blockEndIdx - maxDist;
; 874  :         if (window->lowLimit < newLowLimit) window->lowLimit = newLowLimit;

	mov	eax, DWORD PTR [rbx+28]
	sub	r9d, r13d
	cmp	eax, r9d
	jae	SHORT $LN31@ZSTD_ldm_g
	mov	DWORD PTR [rbx+28], r9d
	mov	eax, r9d
$LN31@ZSTD_ldm_g:

; 875  :         if (window->dictLimit < window->lowLimit) {

	cmp	DWORD PTR [rbx+24], eax
	jae	SHORT $LN32@ZSTD_ldm_g

; 876  :             DEBUGLOG(5, "Update dictLimit to match lowLimit, from %u to %u",
; 877  :                         (unsigned)window->dictLimit, (unsigned)window->lowLimit);
; 878  :             window->dictLimit = window->lowLimit;

	mov	DWORD PTR [rbx+24], eax
$LN32@ZSTD_ldm_g:

; 879  :         }
; 880  :         /* On reaching window size, dictionaries are invalidated */
; 881  :         if (loadedDictEndPtr) *loadedDictEndPtr = 0;

	test	rcx, rcx
	je	SHORT $LN33@ZSTD_ldm_g
	mov	DWORD PTR [rcx], 0
$LN33@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 486  :         newLeftoverSize = ZSTD_ldm_generateSequences_internal(

	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rbp
	mov	rdx, rsi
	mov	rcx, rbx
	call	ZSTD_ldm_generateSequences_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 488  :         if (ZSTD_isError(newLeftoverSize))

	ja	SHORT $LN1@ZSTD_ldm_g

; 489  :             return newLeftoverSize;
; 490  :         /* 4. We add the leftover literals from previous iterations to the first
; 491  :          *    newly generated sequence, or add the `newLeftoverSize` if none are
; 492  :          *    generated.
; 493  :          */
; 494  :         /* Prepend the leftover literals from the last call */
; 495  :         if (prevSize < sequences->size) {

	cmp	r14, QWORD PTR [rsi+16]
	jae	SHORT $LN7@ZSTD_ldm_g

; 496  :             sequences->seq[prevSize].litLength += (U32)leftoverSize;

	mov	rcx, QWORD PTR [rsi]
	lea	rdx, QWORD PTR [r14+r14*2]
	add	DWORD PTR [rcx+rdx*4+4], r15d

; 497  :             leftoverSize = newLeftoverSize;

	mov	r15, rax

; 498  :         } else {

	jmp	SHORT $LN2@ZSTD_ldm_g
$LN7@ZSTD_ldm_g:

; 499  :             assert(newLeftoverSize == chunkSize);
; 500  :             leftoverSize += chunkSize;

	add	r15, rbp
$LN2@ZSTD_ldm_g:

; 440  : 
; 441  :     assert(ZSTD_CHUNKSIZE_MAX >= kMaxChunkSize);
; 442  :     /* Check that ZSTD_window_update() has been called for this chunk prior
; 443  :      * to passing it to this function.
; 444  :      */
; 445  :     assert(ldmState->window.nextSrc >= (BYTE const*)src + srcSize);
; 446  :     /* The input could be very large (in zstdmt), so it must be broken up into
; 447  :      * chunks to enforce the maximum distance and handle overflow correction.
; 448  :      */
; 449  :     assert(sequences->pos <= sequences->size);
; 450  :     assert(sequences->size <= sequences->capacity);
; 451  :     for (chunk = 0; chunk < nbChunks && sequences->size < sequences->capacity; ++chunk) {

	mov	r8, QWORD PTR params$[rsp]
	inc	r12
	mov	rdx, QWORD PTR iend$1$[rsp]
	add	rdi, 1048576				; 00100000H
	mov	r11d, 1
	cmp	r12, QWORD PTR nbChunks$1$[rsp]
	jb	$LL4@ZSTD_ldm_g
$LN3@ZSTD_ldm_g:

; 501  :         }
; 502  :     }
; 503  :     return 0;

	xor	eax, eax
$LN1@ZSTD_ldm_g:

; 504  : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_ldm_generateSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
params$ = 8
cParams$ = 16
ZSTD_ldm_adjustParameters PROC

; 25   :     params->windowLog = cParams->windowLog;
; 26   :     ZSTD_STATIC_ASSERT(LDM_BUCKET_SIZE_LOG <= ZSTD_LDM_BUCKETSIZELOG_MAX);
; 27   :     DEBUGLOG(4, "ZSTD_ldm_adjustParameters");
; 28   :     if (!params->bucketSizeLog) params->bucketSizeLog = LDM_BUCKET_SIZE_LOG;

	mov	r9d, DWORD PTR [rcx+8]
	mov	r8, rcx
	mov	r10d, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+20], r10d
	test	r9d, r9d
	jne	SHORT $LN2@ZSTD_ldm_a
	mov	r9d, 3
	mov	DWORD PTR [rcx+8], r9d
$LN2@ZSTD_ldm_a:

; 29   :     if (!params->minMatchLength) params->minMatchLength = LDM_MIN_MATCH_LENGTH;

	mov	ecx, DWORD PTR [rcx+12]
	test	ecx, ecx
	jne	SHORT $LN3@ZSTD_ldm_a
	mov	ecx, 64					; 00000040H
	mov	DWORD PTR [r8+12], ecx
$LN3@ZSTD_ldm_a:

; 30   :     if (cParams->strategy >= ZSTD_btopt) {

	cmp	DWORD PTR [rdx+24], 7
	jl	SHORT $LN4@ZSTD_ldm_a

; 31   :       /* Get out of the way of the optimal parser */
; 32   :       U32 const minMatch = MAX(cParams->targetLength, params->minMatchLength);

	mov	eax, DWORD PTR [rdx+20]

; 33   :       assert(minMatch >= ZSTD_LDM_MINMATCH_MIN);
; 34   :       assert(minMatch <= ZSTD_LDM_MINMATCH_MAX);
; 35   :       params->minMatchLength = minMatch;

	cmp	eax, ecx
	cmovbe	eax, ecx
	mov	DWORD PTR [r8+12], eax
$LN4@ZSTD_ldm_a:

; 36   :     }
; 37   :     if (params->hashLog == 0) {

	mov	edx, DWORD PTR [r8+4]
	test	edx, edx
	jne	SHORT $LN5@ZSTD_ldm_a

; 38   :         params->hashLog = MAX(ZSTD_HASHLOG_MIN, params->windowLog - LDM_HASH_RLOG);

	lea	edx, DWORD PTR [r10-7]
	mov	eax, 6
	cmp	edx, eax
	cmovb	edx, eax
	mov	DWORD PTR [r8+4], edx
$LN5@ZSTD_ldm_a:

; 39   :         assert(params->hashLog <= ZSTD_HASHLOG_MAX);
; 40   :     }
; 41   :     if (params->hashRateLog == 0) {

	cmp	DWORD PTR [r8+16], 0
	jne	SHORT $LN6@ZSTD_ldm_a

; 42   :         params->hashRateLog = params->windowLog < params->hashLog

	xor	eax, eax
	mov	ecx, r10d
	sub	ecx, edx
	cmp	r10d, edx
	cmovae	eax, ecx
	mov	DWORD PTR [r8+16], eax
$LN6@ZSTD_ldm_a:

; 43   :                                    ? 0
; 44   :                                    : params->windowLog - params->hashLog;
; 45   :     }
; 46   :     params->bucketSizeLog = MIN(params->bucketSizeLog, params->hashLog);

	cmp	r9d, edx
	cmovae	r9d, edx
	mov	DWORD PTR [r8+8], r9d

; 47   : }

	ret	0
ZSTD_ldm_adjustParameters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
params$ = 8
ZSTD_ldm_getTableSize PROC

; 51   :     size_t const ldmHSize = ((size_t)1) << params.hashLog;
; 52   :     size_t const ldmBucketSizeLog = MIN(params.bucketSizeLog, params.hashLog);

	mov	edx, DWORD PTR [rcx+8]
	mov	r10, rcx
	mov	r9d, DWORD PTR [rcx+4]

; 53   :     size_t const ldmBucketSize = ((size_t)1) << (params.hashLog - ldmBucketSizeLog);

	mov	r8d, 1
	cmp	edx, r9d
	movzx	ecx, r9b
	cmovae	edx, r9d

; 54   :     size_t const totalSize = ZSTD_cwksp_alloc_size(ldmBucketSize)
; 55   :                            + ZSTD_cwksp_alloc_size(ldmHSize * sizeof(ldmEntry_t));
; 56   :     return params.enableLdm ? totalSize : 0;

	xor	eax, eax
	sub	cl, dl
	mov	edx, r8d
	shl	rdx, cl
	mov	ecx, r9d
	shl	r8, cl
	cmp	DWORD PTR [r10], eax
	lea	rcx, QWORD PTR [rdx+r8*8]
	cmovne	rax, rcx

; 57   : }

	ret	0
ZSTD_ldm_getTableSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
rawSeqStore$ = 8
srcSize$ = 16
minMatch$ = 24
ZSTD_ldm_skipSequences PROC

; 506  : void ZSTD_ldm_skipSequences(rawSeqStore_t* rawSeqStore, size_t srcSize, U32 const minMatch) {

	mov	r10d, r8d
	mov	r9, rcx

; 507  :     while (srcSize > 0 && rawSeqStore->pos < rawSeqStore->size) {

	test	rdx, rdx
	je	SHORT $LN6@ZSTD_ldm_s
	mov	rax, QWORD PTR [rcx+8]
	xor	r11d, r11d
$LL2@ZSTD_ldm_s:
	cmp	rax, QWORD PTR [r9+16]
	jae	SHORT $LN6@ZSTD_ldm_s

; 508  :         rawSeq* seq = rawSeqStore->seq + rawSeqStore->pos;

	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r9]
	lea	r8, QWORD PTR [rax+rcx*4]

; 509  :         if (srcSize <= seq->litLength) {

	mov	eax, DWORD PTR [rax+rcx*4+4]
	cmp	rdx, rax
	jbe	SHORT $LN10@ZSTD_ldm_s

; 512  :             return;
; 513  :         }
; 514  :         srcSize -= seq->litLength;
; 515  :         seq->litLength = 0;
; 516  :         if (srcSize < seq->matchLength) {

	mov	ecx, DWORD PTR [r8+8]
	sub	rdx, rax
	mov	DWORD PTR [r8+4], r11d
	cmp	rdx, rcx
	jb	SHORT $LN11@ZSTD_ldm_s

; 525  :             }
; 526  :             return;
; 527  :         }
; 528  :         srcSize -= seq->matchLength;
; 529  :         seq->matchLength = 0;

	mov	DWORD PTR [r8+8], r11d

; 530  :         rawSeqStore->pos++;

	inc	QWORD PTR [r9+8]
	mov	rax, QWORD PTR [r9+8]
	sub	rdx, rcx
	jne	SHORT $LL2@ZSTD_ldm_s

; 531  :     }
; 532  : }

	ret	0
$LN11@ZSTD_ldm_s:

; 517  :             /* Skip past the first srcSize of the match */
; 518  :             seq->matchLength -= (U32)srcSize;

	sub	ecx, edx
	mov	DWORD PTR [r8+8], ecx

; 519  :             if (seq->matchLength < minMatch) {

	cmp	ecx, r10d
	jae	SHORT $LN6@ZSTD_ldm_s

; 520  :                 /* The match is too short, omit it */
; 521  :                 if (rawSeqStore->pos + 1 < rawSeqStore->size) {

	mov	rdx, QWORD PTR [r9+8]
	lea	rax, QWORD PTR [rdx+1]
	cmp	rax, QWORD PTR [r9+16]
	jae	SHORT $LN7@ZSTD_ldm_s

; 522  :                     seq[1].litLength += seq[0].matchLength;

	add	DWORD PTR [r8+16], ecx
	mov	rdx, QWORD PTR [r9+8]
$LN7@ZSTD_ldm_s:

; 523  :                 }
; 524  :                 rawSeqStore->pos++;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [r9+8], rax

; 531  :     }
; 532  : }

	ret	0
$LN10@ZSTD_ldm_s:

; 510  :             /* Skip past srcSize literals */
; 511  :             seq->litLength -= (U32)srcSize;

	sub	eax, edx
	mov	DWORD PTR [r8+4], eax
$LN6@ZSTD_ldm_s:

; 531  :     }
; 532  : }

	ret	0
ZSTD_ldm_skipSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_64bits PROC

; 184  : MEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }

	mov	eax, 1
	ret	0
MEM_64bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readST PROC

; 254  :     size_t val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 255  : }

	ret	0
MEM_readST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy8 PROC

; 231  : #ifdef __aarch64__
; 232  :     vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));
; 233  : #else
; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 235  : #endif
; 236  : }

	ret	0
ZSTD_copy8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy16 PROC

; 240  : #ifdef __aarch64__
; 241  :     vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));
; 242  : #else
; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 244  : #endif
; 245  : }

	ret	0
ZSTD_copy16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
length$ = 24
ovtype$dead$ = 32
ZSTD_wildcopy PROC

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;
; 268  :     const BYTE* ip = (const BYTE*)src;
; 269  :     BYTE* op = (BYTE*)dst;
; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [rcx+r8]
	sub	rdx, rcx
	npad	9
$LL7@ZSTD_wildc:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {
; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)
; 278  :         } while (op < oend);
; 279  :     } else {
; 280  :         assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);
; 281  :         /* Separate out the first COPY16() call because the copy length is
; 282  :          * almost certain to be short, so the branches have different
; 283  :          * probabilities. Since it is almost certain to be short, only do
; 284  :          * one COPY16() in the first call. Then, do two calls per loop since
; 285  :          * at that point it is more likely to have a high trip count.
; 286  :          */
; 287  : #ifndef __aarch64__
; 288  :         do {
; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL7@ZSTD_wildc

; 292  : #else
; 293  :         COPY16(op, ip);
; 294  :         if (op >= oend) return;
; 295  :         do {
; 296  :             COPY16(op, ip);
; 297  :             COPY16(op, ip);
; 298  :         }
; 299  :         while (op < oend);
; 300  : #endif
; 301  :     }
; 302  : }

	ret	0
ZSTD_wildcopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
size$ = 8
ZSTD_cwksp_alloc_size PROC

; 181  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 182  :     return size + 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 183  : #else
; 184  :     return size;

	mov	rax, rcx

; 185  : #endif
; 186  : }

	ret	0
ZSTD_cwksp_alloc_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
op$ = 8
ip$ = 16
iend$ = 24
ilimit_w$ = 32
ZSTD_safecopyLiterals PROC

; 423  :     assert(iend > ilimit_w);
; 424  :     if (ip <= ilimit_w) {

	cmp	rdx, r9
	ja	SHORT $LN19@ZSTD_safec
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r10, rcx
	sub	r10, rdx
	add	r10, r9
	sub	rdx, rcx
	npad	15
$LL12@ZSTD_safec:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL12@ZSTD_safec
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	mov	rdx, r9
$LN19@ZSTD_safec:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdx, r8
	jae	SHORT $LN3@ZSTD_safec
	npad	5
$LL21@ZSTD_safec:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	cmp	rdx, r8
	jb	SHORT $LL21@ZSTD_safec
$LN3@ZSTD_safec:

; 430  : }

	ret	0
ZSTD_safecopyLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
seqStorePtr$ = 8
litLength$ = 16
literals$ = 24
litLimit$ = 32
offCode$ = 40
mlBase$ = 48
ZSTD_storeSeq PROC

; 440  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	r10, rcx

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rcx, QWORD PTR [rdx+r8]
	mov	r11, rdx
	mov	r9, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	rcx, rbx
	ja	SHORT $LN2@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r9], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	SHORT $LN24@ZSTD_store

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rdx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r8, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	3
$LL16@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]

; 289  :             COPY16(op, ip);

	lea	r8, QWORD PTR [r8+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL16@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN24@ZSTD_store
$LN2@ZSTD_store:

; 424  :     if (ip <= ilimit_w) {

	cmp	r8, rbx
	ja	SHORT $LN41@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, r9
	sub	rdx, r8
	add	rdx, rbx
	sub	r8, r9
	npad	9
$LL33@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+r9]
	movups	XMMWORD PTR [r9], xmm0

; 289  :             COPY16(op, ip);

	add	r9, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	r9, rdx
	jb	SHORT $LL33@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	r9, rdx
	mov	r8, rbx
$LN41@ZSTD_store:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r8, rcx
	jae	SHORT $LN24@ZSTD_store
	sub	r9, r8
$LL43@ZSTD_store:
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r9+r8], al
	inc	r8
	cmp	r8, rcx
	jb	SHORT $LL43@ZSTD_store
$LN24@ZSTD_store:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);
; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], r11
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r11, 65535				; 0000ffffH
	jbe	SHORT $LN48@ZSTD_store

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN48@ZSTD_store:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;
; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;
; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	mov	rdx, QWORD PTR mlBase$[rsp]
	mov	WORD PTR [rcx+4], r11w
	mov	ecx, DWORD PTR offCode$[rsp]
	mov	rax, QWORD PTR [r10+8]
	inc	ecx
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r10+8]
	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN53@ZSTD_store

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 2
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN53@ZSTD_store:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;
; 488  : 
; 489  :     seqStorePtr->sequences++;
; 490  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	WORD PTR [rcx+6], dx
	add	QWORD PTR [r10+8], 8
	ret	0
ZSTD_storeSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
val$ = 8
r$1 = 16
ZSTD_NbCommonBytes PROC

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN9@ZSTD_NbCom
	shr	eax, 3

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
$LN9@ZSTD_NbCom:

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
ZSTD_NbCommonBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
r$1 = 8
r$2 = 8
pIn$ = 8
pMatch$ = 16
pInLimit$ = 24
ZSTD_count PROC

; 563  :     const BYTE* const pStart = pIn;
; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r9, QWORD PTR [r8-7]
	mov	r10, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN5@ZSTD_count

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN20@ZSTD_count
	shr	eax, 3

; 580  : }

	ret	0
$LN20@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 580  : }

	ret	0
$LN5@ZSTD_count:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count
$LL2@ZSTD_count:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN6@ZSTD_count
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r9
	jb	SHORT $LL2@ZSTD_count
$LN3@ZSTD_count:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r8-3]
	cmp	rcx, rax
	jae	SHORT $LN7@ZSTD_count
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN7@ZSTD_count
	add	rcx, 4
	add	rdx, 4
$LN7@ZSTD_count:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r8-1]
	cmp	rcx, rax
	jae	SHORT $LN8@ZSTD_count
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN8@ZSTD_count
	add	rcx, 2
	add	rdx, 2
$LN8@ZSTD_count:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r8
	jae	SHORT $LN9@ZSTD_count
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN9@ZSTD_count
	inc	rcx
$LN9@ZSTD_count:

; 579  :     return (size_t)(pIn - pStart);

	sub	rcx, r10
	mov	rax, rcx

; 580  : }

	ret	0
$LN6@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN36@ZSTD_count
	shr	edx, 3

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
$LN36@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
ZSTD_count ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ip$ = 48
match$ = 56
iEnd$ = 64
mEnd$ = 72
iStart$ = 80
ZSTD_count_2segments PROC

; 589  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r10, rcx
	mov	rsi, r8
	sub	r10, rdx
	mov	rbx, r9
	add	r10, r9
	mov	r11, rdx
	cmp	r10, r8
	mov	rbp, rcx
	cmovb	r8, r10

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	call	ZSTD_count
	mov	rdi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	jne	SHORT $LN1@ZSTD_count

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR iStart$[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	mov	r8, rsi
	call	ZSTD_count
	add	rax, rdi
$LN1@ZSTD_count:

; 599  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_count_2segments ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
hash$dead$ = 8
buf$ = 16
size$ = 24
ZSTD_rollingHash_append PROC

; 662  : {

	xor	eax, eax

; 663  :     BYTE const* istart = (BYTE const*)buf;

	mov	r9d, eax

; 664  :     size_t pos;
; 665  :     for (pos = 0; pos < size; ++pos) {

	test	r8, r8
	je	SHORT $LN12@ZSTD_rolli
	mov	r10, -3523014627327384477		; cf1bbcdcb7a56463H
	npad	12
$LL8@ZSTD_rolli:

; 666  :         hash *= prime8bytes;
; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	ecx, BYTE PTR [r9+rdx]
	inc	r9
	imul	rax, r10
	add	rax, 10
	add	rax, rcx
	cmp	r9, r8
	jb	SHORT $LL8@ZSTD_rolli
$LN12@ZSTD_rolli:

; 668  :     }
; 669  :     return hash;
; 670  : }

	ret	0
ZSTD_rollingHash_append ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
buf$ = 8
size$ = 16
ZSTD_rollingHash_compute PROC

; 677  :     return ZSTD_rollingHash_append(0, buf, size);

	xor	eax, eax
	mov	r9d, eax

; 665  :     for (pos = 0; pos < size; ++pos) {

	test	rdx, rdx
	je	SHORT $LN14@ZSTD_rolli
	mov	r10, -3523014627327384477		; cf1bbcdcb7a56463H
	npad	12
$LL10@ZSTD_rolli:

; 666  :         hash *= prime8bytes;
; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	r8d, BYTE PTR [r9+rcx]
	inc	r9
	imul	rax, r10
	add	rax, 10
	add	rax, r8
	cmp	r9, rdx
	jb	SHORT $LL10@ZSTD_rolli
$LN14@ZSTD_rolli:

; 678  : }

	ret	0
ZSTD_rollingHash_compute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
hash$ = 8
toRemove$ = 16
toAdd$ = 24
primePower$ = 32
ZSTD_rollingHash_rotate PROC

; 694  :     hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;
; 695  :     hash *= prime8bytes;
; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	movzx	edx, dl
	add	edx, 10
	imul	rdx, r9
	sub	rcx, rdx
	imul	rcx, rax
	movzx	eax, r8b
	add	eax, 10
	add	rax, rcx

; 697  :     return hash;
; 698  : }

	ret	0
ZSTD_rollingHash_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
ZSTD_window_hasExtDict PROC

; 732  :     return window.lowLimit < window.dictLimit;

	mov	edx, DWORD PTR [rcx+24]
	xor	eax, eax
	cmp	DWORD PTR [rcx+28], edx
	setb	al

; 733  : }

	ret	0
ZSTD_window_hasExtDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 48
ZSTD_matchState_dictMode PROC

; 741  : {

	sub	rsp, 40					; 00000028H

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	movups	xmm1, XMMWORD PTR [rcx+16]

; 732  :     return window.lowLimit < window.dictLimit;

	psrldq	xmm1, 8
	movq	rdx, xmm1
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	cmp	eax, edx

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	jae	SHORT $LN3@ZSTD_match
	mov	eax, 1

; 743  :         ZSTD_extDict :
; 744  :         ms->dictMatchState != NULL ?
; 745  :             ZSTD_dictMatchState :
; 746  :             ZSTD_noDict;
; 747  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@ZSTD_match:

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	mov	rax, QWORD PTR [rcx+176]
	neg	rax
	sbb	eax, eax
	and	eax, 2

; 743  :         ZSTD_extDict :
; 744  :         ms->dictMatchState != NULL ?
; 745  :             ZSTD_dictMatchState :
; 746  :             ZSTD_noDict;
; 747  : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_matchState_dictMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
srcEnd$ = 16
ZSTD_window_needOverflowCorrection PROC

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	sub	edx, DWORD PTR [rcx+8]

; 758  :     return current > ZSTD_CURRENT_MAX;

	xor	eax, eax
	cmp	edx, -536870912				; e0000000H
	seta	al

; 759  : }

	ret	0
ZSTD_window_needOverflowCorrection ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
cycleLog$dead$ = 16
maxDist$ = 24
src$ = 32
ZSTD_window_correctOverflow PROC

; 774  :     /* preemptive overflow correction:
; 775  :      * 1. correction is large enough:
; 776  :      *    lowLimit > (3<<29) ==> current > 3<<29 + 1<<windowLog
; 777  :      *    1<<windowLog <= newCurrent < 1<<chainLog + 1<<windowLog
; 778  :      *
; 779  :      *    current - newCurrent
; 780  :      *    > (3<<29 + 1<<windowLog) - (1<<windowLog + 1<<chainLog)
; 781  :      *    > (3<<29) - (1<<chainLog)
; 782  :      *    > (3<<29) - (1<<30)             (NOTE: chainLog <= 30)
; 783  :      *    > 1<<29
; 784  :      *
; 785  :      * 2. (ip+ZSTD_CHUNKSIZE_MAX - cctx->base) doesn't overflow:
; 786  :      *    After correction, current is less than (1<<chainLog + 1<<windowLog).
; 787  :      *    In 64-bit mode we are safe, because we have 64-bit ptrdiff_t.
; 788  :      *    In 32-bit mode we are safe, because (chainLog <= 29), so
; 789  :      *    ip+ZSTD_CHUNKSIZE_MAX - cctx->base < 1<<32.
; 790  :      * 3. (cctx->lowLimit + 1<<windowLog) < 1<<32:
; 791  :      *    windowLog <= 31 ==> 3<<29 + 1<<windowLog < 7<<29 < 1<<32.
; 792  :      */
; 793  :     U32 const cycleMask = (1U << cycleLog) - 1;
; 794  :     U32 const current = (U32)((BYTE const*)src - window->base);
; 795  :     U32 const currentCycle0 = current & cycleMask;
; 796  :     /* Exclude zero so that newCurrent - maxDist >= 1. */
; 797  :     U32 const currentCycle1 = currentCycle0 == 0 ? (1U << cycleLog) : currentCycle0;
; 798  :     U32 const newCurrent = currentCycle1 + maxDist;
; 799  :     U32 const correction = current - newCurrent;

	sub	r9d, r8d

; 800  :     assert((maxDist & cycleMask) == 0);
; 801  :     assert(current > newCurrent);
; 802  :     /* Loose bound, should be around 1<<29 (see above) */
; 803  :     assert(correction > 1<<28);
; 804  : 
; 805  :     window->base += correction;
; 806  :     window->dictBase += correction;
; 807  :     if (window->lowLimit <= correction) window->lowLimit = 1;

	mov	r8d, 1
	sub	r9d, DWORD PTR [rcx+8]
	dec	r9d
	mov	eax, r9d
	add	QWORD PTR [rcx+8], rax
	add	QWORD PTR [rcx+16], rax

; 808  :     else window->lowLimit -= correction;

	mov	eax, DWORD PTR [rcx+28]
	sub	eax, r9d
	cmp	DWORD PTR [rcx+28], r9d
	cmovbe	eax, r8d

; 809  :     if (window->dictLimit <= correction) window->dictLimit = 1;

	mov	DWORD PTR [rcx+28], eax

; 810  :     else window->dictLimit -= correction;

	mov	eax, DWORD PTR [rcx+24]
	sub	eax, r9d
	cmp	DWORD PTR [rcx+24], r9d
	cmovbe	eax, r8d

; 811  : 
; 812  :     /* Ensure we can still reference the full window. */
; 813  :     assert(newCurrent >= maxDist);
; 814  :     assert(newCurrent - maxDist >= 1);
; 815  :     /* Ensure that lowLimit and dictLimit didn't underflow. */
; 816  :     assert(window->lowLimit <= newCurrent);
; 817  :     assert(window->dictLimit <= newCurrent);
; 818  : 
; 819  :     DEBUGLOG(4, "Correction of 0x%x bytes to lowLimit=0x%x", correction,
; 820  :              window->lowLimit);
; 821  :     return correction;

	mov	DWORD PTR [rcx+24], eax
	mov	eax, r9d

; 822  : }

	ret	0
ZSTD_window_correctOverflow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
blockEnd$ = 16
maxDist$ = 24
loadedDictEndPtr$ = 32
dictMatchStatePtr$dead$ = 40
ZSTD_window_enforceMaxDist PROC

; 854  :     U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);

	sub	edx, DWORD PTR [rcx+8]

; 855  :     U32 const loadedDictEnd = (loadedDictEndPtr != NULL) ? *loadedDictEndPtr : 0;

	test	r9, r9
	je	SHORT $LN8@ZSTD_windo
	mov	eax, DWORD PTR [r9]
	jmp	SHORT $LN9@ZSTD_windo
$LN8@ZSTD_windo:
	xor	eax, eax
$LN9@ZSTD_windo:

; 856  :     DEBUGLOG(5, "ZSTD_window_enforceMaxDist: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u",
; 857  :                 (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);
; 858  : 
; 859  :     /* - When there is no dictionary : loadedDictEnd == 0.
; 860  :          In which case, the test (blockEndIdx > maxDist) is merely to avoid
; 861  :          overflowing next operation `newLowLimit = blockEndIdx - maxDist`.
; 862  :        - When there is a standard dictionary :
; 863  :          Index referential is copied from the dictionary,
; 864  :          which means it starts from 0.
; 865  :          In which case, loadedDictEnd == dictSize,
; 866  :          and it makes sense to compare `blockEndIdx > maxDist + dictSize`
; 867  :          since `blockEndIdx` also starts from zero.
; 868  :        - When there is an attached dictionary :
; 869  :          loadedDictEnd is expressed within the referential of the context,
; 870  :          so it can be directly compared against blockEndIdx.
; 871  :     */
; 872  :     if (blockEndIdx > maxDist + loadedDictEnd) {

	add	eax, r8d
	cmp	edx, eax
	jbe	SHORT $LN6@ZSTD_windo

; 873  :         U32 const newLowLimit = blockEndIdx - maxDist;
; 874  :         if (window->lowLimit < newLowLimit) window->lowLimit = newLowLimit;

	mov	eax, DWORD PTR [rcx+28]
	sub	edx, r8d
	cmp	eax, edx
	jae	SHORT $LN3@ZSTD_windo
	mov	DWORD PTR [rcx+28], edx
	mov	eax, edx
$LN3@ZSTD_windo:

; 875  :         if (window->dictLimit < window->lowLimit) {

	cmp	DWORD PTR [rcx+24], eax
	jae	SHORT $LN4@ZSTD_windo

; 876  :             DEBUGLOG(5, "Update dictLimit to match lowLimit, from %u to %u",
; 877  :                         (unsigned)window->dictLimit, (unsigned)window->lowLimit);
; 878  :             window->dictLimit = window->lowLimit;

	mov	DWORD PTR [rcx+24], eax
$LN4@ZSTD_windo:

; 879  :         }
; 880  :         /* On reaching window size, dictionaries are invalidated */
; 881  :         if (loadedDictEndPtr) *loadedDictEndPtr = 0;

	test	r9, r9
	je	SHORT $LN6@ZSTD_windo
	mov	DWORD PTR [r9], 0
$LN6@ZSTD_windo:

; 882  :         if (dictMatchStatePtr) *dictMatchStatePtr = NULL;
; 883  :     }
; 884  : }

	ret	0
ZSTD_window_enforceMaxDist ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
value$ = 8
numBits$ = 16
ZSTD_ldm_getSmallHash PROC

; 69   : {

	mov	r8, rcx

; 70   :     assert(numBits <= 32);
; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	test	edx, edx
	jne	SHORT $LN3@ZSTD_ldm_g
	xor	eax, eax

; 72   : }

	ret	0
$LN3@ZSTD_ldm_g:

; 70   :     assert(numBits <= 32);
; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	r8, cl
	mov	eax, r8d

; 72   : }

	ret	0
ZSTD_ldm_getSmallHash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
hash$ = 8
numBitsToDiscard$ = 16
ZSTD_ldm_getChecksum PROC

; 78   : {

	mov	rax, rcx

; 79   :     assert(numBitsToDiscard <= 32);
; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	rax, cl

; 81   : }

	ret	0
ZSTD_ldm_getChecksum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
hash$ = 8
hbits$ = 16
numTagBits$ = 24
ZSTD_ldm_getTag PROC

; 91   :     assert(numTagBits < 32 && hbits <= 32);
; 92   :     if (32 - hbits < numTagBits) {

	mov	r10d, 32				; 00000020H
	mov	r9, rcx
	sub	r10d, edx
	mov	ecx, r8d
	mov	edx, 1
	shl	edx, cl
	dec	edx
	mov	eax, edx
	cmp	r10d, r8d
	jae	SHORT $LN2@ZSTD_ldm_g

; 93   :         return hash & (((U32)1 << numTagBits) - 1);

	and	eax, r9d

; 96   :     }
; 97   : }

	ret	0
$LN2@ZSTD_ldm_g:

; 94   :     } else {
; 95   :         return (hash >> (32 - hbits - numTagBits)) & (((U32)1 << numTagBits) - 1);

	sub	r10d, r8d
	movzx	ecx, r10b
	shr	r9, cl
	and	r9d, edx
	mov	eax, r9d

; 96   :     }
; 97   : }

	ret	0
ZSTD_ldm_getTag ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
ldmState$ = 8
hash$ = 16
ldmParams$ = 24
ZSTD_ldm_getBucket PROC

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	mov	rax, QWORD PTR [rcx+32]
	mov	ecx, DWORD PTR [r8+8]
	shl	rdx, cl
	lea	rax, QWORD PTR [rax+rdx*8]

; 105  : }

	ret	0
ZSTD_ldm_getBucket ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
ldmState$ = 48
hash$ = 56
entry$ = 64
ldmParams$ = 72
ZSTD_ldm_insertEntry PROC

; 112  : {

	sub	rsp, 40					; 00000028H

; 113  :     BYTE* const bucketOffsets = ldmState->bucketOffsets;

	mov	r11, QWORD PTR [rcx+48]
	mov	r10, rcx

; 114  :     *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + bucketOffsets[hash]) = entry;

	movaps	xmm1, XMMWORD PTR [r9]
	add	r11, rdx

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	psrldq	xmm1, 8
	movd	ecx, xmm1

; 114  :     *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + bucketOffsets[hash]) = entry;

	movzx	eax, BYTE PTR [r11]

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	shl	rdx, cl

; 115  :     bucketOffsets[hash]++;
; 116  :     bucketOffsets[hash] &= ((U32)1 << ldmParams.bucketSizeLog) - 1;

	mov	ecx, DWORD PTR [r9+8]
	add	rdx, rax
	mov	rax, QWORD PTR [r10+32]
	mov	QWORD PTR [rax+rdx*8], r8
	mov	edx, 1
	movzx	eax, BYTE PTR [r11]
	shl	dl, cl
	inc	al
	dec	dl
	and	dl, al
	mov	BYTE PTR [r11], dl

; 117  : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_ldm_insertEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
ldmState$ = 48
rollingHash$ = 56
hBits$ = 64
offset$ = 72
entry$1 = 80
ldmParams$ = 80
ZSTD_ldm_makeEntryAndInsertByTag PROC

; 134  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 135  :     U32 const tag = ZSTD_ldm_getTag(rollingHash, hBits, ldmParams.hashRateLog);

	mov	rsi, QWORD PTR ldmParams$[rsp]
	mov	r14d, r9d

; 92   :     if (32 - hbits < numTagBits) {

	mov	edi, 1

; 134  : {

	mov	rbp, rcx

; 92   :     if (32 - hbits < numTagBits) {

	mov	r10d, 32				; 00000020H
	mov	r9d, edi
	mov	ebx, r10d

; 134  : {

	mov	r11, rdx

; 135  :     U32 const tag = ZSTD_ldm_getTag(rollingHash, hBits, ldmParams.hashRateLog);

	mov	ecx, DWORD PTR [rsi+16]

; 92   :     if (32 - hbits < numTagBits) {

	sub	ebx, r8d
	shl	r9d, cl
	dec	r9d
	cmp	ebx, ecx
	jb	SHORT $LN6@ZSTD_ldm_m

; 93   :         return hash & (((U32)1 << numTagBits) - 1);
; 94   :     } else {
; 95   :         return (hash >> (32 - hbits - numTagBits)) & (((U32)1 << numTagBits) - 1);

	sub	r10d, ecx
	sub	r10d, r8d
	movzx	ecx, r10b
	shr	rdx, cl
$LN6@ZSTD_ldm_m:

; 136  :     U32 const tagMask = ((U32)1 << ldmParams.hashRateLog) - 1;

	mov	eax, r9d
	and	eax, edx

; 137  :     if (tag == tagMask) {

	cmp	eax, r9d
	jne	SHORT $LN14@ZSTD_ldm_m

; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	test	r8d, r8d
	jne	SHORT $LN10@ZSTD_ldm_m
	xor	edx, edx
	jmp	SHORT $LN11@ZSTD_ldm_m
$LN10@ZSTD_ldm_m:
	mov	ecx, 64					; 00000040H
	mov	rdx, r11
	sub	ecx, r8d
	shr	rdx, cl
$LN11@ZSTD_ldm_m:

; 113  :     BYTE* const bucketOffsets = ldmState->bucketOffsets;

	mov	r8, QWORD PTR [rbp+48]

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	mov	ecx, ebx

; 143  :         ZSTD_ldm_insertEntry(ldmState, hash, entry, ldmParams);

	movaps	xmm2, XMMWORD PTR [rsi]

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	shr	r11, cl

; 114  :     *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + bucketOffsets[hash]) = entry;

	movaps	xmm1, xmm2

; 143  :         ZSTD_ldm_insertEntry(ldmState, hash, entry, ldmParams);

	mov	edx, edx

; 114  :     *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + bucketOffsets[hash]) = entry;

	add	r8, rdx

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	psrldq	xmm1, 8
	movd	ecx, xmm1

; 138  :         U32 const hash = ZSTD_ldm_getSmallHash(rollingHash, hBits);
; 139  :         U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);
; 140  :         ldmEntry_t entry;
; 141  :         entry.offset = offset;

	mov	DWORD PTR entry$1[rsp], r14d

; 142  :         entry.checksum = checksum;

	mov	DWORD PTR entry$1[rsp+4], r11d

; 114  :     *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + bucketOffsets[hash]) = entry;

	movzx	eax, BYTE PTR [r8]

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	shl	rdx, cl

; 114  :     *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + bucketOffsets[hash]) = entry;

	mov	rcx, QWORD PTR [rbp+32]
	add	rdx, rax
	mov	rax, QWORD PTR entry$1[rsp]

; 115  :     bucketOffsets[hash]++;
; 116  :     bucketOffsets[hash] &= ((U32)1 << ldmParams.bucketSizeLog) - 1;

	psrldq	xmm2, 8
	mov	QWORD PTR [rcx+rdx*8], rax
	movzx	eax, BYTE PTR [r8]
	movd	ecx, xmm2
	inc	al
	shl	dil, cl
	dec	dil
	and	dil, al
	mov	BYTE PTR [r8], dil
$LN14@ZSTD_ldm_m:

; 144  :     }
; 145  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
ZSTD_ldm_makeEntryAndInsertByTag ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
pIn$ = 8
pAnchor$ = 16
pMatch$ = 24
pBase$ = 32
ZSTD_ldm_countBackwardsMatch PROC

; 155  :     size_t matchLength = 0;

	xor	eax, eax
	mov	r10, r9

; 156  :     while (pIn > pAnchor && pMatch > pBase && pIn[-1] == pMatch[-1]) {

	cmp	rcx, rdx
	jbe	SHORT $LN9@ZSTD_ldm_c
	npad	6
$LL2@ZSTD_ldm_c:
	cmp	r8, r10
	jbe	SHORT $LN9@ZSTD_ldm_c
	dec	r8
	lea	r9, QWORD PTR [rcx-1]
	movzx	ecx, BYTE PTR [r8]
	cmp	BYTE PTR [r9], cl
	jne	SHORT $LN9@ZSTD_ldm_c

; 157  :         pIn--;
; 158  :         pMatch--;
; 159  :         matchLength++;

	inc	rax
	mov	rcx, r9
	cmp	r9, rdx
	ja	SHORT $LL2@ZSTD_ldm_c
$LN9@ZSTD_ldm_c:

; 160  :     }
; 161  :     return matchLength;
; 162  : }

	ret	0
ZSTD_ldm_countBackwardsMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
ms$ = 48
end$ = 56
ZSTD_ldm_fillFastTables PROC

; 173  : {

	sub	rsp, 40					; 00000028H

; 174  :     const BYTE* const iend = (const BYTE*)end;
; 175  : 
; 176  :     switch(ms->cParams.strategy)

	mov	r8d, DWORD PTR [rcx+208]
	sub	r8d, 1
	je	SHORT $LN4@ZSTD_ldm_f
	cmp	r8d, 1
	jne	SHORT $LN10@ZSTD_ldm_f

; 180  :         break;
; 181  : 
; 182  :     case ZSTD_dfast:
; 183  :         ZSTD_fillDoubleHashTable(ms, iend, ZSTD_dtlm_fast);

	xor	r8d, r8d
	call	ZSTD_fillDoubleHashTable

; 184  :         break;
; 185  : 
; 186  :     case ZSTD_greedy:
; 187  :     case ZSTD_lazy:
; 188  :     case ZSTD_lazy2:
; 189  :     case ZSTD_btlazy2:
; 190  :     case ZSTD_btopt:
; 191  :     case ZSTD_btultra:
; 192  :     case ZSTD_btultra2:
; 193  :         break;
; 194  :     default:
; 195  :         assert(0);  /* not possible : not a valid strategy id */
; 196  :     }
; 197  : 
; 198  :     return 0;
; 199  : }

	xor	eax, eax
	add	rsp, 40					; 00000028H
	ret	0
$LN4@ZSTD_ldm_f:

; 177  :     {
; 178  :     case ZSTD_fast:
; 179  :         ZSTD_fillHashTable(ms, iend, ZSTD_dtlm_fast);

	xor	r8d, r8d
	call	ZSTD_fillHashTable
$LN10@ZSTD_ldm_f:

; 184  :         break;
; 185  : 
; 186  :     case ZSTD_greedy:
; 187  :     case ZSTD_lazy:
; 188  :     case ZSTD_lazy2:
; 189  :     case ZSTD_btlazy2:
; 190  :     case ZSTD_btopt:
; 191  :     case ZSTD_btultra:
; 192  :     case ZSTD_btultra2:
; 193  :         break;
; 194  :     default:
; 195  :         assert(0);  /* not possible : not a valid strategy id */
; 196  :     }
; 197  : 
; 198  :     return 0;
; 199  : }

	xor	eax, eax
	add	rsp, 40					; 00000028H
	ret	0
ZSTD_ldm_fillFastTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
$T1 = 48
state$ = 128
lastHash$ = 136
lastHashed$ = 144
iend$ = 152
base$ = 160
hBits$ = 168
ldmParams$ = 176
ZSTD_ldm_fillLdmHashTable PROC

; 211  : {

	mov	rax, rsp
	push	rbx
	push	rbp
	push	rdi
	push	r14
	sub	rsp, 88					; 00000058H

; 212  :     U64 rollingHash = lastHash;
; 213  :     const BYTE* cur = lastHashed + 1;

	lea	rdi, QWORD PTR [r8+1]
	mov	rbp, r9
	mov	rbx, rdx
	mov	r14, rcx

; 214  : 
; 215  :     while (cur < iend) {

	cmp	rdi, r9
	jae	$LN11@ZSTD_ldm_f
	mov	QWORD PTR [rax+8], rsi
	mov	rsi, QWORD PTR ldmParams$[rsp]
	mov	QWORD PTR [rax+16], r12
	mov	r12, QWORD PTR base$[rsp]
	mov	QWORD PTR [rax+24], r13
	mov	r13, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	QWORD PTR [rax-40], r15
	mov	r15d, DWORD PTR hBits$[rsp]
	npad	12
$LL2@ZSTD_ldm_f:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 694  :     hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;

	movzx	eax, BYTE PTR [rdi-1]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 219  :         ZSTD_ldm_makeEntryAndInsertByTag(state,

	mov	r9d, edi
	movaps	xmm0, XMMWORD PTR [rsi]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 694  :     hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;

	add	rax, 10

; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	imul	rax, QWORD PTR [r14+56]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 219  :         ZSTD_ldm_makeEntryAndInsertByTag(state,

	movsd	xmm1, QWORD PTR [rsi+16]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	sub	r9d, r12d
	mov	r8d, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	sub	rbx, rax
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 216  :         rollingHash = ZSTD_rollingHash_rotate(rollingHash, cur[-1],

	mov	eax, DWORD PTR [rsi+12]
	dec	eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	imul	rbx, r13
	movzx	ecx, BYTE PTR [rax+rdi]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 219  :         ZSTD_ldm_makeEntryAndInsertByTag(state,

	lea	rax, QWORD PTR $T1[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	add	rcx, 10
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 219  :         ZSTD_ldm_makeEntryAndInsertByTag(state,

	mov	QWORD PTR [rsp+32], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	add	rbx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 219  :         ZSTD_ldm_makeEntryAndInsertByTag(state,

	mov	rcx, r14
	mov	rdx, rbx
	call	ZSTD_ldm_makeEntryAndInsertByTag

; 220  :                                          rollingHash, hBits,
; 221  :                                          (U32)(cur - base), ldmParams);
; 222  :         ++cur;

	inc	rdi
	cmp	rdi, rbp
	jb	SHORT $LL2@ZSTD_ldm_f

; 223  :     }
; 224  :     return rollingHash;

	mov	r15, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
$LN11@ZSTD_ldm_f:

; 225  : }

	mov	rax, rbx
	add	rsp, 88					; 00000058H
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_ldm_fillLdmHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
ms$ = 8
anchor$ = 16
ZSTD_ldm_limitTableUpdate PROC

; 249  :     U32 const current = (U32)(anchor - ms->window.base);
; 250  :     if (current > ms->nextToUpdate + 1024) {

	mov	r8d, DWORD PTR [rcx+36]
	sub	edx, DWORD PTR [rcx+8]
	lea	eax, DWORD PTR [r8+1024]
	cmp	edx, eax
	jbe	SHORT $LN2@ZSTD_ldm_l

; 251  :         ms->nextToUpdate =

	mov	eax, edx
	sub	eax, r8d
	mov	r8d, 512				; 00000200H
	add	eax, -1024				; fffffc00H
	cmp	eax, r8d
	cmova	eax, r8d
	sub	edx, eax
	mov	DWORD PTR [rcx+36], edx
$LN2@ZSTD_ldm_l:

; 252  :             current - MIN(512, current - ms->nextToUpdate - 1024);
; 253  :     }
; 254  : }

	ret	0
ZSTD_ldm_limitTableUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
hBits$1$ = 64
hashRateLog$1$ = 68
lowestIndex$1$ = 72
offset$1$ = 76
tv1559 = 80
tv1617 = 88
bestEntry$1$ = 96
backwardMatchLength$1$ = 104
forwardMatchLength$1$ = 112
lowPrefixPtr$1$ = 120
ldmTagMask$1$ = 128
tv1552 = 132
ldmBucketSize$1$ = 136
tv1556 = 140
dictLimit$1$ = 144
r$1 = 148
r$2 = 148
rollingHash$1$ = 152
base$1$ = 160
tv1548 = 168
dictBase$1$ = 176
dictEnd$1$ = 184
dictStart$1$ = 192
bestMatchLength$1$ = 200
tv1550 = 208
lastHashed$1$ = 216
ilimit$1$ = 224
hashPower$1$ = 232
$T3 = 240
$T4 = 272
$T5 = 304
$T6 = 336
ldmState$ = 448
rawSeqStore$ = 456
params$ = 464
src$ = 472
tv1677 = 480
srcSize$ = 480
ZSTD_ldm_generateSequences_internal PROC

; 259  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], r9
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 376				; 00000178H

; 261  :     int const extDict = ZSTD_window_hasExtDict(ldmState->window);

	movups	xmm1, XMMWORD PTR [rcx+16]
	mov	rdi, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	xor	r12d, r12d
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 261  :     int const extDict = ZSTD_window_hasExtDict(ldmState->window);

	movups	xmm0, XMMWORD PTR [rcx]
	mov	r8, rcx
	mov	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	mov	ebx, r12d
	psrldq	xmm1, 8
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 264  :     U32 const hBits = params->hashLog - params->bucketSizeLog;

	mov	r9d, DWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	movq	r11, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 262  :     U32 const minMatchLength = params->minMatchLength;

	mov	edx, DWORD PTR [rdi+12]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	mov	r10, r11
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 261  :     int const extDict = ZSTD_window_hasExtDict(ldmState->window);

	movaps	XMMWORD PTR [rax-104], xmm0

; 263  :     U64 const hashPower = ldmState->hashPower;

	mov	rax, QWORD PTR [rcx+56]

; 264  :     U32 const hBits = params->hashLog - params->bucketSizeLog;

	mov	ecx, DWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	shr	r10, 32					; 00000020H
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 263  :     U64 const hashPower = ldmState->hashPower;

	mov	QWORD PTR hashPower$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	cmp	r10d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 265  :     U32 const ldmBucketSize = 1U << params->bucketSizeLog;

	mov	eax, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	setb	bl
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 265  :     U32 const ldmBucketSize = 1U << params->bucketSizeLog;

	mov	ebp, eax
	sub	r9d, ecx
	shl	ebp, cl

; 266  :     U32 const hashRateLog = params->hashRateLog;

	mov	ecx, DWORD PTR [rdi+16]

; 267  :     U32 const ldmTagMask = (1U << params->hashRateLog) - 1;

	shl	eax, cl
	dec	eax
	mov	DWORD PTR hashRateLog$1$[rsp], ecx

; 268  :     /* Prefix and extDict parameters */
; 269  :     U32 const dictLimit = ldmState->window.dictLimit;

	mov	ecx, DWORD PTR [r8+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 732  :     return window.lowLimit < window.dictLimit;

	mov	DWORD PTR tv1556[rsp], ebx
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 264  :     U32 const hBits = params->hashLog - params->bucketSizeLog;

	mov	DWORD PTR hBits$1$[rsp], r9d

; 265  :     U32 const ldmBucketSize = 1U << params->bucketSizeLog;

	mov	DWORD PTR ldmBucketSize$1$[rsp], ebp

; 267  :     U32 const ldmTagMask = (1U << params->hashRateLog) - 1;

	mov	DWORD PTR ldmTagMask$1$[rsp], eax

; 268  :     /* Prefix and extDict parameters */
; 269  :     U32 const dictLimit = ldmState->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rsp], ecx

; 270  :     U32 const lowestIndex = extDict ? ldmState->window.lowLimit : dictLimit;

	cmp	r10d, r11d
	jae	SHORT $LN21@ZSTD_ldm_g
	mov	eax, DWORD PTR [r8+28]
	jmp	SHORT $LN146@ZSTD_ldm_g
$LN21@ZSTD_ldm_g:
	mov	eax, ecx
$LN146@ZSTD_ldm_g:

; 271  :     BYTE const* const base = ldmState->window.base;

	mov	rbp, QWORD PTR [r8+8]
	mov	QWORD PTR base$1$[rsp], rbp
	mov	DWORD PTR lowestIndex$1$[rsp], eax

; 272  :     BYTE const* const dictBase = extDict ? ldmState->window.dictBase : NULL;

	test	ebx, ebx
	je	SHORT $LN23@ZSTD_ldm_g
	mov	r8, QWORD PTR [r8+16]

; 273  :     BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;

	mov	r11d, eax
	add	r11, r8
	mov	QWORD PTR dictBase$1$[rsp], r8

; 274  :     BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;

	add	r8, rcx
	mov	QWORD PTR dictStart$1$[rsp], r11
	mov	QWORD PTR dictEnd$1$[rsp], r8
	jmp	SHORT $LN147@ZSTD_ldm_g
$LN23@ZSTD_ldm_g:

; 272  :     BYTE const* const dictBase = extDict ? ldmState->window.dictBase : NULL;

	mov	QWORD PTR dictBase$1$[rsp], r12

; 273  :     BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;

	mov	QWORD PTR dictStart$1$[rsp], r12

; 274  :     BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;

	mov	QWORD PTR dictEnd$1$[rsp], r12
$LN147@ZSTD_ldm_g:

; 275  :     BYTE const* const lowPrefixPtr = base + dictLimit;
; 276  :     /* Input bounds */
; 277  :     BYTE const* const istart = (BYTE const*)src;
; 278  :     BYTE const* const iend = istart + srcSize;

	mov	r13, QWORD PTR srcSize$[rsp]
	lea	r10, QWORD PTR [rcx+rbp]
	mov	rax, rcx
	mov	QWORD PTR lowPrefixPtr$1$[rsp], r10
	add	r13, rsi

; 279  :     BYTE const* const ilimit = iend - MAX(minMatchLength, HASH_READ_SIZE);

	mov	eax, 8
	cmp	edx, eax
	mov	rcx, r13

; 280  :     /* Input positions */
; 281  :     BYTE const* anchor = istart;

	mov	r14, rsi

; 282  :     BYTE const* ip = istart;
; 283  :     /* Rolling hash */
; 284  :     BYTE const* lastHashed = NULL;

	mov	r15, r12
	cmova	eax, edx
	sub	rcx, rax
	mov	QWORD PTR ilimit$1$[rsp], rcx

; 285  :     U64 rollingHash = 0;
; 286  : 
; 287  :     while (ip <= ilimit) {

	cmp	QWORD PTR src$[rsp], rcx
	ja	$LN139@ZSTD_ldm_g

; 95   :         return (hash >> (32 - hbits - numTagBits)) & (((U32)1 << numTagBits) - 1);

	mov	eax, 32					; 00000020H
	mov	QWORD PTR tv1548[rsp], rdx
	mov	ecx, eax

; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	mov	r8d, 64					; 00000040H

; 95   :         return (hash >> (32 - hbits - numTagBits)) & (((U32)1 << numTagBits) - 1);

	sub	ecx, DWORD PTR hashRateLog$1$[rsp]

; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	sub	r8d, r9d

; 95   :         return (hash >> (32 - hbits - numTagBits)) & (((U32)1 << numTagBits) - 1);

	sub	ecx, r9d

; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	mov	DWORD PTR tv1552[rsp], r8d

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	sub	eax, r9d

; 95   :         return (hash >> (32 - hbits - numTagBits)) & (((U32)1 << numTagBits) - 1);

	mov	DWORD PTR tv1559[rsp], ecx
	mov	r11, rdx

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	mov	DWORD PTR tv1677[rsp], eax
	mov	edx, eax
	npad	10
$LL2@ZSTD_ldm_g:

; 288  :         size_t mLength;
; 289  :         U32 const current = (U32)(ip - base);
; 290  :         size_t forwardMatchLength = 0, backwardMatchLength = 0;

	xor	ebx, ebx
	xor	r9d, r9d

; 291  :         ldmEntry_t* bestEntry = NULL;

	xor	r8d, r8d
	mov	QWORD PTR forwardMatchLength$1$[rsp], rbx
	mov	eax, esi
	mov	QWORD PTR backwardMatchLength$1$[rsp], r9
	sub	eax, ebp
	mov	QWORD PTR bestEntry$1$[rsp], r8
	mov	DWORD PTR offset$1$[rsp], eax

; 292  :         if (ip != istart) {

	cmp	rsi, QWORD PTR src$[rsp]
	je	SHORT $LN7@ZSTD_ldm_g
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 694  :     hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;

	movzx	eax, BYTE PTR [r15]
	add	rax, 10

; 695  :     hash *= prime8bytes;
; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	imul	rax, QWORD PTR hashPower$1$[rsp]
	sub	r12, rax
	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	r12, rax
	movzx	eax, BYTE PTR [r11+r15]
	add	r12, 10
	add	r12, rax
	mov	QWORD PTR rollingHash$1$[rsp], r12
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 296  :         } else {

	jmp	SHORT $LN8@ZSTD_ldm_g
$LN7@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 677  :     return ZSTD_rollingHash_append(0, buf, size);

	xor	r12d, r12d
	xor	ecx, ecx
	mov	QWORD PTR rollingHash$1$[rsp], r12

; 665  :     for (pos = 0; pos < size; ++pos) {

	test	r11, r11
	je	SHORT $LN37@ZSTD_ldm_g
	mov	r15, -3523014627327384477		; cf1bbcdcb7a56463H
	npad	3
$LL123@ZSTD_ldm_g:

; 666  :         hash *= prime8bytes;
; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	eax, BYTE PTR [rcx+rsi]
	inc	rcx
	imul	r12, r15
	add	r12, 10
	add	r12, rax
	cmp	rcx, r11
	jb	SHORT $LL123@ZSTD_ldm_g
	mov	QWORD PTR rollingHash$1$[rsp], r12
$LN37@ZSTD_ldm_g:
	mov	ecx, DWORD PTR tv1559[rsp]
$LN8@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 302  :         if (ZSTD_ldm_getTag(rollingHash, hBits, hashRateLog) != ldmTagMask) {

	mov	rax, r12
	mov	QWORD PTR lastHashed$1$[rsp], rsi
	shr	rax, cl
	mov	r15, rsi
	cmp	edx, DWORD PTR hashRateLog$1$[rsp]
	mov	ecx, r12d
	cmovae	ecx, eax
	and	ecx, DWORD PTR ldmTagMask$1$[rsp]
	cmp	ecx, DWORD PTR ldmTagMask$1$[rsp]
	jne	$LN148@ZSTD_ldm_g

; 303  :            ip++;
; 304  :            continue;
; 305  :         }
; 306  : 
; 307  :         /* Get the best entry and compute the match lengths */
; 308  :         {
; 309  :             ldmEntry_t* const bucket =

	movups	xmm0, XMMWORD PTR [rdi]
	movaps	XMMWORD PTR $T3[rsp], xmm0

; 71   :     return numBits == 0 ? 0 : (U32)(value >> (64 - numBits));

	cmp	DWORD PTR hBits$1$[rsp], ebx
	jne	SHORT $LN46@ZSTD_ldm_g
	xor	eax, eax
	jmp	SHORT $LN47@ZSTD_ldm_g
$LN46@ZSTD_ldm_g:
	mov	ecx, DWORD PTR tv1552[rsp]
	mov	rax, r12
	shr	rax, cl
$LN47@ZSTD_ldm_g:

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	mov	ecx, DWORD PTR $T3[rsp+8]

; 303  :            ip++;
; 304  :            continue;
; 305  :         }
; 306  : 
; 307  :         /* Get the best entry and compute the match lengths */
; 308  :         {
; 309  :             ldmEntry_t* const bucket =

	mov	edx, eax

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	mov	rax, QWORD PTR ldmState$[rsp]
	shl	rdx, cl

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	mov	ecx, DWORD PTR tv1677[rsp]

; 104  :     return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);

	mov	rax, QWORD PTR [rax+32]
	lea	r15, QWORD PTR [rax+rdx*8]

; 310  :                 ZSTD_ldm_getBucket(ldmState,
; 311  :                                    ZSTD_ldm_getSmallHash(rollingHash, hBits),
; 312  :                                    *params);
; 313  :             ldmEntry_t* cur;
; 314  :             size_t bestMatchLength = 0;

	xor	eax, eax
	mov	QWORD PTR bestMatchLength$1$[rsp], rax

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	mov	rdx, r12

; 315  :             U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);
; 316  : 
; 317  :             for (cur = bucket; cur < bucket + ldmBucketSize; ++cur) {

	mov	eax, DWORD PTR ldmBucketSize$1$[rsp]

; 80   :     return (hash >> (64 - 32 - numBitsToDiscard)) & 0xFFFFFFFF;

	shr	rdx, cl
	mov	QWORD PTR tv1617[rsp], rdx

; 315  :             U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);
; 316  : 
; 317  :             for (cur = bucket; cur < bucket + ldmBucketSize; ++cur) {

	lea	rdi, QWORD PTR [r15+rax*8]
	mov	QWORD PTR tv1550[rsp], rdi
	cmp	r15, rdi
	jae	$LN138@ZSTD_ldm_g
	mov	r12, QWORD PTR base$1$[rsp]
$LL6@ZSTD_ldm_g:

; 318  :                 size_t curForwardMatchLength, curBackwardMatchLength,
; 319  :                        curTotalMatchLength;
; 320  :                 if (cur->checksum != checksum || cur->offset <= lowestIndex) {

	cmp	DWORD PTR [r15+4], edx
	jne	$LN4@ZSTD_ldm_g
	mov	eax, DWORD PTR [r15]
	cmp	eax, DWORD PTR lowestIndex$1$[rsp]
	jbe	$LN4@ZSTD_ldm_g

; 321  :                     continue;
; 322  :                 }
; 323  :                 if (extDict) {

	cmp	DWORD PTR tv1556[rsp], 0
	je	$LN12@ZSTD_ldm_g

; 324  :                     BYTE const* const curMatchBase =

	cmp	eax, DWORD PTR dictLimit$1$[rsp]

; 328  :                         cur->offset < dictLimit ? dictEnd : iend;
; 329  :                     BYTE const* const lowMatchPtr =

	mov	rbp, r10
	mov	rdi, r12
	mov	r11, r13
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 326  :                     BYTE const* const pMatch = curMatchBase + cur->offset;

	add	rdi, rax

; 327  :                     BYTE const* const matchEnd =

	cmp	eax, DWORD PTR dictLimit$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 327  :                     BYTE const* const matchEnd =

	cmovb	r11, QWORD PTR dictEnd$1$[rsp]

; 328  :                         cur->offset < dictLimit ? dictEnd : iend;
; 329  :                     BYTE const* const lowMatchPtr =

	cmovb	rbp, QWORD PTR dictStart$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r11
	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, r13
	cmovb	r8, rcx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rcx, rsi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, r11
	jne	SHORT $LN52@ZSTD_ldm_g

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR lowPrefixPtr$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	mov	r8, r13
	call	ZSTD_count
	add	rbx, rax
$LN52@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 335  :                     if (curForwardMatchLength < minMatchLength) {

	mov	r11, QWORD PTR tv1548[rsp]
	cmp	rbx, r11
	jb	$LN144@ZSTD_ldm_g

; 155  :     size_t matchLength = 0;

	xor	edx, edx

; 156  :     while (pIn > pAnchor && pMatch > pBase && pIn[-1] == pMatch[-1]) {

	cmp	rsi, r14
	jbe	SHORT $LN140@ZSTD_ldm_g

; 336  :                         continue;
; 337  :                     }
; 338  :                     curBackwardMatchLength =

	mov	r8, rsi
	lea	rcx, QWORD PTR [rdi-1]
	sub	r8, rdi
	npad	7
$LL58@ZSTD_ldm_g:

; 156  :     while (pIn > pAnchor && pMatch > pBase && pIn[-1] == pMatch[-1]) {

	lea	rax, QWORD PTR [rcx+1]
	cmp	rax, rbp
	jbe	SHORT $LN140@ZSTD_ldm_g
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rcx+r8], al
	jne	SHORT $LN140@ZSTD_ldm_g

; 157  :         pIn--;
; 158  :         pMatch--;

	dec	rcx

; 159  :         matchLength++;

	inc	rdx
	lea	rax, QWORD PTR [rcx+1]
	add	rax, r8
	cmp	rax, r14
	ja	SHORT $LL58@ZSTD_ldm_g
$LN140@ZSTD_ldm_g:

; 339  :                         ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,
; 340  :                                                      lowMatchPtr);
; 341  :                     curTotalMatchLength = curForwardMatchLength +
; 342  :                                           curBackwardMatchLength;
; 343  :                 } else { /* !extDict */

	mov	rdi, QWORD PTR tv1550[rsp]
	jmp	$LN141@ZSTD_ldm_g
$LN12@ZSTD_ldm_g:

; 344  :                     BYTE const* const pMatch = base + cur->offset;

	lea	r9, QWORD PTR [rax+r12]

; 345  :                     curForwardMatchLength = ZSTD_count(ip, pMatch, iend);

	mov	rax, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [r13-7]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 345  :                     curForwardMatchLength = ZSTD_count(ip, pMatch, iend);

	mov	rdx, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rsi, r8
	jae	SHORT $LN63@ZSTD_ldm_g

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [r9]
	xor	rax, QWORD PTR [rsi]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN65@ZSTD_ldm_g

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN80@ZSTD_ldm_g
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ebx, eax
	jmp	SHORT $LN61@ZSTD_ldm_g
$LN80@ZSTD_ldm_g:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ebx, eax
	jmp	SHORT $LN61@ZSTD_ldm_g
$LN65@ZSTD_ldm_g:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	lea	rax, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [r9+8]

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN63@ZSTD_ldm_g
	npad	9
$LL62@ZSTD_ldm_g:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN66@ZSTD_ldm_g
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL62@ZSTD_ldm_g
$LN63@ZSTD_ldm_g:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r13-3]
	cmp	rax, rcx
	jae	SHORT $LN67@ZSTD_ldm_g
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN67@ZSTD_ldm_g
	add	rax, 4
	add	rdx, 4
$LN67@ZSTD_ldm_g:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r13-1]
	cmp	rax, rcx
	jae	SHORT $LN68@ZSTD_ldm_g
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN68@ZSTD_ldm_g
	add	rax, 2
	add	rdx, 2
$LN68@ZSTD_ldm_g:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r13
	jae	SHORT $LN69@ZSTD_ldm_g
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN69@ZSTD_ldm_g
	inc	rax
$LN69@ZSTD_ldm_g:

; 579  :     return (size_t)(pIn - pStart);

	mov	rbx, rax
	sub	rbx, rsi
$LN61@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 346  :                     if (curForwardMatchLength < minMatchLength) {

	cmp	rbx, r11
	jb	$LN142@ZSTD_ldm_g

; 155  :     size_t matchLength = 0;

	xor	edx, edx

; 156  :     while (pIn > pAnchor && pMatch > pBase && pIn[-1] == pMatch[-1]) {

	cmp	rsi, r14
	jbe	SHORT $LN141@ZSTD_ldm_g

; 347  :                         continue;
; 348  :                     }
; 349  :                     curBackwardMatchLength =

	mov	r8, rsi
	lea	rcx, QWORD PTR [r9-1]
	sub	r8, r9
	npad	8
$LL105@ZSTD_ldm_g:

; 156  :     while (pIn > pAnchor && pMatch > pBase && pIn[-1] == pMatch[-1]) {

	lea	rax, QWORD PTR [rcx+1]
	cmp	rax, r10
	jbe	SHORT $LN141@ZSTD_ldm_g
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rcx+r8], al
	jne	SHORT $LN141@ZSTD_ldm_g

; 157  :         pIn--;
; 158  :         pMatch--;

	dec	rcx

; 159  :         matchLength++;

	inc	rdx
	lea	rax, QWORD PTR [rcx+1]
	add	rax, r8
	cmp	rax, r14
	ja	SHORT $LL105@ZSTD_ldm_g
$LN141@ZSTD_ldm_g:

; 350  :                         ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,
; 351  :                                                      lowPrefixPtr);
; 352  :                     curTotalMatchLength = curForwardMatchLength +
; 353  :                                           curBackwardMatchLength;
; 354  :                 }
; 355  : 
; 356  :                 if (curTotalMatchLength > bestMatchLength) {

	lea	rax, QWORD PTR [rdx+rbx]
	cmp	rax, QWORD PTR bestMatchLength$1$[rsp]
	jbe	SHORT $LN142@ZSTD_ldm_g

; 357  :                     bestMatchLength = curTotalMatchLength;

	mov	QWORD PTR bestMatchLength$1$[rsp], rax

; 358  :                     forwardMatchLength = curForwardMatchLength;
; 359  :                     backwardMatchLength = curBackwardMatchLength;

	mov	r9, rdx
	mov	QWORD PTR forwardMatchLength$1$[rsp], rbx

; 360  :                     bestEntry = cur;

	mov	r8, r15
	mov	QWORD PTR backwardMatchLength$1$[rsp], rdx
	mov	QWORD PTR bestEntry$1$[rsp], r15
	jmp	SHORT $LN149@ZSTD_ldm_g
$LN66@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN96@ZSTD_ldm_g
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ebx, edx
	sub	rbx, rsi
	add	rbx, rax
	jmp	$LN61@ZSTD_ldm_g
$LN96@ZSTD_ldm_g:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	ebx, edx
	sub	rbx, rsi
	add	rbx, rax
	jmp	$LN61@ZSTD_ldm_g
$LN144@ZSTD_ldm_g:
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 335  :                     if (curForwardMatchLength < minMatchLength) {

	mov	rdi, QWORD PTR tv1550[rsp]
$LN142@ZSTD_ldm_g:

; 315  :             U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);
; 316  : 
; 317  :             for (cur = bucket; cur < bucket + ldmBucketSize; ++cur) {

	mov	r8, QWORD PTR bestEntry$1$[rsp]
	mov	r9, QWORD PTR backwardMatchLength$1$[rsp]
	mov	rbx, QWORD PTR forwardMatchLength$1$[rsp]
$LN149@ZSTD_ldm_g:
	mov	rdx, QWORD PTR tv1617[rsp]
$LN4@ZSTD_ldm_g:
	mov	r10, QWORD PTR lowPrefixPtr$1$[rsp]
	add	r15, 8
	cmp	r15, rdi
	jb	$LL6@ZSTD_ldm_g

; 361  :                 }
; 362  :             }
; 363  :         }
; 364  : 
; 365  :         /* No match found -- continue searching */
; 366  :         if (bestEntry == NULL) {

	mov	r12, QWORD PTR rollingHash$1$[rsp]
	test	r8, r8
	je	$LN145@ZSTD_ldm_g

; 368  :                                              hBits, current,
; 369  :                                              *params);
; 370  :             ip++;
; 371  :             continue;
; 372  :         }
; 373  : 
; 374  :         /* Match found */
; 375  :         mLength = forwardMatchLength + backwardMatchLength;

	add	rbx, r9

; 376  :         ip -= backwardMatchLength;

	sub	rsi, r9

; 377  : 
; 378  :         {
; 379  :             /* Store the sequence:
; 380  :              * ip = current - backwardMatchLength
; 381  :              * The match is at (bestEntry->offset - backwardMatchLength)
; 382  :              */
; 383  :             U32 const matchIndex = bestEntry->offset;
; 384  :             U32 const offset = current - matchIndex;

	mov	r9d, DWORD PTR offset$1$[rsp]
	sub	r9d, DWORD PTR [r8]

; 385  :             rawSeq* const seq = rawSeqStore->seq + rawSeqStore->size;

	mov	r8, QWORD PTR rawSeqStore$[rsp]
	mov	rax, QWORD PTR [r8+16]

; 386  : 
; 387  :             /* Out of sequence storage */
; 388  :             if (rawSeqStore->size == rawSeqStore->capacity)

	cmp	rax, QWORD PTR [r8+24]
	je	$LN116@ZSTD_ldm_g

; 390  :             seq->litLength = (U32)(ip - anchor);
; 391  :             seq->matchLength = (U32)mLength;
; 392  :             seq->offset = offset;
; 393  :             rawSeqStore->size++;
; 394  :         }
; 395  : 
; 396  :         /* Insert the current entry into the hash table */
; 397  :         ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash, hBits,

	mov	rdi, QWORD PTR params$[rsp]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r8]
	mov	r15, QWORD PTR lastHashed$1$[rsp]
	mov	rbp, QWORD PTR base$1$[rsp]
	mov	DWORD PTR [rax+rcx*4], r9d
	mov	r9d, r15d
	lea	rdx, QWORD PTR [rax+rcx*4]
	mov	eax, esi
	mov	DWORD PTR [rdx+8], ebx
	sub	eax, r14d
	mov	r14, QWORD PTR ldmState$[rsp]
	sub	r9d, ebp
	mov	DWORD PTR [rdx+4], eax
	mov	rcx, r14
	inc	QWORD PTR [r8+16]
	lea	rax, QWORD PTR $T4[rsp]
	movups	xmm0, XMMWORD PTR [rdi]
	mov	rdx, r12
	mov	r8d, DWORD PTR hBits$1$[rsp]
	movsd	xmm1, QWORD PTR [rdi+16]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movsd	QWORD PTR $T4[rsp+16], xmm1
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_ldm_makeEntryAndInsertByTag

; 398  :                                          (U32)(lastHashed - base),
; 399  :                                          *params);
; 400  : 
; 401  :         assert(ip + backwardMatchLength == lastHashed);
; 402  : 
; 403  :         /* Fill the hash table from lastHashed+1 to ip+mLength*/
; 404  :         /* Heuristic: don't need to fill the entire table at end of block */
; 405  :         if (ip + mLength <= ilimit) {

	add	rsi, rbx
	cmp	rsi, QWORD PTR ilimit$1$[rsp]
	ja	SHORT $LN131@ZSTD_ldm_g

; 406  :             rollingHash = ZSTD_ldm_fillLdmHashTable(

	movups	xmm0, XMMWORD PTR [rdi]
	lea	rax, QWORD PTR $T5[rsp]
	mov	r9, rsi
	movsd	xmm1, QWORD PTR [rdi+16]
	mov	r8, r15
	mov	QWORD PTR [rsp+48], rax
	mov	rdx, r12
	mov	eax, DWORD PTR hBits$1$[rsp]
	mov	rcx, r14
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rbp
	movaps	XMMWORD PTR $T5[rsp], xmm0
	movsd	QWORD PTR $T5[rsp+16], xmm1
	call	ZSTD_ldm_fillLdmHashTable
	mov	r12, rax

; 407  :                               ldmState, rollingHash, lastHashed,
; 408  :                               ip + mLength, base, hBits, *params);
; 409  :             lastHashed = ip + mLength - 1;

	lea	r15, QWORD PTR [rsi-1]
$LN131@ZSTD_ldm_g:

; 410  :         }
; 411  :         ip += mLength;
; 412  :         anchor = ip;

	mov	r10, QWORD PTR lowPrefixPtr$1$[rsp]
	mov	r14, rsi
	mov	r11, QWORD PTR tv1548[rsp]
	mov	edx, DWORD PTR tv1677[rsp]
	jmp	SHORT $LN122@ZSTD_ldm_g
$LN145@ZSTD_ldm_g:

; 361  :                 }
; 362  :             }
; 363  :         }
; 364  : 
; 365  :         /* No match found -- continue searching */
; 366  :         if (bestEntry == NULL) {

	mov	rbp, QWORD PTR base$1$[rsp]
$LN138@ZSTD_ldm_g:

; 367  :             ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash,

	mov	rdi, QWORD PTR params$[rsp]
	lea	rax, QWORD PTR $T6[rsp]
	mov	r9d, DWORD PTR offset$1$[rsp]
	mov	rdx, r12
	mov	r8d, DWORD PTR hBits$1$[rsp]
	mov	rcx, QWORD PTR ldmState$[rsp]
	movups	xmm0, XMMWORD PTR [rdi]
	mov	QWORD PTR [rsp+32], rax
	movsd	xmm1, QWORD PTR [rdi+16]
	movaps	XMMWORD PTR $T6[rsp], xmm0
	movsd	QWORD PTR $T6[rsp+16], xmm1
	call	ZSTD_ldm_makeEntryAndInsertByTag
	mov	r10, QWORD PTR lowPrefixPtr$1$[rsp]
	mov	r11, QWORD PTR tv1548[rsp]
	mov	edx, DWORD PTR tv1677[rsp]
	mov	r15, QWORD PTR lastHashed$1$[rsp]
$LN148@ZSTD_ldm_g:

; 285  :     U64 rollingHash = 0;
; 286  : 
; 287  :     while (ip <= ilimit) {

	inc	rsi
$LN122@ZSTD_ldm_g:
	cmp	rsi, QWORD PTR ilimit$1$[rsp]
	ja	SHORT $LN139@ZSTD_ldm_g
	mov	ecx, DWORD PTR tv1559[rsp]
	jmp	$LL2@ZSTD_ldm_g
$LN116@ZSTD_ldm_g:

; 389  :                 return ERROR(dstSize_tooSmall);

	mov	rax, -70				; ffffffffffffffbaH
	jmp	SHORT $LN1@ZSTD_ldm_g
$LN139@ZSTD_ldm_g:

; 413  :     }
; 414  :     return iend - anchor;

	sub	r13, r14
	mov	rax, r13
$LN1@ZSTD_ldm_g:

; 415  : }

	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_ldm_generateSequences_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
table$ = 8
size$ = 16
reducerValue$ = 24
ZSTD_ldm_reduceTable PROC

; 422  :     U32 u;
; 423  :     for (u = 0; u < size; u++) {

	test	edx, edx
	je	SHORT $LN3@ZSTD_ldm_r
	mov	r10d, edx
	npad	9
$LL4@ZSTD_ldm_r:
	mov	edx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+8]
	sub	edx, r8d
	xor	eax, eax
	cmp	DWORD PTR [rcx-8], r8d
	cmovae	eax, edx
	mov	DWORD PTR [rcx-8], eax
	sub	r10, 1
	jne	SHORT $LL4@ZSTD_ldm_r
$LN3@ZSTD_ldm_r:

; 424  :         if (table[u].offset < reducerValue) table[u].offset = 0;
; 425  :         else table[u].offset -= reducerValue;
; 426  :     }
; 427  : }

	ret	0
ZSTD_ldm_reduceTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
_TEXT	SEGMENT
$T1 = 48
rawSeqStore$ = 56
remaining$ = 64
minMatch$ = 72
maybeSplitSequence PROC

; 543  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 544  :     rawSeq sequence = rawSeqStore->seq[rawSeqStore->pos];

	mov	rax, QWORD PTR [rdx]
	mov	r11, rdx
	mov	rdi, QWORD PTR [rdx+8]
	mov	rbx, rcx
	lea	r10, QWORD PTR [rdi+rdi*2]
	movsd	xmm0, QWORD PTR [rax+r10*4]
	mov	eax, DWORD PTR [rax+r10*4+8]
	movsd	QWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+8], eax

; 545  :     assert(sequence.offset > 0);
; 546  :     /* Likely: No partial sequence */
; 547  :     if (remaining >= sequence.litLength + sequence.matchLength) {

	mov	edx, DWORD PTR [rcx+4]
	lea	ecx, DWORD PTR [rdx+rax]
	cmp	r8d, ecx
	jb	SHORT $LN2@maybeSplit

; 548  :         rawSeqStore->pos++;

	lea	rax, QWORD PTR [rdi+1]
	mov	QWORD PTR [r11+8], rax

; 562  :     return sequence;
; 563  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@maybeSplit:

; 549  :         return sequence;
; 550  :     }
; 551  :     /* Cut the sequence short (offset == 0 ==> rest is literals). */
; 552  :     if (remaining <= sequence.litLength) {

	cmp	r8d, edx
	jbe	SHORT $LN8@maybeSplit

; 553  :         sequence.offset = 0;
; 554  :     } else if (remaining < sequence.litLength + sequence.matchLength) {
; 555  :         sequence.matchLength = remaining - sequence.litLength;

	mov	eax, r8d
	sub	eax, edx
	mov	DWORD PTR [rbx+8], eax

; 556  :         if (sequence.matchLength < minMatch) {

	cmp	eax, r9d
	jae	SHORT $LN6@maybeSplit
$LN8@maybeSplit:

; 557  :             sequence.offset = 0;

	mov	DWORD PTR [rbx], 0
$LN6@maybeSplit:

; 558  :         }
; 559  :     }
; 560  :     /* Skip past `remaining` bytes for the future sequences. */
; 561  :     ZSTD_ldm_skipSequences(rawSeqStore, remaining, minMatch);

	mov	edx, r8d
	mov	rcx, r11
	mov	r8d, r9d
	call	ZSTD_ldm_skipSequences

; 562  :     return sequence;
; 563  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
maybeSplitSequence ENDP
_TEXT	ENDS
END
