; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_InitializeConditionVariable:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_WakeConditionVariable:PROC
EXTRN	__imp_WakeAllConditionVariable:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_SleepConditionVariableCS:PROC
ZSTD_defaultCMem DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
PUBLIC	POOL_tryAdd
PUBLIC	POOL_add
PUBLIC	POOL_resize
PUBLIC	POOL_free
PUBLIC	POOL_create_advanced
PUBLIC	POOL_create
pdata	SEGMENT
$pdata$POOL_tryAdd DD imagerel $LN15
	DD	imagerel $LN15+207
	DD	imagerel $unwind$POOL_tryAdd
$pdata$POOL_add DD imagerel $LN15
	DD	imagerel $LN15+192
	DD	imagerel $unwind$POOL_add
$pdata$POOL_resize DD imagerel $LN37
	DD	imagerel $LN37+36
	DD	imagerel $unwind$POOL_resize
$pdata$0$POOL_resize DD imagerel $LN37+36
	DD	imagerel $LN37+94
	DD	imagerel $chain$0$POOL_resize
$pdata$1$POOL_resize DD imagerel $LN37+94
	DD	imagerel $LN37+158
	DD	imagerel $chain$1$POOL_resize
$pdata$3$POOL_resize DD imagerel $LN37+158
	DD	imagerel $LN37+360
	DD	imagerel $chain$3$POOL_resize
$pdata$4$POOL_resize DD imagerel $LN37+360
	DD	imagerel $LN37+368
	DD	imagerel $chain$4$POOL_resize
$pdata$5$POOL_resize DD imagerel $LN37+368
	DD	imagerel $LN37+407
	DD	imagerel $chain$5$POOL_resize
$pdata$7$POOL_resize DD imagerel $LN37+407
	DD	imagerel $LN37+418
	DD	imagerel $chain$7$POOL_resize
$pdata$POOL_resize_internal DD imagerel POOL_resize_internal
	DD	imagerel POOL_resize_internal+119
	DD	imagerel $unwind$POOL_resize_internal
$pdata$2$POOL_resize_internal DD imagerel POOL_resize_internal+119
	DD	imagerel POOL_resize_internal+344
	DD	imagerel $chain$2$POOL_resize_internal
$pdata$4$POOL_resize_internal DD imagerel POOL_resize_internal+344
	DD	imagerel POOL_resize_internal+355
	DD	imagerel $chain$4$POOL_resize_internal
$pdata$POOL_free DD imagerel $LN40
	DD	imagerel $LN40+17
	DD	imagerel $unwind$POOL_free
$pdata$1$POOL_free DD imagerel $LN40+17
	DD	imagerel $LN40+91
	DD	imagerel $chain$1$POOL_free
$pdata$2$POOL_free DD imagerel $LN40+91
	DD	imagerel $LN40+165
	DD	imagerel $chain$2$POOL_free
$pdata$3$POOL_free DD imagerel $LN40+165
	DD	imagerel $LN40+213
	DD	imagerel $chain$3$POOL_free
$pdata$4$POOL_free DD imagerel $LN40+213
	DD	imagerel $LN40+357
	DD	imagerel $chain$4$POOL_free
$pdata$POOL_join DD imagerel POOL_join
	DD	imagerel POOL_join+77
	DD	imagerel $unwind$POOL_join
$pdata$0$POOL_join DD imagerel POOL_join+77
	DD	imagerel POOL_join+151
	DD	imagerel $chain$0$POOL_join
$pdata$1$POOL_join DD imagerel POOL_join+151
	DD	imagerel POOL_join+162
	DD	imagerel $chain$1$POOL_join
$pdata$POOL_create_advanced DD imagerel $LN37
	DD	imagerel $LN37+127
	DD	imagerel $unwind$POOL_create_advanced
$pdata$0$POOL_create_advanced DD imagerel $LN37+127
	DD	imagerel $LN37+316
	DD	imagerel $chain$0$POOL_create_advanced
$pdata$2$POOL_create_advanced DD imagerel $LN37+316
	DD	imagerel $LN37+450
	DD	imagerel $chain$2$POOL_create_advanced
$pdata$3$POOL_create_advanced DD imagerel $LN37+450
	DD	imagerel $LN37+472
	DD	imagerel $chain$3$POOL_create_advanced
$pdata$5$POOL_create_advanced DD imagerel $LN37+472
	DD	imagerel $LN37+488
	DD	imagerel $chain$5$POOL_create_advanced
$pdata$6$POOL_create_advanced DD imagerel $LN37+488
	DD	imagerel $LN37+500
	DD	imagerel $chain$6$POOL_create_advanced
$pdata$7$POOL_create_advanced DD imagerel $LN37+500
	DD	imagerel $LN37+519
	DD	imagerel $chain$7$POOL_create_advanced
$pdata$POOL_create DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$POOL_create
$pdata$POOL_thread DD imagerel POOL_thread
	DD	imagerel POOL_thread+286
	DD	imagerel $unwind$POOL_thread
xdata	SEGMENT
$unwind$POOL_tryAdd DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$POOL_add DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$POOL_resize DD 040901H
	DD	0f0059209H
	DD	030027003H
$chain$0$POOL_resize DD 020521H
	DD	0e5405H
	DD	imagerel $LN37
	DD	imagerel $LN37+36
	DD	imagerel $unwind$POOL_resize
$chain$1$POOL_resize DD 020821H
	DD	011e408H
	DD	imagerel $LN37+36
	DD	imagerel $LN37+94
	DD	imagerel $chain$0$POOL_resize
$chain$3$POOL_resize DD 045821H
	DD	010c458H
	DD	0f6405H
	DD	imagerel $LN37+94
	DD	imagerel $LN37+158
	DD	imagerel $chain$1$POOL_resize
$chain$4$POOL_resize DD 021H
	DD	imagerel $LN37+94
	DD	imagerel $LN37+158
	DD	imagerel $chain$1$POOL_resize
$chain$5$POOL_resize DD 021H
	DD	imagerel $LN37+36
	DD	imagerel $LN37+94
	DD	imagerel $chain$0$POOL_resize
$chain$7$POOL_resize DD 080021H
	DD	011e400H
	DD	010c400H
	DD	0f6400H
	DD	0e5400H
	DD	imagerel $LN37
	DD	imagerel $LN37+36
	DD	imagerel $unwind$POOL_resize
$unwind$POOL_resize_internal DD 040901H
	DD	0e0059209H
	DD	060027003H
$chain$2$POOL_resize_internal DD 065b21H
	DD	010f45bH
	DD	0f5453H
	DD	0e3405H
	DD	imagerel POOL_resize_internal
	DD	imagerel POOL_resize_internal+119
	DD	imagerel $unwind$POOL_resize_internal
$chain$4$POOL_resize_internal DD 060021H
	DD	010f400H
	DD	0f5400H
	DD	0e3400H
	DD	imagerel POOL_resize_internal
	DD	imagerel POOL_resize_internal+119
	DD	imagerel $unwind$POOL_resize_internal
$unwind$POOL_free DD 020e01H
	DD	0300a720eH
$chain$1$POOL_free DD 040e21H
	DD	0c740eH
	DD	0a5405H
	DD	imagerel $LN40
	DD	imagerel $LN40+17
	DD	imagerel $unwind$POOL_free
$chain$2$POOL_free DD 020521H
	DD	0b6405H
	DD	imagerel $LN40+17
	DD	imagerel $LN40+91
	DD	imagerel $chain$1$POOL_free
$chain$3$POOL_free DD 021H
	DD	imagerel $LN40+17
	DD	imagerel $LN40+91
	DD	imagerel $chain$1$POOL_free
$chain$4$POOL_free DD 021H
	DD	imagerel $LN40
	DD	imagerel $LN40+17
	DD	imagerel $unwind$POOL_free
$unwind$POOL_join DD 040a01H
	DD	0b340aH
	DD	06006720aH
$chain$0$POOL_join DD 020521H
	DD	0a7405H
	DD	imagerel POOL_join
	DD	imagerel POOL_join+77
	DD	imagerel $unwind$POOL_join
$chain$1$POOL_join DD 021H
	DD	imagerel POOL_join
	DD	imagerel POOL_join+77
	DD	imagerel $unwind$POOL_join
$unwind$POOL_create_advanced DD 060d01H
	DD	011340dH
	DD	0f009920dH
	DD	060067007H
$chain$0$POOL_create_advanced DD 020521H
	DD	0e5405H
	DD	imagerel $LN37
	DD	imagerel $LN37+127
	DD	imagerel $unwind$POOL_create_advanced
$chain$2$POOL_create_advanced DD 041021H
	DD	010e410H
	DD	0fc405H
	DD	imagerel $LN37+127
	DD	imagerel $LN37+316
	DD	imagerel $chain$0$POOL_create_advanced
$chain$3$POOL_create_advanced DD 021H
	DD	imagerel $LN37+127
	DD	imagerel $LN37+316
	DD	imagerel $chain$0$POOL_create_advanced
$chain$5$POOL_create_advanced DD 060021H
	DD	010e400H
	DD	0fc400H
	DD	0e5400H
	DD	imagerel $LN37
	DD	imagerel $LN37+127
	DD	imagerel $unwind$POOL_create_advanced
$chain$6$POOL_create_advanced DD 020021H
	DD	0e5400H
	DD	imagerel $LN37
	DD	imagerel $LN37+127
	DD	imagerel $unwind$POOL_create_advanced
$chain$7$POOL_create_advanced DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+127
	DD	imagerel $unwind$POOL_create_advanced
$unwind$POOL_create DD 010401H
	DD	08204H
$unwind$POOL_thread DD 062001H
	DD	086420H
	DD	09741bH
	DD	030025206H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
job$3$ = 32
opaque$ = 64
POOL_thread PROC

; 67   : static void* POOL_thread(void* opaque) {

	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 68   :     POOL_ctx* const ctx = (POOL_ctx*)opaque;
; 69   :     if (!ctx) { return NULL; }

	test	rcx, rcx
	jne	SHORT $LN19@POOL_threa
	xor	eax, eax

; 103  :         }
; 104  :     }  /* for (;;) */
; 105  :     assert(0);  /* Unreachable */
; 106  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN19@POOL_threa:
	mov	QWORD PTR [rsp+72], rdi
	mov	QWORD PTR [rsp+64], rsi
$LL2@POOL_threa:

; 70   :     for (;;) {
; 71   :         /* Lock the mutex and wait for a non-empty queue or until shutdown */
; 72   :         ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_EnterCriticalSection
	npad	6
$LL5@POOL_threa:

; 73   : 
; 74   :         while ( ctx->queueEmpty
; 75   :             || (ctx->numThreadsBusy >= ctx->threadLimit) ) {

	cmp	DWORD PTR [rbx+88], 0
	jne	SHORT $LN8@POOL_threa
	mov	r8, QWORD PTR [rbx+80]
	cmp	r8, QWORD PTR [rbx+40]
	jb	SHORT $LN6@POOL_threa
$LN8@POOL_threa:

; 76   :             if (ctx->shutdown) {

	cmp	DWORD PTR [rbx+152], 0
	jne	$LN16@POOL_threa

; 82   :             }
; 83   :             ZSTD_pthread_cond_wait(&ctx->queuePopCond, &ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+144]
	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_SleepConditionVariableCS

; 84   :         }

	jmp	SHORT $LL5@POOL_threa
$LN6@POOL_threa:

; 85   :         /* Pop a job off the queue */
; 86   :         {   POOL_job const job = ctx->queue[ctx->queueHead];

	mov	rdx, QWORD PTR [rbx+56]
	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, rdx
	add	rcx, rcx
	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 87   :             ctx->queueHead = (ctx->queueHead + 1) % ctx->queueSize;

	lea	rax, QWORD PTR [rdx+1]
	xor	edx, edx
	div	QWORD PTR [rbx+72]

; 88   :             ctx->numThreadsBusy++;

	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rbx+80], rax

; 89   :             ctx->queueEmpty = ctx->queueHead == ctx->queueTail;
; 90   :             /* Unlock the mutex, signal a pusher, and run the job */
; 91   :             ZSTD_pthread_cond_signal(&ctx->queuePushCond);

	lea	rcx, QWORD PTR [rbx+136]
	xor	eax, eax
	mov	QWORD PTR [rbx+56], rdx
	cmp	rdx, QWORD PTR [rbx+64]
	movups	XMMWORD PTR job$3$[rsp], xmm0
	sete	al
	mov	DWORD PTR [rbx+88], eax
	call	QWORD PTR __imp_WakeConditionVariable

; 92   :             ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_LeaveCriticalSection

; 93   : 
; 94   :             job.function(job.opaque);

	movups	xmm1, XMMWORD PTR job$3$[rsp]
	movdqa	xmm0, xmm1
	movq	rax, xmm1
	psrldq	xmm0, 8
	movq	rcx, xmm0
	call	rax

; 95   : 
; 96   :             /* If the intended queue size was 0, signal after finishing job */
; 97   :             ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_EnterCriticalSection

; 98   :             ctx->numThreadsBusy--;

	dec	QWORD PTR [rbx+80]

; 99   :             if (ctx->queueSize == 1) {

	cmp	QWORD PTR [rbx+72], 1
	jne	SHORT $LN23@POOL_threa

; 100  :                 ZSTD_pthread_cond_signal(&ctx->queuePushCond);

	lea	rcx, QWORD PTR [rbx+136]
	call	QWORD PTR __imp_WakeConditionVariable
$LN23@POOL_threa:

; 101  :             }
; 102  :             ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_LeaveCriticalSection
	jmp	$LL2@POOL_threa
$LN16@POOL_threa:

; 77   :                 /* even if !queueEmpty, (possible if numThreadsBusy >= threadLimit),
; 78   :                  * a few threads will be shutdown while !queueEmpty,
; 79   :                  * but enough threads will remain active to finish the queue */
; 80   :                 ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_LeaveCriticalSection

; 81   :                 return opaque;

	mov	rdi, QWORD PTR [rsp+72]
	mov	rax, rbx
	mov	rsi, QWORD PTR [rsp+64]

; 103  :         }
; 104  :     }  /* for (;;) */
; 105  :     assert(0);  /* Unreachable */
; 106  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
POOL_thread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
$T1 = 32
numThreads$ = 80
queueSize$dead$ = 88
POOL_create PROC

; 108  : POOL_ctx* POOL_create(size_t numThreads, size_t queueSize) {

$LN4:
	sub	rsp, 72					; 00000048H

; 109  :     return POOL_create_advanced(numThreads, queueSize, ZSTD_defaultCMem);

	movups	xmm0, XMMWORD PTR ZSTD_defaultCMem
	lea	r8, QWORD PTR $T1[rsp]
	mov	edx, 1
	movsd	xmm1, QWORD PTR ZSTD_defaultCMem+16
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	call	POOL_create_advanced

; 110  : }

	add	rsp, 72					; 00000048H
	ret	0
POOL_create ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
numThreads$ = 112
queueSize$ = 120
customMem$ = 128
POOL_create_advanced PROC

; 113  :                                ZSTD_customMem customMem) {

$LN37:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rbx, r8
	mov	rsi, rdx
	mov	r15, rcx

; 114  :     POOL_ctx* ctx;
; 115  :     /* Check parameters */
; 116  :     if (!numThreads) { return NULL; }

	test	rcx, rcx
	je	$LN31@POOL_creat
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [r8]
	mov	edx, 160				; 000000a0H
; File E:\dev\pyzstd\lib\common\pool.c

; 118  :     ctx = (POOL_ctx*)ZSTD_calloc(sizeof(POOL_ctx), customMem);

	movsd	xmm0, QWORD PTR [r8+16]
	movsd	QWORD PTR $T3[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	test	rax, rax
	je	SHORT $LN13@POOL_creat

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T3[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	xor	edx, edx
	mov	r8d, 160				; 000000a0H
	mov	rcx, rax
	mov	rdi, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN12@POOL_creat
$LN13@POOL_creat:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	ecx, 1
	call	QWORD PTR __imp_calloc
	mov	rdi, rax
$LN12@POOL_creat:
; File E:\dev\pyzstd\lib\common\pool.c

; 119  :     if (!ctx) { return NULL; }

	test	rdi, rdi
	je	$LN31@POOL_creat
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx]
; File E:\dev\pyzstd\lib\common\pool.c

; 124  :     ctx->queueSize = queueSize + 1;

	lea	rcx, QWORD PTR [rsi+1]

; 125  :     ctx->queue = (POOL_job*)ZSTD_malloc(ctx->queueSize * sizeof(POOL_job), customMem);

	movsd	xmm0, QWORD PTR [rbx+16]
	mov	QWORD PTR [rdi+72], rcx
	shl	rcx, 4
	mov	QWORD PTR [rsp+112], rbp
	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN16@POOL_creat

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax
	jmp	SHORT $LN15@POOL_creat
$LN16@POOL_creat:

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
$LN15@POOL_creat:
; File E:\dev\pyzstd\lib\common\pool.c

; 126  :     ctx->queueHead = 0;

	xor	ebp, ebp
	mov	QWORD PTR [rdi+48], rax

; 127  :     ctx->queueTail = 0;
; 128  :     ctx->numThreadsBusy = 0;
; 129  :     ctx->queueEmpty = 1;
; 130  :     {
; 131  :         int error = 0;
; 132  :         error |= ZSTD_pthread_mutex_init(&ctx->queueMutex, NULL);

	lea	rcx, QWORD PTR [rdi+96]
	mov	QWORD PTR [rdi+56], rbp
	mov	QWORD PTR [rdi+64], rbp
	mov	QWORD PTR [rdi+80], rbp
	mov	DWORD PTR [rdi+88], 1
	call	QWORD PTR __imp_InitializeCriticalSection

; 133  :         error |= ZSTD_pthread_cond_init(&ctx->queuePushCond, NULL);

	lea	rcx, QWORD PTR [rdi+136]
	call	QWORD PTR __imp_InitializeConditionVariable

; 134  :         error |= ZSTD_pthread_cond_init(&ctx->queuePopCond, NULL);

	lea	rcx, QWORD PTR [rdi+144]
	call	QWORD PTR __imp_InitializeConditionVariable
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx]
; File E:\dev\pyzstd\lib\common\pool.c

; 139  :     ctx->threads = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), customMem);

	lea	rcx, QWORD PTR [r15+r15*2]
	movsd	xmm0, QWORD PTR [rbx+16]
	shl	rcx, 3
	mov	DWORD PTR [rdi+152], ebp
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN19@POOL_creat

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN18@POOL_creat
$LN19@POOL_creat:

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
$LN18@POOL_creat:
; File E:\dev\pyzstd\lib\common\pool.c

; 141  :     ctx->customMem = customMem;

	movaps	xmm0, XMMWORD PTR [rbx]
	movsd	xmm1, QWORD PTR [rbx+16]
	mov	QWORD PTR [rdi+24], rax
	mov	QWORD PTR [rdi+32], rbp
	movups	XMMWORD PTR [rdi], xmm0
	movsd	QWORD PTR [rdi+16], xmm1

; 142  :     /* Check for errors */
; 143  :     if (!ctx->threads || !ctx->queue) { POOL_free(ctx); return NULL; }

	test	rax, rax
	je	$LN9@POOL_creat
	cmp	QWORD PTR [rdi+48], rbp
	je	$LN9@POOL_creat

; 144  :     /* Initialize the threads */
; 145  :     {   size_t i;
; 146  :         for (i = 0; i < numThreads; ++i) {

	mov	QWORD PTR [rsp+120], r12
	mov	rsi, rbp
	mov	QWORD PTR [rsp+128], r14
	test	r15, r15
	je	SHORT $LN32@POOL_creat
	mov	r14, rbp
	lea	r12, OFFSET FLAT:POOL_thread
	npad	5
$LL4@POOL_creat:

; 147  :             if (ZSTD_pthread_create(&ctx->threads[i], NULL, &POOL_thread, ctx)) {

	mov	rbx, QWORD PTR [rdi+24]
; File E:\dev\pyzstd\lib\common\threading.c

; 51   :     thread->handle = (HANDLE) _beginthreadex(NULL, 0, worker, thread, 0, NULL);

	lea	r8, OFFSET FLAT:worker
; File E:\dev\pyzstd\lib\common\pool.c

; 147  :             if (ZSTD_pthread_create(&ctx->threads[i], NULL, &POOL_thread, ctx)) {

	add	rbx, r14
; File E:\dev\pyzstd\lib\common\threading.c

; 51   :     thread->handle = (HANDLE) _beginthreadex(NULL, 0, worker, thread, 0, NULL);

	mov	QWORD PTR [rsp+40], rbp
	mov	r9, rbx
	mov	DWORD PTR [rsp+32], ebp
	xor	edx, edx
	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], rdi
	mov	QWORD PTR [rbx+8], r12
	call	QWORD PTR __imp__beginthreadex
	mov	QWORD PTR [rbx], rax

; 52   : 
; 53   :     if (!thread->handle)

	test	rax, rax
	jne	SHORT $LN30@POOL_creat

; 54   :         return errno;

	call	QWORD PTR __imp__errno
; File E:\dev\pyzstd\lib\common\pool.c

; 147  :             if (ZSTD_pthread_create(&ctx->threads[i], NULL, &POOL_thread, ctx)) {

	cmp	DWORD PTR [rax], ebp
	jne	SHORT $LN26@POOL_creat
$LN30@POOL_creat:

; 144  :     /* Initialize the threads */
; 145  :     {   size_t i;
; 146  :         for (i = 0; i < numThreads; ++i) {

	inc	rsi
	add	r14, 24
	cmp	rsi, r15
	jb	SHORT $LL4@POOL_creat
$LN32@POOL_creat:

; 151  :         }   }
; 152  :         ctx->threadCapacity = numThreads;

	mov	QWORD PTR [rdi+32], r15

; 153  :         ctx->threadLimit = numThreads;
; 154  :     }
; 155  :     return ctx;

	mov	rax, rdi
	mov	QWORD PTR [rdi+40], r15
$LN35@POOL_creat:
	mov	r12, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+128]
$LN33@POOL_creat:
	mov	rbp, QWORD PTR [rsp+112]

; 156  : }

	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN26@POOL_creat:

; 148  :                 ctx->threadCapacity = i;
; 149  :                 POOL_free(ctx);

	mov	rcx, rdi
	mov	QWORD PTR [rdi+32], rsi
	call	POOL_free

; 150  :                 return NULL;

	xor	eax, eax
	jmp	SHORT $LN35@POOL_creat
$LN9@POOL_creat:

; 142  :     /* Check for errors */
; 143  :     if (!ctx->threads || !ctx->queue) { POOL_free(ctx); return NULL; }

	mov	rcx, rdi
	call	POOL_free
	xor	eax, eax
	jmp	SHORT $LN33@POOL_creat
$LN31@POOL_creat:

; 156  : }

	mov	rbx, QWORD PTR [rsp+136]
	xor	eax, eax
	add	rsp, 80					; 00000050H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
POOL_create_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
ctx$ = 80
POOL_join PROC

; 161  : static void POOL_join(POOL_ctx* ctx) {

	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 64					; 00000040H
	mov	rsi, rcx

; 162  :     /* Shut down the queue */
; 163  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	add	rcx, 96					; 00000060H
	call	QWORD PTR __imp_EnterCriticalSection

; 164  :     ctx->shutdown = 1;
; 165  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rsi+96]
	mov	DWORD PTR [rsi+152], 1
	call	QWORD PTR __imp_LeaveCriticalSection

; 166  :     /* Wake up sleeping threads */
; 167  :     ZSTD_pthread_cond_broadcast(&ctx->queuePushCond);

	lea	rcx, QWORD PTR [rsi+136]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 168  :     ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);

	lea	rcx, QWORD PTR [rsi+144]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 171  :         for (i = 0; i < ctx->threadCapacity; ++i) {

	xor	ebx, ebx
	cmp	QWORD PTR [rsi+32], rbx
	jbe	SHORT $LN3@POOL_join

; 162  :     /* Shut down the queue */
; 163  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	mov	QWORD PTR [rsp+80], rdi
	mov	edi, ebx
	npad	12
$LL4@POOL_join:

; 172  :             ZSTD_pthread_join(ctx->threads[i], NULL);  /* note : could fail */

	mov	rax, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\common\threading.c

; 63   :     if (!thread.handle) return 0;

	mov	rcx, QWORD PTR [rax+rdi]
	test	rcx, rcx
	je	SHORT $LN2@POOL_join

; 64   : 
; 65   :     result = WaitForSingleObject(thread.handle, INFINITE);

	mov	edx, -1					; ffffffffH
	call	QWORD PTR __imp_WaitForSingleObject

; 66   :     switch (result) {

	test	eax, -129				; ffffff7fH
	je	SHORT $LN2@POOL_join

; 67   :     case WAIT_OBJECT_0:
; 68   :         if (value_ptr) *value_ptr = thread.arg;
; 69   :         return 0;
; 70   :     case WAIT_ABANDONED:
; 71   :         return EINVAL;
; 72   :     default:
; 73   :         return GetLastError();

	call	QWORD PTR __imp_GetLastError
$LN2@POOL_join:
; File E:\dev\pyzstd\lib\common\pool.c

; 171  :         for (i = 0; i < ctx->threadCapacity; ++i) {

	inc	rbx
	add	rdi, 24
	cmp	rbx, QWORD PTR [rsi+32]
	jb	SHORT $LL4@POOL_join
	mov	rdi, QWORD PTR [rsp+80]
$LN3@POOL_join:

; 173  :     }   }
; 174  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
POOL_join ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
ctx$ = 80
POOL_free PROC

; 176  : void POOL_free(POOL_ctx *ctx) {

$LN40:

; 177  :     if (!ctx) { return; }

	test	rcx, rcx
	je	$LN38@POOL_free
	push	rbx
	sub	rsp, 64					; 00000040H

; 176  : void POOL_free(POOL_ctx *ctx) {

	mov	rbx, rcx

; 163  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	mov	QWORD PTR [rsp+80], rbp
	add	rcx, 96					; 00000060H
	mov	QWORD PTR [rsp+96], rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 164  :     ctx->shutdown = 1;
; 165  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	mov	DWORD PTR [rbx+152], 1
	call	QWORD PTR __imp_LeaveCriticalSection

; 166  :     /* Wake up sleeping threads */
; 167  :     ZSTD_pthread_cond_broadcast(&ctx->queuePushCond);

	lea	rcx, QWORD PTR [rbx+136]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 168  :     ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);

	lea	rcx, QWORD PTR [rbx+144]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 171  :         for (i = 0; i < ctx->threadCapacity; ++i) {

	xor	edi, edi
	cmp	QWORD PTR [rbx+32], rdi
	jbe	SHORT $LN6@POOL_free

; 163  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	mov	QWORD PTR [rsp+88], rsi
	mov	esi, edi
$LL7@POOL_free:

; 172  :             ZSTD_pthread_join(ctx->threads[i], NULL);  /* note : could fail */

	mov	rax, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\common\threading.c

; 63   :     if (!thread.handle) return 0;

	mov	rcx, QWORD PTR [rax+rsi]
; File E:\dev\pyzstd\lib\common\pool.c

; 172  :             ZSTD_pthread_join(ctx->threads[i], NULL);  /* note : could fail */

	movsd	xmm0, QWORD PTR [rax+rsi+16]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\threading.c

; 63   :     if (!thread.handle) return 0;

	test	rcx, rcx
	je	SHORT $LN5@POOL_free

; 64   : 
; 65   :     result = WaitForSingleObject(thread.handle, INFINITE);

	mov	edx, -1					; ffffffffH
	call	QWORD PTR __imp_WaitForSingleObject

; 66   :     switch (result) {

	test	eax, -129				; ffffff7fH
	je	SHORT $LN5@POOL_free

; 67   :     case WAIT_OBJECT_0:
; 68   :         if (value_ptr) *value_ptr = thread.arg;
; 69   :         return 0;
; 70   :     case WAIT_ABANDONED:
; 71   :         return EINVAL;
; 72   :     default:
; 73   :         return GetLastError();

	call	QWORD PTR __imp_GetLastError
$LN5@POOL_free:
; File E:\dev\pyzstd\lib\common\pool.c

; 171  :         for (i = 0; i < ctx->threadCapacity; ++i) {

	inc	rdi
	add	rsi, 24
	cmp	rdi, QWORD PTR [rbx+32]
	jb	SHORT $LL7@POOL_free
	mov	rsi, QWORD PTR [rsp+88]
$LN6@POOL_free:

; 178  :     POOL_join(ctx);
; 179  :     ZSTD_pthread_mutex_destroy(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_DeleteCriticalSection

; 180  :     ZSTD_pthread_cond_destroy(&ctx->queuePushCond);
; 181  :     ZSTD_pthread_cond_destroy(&ctx->queuePopCond);
; 182  :     ZSTD_free(ctx->queue, ctx->customMem);

	movups	xmm0, XMMWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+48]
	movsd	xmm1, QWORD PTR [rbx+16]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+80]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movsd	QWORD PTR $T4[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN21@POOL_free

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T4[rsp+8]
	test	rax, rax
	je	SHORT $LN20@POOL_free

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T4[rsp+16]
	call	rax
	jmp	SHORT $LN21@POOL_free
$LN20@POOL_free:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN21@POOL_free:
; File E:\dev\pyzstd\lib\common\pool.c

; 183  :     ZSTD_free(ctx->threads, ctx->customMem);

	movups	xmm0, XMMWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+24]
	movsd	xmm1, QWORD PTR [rbx+16]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movsd	QWORD PTR $T3[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN26@POOL_free

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T3[rsp+8]
	test	rax, rax
	je	SHORT $LN25@POOL_free

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T3[rsp+16]
	call	rax
	jmp	SHORT $LN26@POOL_free
$LN25@POOL_free:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN26@POOL_free:
; File E:\dev\pyzstd\lib\common\pool.c

; 184  :     ZSTD_free(ctx, ctx->customMem);

	movups	xmm1, XMMWORD PTR [rbx]
	movsd	xmm0, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\common\pool.c

; 184  :     ZSTD_free(ctx, ctx->customMem);

	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN30@POOL_free

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rbx
; File E:\dev\pyzstd\lib\common\pool.c

; 185  : }

	add	rsp, 64					; 00000040H
	pop	rbx
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 79   :             customMem.customFree(customMem.opaque, ptr);

	rex_jmp	rax
$LN30@POOL_free:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File E:\dev\pyzstd\lib\common\pool.c

; 185  : }

	add	rsp, 64					; 00000040H
	pop	rbx
$LN38@POOL_free:
	ret	0
POOL_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
ctx$ = 112
numThreads$ = 120
POOL_resize_internal PROC

; 199  : {

	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	r14, rdx
	mov	rdi, rcx

; 200  :     if (numThreads <= ctx->threadCapacity) {

	cmp	rdx, QWORD PTR [rcx+32]
	ja	SHORT $LN5@POOL_resiz

; 201  :         if (!numThreads) return 1;

	test	rdx, rdx
	je	SHORT $LN28@POOL_resiz

; 202  :         ctx->threadLimit = numThreads;

	mov	QWORD PTR [rcx+40], rdx

; 203  :         return 0;

	xor	eax, eax

; 224  : }

	add	rsp, 80					; 00000050H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN5@POOL_resiz:

; 206  :     {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), ctx->customMem);

	movsd	xmm0, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rdx+rdx*2]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rdi]
; File E:\dev\pyzstd\lib\common\pool.c

; 206  :     {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), ctx->customMem);

	shl	rcx, 3
	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN11@POOL_resiz

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax
	jmp	SHORT $LN33@POOL_resiz
$LN11@POOL_resiz:

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
$LN33@POOL_resiz:
; File E:\dev\pyzstd\lib\common\pool.c

; 207  :         if (!threadPool) return 1;

	mov	rsi, rax
	test	rax, rax
	jne	SHORT $LN7@POOL_resiz
$LN28@POOL_resiz:
	mov	eax, 1

; 224  : }

	add	rsp, 80					; 00000050H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN7@POOL_resiz:

; 208  :         /* replace existing thread pool */
; 209  :         memcpy(threadPool, ctx->threads, ctx->threadCapacity * sizeof(*threadPool));

	mov	rax, QWORD PTR [rdi+32]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rsp+112], rbx
	lea	r8, QWORD PTR [rax+rax*2]
	shl	r8, 3
	call	memcpy

; 210  :         ZSTD_free(ctx->threads, ctx->customMem);

	movups	xmm0, XMMWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+24]
	movsd	xmm1, QWORD PTR [rdi+16]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN16@POOL_resiz

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN15@POOL_resiz

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN16@POOL_resiz
$LN15@POOL_resiz:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN16@POOL_resiz:
; File E:\dev\pyzstd\lib\common\pool.c

; 214  :             for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {

	mov	rbx, QWORD PTR [rdi+32]
	mov	QWORD PTR [rsp+120], rbp
	mov	QWORD PTR [rsp+128], r15
	mov	QWORD PTR [rdi+24], rsi
	cmp	rbx, r14
	jae	SHORT $LN29@POOL_resiz

; 211  :         ctx->threads = threadPool;

	lea	rax, QWORD PTR [rbx+rbx*2]
	xor	ebp, ebp
	lea	rsi, QWORD PTR [rsi+rax*8]
	lea	r15, OFFSET FLAT:POOL_thread
	npad	4
$LL4@POOL_resiz:
; File E:\dev\pyzstd\lib\common\threading.c

; 51   :     thread->handle = (HANDLE) _beginthreadex(NULL, 0, worker, thread, 0, NULL);

	mov	QWORD PTR [rsp+40], rbp
	lea	r8, OFFSET FLAT:worker
	mov	r9, rsi
	mov	DWORD PTR [rsp+32], ebp
	xor	edx, edx
	mov	QWORD PTR [rsi+16], rdi
	xor	ecx, ecx
	mov	QWORD PTR [rsi+8], r15
	call	QWORD PTR __imp__beginthreadex
	mov	QWORD PTR [rsi], rax

; 52   : 
; 53   :     if (!thread->handle)

	test	rax, rax
	jne	SHORT $LN27@POOL_resiz

; 54   :         return errno;

	call	QWORD PTR __imp__errno
; File E:\dev\pyzstd\lib\common\pool.c

; 215  :                 if (ZSTD_pthread_create(&threadPool[threadId], NULL, &POOL_thread, ctx)) {

	cmp	DWORD PTR [rax], ebp
	jne	SHORT $LN23@POOL_resiz
$LN27@POOL_resiz:

; 214  :             for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {

	inc	rbx
	add	rsi, 24
	cmp	rbx, r14
	jb	SHORT $LL4@POOL_resiz
$LN29@POOL_resiz:

; 218  :             }   }
; 219  :     }   }
; 220  :     /* successfully expanded */
; 221  :     ctx->threadCapacity = numThreads;

	mov	QWORD PTR [rdi+32], r14

; 222  :     ctx->threadLimit = numThreads;
; 223  :     return 0;

	xor	eax, eax
	mov	QWORD PTR [rdi+40], r14
$LN32@POOL_resiz:
	mov	rbp, QWORD PTR [rsp+120]
	mov	r15, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+112]

; 224  : }

	add	rsp, 80					; 00000050H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN23@POOL_resiz:

; 216  :                     ctx->threadCapacity = threadId;

	mov	QWORD PTR [rdi+32], rbx

; 217  :                     return 1;

	mov	eax, 1
	jmp	SHORT $LN32@POOL_resiz
POOL_resize_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\common\threading.c
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
ctx$ = 112
numThreads$ = 120
POOL_resize PROC

; 228  : {

$LN37:
	push	rbx
	push	rdi
	push	r15
	sub	rsp, 80					; 00000050H
	mov	r15, rdx
	mov	rdi, rcx

; 229  :     int result;
; 230  :     if (ctx==NULL) return 1;

	test	rcx, rcx
	jne	SHORT $LN2@POOL_resiz
	lea	eax, QWORD PTR [rcx+1]

; 236  : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN2@POOL_resiz:

; 231  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	add	rcx, 96					; 00000060H
	mov	QWORD PTR [rsp+112], rbp
	call	QWORD PTR __imp_EnterCriticalSection

; 200  :     if (numThreads <= ctx->threadCapacity) {

	cmp	r15, QWORD PTR [rdi+32]
	ja	SHORT $LN8@POOL_resiz

; 201  :         if (!numThreads) return 1;

	test	r15, r15
	jne	SHORT $LN9@POOL_resiz
	lea	ebx, QWORD PTR [r15+1]
	jmp	$LN4@POOL_resiz
$LN9@POOL_resiz:

; 202  :         ctx->threadLimit = numThreads;

	mov	QWORD PTR [rdi+40], r15

; 203  :         return 0;

	xor	ebx, ebx
	jmp	$LN4@POOL_resiz
$LN8@POOL_resiz:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rdi]
; File E:\dev\pyzstd\lib\common\pool.c

; 206  :     {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), ctx->customMem);

	lea	rcx, QWORD PTR [r15+r15*2]
	movsd	xmm0, QWORD PTR [rdi+16]
	shl	rcx, 3
	mov	QWORD PTR [rsp+136], r14
	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN14@POOL_resiz

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax
	jmp	SHORT $LN35@POOL_resiz
$LN14@POOL_resiz:

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
$LN35@POOL_resiz:
; File E:\dev\pyzstd\lib\common\pool.c

; 207  :         if (!threadPool) return 1;

	mov	r14, rax
	test	rax, rax
	jne	SHORT $LN10@POOL_resiz
	lea	ebx, QWORD PTR [rax+1]
	jmp	$LN32@POOL_resiz
$LN10@POOL_resiz:

; 208  :         /* replace existing thread pool */
; 209  :         memcpy(threadPool, ctx->threads, ctx->threadCapacity * sizeof(*threadPool));

	mov	rax, QWORD PTR [rdi+32]
	mov	rcx, r14
	mov	rdx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rsp+120], rsi
	lea	r8, QWORD PTR [rax+rax*2]
	shl	r8, 3
	call	memcpy

; 210  :         ZSTD_free(ctx->threads, ctx->customMem);

	movups	xmm0, XMMWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+24]
	movsd	xmm1, QWORD PTR [rdi+16]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN19@POOL_resiz

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN18@POOL_resiz

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN19@POOL_resiz
$LN18@POOL_resiz:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN19@POOL_resiz:
; File E:\dev\pyzstd\lib\common\pool.c

; 214  :             for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {

	mov	rsi, QWORD PTR [rdi+32]
	xor	ebx, ebx
	mov	QWORD PTR [rsp+128], r12

; 211  :         ctx->threads = threadPool;

	mov	QWORD PTR [rdi+24], r14

; 214  :             for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {

	cmp	rsi, r15
	jae	SHORT $LN31@POOL_resiz

; 211  :         ctx->threads = threadPool;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	r14, QWORD PTR [r14+rax*8]
	lea	r12, OFFSET FLAT:POOL_thread
	npad	2
$LL7@POOL_resiz:
; File E:\dev\pyzstd\lib\common\threading.c

; 51   :     thread->handle = (HANDLE) _beginthreadex(NULL, 0, worker, thread, 0, NULL);

	mov	QWORD PTR [rsp+40], rbx
	lea	r8, OFFSET FLAT:worker
	mov	r9, r14
	mov	DWORD PTR [rsp+32], ebx
	xor	edx, edx
	mov	QWORD PTR [r14+16], rdi
	xor	ecx, ecx
	mov	QWORD PTR [r14+8], r12
	call	QWORD PTR __imp__beginthreadex
	mov	QWORD PTR [r14], rax

; 52   : 
; 53   :     if (!thread->handle)

	test	rax, rax
	jne	SHORT $LN30@POOL_resiz

; 54   :         return errno;

	call	QWORD PTR __imp__errno
; File E:\dev\pyzstd\lib\common\pool.c

; 215  :                 if (ZSTD_pthread_create(&threadPool[threadId], NULL, &POOL_thread, ctx)) {

	cmp	DWORD PTR [rax], ebx
	jne	SHORT $LN26@POOL_resiz
$LN30@POOL_resiz:

; 214  :             for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {

	inc	rsi
	add	r14, 24
	cmp	rsi, r15
	jb	SHORT $LL7@POOL_resiz
$LN31@POOL_resiz:

; 218  :             }   }
; 219  :     }   }
; 220  :     /* successfully expanded */
; 221  :     ctx->threadCapacity = numThreads;

	mov	QWORD PTR [rdi+32], r15

; 222  :     ctx->threadLimit = numThreads;

	mov	QWORD PTR [rdi+40], r15
$LN34@POOL_resiz:
	mov	r12, QWORD PTR [rsp+128]
	mov	rsi, QWORD PTR [rsp+120]
$LN32@POOL_resiz:
	mov	r14, QWORD PTR [rsp+136]
$LN4@POOL_resiz:

; 232  :     result = POOL_resize_internal(ctx, numThreads);
; 233  :     ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);

	lea	rcx, QWORD PTR [rdi+144]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 234  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rdi+96]
	call	QWORD PTR __imp_LeaveCriticalSection

; 235  :     return result;

	mov	rbp, QWORD PTR [rsp+112]
	mov	eax, ebx

; 236  : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN26@POOL_resiz:

; 216  :                     ctx->threadCapacity = threadId;

	mov	QWORD PTR [rdi+32], rsi

; 217  :                     return 1;

	mov	ebx, 1
	jmp	SHORT $LN34@POOL_resiz
POOL_resize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
ctx$ = 8
isQueueFull PROC

; 245  :     if (ctx->queueSize > 1) {

	mov	r8, QWORD PTR [rcx+72]
	cmp	r8, 1
	jbe	SHORT $LN2@isQueueFul

; 246  :         return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);

	mov	rax, QWORD PTR [rcx+64]
	xor	edx, edx
	inc	rax
	div	r8
	xor	eax, eax
	cmp	QWORD PTR [rcx+56], rdx
	sete	al

; 249  :                !ctx->queueEmpty;
; 250  :     }
; 251  : }

	ret	0
$LN2@isQueueFul:

; 247  :     } else {
; 248  :         return (ctx->numThreadsBusy == ctx->threadLimit) ||

	mov	rax, QWORD PTR [rcx+40]
	cmp	QWORD PTR [rcx+80], rax
	je	SHORT $LN5@isQueueFul
	cmp	DWORD PTR [rcx+88], 0
	je	SHORT $LN5@isQueueFul
	xor	eax, eax

; 249  :                !ctx->queueEmpty;
; 250  :     }
; 251  : }

	ret	0
$LN5@isQueueFul:

; 247  :     } else {
; 248  :         return (ctx->numThreadsBusy == ctx->threadLimit) ||

	mov	eax, 1

; 249  :                !ctx->queueEmpty;
; 250  :     }
; 251  : }

	ret	0
isQueueFull ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
ctx$ = 8
function$ = 16
opaque$ = 24
POOL_add_internal PROC

; 256  :     POOL_job const job = {function, opaque};
; 257  :     assert(ctx != NULL);
; 258  :     if (ctx->shutdown) return;

	cmp	DWORD PTR [rcx+152], 0
	jne	SHORT $LN1@POOL_add_i

; 259  : 
; 260  :     ctx->queueEmpty = 0;
; 261  :     ctx->queue[ctx->queueTail] = job;

	mov	r9, QWORD PTR [rcx+64]
	mov	rax, QWORD PTR [rcx+48]
	add	r9, r9
	mov	DWORD PTR [rcx+88], 0
	mov	QWORD PTR [rax+r9*8], rdx

; 262  :     ctx->queueTail = (ctx->queueTail + 1) % ctx->queueSize;

	xor	edx, edx
	mov	QWORD PTR [rax+r9*8+8], r8
	mov	rax, QWORD PTR [rcx+64]
	inc	rax
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR [rcx+64], rdx

; 263  :     ZSTD_pthread_cond_signal(&ctx->queuePopCond);

	add	rcx, 144				; 00000090H
	rex_jmp	QWORD PTR __imp_WakeConditionVariable
$LN1@POOL_add_i:

; 264  : }

	ret	0
POOL_add_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
ctx$ = 48
function$ = 56
opaque$ = 64
POOL_add PROC

; 267  : {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r8

; 268  :     assert(ctx != NULL);
; 269  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	add	rcx, 96					; 00000060H
	mov	rbp, rdx
	call	QWORD PTR __imp_EnterCriticalSection

; 270  :     /* Wait until there is space in the queue for the new job */
; 271  :     while (isQueueFull(ctx) && (!ctx->shutdown)) {

	mov	rcx, rbx
	call	isQueueFull
	test	eax, eax
	je	SHORT $LN12@POOL_add
$LL2@POOL_add:
	cmp	DWORD PTR [rbx+152], 0
	jne	SHORT $LN5@POOL_add

; 272  :         ZSTD_pthread_cond_wait(&ctx->queuePushCond, &ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+136]
	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_SleepConditionVariableCS
	mov	rcx, rbx
	call	isQueueFull
	test	eax, eax
	jne	SHORT $LL2@POOL_add
$LN12@POOL_add:

; 258  :     if (ctx->shutdown) return;

	cmp	DWORD PTR [rbx+152], 0
	jne	SHORT $LN5@POOL_add

; 259  : 
; 260  :     ctx->queueEmpty = 0;
; 261  :     ctx->queue[ctx->queueTail] = job;

	mov	rcx, QWORD PTR [rbx+64]

; 262  :     ctx->queueTail = (ctx->queueTail + 1) % ctx->queueSize;

	xor	edx, edx
	mov	rax, QWORD PTR [rbx+48]
	add	rcx, rcx
	mov	DWORD PTR [rbx+88], 0
	mov	QWORD PTR [rax+rcx*8], rbp
	mov	QWORD PTR [rax+rcx*8+8], rsi

; 263  :     ZSTD_pthread_cond_signal(&ctx->queuePopCond);

	lea	rcx, QWORD PTR [rbx+144]
	mov	rax, QWORD PTR [rbx+64]
	inc	rax
	div	QWORD PTR [rbx+72]
	mov	QWORD PTR [rbx+64], rdx
	call	QWORD PTR __imp_WakeConditionVariable
$LN5@POOL_add:

; 273  :     }
; 274  :     POOL_add_internal(ctx, function, opaque);
; 275  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]

; 276  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 273  :     }
; 274  :     POOL_add_internal(ctx, function, opaque);
; 275  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
POOL_add ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\pool.c
_TEXT	SEGMENT
ctx$ = 48
function$dead$ = 56
opaque$ = 64
POOL_tryAdd PROC

; 280  : {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r8

; 281  :     assert(ctx != NULL);
; 282  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	add	rcx, 96					; 00000060H
	call	QWORD PTR __imp_EnterCriticalSection

; 245  :     if (ctx->queueSize > 1) {

	mov	rcx, QWORD PTR [rbx+72]
	cmp	rcx, 1
	jbe	SHORT $LN5@POOL_tryAd

; 246  :         return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);

	mov	rax, QWORD PTR [rbx+64]
	xor	edx, edx
	inc	rax
	div	rcx

; 283  :     if (isQueueFull(ctx)) {

	cmp	QWORD PTR [rbx+56], rdx
	jne	SHORT $LN2@POOL_tryAd
$LN13@POOL_tryAd:

; 284  :         ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_LeaveCriticalSection

; 285  :         return 0;

	xor	eax, eax

; 289  :     return 1;
; 290  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@POOL_tryAd:

; 248  :         return (ctx->numThreadsBusy == ctx->threadLimit) ||

	mov	rax, QWORD PTR [rbx+40]
	cmp	QWORD PTR [rbx+80], rax
	je	SHORT $LN13@POOL_tryAd
	cmp	DWORD PTR [rbx+88], 0
	je	SHORT $LN13@POOL_tryAd
$LN2@POOL_tryAd:

; 258  :     if (ctx->shutdown) return;

	cmp	DWORD PTR [rbx+152], 0
	jne	SHORT $LN10@POOL_tryAd

; 259  : 
; 260  :     ctx->queueEmpty = 0;
; 261  :     ctx->queue[ctx->queueTail] = job;

	mov	rcx, QWORD PTR [rbx+64]
	lea	rdx, OFFSET FLAT:ZSTDMT_compressionJob
	mov	rax, QWORD PTR [rbx+48]
	add	rcx, rcx
	mov	DWORD PTR [rbx+88], 0
	mov	QWORD PTR [rax+rcx*8], rdx

; 262  :     ctx->queueTail = (ctx->queueTail + 1) % ctx->queueSize;

	xor	edx, edx
	mov	QWORD PTR [rax+rcx*8+8], rsi

; 263  :     ZSTD_pthread_cond_signal(&ctx->queuePopCond);

	lea	rcx, QWORD PTR [rbx+144]
	mov	rax, QWORD PTR [rbx+64]
	inc	rax
	div	QWORD PTR [rbx+72]
	mov	QWORD PTR [rbx+64], rdx
	call	QWORD PTR __imp_WakeConditionVariable
$LN10@POOL_tryAd:

; 286  :     }
; 287  :     POOL_add_internal(ctx, function, opaque);
; 288  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rbx+96]
	call	QWORD PTR __imp_LeaveCriticalSection

; 289  :     return 1;
; 290  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 1
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
POOL_tryAdd ENDP
_TEXT	ENDS
END
