; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	HIST_count_simple
PUBLIC	HIST_count_wksp
PUBLIC	HIST_countFast_wksp
pdata	SEGMENT
$pdata$HIST_count_parallel_wksp DD imagerel HIST_count_parallel_wksp
	DD	imagerel HIST_count_parallel_wksp+893
	DD	imagerel $unwind$HIST_count_parallel_wksp
$pdata$HIST_count_simple DD imagerel $LN39
	DD	imagerel $LN39+308
	DD	imagerel $unwind$HIST_count_simple
$pdata$HIST_count_wksp DD imagerel $LN13
	DD	imagerel $LN13+104
	DD	imagerel $unwind$HIST_count_wksp
$pdata$HIST_countFast_wksp DD imagerel $LN7
	DD	imagerel $LN7+68
	DD	imagerel $unwind$HIST_countFast_wksp
xdata	SEGMENT
$unwind$HIST_count_parallel_wksp DD 0a1e01H
	DD	0c341eH
	DD	0f01a321eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$HIST_count_simple DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$HIST_count_wksp DD 010401H
	DD	06204H
$unwind$HIST_countFast_wksp DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\hist.c
_TEXT	SEGMENT
count$ = 64
maxSymbolValuePtr$ = 72
source$ = 80
sourceSize$ = 88
workSpace$ = 96
workSpaceSize$dead$ = 104
HIST_countFast_wksp PROC

; 147  : {

$LN7:
	sub	rsp, 56					; 00000038H

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	r9, 1500				; 000005dcH
	jae	SHORT $LN2@HIST_count

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	call	HIST_count_simple
	mov	eax, eax

; 153  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@HIST_count:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	mov	rax, QWORD PTR workSpace$[rsp]
	test	al, 3
	je	SHORT $LN3@HIST_count
	mov	rax, -1

; 153  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN3@HIST_count:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR workSpaceSize$dead$[rsp], rax
	mov	DWORD PTR workSpace$[rsp], 0

; 153  : }

	add	rsp, 56					; 00000038H

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	jmp	HIST_count_parallel_wksp
HIST_countFast_wksp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\hist.c
_TEXT	SEGMENT
count$ = 64
maxSymbolValuePtr$ = 72
source$ = 80
sourceSize$ = 88
workSpace$ = 96
workSpaceSize$dead$ = 104
HIST_count_wksp PROC

; 169  : {

$LN13:
	sub	rsp, 56					; 00000038H

; 170  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	mov	rax, QWORD PTR workSpace$[rsp]
	test	al, 3
	je	SHORT $LN2@HIST_count
	mov	rax, -1

; 175  :     return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);
; 176  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@HIST_count:

; 171  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 172  :     if (*maxSymbolValuePtr < 255)

	cmp	DWORD PTR [rdx], 255			; 000000ffH
	jae	SHORT $LN4@HIST_count

; 173  :         return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, checkMaxSymbolValue, (U32*)workSpace);

	mov	QWORD PTR workSpaceSize$dead$[rsp], rax
	mov	DWORD PTR workSpace$[rsp], 1

; 175  :     return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);
; 176  : }

	add	rsp, 56					; 00000038H
	jmp	HIST_count_parallel_wksp
$LN4@HIST_count:

; 174  :     *maxSymbolValuePtr = 255;

	mov	DWORD PTR [rdx], 255			; 000000ffH

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	r9, 1500				; 000005dcH
	jae	SHORT $LN7@HIST_count

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	call	HIST_count_simple
	mov	eax, eax

; 175  :     return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);
; 176  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN7@HIST_count:

; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR workSpaceSize$dead$[rsp], rax
	mov	DWORD PTR workSpace$[rsp], 0

; 175  :     return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);
; 176  : }

	add	rsp, 56					; 00000038H
	jmp	HIST_count_parallel_wksp
HIST_count_wksp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\hist.c
_TEXT	SEGMENT
count$ = 64
maxSymbolValuePtr$ = 72
src$ = 80
srcSize$ = 88
HIST_count_simple PROC

; 31   : {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 32   :     const BYTE* ip = (const BYTE*)src;
; 33   :     const BYTE* const end = ip + srcSize;
; 34   :     unsigned maxSymbolValue = *maxSymbolValuePtr;

	mov	edi, DWORD PTR [rdx]
	lea	rbp, QWORD PTR [r8+r9]
	mov	r14, r8
	mov	r12, rdx

; 35   :     unsigned largestCount=0;
; 36   : 
; 37   :     memset(count, 0, (maxSymbolValue+1) * sizeof(*count));

	xor	edx, edx
	mov	rbx, r9
	mov	r15, rcx
	xor	esi, esi
	lea	r8d, DWORD PTR [rdi+1]
	shl	r8, 2
	call	memset

; 38   :     if (srcSize==0) { *maxSymbolValuePtr = 0; return 0; }

	test	rbx, rbx
	jne	SHORT $LN12@HIST_count
	mov	DWORD PTR [r12], esi
	xor	eax, eax
	jmp	$LN1@HIST_count
$LN12@HIST_count:

; 39   : 
; 40   :     while (ip<end) {

	cmp	r14, rbp
	jae	SHORT $LN13@HIST_count
	npad	10
$LL2@HIST_count:

; 41   :         assert(*ip <= maxSymbolValue);
; 42   :         count[*ip++]++;

	movzx	eax, BYTE PTR [r14]
	inc	r14
	inc	DWORD PTR [r15+rax*4]
	cmp	r14, rbp
	jb	SHORT $LL2@HIST_count
$LN13@HIST_count:

; 43   :     }
; 44   : 
; 45   :     while (!count[maxSymbolValue]) maxSymbolValue--;

	cmp	DWORD PTR [r15+rdi*4], esi
	jne	SHORT $LN5@HIST_count
$LL4@HIST_count:
	dec	edi
	cmp	DWORD PTR [r15+rdi*4], esi
	je	SHORT $LL4@HIST_count
$LN5@HIST_count:

; 46   :     *maxSymbolValuePtr = maxSymbolValue;

	lea	ecx, DWORD PTR [rdi+1]
	mov	DWORD PTR [r12], edi
	mov	eax, esi

; 47   : 
; 48   :     {   U32 s;
; 49   :         for (s=0; s<=maxSymbolValue; s++)

	cmp	ecx, 8
	jb	SHORT $LL36@HIST_count

; 46   :     *maxSymbolValuePtr = maxSymbolValue;

	cmp	DWORD PTR __isa_available, 2
	jl	SHORT $LL36@HIST_count
	and	ecx, 7
	mov	r8d, edi
	sub	r8d, ecx
	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	npad	12
$LL8@HIST_count:

; 50   :             if (count[s] > largestCount) largestCount = count[s];

	mov	ecx, eax
	movdqu	xmm0, XMMWORD PTR [r15+rcx*4]
	lea	ecx, DWORD PTR [rax+4]
	add	eax, 8
	pmaxud	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [r15+rcx*4]
	pmaxud	xmm2, xmm0
	cmp	eax, r8d
	jbe	SHORT $LL8@HIST_count

; 46   :     *maxSymbolValuePtr = maxSymbolValue;

	pmaxud	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	pmaxud	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	pmaxud	xmm1, xmm0
	movd	esi, xmm1

; 47   : 
; 48   :     {   U32 s;
; 49   :         for (s=0; s<=maxSymbolValue; s++)

	cmp	eax, edi
	ja	SHORT $LN7@HIST_count
	npad	4
$LL36@HIST_count:

; 50   :             if (count[s] > largestCount) largestCount = count[s];

	mov	ecx, eax
	mov	edx, DWORD PTR [r15+rcx*4]
	cmp	edx, esi
	cmovbe	edx, esi
	inc	eax
	mov	esi, edx
	cmp	eax, edi
	jbe	SHORT $LL36@HIST_count
$LN7@HIST_count:

; 51   :     }
; 52   : 
; 53   :     return largestCount;

	mov	eax, esi
$LN1@HIST_count:

; 54   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
HIST_count_simple ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\hist.c
_TEXT	SEGMENT
count$ = 96
maxSymbolValuePtr$ = 104
source$ = 112
sourceSize$ = 120
check$ = 128
workSpace$ = 136
HIST_count_parallel_wksp PROC

; 71   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 72   :     const BYTE* ip = (const BYTE*)source;
; 73   :     const BYTE* const iend = ip+sourceSize;
; 74   :     unsigned maxSymbolValue = *maxSymbolValuePtr;
; 75   :     unsigned max=0;
; 76   :     U32* const Counting1 = workSpace;
; 77   :     U32* const Counting2 = Counting1 + 256;

	mov	r14, QWORD PTR workSpace$[rsp]
	mov	rbp, rcx
	mov	ebx, DWORD PTR [rdx]

; 78   :     U32* const Counting3 = Counting2 + 256;
; 79   :     U32* const Counting4 = Counting3 + 256;
; 80   : 
; 81   :     memset(workSpace, 0, 4*256*sizeof(unsigned));

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, r14
	mov	rdi, r9
	xor	esi, esi
	lea	r13, QWORD PTR [r14+1024]
	lea	r15, QWORD PTR [r13+1024]
	lea	r12, QWORD PTR [r15+1024]
	call	memset

; 82   : 
; 83   :     /* safety checks */
; 84   :     if (!sourceSize) {

	test	rdi, rdi
	jne	SHORT $LN14@HIST_count

; 85   :         memset(count, 0, maxSymbolValue + 1);

	lea	r8d, DWORD PTR [rbx+1]
	xor	edx, edx
	mov	rcx, rbp
	call	memset

; 86   :         *maxSymbolValuePtr = 0;

	mov	rax, QWORD PTR maxSymbolValuePtr$[rsp]
	mov	DWORD PTR [rax], esi

; 87   :         return 0;

	xor	eax, eax
	jmp	$LN1@HIST_count
$LN14@HIST_count:

; 88   :     }
; 89   :     if (!maxSymbolValue) maxSymbolValue = 255;            /* 0 == default */
; 90   : 
; 91   :     /* by stripes of 16 bytes */
; 92   :     {   U32 cached = MEM_read32(ip); ip += 4;

	mov	rax, QWORD PTR source$[rsp]
	test	ebx, ebx
	mov	r9d, 255				; 000000ffH
	cmove	ebx, r9d
	mov	edx, DWORD PTR [rax]

; 93   :         while (ip < iend-15) {

	lea	r10, QWORD PTR [rax+rdi]
	lea	r11, QWORD PTR [r10-15]
	lea	r8, QWORD PTR [rax+4]
	cmp	r8, r11
	jae	$LN3@HIST_count
	npad	2
$LL2@HIST_count:

; 94   :             U32 c = cached; cached = MEM_read32(ip); ip += 4;

	mov	ecx, DWORD PTR [r8]

; 95   :             Counting1[(BYTE) c     ]++;

	movzx	eax, dl
	inc	DWORD PTR [r14+rax*4]

; 96   :             Counting2[(BYTE)(c>>8) ]++;

	mov	eax, edx
	shr	eax, 8
	movzx	eax, al
	inc	DWORD PTR [r13+rax*4]

; 97   :             Counting3[(BYTE)(c>>16)]++;

	mov	eax, edx
	shr	eax, 16
	movzx	eax, al
	inc	DWORD PTR [r15+rax*4]

; 98   :             Counting4[       c>>24 ]++;

	mov	eax, edx
	shr	rax, 24
	inc	DWORD PTR [r12+rax*4]

; 99   :             c = cached; cached = MEM_read32(ip); ip += 4;

	mov	edx, DWORD PTR [r8+4]

; 100  :             Counting1[(BYTE) c     ]++;

	movzx	eax, cl
	inc	DWORD PTR [r14+rax*4]

; 101  :             Counting2[(BYTE)(c>>8) ]++;

	mov	eax, ecx
	shr	eax, 8
	movzx	eax, al
	inc	DWORD PTR [r13+rax*4]

; 102  :             Counting3[(BYTE)(c>>16)]++;

	mov	eax, ecx
	shr	eax, 16
	movzx	eax, al
	inc	DWORD PTR [r15+rax*4]

; 103  :             Counting4[       c>>24 ]++;

	mov	eax, ecx
	shr	rax, 24
	inc	DWORD PTR [r12+rax*4]

; 104  :             c = cached; cached = MEM_read32(ip); ip += 4;

	mov	ecx, DWORD PTR [r8+8]

; 105  :             Counting1[(BYTE) c     ]++;

	movzx	eax, dl
	inc	DWORD PTR [r14+rax*4]

; 106  :             Counting2[(BYTE)(c>>8) ]++;

	mov	eax, edx
	shr	eax, 8
	movzx	eax, al
	inc	DWORD PTR [r13+rax*4]

; 107  :             Counting3[(BYTE)(c>>16)]++;

	mov	eax, edx
	shr	eax, 16
	movzx	eax, al
	inc	DWORD PTR [r15+rax*4]

; 108  :             Counting4[       c>>24 ]++;

	mov	eax, edx
	shr	rax, 24
	inc	DWORD PTR [r12+rax*4]

; 109  :             c = cached; cached = MEM_read32(ip); ip += 4;

	mov	edx, DWORD PTR [r8+12]
	add	r8, 16

; 110  :             Counting1[(BYTE) c     ]++;

	movzx	eax, cl
	inc	DWORD PTR [r14+rax*4]

; 111  :             Counting2[(BYTE)(c>>8) ]++;

	mov	eax, ecx
	shr	eax, 8
	movzx	eax, al
	inc	DWORD PTR [r13+rax*4]

; 112  :             Counting3[(BYTE)(c>>16)]++;

	mov	eax, ecx
	shr	eax, 16
	movzx	eax, al
	inc	DWORD PTR [r15+rax*4]

; 113  :             Counting4[       c>>24 ]++;

	mov	eax, ecx
	shr	rax, 24
	inc	DWORD PTR [r12+rax*4]
	cmp	r8, r11
	jb	$LL2@HIST_count
$LN3@HIST_count:

; 114  :         }
; 115  :         ip-=4;
; 116  :     }
; 117  : 
; 118  :     /* finish last symbols */
; 119  :     while (ip<iend) Counting1[*ip++]++;

	sub	r8, 4
	cmp	r8, r10
	jae	SHORT $LN5@HIST_count
	npad	3
$LL4@HIST_count:
	movzx	eax, BYTE PTR [r8]
	inc	r8
	inc	DWORD PTR [r14+rax*4]
	cmp	r8, r10
	jb	SHORT $LL4@HIST_count
$LN5@HIST_count:

; 120  : 
; 121  :     if (check) {   /* verify stats will fit into destination table */

	cmp	DWORD PTR check$[rsp], esi
	je	$LN7@HIST_count

; 122  :         U32 s; for (s=255; s>maxSymbolValue; s--) {

	cmp	ebx, r9d
	jae	$LN70@HIST_count
	mov	rdx, r12
	lea	rcx, QWORD PTR [r15+1020]
	mov	r8, r13
	sub	rdx, r15
	sub	r8, r15
	mov	r10, r14
	sub	r10, r15
	npad	1
$LL8@HIST_count:

; 123  :             Counting1[s] += Counting2[s] + Counting3[s] + Counting4[s];

	mov	eax, DWORD PTR [r8+rcx]
	add	eax, DWORD PTR [rdx+rcx]
	add	eax, DWORD PTR [rcx]
	add	DWORD PTR [r10+rcx], eax

; 124  :             if (Counting1[s]) return ERROR(maxSymbolValue_tooSmall);

	jne	$LN26@HIST_count

; 122  :         U32 s; for (s=255; s>maxSymbolValue; s--) {

	dec	r9d
	sub	rcx, 4
	cmp	r9d, ebx
	ja	SHORT $LL8@HIST_count
$LN18@HIST_count:

; 129  :         for (s=0; s<=maxSymbolValue; s++) {

	lea	edx, DWORD PTR [rbx+1]
	mov	r9d, esi
	cmp	edx, 8
	jb	$LL66@HIST_count
$LN57@HIST_count:
	cmp	DWORD PTR __isa_available, 2
	mov	r9d, esi
	jl	$LL66@HIST_count
	mov	eax, ebx
	lea	rcx, QWORD PTR [rax*4]
	lea	rax, QWORD PTR [rcx+r14]
	lea	r8, QWORD PTR [rcx+rbp]
	cmp	rbp, rax
	ja	SHORT $LN35@HIST_count
	cmp	r8, r14
	jae	$LL66@HIST_count
$LN35@HIST_count:
	lea	rax, QWORD PTR [rcx+r13]
	cmp	rbp, rax
	ja	SHORT $LN36@HIST_count
	cmp	r8, r13
	jae	$LL66@HIST_count
$LN36@HIST_count:
	lea	rax, QWORD PTR [rcx+r15]
	cmp	rbp, rax
	ja	SHORT $LN37@HIST_count
	cmp	r8, r15
	jae	$LL66@HIST_count
$LN37@HIST_count:
	lea	rax, QWORD PTR [rcx+r12]
	cmp	rbp, rax
	ja	SHORT $LN38@HIST_count
	cmp	r8, r12
	jae	$LL66@HIST_count
$LN38@HIST_count:
	and	edx, 7
	mov	r8d, ebx
	sub	r8d, edx
	xorps	xmm2, xmm2
	xorps	xmm3, xmm3
	npad	13
$LL11@HIST_count:

; 130  :             count[s] = Counting1[s] + Counting2[s] + Counting3[s] + Counting4[s];

	mov	eax, r9d
	movdqu	xmm0, XMMWORD PTR [r15+rax*4]
	movdqu	xmm1, XMMWORD PTR [r12+rax*4]
	paddd	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [r13+rax*4]
	paddd	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [r14+rax*4]
	paddd	xmm1, xmm0
	movdqu	XMMWORD PTR [rbp+rax*4], xmm1
	lea	eax, DWORD PTR [r9+4]
	add	r9d, 8

; 131  :             if (count[s] > max) max = count[s];

	pmaxud	xmm2, xmm1
	movdqu	xmm0, XMMWORD PTR [r15+rax*4]
	movdqu	xmm1, XMMWORD PTR [r12+rax*4]
	paddd	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [r13+rax*4]
	paddd	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [r14+rax*4]
	paddd	xmm1, xmm0
	pmaxud	xmm3, xmm1
	movdqu	XMMWORD PTR [rbp+rax*4], xmm1
	cmp	r9d, r8d
	jbe	SHORT $LL11@HIST_count

; 129  :         for (s=0; s<=maxSymbolValue; s++) {

	pmaxud	xmm2, xmm3
	movdqa	xmm0, xmm2
	psrldq	xmm0, 8
	pmaxud	xmm2, xmm0
	movdqa	xmm0, xmm2
	psrldq	xmm0, 4
	pmaxud	xmm2, xmm0
	movd	esi, xmm2
	cmp	r9d, ebx
	ja	SHORT $LN25@HIST_count
	npad	6
$LL66@HIST_count:

; 130  :             count[s] = Counting1[s] + Counting2[s] + Counting3[s] + Counting4[s];

	mov	eax, r9d
	lea	r8, QWORD PTR [rax*4]
	mov	edx, DWORD PTR [r8+r12]
	add	edx, DWORD PTR [r8+r15]
	add	edx, DWORD PTR [r8+r13]
	add	edx, DWORD PTR [r8+r14]
	cmp	edx, esi
	mov	DWORD PTR [r8+rbp], edx
	cmovbe	edx, esi
	inc	r9d
	mov	esi, edx
	cmp	r9d, ebx
	jbe	SHORT $LL66@HIST_count
$LN25@HIST_count:

; 132  :     }   }
; 133  : 
; 134  :     while (!count[maxSymbolValue]) maxSymbolValue--;

	mov	eax, ebx
	cmp	DWORD PTR [rbp+rax*4], 0
	jne	SHORT $LN13@HIST_count
$LL12@HIST_count:
	dec	ebx
	cmp	DWORD PTR [rbp+rbx*4], 0
	je	SHORT $LL12@HIST_count
$LN13@HIST_count:

; 135  :     *maxSymbolValuePtr = maxSymbolValue;

	mov	rax, QWORD PTR maxSymbolValuePtr$[rsp]
	mov	DWORD PTR [rax], ebx

; 136  :     return (size_t)max;

	mov	eax, esi
$LN1@HIST_count:

; 137  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN26@HIST_count:

; 124  :             if (Counting1[s]) return ERROR(maxSymbolValue_tooSmall);

	mov	rax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN1@HIST_count
$LN7@HIST_count:

; 125  :     }   }
; 126  : 
; 127  :     {   U32 s;
; 128  :         if (maxSymbolValue > 255) maxSymbolValue = 255;

	cmp	ebx, r9d
$LN70@HIST_count:
	jbe	$LN18@HIST_count
	mov	ebx, r9d
	mov	edx, 256				; 00000100H
	jmp	$LN57@HIST_count
HIST_count_parallel_wksp ENDP
_TEXT	ENDS
END
