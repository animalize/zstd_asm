; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ZSTD_compressRleLiteralsBlock
PUBLIC	ZSTD_noCompressLiterals
PUBLIC	ZSTD_compressLiterals
pdata	SEGMENT
$pdata$ZSTD_noCompressLiterals DD imagerel $LN12
	DD	imagerel $LN12+161
	DD	imagerel $unwind$ZSTD_noCompressLiterals
$pdata$ZSTD_compressLiterals DD imagerel $LN41
	DD	imagerel $LN41+931
	DD	imagerel $unwind$ZSTD_compressLiterals
xdata	SEGMENT
$unwind$ZSTD_noCompressLiterals DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTD_compressLiterals DD 0a1401H
	DD	0163414H
	DD	0f010d214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
_TEXT	SEGMENT
prevHuf$ = 176
nextHuf$ = 184
repeat$1 = 192
strategy$ = 192
singleStream$1$ = 200
disableLiteralCompression$ = 200
minGain$1$ = 208
dst$ = 208
dstCapacity$ = 216
src$ = 224
srcSize$ = 232
entropyWorkspace$ = 240
entropyWorkspaceSize$dead$ = 248
bmi2$dead$ = 256
ZSTD_compressLiterals PROC

; 77   : {

$LN41:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	r14, QWORD PTR dst$[rsp]
	mov	rdi, rcx
	mov	r12, QWORD PTR dstCapacity$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	lea	ecx, DWORD PTR [r8-1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 77   : {

	mov	r11d, r9d
	mov	r10d, r8d
	mov	rbx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	mov	r13d, 6
	cmp	r8d, 8
	jge	SHORT $LN25@ZSTD_compr
	mov	ecx, r13d
$LN25@ZSTD_compr:

; 399  :     return (srcSize >> minlog) + 2;

	mov	rbp, QWORD PTR srcSize$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 79   :     size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);

	xor	r9d, r9d
	mov	r15d, r9d

; 80   :     BYTE*  const ostart = (BYTE*)dst;
; 81   :     U32 singleStream = srcSize < 256;

	mov	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 399  :     return (srcSize >> minlog) + 2;

	mov	rax, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 89   :     memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	mov	esi, 8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 399  :     return (srcSize >> minlog) + 2;

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 89   :     memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	mov	edx, esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 399  :     return (srcSize >> minlog) + 2;

	add	rax, 2
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 89   :     memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	mov	rcx, rbx
	cmp	rbp, 16384				; 00004000H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 399  :     return (srcSize >> minlog) + 2;

	mov	QWORD PTR minGain$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 79   :     size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);

	setae	r15b
	cmp	rbp, 1024				; 00000400H
	sbb	rax, rax
	add	rax, 4
	add	r15, rax

; 89   :     memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	mov	rax, rdi
	cmp	rbp, 256				; 00000100H
	setb	r8b
	mov	DWORD PTR singleStream$1$[rsp], r8d
$LL37@ZSTD_compr:
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx-128], xmm0
	movups	xmm1, XMMWORD PTR [rax-112]
	movups	XMMWORD PTR [rcx-112], xmm1
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx-96], xmm0
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx-80], xmm1
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx-48], xmm1
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx-32], xmm0
	movups	xmm1, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL37@ZSTD_compr
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 90   : 
; 91   :     if (disableLiteralCompression)

	test	r11d, r11d
	jne	$LN39@ZSTD_compr

; 92   :         return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);
; 93   : 
; 94   :     /* small ? don't even attempt compression (speed opt) */
; 95   : #   define COMPRESS_LITERALS_SIZE_MIN 63
; 96   :     {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;

	mov	ecx, DWORD PTR [rdi+1024]
	mov	eax, 63					; 0000003fH
	cmp	ecx, 2
	cmove	rax, r13

; 97   :         if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);

	cmp	rbp, rax
	jbe	$LN39@ZSTD_compr

; 98   :     }
; 99   : 
; 100  :     RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, "not enough space for compression");

	lea	rax, QWORD PTR [r15+1]
	cmp	r12, rax
	jae	SHORT $LN6@ZSTD_compr
	lea	rax, QWORD PTR [rdx-70]
	jmp	$LN1@ZSTD_compr
$LN6@ZSTD_compr:

; 101  :     {   HUF_repeat repeat = prevHuf->repeatMode;

	mov	DWORD PTR repeat$1[rsp], ecx

; 102  :         int const preferRepeat = strategy < ZSTD_lazy ? srcSize <= 1024 : 0;

	mov	eax, r9d
	cmp	r10d, 4
	jge	SHORT $LN19@ZSTD_compr
	cmp	rbp, 1024				; 00000400H
	setbe	al
$LN19@ZSTD_compr:

; 103  :         if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;

	mov	r13d, 1
	cmp	ecx, 2
	jne	SHORT $LN8@ZSTD_compr
	cmp	r15, 3
	jne	SHORT $LN8@ZSTD_compr
	mov	rdx, r12
	mov	DWORD PTR singleStream$1$[rsp], r13d
	sub	rdx, r15
	lea	rcx, QWORD PTR [r14+r15]
	jmp	SHORT $LN34@ZSTD_compr
$LN8@ZSTD_compr:

; 104  :         cLitSize = singleStream ?

	mov	rdx, r12
	lea	rcx, QWORD PTR [r15+r14]
	sub	rdx, r15
	test	r8d, r8d
	je	SHORT $LN20@ZSTD_compr
$LN34@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 744  :     return HUF_compress_internal(dst, dstSize, src, srcSize,

	mov	DWORD PTR [rsp+88], eax
	lea	rax, QWORD PTR repeat$1[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR entropyWorkspace$[rsp]
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 104  :         cLitSize = singleStream ?

	jmp	SHORT $LN38@ZSTD_compr
$LN20@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 781  :     return HUF_compress_internal(dst, dstSize, src, srcSize,

	mov	DWORD PTR [rsp+88], eax
	lea	rax, QWORD PTR repeat$1[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR entropyWorkspace$[rsp]
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r13d
$LN38@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 113  :         if (repeat != HUF_repeat_none) {

	mov	r8, QWORD PTR src$[rsp]
	mov	r9, rbp
	call	HUF_compress_internal
	cmp	DWORD PTR repeat$1[rsp], 0
	mov	rdx, rax
	mov	eax, 3
	mov	r8d, 2
	cmovne	r8d, eax

; 120  :     if ((cLitSize==0) | (cLitSize >= srcSize - minGain) | ERR_isError(cLitSize)) {

	xor	r9d, r9d
	mov	ecx, r9d
	mov	rax, rbp
	sub	rax, QWORD PTR minGain$1$[rsp]
	cmp	rdx, rax
	setae	cl
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdx, -120				; ffffffffffffff88H
	seta	r9b
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 120  :     if ((cLitSize==0) | (cLitSize >= srcSize - minGain) | ERR_isError(cLitSize)) {

	or	ecx, r9d
	test	rdx, rdx
	cmove	ecx, r13d
	test	ecx, ecx
	je	SHORT $LN10@ZSTD_compr
$LL36@ZSTD_compr:

; 121  :         memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	lea	rbx, QWORD PTR [rbx+128]
	movups	xmm0, XMMWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+128]
	movups	XMMWORD PTR [rbx-128], xmm0
	movups	xmm1, XMMWORD PTR [rdi-112]
	movups	XMMWORD PTR [rbx-112], xmm1
	movups	xmm0, XMMWORD PTR [rdi-96]
	movups	XMMWORD PTR [rbx-96], xmm0
	movups	xmm1, XMMWORD PTR [rdi-80]
	movups	XMMWORD PTR [rbx-80], xmm1
	movups	xmm0, XMMWORD PTR [rdi-64]
	movups	XMMWORD PTR [rbx-64], xmm0
	movups	xmm1, XMMWORD PTR [rdi-48]
	movups	XMMWORD PTR [rbx-48], xmm1
	movups	xmm0, XMMWORD PTR [rdi-32]
	movups	XMMWORD PTR [rbx-32], xmm0
	movups	xmm1, XMMWORD PTR [rdi-16]
	movups	XMMWORD PTR [rbx-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL36@ZSTD_compr
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx], eax
$LN39@ZSTD_compr:

; 158  : }

	mov	r8, QWORD PTR src$[rsp]
	mov	r9, rbp
	mov	rdx, r12
	mov	rcx, r14
	call	ZSTD_noCompressLiterals
	jmp	$LN1@ZSTD_compr
$LN10@ZSTD_compr:

; 122  :         return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);
; 123  :     }
; 124  :     if (cLitSize==1) {

	cmp	rdx, 1
	jne	SHORT $LN11@ZSTD_compr
	npad	2
$LL35@ZSTD_compr:

; 125  :         memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	lea	rbx, QWORD PTR [rbx+128]
	movups	xmm0, XMMWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+128]
	movups	XMMWORD PTR [rbx-128], xmm0
	movups	xmm1, XMMWORD PTR [rdi-112]
	movups	XMMWORD PTR [rbx-112], xmm1
	movups	xmm0, XMMWORD PTR [rdi-96]
	movups	XMMWORD PTR [rbx-96], xmm0
	movups	xmm1, XMMWORD PTR [rdi-80]
	movups	XMMWORD PTR [rbx-80], xmm1
	movups	xmm0, XMMWORD PTR [rdi-64]
	movups	XMMWORD PTR [rbx-64], xmm0
	movups	xmm1, XMMWORD PTR [rdi-48]
	movups	XMMWORD PTR [rbx-48], xmm1
	movups	xmm0, XMMWORD PTR [rdi-32]
	movups	XMMWORD PTR [rbx-32], xmm0
	movups	xmm1, XMMWORD PTR [rdi-16]
	movups	XMMWORD PTR [rbx-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL35@ZSTD_compr
	mov	eax, DWORD PTR [rdi]

; 126  :         return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);

	mov	r9, rbp
	mov	r8, QWORD PTR src$[rsp]
	mov	rcx, r14
	mov	DWORD PTR [rbx], eax
	call	ZSTD_compressRleLiteralsBlock
	jmp	SHORT $LN1@ZSTD_compr
$LN11@ZSTD_compr:

; 127  :     }
; 128  : 
; 129  :     if (hType == set_compressed) {

	cmp	r8d, 2
	jne	SHORT $LN12@ZSTD_compr

; 130  :         /* using a newly constructed table */
; 131  :         nextHuf->repeatMode = HUF_repeat_check;

	mov	DWORD PTR [rbx+1024], r13d
$LN12@ZSTD_compr:

; 132  :     }
; 133  : 
; 134  :     /* Build header */
; 135  :     switch(lhSize)

	mov	rax, r15
	sub	rax, 3
	je	SHORT $LN13@ZSTD_compr
	sub	rax, 1
	je	SHORT $LN14@ZSTD_compr
	cmp	rax, 1
	jne	SHORT $LN16@ZSTD_compr

; 146  :         }
; 147  :     case 5: /* 2 - 2 - 18 - 18 */
; 148  :         {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);

	mov	eax, edx
	shl	eax, 18
	add	eax, ebp
	shl	eax, 4
	add	eax, 12
	add	eax, r8d

; 149  :             MEM_writeLE32(ostart, lhc);

	mov	DWORD PTR [r14], eax

; 150  :             ostart[4] = (BYTE)(cLitSize >> 10);

	mov	rax, rdx
	shr	rax, 10
	mov	BYTE PTR [r14+4], al

; 151  :             break;

	jmp	SHORT $LN16@ZSTD_compr
$LN14@ZSTD_compr:

; 139  :             MEM_writeLE24(ostart, lhc);
; 140  :             break;
; 141  :         }
; 142  :     case 4: /* 2 - 2 - 14 - 14 */
; 143  :         {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);

	mov	eax, edx
	shl	eax, 14
	add	eax, ebp
	shl	eax, 4
	add	eax, esi
	add	eax, r8d

; 144  :             MEM_writeLE32(ostart, lhc);

	mov	DWORD PTR [r14], eax

; 145  :             break;

	jmp	SHORT $LN16@ZSTD_compr
$LN13@ZSTD_compr:

; 136  :     {
; 137  :     case 3: /* 2 - 2 - 10 - 10 */
; 138  :         {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);

	mov	ecx, DWORD PTR singleStream$1$[rsp]
	mov	eax, edx
	shl	eax, 10
	xor	ecx, 1
	add	eax, ebp
	shl	eax, 4
	add	eax, r8d
	lea	ecx, DWORD PTR [rax+rcx*4]
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [r14], cx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	ecx, 16
	mov	BYTE PTR [r14+2], cl
$LN16@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c

; 157  :     return lhSize+cLitSize;

	lea	rax, QWORD PTR [rdx+r15]
$LN1@ZSTD_compr:

; 158  : }

	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write16 PROC

; 259  :     memcpy(memPtr, &value, sizeof(value));

	mov	WORD PTR [rcx], dx

; 260  : }

	ret	0
MEM_write16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE16 PROC

; 330  :     if (MEM_isLittleEndian()) {
; 331  :         MEM_write16(memPtr, val);

	mov	WORD PTR [rcx], dx

; 332  :     } else {
; 333  :         BYTE* p = (BYTE*)memPtr;
; 334  :         p[0] = (BYTE)val;
; 335  :         p[1] = (BYTE)(val>>8);
; 336  :     }
; 337  : }

	ret	0
MEM_writeLE16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE24 PROC

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rcx], dx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	edx, 16
	mov	BYTE PTR [rcx+2], dl

; 348  : }

	ret	0
MEM_writeLE24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
srcSize$ = 8
strat$ = 16
ZSTD_minGain PROC

; 395  : {

	mov	rax, rcx

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	lea	ecx, DWORD PTR [rdx-1]
	cmp	edx, 8
	jge	SHORT $LN4@ZSTD_minGa
	mov	ecx, 6
$LN4@ZSTD_minGa:

; 397  :     ZSTD_STATIC_ASSERT(ZSTD_btultra == 8);
; 398  :     assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));
; 399  :     return (srcSize >> minlog) + 2;

	shr	rax, cl
	add	rax, 2

; 400  : }

	ret	0
ZSTD_minGain ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
src$ = 64
srcSize$ = 72
ZSTD_noCompressLiterals PROC

; 17   : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 18   :     BYTE* const ostart = (BYTE* const)dst;
; 19   :     U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);

	xor	eax, eax
	mov	rdi, r8
	mov	r10d, eax
	cmp	r9, 4095				; 00000fffH
	mov	r11, rcx
	seta	r10b
	cmp	r9, 31
	seta	al
	inc	eax
	add	r10d, eax

; 20   : 
; 21   :     RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, "");

	mov	r8d, r10d
	lea	rbx, QWORD PTR [r10+r9]
	cmp	rbx, rdx
	jbe	SHORT $LN4@ZSTD_noCom
	mov	rax, -70				; ffffffffffffffbaH

; 41   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@ZSTD_noCom:

; 22   : 
; 23   :     switch(flSize)

	sub	r10d, 1
	je	SHORT $LN6@ZSTD_noCom
	sub	r10d, 1
	je	SHORT $LN7@ZSTD_noCom
	cmp	r10d, 1
	jne	SHORT $LN9@ZSTD_noCom

; 31   :         case 3: /* 2 - 2 - 20 */
; 32   :             MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));

	mov	rax, r9
	shl	rax, 4
	add	eax, 12
	mov	DWORD PTR [rcx], eax

; 33   :             break;

	jmp	SHORT $LN9@ZSTD_noCom
$LN7@ZSTD_noCom:

; 27   :             break;
; 28   :         case 2: /* 2 - 2 - 12 */
; 29   :             MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));

	mov	rax, r9
	shl	rax, 4
	add	ax, 4
	mov	WORD PTR [rcx], ax

; 30   :             break;

	jmp	SHORT $LN9@ZSTD_noCom
$LN6@ZSTD_noCom:

; 24   :     {
; 25   :         case 1: /* 2 - 1 - 5 */
; 26   :             ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));

	movzx	ecx, r9b
	shl	cl, 3
	mov	BYTE PTR [r11], cl
$LN9@ZSTD_noCom:

; 34   :         default:   /* not necessary : flSize is {1,2,3} */
; 35   :             assert(0);
; 36   :     }
; 37   : 
; 38   :     memcpy(ostart + flSize, src, srcSize);

	lea	rcx, QWORD PTR [r8+r11]
	mov	rdx, rdi
	mov	r8, r9
	call	memcpy

; 39   :     DEBUGLOG(5, "Raw literals: %u -> %u", (U32)srcSize, (U32)(srcSize + flSize));
; 40   :     return srcSize + flSize;

	mov	rax, rbx

; 41   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_noCompressLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_literals.c
_TEXT	SEGMENT
dst$ = 8
dstCapacity$dead$ = 16
src$ = 24
srcSize$ = 32
ZSTD_compressRleLiteralsBlock PROC

; 45   :     BYTE* const ostart = (BYTE* const)dst;
; 46   :     U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);

	xor	eax, eax
	mov	r10d, eax
	cmp	r9, 4095				; 00000fffH
	seta	r10b
	cmp	r9, 31
	seta	al
	inc	eax
	add	r10d, eax

; 47   : 
; 48   :     (void)dstCapacity;  /* dstCapacity already guaranteed to be >=4, hence large enough */
; 49   : 
; 50   :     switch(flSize)

	mov	eax, r10d
	sub	eax, 1
	je	SHORT $LN4@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN5@ZSTD_compr
	cmp	eax, 1
	jne	SHORT $LN7@ZSTD_compr

; 57   :             break;
; 58   :         case 3: /* 2 - 2 - 20 */
; 59   :             MEM_writeLE32(ostart, (U32)((U32)set_rle + (3<<2) + (srcSize<<4)));

	shl	r9, 4
	add	r9d, 13
	mov	DWORD PTR [rcx], r9d

; 60   :             break;
; 61   :         default:   /* not necessary : flSize is {1,2,3} */
; 62   :             assert(0);
; 63   :     }
; 64   : 
; 65   :     ostart[flSize] = *(const BYTE*)src;

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r10+rcx], al

; 66   :     DEBUGLOG(5, "RLE literals: %u -> %u", (U32)srcSize, (U32)flSize + 1);
; 67   :     return flSize+1;

	lea	eax, DWORD PTR [r10+1]

; 68   : }

	ret	0
$LN5@ZSTD_compr:

; 54   :             break;
; 55   :         case 2: /* 2 - 2 - 12 */
; 56   :             MEM_writeLE16(ostart, (U16)((U32)set_rle + (1<<2) + (srcSize<<4)));

	shl	r9, 4
	add	r9w, 5
	mov	WORD PTR [rcx], r9w

; 60   :             break;
; 61   :         default:   /* not necessary : flSize is {1,2,3} */
; 62   :             assert(0);
; 63   :     }
; 64   : 
; 65   :     ostart[flSize] = *(const BYTE*)src;

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r10+rcx], al

; 66   :     DEBUGLOG(5, "RLE literals: %u -> %u", (U32)srcSize, (U32)flSize + 1);
; 67   :     return flSize+1;

	lea	eax, DWORD PTR [r10+1]

; 68   : }

	ret	0
$LN4@ZSTD_compr:

; 51   :     {
; 52   :         case 1: /* 2 - 1 - 5 */
; 53   :             ostart[0] = (BYTE)((U32)set_rle + (srcSize<<3));

	shl	r9b, 3
	inc	r9b
	mov	BYTE PTR [rcx], r9b
$LN7@ZSTD_compr:

; 60   :             break;
; 61   :         default:   /* not necessary : flSize is {1,2,3} */
; 62   :             assert(0);
; 63   :     }
; 64   : 
; 65   :     ostart[flSize] = *(const BYTE*)src;

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r10+rcx], al

; 66   :     DEBUGLOG(5, "RLE literals: %u -> %u", (U32)srcSize, (U32)flSize + 1);
; 67   :     return flSize+1;

	lea	eax, DWORD PTR [r10+1]

; 68   : }

	ret	0
ZSTD_compressRleLiteralsBlock ENDP
_TEXT	ENDS
END
