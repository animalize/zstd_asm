; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

LL_defaultNormLog DD 06H
OF_defaultNormLog DD 05H
ML_defaultNormLog DD 06H
LL_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
OF_defaultNorm DW 01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	ORG $+6
ML_defaultNorm DW 01H
	DW	04H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	ORG $+6
ML_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
ZSTD_blockHeaderSize DQ 0000000000000003H
LL_defaultNorm DW 04H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
PUBLIC	ZSTD_compressSuperBlock
pdata	SEGMENT
$pdata$ZSTD_compressSubBlock_multi DD imagerel ZSTD_compressSubBlock_multi
	DD	imagerel ZSTD_compressSubBlock_multi+1577
	DD	imagerel $unwind$ZSTD_compressSubBlock_multi
$pdata$ZSTD_estimateSubBlockSize DD imagerel ZSTD_estimateSubBlockSize
	DD	imagerel ZSTD_estimateSubBlockSize+309
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize
$pdata$ZSTD_estimateSubBlockSize_sequences DD imagerel ZSTD_estimateSubBlockSize_sequences
	DD	imagerel ZSTD_estimateSubBlockSize_sequences+21
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_sequences
$pdata$5$ZSTD_estimateSubBlockSize_sequences DD imagerel ZSTD_estimateSubBlockSize_sequences+21
	DD	imagerel ZSTD_estimateSubBlockSize_sequences+1001
	DD	imagerel $chain$5$ZSTD_estimateSubBlockSize_sequences
$pdata$6$ZSTD_estimateSubBlockSize_sequences DD imagerel ZSTD_estimateSubBlockSize_sequences+1001
	DD	imagerel ZSTD_estimateSubBlockSize_sequences+1020
	DD	imagerel $chain$6$ZSTD_estimateSubBlockSize_sequences
$pdata$ZSTD_estimateSubBlockSize_symbolType DD imagerel ZSTD_estimateSubBlockSize_symbolType
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType+143
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_symbolType
$pdata$0$ZSTD_estimateSubBlockSize_symbolType DD imagerel ZSTD_estimateSubBlockSize_symbolType+143
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType+214
	DD	imagerel $chain$0$ZSTD_estimateSubBlockSize_symbolType
$pdata$1$ZSTD_estimateSubBlockSize_symbolType DD imagerel ZSTD_estimateSubBlockSize_symbolType+214
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType+338
	DD	imagerel $chain$1$ZSTD_estimateSubBlockSize_symbolType
$pdata$ZSTD_estimateSubBlockSize_literal DD imagerel ZSTD_estimateSubBlockSize_literal
	DD	imagerel ZSTD_estimateSubBlockSize_literal+198
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_literal
$pdata$ZSTD_compressSubBlock DD imagerel ZSTD_compressSubBlock
	DD	imagerel ZSTD_compressSubBlock+124
	DD	imagerel $unwind$ZSTD_compressSubBlock
$pdata$0$ZSTD_compressSubBlock DD imagerel ZSTD_compressSubBlock+124
	DD	imagerel ZSTD_compressSubBlock+626
	DD	imagerel $chain$0$ZSTD_compressSubBlock
$pdata$1$ZSTD_compressSubBlock DD imagerel ZSTD_compressSubBlock+626
	DD	imagerel ZSTD_compressSubBlock+646
	DD	imagerel $chain$1$ZSTD_compressSubBlock
$pdata$ZSTD_compressSubBlock_sequences DD imagerel ZSTD_compressSubBlock_sequences
	DD	imagerel ZSTD_compressSubBlock_sequences+203
	DD	imagerel $unwind$ZSTD_compressSubBlock_sequences
$pdata$1$ZSTD_compressSubBlock_sequences DD imagerel ZSTD_compressSubBlock_sequences+203
	DD	imagerel ZSTD_compressSubBlock_sequences+467
	DD	imagerel $chain$1$ZSTD_compressSubBlock_sequences
$pdata$2$ZSTD_compressSubBlock_sequences DD imagerel ZSTD_compressSubBlock_sequences+467
	DD	imagerel ZSTD_compressSubBlock_sequences+488
	DD	imagerel $chain$2$ZSTD_compressSubBlock_sequences
$pdata$ZSTD_seqDecompressedSize DD imagerel ZSTD_seqDecompressedSize
	DD	imagerel ZSTD_seqDecompressedSize+31
	DD	imagerel $unwind$ZSTD_seqDecompressedSize
$pdata$0$ZSTD_seqDecompressedSize DD imagerel ZSTD_seqDecompressedSize+31
	DD	imagerel ZSTD_seqDecompressedSize+112
	DD	imagerel $chain$0$ZSTD_seqDecompressedSize
$pdata$1$ZSTD_seqDecompressedSize DD imagerel ZSTD_seqDecompressedSize+112
	DD	imagerel ZSTD_seqDecompressedSize+118
	DD	imagerel $chain$1$ZSTD_seqDecompressedSize
$pdata$ZSTD_compressSubBlock_literal DD imagerel ZSTD_compressSubBlock_literal
	DD	imagerel ZSTD_compressSubBlock_literal+534
	DD	imagerel $unwind$ZSTD_compressSubBlock_literal
$pdata$ZSTD_buildSuperBlockEntropy DD imagerel ZSTD_buildSuperBlockEntropy
	DD	imagerel ZSTD_buildSuperBlockEntropy+243
	DD	imagerel $unwind$ZSTD_buildSuperBlockEntropy
$pdata$ZSTD_buildSuperBlockEntropy_sequences DD imagerel ZSTD_buildSuperBlockEntropy_sequences
	DD	imagerel ZSTD_buildSuperBlockEntropy_sequences+2575
	DD	imagerel $unwind$ZSTD_buildSuperBlockEntropy_sequences
$pdata$ZSTD_buildSuperBlockEntropy_literal DD imagerel ZSTD_buildSuperBlockEntropy_literal
	DD	imagerel ZSTD_buildSuperBlockEntropy_literal+926
	DD	imagerel $unwind$ZSTD_buildSuperBlockEntropy_literal
$pdata$ZSTD_noCompressBlock DD imagerel ZSTD_noCompressBlock
	DD	imagerel ZSTD_noCompressBlock+76
	DD	imagerel $unwind$ZSTD_noCompressBlock
$pdata$ZSTD_compressSuperBlock DD imagerel $LN40
	DD	imagerel $LN40+381
	DD	imagerel $unwind$ZSTD_compressSuperBlock
xdata	SEGMENT
$unwind$ZSTD_compressSubBlock_multi DD 0b2a19H
	DD	037341cH
	DD	02e011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$ZSTD_estimateSubBlockSize DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
$unwind$ZSTD_estimateSubBlockSize_sequences DD 030a01H
	DD	0d006a20aH
	DD	07004H
$chain$5$ZSTD_estimateSubBlockSize_sequences DD 0c3221H
	DD	06f432H
	DD	07e42bH
	DD	08c424H
	DD	09641eH
	DD	0a540aH
	DD	0103404H
	DD	imagerel ZSTD_estimateSubBlockSize_sequences
	DD	imagerel ZSTD_estimateSubBlockSize_sequences+21
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_sequences
$chain$6$ZSTD_estimateSubBlockSize_sequences DD 021H
	DD	imagerel ZSTD_estimateSubBlockSize_sequences
	DD	imagerel ZSTD_estimateSubBlockSize_sequences+21
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_sequences
$unwind$ZSTD_estimateSubBlockSize_symbolType DD 081001H
	DD	0e3410H
	DD	0f00c5210H
	DD	07008e00aH
	DD	050066007H
$chain$0$ZSTD_estimateSubBlockSize_symbolType DD 020521H
	DD	0dc405H
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType+143
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_symbolType
$chain$1$ZSTD_estimateSubBlockSize_symbolType DD 021H
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType
	DD	imagerel ZSTD_estimateSubBlockSize_symbolType+143
	DD	imagerel $unwind$ZSTD_estimateSubBlockSize_symbolType
$unwind$ZSTD_estimateSubBlockSize_literal DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
$unwind$ZSTD_compressSubBlock DD 081501H
	DD	0133415H
	DD	0f011b215H
	DD	0700dd00fH
	DD	0500b600cH
$chain$0$ZSTD_compressSubBlock DD 020821H
	DD	012e408H
	DD	imagerel ZSTD_compressSubBlock
	DD	imagerel ZSTD_compressSubBlock+124
	DD	imagerel $unwind$ZSTD_compressSubBlock
$chain$1$ZSTD_compressSubBlock DD 021H
	DD	imagerel ZSTD_compressSubBlock
	DD	imagerel ZSTD_compressSubBlock+124
	DD	imagerel $unwind$ZSTD_compressSubBlock
$unwind$ZSTD_compressSubBlock_sequences DD 088001H
	DD	0123480H
	DD	0f00db211H
	DD	0c009d00bH
	DD	060067007H
$chain$1$ZSTD_compressSubBlock_sequences DD 020821H
	DD	013e408H
	DD	imagerel ZSTD_compressSubBlock_sequences
	DD	imagerel ZSTD_compressSubBlock_sequences+203
	DD	imagerel $unwind$ZSTD_compressSubBlock_sequences
$chain$2$ZSTD_compressSubBlock_sequences DD 021H
	DD	imagerel ZSTD_compressSubBlock_sequences
	DD	imagerel ZSTD_compressSubBlock_sequences+203
	DD	imagerel $unwind$ZSTD_compressSubBlock_sequences
$unwind$ZSTD_seqDecompressedSize DD 010201H
	DD	07002H
$chain$0$ZSTD_seqDecompressedSize DD 020521H
	DD	023405H
	DD	imagerel ZSTD_seqDecompressedSize
	DD	imagerel ZSTD_seqDecompressedSize+31
	DD	imagerel $unwind$ZSTD_seqDecompressedSize
$chain$1$ZSTD_seqDecompressedSize DD 021H
	DD	imagerel ZSTD_seqDecompressedSize
	DD	imagerel ZSTD_seqDecompressedSize+31
	DD	imagerel $unwind$ZSTD_seqDecompressedSize
$unwind$ZSTD_compressSubBlock_literal DD 0a1e01H
	DD	010341eH
	DD	0f01a521eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_buildSuperBlockEntropy DD 0c1e01H
	DD	0f741eH
	DD	0e641eH
	DD	0d541eH
	DD	0c341eH
	DD	0f01a721eH
	DD	0d016e018H
$unwind$ZSTD_buildSuperBlockEntropy_sequences DD 0a1d01H
	DD	019011dH
	DD	0e014f016H
	DD	0c010d012H
	DD	0600d700eH
	DD	0300b500cH
$unwind$ZSTD_buildSuperBlockEntropy_literal DD 0c1c01H
	DD	0f641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$ZSTD_noCompressBlock DD 020601H
	DD	030023206H
$unwind$ZSTD_compressSuperBlock DD 0a2619H
	DD	0950114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0490H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
src$GSCopy$1$ = 112
entropyMetadata$ = 128
__$ArrayPad$ = 1168
zc$ = 1264
dst$ = 1272
dstCapacity$ = 1280
src$ = 1288
srcSize$ = 1296
lastBlock$ = 1304
ZSTD_compressSuperBlock PROC

; 826  :                                unsigned lastBlock) {

$LN40:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 1192				; 000004a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	mov	r10, QWORD PTR [rcx+584]

; 827  :     ZSTD_entropyCTablesMetadata_t entropyMetadata;
; 828  : 
; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	lea	rbx, QWORD PTR [rcx+160]
	mov	rbp, QWORD PTR [rcx+992]
	mov	r12, rdx

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	mov	rdx, QWORD PTR [rcx+592]

; 826  :                                unsigned lastBlock) {

	mov	rdi, rcx

; 827  :     ZSTD_entropyCTablesMetadata_t entropyMetadata;
; 828  : 
; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	mov	r14, QWORD PTR [rcx+768]

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	sub	rdx, r10

; 827  :     ZSTD_entropyCTablesMetadata_t entropyMetadata;
; 828  : 
; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	mov	r15, QWORD PTR [rcx+760]
	mov	r13, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	mov	ecx, DWORD PTR [rbx+72]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 826  :                                unsigned lastBlock) {

	mov	QWORD PTR src$GSCopy$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	test	ecx, ecx
	je	SHORT $LN25@ZSTD_compr
	sub	ecx, 1
	je	SHORT $LN28@ZSTD_compr
	cmp	ecx, 1
	je	SHORT $LN36@ZSTD_compr
$LN25@ZSTD_compr:

; 405  :     case ZSTD_lcm_huffman:
; 406  :         return 0;
; 407  :     case ZSTD_lcm_uncompressed:
; 408  :         return 1;
; 409  :     default:
; 410  :         assert(0 /* impossible: pre-validated */);
; 411  :         /* fall-through */
; 412  :     case ZSTD_lcm_auto:
; 413  :         return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);

	cmp	DWORD PTR [rbx+28], 1
	jne	SHORT $LN28@ZSTD_compr
	cmp	DWORD PTR [rbx+24], 0
	jbe	SHORT $LN28@ZSTD_compr
$LN36@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 283  :     entropyMetadata->hufMetadata.hufDesSize =

	mov	eax, 1
	jmp	SHORT $LN29@ZSTD_compr
$LN28@ZSTD_compr:
	xor	eax, eax
$LN29@ZSTD_compr:
	mov	QWORD PTR [rsp+48], rbp
	mov	r9, r14
	mov	DWORD PTR [rsp+40], eax
	mov	r8, r15
	lea	rax, QWORD PTR entropyMetadata$[rsp]
	mov	rcx, r10
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_buildSuperBlockEntropy_literal
	mov	QWORD PTR entropyMetadata$[rsp+504], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 289  :     FORWARD_IF_ERROR(entropyMetadata->hufMetadata.hufDesSize, "ZSTD_buildSuperBlockEntropy_literal failed");

	ja	$LN1@ZSTD_compr

; 290  :     entropyMetadata->fseMetadata.fseTablesSize =

	lea	rax, QWORD PTR entropyMetadata$[rsp+512]
	mov	QWORD PTR [rsp+40], rbp
	lea	r8, QWORD PTR [r14+1028]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r15+1028]
	mov	r9, rbx
	lea	rcx, QWORD PTR [rdi+568]
	call	ZSTD_buildSuperBlockEntropy_sequences
	mov	QWORD PTR entropyMetadata$[rsp+1024], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 296  :     FORWARD_IF_ERROR(entropyMetadata->fseMetadata.fseTablesSize, "ZSTD_buildSuperBlockEntropy_sequences failed");

	ja	SHORT $LN1@ZSTD_compr

; 830  :           &zc->blockState.prevCBlock->entropy,
; 831  :           &zc->blockState.nextCBlock->entropy,
; 832  :           &zc->appliedParams,
; 833  :           &entropyMetadata,
; 834  :           zc->entropyWorkspace, HUF_WORKSPACE_SIZE /* statically allocated in resetCCtx */), "");
; 835  : 
; 836  :     return ZSTD_compressSubBlock_multi(&zc->seqStore,

	mov	rax, QWORD PTR [rdi+992]
	lea	r9, QWORD PTR entropyMetadata$[rsp]
	mov	r8, QWORD PTR [rdi+768]
	lea	rcx, QWORD PTR [rdi+568]
	mov	rdx, QWORD PTR [rdi+760]
	mov	QWORD PTR [rsp+88], rax
	mov	eax, DWORD PTR lastBlock$[rsp]
	mov	DWORD PTR [rsp+80], eax
	mov	rax, QWORD PTR srcSize$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR src$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], r12
	mov	QWORD PTR [rsp+32], rbx
	call	ZSTD_compressSubBlock_multi
$LN1@ZSTD_compr:

; 837  :             zc->blockState.prevCBlock,
; 838  :             zc->blockState.nextCBlock,
; 839  :             &entropyMetadata,
; 840  :             &zc->appliedParams,
; 841  :             dst, dstCapacity,
; 842  :             src, srcSize,
; 843  :             zc->bmi2, lastBlock,
; 844  :             zc->entropyWorkspace, HUF_WORKSPACE_SIZE /* statically allocated in resetCCtx */);
; 845  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1192				; 000004a8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressSuperBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write16 PROC

; 259  :     memcpy(memPtr, &value, sizeof(value));

	mov	WORD PTR [rcx], dx

; 260  : }

	ret	0
MEM_write16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE16 PROC

; 330  :     if (MEM_isLittleEndian()) {
; 331  :         MEM_write16(memPtr, val);

	mov	WORD PTR [rcx], dx

; 332  :     } else {
; 333  :         BYTE* p = (BYTE*)memPtr;
; 334  :         p[0] = (BYTE)val;
; 335  :         p[1] = (BYTE)(val>>8);
; 336  :     }
; 337  : }

	ret	0
MEM_writeLE16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE24 PROC

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rcx], dx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	edx, 16
	mov	BYTE PTR [rcx+2], dl

; 348  : }

	ret	0
MEM_writeLE24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
seqStore$ = 8
seq$ = 16
ZSTD_getSequenceLength PROC

; 358  :     ZSTD_sequenceLength seqLen;
; 359  :     seqLen.litLength = seq->litLength;
; 360  :     seqLen.matchLength = seq->matchLength + MINMATCH;

	movzx	r9d, WORD PTR [rdx+6]
	movzx	r8d, WORD PTR [rdx+4]
	add	r9d, 3

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	sub	rdx, QWORD PTR [rcx]
	sar	rdx, 3
	mov	eax, r9d
	cmp	DWORD PTR [rcx+76], edx
	jne	SHORT $LN4@ZSTD_getSe

; 362  :         if (seqStore->longLengthID == 1) {

	mov	ecx, DWORD PTR [rcx+72]

; 363  :             seqLen.litLength += 0xFFFF;
; 364  :         }
; 365  :         if (seqStore->longLengthID == 2) {

	lea	eax, DWORD PTR [r8+65535]
	cmp	ecx, 1
	cmovne	eax, r8d
	mov	r8d, eax
	mov	eax, r9d
	cmp	ecx, 2
	jne	SHORT $LN4@ZSTD_getSe

; 366  :             seqLen.matchLength += 0xFFFF;

	lea	eax, DWORD PTR [r9+65535]
$LN4@ZSTD_getSe:

; 367  :         }
; 368  :     }
; 369  :     return seqLen;

	shl	rax, 32					; 00000020H
	mov	ecx, r8d
	or	rax, rcx

; 370  : }

	ret	0
ZSTD_getSequenceLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
$T1 = 8
rep$ = 16
offset$ = 24
ll0$ = 32
ZSTD_updateRep PROC

; 335  :     repcodes_t newReps;
; 336  :     if (offset >= ZSTD_REP_NUM) {  /* full offset */

	cmp	r8d, 3
	jb	SHORT $LN2@ZSTD_updat

; 337  :         newReps.rep[2] = rep[1];

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+8], eax

; 338  :         newReps.rep[1] = rep[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+4], eax

; 339  :         newReps.rep[0] = offset - ZSTD_REP_MOVE;

	lea	eax, DWORD PTR [r8-2]
	mov	DWORD PTR [rcx], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	ret	0
$LN2@ZSTD_updat:

; 340  :     } else {   /* repcode */
; 341  :         U32 const repCode = offset + ll0;

	add	r8d, r9d

; 342  :         if (repCode > 0) {  /* note : if repCode==0, no change */

	je	SHORT $LN4@ZSTD_updat

; 343  :             U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	mov	eax, DWORD PTR [rdx]
	cmp	r8d, 3
	jne	SHORT $LN7@ZSTD_updat

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	mov	r8d, DWORD PTR [rdx+4]
	lea	r9d, DWORD PTR [rax-1]

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR [rcx+4], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rcx+8], r8d
	ret	0
$LN7@ZSTD_updat:

; 343  :             U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	mov	r9d, DWORD PTR [rdx+r8*4]

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	cmp	r8d, 2
	jb	SHORT $LN9@ZSTD_updat
	mov	r8d, DWORD PTR [rdx+4]

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR [rcx+4], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	mov	DWORD PTR [rcx+8], r8d
	mov	DWORD PTR [rcx], r9d
	ret	0
$LN9@ZSTD_updat:

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	mov	r8d, DWORD PTR [rdx+8]

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR [rcx+4], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	mov	DWORD PTR [rcx+8], r8d
	mov	DWORD PTR [rcx], r9d
	ret	0
$LN4@ZSTD_updat:

; 346  :             newReps.rep[0] = currentOffset;
; 347  :         } else {   /* repCode == 0 */
; 348  :             memcpy(&newReps, rep, sizeof(newReps));

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+8], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	ret	0
ZSTD_updateRep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
src$ = 64
srcSize$ = 72
lastBlock$ = 80
ZSTD_noCompressBlock PROC

; 370  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 371  :     U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);

	lea	rax, QWORD PTR [r9*8]
	mov	r10, r8
	add	eax, DWORD PTR lastBlock$[rsp]

; 372  :     RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,

	lea	rbx, QWORD PTR [r9+3]
	cmp	rbx, rdx
	jbe	SHORT $LN2@ZSTD_noCom
	mov	rax, -70				; ffffffffffffffbaH

; 377  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@ZSTD_noCom:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rcx], ax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	r8, r9
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	eax, 16
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	rdx, r10
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [rcx+2], al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	add	rcx, 3
	call	memcpy

; 376  :     return ZSTD_blockHeaderSize + srcSize;

	mov	rax, rbx

; 377  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_noCompressBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
cctxParams$ = 8
ZSTD_disableLiteralsCompression PROC

; 404  :     switch (cctxParams->literalCompressionMode) {

	mov	edx, DWORD PTR [rcx+72]
	test	edx, edx
	je	SHORT $LN6@ZSTD_disab
	sub	edx, 1
	je	SHORT $LN9@ZSTD_disab
	cmp	edx, 1
	je	SHORT $LN11@ZSTD_disab
$LN6@ZSTD_disab:

; 405  :     case ZSTD_lcm_huffman:
; 406  :         return 0;
; 407  :     case ZSTD_lcm_uncompressed:
; 408  :         return 1;
; 409  :     default:
; 410  :         assert(0 /* impossible: pre-validated */);
; 411  :         /* fall-through */
; 412  :     case ZSTD_lcm_auto:
; 413  :         return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);

	cmp	DWORD PTR [rcx+28], 1
	jne	SHORT $LN9@ZSTD_disab
	cmp	DWORD PTR [rcx+24], 0
	jbe	SHORT $LN9@ZSTD_disab
$LN11@ZSTD_disab:

; 414  :     }
; 415  : }

	mov	eax, 1
	ret	0
$LN9@ZSTD_disab:
	xor	eax, eax
	ret	0
ZSTD_disableLiteralsCompression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
src$ = 96
srcSize$ = 104
newCSize$1$ = 112
prevHuf$ = 112
nextHuf$ = 120
hufMetadata$ = 128
maxSymbolValue$ = 136
disableLiteralsCompression$ = 136
repeat$1$ = 144
workspace$ = 144
wkspSize$dead$ = 152
ZSTD_buildSuperBlockEntropy_literal PROC

; 67   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 68   :     BYTE* const wkspStart = (BYTE*)workspace;
; 69   :     BYTE* const wkspEnd = wkspStart + wkspSize;
; 70   :     BYTE* const countWkspStart = wkspStart;
; 71   :     unsigned* const countWksp = (unsigned*)workspace;
; 72   :     const size_t countWkspSize = (HUF_SYMBOLVALUE_MAX + 1) * sizeof(unsigned);
; 73   :     BYTE* const nodeWksp = countWkspStart + countWkspSize;

	mov	r15, QWORD PTR workspace$[rsp]
	mov	rbx, r8

; 74   :     const size_t nodeWkspSize = wkspEnd-nodeWksp;
; 75   :     unsigned maxSymbolValue = 255;
; 76   :     unsigned huffLog = HUF_TABLELOG_DEFAULT;
; 77   :     HUF_repeat repeat = prevHuf->repeatMode;

	mov	r14d, DWORD PTR [r8+1024]

; 78   : 
; 79   :     DEBUGLOG(5, "ZSTD_buildSuperBlockEntropy_literal (srcSize=%zu)", srcSize);
; 80   : 
; 81   :     /* Prepare nextEntropy assuming reusing the existing table */
; 82   :     memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	mov	esi, 8
	mov	rbp, rdx
	mov	DWORD PTR repeat$1$[rsp], r14d
	mov	rdi, r9
	mov	r8, r9
	lea	r12, QWORD PTR [r15+1024]
	mov	rax, rbx
	mov	edx, esi
$LL56@ZSTD_build:
	lea	r8, QWORD PTR [r8+128]
	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [r8-128], xmm0
	movups	xmm1, XMMWORD PTR [rax-112]
	movups	XMMWORD PTR [r8-112], xmm1
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [r8-96], xmm0
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [r8-80], xmm1
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [r8-64], xmm0
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [r8-48], xmm1
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [r8-32], xmm0
	movups	xmm1, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [r8-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL56@ZSTD_build
	mov	eax, DWORD PTR [rax]

; 83   : 
; 84   :     if (disableLiteralsCompression) {

	xor	r13d, r13d
	mov	DWORD PTR [r8], eax
	cmp	DWORD PTR disableLiteralsCompression$[rsp], r13d
	jne	$LN53@ZSTD_build

; 85   :         DEBUGLOG(5, "set_basic - disabled");
; 86   :         hufMetadata->hType = set_basic;
; 87   :         return 0;
; 88   :     }
; 89   : 
; 90   :     /* small ? don't even attempt compression (speed opt) */
; 91   : #   define COMPRESS_LITERALS_SIZE_MIN 63
; 92   :     {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;

	cmp	DWORD PTR [rbx+1024], 2
	mov	eax, 63					; 0000003fH
	mov	edx, 6
	cmove	eax, edx

; 93   :         if (srcSize <= minLitSize) {

	cmp	rbp, rax
	jbe	$LN53@ZSTD_build
; File E:\dev\pyzstd\lib\compress\hist.c

; 170  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	r15b, 3
	je	SHORT $LN23@ZSTD_build
	mov	rcx, -1
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 102  :         FORWARD_IF_ERROR(largest, "HIST_count_wksp failed");

	mov	rax, rcx
	jmp	$LN1@ZSTD_build
$LN23@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\hist.c

; 174  :     *maxSymbolValuePtr = 255;

	mov	DWORD PTR maxSymbolValue$[rsp], 255	; 000000ffH

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	r8, rcx
	lea	rdx, QWORD PTR maxSymbolValue$[rsp]
	mov	rcx, r15
	mov	r9, rbp
	cmp	rbp, 1500				; 000005dcH
	jae	SHORT $LN28@ZSTD_build

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	call	HIST_count_simple
	mov	ecx, eax
	jmp	SHORT $LN27@ZSTD_build
$LN28@ZSTD_build:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], r15
	mov	DWORD PTR [rsp+32], r13d
	call	HIST_count_parallel_wksp
	mov	rcx, rax
$LN27@ZSTD_build:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rcx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 102  :         FORWARD_IF_ERROR(largest, "HIST_count_wksp failed");

	jbe	SHORT $LN2@ZSTD_build
	mov	rax, rcx
	jmp	$LN1@ZSTD_build
$LN2@ZSTD_build:

; 103  :         if (largest == srcSize) {

	cmp	rcx, rbp
	jne	SHORT $LN12@ZSTD_build

; 104  :             DEBUGLOG(5, "set_rle");
; 105  :             hufMetadata->hType = set_rle;

	mov	rax, QWORD PTR hufMetadata$[rsp]
	mov	DWORD PTR [rax], 1

; 106  :             return 0;

	jmp	$LN61@ZSTD_build
$LN12@ZSTD_build:

; 107  :         }
; 108  :         if (largest <= (srcSize >> 7)+4) {

	mov	rax, rbp
	shr	rax, 7
	add	rax, 4
	cmp	rcx, rax
	jbe	$LN53@ZSTD_build

; 116  :     if (repeat == HUF_repeat_check && !HUF_validateCTable((HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue)) {

	mov	r13d, DWORD PTR maxSymbolValue$[rsp]
	cmp	r14d, 1
	jne	SHORT $LN14@ZSTD_build
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 433  :   int bad = 0;

	xor	r11d, r11d
	mov	r8d, r11d

; 434  :   int s;
; 435  :   for (s = 0; s <= (int)maxSymbolValue; ++s) {

	test	r13d, r13d
	js	SHORT $LN14@ZSTD_build
	mov	r10, rbx
	lea	r9d, DWORD PTR [r13+1]
	sub	r10, r15
	mov	rdx, r15
	npad	13
$LL43@ZSTD_build:

; 436  :     bad |= (count[s] != 0) & (CTable[s].nbBits == 0);

	mov	ecx, r11d
	mov	eax, r11d
	cmp	BYTE PTR [r10+rdx+2], cl
	lea	rdx, QWORD PTR [rdx+4]
	sete	cl
	cmp	DWORD PTR [rdx-4], eax
	setne	al
	and	ecx, eax
	or	r8d, ecx
	sub	r9, 1
	jne	SHORT $LL43@ZSTD_build

; 437  :   }
; 438  :   return !bad;

	test	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 116  :     if (repeat == HUF_repeat_check && !HUF_validateCTable((HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue)) {

	cmovne	r14d, r11d
	mov	DWORD PTR repeat$1$[rsp], r14d
$LN14@ZSTD_build:

; 117  :         repeat = HUF_repeat_none;
; 118  :     }
; 119  : 
; 120  :     /* Build Huffman Tree */
; 121  :     memset(nextHuf->CTable, 0, sizeof(nextHuf->CTable));

	xor	edx, edx
	mov	r8d, 1024				; 00000400H
	mov	rcx, rdi
	call	memset

; 122  :     huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);

	mov	r8d, r13d
	mov	rdx, rbp
	call	HUF_optimalTableLog

; 123  :     {   size_t const maxBits = HUF_buildCTable_wksp((HUF_CElt*)nextHuf->CTable, countWksp,

	mov	r9d, eax
	mov	QWORD PTR [rsp+40], 5376		; 00001500H
	mov	rcx, rdi
	mov	QWORD PTR [rsp+32], r12
	mov	rdx, r15
	call	HUF_buildCTable_wksp
	mov	r14, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 126  :         FORWARD_IF_ERROR(maxBits, "HUF_buildCTable_wksp");

	ja	$LN1@ZSTD_build

; 127  :         huffLog = (U32)maxBits;
; 128  :         {   /* Build and write the CTable */
; 129  :             size_t const newCSize = HUF_estimateCompressedSize(

	mov	r8d, r13d
	mov	rdx, r15
	mov	rcx, rdi
	call	HUF_estimateCompressedSize

; 130  :                     (HUF_CElt*)nextHuf->CTable, countWksp, maxSymbolValue);
; 131  :             size_t const hSize = HUF_writeCTable(

	mov	r12, QWORD PTR hufMetadata$[rsp]
	mov	r9d, r13d
	mov	r8, rdi
	mov	QWORD PTR newCSize$1$[rsp], rax
	mov	edx, 500				; 000001f4H
	mov	DWORD PTR [rsp+32], r14d
	lea	rcx, QWORD PTR [r12+4]
	call	HUF_writeCTable

; 132  :                     hufMetadata->hufDesBuffer, sizeof(hufMetadata->hufDesBuffer),
; 133  :                     (HUF_CElt*)nextHuf->CTable, maxSymbolValue, huffLog);
; 134  :             /* Check against repeating the previous CTable */
; 135  :             if (repeat != HUF_repeat_none) {

	cmp	DWORD PTR repeat$1$[rsp], 0
	mov	r14, rax
	je	$LN57@ZSTD_build

; 136  :                 size_t const oldCSize = HUF_estimateCompressedSize(

	mov	r8d, r13d
	mov	rdx, r15
	mov	rcx, rbx
	call	HUF_estimateCompressedSize

; 137  :                         (HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue);
; 138  :                 if (oldCSize < srcSize && (oldCSize <= hSize + newCSize || hSize + 12 >= srcSize)) {

	mov	rdx, QWORD PTR newCSize$1$[rsp]
	cmp	rax, rbp
	jae	SHORT $LN18@ZSTD_build
	lea	rcx, QWORD PTR [r14+rdx]
	cmp	rax, rcx
	jbe	SHORT $LL19@ZSTD_build
	lea	rax, QWORD PTR [r14+12]
	cmp	rax, rbp
	jb	SHORT $LN18@ZSTD_build
$LL19@ZSTD_build:

; 139  :                     DEBUGLOG(5, "set_repeat - smaller");
; 140  :                     memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	lea	rdi, QWORD PTR [rdi+128]
	movups	xmm0, XMMWORD PTR [rbx]
	lea	rbx, QWORD PTR [rbx+128]
	movups	XMMWORD PTR [rdi-128], xmm0
	movups	xmm1, XMMWORD PTR [rbx-112]
	movups	XMMWORD PTR [rdi-112], xmm1
	movups	xmm0, XMMWORD PTR [rbx-96]
	movups	XMMWORD PTR [rdi-96], xmm0
	movups	xmm1, XMMWORD PTR [rbx-80]
	movups	XMMWORD PTR [rdi-80], xmm1
	movups	xmm0, XMMWORD PTR [rbx-64]
	movups	XMMWORD PTR [rdi-64], xmm0
	movups	xmm1, XMMWORD PTR [rbx-48]
	movups	XMMWORD PTR [rdi-48], xmm1
	movups	xmm0, XMMWORD PTR [rbx-32]
	movups	XMMWORD PTR [rdi-32], xmm0
	movups	xmm1, XMMWORD PTR [rbx-16]
	movups	XMMWORD PTR [rdi-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL19@ZSTD_build
	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rdi], eax

; 141  :                     hufMetadata->hType = set_repeat;

	mov	DWORD PTR [r12], 3

; 142  :                     return 0;

	jmp	$LN61@ZSTD_build
$LN57@ZSTD_build:

; 132  :                     hufMetadata->hufDesBuffer, sizeof(hufMetadata->hufDesBuffer),
; 133  :                     (HUF_CElt*)nextHuf->CTable, maxSymbolValue, huffLog);
; 134  :             /* Check against repeating the previous CTable */
; 135  :             if (repeat != HUF_repeat_none) {

	mov	rdx, QWORD PTR newCSize$1$[rsp]
$LN18@ZSTD_build:

; 143  :                 }
; 144  :             }
; 145  :             if (newCSize + hSize >= srcSize) {

	lea	rax, QWORD PTR [r14+rdx]
	cmp	rax, rbp
	jb	SHORT $LN20@ZSTD_build
	npad	8
$LL54@ZSTD_build:

; 146  :                 DEBUGLOG(5, "set_basic - no gains");
; 147  :                 memcpy(nextHuf, prevHuf, sizeof(*prevHuf));

	lea	rdi, QWORD PTR [rdi+128]
	movups	xmm0, XMMWORD PTR [rbx]
	lea	rbx, QWORD PTR [rbx+128]
	movups	XMMWORD PTR [rdi-128], xmm0
	movups	xmm1, XMMWORD PTR [rbx-112]
	movups	XMMWORD PTR [rdi-112], xmm1
	movups	xmm0, XMMWORD PTR [rbx-96]
	movups	XMMWORD PTR [rdi-96], xmm0
	movups	xmm1, XMMWORD PTR [rbx-80]
	movups	XMMWORD PTR [rdi-80], xmm1
	movups	xmm0, XMMWORD PTR [rbx-64]
	movups	XMMWORD PTR [rdi-64], xmm0
	movups	xmm1, XMMWORD PTR [rbx-48]
	movups	XMMWORD PTR [rdi-48], xmm1
	movups	xmm0, XMMWORD PTR [rbx-32]
	movups	XMMWORD PTR [rdi-32], xmm0
	movups	xmm1, XMMWORD PTR [rbx-16]
	movups	XMMWORD PTR [rdi-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL54@ZSTD_build
	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rdi], eax

; 148  :                 hufMetadata->hType = set_basic;

	mov	DWORD PTR [r12], esi

; 149  :                 return 0;

	jmp	SHORT $LN61@ZSTD_build
$LN20@ZSTD_build:

; 150  :             }
; 151  :             DEBUGLOG(5, "set_compressed (hSize=%u)", (U32)hSize);
; 152  :             hufMetadata->hType = set_compressed;

	mov	DWORD PTR [r12], 2

; 153  :             nextHuf->repeatMode = HUF_repeat_check;
; 154  :             return hSize;

	mov	rax, r14
	mov	DWORD PTR [rdi+1024], 1
	jmp	SHORT $LN1@ZSTD_build
$LN53@ZSTD_build:

; 109  :             DEBUGLOG(5, "set_basic - no gain");
; 110  :             hufMetadata->hType = set_basic;

	mov	rax, QWORD PTR hufMetadata$[rsp]
	mov	DWORD PTR [rax], r13d
$LN61@ZSTD_build:

; 155  :         }
; 156  :     }
; 157  : }

	xor	eax, eax
$LN1@ZSTD_build:
	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
ZSTD_buildSuperBlockEntropy_literal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
mlCodeTable$1$ = 128
op$1$ = 136
llCodeTable$1$ = 136
repeatCost$1$ = 144
oend$1$ = 152
ostart$1$ = 160
CTable_LitLength$1$ = 168
cTableWksp$1$ = 176
CTable_MatchLength$1$ = 184
max$1 = 272
max$2 = 272
max$3 = 272
seqStorePtr$ = 272
prevEntropy$ = 280
nextEntropy$ = 288
strategy$1$ = 296
cctxParams$ = 296
fseMetadata$ = 304
workspace$ = 312
ofCodeTable$1$ = 320
wkspSize$dead$ = 320
ZSTD_buildSuperBlockEntropy_sequences PROC

; 169  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 200				; 000000c8H

; 170  :     BYTE* const wkspStart = (BYTE*)workspace;
; 171  :     BYTE* const wkspEnd = wkspStart + wkspSize;
; 172  :     BYTE* const countWkspStart = wkspStart;
; 173  :     unsigned* const countWksp = (unsigned*)workspace;
; 174  :     const size_t countWkspSize = (MaxSeq + 1) * sizeof(unsigned);
; 175  :     BYTE* const cTableWksp = countWkspStart + countWkspSize;
; 176  :     const size_t cTableWkspSize = wkspEnd-cTableWksp;
; 177  :     ZSTD_strategy const strategy = cctxParams->cParams.strategy;
; 178  :     FSE_CTable* CTable_LitLength = nextEntropy->litlengthCTable;
; 179  :     FSE_CTable* CTable_OffsetBits = nextEntropy->offcodeCTable;
; 180  :     FSE_CTable* CTable_MatchLength = nextEntropy->matchlengthCTable;
; 181  :     const BYTE* const ofCodeTable = seqStorePtr->ofCode;
; 182  :     const BYTE* const llCodeTable = seqStorePtr->llCode;
; 183  :     const BYTE* const mlCodeTable = seqStorePtr->mlCode;
; 184  :     size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;

	mov	rsi, QWORD PTR [rcx+8]
	lea	r13, QWORD PTR [r8+2224]
	mov	r12, QWORD PTR [rcx+32]
	mov	r14, r8
	sub	rsi, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	rbp, QWORD PTR workspace$[rsp]

; 185  :     BYTE* const ostart = fseMetadata->fseTablesBuffer;
; 186  :     BYTE* const oend = ostart + sizeof(fseMetadata->fseTablesBuffer);
; 187  :     BYTE* op = ostart;
; 188  : 
; 189  :     assert(cTableWkspSize >= (1 << MaxFSELog) * sizeof(FSE_FUNCTION_TYPE));
; 190  :     DEBUGLOG(5, "ZSTD_buildSuperBlockEntropy_sequences (nbSeq=%zu)", nbSeq);
; 191  :     memset(workspace, 0, wkspSize);

	xor	edx, edx
	mov	r15, QWORD PTR fseMetadata$[rsp]
	mov	QWORD PTR CTable_LitLength$1$[rsp], r13
	mov	QWORD PTR llCodeTable$1$[rsp], r12
	lea	rax, QWORD PTR [rbp+212]
	sar	rsi, 3
	mov	QWORD PTR cTableWksp$1$[rsp], rax
	mov	eax, DWORD PTR [r9+28]
	mov	DWORD PTR strategy$1$[rsp], eax
	lea	rax, QWORD PTR [r8+772]
	mov	QWORD PTR CTable_MatchLength$1$[rsp], rax
	mov	r8d, 6400				; 00001900H
	mov	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR ofCodeTable$1$[rsp], rax
	mov	rax, QWORD PTR [rcx+40]
	mov	rcx, rbp
	mov	QWORD PTR mlCodeTable$1$[rsp], rax
	lea	rax, QWORD PTR [r15+12]
	mov	QWORD PTR ostart$1$[rsp], rax
	add	rax, 500				; 000001f4H
	mov	QWORD PTR oend$1$[rsp], rax
	call	memset

; 192  : 
; 193  :     fseMetadata->lastCountSize = 0;

	xor	edi, edi

; 194  :     /* convert length/distances into codes */
; 195  :     ZSTD_seqToCodes(seqStorePtr);

	mov	rcx, rbx
	mov	QWORD PTR [r15+520], rdi
	call	ZSTD_seqToCodes
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	r10, -1
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 198  :         unsigned max = MaxLL;

	mov	r15d, 35				; 00000023H
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	QWORD PTR repeatCost$1$[rsp], r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 198  :         unsigned max = MaxLL;

	mov	DWORD PTR max$3[rsp], r15d
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN22@ZSTD_build

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r9, rsi
	lea	rdx, QWORD PTR max$3[rsp]
	mov	r8, r12
	mov	rcx, rbp
	call	HIST_count_simple
	mov	ecx, eax
	jmp	SHORT $LN160@ZSTD_build
$LN22@ZSTD_build:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	bpl, 3
	je	SHORT $LN24@ZSTD_build
	mov	rcx, r10
	jmp	SHORT $LN21@ZSTD_build
$LN24@ZSTD_build:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbp
	lea	rdx, QWORD PTR max$3[rsp]
	mov	r9, rsi
	mov	DWORD PTR [rsp+32], edi
	mov	r8, r12
	mov	rcx, rbp
	call	HIST_count_parallel_wksp
	mov	rcx, rax
$LN160@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 201  :         nextEntropy->litlength_repeatMode = prevEntropy->litlength_repeatMode;

	mov	r15d, DWORD PTR max$3[rsp]
	mov	r10, -1
$LN21@ZSTD_build:
	mov	r11, QWORD PTR prevEntropy$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	lea	rax, OFFSET FLAT:LL_defaultNorm
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 201  :         nextEntropy->litlength_repeatMode = prevEntropy->litlength_repeatMode;

	mov	r8d, DWORD PTR [r11+3548]
	mov	DWORD PTR [r14+3548], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	cmp	rcx, rsi
	jne	SHORT $LN27@ZSTD_build

; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	cmp	rsi, 2
	mov	DWORD PTR [r14+3548], edi
	mov	ebx, edi
	seta	bl

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	jmp	$LN26@ZSTD_build
$LN27@ZSTD_build:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	edx, DWORD PTR strategy$1$[rsp]
	cmp	edx, 4
	jge	SHORT $LN29@ZSTD_build

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	mov	eax, 10
	sub	eax, edx
	movsxd	rdx, eax

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	shl	rdx, 6
	shr	rdx, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	r8d, 2
	jne	SHORT $LN32@ZSTD_build
	cmp	rsi, 1000				; 000003e8H
	jae	SHORT $LN32@ZSTD_build

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;

	lea	ebx, QWORD PTR [r8+1]
	jmp	$LN26@ZSTD_build
$LN32@ZSTD_build:

; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rsi, rdx
	jb	SHORT $LN34@ZSTD_build
	mov	rax, rsi
	shr	rax, 5
	cmp	rcx, rax
	jae	$LN37@ZSTD_build
$LN34@ZSTD_build:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r14+3548], edi

; 187  :                 return set_basic;

	mov	ebx, edi
	jmp	$LN26@ZSTD_build
$LN29@ZSTD_build:

; 128  :     size_t cost = 0;

	mov	rdx, rax
	mov	r8, rbp
	lea	eax, DWORD PTR [r15+1]
	mov	rbx, rdi
	mov	r14d, eax
	lea	rbp, OFFSET FLAT:kInverseProbabilityLog256
	mov	r9d, eax
	mov	r11d, 1
$LL46@ZSTD_build:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [rdx]
	cmp	ax, -1
	jne	SHORT $LN49@ZSTD_build
	mov	eax, r11d
$LN49@ZSTD_build:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*4]
	add	rdx, 2

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [rbp+rax*4]
	imul	eax, DWORD PTR [r8]
	add	r8, 4
	add	rbx, rax
	sub	r9, r11
	jne	SHORT $LL46@ZSTD_build

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	rax, QWORD PTR nextEntropy$[rsp]
	mov	rbp, QWORD PTR workspace$[rsp]
	mov	r11, QWORD PTR prevEntropy$[rsp]

; 138  :     return cost >> 8;

	shr	rbx, 8

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	cmp	DWORD PTR [rax+3548], edi
	je	SHORT $LN41@ZSTD_build
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 202  :         LLtype = ZSTD_selectEncodingType(&nextEntropy->litlength_repeatMode,

	lea	rcx, QWORD PTR [r11+2224]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r8d, r15d
	mov	rdx, rbp
	call	ZSTD_fseBitCost
	mov	rbp, rax
	jmp	SHORT $LN42@ZSTD_build
$LN41@ZSTD_build:
	mov	rbp, r10
$LN42@ZSTD_build:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	rcx, QWORD PTR workspace$[rsp]
	mov	r9d, 9
	mov	r8, rsi
	mov	edx, r15d
	call	ZSTD_NCountCost
	mov	r9, QWORD PTR workspace$[rsp]
	lea	r12, OFFSET FLAT:kInverseProbabilityLog256
	mov	r11, rax

; 73   :     unsigned cost = 0;

	mov	r10d, edi

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r13d, 1
	npad	2
$LL53@ZSTD_build:

; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [r9]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rsi

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN54@ZSTD_build
	test	eax, eax
	cmove	eax, r13d
$LN54@ZSTD_build:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	r9, 4
	mov	ecx, DWORD PTR [r12+rax*4]
	imul	ecx, r8d
	add	r10d, ecx
	sub	r14, r13
	jne	SHORT $LL53@ZSTD_build

; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	r12, QWORD PTR llCodeTable$1$[rsp]
	mov	r13, QWORD PTR CTable_LitLength$1$[rsp]
	mov	eax, r10d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r11*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	cmp	rbx, rbp
	ja	SHORT $LN36@ZSTD_build
	cmp	rbx, rcx
	ja	SHORT $LN36@ZSTD_build

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	rax, QWORD PTR nextEntropy$[rsp]

; 208  :             return set_basic;

	mov	ebx, edi
	mov	DWORD PTR [rax+3548], edi
	jmp	SHORT $LN26@ZSTD_build
$LN36@ZSTD_build:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	cmp	rbp, rcx
	ja	SHORT $LN156@ZSTD_build

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	mov	ebx, 3
	jmp	SHORT $LN26@ZSTD_build
$LN156@ZSTD_build:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	mov	r14, QWORD PTR nextEntropy$[rsp]
$LN37@ZSTD_build:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	eax, 1
	mov	DWORD PTR [r14+3548], eax

; 219  :     return set_compressed;

	lea	ebx, QWORD PTR [rax+1]
$LN26@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 209  :         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,

	mov	rdx, QWORD PTR cTableWksp$1$[rsp]
	mov	r9d, 9
	mov	rbp, QWORD PTR prevEntropy$[rsp]
	mov	r8, r13
	mov	r14, QWORD PTR ostart$1$[rsp]
	mov	QWORD PTR [rsp+120], 6188		; 0000182cH
	mov	rcx, r14
	mov	QWORD PTR [rsp+112], rdx
	mov	edx, 500				; 000001f4H
	mov	QWORD PTR [rsp+104], 1316		; 00000524H
	lea	rax, QWORD PTR [rbp+2224]
	mov	QWORD PTR [rsp+96], rax
	lea	rax, OFFSET FLAT:LL_defaultNorm
	mov	DWORD PTR [rsp+88], 35			; 00000023H
	mov	DWORD PTR [rsp+80], 6
	mov	QWORD PTR [rsp+72], rax
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], r12
	mov	r12, QWORD PTR workspace$[rsp]
	mov	DWORD PTR [rsp+48], r15d
	mov	QWORD PTR [rsp+40], r12
	mov	DWORD PTR [rsp+32], ebx
	call	ZSTD_buildCTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 213  :             FORWARD_IF_ERROR(countSize, "ZSTD_buildCTable for LitLens failed");

	ja	$LN1@ZSTD_build

; 214  :             if (LLtype == set_compressed)

	cmp	ebx, 2
	jne	SHORT $LN13@ZSTD_build

; 215  :                 fseMetadata->lastCountSize = countSize;

	mov	rcx, QWORD PTR fseMetadata$[rsp]
	mov	QWORD PTR [rcx+520], rax
$LN13@ZSTD_build:

; 216  :             op += countSize;

	add	rax, r14

; 217  :             fseMetadata->llType = (symbolEncodingType_e) LLtype;
; 218  :     }   }
; 219  :     /* build CTable for Offsets */
; 220  :     {   U32 Offtype;
; 221  :         unsigned max = MaxOff;

	mov	r15d, 31
	mov	QWORD PTR op$1$[rsp], rax
	mov	rax, QWORD PTR fseMetadata$[rsp]
	mov	DWORD PTR max$2[rsp], r15d
	mov	DWORD PTR [rax], ebx
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN59@ZSTD_build

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, QWORD PTR ofCodeTable$1$[rsp]
	lea	rdx, QWORD PTR max$2[rsp]
	mov	r9, rsi
	mov	rcx, r12
	call	HIST_count_simple
	mov	edx, eax
	jmp	SHORT $LN161@ZSTD_build
$LN59@ZSTD_build:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	r12b, 3
	je	SHORT $LN61@ZSTD_build
	mov	rdx, -1
	jmp	SHORT $LN58@ZSTD_build
$LN61@ZSTD_build:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	r8, QWORD PTR ofCodeTable$1$[rsp]
	lea	rdx, QWORD PTR max$2[rsp]
	mov	QWORD PTR [rsp+40], r12
	mov	r9, rsi
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], edi
	call	HIST_count_parallel_wksp
	mov	rdx, rax
$LN161@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 224  :         ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;

	mov	r15d, DWORD PTR max$2[rsp]
$LN58@ZSTD_build:

; 226  :         nextEntropy->offcode_repeatMode = prevEntropy->offcode_repeatMode;

	mov	r13, QWORD PTR nextEntropy$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	lea	rax, OFFSET FLAT:OF_defaultNorm
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 226  :         nextEntropy->offcode_repeatMode = prevEntropy->offcode_repeatMode;

	mov	r8d, DWORD PTR [rbp+3540]
	cmp	r15d, 28
	mov	ecx, edi
	setbe	cl
	mov	DWORD PTR [r13+3540], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	cmp	rdx, rsi
	jne	SHORT $LN64@ZSTD_build

; 152  :         *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r13+3540], edi

; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	test	ecx, ecx
	je	SHORT $LN65@ZSTD_build
	cmp	rsi, 2
	ja	SHORT $LN65@ZSTD_build

; 154  :             /* Prefer set_basic over set_rle when there are 2 or less symbols,
; 155  :              * since RLE uses 1 byte, but set_basic uses 5-6 bits per symbol.
; 156  :              * If basic encoding isn't possible, always choose RLE.
; 157  :              */
; 158  :             DEBUGLOG(5, "Selected set_basic");
; 159  :             return set_basic;

	mov	ebx, edi
	mov	ebp, 10
	jmp	$LN63@ZSTD_build
$LN65@ZSTD_build:

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	mov	ebx, 1
	lea	ebp, QWORD PTR [rbx+9]
	jmp	$LN63@ZSTD_build
$LN64@ZSTD_build:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	r9d, DWORD PTR strategy$1$[rsp]
	cmp	r9d, 4
	jge	SHORT $LN66@ZSTD_build

; 165  :         if (isDefaultAllowed) {

	mov	ebp, 10
	test	ecx, ecx
	je	$LN74@ZSTD_build

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	mov	eax, ebp
	sub	eax, r9d
	movsxd	rcx, eax

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	shl	rcx, 5
	shr	rcx, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	r8d, 2
	jne	SHORT $LN69@ZSTD_build
	cmp	rsi, 1000				; 000003e8H
	jae	SHORT $LN69@ZSTD_build

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;

	lea	ebx, QWORD PTR [rbp-7]
	jmp	$LN63@ZSTD_build
$LN69@ZSTD_build:

; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rsi, rcx
	jb	SHORT $LN71@ZSTD_build
	mov	rax, rsi
	shr	rax, 4
	cmp	rdx, rax
	jae	$LN74@ZSTD_build
$LN71@ZSTD_build:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r13+3540], edi

; 187  :                 return set_basic;

	mov	ebx, edi
	jmp	$LN63@ZSTD_build
$LN66@ZSTD_build:

; 188  :             }
; 189  :         }
; 190  :     } else {
; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	test	ecx, ecx
	je	SHORT $LN76@ZSTD_build

; 127  :     unsigned const shift = 8 - accuracyLog;

	mov	r8, r12
	lea	r9d, DWORD PTR [r15+1]
	lea	r12, OFFSET FLAT:kInverseProbabilityLog256

; 128  :     size_t cost = 0;

	mov	rbx, rdi
	mov	rdx, rax
	mov	ebp, 1
$LL83@ZSTD_build:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [rdx]
	cmp	ax, -1
	jne	SHORT $LN86@ZSTD_build
	mov	eax, ebp
$LN86@ZSTD_build:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*8]
	add	rdx, 2

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [r12+rax*4]
	imul	eax, DWORD PTR [r8]
	add	r8, 4
	add	rbx, rax
	sub	r9, rbp
	jne	SHORT $LL83@ZSTD_build
	mov	r8d, DWORD PTR [r13+3540]

; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	mov	r12, QWORD PTR workspace$[rsp]
	mov	rbp, QWORD PTR prevEntropy$[rsp]

; 138  :     return cost >> 8;

	shr	rbx, 8

; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	jmp	SHORT $LN77@ZSTD_build
$LN76@ZSTD_build:
	mov	rbx, -1
$LN77@ZSTD_build:

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	test	r8d, r8d
	je	SHORT $LN78@ZSTD_build
	mov	r8d, r15d
	mov	rdx, r12
	mov	rcx, rbp
	call	ZSTD_fseBitCost
	mov	rbp, rax
	jmp	SHORT $LN79@ZSTD_build
$LN78@ZSTD_build:
	mov	rbp, -1
$LN79@ZSTD_build:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r9d, 8
	mov	r8, rsi
	mov	edx, r15d
	mov	rcx, r12
	call	ZSTD_NCountCost
	mov	r9, r12
	lea	r11d, DWORD PTR [r15+1]
	lea	r12, OFFSET FLAT:kInverseProbabilityLog256
	mov	r14, rax

; 73   :     unsigned cost = 0;

	mov	r10d, edi

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r13d, 1
	npad	1
$LL90@ZSTD_build:

; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [r9]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rsi

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN91@ZSTD_build
	test	eax, eax
	cmove	eax, r13d
$LN91@ZSTD_build:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	r9, 4
	mov	ecx, DWORD PTR [r12+rax*4]
	imul	ecx, r8d
	add	r10d, ecx
	sub	r11, r13
	jne	SHORT $LL90@ZSTD_build

; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	r12, QWORD PTR workspace$[rsp]
	mov	r13, QWORD PTR nextEntropy$[rsp]
	mov	eax, r10d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r14*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	cmp	rbx, rbp
	ja	SHORT $LN73@ZSTD_build
	cmp	rbx, rcx
	ja	SHORT $LN73@ZSTD_build

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r13+3540], edi

; 208  :             return set_basic;

	lea	ebp, QWORD PTR [r11+10]
	mov	ebx, edi
	jmp	SHORT $LN63@ZSTD_build
$LN73@ZSTD_build:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	cmp	rbp, rcx
	mov	ebp, 10
	ja	SHORT $LN74@ZSTD_build

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	lea	ebx, QWORD PTR [rbp-7]
	jmp	SHORT $LN63@ZSTD_build
$LN74@ZSTD_build:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	eax, 1
	mov	DWORD PTR [r13+3540], eax

; 219  :     return set_compressed;

	lea	ebx, QWORD PTR [rax+1]
$LN63@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 233  :         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,

	mov	r11, QWORD PTR prevEntropy$[rsp]
	lea	rax, QWORD PTR [r12+212]
	mov	rdx, QWORD PTR oend$1$[rsp]
	mov	r9d, 8
	sub	rdx, QWORD PTR op$1$[rsp]
	mov	r8, r13
	mov	QWORD PTR [rsp+120], 6188		; 0000182cH
	mov	QWORD PTR [rsp+112], rax
	lea	rax, OFFSET FLAT:OF_defaultNorm
	mov	QWORD PTR [rsp+104], 772		; 00000304H
	mov	QWORD PTR [rsp+96], r11
	mov	DWORD PTR [rsp+88], 28
	mov	DWORD PTR [rsp+80], 5
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR ofCodeTable$1$[rsp]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r15d
	mov	r15, QWORD PTR op$1$[rsp]
	mov	rcx, r15
	mov	QWORD PTR [rsp+40], r12
	mov	DWORD PTR [rsp+32], ebx
	call	ZSTD_buildCTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 237  :             FORWARD_IF_ERROR(countSize, "ZSTD_buildCTable for Offsets failed");

	ja	$LN1@ZSTD_build

; 238  :             if (Offtype == set_compressed)

	cmp	ebx, 2
	jne	SHORT $LN16@ZSTD_build

; 239  :                 fseMetadata->lastCountSize = countSize;

	mov	rcx, QWORD PTR fseMetadata$[rsp]
	mov	QWORD PTR [rcx+520], rax
$LN16@ZSTD_build:

; 240  :             op += countSize;

	add	r15, rax

; 241  :             fseMetadata->ofType = (symbolEncodingType_e) Offtype;
; 242  :     }   }
; 243  :     /* build CTable for MatchLengths */
; 244  :     {   U32 MLtype;
; 245  :         unsigned max = MaxML;

	mov	r14d, 52				; 00000034H
	mov	rax, QWORD PTR fseMetadata$[rsp]
	mov	DWORD PTR max$1[rsp], r14d
	mov	DWORD PTR [rax+4], ebx
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN96@ZSTD_build

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, QWORD PTR mlCodeTable$1$[rsp]
	lea	rdx, QWORD PTR max$1[rsp]
	mov	r9, rsi
	mov	rcx, r12
	call	HIST_count_simple
	mov	ecx, eax
	jmp	SHORT $LN162@ZSTD_build
$LN96@ZSTD_build:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	r12b, 3
	je	SHORT $LN98@ZSTD_build
	mov	rcx, -1
	jmp	SHORT $LN95@ZSTD_build
$LN98@ZSTD_build:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	r8, QWORD PTR mlCodeTable$1$[rsp]
	lea	rdx, QWORD PTR max$1[rsp]
	mov	QWORD PTR [rsp+40], r12
	mov	r9, rsi
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], edi
	call	HIST_count_parallel_wksp
	mov	rcx, rax
$LN162@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 248  :         nextEntropy->matchlength_repeatMode = prevEntropy->matchlength_repeatMode;

	mov	r14d, DWORD PTR max$1[rsp]
$LN95@ZSTD_build:
	mov	r10, QWORD PTR prevEntropy$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	lea	r9, OFFSET FLAT:ML_defaultNorm
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 248  :         nextEntropy->matchlength_repeatMode = prevEntropy->matchlength_repeatMode;

	mov	edx, DWORD PTR [r10+3544]
	mov	DWORD PTR [r13+3544], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	cmp	rcx, rsi
	jne	SHORT $LN101@ZSTD_build

; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	cmp	rsi, 2
	mov	DWORD PTR [r13+3544], edi
	seta	dil

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	jmp	$LN100@ZSTD_build
$LN101@ZSTD_build:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	eax, DWORD PTR strategy$1$[rsp]
	cmp	eax, 4
	jge	SHORT $LN103@ZSTD_build

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	sub	ebp, eax
	movsxd	rax, ebp

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	shl	rax, 6
	shr	rax, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	edx, 2
	jne	SHORT $LN106@ZSTD_build
	cmp	rsi, 1000				; 000003e8H
	jae	SHORT $LN106@ZSTD_build

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;

	lea	edi, QWORD PTR [rdx+1]
	jmp	$LN100@ZSTD_build
$LN106@ZSTD_build:

; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rsi, rax
	jb	SHORT $LN108@ZSTD_build
	mov	rax, rsi
	shr	rax, 5
	cmp	rcx, rax
	jae	$LN111@ZSTD_build
$LN108@ZSTD_build:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r13+3544], edi

; 187  :                 return set_basic;

	jmp	$LN100@ZSTD_build
$LN103@ZSTD_build:

; 128  :     size_t cost = 0;

	lea	eax, DWORD PTR [r14+1]
	mov	r8, r12
	mov	rdx, r9
	mov	ebp, eax
	mov	r9d, eax
	lea	r12, OFFSET FLAT:kInverseProbabilityLog256
	mov	rbx, rdi
	mov	r10d, 1
$LL120@ZSTD_build:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [rdx]
	cmp	ax, -1
	jne	SHORT $LN123@ZSTD_build
	mov	eax, r10d
$LN123@ZSTD_build:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*4]
	add	rdx, 2

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [r12+rax*4]
	imul	eax, DWORD PTR [r8]
	add	r8, 4
	add	rbx, rax
	sub	r9, r10
	jne	SHORT $LL120@ZSTD_build

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r12, QWORD PTR workspace$[rsp]
	mov	r10, QWORD PTR prevEntropy$[rsp]

; 138  :     return cost >> 8;

	shr	rbx, 8

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	cmp	DWORD PTR [r13+3544], edi
	je	SHORT $LN115@ZSTD_build
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 249  :         MLtype = ZSTD_selectEncodingType(&nextEntropy->matchlength_repeatMode,

	lea	rcx, QWORD PTR [r10+772]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r8d, r14d
	mov	rdx, r12
	call	ZSTD_fseBitCost
	mov	QWORD PTR repeatCost$1$[rsp], rax
$LN115@ZSTD_build:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r9d, 9
	mov	r8, rsi
	mov	edx, r14d
	mov	rcx, r12
	call	ZSTD_NCountCost
	mov	r9, r12
	mov	r11, rax
	lea	r12, OFFSET FLAT:kInverseProbabilityLog256

; 73   :     unsigned cost = 0;

	mov	r10d, edi

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r13d, 1
	npad	13
$LL127@ZSTD_build:

; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [r9]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rsi

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN128@ZSTD_build
	test	eax, eax
	cmove	eax, r13d
$LN128@ZSTD_build:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	r9, 4
	mov	ecx, DWORD PTR [r12+rax*4]
	imul	ecx, r8d
	add	r10d, ecx
	sub	rbp, 1
	jne	SHORT $LL127@ZSTD_build

; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	r12, QWORD PTR workspace$[rsp]
	mov	r13, QWORD PTR nextEntropy$[rsp]
	mov	eax, r10d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r11*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	rax, QWORD PTR repeatCost$1$[rsp]
	cmp	rbx, rax
	ja	SHORT $LN110@ZSTD_build
	cmp	rbx, rcx
	ja	SHORT $LN110@ZSTD_build

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r13+3544], edi

; 208  :             return set_basic;

	jmp	SHORT $LN100@ZSTD_build
$LN110@ZSTD_build:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	cmp	rax, rcx
	ja	SHORT $LN111@ZSTD_build

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	mov	edi, 3
	jmp	SHORT $LN100@ZSTD_build
$LN111@ZSTD_build:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	eax, 1
	mov	DWORD PTR [r13+3544], eax

; 219  :     return set_compressed;

	lea	edi, QWORD PTR [rax+1]
$LN100@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 255  :         {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,

	mov	rax, QWORD PTR prevEntropy$[rsp]
	lea	rdx, QWORD PTR [r12+212]
	mov	rcx, QWORD PTR oend$1$[rsp]
	add	rax, 772				; 00000304H
	mov	r8, QWORD PTR CTable_MatchLength$1$[rsp]
	sub	rcx, r15
	mov	QWORD PTR [rsp+120], 6188		; 0000182cH
	mov	r9d, 9
	mov	QWORD PTR [rsp+112], rdx
	mov	rdx, rcx
	mov	QWORD PTR [rsp+104], 1452		; 000005acH
	mov	rcx, r15
	mov	QWORD PTR [rsp+96], rax
	lea	rax, OFFSET FLAT:ML_defaultNorm
	mov	DWORD PTR [rsp+88], 52			; 00000034H
	mov	DWORD PTR [rsp+80], 6
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR mlCodeTable$1$[rsp]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r14d
	mov	QWORD PTR [rsp+40], r12
	mov	DWORD PTR [rsp+32], edi
	call	ZSTD_buildCTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 259  :             FORWARD_IF_ERROR(countSize, "ZSTD_buildCTable for MatchLengths failed");

	ja	SHORT $LN1@ZSTD_build

; 260  :             if (MLtype == set_compressed)

	mov	rcx, QWORD PTR fseMetadata$[rsp]
	cmp	edi, 2
	jne	SHORT $LN19@ZSTD_build

; 261  :                 fseMetadata->lastCountSize = countSize;

	mov	QWORD PTR [rcx+520], rax
$LN19@ZSTD_build:

; 262  :             op += countSize;
; 263  :             fseMetadata->mlType = (symbolEncodingType_e) MLtype;
; 264  :     }   }
; 265  :     assert((size_t) (op-ostart) <= sizeof(fseMetadata->fseTablesBuffer));
; 266  :     return op-ostart;

	sub	rax, QWORD PTR ostart$1$[rsp]
	add	rax, r15
	mov	DWORD PTR [rcx+8], edi
$LN1@ZSTD_build:

; 267  : }

	add	rsp, 200				; 000000c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_buildSuperBlockEntropy_sequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
seqStorePtr$ = 96
prevEntropy$ = 104
nextEntropy$ = 112
cctxParams$ = 120
entropyMetadata$ = 128
workspace$ = 136
wkspSize$dead$ = 144
ZSTD_buildSuperBlockEntropy PROC

; 280  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	mov	r10d, DWORD PTR [r9+72]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 280  : {

	mov	rbp, rcx

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	mov	rcx, QWORD PTR [rcx+16]
	mov	r13, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	xor	edi, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 280  : {

	mov	rbx, r9
	mov	r15, r8

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	mov	rdx, QWORD PTR [rbp+24]
	sub	rdx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	test	r10d, r10d
	je	SHORT $LN18@ZSTD_build
	sub	r10d, 1
	je	SHORT $LN21@ZSTD_build
	cmp	r10d, 1
	je	SHORT $LN27@ZSTD_build
$LN18@ZSTD_build:

; 405  :     case ZSTD_lcm_huffman:
; 406  :         return 0;
; 407  :     case ZSTD_lcm_uncompressed:
; 408  :         return 1;
; 409  :     default:
; 410  :         assert(0 /* impossible: pre-validated */);
; 411  :         /* fall-through */
; 412  :     case ZSTD_lcm_auto:
; 413  :         return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);

	cmp	DWORD PTR [r9+28], 1
	jne	SHORT $LN21@ZSTD_build
	cmp	DWORD PTR [r9+24], edi
	jbe	SHORT $LN21@ZSTD_build
$LN27@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 283  :     entropyMetadata->hufMetadata.hufDesSize =

	mov	eax, 1
	jmp	SHORT $LN22@ZSTD_build
$LN21@ZSTD_build:
	mov	eax, edi
$LN22@ZSTD_build:
	mov	r14, QWORD PTR workspace$[rsp]
	mov	r9, r15
	mov	rsi, QWORD PTR entropyMetadata$[rsp]
	mov	r8, r13
	mov	QWORD PTR [rsp+48], r14
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rsi
	call	ZSTD_buildSuperBlockEntropy_literal
	mov	QWORD PTR [rsi+504], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 289  :     FORWARD_IF_ERROR(entropyMetadata->hufMetadata.hufDesSize, "ZSTD_buildSuperBlockEntropy_literal failed");

	ja	SHORT $LN5@ZSTD_build

; 290  :     entropyMetadata->fseMetadata.fseTablesSize =

	lea	rcx, QWORD PTR [rsi+512]
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], rcx
	lea	r8, QWORD PTR [r15+1028]
	mov	rcx, rbp
	lea	rdx, QWORD PTR [r13+1028]
	mov	r9, rbx
	call	ZSTD_buildSuperBlockEntropy_sequences
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 290  :     entropyMetadata->fseMetadata.fseTablesSize =

	mov	QWORD PTR [rsi+1024], rax

; 291  :         ZSTD_buildSuperBlockEntropy_sequences(seqStorePtr,
; 292  :                                               &prevEntropy->fse, &nextEntropy->fse,
; 293  :                                               cctxParams,
; 294  :                                               &entropyMetadata->fseMetadata,
; 295  :                                               workspace, wkspSize);
; 296  :     FORWARD_IF_ERROR(entropyMetadata->fseMetadata.fseTablesSize, "ZSTD_buildSuperBlockEntropy_sequences failed");

	cmova	rdi, rax
	mov	rax, rdi
$LN5@ZSTD_build:

; 297  :     return 0;
; 298  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	ret	0
ZSTD_buildSuperBlockEntropy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
hufTable$ = 112
hufMetadata$ = 120
literals$ = 128
litSize$ = 136
tv594 = 144
dst$ = 144
dstSize$ = 152
bmi2$dead$ = 160
writeEntropy$ = 168
entropyWritten$ = 176
ZSTD_compressSubBlock_literal PROC

; 324  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r11d, DWORD PTR writeEntropy$[rsp]
	mov	rsi, r9

; 325  :     size_t const header = writeEntropy ? 200 : 0;
; 326  :     size_t const lhSize = 3 + (litSize >= (1 KB - header)) + (litSize >= (16 KB - header));
; 327  :     BYTE* const ostart = (BYTE*)dst;
; 328  :     BYTE* const oend = ostart + dstSize;

	mov	rdi, QWORD PTR dst$[rsp]
	test	r11d, r11d
	mov	ecx, 824				; 00000338H
	mov	r15, r8
	mov	eax, 1024				; 00000400H
	mov	r8d, 16384				; 00004000H
	cmovne	eax, ecx
	mov	r9, rdx
	mov	rcx, QWORD PTR dstSize$[rsp]
	cmp	rsi, rax
	mov	eax, 16184				; 00003f38H
	sbb	r10, r10
	test	r11d, r11d
	lea	rdx, QWORD PTR [rdi+rcx]
	cmovne	r8d, eax
	mov	QWORD PTR tv594[rsp], rdx
	xor	r12d, r12d
	lea	r14, QWORD PTR [r10+4]
	cmp	rsi, r8
	mov	eax, r12d
	setae	al
	add	r14, rax

; 329  :     BYTE* op = ostart + lhSize;

	lea	rbp, QWORD PTR [r14+rdi]

; 330  :     U32 const singleStream = lhSize == 3;
; 331  :     symbolEncodingType_e hType = writeEntropy ? hufMetadata->hType : set_repeat;

	test	r11d, r11d
	je	SHORT $LN18@ZSTD_compr
	mov	r13d, DWORD PTR [r9]
	jmp	SHORT $LN19@ZSTD_compr
$LN18@ZSTD_compr:
	mov	r13d, 3
$LN19@ZSTD_compr:

; 332  :     size_t cLitSize = 0;
; 333  : 
; 334  :     (void)bmi2; /* TODO bmi2... */
; 335  : 
; 336  :     DEBUGLOG(5, "ZSTD_compressSubBlock_literal (litSize=%zu, lhSize=%zu, writeEntropy=%d)", litSize, lhSize, writeEntropy);
; 337  : 
; 338  :     *entropyWritten = 0;

	mov	rax, QWORD PTR entropyWritten$[rsp]
	mov	rbx, r12
	mov	DWORD PTR [rax], r12d

; 339  :     if (litSize == 0 || hufMetadata->hType == set_basic) {

	test	rsi, rsi
	je	$LN6@ZSTD_compr
	mov	eax, DWORD PTR [r9]
	test	eax, eax
	je	$LN6@ZSTD_compr

; 342  :     } else if (hufMetadata->hType == set_rle) {

	cmp	eax, 1
	jne	SHORT $LN7@ZSTD_compr

; 343  :       DEBUGLOG(5, "ZSTD_compressSubBlock_literal using rle literal");
; 344  :       return ZSTD_compressRleLiteralsBlock(dst, dstSize, literals, litSize);

	mov	r9, rsi
	mov	r8, r15
	mov	rcx, rdi
	call	ZSTD_compressRleLiteralsBlock
	jmp	$LN1@ZSTD_compr
$LN7@ZSTD_compr:

; 345  :     }
; 346  : 
; 347  :     assert(litSize > 0);
; 348  :     assert(hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat);
; 349  : 
; 350  :     if (writeEntropy && hufMetadata->hType == set_compressed) {

	test	r11d, r11d
	je	SHORT $LN8@ZSTD_compr
	cmp	eax, 2
	jne	SHORT $LN8@ZSTD_compr

; 351  :         memcpy(op, hufMetadata->hufDesBuffer, hufMetadata->hufDesSize);

	mov	r8, QWORD PTR [r9+504]
	lea	rdx, QWORD PTR [r9+4]
	mov	rcx, rbp
	call	memcpy

; 352  :         op += hufMetadata->hufDesSize;

	mov	rbx, QWORD PTR hufMetadata$[rsp]
	mov	rdx, QWORD PTR tv594[rsp]
	mov	rbx, QWORD PTR [rbx+504]
	add	rbp, rbx
$LN8@ZSTD_compr:

; 358  :     {   const size_t cSize = singleStream ? HUF_compress1X_usingCTable(op, oend-op, literals, litSize, hufTable)

	mov	rax, QWORD PTR hufTable$[rsp]
	sub	rdx, rbp
	mov	QWORD PTR [rsp+32], rax
	mov	r9, rsi
	mov	r8, r15
	mov	rcx, rbp
	cmp	r14, 3
	jne	SHORT $LN20@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 548  :     return HUF_compress1X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, /* bmi2 */ 0);

	call	HUF_compress1X_usingCTable_internal
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 358  :     {   const size_t cSize = singleStream ? HUF_compress1X_usingCTable(op, oend-op, literals, litSize, hufTable)

	jmp	SHORT $LN21@ZSTD_compr
$LN20@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 607  :     return HUF_compress4X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, /* bmi2 */ 0);

	call	HUF_compress4X_usingCTable_internal
$LN21@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 360  :         op += cSize;

	add	rbp, rax

; 361  :         cLitSize += cSize;

	add	rbx, rax

; 362  :         if (cSize == 0 || ERR_isError(cSize)) {

	dec	rax
	cmp	rax, -121				; ffffffffffffff87H
	ja	$LN10@ZSTD_compr

; 365  :         }
; 366  :         /* If we expand and we aren't writing a header then emit uncompressed */
; 367  :         if (!writeEntropy && cLitSize >= litSize) {

	cmp	DWORD PTR writeEntropy$[rsp], r12d
	jne	SHORT $LN11@ZSTD_compr
	cmp	rbx, rsi
	jb	SHORT $LN11@ZSTD_compr
$LN32@ZSTD_compr:

; 405  : }

	mov	rdx, QWORD PTR dstSize$[rsp]
	jmp	$LN31@ZSTD_compr
$LN11@ZSTD_compr:

; 368  :             DEBUGLOG(5, "ZSTD_compressSubBlock_literal using raw literal because uncompressible");
; 369  :             return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);
; 370  :         }
; 371  :         /* If we are writing headers then allow expansion that doesn't change our header size. */
; 372  :         if (lhSize < (size_t)(3 + (cLitSize >= 1 KB) + (cLitSize >= 16 KB))) {

	cmp	rbx, 16384				; 00004000H
	setae	r12b
	cmp	rbx, 1024				; 00000400H
	sbb	rax, rax
	add	rax, 4
	add	r12, rax
	cmp	r14, r12
	jb	SHORT $LN32@ZSTD_compr

; 373  :             assert(cLitSize > litSize);
; 374  :             DEBUGLOG(5, "Literals expanded beyond allowed header size");
; 375  :             return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);
; 376  :         }
; 377  :         DEBUGLOG(5, "ZSTD_compressSubBlock_literal (cSize=%zu)", cSize);
; 378  :     }
; 379  : 
; 380  :     /* Build header */
; 381  :     switch(lhSize)

	sub	r14, 3
	je	SHORT $LN13@ZSTD_compr
	sub	r14, 1
	je	SHORT $LN14@ZSTD_compr
	cmp	r14, 1
	jne	SHORT $LN16@ZSTD_compr

; 392  :         }
; 393  :     case 5: /* 2 - 2 - 18 - 18 */
; 394  :         {   U32 const lhc = hType + (3 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<22);

	mov	eax, ebx
	shl	eax, 18
	add	eax, esi
	shl	eax, 4
	add	eax, 12
	add	eax, r13d

; 395  :             MEM_writeLE32(ostart, lhc);
; 396  :             ostart[4] = (BYTE)(cLitSize >> 10);

	shr	rbx, 10
	mov	DWORD PTR [rdi], eax
	mov	BYTE PTR [rdi+4], bl

; 397  :             break;

	jmp	SHORT $LN16@ZSTD_compr
$LN14@ZSTD_compr:

; 385  :             MEM_writeLE24(ostart, lhc);
; 386  :             break;
; 387  :         }
; 388  :     case 4: /* 2 - 2 - 14 - 14 */
; 389  :         {   U32 const lhc = hType + (2 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<18);

	shl	ebx, 14
	lea	eax, DWORD PTR [r13+8]
	add	ebx, esi
	shl	ebx, 4
	add	eax, ebx

; 390  :             MEM_writeLE32(ostart, lhc);

	mov	DWORD PTR [rdi], eax

; 391  :             break;

	jmp	SHORT $LN16@ZSTD_compr
$LN13@ZSTD_compr:

; 382  :     {
; 383  :     case 3: /* 2 - 2 - 10 - 10 */
; 384  :         {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<14);

	shl	ebx, 10
	add	ebx, esi
	shl	ebx, 4
	add	ebx, r13d
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rdi], bx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	ebx, 16
	mov	BYTE PTR [rdi+2], bl
$LN16@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 402  :     *entropyWritten = 1;

	mov	rax, QWORD PTR entropyWritten$[rsp]

; 403  :     DEBUGLOG(5, "Compressed literals: %u -> %u", (U32)litSize, (U32)(op-ostart));
; 404  :     return op-ostart;

	sub	rbp, rdi
	mov	DWORD PTR [rax], 1
	mov	rax, rbp
	jmp	SHORT $LN1@ZSTD_compr
$LN10@ZSTD_compr:

; 363  :             DEBUGLOG(5, "Failed to write entropy tables %s", ZSTD_getErrorName(cSize));
; 364  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_compr
$LN6@ZSTD_compr:

; 340  :       DEBUGLOG(5, "ZSTD_compressSubBlock_literal using raw literal");
; 341  :       return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);

	mov	rdx, rcx
$LN31@ZSTD_compr:

; 405  : }

	mov	r9, rsi
	mov	r8, r15
	mov	rcx, rdi
	call	ZSTD_noCompressLiterals
$LN1@ZSTD_compr:
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressSubBlock_literal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
seqStore$ = 16
sequences$ = 24
nbSeq$ = 32
litSize$ = 40
lastSequence$dead$ = 48
ZSTD_seqDecompressedSize PROC

; 407  : static size_t ZSTD_seqDecompressedSize(seqStore_t const* seqStore, const seqDef* sequences, size_t nbSeq, size_t litSize, int lastSequence) {

	push	rdi

; 408  :     const seqDef* const sstart = sequences;
; 409  :     const seqDef* const send = sequences + nbSeq;

	lea	r8, QWORD PTR [r8*8]

; 410  :     const seqDef* sp = sstart;
; 411  :     size_t matchLengthSum = 0;

	xor	r10d, r10d
	mov	rdi, r9
	mov	r11, rcx

; 412  :     size_t litLengthSum = 0;
; 413  :     while (send-sp > 0) {

	test	r8, -8
	jle	SHORT $LN15@ZSTD_seqDe
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+16], rbx
	sub	rdx, rax
	mov	ebx, DWORD PTR [rcx+76]
	lea	r9, QWORD PTR [rax+6]
	npad	2
$LL2@ZSTD_seqDe:

; 360  :     seqLen.matchLength = seq->matchLength + MINMATCH;

	movzx	eax, WORD PTR [r9+rdx]

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	mov	rcx, rdx
	add	eax, 3
	sar	rcx, 3
	cmp	ebx, ecx
	jne	SHORT $LN9@ZSTD_seqDe

; 362  :         if (seqStore->longLengthID == 1) {
; 363  :             seqLen.litLength += 0xFFFF;
; 364  :         }
; 365  :         if (seqStore->longLengthID == 2) {

	cmp	DWORD PTR [r11+72], 2
	jne	SHORT $LN9@ZSTD_seqDe

; 366  :             seqLen.matchLength += 0xFFFF;

	add	eax, 65535				; 0000ffffH
$LN9@ZSTD_seqDe:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 416  :         matchLengthSum += seqLen.matchLength;

	mov	ecx, eax

; 417  :         sp++;

	add	rdx, 8
	add	r10, rcx
	sub	r8, 8
	test	r8, -8
	jg	SHORT $LL2@ZSTD_seqDe

; 418  :     }
; 419  :     assert(litLengthSum <= litSize);
; 420  :     if (!lastSequence) {
; 421  :         assert(litLengthSum == litSize);
; 422  :     }
; 423  :     return matchLengthSum + litSize;

	mov	rbx, QWORD PTR [rsp+16]
	lea	rax, QWORD PTR [r10+rdi]

; 424  : }

	pop	rdi
	ret	0
$LN15@ZSTD_seqDe:

; 418  :     }
; 419  :     assert(litLengthSum <= litSize);
; 420  :     if (!lastSequence) {
; 421  :         assert(litLengthSum == litSize);
; 422  :     }
; 423  :     return matchLengthSum + litSize;

	lea	rax, QWORD PTR [r10+r9]

; 424  : }

	pop	rdi
	ret	0
ZSTD_seqDecompressedSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
fseTables$ = 144
fseMetadata$ = 152
sequences$ = 160
nbSeq$ = 168
llCode$ = 176
mlCode$ = 184
ofCode$ = 192
cctxParams$ = 200
oend$1$ = 208
dst$ = 208
dstCapacity$ = 216
longOffsets$1$ = 224
bmi2$dead$ = 224
writeEntropy$ = 232
entropyWritten$ = 240
ZSTD_compressSubBlock_sequences PROC

; 443  : {

	mov	QWORD PTR [rsp+24], r8
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 96					; 00000060H

; 444  :     const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;

	mov	rax, QWORD PTR cctxParams$[rsp]
	mov	r13, rcx
	mov	rdi, QWORD PTR dst$[rsp]
	xor	ecx, ecx

; 445  :     BYTE* const ostart = (BYTE*)dst;
; 446  :     BYTE* const oend = ostart + dstCapacity;
; 447  :     BYTE* op = ostart;
; 448  :     BYTE* seqHead;
; 449  : 
; 450  :     DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (nbSeq=%zu, writeEntropy=%d, longOffsets=%d)", nbSeq, writeEntropy, longOffsets);
; 451  : 
; 452  :     *entropyWritten = 0;

	mov	r12, QWORD PTR entropyWritten$[rsp]
	mov	r15, rdx
	mov	rsi, r9
	cmp	DWORD PTR [rax+4], 57			; 00000039H
	mov	rax, QWORD PTR dstCapacity$[rsp]
	seta	cl
	mov	DWORD PTR [r12], 0
	mov	DWORD PTR longOffsets$1$[rsp], ecx
	lea	rdx, QWORD PTR [rdi+rax]
	mov	QWORD PTR oend$1$[rsp], rdx

; 453  :     /* Sequences Header */
; 454  :     RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,

	cmp	rax, 4
	jge	SHORT $LN5@ZSTD_compr
	mov	rax, -70				; ffffffffffffffbaH

; 530  : }

	add	rsp, 96					; 00000060H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN5@ZSTD_compr:
	mov	QWORD PTR [rsp+144], rbx

; 455  :                     dstSize_tooSmall, "");
; 456  :     if (nbSeq < 0x7F)

	lea	rbx, QWORD PTR [rdi+1]
	cmp	rsi, 127				; 0000007fH
	jae	SHORT $LN7@ZSTD_compr

; 462  :     if (nbSeq==0) {

	mov	BYTE PTR [rdi], sil
	test	rsi, rsi
	jne	SHORT $LN11@ZSTD_compr

; 463  :         return op - ostart;

	sub	rbx, rdi
	mov	rax, rbx
	jmp	$LN24@ZSTD_compr
$LN7@ZSTD_compr:

; 457  :         *op++ = (BYTE)nbSeq;
; 458  :     else if (nbSeq < LONGNBSEQ)

	mov	ecx, 32512				; 00007f00H
	cmp	rsi, rcx
	jae	SHORT $LN9@ZSTD_compr

; 459  :         op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;

	mov	BYTE PTR [rbx], sil
	mov	rax, rsi
	shr	rax, 8
	lea	rbx, QWORD PTR [rdi+2]
	add	al, 128					; 00000080H
	mov	BYTE PTR [rdi], al
	jmp	SHORT $LN11@ZSTD_compr
$LN9@ZSTD_compr:

; 460  :     else
; 461  :         op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;

	movzx	eax, si
	sub	ax, cx
	mov	WORD PTR [rbx], ax
	lea	rbx, QWORD PTR [rdi+3]
	mov	BYTE PTR [rdi], 255			; 000000ffH
$LN11@ZSTD_compr:

; 464  :     }
; 465  : 
; 466  :     /* seqHead : flags for FSE encoding type */
; 467  :     seqHead = op++;

	mov	QWORD PTR [rsp+152], r14
	mov	r14, rbx
	inc	rbx

; 468  : 
; 469  :     DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (seqHeadSize=%u)", (unsigned)(op-ostart));
; 470  : 
; 471  :     if (writeEntropy) {

	cmp	DWORD PTR writeEntropy$[rsp], 0
	je	SHORT $LN12@ZSTD_compr

; 472  :         const U32 LLtype = fseMetadata->llType;
; 473  :         const U32 Offtype = fseMetadata->ofType;
; 474  :         const U32 MLtype = fseMetadata->mlType;

	movzx	eax, BYTE PTR [r15]

; 475  :         DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (fseTablesSize=%zu)", fseMetadata->fseTablesSize);
; 476  :         *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));
; 477  :         memcpy(op, fseMetadata->fseTablesBuffer, fseMetadata->fseTablesSize);

	lea	rdx, QWORD PTR [r15+12]
	shl	al, 2
	mov	rcx, rbx
	add	al, BYTE PTR [r15+4]
	shl	al, 2
	add	al, BYTE PTR [r15+8]
	shl	al, 2
	mov	BYTE PTR [r14], al
	mov	r8, QWORD PTR [r15+512]
	call	memcpy

; 478  :         op += fseMetadata->fseTablesSize;

	add	rbx, QWORD PTR [r15+512]

; 479  :     } else {

	mov	rdx, QWORD PTR oend$1$[rsp]
	jmp	SHORT $LN13@ZSTD_compr
$LN12@ZSTD_compr:

; 480  :         const U32 repeat = set_repeat;
; 481  :         *seqHead = (BYTE)((repeat<<6) + (repeat<<4) + (repeat<<2));

	mov	BYTE PTR [r14], 252			; 000000fcH
$LN13@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	eax, DWORD PTR longOffsets$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 484  :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	lea	rcx, QWORD PTR [r13+2224]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	r9, QWORD PTR mlCode$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 484  :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	lea	r8, QWORD PTR [r13+772]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	DWORD PTR [rsp+80], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 484  :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	sub	rdx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	rax, QWORD PTR sequences$[rsp]
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR llCode$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR ofCode$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r13
	call	ZSTD_encodeSequences_default
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 491  :         FORWARD_IF_ERROR(bitstreamSize, "ZSTD_encodeSequences failed");

	ja	SHORT $LN25@ZSTD_compr

; 492  :         op += bitstreamSize;

	add	rbx, rax

; 493  :         /* zstd versions <= 1.3.4 mistakenly report corruption when
; 494  :          * FSE_readNCount() receives a buffer < 4 bytes.
; 495  :          * Fixed by https://github.com/facebook/zstd/pull/1146.
; 496  :          * This can happen when the last set_compressed table present is 2
; 497  :          * bytes and the bitstream is only one byte.
; 498  :          * In this exceedingly rare case, we will simply emit an uncompressed
; 499  :          * block, since it isn't worth optimizing.
; 500  :          */
; 501  : #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 502  :         if (writeEntropy && fseMetadata->lastCountSize && fseMetadata->lastCountSize + bitstreamSize < 4) {

	cmp	DWORD PTR writeEntropy$[rsp], 0
	je	SHORT $LN16@ZSTD_compr
	mov	rcx, QWORD PTR [r15+520]
	test	rcx, rcx
	je	SHORT $LN16@ZSTD_compr
	add	rax, rcx
	cmp	rax, 4
	jb	SHORT $LN23@ZSTD_compr
$LN16@ZSTD_compr:

; 503  :             /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */
; 504  :             assert(fseMetadata->lastCountSize + bitstreamSize == 3);
; 505  :             DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.3.4 by "
; 506  :                         "emitting an uncompressed block.");
; 507  :             return 0;
; 508  :         }
; 509  : #endif
; 510  :         DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (bitstreamSize=%zu)", bitstreamSize);
; 511  :     }
; 512  : 
; 513  :     /* zstd versions <= 1.4.0 mistakenly report error when
; 514  :      * sequences section body size is less than 3 bytes.
; 515  :      * Fixed by https://github.com/facebook/zstd/pull/1664.
; 516  :      * This can happen when the previous sequences section block is compressed
; 517  :      * with rle mode and the current block's sequences section is compressed
; 518  :      * with repeat mode where sequences section body size can be 1 byte.
; 519  :      */
; 520  : #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 521  :     if (op-seqHead < 4) {

	mov	rax, rbx
	sub	rax, r14
	cmp	rax, 4
	jge	SHORT $LN17@ZSTD_compr
$LN23@ZSTD_compr:

; 522  :         DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.4.0 by emitting "
; 523  :                     "an uncompressed block when sequences are < 4 bytes");
; 524  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN25@ZSTD_compr
$LN17@ZSTD_compr:

; 525  :     }
; 526  : #endif
; 527  : 
; 528  :     *entropyWritten = 1;
; 529  :     return op - ostart;

	sub	rbx, rdi
	mov	DWORD PTR [r12], 1
	mov	rax, rbx
$LN25@ZSTD_compr:
	mov	r14, QWORD PTR [rsp+152]
$LN24@ZSTD_compr:
	mov	rbx, QWORD PTR [rsp+144]

; 530  : }

	add	rsp, 96					; 00000060H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
ZSTD_compressSubBlock_sequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
entropy$ = 144
entropyMetadata$ = 152
sequences$ = 160
nbSeq$ = 168
literals$ = 176
litSize$ = 184
llCode$ = 192
mlCode$ = 200
ofCode$ = 208
cctxParams$ = 216
fseTables$1$ = 224
dst$ = 224
dstCapacity$ = 232
longOffsets$1$ = 240
bmi2$dead$ = 240
writeLitEntropy$ = 248
writeSeqEntropy$ = 256
litEntropyWritten$ = 264
seqEntropyWritten$ = 272
lastBlock$ = 280
ZSTD_compressSubBlock PROC

; 547  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r15
	sub	rsp, 96					; 00000060H

; 548  :     BYTE* const ostart = (BYTE*)dst;
; 549  :     BYTE* const oend = ostart + dstCapacity;
; 550  :     BYTE* op = ostart + ZSTD_blockHeaderSize;
; 551  :     DEBUGLOG(5, "ZSTD_compressSubBlock (litSize=%zu, nbSeq=%zu, writeLitEntropy=%d, writeSeqEntropy=%d, lastBlock=%d)",
; 552  :                 litSize, nbSeq, writeLitEntropy, writeSeqEntropy, lastBlock);
; 553  :     {   size_t cLitSize = ZSTD_compressSubBlock_literal((const HUF_CElt*)entropy->huf.CTable,

	mov	rax, QWORD PTR litEntropyWritten$[rsp]
	mov	rsi, r9
	mov	r15, QWORD PTR dst$[rsp]
	mov	rbp, rdx
	mov	r13, QWORD PTR dstCapacity$[rsp]
	mov	rdi, rcx
	mov	r9, QWORD PTR litSize$[rsp]
	add	r13, r15
	mov	r8, QWORD PTR literals$[rsp]
	mov	r10, r13
	mov	QWORD PTR [rsp+64], rax
	lea	rbx, QWORD PTR [r15+3]
	mov	eax, DWORD PTR writeLitEntropy$[rsp]
	sub	r10, rbx
	mov	DWORD PTR [rsp+56], eax
	mov	QWORD PTR [rsp+40], r10
	mov	QWORD PTR [rsp+32], rbx
	call	ZSTD_compressSubBlock_literal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 556  :         FORWARD_IF_ERROR(cLitSize, "ZSTD_compressSubBlock_literal failed");

	ja	$LN1@ZSTD_compr

; 557  :         if (cLitSize == 0) return 0;

	mov	QWORD PTR [rsp+144], r14
	test	rax, rax
	je	$LN44@ZSTD_compr

; 558  :         op += cLitSize;

	add	rbx, rax

; 559  :     }
; 560  :     {   size_t cSeqSize = ZSTD_compressSubBlock_sequences(&entropy->fse,

	lea	rdx, QWORD PTR [rdi+1028]

; 444  :     const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;

	mov	rax, QWORD PTR cctxParams$[rsp]
	xor	ecx, ecx

; 559  :     }
; 560  :     {   size_t cSeqSize = ZSTD_compressSubBlock_sequences(&entropy->fse,

	mov	QWORD PTR fseTables$1$[rsp], rdx

; 444  :     const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;

	cmp	DWORD PTR [rax+4], 57			; 00000039H

; 445  :     BYTE* const ostart = (BYTE*)dst;
; 446  :     BYTE* const oend = ostart + dstCapacity;
; 447  :     BYTE* op = ostart;
; 448  :     BYTE* seqHead;
; 449  : 
; 450  :     DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (nbSeq=%zu, writeEntropy=%d, longOffsets=%d)", nbSeq, writeEntropy, longOffsets);
; 451  : 
; 452  :     *entropyWritten = 0;

	mov	rax, QWORD PTR seqEntropyWritten$[rsp]
	seta	cl
	mov	DWORD PTR longOffsets$1$[rsp], ecx
	mov	DWORD PTR [rax], 0

; 453  :     /* Sequences Header */
; 454  :     RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,

	mov	rax, r13
	sub	rax, rbx
	cmp	rax, 4
	jge	SHORT $LN21@ZSTD_compr
	mov	rcx, -70				; ffffffffffffffbaH

; 567  :         FORWARD_IF_ERROR(cSeqSize, "ZSTD_compressSubBlock_sequences failed");

	mov	rax, rcx
	jmp	$LN45@ZSTD_compr
$LN21@ZSTD_compr:

; 456  :     if (nbSeq < 0x7F)

	lea	rcx, QWORD PTR [rbx+1]
	cmp	rsi, 127				; 0000007fH
	jae	SHORT $LN23@ZSTD_compr

; 462  :     if (nbSeq==0) {

	mov	BYTE PTR [rbx], sil
	mov	rdi, rcx
	test	rsi, rsi
	jne	SHORT $LN27@ZSTD_compr

; 463  :         return op - ostart;

	jmp	$LN46@ZSTD_compr
$LN23@ZSTD_compr:

; 457  :         *op++ = (BYTE)nbSeq;
; 458  :     else if (nbSeq < LONGNBSEQ)

	mov	r8d, 32512				; 00007f00H
	cmp	rsi, r8
	jae	SHORT $LN25@ZSTD_compr

; 459  :         op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;

	mov	rax, rsi
	mov	BYTE PTR [rcx], sil
	shr	rax, 8
	lea	rdi, QWORD PTR [rbx+2]
	add	al, 128					; 00000080H
	mov	BYTE PTR [rbx], al
	jmp	SHORT $LN27@ZSTD_compr
$LN25@ZSTD_compr:

; 460  :     else
; 461  :         op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;

	movzx	eax, si
	lea	rdi, QWORD PTR [rbx+3]
	sub	ax, r8w
	mov	WORD PTR [rcx], ax
	mov	BYTE PTR [rbx], 255			; 000000ffH
$LN27@ZSTD_compr:

; 464  :     }
; 465  : 
; 466  :     /* seqHead : flags for FSE encoding type */
; 467  :     seqHead = op++;

	mov	r14, rdi
	inc	rdi

; 468  : 
; 469  :     DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (seqHeadSize=%u)", (unsigned)(op-ostart));
; 470  : 
; 471  :     if (writeEntropy) {

	cmp	DWORD PTR writeSeqEntropy$[rsp], 0
	je	SHORT $LN28@ZSTD_compr

; 472  :         const U32 LLtype = fseMetadata->llType;
; 473  :         const U32 Offtype = fseMetadata->ofType;
; 474  :         const U32 MLtype = fseMetadata->mlType;

	movzx	eax, BYTE PTR [rbp+512]

; 475  :         DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (fseTablesSize=%zu)", fseMetadata->fseTablesSize);
; 476  :         *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));
; 477  :         memcpy(op, fseMetadata->fseTablesBuffer, fseMetadata->fseTablesSize);

	lea	rdx, QWORD PTR [rbp+524]
	shl	al, 2
	mov	rcx, rdi
	add	al, BYTE PTR [rbp+516]
	shl	al, 2
	add	al, BYTE PTR [rbp+520]
	shl	al, 2
	mov	BYTE PTR [r14], al
	mov	r8, QWORD PTR [rbp+1024]
	call	memcpy

; 478  :         op += fseMetadata->fseTablesSize;

	add	rdi, QWORD PTR [rbp+1024]

; 479  :     } else {

	mov	rdx, QWORD PTR fseTables$1$[rsp]
	jmp	SHORT $LN29@ZSTD_compr
$LN28@ZSTD_compr:

; 480  :         const U32 repeat = set_repeat;
; 481  :         *seqHead = (BYTE)((repeat<<6) + (repeat<<4) + (repeat<<2));

	mov	BYTE PTR [r14], 252			; 000000fcH
$LN29@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	eax, DWORD PTR longOffsets$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 484  :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	lea	rcx, QWORD PTR [rdx+2224]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	r9, QWORD PTR mlCode$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 484  :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	lea	r8, QWORD PTR [rdx+772]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	DWORD PTR [rsp+80], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 484  :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	sub	r13, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	rax, QWORD PTR sequences$[rsp]
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR llCode$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR ofCode$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rdx
	mov	rdx, r13
	call	ZSTD_encodeSequences_default
	mov	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 491  :         FORWARD_IF_ERROR(bitstreamSize, "ZSTD_encodeSequences failed");

	ja	SHORT $LN43@ZSTD_compr

; 492  :         op += bitstreamSize;

	add	rdi, rax

; 493  :         /* zstd versions <= 1.3.4 mistakenly report corruption when
; 494  :          * FSE_readNCount() receives a buffer < 4 bytes.
; 495  :          * Fixed by https://github.com/facebook/zstd/pull/1146.
; 496  :          * This can happen when the last set_compressed table present is 2
; 497  :          * bytes and the bitstream is only one byte.
; 498  :          * In this exceedingly rare case, we will simply emit an uncompressed
; 499  :          * block, since it isn't worth optimizing.
; 500  :          */
; 501  : #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 502  :         if (writeEntropy && fseMetadata->lastCountSize && fseMetadata->lastCountSize + bitstreamSize < 4) {

	cmp	DWORD PTR writeSeqEntropy$[rsp], 0
	je	SHORT $LN32@ZSTD_compr
	mov	rax, QWORD PTR [rbp+1032]
	test	rax, rax
	je	SHORT $LN32@ZSTD_compr
	add	rax, rcx
	cmp	rax, 4
	jb	SHORT $LN44@ZSTD_compr
$LN32@ZSTD_compr:

; 503  :             /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */
; 504  :             assert(fseMetadata->lastCountSize + bitstreamSize == 3);
; 505  :             DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.3.4 by "
; 506  :                         "emitting an uncompressed block.");
; 507  :             return 0;
; 508  :         }
; 509  : #endif
; 510  :         DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (bitstreamSize=%zu)", bitstreamSize);
; 511  :     }
; 512  : 
; 513  :     /* zstd versions <= 1.4.0 mistakenly report error when
; 514  :      * sequences section body size is less than 3 bytes.
; 515  :      * Fixed by https://github.com/facebook/zstd/pull/1664.
; 516  :      * This can happen when the previous sequences section block is compressed
; 517  :      * with rle mode and the current block's sequences section is compressed
; 518  :      * with repeat mode where sequences section body size can be 1 byte.
; 519  :      */
; 520  : #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 521  :     if (op-seqHead < 4) {

	mov	rax, rdi
	sub	rax, r14
	cmp	rax, 4
	jl	SHORT $LN44@ZSTD_compr

; 522  :         DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.4.0 by emitting "
; 523  :                     "an uncompressed block when sequences are < 4 bytes");
; 524  :         return 0;
; 525  :     }
; 526  : #endif
; 527  : 
; 528  :     *entropyWritten = 1;

	mov	rax, QWORD PTR seqEntropyWritten$[rsp]

; 529  :     return op - ostart;

	mov	rcx, rdi
	mov	DWORD PTR [rax], 1
$LN46@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	sub	rcx, rbx
	cmp	rcx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 567  :         FORWARD_IF_ERROR(cSeqSize, "ZSTD_compressSubBlock_sequences failed");

	jbe	SHORT $LN5@ZSTD_compr
$LN43@ZSTD_compr:
	mov	rax, rcx
	jmp	SHORT $LN45@ZSTD_compr
$LN5@ZSTD_compr:

; 568  :         if (cSeqSize == 0) return 0;

	test	rcx, rcx
	je	SHORT $LN44@ZSTD_compr

; 569  :         op += cSeqSize;

	add	rbx, rcx

; 570  :     }
; 571  :     /* Write block header */
; 572  :     {   size_t cSize = (op-ostart)-ZSTD_blockHeaderSize;
; 573  :         U32 const cBlockHeader24 = lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);

	sub	rbx, r15

; 576  :     return op-ostart;

	mov	rax, rbx
	lea	edx, DWORD PTR [rbx*8-20]
	add	edx, DWORD PTR lastBlock$[rsp]
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [r15], dx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	edx, 16
	mov	BYTE PTR [r15+2], dl
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 576  :     return op-ostart;

	jmp	SHORT $LN45@ZSTD_compr
$LN44@ZSTD_compr:

; 568  :         if (cSeqSize == 0) return 0;

	xor	eax, eax
$LN45@ZSTD_compr:
	mov	r14, QWORD PTR [rsp+144]
$LN1@ZSTD_compr:

; 577  : }

	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressSubBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
literals$ = 64
litSize$ = 72
huf$ = 80
hufMetadata$ = 88
maxSymbolValue$ = 96
workspace$ = 96
wkspSize$dead$ = 104
writeEntropy$ = 112
ZSTD_estimateSubBlockSize_literal PROC

; 584  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 585  :     unsigned* const countWksp = (unsigned*)workspace;
; 586  :     unsigned maxSymbolValue = 255;
; 587  :     size_t literalSectionHeaderSize = 3; /* Use hard coded size of 3 bytes */
; 588  : 
; 589  :     if (hufMetadata->hType == set_basic) return litSize;

	mov	eax, DWORD PTR [r9]
	mov	rsi, r9
	mov	rbp, r8
	mov	rdi, rdx
	test	eax, eax
	je	$LN23@ZSTD_estim

; 590  :     else if (hufMetadata->hType == set_rle) return 1;

	cmp	eax, 1
	jne	SHORT $LN4@ZSTD_estim
	mov	eax, 1
	jmp	SHORT $LN1@ZSTD_estim
$LN4@ZSTD_estim:

; 591  :     else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN7@ZSTD_estim

; 597  :     }   }
; 598  :     assert(0); /* impossible */
; 599  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_estim
$LN7@ZSTD_estim:
; File E:\dev\pyzstd\lib\compress\hist.c

; 170  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	mov	rbx, QWORD PTR workspace$[rsp]
	test	bl, 3
	jne	SHORT $LN23@ZSTD_estim

; 171  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 172  :     if (*maxSymbolValuePtr < 255)
; 173  :         return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, checkMaxSymbolValue, (U32*)workSpace);
; 174  :     *maxSymbolValuePtr = 255;

	mov	DWORD PTR maxSymbolValue$[rsp], 255	; 000000ffH

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	r8, rcx
	lea	rdx, QWORD PTR maxSymbolValue$[rsp]
	mov	rcx, rbx
	mov	r9, rdi
	cmp	rdi, 1500				; 000005dcH
	jae	SHORT $LN17@ZSTD_estim

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	call	HIST_count_simple
	mov	eax, eax
	jmp	SHORT $LN16@ZSTD_estim
$LN17@ZSTD_estim:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbx
	mov	DWORD PTR [rsp+32], 0
	call	HIST_count_parallel_wksp
$LN16@ZSTD_estim:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 593  :         if (ZSTD_isError(largest)) return litSize;

	ja	SHORT $LN23@ZSTD_estim

; 594  :         {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);

	mov	r8d, DWORD PTR maxSymbolValue$[rsp]
	mov	rdx, rbx
	mov	rcx, rbp
	call	HUF_estimateCompressedSize

; 595  :             if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;

	cmp	DWORD PTR writeEntropy$[rsp], 0
	je	SHORT $LN9@ZSTD_estim
	add	rax, QWORD PTR [rsi+504]
$LN9@ZSTD_estim:

; 596  :             return cLitSizeEstimate + literalSectionHeaderSize;

	add	rax, 3
	jmp	SHORT $LN1@ZSTD_estim
$LN23@ZSTD_estim:

; 593  :         if (ZSTD_isError(largest)) return litSize;

	mov	rax, rdi
$LN1@ZSTD_estim:

; 600  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ZSTD_estimateSubBlockSize_literal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
max$ = 96
type$ = 96
codeTable$ = 104
maxCode$ = 112
nbSeq$ = 120
fseCTable$ = 128
additionalBits$ = 136
defaultNorm$ = 144
defaultNormLog$ = 152
workspace$ = 160
wkspSize$dead$ = 168
ZSTD_estimateSubBlockSize_symbolType PROC

; 608  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	rsi, QWORD PTR workspace$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 608  : {

	mov	r14, r9

; 609  :     unsigned* const countWksp = (unsigned*)workspace;
; 610  :     const BYTE* ctp = codeTable;
; 611  :     const BYTE* const ctStart = ctp;
; 612  :     const BYTE* const ctEnd = ctStart + nbSeq;
; 613  :     size_t cSymbolTypeSizeEstimateInBits = 0;

	xor	ebx, ebx

; 614  :     unsigned max = maxCode;

	mov	DWORD PTR max$[rsp], r8d
	mov	r9d, r8d
	mov	rdi, rdx
	mov	ebp, ecx
	lea	r15, QWORD PTR [rdx+r14]
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	r14, 1500				; 000005dcH
	jae	SHORT $LN15@ZSTD_estim

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, rdx
	mov	r9, r14
	lea	rdx, QWORD PTR max$[rsp]
	mov	rcx, rsi
	call	HIST_count_simple
	jmp	SHORT $LN41@ZSTD_estim
$LN15@ZSTD_estim:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	sil, 3
	jne	SHORT $LN14@ZSTD_estim

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rsi
	lea	rdx, QWORD PTR max$[rsp]
	mov	r9, r14
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, rdi
	mov	rcx, rsi
	call	HIST_count_parallel_wksp
$LN41@ZSTD_estim:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 617  :     if (type == set_basic) {

	mov	r9d, DWORD PTR max$[rsp]
$LN14@ZSTD_estim:
	test	ebp, ebp
	jne	SHORT $LN4@ZSTD_estim
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 127  :     unsigned const shift = 8 - accuracyLog;

	mov	r10, QWORD PTR defaultNorm$[rsp]
	mov	r11d, 8
	sub	r11d, DWORD PTR defaultNormLog$[rsp]
	mov	edx, ebx
	mov	QWORD PTR [rsp+104], r12
	lea	r12, OFFSET FLAT:kInverseProbabilityLog256
	npad	5
$LL22@ZSTD_estim:

; 128  :     size_t cost = 0;
; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	mov	r8d, edx
	movsx	eax, WORD PTR [r10+r8*2]
	cmp	ax, -1
	jne	SHORT $LN25@ZSTD_estim
	mov	eax, 1
$LN25@ZSTD_estim:

; 133  :         unsigned const norm256 = normAcc << shift;

	mov	ecx, r11d
	inc	edx
	shl	eax, cl

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [r12+rax*4]
	imul	eax, DWORD PTR [rsi+r8*4]
	add	rbx, rax
	cmp	edx, r9d
	jbe	SHORT $LL22@ZSTD_estim

; 137  :     }
; 138  :     return cost >> 8;

	mov	r12, QWORD PTR [rsp+104]
	shr	rbx, 8
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 618  :         cSymbolTypeSizeEstimateInBits = ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max);

	jmp	SHORT $LN8@ZSTD_estim
$LN4@ZSTD_estim:

; 619  :     } else if (type == set_rle) {

	cmp	ebp, 1
	je	SHORT $LN29@ZSTD_estim

; 620  :         cSymbolTypeSizeEstimateInBits = 0;
; 621  :     } else if (type == set_compressed || type == set_repeat) {

	lea	eax, DWORD PTR [rbp-2]
	cmp	eax, 1
	ja	SHORT $LN29@ZSTD_estim

; 622  :         cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);

	mov	rcx, QWORD PTR fseCTable$[rsp]
	mov	r8d, r9d
	mov	rdx, rsi
	call	ZSTD_fseBitCost
	mov	rbx, rax
$LN8@ZSTD_estim:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 624  :     if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;

	jbe	SHORT $LN29@ZSTD_estim
	lea	rax, QWORD PTR [r14+r14*4]
	add	rax, rax

; 631  : }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN29@ZSTD_estim:

; 625  :     while (ctp < ctEnd) {

	cmp	rdi, r15
	jae	SHORT $LN3@ZSTD_estim
	mov	rcx, QWORD PTR additionalBits$[rsp]
$LL32@ZSTD_estim:

; 626  :         if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];

	movzx	eax, BYTE PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN33@ZSTD_estim
	mov	eax, DWORD PTR [rcx+rax*4]
$LN33@ZSTD_estim:

; 627  :         else cSymbolTypeSizeEstimateInBits += *ctp; /* for offset, offset code is also the number of additional bits */
; 628  :         ctp++;

	add	rbx, rax
	inc	rdi
	cmp	rdi, r15
	jb	SHORT $LL32@ZSTD_estim
$LN3@ZSTD_estim:

; 629  :     }
; 630  :     return cSymbolTypeSizeEstimateInBits / 8;

	shr	rbx, 3
	mov	rax, rbx

; 631  : }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_estimateSubBlockSize_symbolType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
ctEnd$1$ = 112
max$1 = 112
ofCodeTable$ = 112
ctEnd$1$ = 120
llCodeTable$ = 120
mlCodeTable$ = 128
nbSeq$ = 136
fseTables$ = 144
max$2 = 152
fseMetadata$ = 152
max$3 = 160
workspace$ = 160
wkspSize$dead$ = 168
writeEntropy$ = 176
ZSTD_estimateSubBlockSize_sequences PROC

; 641  : {

	mov	r11, rsp
	push	rdi
	push	r13
	sub	rsp, 88					; 00000058H

; 644  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->ofType, ofCodeTable, MaxOff,

	mov	rax, QWORD PTR fseMetadata$[rsp]
	mov	rdi, rcx
	mov	QWORD PTR [r11+24], rbx

; 613  :     size_t cSymbolTypeSizeEstimateInBits = 0;

	xor	ebx, ebx

; 641  : {

	mov	QWORD PTR [r11-24], rbp
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	rbp, QWORD PTR workspace$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 644  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->ofType, ofCodeTable, MaxOff,

	mov	r13d, DWORD PTR [rax+4]

; 612  :     const BYTE* const ctEnd = ctStart + nbSeq;

	lea	rax, QWORD PTR [rcx+r9]

; 641  : {

	mov	QWORD PTR [r11-32], rsi

; 613  :     size_t cSymbolTypeSizeEstimateInBits = 0;

	mov	esi, ebx

; 641  : {

	mov	QWORD PTR [r11-40], r12
	mov	r12, rdx
	mov	QWORD PTR [r11-48], r14
	mov	r14, r8
	mov	QWORD PTR [r11-56], r15
	mov	r15, r9

; 612  :     const BYTE* const ctEnd = ctStart + nbSeq;

	mov	QWORD PTR ctEnd$1$[rsp], rax

; 614  :     unsigned max = maxCode;

	mov	r9d, 31
	mov	DWORD PTR [r11+8], r9d
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	r15, 1500				; 000005dcH
	jae	SHORT $LN18@ZSTD_estim

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, rcx
	lea	rdx, QWORD PTR [r11+8]
	mov	rcx, rbp
	mov	r9, r15
	call	HIST_count_simple
	jmp	SHORT $LN129@ZSTD_estim
$LN18@ZSTD_estim:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	bpl, 3
	jne	SHORT $LN17@ZSTD_estim

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbp
	lea	rdx, QWORD PTR max$1[rsp]
	mov	r9, r15
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, rdi
	mov	rcx, rbp
	call	HIST_count_parallel_wksp
$LN129@ZSTD_estim:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 617  :     if (type == set_basic) {

	mov	r9d, DWORD PTR max$1[rsp]
$LN17@ZSTD_estim:
	lea	r10, OFFSET FLAT:__ImageBase
	test	r13d, r13d
	jne	SHORT $LN7@ZSTD_estim
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 127  :     unsigned const shift = 8 - accuracyLog;

	mov	edx, ebx
	npad	5
$LL25@ZSTD_estim:

; 128  :     size_t cost = 0;
; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	mov	r8d, edx
	movsx	eax, WORD PTR OF_defaultNorm[r10+r8*2]
	cmp	ax, -1
	jne	SHORT $LN28@ZSTD_estim
	mov	eax, 1
$LN28@ZSTD_estim:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*8]
	inc	edx

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR kInverseProbabilityLog256[r10+rax*4]
	imul	eax, DWORD PTR [rbp+r8*4]
	add	rsi, rax
	cmp	edx, r9d
	jbe	SHORT $LL25@ZSTD_estim

; 137  :     }
; 138  :     return cost >> 8;

	shr	rsi, 8
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 618  :         cSymbolTypeSizeEstimateInBits = ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max);

	jmp	SHORT $LN11@ZSTD_estim
$LN7@ZSTD_estim:

; 619  :     } else if (type == set_rle) {

	cmp	r13d, 1
	je	SHORT $LN86@ZSTD_estim

; 620  :         cSymbolTypeSizeEstimateInBits = 0;
; 621  :     } else if (type == set_compressed || type == set_repeat) {

	lea	eax, DWORD PTR [r13-2]
	cmp	eax, 1
	ja	SHORT $LN86@ZSTD_estim

; 622  :         cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);

	mov	rcx, QWORD PTR fseTables$[rsp]
	mov	r8d, r9d
	mov	rdx, rbp
	call	ZSTD_fseBitCost
	mov	rsi, rax
$LN11@ZSTD_estim:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rsi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 624  :     if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;

	jbe	SHORT $LN86@ZSTD_estim
	lea	rsi, QWORD PTR [r15+r15*4]
	add	rsi, rsi
	jmp	SHORT $LN4@ZSTD_estim
$LN86@ZSTD_estim:

; 625  :     while (ctp < ctEnd) {

	mov	r9, QWORD PTR ctEnd$1$[rsp]
	mov	rcx, rbx
	mov	rdx, rbx
	cmp	rdi, r9
	jae	SHORT $LN111@ZSTD_estim
	cmp	r15, 2
	jb	SHORT $LN124@ZSTD_estim
	lea	r8, QWORD PTR [r9-1]
	npad	6
$LL114@ZSTD_estim:

; 627  :         else cSymbolTypeSizeEstimateInBits += *ctp; /* for offset, offset code is also the number of additional bits */

	movzx	eax, BYTE PTR [rdi]
	add	rcx, rax
	movzx	eax, BYTE PTR [rdi+1]
	add	rdx, rax
	add	rdi, 2
	cmp	rdi, r8
	jb	SHORT $LL114@ZSTD_estim

; 625  :     while (ctp < ctEnd) {

	cmp	rdi, r9
	jae	SHORT $LN113@ZSTD_estim
$LN124@ZSTD_estim:

; 627  :         else cSymbolTypeSizeEstimateInBits += *ctp; /* for offset, offset code is also the number of additional bits */

	movzx	eax, BYTE PTR [rdi]
	add	rsi, rax
$LN113@ZSTD_estim:
	lea	rax, QWORD PTR [rdx+rcx]
	add	rsi, rax
$LN111@ZSTD_estim:

; 629  :     }
; 630  :     return cSymbolTypeSizeEstimateInBits / 8;

	shr	rsi, 3
$LN4@ZSTD_estim:

; 645  :                                          nbSeq, fseTables->offcodeCTable, NULL,
; 646  :                                          OF_defaultNorm, OF_defaultNormLog,
; 647  :                                          workspace, wkspSize);
; 648  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,

	mov	rax, QWORD PTR fseMetadata$[rsp]

; 614  :     unsigned max = maxCode;

	mov	r9d, 35					; 00000023H
	mov	DWORD PTR max$3[rsp], r9d
	mov	rdi, rbx

; 645  :                                          nbSeq, fseTables->offcodeCTable, NULL,
; 646  :                                          OF_defaultNorm, OF_defaultNormLog,
; 647  :                                          workspace, wkspSize);
; 648  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,

	mov	r13d, DWORD PTR [rax]

; 612  :     const BYTE* const ctEnd = ctStart + nbSeq;

	lea	rax, QWORD PTR [r12+r15]
	mov	QWORD PTR ctEnd$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	r15, 1500				; 000005dcH
	jae	SHORT $LN45@ZSTD_estim

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r9, r15
	lea	rdx, QWORD PTR max$3[rsp]
	mov	r8, r12
	mov	rcx, rbp
	call	HIST_count_simple
	jmp	SHORT $LN130@ZSTD_estim
$LN45@ZSTD_estim:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	bpl, 3
	jne	SHORT $LN44@ZSTD_estim

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbp
	lea	rdx, QWORD PTR max$3[rsp]
	mov	r9, r15
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, r12
	mov	rcx, rbp
	call	HIST_count_parallel_wksp
$LN130@ZSTD_estim:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 617  :     if (type == set_basic) {

	mov	r9d, DWORD PTR max$3[rsp]
$LN44@ZSTD_estim:
	test	r13d, r13d
	jne	SHORT $LN34@ZSTD_estim
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 127  :     unsigned const shift = 8 - accuracyLog;

	mov	edx, ebx
	lea	r10, OFFSET FLAT:__ImageBase
	npad	3
$LL52@ZSTD_estim:

; 128  :     size_t cost = 0;
; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	mov	r8d, edx
	movsx	eax, WORD PTR LL_defaultNorm[r10+r8*2]
	cmp	ax, -1
	jne	SHORT $LN55@ZSTD_estim
	mov	eax, 1
$LN55@ZSTD_estim:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*4]
	inc	edx

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR kInverseProbabilityLog256[r10+rax*4]
	imul	eax, DWORD PTR [rbp+r8*4]
	add	rdi, rax
	cmp	edx, r9d
	jbe	SHORT $LL52@ZSTD_estim

; 137  :     }
; 138  :     return cost >> 8;

	shr	rdi, 8
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 618  :         cSymbolTypeSizeEstimateInBits = ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max);

	jmp	SHORT $LN38@ZSTD_estim
$LN34@ZSTD_estim:

; 619  :     } else if (type == set_rle) {

	cmp	r13d, 1
	je	SHORT $LN88@ZSTD_estim

; 620  :         cSymbolTypeSizeEstimateInBits = 0;
; 621  :     } else if (type == set_compressed || type == set_repeat) {

	lea	eax, DWORD PTR [r13-2]
	cmp	eax, 1
	ja	SHORT $LN88@ZSTD_estim

; 645  :                                          nbSeq, fseTables->offcodeCTable, NULL,
; 646  :                                          OF_defaultNorm, OF_defaultNormLog,
; 647  :                                          workspace, wkspSize);
; 648  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,

	mov	rcx, QWORD PTR fseTables$[rsp]

; 622  :         cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);

	mov	r8d, r9d

; 645  :                                          nbSeq, fseTables->offcodeCTable, NULL,
; 646  :                                          OF_defaultNorm, OF_defaultNormLog,
; 647  :                                          workspace, wkspSize);
; 648  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,

	add	rcx, 2224				; 000008b0H

; 622  :         cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);

	mov	rdx, rbp
	call	ZSTD_fseBitCost
	mov	rdi, rax
$LN38@ZSTD_estim:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 624  :     if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;

	jbe	SHORT $LN88@ZSTD_estim
	lea	rdi, QWORD PTR [r15+r15*4]
	add	rdi, rdi
	jmp	SHORT $LN31@ZSTD_estim
$LN88@ZSTD_estim:

; 625  :     while (ctp < ctEnd) {

	mov	rcx, QWORD PTR ctEnd$1$[rsp]
	cmp	r12, rcx
	jae	SHORT $LN33@ZSTD_estim
	lea	rdx, OFFSET FLAT:__ImageBase
	npad	8
$LL97@ZSTD_estim:

; 626  :         if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];

	movzx	eax, BYTE PTR [r12]

; 628  :         ctp++;

	inc	r12
	mov	eax, DWORD PTR LL_bits[rdx+rax*4]
	add	rdi, rax
	cmp	r12, rcx
	jb	SHORT $LL97@ZSTD_estim
$LN33@ZSTD_estim:

; 629  :     }
; 630  :     return cSymbolTypeSizeEstimateInBits / 8;

	shr	rdi, 3
$LN31@ZSTD_estim:

; 649  :                                          nbSeq, fseTables->litlengthCTable, LL_bits,
; 650  :                                          LL_defaultNorm, LL_defaultNormLog,
; 651  :                                          workspace, wkspSize);
; 652  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,

	mov	r13, QWORD PTR fseMetadata$[rsp]

; 612  :     const BYTE* const ctEnd = ctStart + nbSeq;

	lea	r12, QWORD PTR [r14+r15]

; 645  :                                          nbSeq, fseTables->offcodeCTable, NULL,
; 646  :                                          OF_defaultNorm, OF_defaultNormLog,
; 647  :                                          workspace, wkspSize);
; 648  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,

	add	rdi, rsi

; 614  :     unsigned max = maxCode;

	mov	r9d, 52					; 00000034H
	mov	DWORD PTR max$2[rsp], r9d

; 649  :                                          nbSeq, fseTables->litlengthCTable, LL_bits,
; 650  :                                          LL_defaultNorm, LL_defaultNormLog,
; 651  :                                          workspace, wkspSize);
; 652  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,

	mov	esi, DWORD PTR [r13+8]
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	r15, 1500				; 000005dcH
	jae	SHORT $LN72@ZSTD_estim

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r9, r15
	lea	rdx, QWORD PTR max$2[rsp]
	mov	r8, r14
	mov	rcx, rbp
	call	HIST_count_simple
	jmp	SHORT $LN131@ZSTD_estim
$LN72@ZSTD_estim:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	bpl, 3
	jne	SHORT $LN71@ZSTD_estim

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbp
	lea	rdx, QWORD PTR max$2[rsp]
	mov	r9, r15
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, r14
	mov	rcx, rbp
	call	HIST_count_parallel_wksp
$LN131@ZSTD_estim:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 617  :     if (type == set_basic) {

	mov	r9d, DWORD PTR max$2[rsp]
$LN71@ZSTD_estim:
	test	esi, esi
	jne	SHORT $LN61@ZSTD_estim
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 127  :     unsigned const shift = 8 - accuracyLog;

	mov	edx, ebx
	lea	r10, OFFSET FLAT:__ImageBase
	npad	9
$LL79@ZSTD_estim:

; 128  :     size_t cost = 0;
; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	mov	r8d, edx
	movsx	eax, WORD PTR ML_defaultNorm[r10+r8*2]
	cmp	ax, -1
	jne	SHORT $LN82@ZSTD_estim
	mov	eax, 1
$LN82@ZSTD_estim:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*4]
	inc	edx

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR kInverseProbabilityLog256[r10+rax*4]
	imul	eax, DWORD PTR [rbp+r8*4]
	add	rbx, rax
	cmp	edx, r9d
	jbe	SHORT $LL79@ZSTD_estim

; 137  :     }
; 138  :     return cost >> 8;

	shr	rbx, 8
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 618  :         cSymbolTypeSizeEstimateInBits = ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max);

	jmp	SHORT $LN65@ZSTD_estim
$LN61@ZSTD_estim:

; 619  :     } else if (type == set_rle) {

	cmp	esi, 1
	je	SHORT $LN90@ZSTD_estim

; 620  :         cSymbolTypeSizeEstimateInBits = 0;
; 621  :     } else if (type == set_compressed || type == set_repeat) {

	lea	eax, DWORD PTR [rsi-2]
	cmp	eax, 1
	ja	SHORT $LN90@ZSTD_estim

; 649  :                                          nbSeq, fseTables->litlengthCTable, LL_bits,
; 650  :                                          LL_defaultNorm, LL_defaultNormLog,
; 651  :                                          workspace, wkspSize);
; 652  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,

	mov	rcx, QWORD PTR fseTables$[rsp]

; 622  :         cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);

	mov	r8d, r9d

; 649  :                                          nbSeq, fseTables->litlengthCTable, LL_bits,
; 650  :                                          LL_defaultNorm, LL_defaultNormLog,
; 651  :                                          workspace, wkspSize);
; 652  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,

	add	rcx, 772				; 00000304H

; 622  :         cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);

	mov	rdx, rbp
	call	ZSTD_fseBitCost
	mov	rbx, rax
$LN65@ZSTD_estim:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 624  :     if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;

	jbe	SHORT $LN90@ZSTD_estim
	lea	rbx, QWORD PTR [r15+r15*4]
	add	rbx, rbx
	jmp	SHORT $LN58@ZSTD_estim
$LN90@ZSTD_estim:

; 625  :     while (ctp < ctEnd) {

	cmp	r14, r12
	jae	SHORT $LN60@ZSTD_estim
	lea	rcx, OFFSET FLAT:__ImageBase
$LL101@ZSTD_estim:

; 626  :         if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];

	movzx	eax, BYTE PTR [r14]

; 628  :         ctp++;

	inc	r14
	mov	eax, DWORD PTR ML_bits[rcx+rax*4]
	add	rbx, rax
	cmp	r14, r12
	jb	SHORT $LL101@ZSTD_estim
$LN60@ZSTD_estim:

; 629  :     }
; 630  :     return cSymbolTypeSizeEstimateInBits / 8;

	shr	rbx, 3
$LN58@ZSTD_estim:

; 649  :                                          nbSeq, fseTables->litlengthCTable, LL_bits,
; 650  :                                          LL_defaultNorm, LL_defaultNormLog,
; 651  :                                          workspace, wkspSize);
; 652  :     cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,

	mov	r15, QWORD PTR [rsp+48]
	add	rdi, rbx

; 653  :                                          nbSeq, fseTables->matchlengthCTable, ML_bits,
; 654  :                                          ML_defaultNorm, ML_defaultNormLog,
; 655  :                                          workspace, wkspSize);
; 656  :     if (writeEntropy) cSeqSizeEstimate += fseMetadata->fseTablesSize;

	cmp	DWORD PTR writeEntropy$[rsp], 0
	mov	r14, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+128]
	je	SHORT $LN128@ZSTD_estim
	add	rdi, QWORD PTR [r13+512]
$LN128@ZSTD_estim:

; 657  :     return cSeqSizeEstimate + sequencesSectionHeaderSize;
; 658  : }

	lea	rax, QWORD PTR [rdi+3]
	add	rsp, 88					; 00000058H
	pop	r13
	pop	rdi
	ret	0
ZSTD_estimateSubBlockSize_sequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
literals$ = 112
litSize$ = 120
ofCodeTable$ = 128
llCodeTable$ = 136
mlCodeTable$ = 144
nbSeq$ = 152
entropy$ = 160
maxSymbolValue$1 = 168
entropyMetadata$ = 168
workspace$ = 176
wkspSize$dead$ = 184
writeLitEntropy$ = 192
writeSeqEntropy$ = 200
ZSTD_estimateSubBlockSize PROC

; 668  :                                         int writeLitEntropy, int writeSeqEntropy) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 589  :     if (hufMetadata->hType == set_basic) return litSize;

	mov	rsi, QWORD PTR entropyMetadata$[rsp]

; 668  :                                         int writeLitEntropy, int writeSeqEntropy) {

	mov	r14, r9

; 589  :     if (hufMetadata->hType == set_basic) return litSize;

	mov	rdi, QWORD PTR workspace$[rsp]

; 668  :                                         int writeLitEntropy, int writeSeqEntropy) {

	mov	r15, r8

; 589  :     if (hufMetadata->hType == set_basic) return litSize;

	mov	rbp, QWORD PTR entropy$[rsp]

; 668  :                                         int writeLitEntropy, int writeSeqEntropy) {

	mov	rbx, rdx

; 589  :     if (hufMetadata->hType == set_basic) return litSize;

	mov	eax, DWORD PTR [rsi]
	test	eax, eax
	je	$LN25@ZSTD_estim

; 590  :     else if (hufMetadata->hType == set_rle) return 1;

	cmp	eax, 1
	jne	SHORT $LN6@ZSTD_estim
	mov	ebx, eax
	jmp	$LN25@ZSTD_estim
$LN6@ZSTD_estim:

; 591  :     else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN9@ZSTD_estim

; 597  :     }   }
; 598  :     assert(0); /* impossible */
; 599  :     return 0;

	xor	ebx, ebx
	jmp	SHORT $LN25@ZSTD_estim
$LN9@ZSTD_estim:
; File E:\dev\pyzstd\lib\compress\hist.c

; 170  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	dil, 3
	jne	SHORT $LN25@ZSTD_estim

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	r9, rdx

; 174  :     *maxSymbolValuePtr = 255;

	mov	DWORD PTR maxSymbolValue$1[rsp], 255	; 000000ffH

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	r8, rcx
	cmp	rdx, 1500				; 000005dcH
	mov	rcx, rdi
	lea	rdx, QWORD PTR maxSymbolValue$1[rsp]
	jae	SHORT $LN19@ZSTD_estim

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	call	HIST_count_simple
	mov	eax, eax
	jmp	SHORT $LN18@ZSTD_estim
$LN19@ZSTD_estim:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], 0
	call	HIST_count_parallel_wksp
$LN18@ZSTD_estim:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 593  :         if (ZSTD_isError(largest)) return litSize;

	ja	SHORT $LN25@ZSTD_estim

; 594  :         {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);

	mov	r8d, DWORD PTR maxSymbolValue$1[rsp]
	mov	rdx, rdi
	mov	rcx, rbp
	call	HUF_estimateCompressedSize

; 595  :             if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;

	cmp	DWORD PTR writeLitEntropy$[rsp], 0
	je	SHORT $LN11@ZSTD_estim
	add	rax, QWORD PTR [rsi+504]
$LN11@ZSTD_estim:

; 596  :             return cLitSizeEstimate + literalSectionHeaderSize;

	lea	rbx, QWORD PTR [rax+3]
$LN25@ZSTD_estim:

; 669  :     size_t cSizeEstimate = 0;
; 670  :     cSizeEstimate += ZSTD_estimateSubBlockSize_literal(literals, litSize,
; 671  :                                                          &entropy->huf, &entropyMetadata->hufMetadata,
; 672  :                                                          workspace, wkspSize, writeLitEntropy);
; 673  :     cSizeEstimate += ZSTD_estimateSubBlockSize_sequences(ofCodeTable, llCodeTable, mlCodeTable,

	mov	eax, DWORD PTR writeSeqEntropy$[rsp]
	lea	rcx, QWORD PTR [rsi+512]
	mov	r9, QWORD PTR nbSeq$[rsp]
	lea	rdx, QWORD PTR [rbp+1028]
	mov	r8, QWORD PTR mlCodeTable$[rsp]
	mov	DWORD PTR [rsp+64], eax
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], rdx
	mov	rdx, r14
	call	ZSTD_estimateSubBlockSize_sequences

; 674  :                                                          nbSeq, &entropy->fse, &entropyMetadata->fseMetadata,
; 675  :                                                          workspace, wkspSize, writeSeqEntropy);
; 676  :     return cSizeEstimate + ZSTD_blockHeaderSize;
; 677  : }

	mov	rbp, QWORD PTR [rsp+120]
	add	rax, 3
	mov	rsi, QWORD PTR [rsp+128]
	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
ZSTD_estimateSubBlockSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
fseMetadata$ = 8
ZSTD_needSequenceEntropyTables PROC

; 681  :     if (fseMetadata->llType == set_compressed || fseMetadata->llType == set_rle)

	mov	eax, DWORD PTR [rcx]
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN3@ZSTD_needS

; 683  :     if (fseMetadata->mlType == set_compressed || fseMetadata->mlType == set_rle)

	mov	eax, DWORD PTR [rcx+8]
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN3@ZSTD_needS

; 684  :         return 1;
; 685  :     if (fseMetadata->ofType == set_compressed || fseMetadata->ofType == set_rle)

	mov	eax, DWORD PTR [rcx+4]
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN3@ZSTD_needS

; 686  :         return 1;
; 687  :     return 0;

	xor	eax, eax

; 688  : }

	ret	0
$LN3@ZSTD_needS:

; 682  :         return 1;

	mov	eax, 1

; 688  : }

	ret	0
ZSTD_needSequenceEntropyTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
_TEXT	SEGMENT
writeLitEntropy$1$ = 144
writeSeqEntropy$1$ = 148
maxSymbolValue$4 = 152
litEntropyWritten$5 = 152
seqCount$1$ = 160
lp$1$ = 168
sp$1$ = 176
seqEntropyWritten$6 = 184
op$1$ = 192
cctxParams$GSCopy$1$ = 200
$T7 = 200
llCodePtr$1$ = 216
mlCodePtr$1$ = 224
ofCodePtr$1$ = 232
ip$1$ = 240
entropyMetadata$GSCopy$1$ = 248
nextCBlock$GSCopy$1$ = 256
workspace$GSCopy$1$ = 264
send$1$ = 272
prevCBlock$1$ = 280
fseMetadata$1$ = 288
oend$1$ = 296
tv1205 = 304
tv1187 = 312
targetCBlockSize$1$ = 320
dst$GSCopy$1$ = 328
srcSize$1$ = 336
rep$8 = 336
__$ArrayPad$ = 352
seqStorePtr$ = 432
prevCBlock$ = 440
nextCBlock$ = 448
entropyMetadata$ = 456
cctxParams$ = 464
dst$ = 472
dstCapacity$ = 480
src$ = 488
srcSize$ = 496
bmi2$dead$ = 504
lastBlock$ = 512
workspace$ = 520
wkspSize$dead$ = 528
ZSTD_compressSubBlock_multi PROC

; 706  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 368				; 00000170H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-272], rax
	mov	r12, QWORD PTR dst$[rbp-272]
	mov	r14, rcx
	mov	r15, QWORD PTR cctxParams$[rbp-272]
	mov	r13, r8
	mov	rdi, QWORD PTR src$[rbp-272]

; 707  :     const seqDef* const sstart = seqStorePtr->sequencesStart;
; 708  :     const seqDef* const send = seqStorePtr->sequences;

	mov	r11, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR dstCapacity$[rbp-272]
	mov	rsi, QWORD PTR [rcx]

; 709  :     const seqDef* sp = sstart;
; 710  :     const BYTE* const lstart = seqStorePtr->litStart;
; 711  :     const BYTE* const lend = seqStorePtr->lit;
; 712  :     const BYTE* lp = lstart;
; 713  :     BYTE const* ip = (BYTE const*)src;
; 714  :     BYTE const* const iend = ip + srcSize;
; 715  :     BYTE* const ostart = (BYTE*)dst;
; 716  :     BYTE* const oend = ostart + dstCapacity;

	add	rax, r12
	mov	rbx, QWORD PTR workspace$[rbp-272]
	mov	rcx, rsi
	mov	QWORD PTR oend$1$[rbp-272], rax

; 717  :     BYTE* op = ostart;
; 718  :     const BYTE* llCodePtr = seqStorePtr->llCode;

	mov	rax, QWORD PTR [r14+32]
	mov	QWORD PTR llCodePtr$1$[rbp-272], rax

; 719  :     const BYTE* mlCodePtr = seqStorePtr->mlCode;

	mov	rax, QWORD PTR [r14+40]
	mov	QWORD PTR mlCodePtr$1$[rbp-272], rax

; 720  :     const BYTE* ofCodePtr = seqStorePtr->ofCode;

	mov	rax, QWORD PTR [r14+48]
	mov	QWORD PTR ofCodePtr$1$[rbp-272], rax

; 721  :     size_t targetCBlockSize = cctxParams->targetCBlockSize;

	mov	rax, QWORD PTR [r15+56]
	mov	QWORD PTR targetCBlockSize$1$[rbp-272], rax
	mov	QWORD PTR nextCBlock$GSCopy$1$[rbp-272], r8
	mov	r8, QWORD PTR srcSize$[rbp-272]
	add	r8, rdi
	mov	QWORD PTR prevCBlock$1$[rbp-272], rdx
	mov	rdx, QWORD PTR [r14+24]
	mov	QWORD PTR srcSize$1$[rbp-272], r8

; 722  :     size_t litSize, seqCount;
; 723  :     int writeLitEntropy = entropyMetadata->hufMetadata.hType == set_compressed;

	xor	r8d, r8d
	cmp	DWORD PTR [r9], 2
	mov	eax, r8d
	mov	QWORD PTR tv1205[rbp-272], rdx
	mov	rdx, QWORD PTR [r14+16]
	sete	al
	mov	DWORD PTR writeLitEntropy$1$[rbp-272], eax
	lea	rax, QWORD PTR [r9+512]
	mov	QWORD PTR fseMetadata$1$[rbp-272], rax
	lea	rax, QWORD PTR [r13+1028]
	mov	QWORD PTR cctxParams$GSCopy$1$[rbp-272], r15

; 724  :     int writeSeqEntropy = 1;
; 725  :     int lastSequence = 0;
; 726  : 
; 727  :     DEBUGLOG(5, "ZSTD_compressSubBlock_multi (litSize=%u, nbSeq=%u)",
; 728  :                 (unsigned)(lend-lp), (unsigned)(send-sstart));
; 729  : 
; 730  :     litSize = 0;
; 731  :     seqCount = 0;

	mov	r15d, r8d
	mov	QWORD PTR ip$1$[rbp-272], rdi
	mov	edi, r8d
	mov	QWORD PTR tv1187[rbp-272], rax
	mov	QWORD PTR entropyMetadata$GSCopy$1$[rbp-272], r9
	mov	QWORD PTR dst$GSCopy$1$[rbp-272], r12
	mov	QWORD PTR workspace$GSCopy$1$[rbp-272], rbx
	mov	QWORD PTR send$1$[rbp-272], r11
	mov	QWORD PTR sp$1$[rbp-272], rcx
	mov	QWORD PTR lp$1$[rbp-272], rdx
	mov	QWORD PTR op$1$[rbp-272], r12
	mov	DWORD PTR writeSeqEntropy$1$[rbp-272], 1
	mov	QWORD PTR seqCount$1$[rbp-272], r8

; 753  :                                                        &nextCBlock->entropy, entropyMetadata,
; 754  :                                                        workspace, wkspSize, writeLitEntropy, writeSeqEntropy);
; 755  :         if (cBlockSizeEstimate > targetCBlockSize || lastSequence) {

	jmp	SHORT $LN4@ZSTD_compr
$LL130@ZSTD_compr:
	mov	r9, QWORD PTR entropyMetadata$GSCopy$1$[rbp-272]
	jmp	SHORT $LN4@ZSTD_compr
$LN132@ZSTD_compr:

; 786  :                     writeSeqEntropy = 0;
; 787  :                 }
; 788  :             }
; 789  :         }
; 790  :     } while (!lastSequence);

	xor	r8d, r8d
$LN4@ZSTD_compr:

; 732  :     do {
; 733  :         size_t cBlockSizeEstimate = 0;
; 734  :         if (sstart == send) {

	cmp	rsi, r11
	jne	SHORT $LN14@ZSTD_compr

; 735  :             lastSequence = 1;

	mov	r12d, 1

; 736  :         } else {

	jmp	SHORT $LN15@ZSTD_compr
$LN14@ZSTD_compr:

; 737  :             const seqDef* const sequence = sp + seqCount;

	lea	rcx, QWORD PTR [rcx+r15*8]

; 738  :             lastSequence = sequence == send - 1;

	mov	r12d, r8d
	lea	rax, QWORD PTR [r11-8]
	cmp	rcx, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 359  :     seqLen.litLength = seq->litLength;

	movzx	eax, WORD PTR [rcx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 738  :             lastSequence = sequence == send - 1;

	sete	r12b
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	sub	rcx, QWORD PTR [r14]
	sar	rcx, 3
	cmp	DWORD PTR [r14+76], ecx
	jne	SHORT $LN35@ZSTD_compr

; 362  :         if (seqStore->longLengthID == 1) {

	cmp	DWORD PTR [r14+72], 1
	jne	SHORT $LN35@ZSTD_compr

; 363  :             seqLen.litLength += 0xFFFF;

	add	eax, 65535				; 0000ffffH
$LN35@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 739  :             litSize += ZSTD_getSequenceLength(seqStorePtr, sequence).litLength;

	add	rdi, rax

; 740  :             seqCount++;

	inc	r15
	mov	QWORD PTR seqCount$1$[rbp-272], r15
$LN15@ZSTD_compr:

; 741  :         }
; 742  :         if (lastSequence) {
; 743  :             assert(lp <= lend);
; 744  :             assert(litSize <= (size_t)(lend - lp));
; 745  :             litSize = (size_t)(lend - lp);
; 746  :         }
; 747  :         /* I think there is an optimization opportunity here.
; 748  :          * Calling ZSTD_estimateSubBlockSize for every sequence can be wasteful
; 749  :          * since it recalculates estimate from scratch.
; 750  :          * For example, it would recount literal distribution and symbol codes everytime.
; 751  :          */
; 752  :         cBlockSizeEstimate = ZSTD_estimateSubBlockSize(lp, litSize, ofCodePtr, llCodePtr, mlCodePtr, seqCount,

	mov	rax, QWORD PTR tv1205[rbp-272]
	sub	rax, rdx
	test	r12d, r12d
	cmove	rax, rdi
	mov	rdi, rax
	mov	r13, rax

; 589  :     if (hufMetadata->hType == set_basic) return litSize;

	mov	eax, DWORD PTR [r9]
	test	eax, eax
	je	$LN119@ZSTD_compr

; 590  :     else if (hufMetadata->hType == set_rle) return 1;

	cmp	eax, 1
	jne	SHORT $LN43@ZSTD_compr
	mov	ebx, eax
	jmp	SHORT $LN40@ZSTD_compr
$LN43@ZSTD_compr:

; 591  :     else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	jbe	SHORT $LN46@ZSTD_compr

; 597  :     }   }
; 598  :     assert(0); /* impossible */
; 599  :     return 0;

	mov	rbx, r8
	jmp	SHORT $LN40@ZSTD_compr
$LN46@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\hist.c

; 170  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	bl, 3
	jne	SHORT $LN119@ZSTD_compr

; 171  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 172  :     if (*maxSymbolValuePtr < 255)
; 173  :         return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, checkMaxSymbolValue, (U32*)workSpace);
; 174  :     *maxSymbolValuePtr = 255;

	mov	DWORD PTR maxSymbolValue$4[rbp-272], 255 ; 000000ffH

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	mov	r9, rdi
	mov	rcx, rbx
	cmp	rdi, 1500				; 000005dcH
	jae	SHORT $LN56@ZSTD_compr

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, rdx
	lea	rdx, QWORD PTR maxSymbolValue$4[rbp-272]
	call	HIST_count_simple
	mov	eax, eax
	jmp	SHORT $LN55@ZSTD_compr
$LN56@ZSTD_compr:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbx
	mov	DWORD PTR [rsp+32], r8d
	mov	r8, rdx
	lea	rdx, QWORD PTR maxSymbolValue$4[rbp-272]
	call	HIST_count_parallel_wksp
$LN55@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 593  :         if (ZSTD_isError(largest)) return litSize;

	ja	SHORT $LN119@ZSTD_compr

; 594  :         {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);

	mov	r8d, DWORD PTR maxSymbolValue$4[rbp-272]
	mov	rdx, rbx
	mov	rcx, QWORD PTR nextCBlock$GSCopy$1$[rbp-272]
	call	HUF_estimateCompressedSize

; 595  :             if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;

	cmp	DWORD PTR writeLitEntropy$1$[rbp-272], 0
	je	SHORT $LN48@ZSTD_compr
	mov	rcx, QWORD PTR entropyMetadata$GSCopy$1$[rbp-272]
	add	rax, QWORD PTR [rcx+504]
$LN48@ZSTD_compr:

; 596  :             return cLitSizeEstimate + literalSectionHeaderSize;

	lea	rbx, QWORD PTR [rax+3]
	jmp	SHORT $LN40@ZSTD_compr
$LN119@ZSTD_compr:

; 673  :     cSizeEstimate += ZSTD_estimateSubBlockSize_sequences(ofCodeTable, llCodeTable, mlCodeTable,

	mov	rbx, rdi
$LN40@ZSTD_compr:
	mov	eax, DWORD PTR writeSeqEntropy$1$[rbp-272]
	mov	r9, r15
	mov	r8, QWORD PTR mlCodePtr$1$[rbp-272]
	mov	rdx, QWORD PTR llCodePtr$1$[rbp-272]
	mov	rcx, QWORD PTR ofCodePtr$1$[rbp-272]
	mov	DWORD PTR [rsp+64], eax
	mov	rax, QWORD PTR workspace$GSCopy$1$[rbp-272]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR fseMetadata$1$[rbp-272]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv1187[rbp-272]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_estimateSubBlockSize_sequences

; 674  :                                                          nbSeq, &entropy->fse, &entropyMetadata->fseMetadata,
; 675  :                                                          workspace, wkspSize, writeSeqEntropy);
; 676  :     return cSizeEstimate + ZSTD_blockHeaderSize;

	lea	rcx, QWORD PTR [rbx+3]
	add	rcx, rax

; 753  :                                                        &nextCBlock->entropy, entropyMetadata,
; 754  :                                                        workspace, wkspSize, writeLitEntropy, writeSeqEntropy);
; 755  :         if (cBlockSizeEstimate > targetCBlockSize || lastSequence) {

	cmp	rcx, QWORD PTR targetCBlockSize$1$[rbp-272]
	ja	SHORT $LN18@ZSTD_compr
	mov	rbx, QWORD PTR workspace$GSCopy$1$[rbp-272]
	mov	r8d, 0
	mov	rcx, QWORD PTR sp$1$[rbp-272]
	mov	rdx, QWORD PTR lp$1$[rbp-272]
	mov	r11, QWORD PTR send$1$[rbp-272]
	test	r12d, r12d
	je	$LL130@ZSTD_compr
$LN18@ZSTD_compr:

; 409  :     const seqDef* const send = sequences + nbSeq;

	mov	rdi, QWORD PTR sp$1$[rbp-272]
	lea	r8, QWORD PTR [r15*8]

; 756  :             int litEntropyWritten = 0;

	xor	eax, eax
	mov	DWORD PTR litEntropyWritten$5[rbp-272], eax

; 411  :     size_t matchLengthSum = 0;

	mov	r9d, eax

; 757  :             int seqEntropyWritten = 0;

	mov	DWORD PTR seqEntropyWritten$6[rbp-272], eax

; 409  :     const seqDef* const send = sequences + nbSeq;

	lea	r15, QWORD PTR [r8+rdi]

; 412  :     size_t litLengthSum = 0;
; 413  :     while (send-sp > 0) {

	test	r8, -8
	jle	SHORT $LN64@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	mov	rax, QWORD PTR [r14]
	mov	rdx, rdi
	mov	r10d, DWORD PTR [r14+76]
	sub	rdx, rax
	lea	r11, QWORD PTR [rax+6]
	npad	1
$LL63@ZSTD_compr:

; 360  :     seqLen.matchLength = seq->matchLength + MINMATCH;

	movzx	ecx, WORD PTR [r11+rdx]

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	mov	rax, rdx
	add	ecx, 3
	sar	rax, 3
	cmp	r10d, eax
	jne	SHORT $LN70@ZSTD_compr

; 364  :         }
; 365  :         if (seqStore->longLengthID == 2) {

	cmp	DWORD PTR [r14+72], 2
	jne	SHORT $LN70@ZSTD_compr

; 366  :             seqLen.matchLength += 0xFFFF;

	add	ecx, 65535				; 0000ffffH
$LN70@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 416  :         matchLengthSum += seqLen.matchLength;

	mov	eax, ecx

; 417  :         sp++;

	add	rdx, 8
	add	r9, rax
	sub	r8, 8
	test	r8, -8
	jg	SHORT $LL63@ZSTD_compr
	xor	eax, eax
$LN64@ZSTD_compr:

; 758  :             const size_t decompressedSize = ZSTD_seqDecompressedSize(seqStorePtr, sp, seqCount, litSize, lastSequence);
; 759  :             const size_t cSize = ZSTD_compressSubBlock(&nextCBlock->entropy, entropyMetadata,

	cmp	DWORD PTR lastBlock$[rbp-272], 0

; 423  :     return matchLengthSum + litSize;

	lea	rbx, QWORD PTR [r9+r13]

; 758  :             const size_t decompressedSize = ZSTD_seqDecompressedSize(seqStorePtr, sp, seqCount, litSize, lastSequence);
; 759  :             const size_t cSize = ZSTD_compressSubBlock(&nextCBlock->entropy, entropyMetadata,

	je	SHORT $LN31@ZSTD_compr
	mov	ecx, 1
	test	r12d, r12d
	jne	SHORT $LN32@ZSTD_compr
$LN31@ZSTD_compr:
	mov	ecx, eax
$LN32@ZSTD_compr:
	mov	rdx, QWORD PTR op$1$[rbp-272]
	mov	r8, rdi
	mov	rax, QWORD PTR oend$1$[rbp-272]
	mov	r9, QWORD PTR seqCount$1$[rbp-272]
	sub	rax, rdx
	mov	DWORD PTR [rsp+136], ecx
	lea	rcx, QWORD PTR seqEntropyWritten$6[rbp-272]
	mov	QWORD PTR [rsp+128], rcx
	lea	rcx, QWORD PTR litEntropyWritten$5[rbp-272]
	mov	QWORD PTR [rsp+120], rcx
	mov	ecx, DWORD PTR writeSeqEntropy$1$[rbp-272]
	mov	DWORD PTR [rsp+112], ecx
	mov	ecx, DWORD PTR writeLitEntropy$1$[rbp-272]
	mov	DWORD PTR [rsp+104], ecx
	mov	rcx, QWORD PTR nextCBlock$GSCopy$1$[rbp-272]
	mov	QWORD PTR [rsp+88], rax
	mov	rax, QWORD PTR cctxParams$GSCopy$1$[rbp-272]
	mov	QWORD PTR [rsp+80], rdx
	mov	rdx, QWORD PTR entropyMetadata$GSCopy$1$[rbp-272]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR ofCodePtr$1$[rbp-272]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR mlCodePtr$1$[rbp-272]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR llCodePtr$1$[rbp-272]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR lp$1$[rbp-272]
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressSubBlock
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 768  :             FORWARD_IF_ERROR(cSize, "ZSTD_compressSubBlock failed");

	ja	$LN108@ZSTD_compr

; 769  :             if (cSize > 0 && cSize < decompressedSize) {

	mov	r10, QWORD PTR ip$1$[rbp-272]
	mov	rdi, r13
	mov	rdx, QWORD PTR lp$1$[rbp-272]
	mov	r8d, DWORD PTR writeSeqEntropy$1$[rbp-272]
	test	rax, rax
	je	SHORT $LN129@ZSTD_compr
	cmp	rax, rbx
	jae	SHORT $LN129@ZSTD_compr

; 770  :                 DEBUGLOG(5, "Committed the sub-block");
; 771  :                 assert(ip + decompressedSize <= iend);
; 772  :                 ip += decompressedSize;
; 773  :                 sp += seqCount;
; 774  :                 lp += litSize;
; 775  :                 op += cSize;
; 776  :                 llCodePtr += seqCount;
; 777  :                 mlCodePtr += seqCount;
; 778  :                 ofCodePtr += seqCount;
; 779  :                 litSize = 0;

	xor	r9d, r9d
	add	rdx, r13
	mov	r13, QWORD PTR op$1$[rbp-272]
	add	r10, rbx
	add	r13, rax
	mov	QWORD PTR ip$1$[rbp-272], r10
	mov	rax, QWORD PTR seqCount$1$[rbp-272]
	mov	edi, r9d
	add	QWORD PTR llCodePtr$1$[rbp-272], rax
	mov	rcx, r15
	add	QWORD PTR mlCodePtr$1$[rbp-272], rax

; 780  :                 seqCount = 0;

	mov	r15d, r9d
	add	QWORD PTR ofCodePtr$1$[rbp-272], rax

; 781  :                 /* Entropy only needs to be written once */
; 782  :                 if (litEntropyWritten) {

	cmp	DWORD PTR litEntropyWritten$5[rbp-272], edi
	mov	eax, DWORD PTR writeLitEntropy$1$[rbp-272]
	cmovne	eax, r9d
	mov	QWORD PTR sp$1$[rbp-272], rcx

; 783  :                     writeLitEntropy = 0;
; 784  :                 }
; 785  :                 if (seqEntropyWritten) {

	cmp	DWORD PTR seqEntropyWritten$6[rbp-272], edi
	mov	QWORD PTR lp$1$[rbp-272], rdx
	cmovne	r8d, r9d
	mov	QWORD PTR op$1$[rbp-272], r13
	mov	DWORD PTR writeSeqEntropy$1$[rbp-272], r8d
	mov	QWORD PTR seqCount$1$[rbp-272], r9
	mov	DWORD PTR writeLitEntropy$1$[rbp-272], eax
	jmp	SHORT $LN2@ZSTD_compr
$LN129@ZSTD_compr:

; 786  :                     writeSeqEntropy = 0;
; 787  :                 }
; 788  :             }
; 789  :         }
; 790  :     } while (!lastSequence);

	mov	eax, DWORD PTR writeLitEntropy$1$[rbp-272]
	mov	r13, QWORD PTR op$1$[rbp-272]
	mov	rcx, QWORD PTR sp$1$[rbp-272]
	mov	r15, QWORD PTR seqCount$1$[rbp-272]
$LN2@ZSTD_compr:
	mov	rbx, QWORD PTR workspace$GSCopy$1$[rbp-272]
	mov	r9, QWORD PTR entropyMetadata$GSCopy$1$[rbp-272]
	mov	r11, QWORD PTR send$1$[rbp-272]
	test	r12d, r12d
	je	$LN132@ZSTD_compr

; 791  :     if (writeLitEntropy) {

	mov	r15, QWORD PTR nextCBlock$GSCopy$1$[rbp-272]
	mov	r12, QWORD PTR prevCBlock$1$[rbp-272]
	test	eax, eax
	je	SHORT $LN24@ZSTD_compr

; 792  :         DEBUGLOG(5, "ZSTD_compressSubBlock_multi has literal entropy tables unwritten");
; 793  :         memcpy(&nextCBlock->entropy.huf, &prevCBlock->entropy.huf, sizeof(prevCBlock->entropy.huf));

	mov	rcx, r15
	mov	rax, r12
	mov	edx, 8
	npad	4
$LL127@ZSTD_compr:
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx-128], xmm0
	movups	xmm1, XMMWORD PTR [rax-112]
	movups	XMMWORD PTR [rcx-112], xmm1
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx-96], xmm0
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx-80], xmm1
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx-48], xmm1
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx-32], xmm0
	movups	xmm1, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL127@ZSTD_compr
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax
$LN24@ZSTD_compr:

; 794  :     }
; 795  :     if (writeSeqEntropy && ZSTD_needSequenceEntropyTables(&entropyMetadata->fseMetadata)) {

	test	r8d, r8d
	je	SHORT $LN25@ZSTD_compr

; 681  :     if (fseMetadata->llType == set_compressed || fseMetadata->llType == set_rle)

	mov	rcx, QWORD PTR fseMetadata$1$[rbp-272]
	mov	eax, DWORD PTR [rcx]
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN76@ZSTD_compr

; 682  :         return 1;
; 683  :     if (fseMetadata->mlType == set_compressed || fseMetadata->mlType == set_rle)

	mov	eax, DWORD PTR [rcx+8]
	dec	eax
	cmp	eax, 1
	jbe	SHORT $LN76@ZSTD_compr

; 684  :         return 1;
; 685  :     if (fseMetadata->ofType == set_compressed || fseMetadata->ofType == set_rle)

	mov	eax, DWORD PTR [rcx+4]
	dec	eax
	cmp	eax, 1
	ja	SHORT $LN25@ZSTD_compr
$LN76@ZSTD_compr:

; 796  :         /* If we haven't written our entropy tables, then we've violated our contract and
; 797  :          * must emit an uncompressed block.
; 798  :          */
; 799  :         DEBUGLOG(5, "ZSTD_compressSubBlock_multi has sequence entropy tables unwritten");
; 800  :         return 0;

	xor	eax, eax
	jmp	$LN108@ZSTD_compr
$LN25@ZSTD_compr:

; 801  :     }
; 802  :     if (ip < iend) {

	mov	rdx, QWORD PTR srcSize$1$[rbp-272]
	cmp	r10, rdx
	jae	$LN29@ZSTD_compr

; 803  :         size_t const cSize = ZSTD_noCompressBlock(op, oend - op, ip, iend - ip, lastBlock);

	mov	rcx, QWORD PTR oend$1$[rbp-272]
	sub	rdx, r10
	sub	rcx, r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 371  :     U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);

	lea	rax, QWORD PTR [rdx*8]
	add	eax, DWORD PTR lastBlock$[rbp-272]

; 372  :     RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,

	lea	rbx, QWORD PTR [rdx+3]
	cmp	rbx, rcx
	jbe	SHORT $LN83@ZSTD_compr
	mov	rbx, -70				; ffffffffffffffbaH
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 805  :         FORWARD_IF_ERROR(cSize, "ZSTD_noCompressBlock failed");

	mov	rax, rbx
	jmp	$LN108@ZSTD_compr
$LN83@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [r13], ax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	lea	rcx, QWORD PTR [r13+3]
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	eax, 16
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	r8, rdx
	mov	rdx, r10
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [r13+2], al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	call	memcpy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 805  :         FORWARD_IF_ERROR(cSize, "ZSTD_noCompressBlock failed");

	jbe	SHORT $LN8@ZSTD_compr
	mov	rax, rbx
	jmp	$LN108@ZSTD_compr
$LN8@ZSTD_compr:

; 806  :         assert(cSize != 0);
; 807  :         op += cSize;
; 808  :         /* We have to regenerate the repcodes because we've skipped some sequences */
; 809  :         if (sp < send) {

	mov	rdi, QWORD PTR sp$1$[rbp-272]
	add	r13, rbx
	cmp	rdi, QWORD PTR send$1$[rbp-272]
	jae	$LN29@ZSTD_compr

; 810  :             seqDef const* seq;
; 811  :             repcodes_t rep;
; 812  :             memcpy(&rep, prevCBlock->rep, sizeof(rep)); 

	movsd	xmm0, QWORD PTR [r12+4580]
	mov	eax, DWORD PTR [r12+4588]
	movsd	QWORD PTR rep$8[rbp-272], xmm0
	mov	DWORD PTR rep$8[rbp-264], eax

; 813  :             for (seq = sstart; seq < sp; ++seq) {

	cmp	rsi, rdi
	jae	$LN12@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	mov	r10, QWORD PTR [r14]
	mov	r11d, DWORD PTR [r14+76]
	npad	11
$LL13@ZSTD_compr:

; 359  :     seqLen.litLength = seq->litLength;

	mov	rcx, rsi
	sub	rcx, r10
	movzx	r9d, WORD PTR [rcx+r10+4]

; 361  :     if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {

	sar	rcx, 3
	cmp	r11d, ecx
	jne	SHORT $LN92@ZSTD_compr

; 362  :         if (seqStore->longLengthID == 1) {

	cmp	DWORD PTR [r14+72], 1
	jne	SHORT $LN92@ZSTD_compr

; 363  :             seqLen.litLength += 0xFFFF;

	add	r9d, 65535				; 0000ffffH
$LN92@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 814  :                 rep = ZSTD_updateRep(rep.rep, seq->offset - 1, ZSTD_getSequenceLength(seqStorePtr, seq).litLength == 0);

	mov	r8d, DWORD PTR [rsi]
	dec	r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 336  :     if (offset >= ZSTD_REP_NUM) {  /* full offset */

	cmp	r8d, 3
	jb	SHORT $LN96@ZSTD_compr

; 337  :         newReps.rep[2] = rep[1];
; 338  :         newReps.rep[1] = rep[0];

	mov	ecx, DWORD PTR rep$8[rbp-272]
	mov	rax, QWORD PTR rep$8[rbp-272]
	mov	DWORD PTR $T7[rbp-268], ecx

; 339  :         newReps.rep[0] = offset - ZSTD_REP_MOVE;

	lea	ecx, DWORD PTR [r8-2]
	mov	DWORD PTR $T7[rbp-272], ecx
	shr	rax, 32					; 00000020H

; 340  :     } else {   /* repcode */

	jmp	SHORT $LN99@ZSTD_compr
$LN96@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 814  :                 rep = ZSTD_updateRep(rep.rep, seq->offset - 1, ZSTD_getSequenceLength(seqStorePtr, seq).litLength == 0);

	xor	edx, edx
	test	r9d, r9d
	sete	dl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 341  :         U32 const repCode = offset + ll0;

	add	edx, r8d

; 342  :         if (repCode > 0) {  /* note : if repCode==0, no change */

	je	SHORT $LN98@ZSTD_compr

; 343  :             U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	mov	r8d, DWORD PTR rep$8[rbp-272]
	cmp	edx, 3
	jne	SHORT $LN101@ZSTD_compr
	lea	ecx, DWORD PTR [r8-1]
	jmp	SHORT $LN120@ZSTD_compr
$LN101@ZSTD_compr:
	mov	ecx, DWORD PTR rep$8[rbp+rdx*4-272]

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	cmp	edx, 2
	jb	SHORT $LN103@ZSTD_compr
$LN120@ZSTD_compr:
	mov	rax, QWORD PTR rep$8[rbp-272]
	shr	rax, 32					; 00000020H
$LN103@ZSTD_compr:

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR $T7[rbp-268], r8d

; 346  :             newReps.rep[0] = currentOffset;

	mov	DWORD PTR $T7[rbp-272], ecx

; 347  :         } else {   /* repCode == 0 */

	jmp	SHORT $LN99@ZSTD_compr
$LN98@ZSTD_compr:

; 348  :             memcpy(&newReps, rep, sizeof(newReps));

	movsd	QWORD PTR $T7[rbp-272], xmm0
$LN99@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 814  :                 rep = ZSTD_updateRep(rep.rep, seq->offset - 1, ZSTD_getSequenceLength(seqStorePtr, seq).litLength == 0);

	movsd	xmm0, QWORD PTR $T7[rbp-272]
	add	rsi, 8
	movsd	QWORD PTR rep$8[rbp-272], xmm0
	mov	DWORD PTR rep$8[rbp-264], eax
	cmp	rsi, rdi
	jb	$LL13@ZSTD_compr
$LN12@ZSTD_compr:

; 815  :             }
; 816  :             memcpy(nextCBlock->rep, &rep, sizeof(rep));

	movsd	QWORD PTR [r15+4580], xmm0
	mov	DWORD PTR [r15+4588], eax
$LN29@ZSTD_compr:

; 817  :         }
; 818  :     }
; 819  :     DEBUGLOG(5, "ZSTD_compressSubBlock_multi compressed");
; 820  :     return op-ostart;

	sub	r13, QWORD PTR dst$GSCopy$1$[rbp-272]
	mov	rax, r13
$LN108@ZSTD_compr:

; 821  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-272]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+440]
	add	rsp, 368				; 00000170H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressSubBlock_multi ENDP
_TEXT	ENDS
END
