; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

$SG4294966996 DB 'Unspecified error code', 00H
?notErrorCode@?1??ERR_getErrorString@@9@9 DQ FLAT:$SG4294966996 ; `ERR_getErrorString'::`2'::notErrorCode
PUBLIC	ERR_getErrorString
	ORG $+2
$SG4294966970 DB 'Destination buffer is wrong', 00H
$SG4294966971 DB 'An I/O error occurred when reading/seeking', 00H
	ORG $+5
$SG4294966972 DB 'Frame index is too large', 00H
	ORG $+5
$SG4294966973 DB 'Operation on NULL destination buffer', 00H
	ORG $+3
$SG4294966974 DB 'Src size is incorrect', 00H
	ORG $+2
$SG4294966975 DB 'Destination buffer is too small', 00H
$SG4294966976 DB 'Cannot create Dictionary from provided samples', 00H
	ORG $+1
$SG4294966977 DB 'Dictionary mismatch', 00H
	ORG $+4
$SG4294966978 DB 'Dictionary is corrupted', 00H
$SG4294966979 DB 'Specified maxSymbolValue is too small', 00H
	ORG $+2
$SG4294966980 DB 'Unsupported max Symbol Value : too large', 00H
	ORG $+5
$SG4294966981 DB 'tableLog requires too much memory : unsupported', 00H
$SG4294966982 DB 'Operation not authorized at current processing stage', 00H
	ORG $+3
$SG4294966983 DB 'workSpace buffer is not large enough', 00H
	ORG $+3
$SG4294966984 DB 'Allocation error : not enough memory', 00H
	ORG $+3
$SG4294966985 DB 'Context should be init first', 00H
	ORG $+3
$SG4294966986 DB 'Parameter is out of bound', 00H
	ORG $+6
$SG4294966987 DB 'Unsupported parameter', 00H
	ORG $+2
$SG4294966988 DB 'Restored data doesn''t match checksum', 00H
	ORG $+3
$SG4294966989 DB 'Corrupted block detected', 00H
	ORG $+6
$SG4294966990 DB 'Frame requires too much memory for decoding', 00H
	ORG $+4
$SG4294966991 DB 'Unsupported frame parameter', 00H
	ORG $+4
$SG4294966992 DB 'Version not supported', 00H
	ORG $+2
$SG4294966993 DB 'Unknown frame descriptor', 00H
	ORG $+6
$SG4294966994 DB 'Error (generic)', 00H
$SG4294966995 DB 'No error detected', 00H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.c
_TEXT	SEGMENT
code$ = 8
ERR_getErrorString PROC

; 17   : #ifdef ZSTD_STRIP_ERROR_STRINGS
; 18   :     (void)code;
; 19   :     return "Error strings stripped";
; 20   : #else
; 21   :     static const char* const notErrorCode = "Unspecified error code";
; 22   :     switch( code )

	cmp	ecx, 104				; 00000068H
	ja	$LN30@ERR_getErr
	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN32@ERR_getErr[rdx+rax]
	mov	ecx, DWORD PTR $LN33@ERR_getErr[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN4@ERR_getErr:

; 23   :     {
; 24   :     case PREFIX(no_error): return "No error detected";

	lea	rax, OFFSET FLAT:$SG4294966995

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN5@ERR_getErr:

; 25   :     case PREFIX(GENERIC):  return "Error (generic)";

	lea	rax, OFFSET FLAT:$SG4294966994

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN6@ERR_getErr:

; 26   :     case PREFIX(prefix_unknown): return "Unknown frame descriptor";

	lea	rax, OFFSET FLAT:$SG4294966993

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN7@ERR_getErr:

; 27   :     case PREFIX(version_unsupported): return "Version not supported";

	lea	rax, OFFSET FLAT:$SG4294966992

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN8@ERR_getErr:

; 28   :     case PREFIX(frameParameter_unsupported): return "Unsupported frame parameter";

	lea	rax, OFFSET FLAT:$SG4294966991

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN9@ERR_getErr:

; 29   :     case PREFIX(frameParameter_windowTooLarge): return "Frame requires too much memory for decoding";

	lea	rax, OFFSET FLAT:$SG4294966990

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN10@ERR_getErr:

; 30   :     case PREFIX(corruption_detected): return "Corrupted block detected";

	lea	rax, OFFSET FLAT:$SG4294966989

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN11@ERR_getErr:

; 31   :     case PREFIX(checksum_wrong): return "Restored data doesn't match checksum";

	lea	rax, OFFSET FLAT:$SG4294966988

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN12@ERR_getErr:

; 32   :     case PREFIX(parameter_unsupported): return "Unsupported parameter";

	lea	rax, OFFSET FLAT:$SG4294966987

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN13@ERR_getErr:

; 33   :     case PREFIX(parameter_outOfBound): return "Parameter is out of bound";

	lea	rax, OFFSET FLAT:$SG4294966986

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN14@ERR_getErr:

; 34   :     case PREFIX(init_missing): return "Context should be init first";

	lea	rax, OFFSET FLAT:$SG4294966985

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN15@ERR_getErr:

; 35   :     case PREFIX(memory_allocation): return "Allocation error : not enough memory";

	lea	rax, OFFSET FLAT:$SG4294966984

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN16@ERR_getErr:

; 36   :     case PREFIX(workSpace_tooSmall): return "workSpace buffer is not large enough";

	lea	rax, OFFSET FLAT:$SG4294966983

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN17@ERR_getErr:

; 37   :     case PREFIX(stage_wrong): return "Operation not authorized at current processing stage";

	lea	rax, OFFSET FLAT:$SG4294966982

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN18@ERR_getErr:

; 38   :     case PREFIX(tableLog_tooLarge): return "tableLog requires too much memory : unsupported";

	lea	rax, OFFSET FLAT:$SG4294966981

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN19@ERR_getErr:

; 39   :     case PREFIX(maxSymbolValue_tooLarge): return "Unsupported max Symbol Value : too large";

	lea	rax, OFFSET FLAT:$SG4294966980

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN20@ERR_getErr:

; 40   :     case PREFIX(maxSymbolValue_tooSmall): return "Specified maxSymbolValue is too small";

	lea	rax, OFFSET FLAT:$SG4294966979

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN21@ERR_getErr:

; 41   :     case PREFIX(dictionary_corrupted): return "Dictionary is corrupted";

	lea	rax, OFFSET FLAT:$SG4294966978

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN22@ERR_getErr:

; 42   :     case PREFIX(dictionary_wrong): return "Dictionary mismatch";

	lea	rax, OFFSET FLAT:$SG4294966977

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN23@ERR_getErr:

; 43   :     case PREFIX(dictionaryCreation_failed): return "Cannot create Dictionary from provided samples";

	lea	rax, OFFSET FLAT:$SG4294966976

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN24@ERR_getErr:

; 44   :     case PREFIX(dstSize_tooSmall): return "Destination buffer is too small";

	lea	rax, OFFSET FLAT:$SG4294966975

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN25@ERR_getErr:

; 45   :     case PREFIX(srcSize_wrong): return "Src size is incorrect";

	lea	rax, OFFSET FLAT:$SG4294966974

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN26@ERR_getErr:

; 46   :     case PREFIX(dstBuffer_null): return "Operation on NULL destination buffer";

	lea	rax, OFFSET FLAT:$SG4294966973

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN27@ERR_getErr:

; 47   :         /* following error codes are not stable and may be removed or changed in a future version */
; 48   :     case PREFIX(frameIndex_tooLarge): return "Frame index is too large";

	lea	rax, OFFSET FLAT:$SG4294966972

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN28@ERR_getErr:

; 49   :     case PREFIX(seekableIO): return "An I/O error occurred when reading/seeking";

	lea	rax, OFFSET FLAT:$SG4294966971

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN29@ERR_getErr:

; 50   :     case PREFIX(dstBuffer_wrong): return "Destination buffer is wrong";

	lea	rax, OFFSET FLAT:$SG4294966970

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
$LN30@ERR_getErr:

; 51   :     case PREFIX(maxCode):
; 52   :     default: return notErrorCode;

	lea	rax, OFFSET FLAT:$SG4294966996

; 53   :     }
; 54   : #endif
; 55   : }

	ret	0
	npad	1
$LN33@ERR_getErr:
	DD	$LN4@ERR_getErr
	DD	$LN5@ERR_getErr
	DD	$LN6@ERR_getErr
	DD	$LN7@ERR_getErr
	DD	$LN8@ERR_getErr
	DD	$LN9@ERR_getErr
	DD	$LN10@ERR_getErr
	DD	$LN11@ERR_getErr
	DD	$LN21@ERR_getErr
	DD	$LN22@ERR_getErr
	DD	$LN23@ERR_getErr
	DD	$LN12@ERR_getErr
	DD	$LN13@ERR_getErr
	DD	$LN18@ERR_getErr
	DD	$LN19@ERR_getErr
	DD	$LN20@ERR_getErr
	DD	$LN17@ERR_getErr
	DD	$LN14@ERR_getErr
	DD	$LN15@ERR_getErr
	DD	$LN16@ERR_getErr
	DD	$LN24@ERR_getErr
	DD	$LN25@ERR_getErr
	DD	$LN26@ERR_getErr
	DD	$LN27@ERR_getErr
	DD	$LN28@ERR_getErr
	DD	$LN29@ERR_getErr
	DD	$LN30@ERR_getErr
$LN32@ERR_getErr:
	DB	0
	DB	1
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	2
	DB	26
	DB	3
	DB	26
	DB	4
	DB	26
	DB	5
	DB	26
	DB	26
	DB	26
	DB	6
	DB	26
	DB	7
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	8
	DB	26
	DB	9
	DB	26
	DB	10
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	11
	DB	26
	DB	12
	DB	26
	DB	13
	DB	26
	DB	14
	DB	26
	DB	15
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	16
	DB	26
	DB	17
	DB	26
	DB	18
	DB	26
	DB	19
	DB	26
	DB	26
	DB	26
	DB	20
	DB	26
	DB	21
	DB	26
	DB	22
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	23
	DB	26
	DB	24
	DB	26
	DB	25
ERR_getErrorString ENDP
_TEXT	ENDS
END
