; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_malloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__security_check_cookie:PROC
BIT_mask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	DD	01ffffH
	DD	03ffffH
	DD	07ffffH
	DD	0fffffH
	DD	01fffffH
	DD	03fffffH
	DD	07fffffH
	DD	0ffffffH
	DD	01ffffffH
	DD	03ffffffH
	DD	07ffffffH
	DD	0fffffffH
	DD	01fffffffH
	DD	03fffffffH
	DD	07fffffffH
PUBLIC	FSE_decompress_wksp
PUBLIC	FSE_decompress_usingDTable
PUBLIC	FSE_buildDTable
PUBLIC	__isa_available_default
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__xmm@00000001000000010000000100000001
PUBLIC	__xmm@f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__isa_available:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT __isa_available_default
_BSS	SEGMENT
__isa_available_default DD 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$FSE_decompress_wksp DD imagerel $LN11
	DD	imagerel $LN11+191
	DD	imagerel $unwind$FSE_decompress_wksp
$pdata$FSE_decompress_usingDTable DD imagerel $LN544
	DD	imagerel $LN544+1937
	DD	imagerel $unwind$FSE_decompress_usingDTable
$pdata$FSE_decompress_usingDTable_generic DD imagerel FSE_decompress_usingDTable_generic
	DD	imagerel FSE_decompress_usingDTable_generic+57
	DD	imagerel $unwind$FSE_decompress_usingDTable_generic
$pdata$5$FSE_decompress_usingDTable_generic DD imagerel FSE_decompress_usingDTable_generic+57
	DD	imagerel FSE_decompress_usingDTable_generic+1238
	DD	imagerel $chain$5$FSE_decompress_usingDTable_generic
$pdata$6$FSE_decompress_usingDTable_generic DD imagerel FSE_decompress_usingDTable_generic+1238
	DD	imagerel FSE_decompress_usingDTable_generic+1245
	DD	imagerel $chain$6$FSE_decompress_usingDTable_generic
$pdata$7$FSE_decompress_usingDTable_generic DD imagerel FSE_decompress_usingDTable_generic+1245
	DD	imagerel FSE_decompress_usingDTable_generic+1305
	DD	imagerel $chain$7$FSE_decompress_usingDTable_generic
$pdata$FSE_buildDTable DD imagerel $LN48
	DD	imagerel $LN48+112
	DD	imagerel $unwind$FSE_buildDTable
$pdata$0$FSE_buildDTable DD imagerel $LN48+112
	DD	imagerel $LN48+433
	DD	imagerel $chain$0$FSE_buildDTable
$pdata$1$FSE_buildDTable DD imagerel $LN48+433
	DD	imagerel $LN48+467
	DD	imagerel $chain$1$FSE_buildDTable
$pdata$FSE_initDState DD imagerel FSE_initDState
	DD	imagerel FSE_initDState+82
	DD	imagerel $unwind$FSE_initDState
$pdata$BIT_reloadDStream DD imagerel BIT_reloadDStream
	DD	imagerel BIT_reloadDStream+175
	DD	imagerel $unwind$BIT_reloadDStream
;	COMDAT __xmm@f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0
CONST	SEGMENT
__xmm@f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0 DB 0f0H, 0f0H, 0f0H, 0f0H, 0f0H, 0f0H
	DB	0f0H, 0f0H, 0f0H, 0f0H, 0f0H, 0f0H, 0f0H, 0f0H, 0f0H, 0f0H
CONST	ENDS
;	COMDAT __xmm@00000001000000010000000100000001
CONST	SEGMENT
__xmm@00000001000000010000000100000001 DB 01H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
xdata	SEGMENT
$unwind$FSE_decompress_wksp DD 072019H
	DD	04a010eH
	DD	07005e007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$FSE_decompress_usingDTable DD 0c2401H
	DD	0137424H
	DD	0126424H
	DD	0113424H
	DD	0f01d9224H
	DD	0d019e01bH
	DD	05015c017H
$unwind$FSE_decompress_usingDTable_generic DD 031301H
	DD	0300ce213H
	DD	0500bH
$chain$5$FSE_decompress_usingDTable_generic DD 0c2e21H
	DD	0af42eH
	DD	0be429H
	DD	0cd41fH
	DD	0dc416H
	DD	0e740dH
	DD	0146408H
	DD	imagerel FSE_decompress_usingDTable_generic
	DD	imagerel FSE_decompress_usingDTable_generic+57
	DD	imagerel $unwind$FSE_decompress_usingDTable_generic
$chain$6$FSE_decompress_usingDTable_generic DD 021H
	DD	imagerel FSE_decompress_usingDTable_generic
	DD	imagerel FSE_decompress_usingDTable_generic+57
	DD	imagerel $unwind$FSE_decompress_usingDTable_generic
$chain$7$FSE_decompress_usingDTable_generic DD 0c0021H
	DD	0af400H
	DD	0be400H
	DD	0cd400H
	DD	0dc400H
	DD	0e7400H
	DD	0146400H
	DD	imagerel FSE_decompress_usingDTable_generic
	DD	imagerel FSE_decompress_usingDTable_generic+57
	DD	imagerel $unwind$FSE_decompress_usingDTable_generic
$unwind$FSE_buildDTable DD 092419H
	DD	0440112H
	DD	0e009f00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0210H
$chain$0$FSE_buildDTable DD 020821H
	DD	04dd408H
	DD	imagerel $LN48
	DD	imagerel $LN48+112
	DD	imagerel $unwind$FSE_buildDTable
$chain$1$FSE_buildDTable DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+112
	DD	imagerel $unwind$FSE_buildDTable
$unwind$FSE_initDState DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$BIT_reloadDStream DD 036601H
	DD	03466H
	DD	0204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLEST PROC

; 384  :     if (MEM_32bits())
; 385  :         return (size_t)MEM_readLE32(memPtr);
; 386  :     else
; 387  :         return (size_t)MEM_readLE64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 388  : }

	ret	0
MEM_readLEST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
val$ = 8
BIT_highbit32 PROC

; 141  :     assert(val != 0);
; 142  :     {
; 143  : #   if defined(_MSC_VER)   /* Visual */
; 144  :         unsigned long r=0;

	xor	eax, eax

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 146  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* Use GCC Intrinsic */
; 147  :         return __builtin_clz (val) ^ 31;
; 148  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 149  :         return 31 - __CLZ(val);
; 150  : #   else   /* Software version */
; 151  :         static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,
; 152  :                                                  11, 14, 16, 18, 22, 25,  3, 30,
; 153  :                                                   8, 12, 20, 28, 15, 17, 24,  7,
; 154  :                                                  19, 27, 23,  6, 26,  5,  4, 31 };
; 155  :         U32 v = val;
; 156  :         v |= v >> 1;
; 157  :         v |= v >> 2;
; 158  :         v |= v >> 4;
; 159  :         v |= v >> 8;
; 160  :         v |= v >> 16;
; 161  :         return DeBruijnClz[ (U32) (v * 0x07C4ACDDU) >> 27];
; 162  : #   endif
; 163  :     }
; 164  : }

	ret	0
BIT_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
srcBuffer$ = 16
srcSize$ = 24
BIT_initDStream PROC

; 273  : {

	mov	r9, rcx

; 274  :     if (srcSize < 1) { memset(bitD, 0, sizeof(*bitD)); return ERROR(srcSize_wrong); }

	cmp	r8, 1
	jae	SHORT $LN4@BIT_initDS
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	QWORD PTR [rcx+32], rax
	mov	rax, -72				; ffffffffffffffb8H

; 318  : }

	ret	0
$LN4@BIT_initDS:

; 275  : 
; 276  :     bitD->start = (const char*)srcBuffer;

	mov	QWORD PTR [rcx+24], rdx

; 277  :     bitD->limitPtr = bitD->start + sizeof(bitD->bitContainer);

	lea	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+32], rax

; 278  : 
; 279  :     if (srcSize >=  sizeof(bitD->bitContainer)) {  /* normal case */

	cmp	r8, 8
	jb	SHORT $LN5@BIT_initDS

; 280  :         bitD->ptr   = (const char*)srcBuffer + srcSize - sizeof(bitD->bitContainer);

	lea	rax, QWORD PTR [r8-8]
	add	rax, rdx
	mov	QWORD PTR [rcx+16], rax

; 281  :         bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 282  :         { BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];

	movzx	eax, BYTE PTR [rdx+r8-1]

; 283  :           bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */

	xor	edx, edx
	test	al, al
	je	SHORT $LN17@BIT_initDS

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax

; 315  :     }
; 316  : 
; 317  :     return srcSize;

	mov	rax, r8

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	cmovne	edx, ecx

; 283  :           bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */

	mov	ecx, 8
	sub	ecx, edx
	mov	DWORD PTR [r9+8], ecx

; 318  : }

	ret	0
$LN17@BIT_initDS:

; 283  :           bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */

	mov	DWORD PTR [rcx+8], edx

; 284  :           if (lastByte == 0) return ERROR(GENERIC); /* endMark not present */ }

	mov	rax, -1

; 318  : }

	ret	0
$LN5@BIT_initDS:

; 285  :     } else {
; 286  :         bitD->ptr   = bitD->start;

	mov	QWORD PTR [rcx+16], rdx

; 287  :         bitD->bitContainer = *(const BYTE*)(bitD->start);
; 288  :         switch(srcSize)

	lea	rax, QWORD PTR [r8-2]
	movzx	ecx, BYTE PTR [rdx]
	mov	QWORD PTR [r9], rcx
	cmp	rax, 5
	ja	SHORT $LN14@BIT_initDS
	lea	r10, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN27@BIT_initDS[r10+rax*4]
	add	rax, r10
	jmp	rax
$LN8@BIT_initDS:

; 289  :         {
; 290  :         case 7: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[6]) << (sizeof(bitD->bitContainer)*8 - 16);

	movzx	eax, BYTE PTR [rdx+6]
	shl	rax, 48					; 00000030H
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN9@BIT_initDS:

; 291  :                 /* fall-through */
; 292  : 
; 293  :         case 6: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[5]) << (sizeof(bitD->bitContainer)*8 - 24);

	movzx	eax, BYTE PTR [rdx+5]
	shl	rax, 40					; 00000028H
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN10@BIT_initDS:

; 294  :                 /* fall-through */
; 295  : 
; 296  :         case 5: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[4]) << (sizeof(bitD->bitContainer)*8 - 32);

	movzx	eax, BYTE PTR [rdx+4]
	shl	rax, 32					; 00000020H
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN11@BIT_initDS:

; 297  :                 /* fall-through */
; 298  : 
; 299  :         case 4: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[3]) << 24;

	movzx	eax, BYTE PTR [rdx+3]
	shl	rax, 24
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN12@BIT_initDS:

; 300  :                 /* fall-through */
; 301  : 
; 302  :         case 3: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[2]) << 16;

	movzx	eax, BYTE PTR [rdx+2]
	shl	rax, 16
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN13@BIT_initDS:

; 303  :                 /* fall-through */
; 304  : 
; 305  :         case 2: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[1]) <<  8;

	movzx	eax, BYTE PTR [rdx+1]
	shl	rax, 8
	add	rax, rcx
	mov	QWORD PTR [r9], rax
$LN14@BIT_initDS:

; 306  :                 /* fall-through */
; 307  : 
; 308  :         default: break;
; 309  :         }
; 310  :         {   BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];

	movzx	eax, BYTE PTR [rdx+r8-1]

; 311  :             bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;

	xor	edx, edx
	test	al, al
	je	SHORT $LN19@BIT_initDS

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	edx, ecx

; 311  :             bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;

	mov	ecx, 8
	mov	eax, ecx
	sub	eax, edx

; 313  :         }
; 314  :         bitD->bitsConsumed += (U32)(sizeof(bitD->bitContainer) - srcSize)*8;

	sub	ecx, r8d
	lea	eax, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR [r9+8], eax

; 315  :     }
; 316  : 
; 317  :     return srcSize;

	mov	rax, r8

; 318  : }

	ret	0
$LN19@BIT_initDS:

; 311  :             bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;

	mov	DWORD PTR [r9+8], edx

; 312  :             if (lastByte == 0) return ERROR(corruption_detected);  /* endMark not present */

	mov	rax, -20

; 318  : }

	ret	0
	npad	3
$LN27@BIT_initDS:
	DD	$LN13@BIT_initDS
	DD	$LN12@BIT_initDS
	DD	$LN11@BIT_initDS
	DD	$LN10@BIT_initDS
	DD	$LN9@BIT_initDS
	DD	$LN8@BIT_initDS
BIT_initDStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitContainer$ = 8
start$ = 16
nbBits$ = 24
BIT_getMiddleBits PROC

; 326  : {

	mov	r9, rcx

; 327  :     U32 const regMask = sizeof(bitContainer)*8 - 1;
; 328  :     /* if start > regMask, bitstream is corrupted, and result is undefined */
; 329  :     assert(nbBits < BIT_MASK_SIZE);
; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, r8d
	and	edx, 63					; 0000003fH
	movzx	ecx, dl
	shr	r9, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	eax, DWORD PTR [rcx+rax*4]
	and	rax, r9

; 331  : }

	ret	0
BIT_getMiddleBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_lookBits PROC

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	rax, QWORD PTR [rcx]

; 347  :     /* arbitrate between double-shift and shift+mask */
; 348  : #if 1
; 349  :     /* if bitD->bitsConsumed + nbBits > sizeof(bitD->bitContainer)*8,
; 350  :      * bitstream is likely corrupted, and result is undefined */
; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	ecx, DWORD PTR [rcx+8]
	add	ecx, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	rax, cl
	mov	ecx, edx
	lea	rdx, OFFSET FLAT:BIT_mask
	mov	edx, DWORD PTR [rdx+rcx*4]
	and	rax, rdx

; 352  : #else
; 353  :     /* this code path is slower on my os-x laptop */
; 354  :     U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;
; 355  :     return ((bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> 1) >> ((regMask-nbBits) & regMask);
; 356  : #endif
; 357  : }

	ret	0
BIT_lookBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_lookBitsFast PROC

; 363  :     U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;
; 364  :     assert(nbBits >= 1);
; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, QWORD PTR [rcx]
	neg	edx
	mov	ecx, DWORD PTR [rcx+8]
	and	edx, 63					; 0000003fH
	and	ecx, 63					; 0000003fH
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 366  : }

	ret	0
BIT_lookBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_skipBits PROC

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rcx+8], edx

; 371  : }

	ret	0
BIT_skipBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_readBits PROC

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rcx+8], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	rax, QWORD PTR [rcx]

; 370  :     bitD->bitsConsumed += nbBits;

	mov	ecx, DWORD PTR [rcx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	rax, cl
	mov	ecx, edx
	lea	rdx, OFFSET FLAT:BIT_mask
	mov	edx, DWORD PTR [rdx+rcx*4]
	and	rax, rdx

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);
; 380  :     BIT_skipBits(bitD, nbBits);
; 381  :     return value;
; 382  : }

	ret	0
BIT_readBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_readBitsFast PROC

; 387  : {

	mov	r8, rcx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [rcx+8]

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+rdx]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [r8+8], eax

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);
; 389  :     assert(nbBits >= 1);
; 390  :     BIT_skipBits(bitD, nbBits);
; 391  :     return value;

	neg	edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, QWORD PTR [r8]
	and	edx, 63					; 0000003fH
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 392  : }

	ret	0
BIT_readBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
BIT_reloadDStreamFast PROC

; 402  :     if (UNLIKELY(bitD->ptr < bitD->limitPtr))

	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rcx
	cmp	r8, QWORD PTR [rcx+32]
	jae	SHORT $LN2@BIT_reload

; 403  :         return BIT_DStream_overflow;

	mov	eax, 3

; 409  : }

	ret	0
$LN2@BIT_reload:

; 404  :     assert(bitD->bitsConsumed <= sizeof(bitD->bitContainer)*8);
; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, ecx

; 406  :     bitD->bitsConsumed &= 7;

	and	ecx, 7
	shr	rax, 3
	sub	r8, rax
	mov	DWORD PTR [rdx+8], ecx
	mov	QWORD PTR [rdx+16], r8

; 407  :     bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 408  :     return BIT_DStream_unfinished;

	xor	eax, eax

; 409  : }

	ret	0
BIT_reloadDStreamFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 16
BIT_reloadDStream PROC

; 417  : {

	sub	rsp, 8

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	mov	r9d, DWORD PTR [rcx+8]
	mov	r8, rcx
	cmp	r9d, 64					; 00000040H
	jbe	SHORT $LN2@BIT_reload

; 419  :         return BIT_DStream_overflow;

	mov	eax, 3

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
$LN2@BIT_reload:

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	mov	rdx, QWORD PTR [rcx+16]
	cmp	rdx, QWORD PTR [rcx+32]
	jb	SHORT $LN3@BIT_reload

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	rax, r9

; 406  :     bitD->bitsConsumed &= 7;

	and	r9d, 7
	shr	rax, 3
	sub	rdx, rax
	mov	DWORD PTR [rcx+8], r9d
	mov	QWORD PTR [rcx+16], rdx

; 407  :     bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 422  :         return BIT_reloadDStreamFast(bitD);

	xor	eax, eax

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
$LN3@BIT_reload:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	mov	r11, QWORD PTR [rcx+24]
	cmp	rdx, r11
	jne	SHORT $LN4@BIT_reload

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;

	cmp	r9d, 64					; 00000040H
	sbb	eax, eax
	add	eax, 2

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
$LN4@BIT_reload:

; 426  :         return BIT_DStream_completed;
; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	r10d, r9d
	mov	QWORD PTR [rsp], rbx
	shr	r10d, 3

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdx
	mov	eax, r10d
	xor	ebx, ebx
	sub	rcx, rax
	cmp	rcx, r11
	jae	SHORT $LN6@BIT_reload

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	r10d, edx

; 433  :             result = BIT_DStream_endOfBuffer;

	mov	ebx, 1
	sub	r10d, r11d
$LN6@BIT_reload:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	ecx, r10d

; 436  :         bitD->bitsConsumed -= nbBytes*8;
; 437  :         bitD->bitContainer = MEM_readLEST(bitD->ptr);   /* reminder : srcSize > sizeof(bitD->bitContainer), otherwise bitD->ptr == bitD->start */
; 438  :         return result;

	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp]
	sub	rdx, rcx
	lea	ecx, DWORD PTR [r10*8]
	mov	QWORD PTR [r8+16], rdx
	sub	r9d, ecx
	mov	DWORD PTR [r8+8], r9d
	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rcx

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
BIT_reloadDStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
DStatePtr$ = 48
bitD$ = 56
dt$ = 64
FSE_initDState PROC

; 578  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 579  :     const void* ptr = dt;
; 580  :     const FSE_DTableHeader* const DTableH = (const FSE_DTableHeader*)ptr;
; 581  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	movzx	r10d, WORD PTR [r8]
	mov	rbx, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rdx+8], r10d
; File E:\dev\pyzstd\lib\common\fse.h

; 578  : {

	mov	rdi, r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	ecx, DWORD PTR [rdx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r9, QWORD PTR [rdx]
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r9, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+r10*4]
	and	r9, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	mov	rcx, rdx
	mov	QWORD PTR [rbx], r9
	call	BIT_reloadDStream

; 583  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rdi+4]
	mov	QWORD PTR [rbx+8], rax

; 584  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
FSE_initDState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
DStatePtr$ = 8
bitD$ = 16
FSE_decodeSymbol PROC

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8, QWORD PTR [rcx]
	mov	r11, rcx
	mov	rax, QWORD PTR [rcx+8]
	mov	r10d, DWORD PTR [rax+r8*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, QWORD PTR [rdx]
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, r10d
	shr	r9d, 24
	mov	eax, r10d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rdx+8], r9d
	mov	ecx, DWORD PTR [rdx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rdx, OFFSET FLAT:BIT_mask
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	eax, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	edx, DWORD PTR [rdx+r9*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	and	r8, rdx

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	ecx, r10w
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r8, rcx
	mov	QWORD PTR [r11], r8

; 608  :     return symbol;
; 609  : }

	ret	0
FSE_decodeSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
DStatePtr$ = 8
bitD$ = 16
FSE_decodeSymbolFast PROC

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8, QWORD PTR [rcx]
	mov	r11, rcx
	mov	rax, QWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [rdx+8]
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [rax+r8*4]
	mov	r8d, r9d
	mov	r10d, r9d
	shr	r8d, 24
	shr	r10d, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+r8]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [rdx+8], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	neg	r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, QWORD PTR [rdx]
	and	r8d, 63					; 0000003fH
	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 621  :     return symbol;

	movzx	eax, r10b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	movzx	ecx, r8b
	shr	rdx, cl

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	ecx, r9w
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	rdx, rcx
	mov	QWORD PTR [r11], rdx

; 622  : }

	ret	0
FSE_decodeSymbolFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
_TEXT	SEGMENT
DTableH$1 = 0
symbolNext$ = 16
__$ArrayPad$ = 528
dt$ = 608
normalizedCounter$ = 616
maxSymbolValue$ = 624
tableLog$ = 632
FSE_buildDTable PROC

; 71   : {

$LN48:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 544				; 00000220H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 72   :     void* const tdPtr = dt+1;   /* because *dt is unsigned, 32-bits aligned on 32-bits */
; 73   :     FSE_DECODE_TYPE* const tableDecode = (FSE_DECODE_TYPE*) (tdPtr);
; 74   :     U16 symbolNext[FSE_MAX_SYMBOL_VALUE+1];
; 75   : 
; 76   :     U32 const maxSV1 = maxSymbolValue + 1;
; 77   :     U32 const tableSize = 1 << tableLog;

	mov	r12d, 1
	lea	ebp, DWORD PTR [r8+1]
	mov	rbx, rcx
	mov	r14d, r12d
	mov	ecx, r9d
	mov	r15d, r9d
	shl	r14d, cl
	mov	rsi, rdx

; 78   :     U32 highThreshold = tableSize-1;

	lea	r10d, DWORD PTR [r14-1]
	mov	r9d, r10d

; 79   : 
; 80   :     /* Sanity Checks */
; 81   :     if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);

	cmp	r8d, 255				; 000000ffH
	jbe	SHORT $LN16@FSE_buildD
	lea	rax, QWORD PTR [r12-47]
	jmp	$LN1@FSE_buildD
$LN16@FSE_buildD:

; 82   :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);

	cmp	r15d, 12
	jbe	SHORT $LN17@FSE_buildD
	mov	rax, -44				; ffffffffffffffd4H
	jmp	$LN1@FSE_buildD
$LN17@FSE_buildD:

; 87   :         DTableH.fastMode = 1;
; 88   :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	lea	ecx, DWORD PTR [r15-1]
	mov	QWORD PTR [rsp+616], r13

; 89   :             U32 s;
; 90   :             for (s=0; s<maxSV1; s++) {

	xor	r13d, r13d
	mov	WORD PTR DTableH$1[rsp], r15w
	mov	r8d, r12d
	mov	WORD PTR DTableH$1[rsp+2], r12w
	shl	r8w, cl
	mov	edx, r13d
	test	ebp, ebp
	je	$LN3@FSE_buildD

; 83   : 
; 84   :     /* Init, lay down lowprob symbols */
; 85   :     {   FSE_DTableHeader DTableH;
; 86   :         DTableH.tableLog = (U16)tableLog;

	lea	rax, QWORD PTR symbolNext$[rsp]
	mov	r11, rsi
	sub	r11, rax
	lea	rcx, QWORD PTR symbolNext$[rsp]
	npad	8
$LL4@FSE_buildD:

; 91   :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR [r11+rcx]
	cmp	ax, -1
	jne	SHORT $LN18@FSE_buildD

; 92   :                     tableDecode[highThreshold--].symbol = (FSE_FUNCTION_TYPE)s;

	mov	eax, r9d
	dec	r9d
	mov	BYTE PTR [rbx+rax*4+6], dl

; 93   :                     symbolNext[s] = 1;

	movzx	eax, r12w

; 94   :                 } else {

	jmp	SHORT $LN2@FSE_buildD
$LN18@FSE_buildD:

; 95   :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r8w
	jl	SHORT $LN2@FSE_buildD
	mov	WORD PTR DTableH$1[rsp+2], r13w
$LN2@FSE_buildD:

; 89   :             U32 s;
; 90   :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR [rcx], ax
	inc	edx
	add	rcx, 2
	cmp	edx, ebp
	jb	SHORT $LL4@FSE_buildD

; 96   :                     symbolNext[s] = normalizedCounter[s];
; 97   :         }   }   }
; 98   :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	eax, DWORD PTR DTableH$1[rsp]
	mov	r8d, r14d
	shr	r8d, 1
	mov	edx, r14d
	add	r8d, 3
	shr	edx, 3
	mov	DWORD PTR [rbx], eax
	add	r8d, edx
	mov	eax, r13d
	mov	r11d, r13d
$LL7@FSE_buildD:

; 106  :             int i;
; 107  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	ecx, WORD PTR [rsi]
	test	ecx, ecx
	jle	SHORT $LN5@FSE_buildD
	mov	edx, ecx
	npad	5
$LL10@FSE_buildD:

; 108  :                 tableDecode[position].symbol = (FSE_FUNCTION_TYPE)s;

	mov	ecx, eax

; 109  :                 position = (position + step) & tableMask;

	add	eax, r8d
	and	eax, r10d
	mov	BYTE PTR [rbx+rcx*4+6], r11b

; 110  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	eax, r9d
	jbe	SHORT $LN8@FSE_buildD
$LL11@FSE_buildD:
	add	eax, r8d
	and	eax, r10d
	cmp	eax, r9d
	ja	SHORT $LL11@FSE_buildD
$LN8@FSE_buildD:

; 106  :             int i;
; 107  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rdx, r12
	jne	SHORT $LL10@FSE_buildD
$LN5@FSE_buildD:

; 99   :     }
; 100  : 
; 101  :     /* Spread symbols */
; 102  :     {   U32 const tableMask = tableSize-1;
; 103  :         U32 const step = FSE_TABLESTEP(tableSize);
; 104  :         U32 s, position = 0;
; 105  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rsi, 2
	cmp	r11d, ebp
	jb	SHORT $LL7@FSE_buildD

; 111  :         }   }
; 112  :         if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */

	test	eax, eax
	je	SHORT $LN21@FSE_buildD
	mov	rax, -1
	jmp	SHORT $LN46@FSE_buildD
$LN3@FSE_buildD:

; 96   :                     symbolNext[s] = normalizedCounter[s];
; 97   :         }   }   }
; 98   :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	eax, DWORD PTR DTableH$1[rsp]
	mov	DWORD PTR [rbx], eax
$LN21@FSE_buildD:

; 117  :         for (u=0; u<tableSize; u++) {

	test	r14d, r14d
	je	SHORT $LN14@FSE_buildD
	lea	r9, QWORD PTR [rbx+7]
	mov	r10d, r14d
	npad	4
$LL15@FSE_buildD:

; 118  :             FSE_FUNCTION_TYPE const symbol = (FSE_FUNCTION_TYPE)(tableDecode[u].symbol);
; 119  :             U32 const nextState = symbolNext[symbol]++;

	movzx	eax, BYTE PTR [r9-1]
	lea	rcx, QWORD PTR symbolNext$[rsp]
	movzx	r8d, WORD PTR [rcx+rax*2]
	lea	rcx, QWORD PTR [rcx+rax*2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, r13d
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 117  :         for (u=0; u<tableSize; u++) {

	lea	r9, QWORD PTR [r9+4]

; 118  :             FSE_FUNCTION_TYPE const symbol = (FSE_FUNCTION_TYPE)(tableDecode[u].symbol);
; 119  :             U32 const nextState = symbolNext[symbol]++;

	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR [rcx], ax

; 120  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r15b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 120  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl

; 121  :             tableDecode[u].newState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, r14w
	mov	BYTE PTR [r9-4], cl
	mov	WORD PTR [r9-7], r8w
	sub	r10, r12
	jne	SHORT $LL15@FSE_buildD
$LN14@FSE_buildD:

; 122  :     }   }
; 123  : 
; 124  :     return 0;

	xor	eax, eax
$LN46@FSE_buildD:
	mov	r13, QWORD PTR [rsp+616]
$LN1@FSE_buildD:

; 125  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 544				; 00000220H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
FSE_buildDTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
_TEXT	SEGMENT
bitD$ = 32
dst$ = 144
tv2085 = 152
maxDstSize$dead$ = 152
cSrc$ = 160
cSrcSize$ = 168
dt$ = 176
fast$ = 184
FSE_decompress_usingDTable_generic PROC

; 181  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	mov	rbp, rsp
	sub	rsp, 120				; 00000078H
	mov	rdx, r8

; 182  :     BYTE* const ostart = (BYTE*) dst;
; 183  :     BYTE* op = ostart;

	mov	rbx, rcx

; 192  :     CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));

	mov	r8, r9
	lea	rcx, QWORD PTR bitD$[rbp-120]
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 192  :     CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));

	ja	$LN1@FSE_decomp
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	edx, DWORD PTR bitD$[rbp-112]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rcx, OFFSET FLAT:BIT_mask
	mov	QWORD PTR [rsp+160], rsi
	mov	QWORD PTR [rsp+112], rdi
; File E:\dev\pyzstd\lib\common\fse.h

; 581  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	rdi, QWORD PTR dt$[rbp-120]
	mov	QWORD PTR [rsp+104], r12
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r12, QWORD PTR bitD$[rbp-120]
	mov	QWORD PTR [rsp+96], r13
; File E:\dev\pyzstd\lib\common\fse.h

; 581  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	movzx	esi, WORD PTR [rdi]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	edx, esi
	mov	QWORD PTR [rsp+88], r14
	mov	QWORD PTR [rsp+80], r15

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR bitD$[rbp-112], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r14d, DWORD PTR [rcx+rsi*4]
	mov	ecx, edx
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r12, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR bitD$[rbp-120]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r12, r14
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	edx, DWORD PTR bitD$[rbp-112]
; File E:\dev\pyzstd\lib\common\fse.h

; 583  :     DStatePtr->table = dt + 1;

	add	rdi, 4
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r13, QWORD PTR bitD$[rbp-120]

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	edx, esi

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, edx
; File E:\dev\pyzstd\lib\common\fse.h

; 583  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR tv2085[rbp-120], rdi
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR bitD$[rbp-112], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	shr	r13, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR bitD$[rbp-120]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r13, r14
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream

; 583  :     DStatePtr->table = dt + 1;

	mov	r14, QWORD PTR bitD$[rbp-104]
	mov	esi, DWORD PTR bitD$[rbp-112]
	mov	r15, QWORD PTR bitD$[rbp-120]
$LN274@FSE_decomp:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	mov	r10, QWORD PTR bitD$[rbp-96]
	mov	r11d, DWORD PTR fast$[rbp-120]
	cmp	esi, 64					; 00000040H
	jbe	SHORT $LN56@FSE_decomp

; 419  :         return BIT_DStream_overflow;

	mov	r8d, 3
	jmp	SHORT $LN55@FSE_decomp
$LN56@FSE_decomp:

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	r14, QWORD PTR bitD$[rbp-88]
	jb	SHORT $LN57@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, esi

; 406  :     bitD->bitsConsumed &= 7;

	and	esi, 7
	shr	rax, 3
	sub	r14, rax

; 422  :         return BIT_reloadDStreamFast(bitD);

	xor	r8d, r8d
	jmp	SHORT $LN273@FSE_decomp
$LN57@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	r14, r10
	jne	SHORT $LN58@FSE_decomp

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;

	cmp	esi, 64					; 00000040H
	sbb	r8d, r8d
	add	r8d, 2

; 426  :         return BIT_DStream_completed;

	jmp	SHORT $LN55@FSE_decomp
$LN58@FSE_decomp:

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, esi

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, r14
	shr	edx, 3
	xor	r8d, r8d
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r10
	jae	SHORT $LN60@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	edx, DWORD PTR bitD$[rbp-104]

; 433  :             result = BIT_DStream_endOfBuffer;

	mov	r8d, 1
	sub	edx, DWORD PTR bitD$[rbp-96]
$LN60@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	r14, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	esi, eax
$LN273@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 200  :     for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {

	mov	r15, QWORD PTR [r14]
	mov	QWORD PTR bitD$[rbp-104], r14
$LN55@FSE_decomp:
	mov	rdx, QWORD PTR dst$[rbp-120]
	xor	ecx, ecx
	lea	rax, QWORD PTR [rdx+252]
	cmp	rbx, rax
	setb	cl
	xor	eax, eax
	test	r8d, r8d
	sete	al
	test	ecx, eax
	je	$LN251@FSE_decomp

; 201  :         op[0] = FSE_GETSYMBOL(&state1);

	mov	r12d, DWORD PTR [rdi+r12*4]
	mov	edx, r12d
	mov	eax, r12d
	shr	eax, 16
	shr	edx, 24
	mov	BYTE PTR [rbx], al
	test	r11d, r11d
	je	$LN17@FSE_decomp
	mov	r11d, DWORD PTR [rdi+r13*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, esi
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	esi, edx
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	eax, r11d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r8, r15
	shl	r8, cl
	mov	r9, r15

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, edx
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	eax, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx+1], al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	movzx	eax, r12w
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r8, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, r11d
	shr	edx, 24
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	add	rax, r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, esi
	mov	r10, r15
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	esi, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	r9, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, edx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	mov	edi, DWORD PTR [rdi+rax*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r12d, di

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r9, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, edi
	shr	edx, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, esi
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	esi, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	r10, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	eax, edi
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 216  :         op[3] = FSE_GETSYMBOL(&state2);

	mov	rdi, QWORD PTR tv2085[rbp-120]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, edx
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	eax, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	BYTE PTR [rbx+2], al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r10, cl
	mov	rdx, r15
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	rcx, QWORD PTR tv2085[rbp-120]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, r10

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	movzx	eax, r11w
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	add	rax, r9
	mov	r11d, DWORD PTR [rcx+rax*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, esi
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r13d, r11w

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8d, r11d
	shr	r8d, 24
	shr	r11d, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 216  :         op[3] = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx+3], r11b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	esi, r8d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r13, rdx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 200  :     for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {

	add	rbx, 4
	jmp	$LN274@FSE_decomp
$LN17@FSE_decomp:

; 201  :         op[0] = FSE_GETSYMBOL(&state1);

	mov	edi, DWORD PTR [rdi+r13*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	r8d, DWORD PTR [rsi+rdx]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r8d
	lea	rsi, OFFSET FLAT:BIT_mask
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	eax, edi
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	eax, 16
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx+1], al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r10, r15
	shr	r10, cl
	mov	r11, r15
	mov	ecx, DWORD PTR [rsi+rdx*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, edi
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r10, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
	movzx	eax, r12w
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	add	rax, r10
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	r9d, DWORD PTR [r8+rdx]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r11, cl
	mov	ecx, DWORD PTR [rsi+rdx*4]
	and	r11, rcx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	mov	rcx, QWORD PTR tv2085[rbp-120]
	mov	r10d, DWORD PTR [rcx+rax*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, r10d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r12d, r10w
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
	mov	eax, r10d
	shr	eax, 16
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	BYTE PTR [rbx+2], al
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	movzx	eax, di
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	rdi, QWORD PTR tv2085[rbp-120]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	r8d, DWORD PTR [r9+rdx]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	add	rax, r11
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	r9, r15
	and	ecx, 63					; 0000003fH
	shr	r9, cl
	mov	ecx, DWORD PTR [rsi+rdx*4]
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	r11d, DWORD PTR [rdi+rax*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r9, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, r11d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r13d, r11w
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, r9

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	r11d, 16
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 216  :         op[3] = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx+3], r11b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	esi, DWORD PTR [r8+rdx]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r15
	mov	ecx, esi
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+rdx*4]
	and	r8, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r13, r8
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 200  :     for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {

	add	rbx, 4
	jmp	$LN274@FSE_decomp
$LN251@FSE_decomp:

; 222  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	lea	rax, QWORD PTR [rdx+253]
	cmp	rbx, rax
	ja	$LN254@FSE_decomp
	npad	10
$LL5@FSE_decomp:

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	mov	r9d, DWORD PTR [rdi+r12*4]
	movzx	r12d, r9w
	test	r11d, r11d
	je	SHORT $LN25@FSE_decomp
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, esi
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8d, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	r8d, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, r15

; 370  :     bitD->bitsConsumed += nbBits;

	add	esi, r8d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shr	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, rdx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	jmp	SHORT $LN275@FSE_decomp
$LN25@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r15
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	esi, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, esi
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+rdx*4]
	and	r8, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, r8
$LN275@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	shr	r9d, 16
	mov	BYTE PTR [rbx], r9b
	inc	rbx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	cmp	esi, 64					; 00000040H
	ja	$LN253@FSE_decomp

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	r14, QWORD PTR bitD$[rbp-88]
	jb	SHORT $LN177@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, esi
	shr	rax, 3
	sub	r14, rax

; 406  :     bitD->bitsConsumed &= 7;

	and	esi, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN276@FSE_decomp
$LN177@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	r14, r10
	je	SHORT $LN260@FSE_decomp

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, esi

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, r14
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r10
	jae	SHORT $LN180@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR bitD$[rbp-104]
	sub	eax, DWORD PTR bitD$[rbp-96]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	r14, rcx
	lea	eax, DWORD PTR [rax*8]
	sub	esi, eax
	jmp	SHORT $LN276@FSE_decomp
$LN180@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	r14, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	esi, eax
$LN276@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 229  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	mov	r15, QWORD PTR [r14]
	mov	QWORD PTR bitD$[rbp-104], r14
$LN260@FSE_decomp:
	mov	rax, QWORD PTR dst$[rbp-120]
	add	rax, 253				; 000000fdH
	cmp	rbx, rax
	ja	$LN254@FSE_decomp

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	mov	r9d, DWORD PTR [rdi+r13*4]
	movzx	r13d, r9w
	test	r11d, r11d
	je	SHORT $LN29@FSE_decomp
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, esi
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8d, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	r8d, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, r15

; 370  :     bitD->bitsConsumed += nbBits;

	add	esi, r8d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shr	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r13, rdx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	jmp	SHORT $LN277@FSE_decomp
$LN29@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r15
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	esi, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, esi
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+rdx*4]
	and	r8, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r13, r8
$LN277@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	shr	r9d, 16
	mov	BYTE PTR [rbx], r9b
	inc	rbx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	cmp	esi, 64					; 00000040H
	ja	$LN255@FSE_decomp

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	r14, QWORD PTR bitD$[rbp-88]
	jb	SHORT $LN223@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, esi
	shr	rax, 3
	sub	r14, rax

; 406  :     bitD->bitsConsumed &= 7;

	and	esi, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN278@FSE_decomp
$LN223@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	r14, r10
	je	SHORT $LN261@FSE_decomp

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, esi

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, r14
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r10
	jae	SHORT $LN226@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR bitD$[rbp-104]
	sub	eax, DWORD PTR bitD$[rbp-96]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	r14, rcx
	lea	eax, DWORD PTR [rax*8]
	sub	esi, eax
	jmp	SHORT $LN278@FSE_decomp
$LN226@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	r14, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	esi, eax
$LN278@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 222  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	mov	r15, QWORD PTR [r14]
	mov	QWORD PTR bitD$[rbp-104], r14
$LN261@FSE_decomp:
	mov	rax, QWORD PTR dst$[rbp-120]
	add	rax, 253				; 000000fdH
	cmp	rbx, rax
	jbe	$LL5@FSE_decomp
$LN254@FSE_decomp:

; 229  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	mov	rax, -70				; ffffffffffffffbaH
$LN272@FSE_decomp:
	mov	r14, QWORD PTR [rsp+88]
	mov	r13, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+160]
	mov	r15, QWORD PTR [rsp+80]
$LN1@FSE_decomp:

; 237  : }

	add	rsp, 120				; 00000078H
	pop	rbx
	pop	rbp
	ret	0
$LN255@FSE_decomp:

; 232  :             *op++ = FSE_GETSYMBOL(&state1);

	mov	ecx, DWORD PTR [rdi+r12*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	eax, ecx
	shr	eax, 16

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	ecx, 16
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 232  :             *op++ = FSE_GETSYMBOL(&state1);

	test	r11d, r11d
	cmovne	ecx, eax
	mov	BYTE PTR [rbx], cl

; 233  :             break;
; 234  :     }   }
; 235  : 
; 236  :     return op-ostart;

	sub	rbx, QWORD PTR dst$[rbp-120]
	lea	rax, QWORD PTR [rbx+1]
	jmp	SHORT $LN272@FSE_decomp
$LN253@FSE_decomp:

; 225  :             *op++ = FSE_GETSYMBOL(&state2);

	mov	edx, DWORD PTR [rdi+r13*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	ecx, edx
	shr	ecx, 16

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 16
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 225  :             *op++ = FSE_GETSYMBOL(&state2);

	test	r11d, r11d
	cmovne	edx, ecx
	mov	BYTE PTR [rbx], dl

; 233  :             break;
; 234  :     }   }
; 235  : 
; 236  :     return op-ostart;

	sub	rbx, QWORD PTR dst$[rbp-120]
	lea	rax, QWORD PTR [rbx+1]
	jmp	SHORT $LN272@FSE_decomp
FSE_decompress_usingDTable_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
_TEXT	SEGMENT
bitD$5 = 32
bitD$6 = 32
dst$ = 128
originalSize$dead$ = 136
cSrc$ = 144
cSrcSize$ = 152
dt$ = 160
FSE_decompress_usingDTable PROC

; 243  : {

$LN544:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 244  :     const void* ptr = dt;
; 245  :     const FSE_DTableHeader* DTableH = (const FSE_DTableHeader*)ptr;
; 246  :     const U32 fastMode = DTableH->fastMode;
; 247  : 
; 248  :     /* select fast mode (static) */
; 249  :     if (fastMode) return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 1);

	mov	r11, QWORD PTR dt$[rbp-80]
	mov	r10, r8
	mov	r8, r9
	mov	rdx, r10
	cmp	WORD PTR [r11+2], 0
	je	$LN2@FSE_decomp

; 183  :     BYTE* op = ostart;

	mov	rbx, rcx

; 192  :     CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));

	lea	rcx, QWORD PTR bitD$6[rbp-80]
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 192  :     CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));

	ja	$LN252@FSE_decomp
; File E:\dev\pyzstd\lib\common\fse.h

; 581  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	movzx	edi, WORD PTR [r11]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rcx, OFFSET FLAT:BIT_mask

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	edx, DWORD PTR bitD$6[rbp-72]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r15, QWORD PTR bitD$6[rbp-80]

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	edx, edi

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR bitD$6[rbp-72], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	esi, DWORD PTR [rcx+rdi*4]
	mov	ecx, edx
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r15, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR bitD$6[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r15, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	edx, DWORD PTR bitD$6[rbp-72]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r12, QWORD PTR bitD$6[rbp-80]

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	edx, edi

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, edx

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR bitD$6[rbp-72], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r12, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR bitD$6[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r12, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream

; 583  :     DStatePtr->table = dt + 1;

	mov	r10d, DWORD PTR bitD$6[rbp-72]
	mov	r9, QWORD PTR dt$[rbp-80]
	mov	r13, QWORD PTR bitD$6[rbp-48]
	mov	r14, QWORD PTR bitD$6[rbp-56]
	mov	rdi, QWORD PTR bitD$6[rbp-64]
	mov	rsi, QWORD PTR bitD$6[rbp-80]
	npad	3
$LL7@FSE_decomp:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	cmp	r10d, 64				; 00000040H
	jbe	SHORT $LN59@FSE_decomp

; 419  :         return BIT_DStream_overflow;

	mov	r8d, 3
	jmp	SHORT $LN58@FSE_decomp
$LN59@FSE_decomp:

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	rdi, r13
	jb	SHORT $LN60@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r10d

; 406  :     bitD->bitsConsumed &= 7;

	and	r10d, 7
	shr	rax, 3
	sub	rdi, rax

; 422  :         return BIT_reloadDStreamFast(bitD);

	xor	r8d, r8d
	jmp	SHORT $LN529@FSE_decomp
$LN60@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	rdi, r14
	jne	SHORT $LN61@FSE_decomp

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;

	cmp	r10d, 64				; 00000040H
	sbb	r8d, r8d
	add	r8d, 2

; 426  :         return BIT_DStream_completed;

	jmp	SHORT $LN58@FSE_decomp
$LN61@FSE_decomp:

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r10d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdi
	shr	edx, 3
	xor	r8d, r8d
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r14
	jae	SHORT $LN63@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	edx, DWORD PTR bitD$6[rbp-64]

; 433  :             result = BIT_DStream_endOfBuffer;

	mov	r8d, 1
	sub	edx, DWORD PTR bitD$6[rbp-56]
$LN63@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	rdi, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	r10d, eax
$LN529@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 200  :     for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {

	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR bitD$6[rbp-64], rdi
$LN58@FSE_decomp:
	mov	rcx, QWORD PTR dst$[rbp-80]
	xor	edx, edx
	lea	rax, QWORD PTR [rcx+252]
	cmp	rbx, rax
	setb	dl
	xor	eax, eax
	test	r8d, r8d
	sete	al
	test	edx, eax
	je	$LN502@FSE_decomp
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, DWORD PTR [r9+r15*4+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r11, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	eax, edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r15, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	eax, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	r8d, DWORD PTR [rax+r10]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	neg	eax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH
	and	r10d, 63				; 0000003fH
	movzx	ecx, r10b
	mov	r10, rsi
	shl	r10, cl
	movzx	ecx, al

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, dx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r10, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r10, rax
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 201  :         op[0] = FSE_GETSYMBOL(&state1);

	shr	edx, 16
	mov	BYTE PTR [rbx], dl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, DWORD PTR [r9+r12*4+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r12, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	eax, edx
	shr	eax, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	lea	r9d, DWORD PTR [r8+rax]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	neg	eax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH
	and	r8d, 63					; 0000003fH
	movzx	ecx, r8b
	shl	r11, cl
	movzx	ecx, al

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, dx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r11, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r11, rax
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	shr	edx, 16
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	rax, QWORD PTR dt$[rbp-80]
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx+1], dl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, DWORD PTR [rax+r10*4+4]
	mov	eax, edx
	shr	eax, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	lea	r8d, DWORD PTR [r9+rax]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	neg	eax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH
	and	r9d, 63					; 0000003fH
	movzx	ecx, r9b
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9, QWORD PTR dt$[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	r15, cl
	movzx	ecx, al

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, dx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	shr	edx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r15, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r15, rax
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	BYTE PTR [rbx+2], dl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, DWORD PTR [r9+r11*4+4]
	mov	eax, edx
	shr	eax, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	lea	r10d, DWORD PTR [rax+r8]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	neg	eax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH
	and	r8d, 63					; 0000003fH
	movzx	ecx, r8b
	shl	r12, cl
	movzx	ecx, al
	shr	r12, cl

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, dx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 216  :         op[3] = FSE_GETSYMBOL(&state2);

	shr	edx, 16
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, rax
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 216  :         op[3] = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx+3], dl
	add	rbx, 4
	jmp	$LL7@FSE_decomp
$LN502@FSE_decomp:

; 222  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	lea	rax, QWORD PTR [rcx+253]
	cmp	rbx, rax
	ja	$LN509@FSE_decomp
	npad	5
$LL8@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [r9+r15*4+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r10d
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r15d, r9w
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8d, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, rsi
	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	r8d, 24
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	shr	r9d, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	mov	BYTE PTR [rbx], r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	inc	rbx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, cl

; 370  :     bitD->bitsConsumed += nbBits;

	lea	r11d, DWORD PTR [r8+r10]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r15, rdx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	cmp	r11d, 64				; 00000040H
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	ja	$LN506@FSE_decomp

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	rdi, r13
	jb	SHORT $LN180@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r11d
	shr	rax, 3
	sub	rdi, rax
	and	r11d, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN530@FSE_decomp
$LN180@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	rdi, r14
	je	SHORT $LN521@FSE_decomp

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r11d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdi
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r14
	jae	SHORT $LN183@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR bitD$6[rbp-64]
	sub	eax, DWORD PTR bitD$6[rbp-56]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	rdi, rcx
	lea	eax, DWORD PTR [rax*8]
	jmp	SHORT $LN531@FSE_decomp
$LN183@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	rdi, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	lea	eax, DWORD PTR [rdx*8]
$LN531@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 229  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	sub	r11d, eax
$LN530@FSE_decomp:
	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR bitD$6[rbp-64], rdi
$LN521@FSE_decomp:
	mov	rax, QWORD PTR dst$[rbp-80]
	add	rax, 253				; 000000fdH
	cmp	rbx, rax
	ja	$LN509@FSE_decomp
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	rax, QWORD PTR dt$[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r11d
	and	ecx, 63					; 0000003fH
	mov	rdx, rsi
	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [rax+r12*4+4]
	mov	r8d, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r12d, r9w
; File E:\dev\pyzstd\lib\common\fse.h

; 615  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	r8d, 24
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	shr	r9d, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	mov	BYTE PTR [rbx], r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	inc	rbx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, cl

; 370  :     bitD->bitsConsumed += nbBits;

	lea	r10d, DWORD PTR [r8+r11]
; File E:\dev\pyzstd\lib\common\fse.h

; 620  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, rdx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	cmp	r10d, 64				; 00000040H
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	ja	SHORT $LN508@FSE_decomp

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	rdi, r13
	jb	SHORT $LN226@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r10d
	shr	rax, 3
	sub	rdi, rax
	and	r10d, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN532@FSE_decomp
$LN226@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	rdi, r14
	je	SHORT $LN522@FSE_decomp

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r10d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdi
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r14
	jae	SHORT $LN229@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR bitD$6[rbp-64]
	sub	eax, DWORD PTR bitD$6[rbp-56]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	rdi, rcx
	lea	eax, DWORD PTR [rax*8]
	jmp	SHORT $LN533@FSE_decomp
$LN229@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	rdi, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	lea	eax, DWORD PTR [rdx*8]
$LN533@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 222  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	sub	r10d, eax
$LN532@FSE_decomp:
	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR bitD$6[rbp-64], rdi
$LN522@FSE_decomp:
	mov	rax, QWORD PTR dst$[rbp-80]
	add	rax, 253				; 000000fdH
	cmp	rbx, rax
	ja	$LN509@FSE_decomp
	mov	r9, QWORD PTR dt$[rbp-80]
	jmp	$LL8@FSE_decomp
$LN508@FSE_decomp:

; 231  :         if (BIT_reloadDStream(&bitD)==BIT_DStream_overflow) {
; 232  :             *op++ = FSE_GETSYMBOL(&state1);

	movzx	eax, BYTE PTR [rax+r15*4+6]

; 233  :             break;
; 234  :     }   }
; 235  : 
; 236  :     return op-ostart;

	mov	BYTE PTR [rbx], al
	sub	rbx, QWORD PTR dst$[rbp-80]
	lea	rax, QWORD PTR [rbx+1]

; 244  :     const void* ptr = dt;
; 245  :     const FSE_DTableHeader* DTableH = (const FSE_DTableHeader*)ptr;
; 246  :     const U32 fastMode = DTableH->fastMode;
; 247  : 
; 248  :     /* select fast mode (static) */
; 249  :     if (fastMode) return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 1);

	jmp	$LN252@FSE_decomp
$LN506@FSE_decomp:

; 225  :             *op++ = FSE_GETSYMBOL(&state2);

	mov	rax, QWORD PTR dt$[rbp-80]
	movzx	eax, BYTE PTR [rax+r12*4+6]

; 233  :             break;
; 234  :     }   }
; 235  : 
; 236  :     return op-ostart;

	mov	BYTE PTR [rbx], al
	sub	rbx, QWORD PTR dst$[rbp-80]
	lea	rax, QWORD PTR [rbx+1]

; 244  :     const void* ptr = dt;
; 245  :     const FSE_DTableHeader* DTableH = (const FSE_DTableHeader*)ptr;
; 246  :     const U32 fastMode = DTableH->fastMode;
; 247  : 
; 248  :     /* select fast mode (static) */
; 249  :     if (fastMode) return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 1);

	jmp	$LN252@FSE_decomp
$LN2@FSE_decomp:

; 183  :     BYTE* op = ostart;

	mov	r14, rcx

; 192  :     CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));

	lea	rcx, QWORD PTR bitD$5[rbp-80]
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 192  :     CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));

	ja	$LN252@FSE_decomp
; File E:\dev\pyzstd\lib\common\fse.h

; 581  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	movzx	ebx, WORD PTR [r11]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rcx, OFFSET FLAT:BIT_mask

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	edx, DWORD PTR bitD$5[rbp-72]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r12, QWORD PTR bitD$5[rbp-80]

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	edx, ebx

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR bitD$5[rbp-72], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	edi, DWORD PTR [rcx+rbx*4]
	mov	ecx, edx
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r12, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR bitD$5[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r12, rdi
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	edx, DWORD PTR bitD$5[rbp-72]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r13, QWORD PTR bitD$5[rbp-80]

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	edx, ebx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, edx

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR bitD$5[rbp-72], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r13, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR bitD$5[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r13, rdi
; File E:\dev\pyzstd\lib\common\fse.h

; 582  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream

; 583  :     DStatePtr->table = dt + 1;

	mov	r10d, DWORD PTR bitD$5[rbp-72]
	mov	r15, QWORD PTR bitD$5[rbp-56]
	mov	rdi, QWORD PTR bitD$5[rbp-64]
	mov	rsi, QWORD PTR bitD$5[rbp-80]
$LN537@FSE_decomp:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	mov	rbx, QWORD PTR bitD$5[rbp-48]
	cmp	r10d, 64				; 00000040H
	jbe	SHORT $LN307@FSE_decomp

; 419  :         return BIT_DStream_overflow;

	mov	r8d, 3
	jmp	SHORT $LN306@FSE_decomp
$LN307@FSE_decomp:

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	rdi, rbx
	jb	SHORT $LN308@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r10d

; 406  :     bitD->bitsConsumed &= 7;

	and	r10d, 7
	shr	rax, 3
	sub	rdi, rax

; 422  :         return BIT_reloadDStreamFast(bitD);

	xor	r8d, r8d
	jmp	SHORT $LN536@FSE_decomp
$LN308@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	rdi, r15
	jne	SHORT $LN309@FSE_decomp

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;

	cmp	r10d, 64				; 00000040H
	sbb	r8d, r8d
	add	r8d, 2

; 426  :         return BIT_DStream_completed;

	jmp	SHORT $LN306@FSE_decomp
$LN309@FSE_decomp:

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r10d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdi
	shr	edx, 3
	xor	r8d, r8d
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r15
	jae	SHORT $LN311@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	edx, DWORD PTR bitD$5[rbp-64]

; 433  :             result = BIT_DStream_endOfBuffer;

	mov	r8d, 1
	sub	edx, DWORD PTR bitD$5[rbp-56]
$LN311@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	rdi, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	r10d, eax
$LN536@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 200  :     for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {

	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR bitD$5[rbp-64], rdi
$LN306@FSE_decomp:
	mov	rdx, QWORD PTR dst$[rbp-80]
	xor	ecx, ecx
	lea	rax, QWORD PTR [rdx+252]
	cmp	r14, rax
	setb	cl
	xor	eax, eax
	test	r8d, r8d
	sete	al
	test	ecx, eax
	je	$LN504@FSE_decomp
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	rax, QWORD PTR dt$[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, rsi
	mov	r11, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [rax+r12*4+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	r12, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, r9d
	shr	edx, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	ebx, DWORD PTR [rdx+r10]

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r10d, r9w
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 201  :         op[0] = FSE_GETSYMBOL(&state1);

	shr	r9d, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, ebx
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 201  :         op[0] = FSE_GETSYMBOL(&state1);

	mov	BYTE PTR [r14], r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	r8, cl
	mov	ecx, DWORD PTR [r12+rdx*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	edx, DWORD PTR [rax+r13*4+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r10, r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, dx
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r8d, edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r13, rsi
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 206  :         op[1] = FSE_GETSYMBOL(&state2);

	shr	edx, 16
	mov	BYTE PTR [r14+1], dl
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [r9+r10*4+4]
	mov	edx, r9d
	shr	r8d, 24
	shr	edx, 24
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	ecx, DWORD PTR [r8+rbx]

; 370  :     bitD->bitsConsumed += nbBits;

	neg	ecx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	shr	r11, cl
	mov	ecx, DWORD PTR [r12+r8*4]

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	add	r8d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r11, rcx

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	add	r8d, ebx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r11, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rbx, OFFSET FLAT:BIT_mask

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, r9w
	mov	ecx, r8d
	neg	ecx
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	shr	r9d, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 211  :         op[2] = FSE_GETSYMBOL(&state1);

	mov	BYTE PTR [r14+2], r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r12, rsi
	shr	r12, cl
	mov	ecx, DWORD PTR [rbx+rdx*4]
	and	r12, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, rax

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	rax, QWORD PTR dt$[rbp-80]
	mov	r9d, DWORD PTR [rax+r11*4+4]
	mov	edx, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, r9w
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 216  :         op[3] = FSE_GETSYMBOL(&state2);

	shr	r9d, 16
	mov	BYTE PTR [r14+3], r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r10d, DWORD PTR [rdx+r8]

; 370  :     bitD->bitsConsumed += nbBits;

	mov	ecx, r10d
	neg	ecx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	shr	r13, cl
	mov	ecx, DWORD PTR [rbx+rdx*4]
	and	r13, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r13, rax
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 200  :     for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {

	add	r14, 4
	jmp	$LN537@FSE_decomp
$LN504@FSE_decomp:

; 222  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	lea	rax, QWORD PTR [rdx+253]
	cmp	r14, rax
	ja	$LN509@FSE_decomp
	npad	14
$LL256@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	rax, QWORD PTR dt$[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [rax+r12*4+4]
	mov	edx, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r12d, r9w
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	shr	r9d, 16
	mov	BYTE PTR [r14], r9b
	inc	r14
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	r11d, DWORD PTR [rdx+r10]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r11d
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+rdx*4]
	and	r8, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r12, r8
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 223  :         *op++ = FSE_GETSYMBOL(&state1);

	cmp	r11d, 64				; 00000040H
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	ja	$LN510@FSE_decomp

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	rdi, rbx
	jb	SHORT $LN428@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r11d
	shr	rax, 3
	sub	rdi, rax
	and	r11d, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN538@FSE_decomp
$LN428@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	rdi, r15
	je	SHORT $LN523@FSE_decomp

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r11d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdi
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r15
	jae	SHORT $LN431@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR bitD$5[rbp-64]
	sub	eax, DWORD PTR bitD$5[rbp-56]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	rdi, rcx
	lea	eax, DWORD PTR [rax*8]
	jmp	SHORT $LN539@FSE_decomp
$LN431@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	rdi, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	lea	eax, DWORD PTR [rdx*8]
$LN539@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 229  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	sub	r11d, eax
$LN538@FSE_decomp:
	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR bitD$5[rbp-64], rdi
$LN523@FSE_decomp:
	mov	rax, QWORD PTR dst$[rbp-80]
	add	rax, 253				; 000000fdH
	cmp	r14, rax
	ja	$LN509@FSE_decomp
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	rax, QWORD PTR dt$[rbp-80]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	mov	r9d, DWORD PTR [rax+r13*4+4]
	mov	edx, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	r13d, r9w
; File E:\dev\pyzstd\lib\common\fse.h

; 602  :     FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];

	shr	edx, 24
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	shr	r9d, 16
	mov	BYTE PTR [r14], r9b
	inc	r14
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	r10d, DWORD PTR [rdx+r11]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r10d
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+rdx*4]
	and	r8, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 607  :     DStatePtr->state = DInfo.newState + lowBits;

	add	r13, r8
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 230  :         *op++ = FSE_GETSYMBOL(&state2);

	cmp	r10d, 64				; 00000040H
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	ja	$LN512@FSE_decomp

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	rdi, rbx
	jb	SHORT $LN474@FSE_decomp

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r10d
	shr	rax, 3
	sub	rdi, rax
	and	r10d, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN540@FSE_decomp
$LN474@FSE_decomp:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	cmp	rdi, r15
	je	SHORT $LN524@FSE_decomp

; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r10d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdi
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r15
	jae	SHORT $LN477@FSE_decomp

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR bitD$5[rbp-64]
	sub	eax, DWORD PTR bitD$5[rbp-56]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	rdi, rcx
	lea	eax, DWORD PTR [rax*8]
	jmp	SHORT $LN541@FSE_decomp
$LN477@FSE_decomp:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	rdi, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	lea	eax, DWORD PTR [rdx*8]
$LN541@FSE_decomp:
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 222  :         if (op>(omax-2)) return ERROR(dstSize_tooSmall);

	sub	r10d, eax
$LN540@FSE_decomp:
	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR bitD$5[rbp-64], rdi
$LN524@FSE_decomp:
	mov	rax, QWORD PTR dst$[rbp-80]
	add	rax, 253				; 000000fdH
	cmp	r14, rax
	jbe	$LL256@FSE_decomp
$LN509@FSE_decomp:

; 250  :     return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 0);
; 251  : }

	mov	rax, -70				; ffffffffffffffbaH
$LN252@FSE_decomp:
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN512@FSE_decomp:

; 232  :             *op++ = FSE_GETSYMBOL(&state1);

	movzx	eax, BYTE PTR [rax+r12*4+6]

; 233  :             break;
; 234  :     }   }
; 235  : 
; 236  :     return op-ostart;

	mov	BYTE PTR [r14], al
	sub	r14, QWORD PTR dst$[rbp-80]
	lea	rax, QWORD PTR [r14+1]

; 250  :     return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 0);
; 251  : }

	jmp	SHORT $LN252@FSE_decomp
$LN510@FSE_decomp:

; 225  :             *op++ = FSE_GETSYMBOL(&state2);

	movzx	eax, BYTE PTR [rax+r13*4+6]

; 233  :             break;
; 234  :     }   }
; 235  : 
; 236  :     return op-ostart;

	mov	BYTE PTR [r14], al
	sub	r14, QWORD PTR dst$[rbp-80]
	lea	rax, QWORD PTR [r14+1]

; 250  :     return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 0);
; 251  : }

	jmp	SHORT $LN252@FSE_decomp
FSE_decompress_usingDTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\fse_decompress.c
_TEXT	SEGMENT
maxSymbolValue$ = 48
tableLog$ = 52
counting$ = 64
__$ArrayPad$ = 576
dst$ = 640
dstCapacity$dead$ = 648
cSrc$ = 656
cSrcSize$ = 664
workSpace$ = 672
maxLog$dead$ = 680
FSE_decompress_wksp PROC

; 255  : {

$LN11:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 592				; 00000250H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, QWORD PTR workSpace$[rsp]

; 256  :     const BYTE* const istart = (const BYTE*)cSrc;
; 257  :     const BYTE* ip = istart;
; 258  :     short counting[FSE_MAX_SYMBOL_VALUE+1];
; 259  :     unsigned tableLog;
; 260  :     unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;
; 261  : 
; 262  :     /* normal FSE decoding mode */
; 263  :     size_t const NCountLength = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);

	lea	rdx, QWORD PTR maxSymbolValue$[rsp]
	mov	rdi, r9
	mov	QWORD PTR [rsp+32], r9
	mov	r9, r8
	mov	DWORD PTR maxSymbolValue$[rsp], 255	; 000000ffH
	mov	r14, r8
	mov	rbp, rcx
	lea	r8, QWORD PTR tableLog$[rsp]
	lea	rcx, QWORD PTR counting$[rsp]
	call	FSE_readNCount
	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 264  :     if (FSE_isError(NCountLength)) return NCountLength;

	ja	SHORT $LN1@FSE_decomp

; 265  :     /* if (NCountLength >= cSrcSize) return ERROR(srcSize_wrong); */  /* too small input size; supposed to be already checked in NCountLength, only remaining case : NCountLength==cSrcSize */
; 266  :     if (tableLog > maxLog) return ERROR(tableLog_tooLarge);

	mov	r9d, DWORD PTR tableLog$[rsp]
	cmp	r9d, 6
	jbe	SHORT $LN3@FSE_decomp
	mov	rax, -44				; ffffffffffffffd4H
	jmp	SHORT $LN1@FSE_decomp
$LN3@FSE_decomp:

; 270  :     CHECK_F( FSE_buildDTable (workSpace, counting, maxSymbolValue, tableLog) );

	mov	r8d, DWORD PTR maxSymbolValue$[rsp]
	lea	rdx, QWORD PTR counting$[rsp]
	mov	rcx, rsi
	call	FSE_buildDTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\fse_decompress.c

; 270  :     CHECK_F( FSE_buildDTable (workSpace, counting, maxSymbolValue, tableLog) );

	ja	SHORT $LN1@FSE_decomp

; 271  : 
; 272  :     return FSE_decompress_usingDTable (dst, dstCapacity, ip, cSrcSize, workSpace);   /* always return, even if it is an error code */

	sub	rdi, rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	r9, rdi
	lea	r8, QWORD PTR [r14+rbx]
	mov	rcx, rbp
	call	FSE_decompress_usingDTable
$LN1@FSE_decomp:

; 273  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 592				; 00000250H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
FSE_decompress_wksp ENDP
_TEXT	ENDS
END
