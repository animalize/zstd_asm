; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

LL_base	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	012H
	DD	014H
	DD	016H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	02000H
	DD	04000H
	DD	08000H
	DD	010000H
ML_base	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	020H
	DD	021H
	DD	022H
	DD	023H
	DD	025H
	DD	027H
	DD	029H
	DD	02bH
	DD	02fH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	083H
	DD	0103H
	DD	0203H
	DD	0403H
	DD	0803H
	DD	01003H
	DD	02003H
	DD	04003H
	DD	08003H
	DD	010003H
ZSTD_defaultCMem DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
LL_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
ZSTD_fcs_fieldSize DQ 0000000000000000H
	DQ	0000000000000002H
	DQ	0000000000000004H
	DQ	0000000000000008H
OF_base	DD	00H
	DD	01H
	DD	01H
	DD	05H
	DD	0dH
	DD	01dH
	DD	03dH
	DD	07dH
	DD	0fdH
	DD	01fdH
	DD	03fdH
	DD	07fdH
	DD	0ffdH
	DD	01ffdH
	DD	03ffdH
	DD	07ffdH
	DD	0fffdH
	DD	01fffdH
	DD	03fffdH
	DD	07fffdH
	DD	0ffffdH
	DD	01ffffdH
	DD	03ffffdH
	DD	07ffffdH
	DD	0fffffdH
	DD	01fffffdH
	DD	03fffffdH
	DD	07fffffdH
	DD	0ffffffdH
	DD	01ffffffdH
	DD	03ffffffdH
	DD	07ffffffdH
ML_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
repStartValue DD 01H
	DD	04H
	DD	08H
ZSTD_blockHeaderSize DQ 0000000000000003H
OF_bits	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
ZSTD_did_fieldSize DQ 0000000000000000H
	DQ	0000000000000001H
	DQ	0000000000000002H
	DQ	0000000000000004H
PUBLIC	ZSTD_decompressStream
PUBLIC	ZSTD_decodingBufferSize_min
PUBLIC	ZSTD_DCtx_reset
PUBLIC	ZSTD_DCtx_setParameter
PUBLIC	ZSTD_dParam_getBounds
PUBLIC	ZSTD_DCtx_refDDict
PUBLIC	ZSTD_decompress_usingDDict
PUBLIC	ZSTD_getDictID_fromFrame
PUBLIC	ZSTD_decompressBegin_usingDDict
PUBLIC	ZSTD_decompressBegin_usingDict
PUBLIC	ZSTD_decompressBegin
PUBLIC	ZSTD_loadDEntropy
PUBLIC	ZSTD_decompressContinue
PUBLIC	ZSTD_nextInputType
PUBLIC	ZSTD_nextSrcSizeToDecompress
PUBLIC	ZSTD_findFrameCompressedSize
PUBLIC	ZSTD_getFrameContentSize
PUBLIC	ZSTD_getFrameHeader
PUBLIC	ZSTD_getFrameHeader_advanced
PUBLIC	ZSTD_freeDCtx
PUBLIC	ZSTD_createDCtx
PUBLIC	ZSTD_createDCtx_advanced
pdata	SEGMENT
$pdata$ZSTD_decompressStream DD imagerel $LN231
	DD	imagerel $LN231+2420
	DD	imagerel $unwind$ZSTD_decompressStream
$pdata$ZSTD_decompressContinueStream DD imagerel ZSTD_decompressContinueStream
	DD	imagerel ZSTD_decompressContinueStream+200
	DD	imagerel $unwind$ZSTD_decompressContinueStream
$pdata$ZSTD_checkOutBuffer DD imagerel ZSTD_checkOutBuffer
	DD	imagerel ZSTD_checkOutBuffer+97
	DD	imagerel $unwind$ZSTD_checkOutBuffer
$pdata$ZSTD_DCtx_setParameter DD imagerel $LN71
	DD	imagerel $LN71+250
	DD	imagerel $unwind$ZSTD_DCtx_setParameter
$pdata$ZSTD_dParam_withinBounds DD imagerel ZSTD_dParam_withinBounds
	DD	imagerel ZSTD_dParam_withinBounds+94
	DD	imagerel $unwind$ZSTD_dParam_withinBounds
$pdata$ZSTD_DCtx_refDDict DD imagerel $LN7
	DD	imagerel $LN7+83
	DD	imagerel $unwind$ZSTD_DCtx_refDDict
$pdata$ZSTD_decompress_usingDDict DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$ZSTD_decompress_usingDDict
$pdata$ZSTD_getDictID_fromFrame DD imagerel $LN9
	DD	imagerel $LN9+70
	DD	imagerel $unwind$ZSTD_getDictID_fromFrame
$pdata$ZSTD_decompressBegin_usingDict DD imagerel $LN37
	DD	imagerel $LN37+370
	DD	imagerel $unwind$ZSTD_decompressBegin_usingDict
$pdata$ZSTD_decompress_insertDictionary DD imagerel ZSTD_decompress_insertDictionary
	DD	imagerel ZSTD_decompress_insertDictionary+266
	DD	imagerel $unwind$ZSTD_decompress_insertDictionary
$pdata$ZSTD_loadDEntropy DD imagerel $LN173
	DD	imagerel $LN173+1708
	DD	imagerel $unwind$ZSTD_loadDEntropy
$pdata$ZSTD_decompressContinue DD imagerel $LN416
	DD	imagerel $LN416+1132
	DD	imagerel $unwind$ZSTD_decompressContinue
$pdata$ZSTD_getDDict DD imagerel ZSTD_getDDict
	DD	imagerel ZSTD_getDDict+54
	DD	imagerel $unwind$ZSTD_getDDict
$pdata$ZSTD_decompressMultiFrame DD imagerel ZSTD_decompressMultiFrame
	DD	imagerel ZSTD_decompressMultiFrame+804
	DD	imagerel $unwind$ZSTD_decompressMultiFrame
$pdata$ZSTD_decompressFrame DD imagerel ZSTD_decompressFrame
	DD	imagerel ZSTD_decompressFrame+635
	DD	imagerel $unwind$ZSTD_decompressFrame
$pdata$ZSTD_setRleBlock DD imagerel ZSTD_setRleBlock
	DD	imagerel ZSTD_setRleBlock+69
	DD	imagerel $unwind$ZSTD_setRleBlock
$pdata$ZSTD_copyRawBlock DD imagerel ZSTD_copyRawBlock
	DD	imagerel ZSTD_copyRawBlock+71
	DD	imagerel $unwind$ZSTD_copyRawBlock
$pdata$ZSTD_findFrameCompressedSize DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$ZSTD_findFrameCompressedSize
$pdata$ZSTD_findFrameSizeInfo DD imagerel ZSTD_findFrameSizeInfo
	DD	imagerel ZSTD_findFrameSizeInfo+369
	DD	imagerel $unwind$ZSTD_findFrameSizeInfo
$pdata$ZSTD_decodeFrameHeader DD imagerel ZSTD_decodeFrameHeader
	DD	imagerel ZSTD_decodeFrameHeader+252
	DD	imagerel $unwind$ZSTD_decodeFrameHeader
$pdata$ZSTD_getFrameContentSize DD imagerel $LN9
	DD	imagerel $LN9+61
	DD	imagerel $unwind$ZSTD_getFrameContentSize
$pdata$ZSTD_getFrameHeader_advanced DD imagerel $LN50
	DD	imagerel $LN50+249
	DD	imagerel $unwind$ZSTD_getFrameHeader_advanced
$pdata$3$ZSTD_getFrameHeader_advanced DD imagerel $LN50+249
	DD	imagerel $LN50+505
	DD	imagerel $chain$3$ZSTD_getFrameHeader_advanced
$pdata$4$ZSTD_getFrameHeader_advanced DD imagerel $LN50+505
	DD	imagerel $LN50+522
	DD	imagerel $chain$4$ZSTD_getFrameHeader_advanced
$pdata$ZSTD_frameHeaderSize_internal DD imagerel ZSTD_frameHeaderSize_internal
	DD	imagerel ZSTD_frameHeaderSize_internal+130
	DD	imagerel $unwind$ZSTD_frameHeaderSize_internal
$pdata$ZSTD_freeDCtx DD imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$ZSTD_freeDCtx
$pdata$0$ZSTD_freeDCtx DD imagerel $LN18+48
	DD	imagerel $LN18+156
	DD	imagerel $chain$0$ZSTD_freeDCtx
$pdata$2$ZSTD_freeDCtx DD imagerel $LN18+156
	DD	imagerel $LN18+170
	DD	imagerel $chain$2$ZSTD_freeDCtx
$pdata$3$ZSTD_freeDCtx DD imagerel $LN18+170
	DD	imagerel $LN18+178
	DD	imagerel $chain$3$ZSTD_freeDCtx
$pdata$ZSTD_clearDict DD imagerel ZSTD_clearDict
	DD	imagerel ZSTD_clearDict+162
	DD	imagerel $unwind$ZSTD_clearDict
$pdata$ZSTD_createDCtx DD imagerel $LN11
	DD	imagerel $LN11+100
	DD	imagerel $unwind$ZSTD_createDCtx
$pdata$ZSTD_createDCtx_advanced DD imagerel $LN11
	DD	imagerel $LN11+144
	DD	imagerel $unwind$ZSTD_createDCtx_advanced
$pdata$ZSTD_initDCtx_internal DD imagerel ZSTD_initDCtx_internal
	DD	imagerel ZSTD_initDCtx_internal+193
	DD	imagerel $unwind$ZSTD_initDCtx_internal
$pdata$ZSTD_limitCopy DD imagerel ZSTD_limitCopy
	DD	imagerel ZSTD_limitCopy+44
	DD	imagerel $unwind$ZSTD_limitCopy
$pdata$ZSTD_cpuid DD imagerel ZSTD_cpuid
	DD	imagerel ZSTD_cpuid+111
	DD	imagerel $unwind$ZSTD_cpuid
xdata	SEGMENT
$unwind$ZSTD_decompressStream DD 0b2101H
	DD	0203421H
	DD	0180121H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
$unwind$ZSTD_decompressContinueStream DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
$unwind$ZSTD_checkOutBuffer DD 010401H
	DD	04204H
$unwind$ZSTD_DCtx_setParameter DD 010401H
	DD	02204H
$unwind$ZSTD_dParam_withinBounds DD 010401H
	DD	02204H
$unwind$ZSTD_DCtx_refDDict DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTD_decompress_usingDDict DD 010401H
	DD	08204H
$unwind$ZSTD_getDictID_fromFrame DD 020601H
	DD	030029206H
$unwind$ZSTD_decompressBegin_usingDict DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$ZSTD_decompress_insertDictionary DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
$unwind$ZSTD_loadDEntropy DD 0b3019H
	DD	053341fH
	DD	048011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$ZSTD_decompressContinue DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
$unwind$ZSTD_getDDict DD 010401H
	DD	04204H
$unwind$ZSTD_decompressMultiFrame DD 0c2101H
	DD	0e6421H
	DD	0d5421H
	DD	0c3421H
	DD	0f01d5221H
	DD	0d019e01bH
	DD	07015c017H
$unwind$ZSTD_decompressFrame DD 0a1e01H
	DD	0e341eH
	DD	0f01a521eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_setRleBlock DD 020601H
	DD	030023206H
$unwind$ZSTD_copyRawBlock DD 020601H
	DD	030023206H
$unwind$ZSTD_findFrameCompressedSize DD 010401H
	DD	06204H
$unwind$ZSTD_findFrameSizeInfo DD 081501H
	DD	0107415H
	DD	0f6415H
	DD	0e3415H
	DD	0e011b215H
$unwind$ZSTD_decodeFrameHeader DD 020901H
	DD	03002f209H
$unwind$ZSTD_getFrameContentSize DD 010401H
	DD	0a204H
$unwind$ZSTD_getFrameHeader_advanced DD 07a301H
	DD	05e4a3H
	DD	047495H
	DD	03648dH
	DD	03002H
$chain$3$ZSTD_getFrameHeader_advanced DD 020521H
	DD	025405H
	DD	imagerel $LN50
	DD	imagerel $LN50+249
	DD	imagerel $unwind$ZSTD_getFrameHeader_advanced
$chain$4$ZSTD_getFrameHeader_advanced DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+249
	DD	imagerel $unwind$ZSTD_getFrameHeader_advanced
$unwind$ZSTD_frameHeaderSize_internal DD 033b01H
	DD	0343bH
	DD	0204H
$unwind$ZSTD_freeDCtx DD 020601H
	DD	030027206H
$chain$0$ZSTD_freeDCtx DD 020521H
	DD	0a7405H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$ZSTD_freeDCtx
$chain$2$ZSTD_freeDCtx DD 020021H
	DD	0a7400H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$ZSTD_freeDCtx
$chain$3$ZSTD_freeDCtx DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$ZSTD_freeDCtx
$unwind$ZSTD_clearDict DD 040a01H
	DD	0e340aH
	DD	07006b20aH
$unwind$ZSTD_createDCtx DD 020601H
	DD	030025206H
$unwind$ZSTD_createDCtx_advanced DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$ZSTD_initDCtx_internal DD 020601H
	DD	030021206H
$unwind$ZSTD_limitCopy DD 020601H
	DD	030023206H
$unwind$ZSTD_cpuid DD 060f01H
	DD	05640fH
	DD	04340fH
	DD	0700b120fH
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE16 PROC

; 320  :     if (MEM_isLittleEndian())
; 321  :         return MEM_read16(memPtr);

	movzx	eax, WORD PTR [rcx]

; 322  :     else {
; 323  :         const BYTE* p = (const BYTE*)memPtr;
; 324  :         return (U16)(p[0] + (p[1]<<8));
; 325  :     }
; 326  : }

	ret	0
MEM_readLE16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\cpu.h
_TEXT	SEGMENT
$T1 = 32
ZSTD_cpuid PROC

; 34   : MEM_STATIC ZSTD_cpuid_t ZSTD_cpuid(void) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 16

; 35   :     U32 f1c = 0;

	xor	r9d, r9d
	mov	r8, rcx

; 36   :     U32 f1d = 0;
; 37   :     U32 f7b = 0;
; 38   :     U32 f7c = 0;
; 39   : #if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
; 40   :     int reg[4];
; 41   :     __cpuid((int*)reg, 0);

	xor	ecx, ecx
	xor	eax, eax
	cpuid
	mov	edi, r9d
	mov	r10d, r9d
	mov	r11d, r9d
	mov	esi, eax

; 42   :     {
; 43   :         int const n = reg[0];

	cmp	eax, 1

; 44   :         if (n >= 1) {

	jl	SHORT $LN2@ZSTD_cpuid

; 45   :             __cpuid((int*)reg, 1);

	mov	eax, 1
	xor	ecx, ecx
	cpuid
	mov	edi, edx
	mov	r9d, ecx
$LN2@ZSTD_cpuid:

; 46   :             f1c = (U32)reg[2];
; 47   :             f1d = (U32)reg[3];
; 48   :         }
; 49   :         if (n >= 7) {

	cmp	esi, 7
	jl	SHORT $LN3@ZSTD_cpuid

; 50   :             __cpuidex((int*)reg, 7, 0);

	mov	eax, 7
	xor	ecx, ecx
	cpuid
	mov	r11d, ecx
	mov	r10d, ebx
$LN3@ZSTD_cpuid:

; 51   :             f7b = (U32)reg[1];
; 52   :             f7c = (U32)reg[2];
; 53   :         }
; 54   :     }
; 55   : #elif defined(__i386__) && defined(__PIC__) && !defined(__clang__) && defined(__GNUC__)
; 56   :     /* The following block like the normal cpuid branch below, but gcc
; 57   :      * reserves ebx for use of its pic register so we must specially
; 58   :      * handle the save and restore to avoid clobbering the register
; 59   :      */
; 60   :     U32 n;
; 61   :     __asm__(
; 62   :         "pushl %%ebx\n\t"
; 63   :         "cpuid\n\t"
; 64   :         "popl %%ebx\n\t"
; 65   :         : "=a"(n)
; 66   :         : "a"(0)
; 67   :         : "ecx", "edx");
; 68   :     if (n >= 1) {
; 69   :       U32 f1a;
; 70   :       __asm__(
; 71   :           "pushl %%ebx\n\t"
; 72   :           "cpuid\n\t"
; 73   :           "popl %%ebx\n\t"
; 74   :           : "=a"(f1a), "=c"(f1c), "=d"(f1d)
; 75   :           : "a"(1));
; 76   :     }
; 77   :     if (n >= 7) {
; 78   :       __asm__(
; 79   :           "pushl %%ebx\n\t"
; 80   :           "cpuid\n\t"
; 81   :           "movl %%ebx, %%eax\n\t"
; 82   :           "popl %%ebx"
; 83   :           : "=a"(f7b), "=c"(f7c)
; 84   :           : "a"(7), "c"(0)
; 85   :           : "edx");
; 86   :     }
; 87   : #elif defined(__x86_64__) || defined(_M_X64) || defined(__i386__)
; 88   :     U32 n;
; 89   :     __asm__("cpuid" : "=a"(n) : "a"(0) : "ebx", "ecx", "edx");
; 90   :     if (n >= 1) {
; 91   :       U32 f1a;
; 92   :       __asm__("cpuid" : "=a"(f1a), "=c"(f1c), "=d"(f1d) : "a"(1) : "ebx");
; 93   :     }
; 94   :     if (n >= 7) {
; 95   :       U32 f7a;
; 96   :       __asm__("cpuid"
; 97   :               : "=a"(f7a), "=b"(f7b), "=c"(f7c)
; 98   :               : "a"(7), "c"(0)
; 99   :               : "edx");
; 100  :     }
; 101  : #endif
; 102  :     {
; 103  :         ZSTD_cpuid_t cpuid;
; 104  :         cpuid.f1c = f1c;
; 105  :         cpuid.f1d = f1d;
; 106  :         cpuid.f7b = f7b;
; 107  :         cpuid.f7c = f7c;
; 108  :         return cpuid;
; 109  :     }
; 110  : }

	mov	rbx, QWORD PTR [rsp+32]
	mov	rax, r8
	mov	rsi, QWORD PTR [rsp+40]
	mov	DWORD PTR [r8], r9d
	mov	DWORD PTR [r8+4], edi
	mov	DWORD PTR [r8+8], r10d
	mov	DWORD PTR [r8+12], r11d
	add	rsp, 16
	pop	rdi
	ret	0
ZSTD_cpuid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\cpu.h
_TEXT	SEGMENT
cpuid$ = 8
ZSTD_cpuid_bmi2 PROC

; 187  :   B(bmi2, 8)

	mov	eax, DWORD PTR [rcx+8]
	shr	eax, 8
	and	eax, 1
	ret	0
ZSTD_cpuid_bmi2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
src$ = 64
srcSize$ = 72
ZSTD_limitCopy PROC

; 305  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 306  :     size_t const length = MIN(dstCapacity, srcSize);

	cmp	rdx, r9
	mov	rbx, r9
	mov	rax, r8
	cmovb	rbx, rdx

; 307  :     if (length > 0) {

	test	rbx, rbx
	je	SHORT $LN4@ZSTD_limit

; 308  :         memcpy(dst, src, length);

	mov	r8, rbx
	mov	rdx, rax
	call	memcpy
$LN4@ZSTD_limit:

; 309  :     }
; 310  :     return length;
; 311  : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_limitCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
format$ = 8
ZSTD_startingInputLength PROC

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	test	ecx, ecx
	mov	eax, 1
	mov	edx, 5
	cmove	eax, edx

; 92   :     /* only supports formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless */
; 93   :     assert( (format == ZSTD_f_zstd1) || (format == ZSTD_f_zstd1_magicless) );
; 94   :     return startingInputLength;
; 95   : }

	ret	0
ZSTD_startingInputLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\cpu.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\cpu.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\cpu.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 32
ZSTD_initDCtx_internal PROC

; 98   : {

	push	rbx
	sub	rsp, 16

; 99   :     dctx->format = ZSTD_f_zstd1;  /* ZSTD_decompressBegin() invokes ZSTD_startingInputLength() with argument dctx->format */

	xor	r11d, r11d

; 100  :     dctx->staticSize  = 0;
; 101  :     dctx->maxWindowSize = ZSTD_MAXWINDOWSIZE_DEFAULT;

	mov	QWORD PTR [rcx+29072], 134217729	; 08000001H
	mov	DWORD PTR [rcx+28944], r11d
	mov	r8, rcx
	mov	QWORD PTR [rcx+29000], r11
; File E:\dev\pyzstd\lib\common\cpu.h

; 41   :     __cpuid((int*)reg, 0);

	xor	eax, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 102  :     dctx->ddict       = NULL;

	mov	QWORD PTR [rcx+29024], r11
; File E:\dev\pyzstd\lib\common\cpu.h

; 37   :     U32 f7b = 0;

	mov	r9d, r11d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 103  :     dctx->ddictLocal  = NULL;

	mov	QWORD PTR [rcx+29016], r11

; 104  :     dctx->dictEnd     = NULL;

	mov	QWORD PTR [rcx+28768], r11

; 105  :     dctx->ddictIsCold = 0;

	mov	QWORD PTR [rcx+29036], r11

; 106  :     dctx->dictUses = ZSTD_dont_use;
; 107  :     dctx->inBuff      = NULL;

	mov	QWORD PTR [rcx+29048], r11

; 108  :     dctx->inBuffSize  = 0;

	mov	QWORD PTR [rcx+29056], r11

; 109  :     dctx->outBuffSize = 0;

	mov	QWORD PTR [rcx+29088], r11

; 110  :     dctx->streamStage = zdss_init;

	mov	DWORD PTR [rcx+29044], r11d

; 111  :     dctx->legacyContext = NULL;

	mov	QWORD PTR [rcx+29120], r11

; 112  :     dctx->previousLegacyVersion = 0;

	mov	DWORD PTR [rcx+29128], r11d

; 113  :     dctx->noForwardProgress = 0;

	mov	DWORD PTR [rcx+29140], r11d

; 114  :     dctx->oversizedDuration = 0;

	mov	QWORD PTR [rcx+160304], r11
; File E:\dev\pyzstd\lib\common\cpu.h

; 41   :     __cpuid((int*)reg, 0);

	xor	ecx, ecx
	cpuid
	mov	r10d, eax

; 42   :     {
; 43   :         int const n = reg[0];

	cmp	eax, 1

; 44   :         if (n >= 1) {

	jl	SHORT $LN4@ZSTD_initD

; 45   :             __cpuid((int*)reg, 1);

	mov	eax, 1
	xor	ecx, ecx
	cpuid
$LN4@ZSTD_initD:

; 46   :             f1c = (U32)reg[2];
; 47   :             f1d = (U32)reg[3];
; 48   :         }
; 49   :         if (n >= 7) {

	cmp	r10d, 7
	jl	SHORT $LN5@ZSTD_initD

; 50   :             __cpuidex((int*)reg, 7, 0);

	mov	eax, 7
	xor	ecx, ecx
	cpuid
	mov	r9d, ebx
$LN5@ZSTD_initD:

; 187  :   B(bmi2, 8)

	shr	r9d, 8
	and	r9d, 1
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 116  :     dctx->outBufferMode = ZSTD_obm_buffered;

	mov	DWORD PTR [r8+29144], r11d
	mov	DWORD PTR [r8+29008], r9d

; 117  : #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 118  :     dctx->dictContentEndForFuzzing = NULL;
; 119  : #endif
; 120  : }

	add	rsp, 16
	pop	rbx
	ret	0
ZSTD_initDCtx_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 32
customMem$ = 80
ZSTD_createDCtx_advanced PROC

; 136  : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 137  :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	xor	edx, edx
	mov	rdi, rcx
	mov	eax, edx
	cmp	QWORD PTR [rcx+8], rax
	sete	al
	cmp	QWORD PTR [rcx], rdx
	sete	dl
	cmp	eax, edx
	jne	SHORT $LN8@ZSTD_creat
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rcx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 139  :     {   ZSTD_DCtx* const dctx = (ZSTD_DCtx*)ZSTD_malloc(sizeof(*dctx), customMem);

	movsd	xmm0, QWORD PTR [rcx+16]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN6@ZSTD_creat

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	edx, 160312				; 00027238H
	call	rax
	jmp	SHORT $LN9@ZSTD_creat
$LN6@ZSTD_creat:

; 60   :     return malloc(size);

	mov	ecx, 160312				; 00027238H
	call	QWORD PTR __imp_malloc
$LN9@ZSTD_creat:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 140  :         if (!dctx) return NULL;

	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN8@ZSTD_creat

; 141  :         dctx->customMem = customMem;

	movaps	xmm0, XMMWORD PTR [rdi]

; 142  :         ZSTD_initDCtx_internal(dctx);

	mov	rcx, rax
	movsd	xmm1, QWORD PTR [rdi+16]
	movups	XMMWORD PTR [rax+28960], xmm0
	movsd	QWORD PTR [rax+28976], xmm1
	call	ZSTD_initDCtx_internal

; 143  :         return dctx;

	mov	rax, rbx

; 144  :     }
; 145  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN8@ZSTD_creat:
	mov	rbx, QWORD PTR [rsp+80]
	xor	eax, eax
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTD_createDCtx_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
ZSTD_createDCtx PROC

; 148  : {

$LN11:
	push	rbx
	sub	rsp, 48					; 00000030H

; 150  :     return ZSTD_createDCtx_advanced(ZSTD_defaultCMem);

	movups	xmm0, XMMWORD PTR ZSTD_defaultCMem
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	mov	ecx, 160312				; 00027238H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 150  :     return ZSTD_createDCtx_advanced(ZSTD_defaultCMem);

	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	xmm0, QWORD PTR ZSTD_defaultCMem+16
	movsd	QWORD PTR $T2[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 140  :         if (!dctx) return NULL;

	test	rax, rax
	jne	SHORT $LN5@ZSTD_creat

; 151  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN5@ZSTD_creat:

; 141  :         dctx->customMem = customMem;

	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 142  :         ZSTD_initDCtx_internal(dctx);

	mov	rcx, rbx
	movups	XMMWORD PTR [rax+28960], xmm0
	movsd	xmm0, QWORD PTR $T2[rsp]
	movsd	QWORD PTR [rax+28976], xmm0
	call	ZSTD_initDCtx_internal

; 150  :     return ZSTD_createDCtx_advanced(ZSTD_defaultCMem);

	mov	rax, rbx

; 151  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
ZSTD_createDCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 32
cMem$2 = 64
dctx$ = 112
ZSTD_clearDict PROC

; 154  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 96					; 00000060H

; 155  :     ZSTD_freeDDict(dctx->ddictLocal);

	mov	rbx, QWORD PTR [rcx+29016]
	mov	rdi, rcx
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 214  :     if (ddict==NULL) return 0;   /* support free on NULL */

	test	rbx, rbx
	je	SHORT $LN14@ZSTD_clear

; 215  :     {   ZSTD_customMem const cMem = ddict->cMem;

	movups	xmm0, XMMWORD PTR [rbx+26696]

; 216  :         ZSTD_free(ddict->dictBuffer, cMem);

	mov	rcx, QWORD PTR [rbx]
	movsd	xmm1, QWORD PTR [rbx+26712]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR cMem$2[rsp+16], xmm1
	movsd	QWORD PTR $T1[rsp+16], xmm1
	movups	XMMWORD PTR cMem$2[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN9@ZSTD_clear

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN8@ZSTD_clear

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN9@ZSTD_clear
$LN8@ZSTD_clear:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN9@ZSTD_clear:

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR cMem$2[rsp+8]
	test	rax, rax
	je	SHORT $LN13@ZSTD_clear

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$2[rsp+16]
	mov	rdx, rbx
	call	rax
	jmp	SHORT $LN14@ZSTD_clear
$LN13@ZSTD_clear:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN14@ZSTD_clear:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 159  : }

	mov	rbx, QWORD PTR [rsp+112]
	xor	eax, eax
	mov	QWORD PTR [rdi+29016], rax
	mov	QWORD PTR [rdi+29024], rax
	mov	DWORD PTR [rdi+29040], eax
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
ZSTD_clearDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
cMem$1 = 32
dctx$ = 80
ZSTD_freeDCtx PROC

; 162  : {

$LN18:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx

; 163  :     if (dctx==NULL) return 0;   /* support free on NULL */

	test	rcx, rcx
	je	$LN14@ZSTD_freeD

; 164  :     RETURN_ERROR_IF(dctx->staticSize, memory_allocation, "not compatible with static DCtx");

	cmp	QWORD PTR [rcx+29000], 0
	je	SHORT $LN3@ZSTD_freeD
	mov	rax, -64				; ffffffffffffffc0H

; 175  :     }
; 176  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN3@ZSTD_freeD:

; 165  :     {   ZSTD_customMem const cMem = dctx->customMem;

	movups	xmm0, XMMWORD PTR [rcx+28960]
	mov	QWORD PTR [rsp+80], rdi
	movsd	xmm1, QWORD PTR [rcx+28976]
	movups	XMMWORD PTR cMem$1[rsp], xmm0
	movsd	QWORD PTR cMem$1[rsp+16], xmm1

; 166  :         ZSTD_clearDict(dctx);

	call	ZSTD_clearDict

; 167  :         ZSTD_free(dctx->inBuff, cMem);

	mov	rcx, QWORD PTR [rbx+29048]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	mov	rdi, QWORD PTR cMem$1[rsp+8]
	test	rcx, rcx
	je	SHORT $LN9@ZSTD_freeD

; 78   :         if (customMem.customFree)

	test	rdi, rdi
	je	SHORT $LN8@ZSTD_freeD

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR cMem$1[rsp+16]
	call	rdi
	jmp	SHORT $LN9@ZSTD_freeD
$LN8@ZSTD_freeD:

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN9@ZSTD_freeD:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 168  :         dctx->inBuff = NULL;

	mov	QWORD PTR [rbx+29048], 0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rdi, rdi
	je	SHORT $LN13@ZSTD_freeD

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$1[rsp+16]
	mov	rdx, rbx
	call	rdi
	mov	rdi, QWORD PTR [rsp+80]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 174  :         return 0;

	xor	eax, eax

; 175  :     }
; 176  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN13@ZSTD_freeD:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	mov	rdi, QWORD PTR [rsp+80]
$LN14@ZSTD_freeD:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 174  :         return 0;

	xor	eax, eax

; 175  :     }
; 176  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_freeDCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
src$ = 16
srcSize$ = 24
format$ = 32
ZSTD_frameHeaderSize_internal PROC

; 214  : {

	sub	rsp, 8

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	test	r8d, r8d
	mov	r10d, 1
	mov	eax, r10d
	mov	r9d, 5
	cmove	eax, r9d

; 215  :     size_t const minInputSize = ZSTD_startingInputLength(format);
; 216  :     RETURN_ERROR_IF(srcSize < minInputSize, srcSize_wrong, "");

	cmp	rdx, rax
	jae	SHORT $LN2@ZSTD_frame
	mov	rax, -72				; ffffffffffffffb8H

; 223  :              + ZSTD_did_fieldSize[dictID] + ZSTD_fcs_fieldSize[fcsId]
; 224  :              + (singleSegment && !fcsId);
; 225  :     }
; 226  : }

	add	rsp, 8
	ret	0
$LN2@ZSTD_frame:

; 217  : 
; 218  :     {   BYTE const fhd = ((const BYTE*)src)[minInputSize-1];
; 219  :         U32 const dictID= fhd & 3;

	movzx	r8d, BYTE PTR [rax+rcx-1]

; 220  :         U32 const singleSegment = (fhd >> 5) & 1;
; 221  :         U32 const fcsId = fhd >> 6;
; 222  :         return minInputSize + !singleSegment

	xor	r9d, r9d
	mov	r11d, r8d
	mov	QWORD PTR [rsp], rbx
	mov	ecx, r8d
	and	r11d, 3
	shr	ecx, 6
	and	r8d, 32					; 00000020H
	je	SHORT $LN5@ZSTD_frame
	test	ecx, ecx
	je	SHORT $LN6@ZSTD_frame
$LN5@ZSTD_frame:
	mov	r10, r9
$LN6@ZSTD_frame:
	lea	rbx, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR ZSTD_fcs_fieldSize[rbx+rcx*8]
	add	rcx, QWORD PTR ZSTD_did_fieldSize[rbx+r11*8]
	mov	rbx, QWORD PTR [rsp]
	test	r8d, r8d
	sete	r9b
	add	rcx, r10
	add	r9, rcx
	add	rax, r9

; 223  :              + ZSTD_did_fieldSize[dictID] + ZSTD_fcs_fieldSize[fcsId]
; 224  :              + (singleSegment && !fcsId);
; 225  :     }
; 226  : }

	add	rsp, 8
	ret	0
ZSTD_frameHeaderSize_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zfhPtr$ = 16
src$ = 24
srcSize$ = 32
format$ = 40
ZSTD_getFrameHeader_advanced PROC

; 245  : {

$LN50:
	push	rbx

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	test	r9d, r9d
	mov	eax, 5
	xorps	xmm0, xmm0
	mov	r10d, 1
	cmove	r10d, eax

; 245  : {

	mov	rbx, r8

; 246  :     const BYTE* ip = (const BYTE*)src;
; 247  :     size_t const minInputSize = ZSTD_startingInputLength(format);
; 248  : 
; 249  :     memset(zfhPtr, 0, sizeof(*zfhPtr));   /* not strictly necessary, but static analyzer do not understand that zfhPtr is only going to be read only if return value is zero, since they are 2 different signals */

	xor	eax, eax
	mov	r11, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	QWORD PTR [rcx+32], rax

; 250  :     if (srcSize < minInputSize) return minInputSize;

	cmp	r8, r10
	jae	SHORT $LN9@ZSTD_getFr
	mov	eax, r10d

; 318  : }

	pop	rbx
	ret	0
$LN9@ZSTD_getFr:

; 251  :     RETURN_ERROR_IF(src==NULL, GENERIC, "invalid parameter");

	test	rdx, rdx
	jne	SHORT $LN10@ZSTD_getFr
	lea	rax, QWORD PTR [rdx-1]

; 318  : }

	pop	rbx
	ret	0
$LN10@ZSTD_getFr:

; 252  : 
; 253  :     if ( (format != ZSTD_f_zstd1_magicless)
; 254  :       && (MEM_readLE32(src) != ZSTD_MAGICNUMBER) ) {

	cmp	r9d, 1
	je	SHORT $LN3@ZSTD_getFr
	mov	eax, DWORD PTR [rdx]
	cmp	eax, -47205080				; fd2fb528H
	je	SHORT $LN3@ZSTD_getFr

; 255  :         if ((MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {

	and	eax, -16				; fffffff0H
	cmp	eax, 407710288				; 184d2a50H
	jne	SHORT $LN4@ZSTD_getFr

; 256  :             /* skippable frame */
; 257  :             if (srcSize < ZSTD_SKIPPABLEHEADERSIZE)

	cmp	rbx, 8
	jae	SHORT $LN14@ZSTD_getFr

; 258  :                 return ZSTD_SKIPPABLEHEADERSIZE; /* magic number + frame length */

	mov	eax, 8

; 318  : }

	pop	rbx
	ret	0
$LN14@ZSTD_getFr:

; 259  :             memset(zfhPtr, 0, sizeof(*zfhPtr));
; 260  :             zfhPtr->frameContentSize = MEM_readLE32((const char *)src + ZSTD_FRAMEIDSIZE);

	mov	eax, DWORD PTR [rdx+4]
	mov	QWORD PTR [rcx], rax

; 261  :             zfhPtr->frameType = ZSTD_skippableFrame;
; 262  :             return 0;

	xor	eax, eax
	mov	DWORD PTR [rcx+20], 1

; 318  : }

	pop	rbx
	ret	0
$LN4@ZSTD_getFr:

; 263  :         }
; 264  :         RETURN_ERROR(prefix_unknown, "");

	mov	rax, -10

; 318  : }

	pop	rbx
	ret	0
$LN3@ZSTD_getFr:

; 219  :         U32 const dictID= fhd & 3;

	movzx	r8d, BYTE PTR [r10+rdx-1]
	mov	r9d, r8d
	mov	QWORD PTR [rsp+24], rsi

; 220  :         U32 const singleSegment = (fhd >> 5) & 1;
; 221  :         U32 const fcsId = fhd >> 6;

	mov	eax, r8d
	mov	QWORD PTR [rsp+32], rdi

; 92   :     /* only supports formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless */
; 93   :     assert( (format == ZSTD_f_zstd1) || (format == ZSTD_f_zstd1_magicless) );
; 94   :     return startingInputLength;
; 95   : }
; 96   : 
; 97   : static void ZSTD_initDCtx_internal(ZSTD_DCtx* dctx)
; 98   : {
; 99   :     dctx->format = ZSTD_f_zstd1;  /* ZSTD_decompressBegin() invokes ZSTD_startingInputLength() with argument dctx->format */
; 100  :     dctx->staticSize  = 0;
; 101  :     dctx->maxWindowSize = ZSTD_MAXWINDOWSIZE_DEFAULT;
; 102  :     dctx->ddict       = NULL;
; 103  :     dctx->ddictLocal  = NULL;
; 104  :     dctx->dictEnd     = NULL;
; 105  :     dctx->ddictIsCold = 0;
; 106  :     dctx->dictUses = ZSTD_dont_use;
; 107  :     dctx->inBuff      = NULL;
; 108  :     dctx->inBuffSize  = 0;
; 109  :     dctx->outBuffSize = 0;
; 110  :     dctx->streamStage = zdss_init;
; 111  :     dctx->legacyContext = NULL;
; 112  :     dctx->previousLegacyVersion = 0;
; 113  :     dctx->noForwardProgress = 0;
; 114  :     dctx->oversizedDuration = 0;
; 115  :     dctx->bmi2 = ZSTD_cpuid_bmi2(ZSTD_cpuid());
; 116  :     dctx->outBufferMode = ZSTD_obm_buffered;
; 117  : #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 118  :     dctx->dictContentEndForFuzzing = NULL;
; 119  : #endif
; 120  : }
; 121  : 
; 122  : ZSTD_DCtx* ZSTD_initStaticDCtx(void *workspace, size_t workspaceSize)
; 123  : {
; 124  :     ZSTD_DCtx* const dctx = (ZSTD_DCtx*) workspace;
; 125  : 
; 126  :     if ((size_t)workspace & 7) return NULL;  /* 8-aligned */
; 127  :     if (workspaceSize < sizeof(ZSTD_DCtx)) return NULL;  /* minimum size */
; 128  : 
; 129  :     ZSTD_initDCtx_internal(dctx);
; 130  :     dctx->staticSize = workspaceSize;
; 131  :     dctx->inBuff = (char*)(dctx+1);
; 132  :     return dctx;
; 133  : }
; 134  : 
; 135  : ZSTD_DCtx* ZSTD_createDCtx_advanced(ZSTD_customMem customMem)
; 136  : {
; 137  :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;
; 138  : 
; 139  :     {   ZSTD_DCtx* const dctx = (ZSTD_DCtx*)ZSTD_malloc(sizeof(*dctx), customMem);
; 140  :         if (!dctx) return NULL;
; 141  :         dctx->customMem = customMem;
; 142  :         ZSTD_initDCtx_internal(dctx);
; 143  :         return dctx;
; 144  :     }
; 145  : }
; 146  : 
; 147  : ZSTD_DCtx* ZSTD_createDCtx(void)
; 148  : {
; 149  :     DEBUGLOG(3, "ZSTD_createDCtx");
; 150  :     return ZSTD_createDCtx_advanced(ZSTD_defaultCMem);
; 151  : }
; 152  : 
; 153  : static void ZSTD_clearDict(ZSTD_DCtx* dctx)
; 154  : {
; 155  :     ZSTD_freeDDict(dctx->ddictLocal);
; 156  :     dctx->ddictLocal = NULL;
; 157  :     dctx->ddict = NULL;
; 158  :     dctx->dictUses = ZSTD_dont_use;
; 159  : }
; 160  : 
; 161  : size_t ZSTD_freeDCtx(ZSTD_DCtx* dctx)
; 162  : {
; 163  :     if (dctx==NULL) return 0;   /* support free on NULL */
; 164  :     RETURN_ERROR_IF(dctx->staticSize, memory_allocation, "not compatible with static DCtx");
; 165  :     {   ZSTD_customMem const cMem = dctx->customMem;
; 166  :         ZSTD_clearDict(dctx);
; 167  :         ZSTD_free(dctx->inBuff, cMem);
; 168  :         dctx->inBuff = NULL;
; 169  : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
; 170  :         if (dctx->legacyContext)
; 171  :             ZSTD_freeLegacyStreamContext(dctx->legacyContext, dctx->previousLegacyVersion);
; 172  : #endif
; 173  :         ZSTD_free(dctx, cMem);
; 174  :         return 0;
; 175  :     }
; 176  : }
; 177  : 
; 178  : /* no longer useful */
; 179  : void ZSTD_copyDCtx(ZSTD_DCtx* dstDCtx, const ZSTD_DCtx* srcDCtx)
; 180  : {
; 181  :     size_t const toCopy = (size_t)((char*)(&dstDCtx->inBuff) - (char*)dstDCtx);
; 182  :     memcpy(dstDCtx, srcDCtx, toCopy);  /* no need to copy workspace */
; 183  : }
; 184  : 
; 185  : 
; 186  : /*-*************************************************************
; 187  :  *   Frame header decoding
; 188  :  ***************************************************************/
; 189  : 
; 190  : /*! ZSTD_isFrame() :
; 191  :  *  Tells if the content of `buffer` starts with a valid Frame Identifier.
; 192  :  *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
; 193  :  *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
; 194  :  *  Note 3 : Skippable Frame Identifiers are considered valid. */
; 195  : unsigned ZSTD_isFrame(const void* buffer, size_t size)
; 196  : {
; 197  :     if (size < ZSTD_FRAMEIDSIZE) return 0;
; 198  :     {   U32 const magic = MEM_readLE32(buffer);
; 199  :         if (magic == ZSTD_MAGICNUMBER) return 1;
; 200  :         if ((magic & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;
; 201  :     }
; 202  : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
; 203  :     if (ZSTD_isLegacy(buffer, size)) return 1;
; 204  : #endif
; 205  :     return 0;
; 206  : }
; 207  : 
; 208  : /** ZSTD_frameHeaderSize_internal() :
; 209  :  *  srcSize must be large enough to reach header size fields.
; 210  :  *  note : only works for formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless.
; 211  :  * @return : size of the Frame Header
; 212  :  *           or an error code, which can be tested with ZSTD_isError() */
; 213  : static size_t ZSTD_frameHeaderSize_internal(const void* src, size_t srcSize, ZSTD_format_e format)
; 214  : {
; 215  :     size_t const minInputSize = ZSTD_startingInputLength(format);
; 216  :     RETURN_ERROR_IF(srcSize < minInputSize, srcSize_wrong, "");
; 217  : 
; 218  :     {   BYTE const fhd = ((const BYTE*)src)[minInputSize-1];
; 219  :         U32 const dictID= fhd & 3;

	and	r9d, 3

; 220  :         U32 const singleSegment = (fhd >> 5) & 1;
; 221  :         U32 const fcsId = fhd >> 6;

	shr	eax, 6

; 222  :         return minInputSize + !singleSegment

	xor	edi, edi
	mov	QWORD PTR [rsp+40], r14
	and	r8d, 32					; 00000020H
	je	SHORT $LN41@ZSTD_getFr
	lea	esi, QWORD PTR [rdi+1]
	test	eax, eax
	je	SHORT $LN42@ZSTD_getFr
$LN41@ZSTD_getFr:
	mov	rsi, rdi
$LN42@ZSTD_getFr:
	lea	r14, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR ZSTD_fcs_fieldSize[r14+rax*8]
	mov	rax, rdi
	add	rcx, QWORD PTR ZSTD_did_fieldSize[r14+r9*8]
	test	r8d, r8d
	sete	al
	add	rcx, rsi
	add	rax, rcx
	add	rax, r10

; 265  :     }
; 266  : 
; 267  :     /* ensure there is enough `srcSize` to fully read/decode frame header */
; 268  :     {   size_t const fhsize = ZSTD_frameHeaderSize_internal(src, srcSize, format);
; 269  :         if (srcSize < fhsize) return fhsize;

	cmp	rbx, rax
	jb	$LN47@ZSTD_getFr

; 270  :         zfhPtr->headerSize = (U32)fhsize;

	mov	DWORD PTR [r11+24], eax

; 271  :     }
; 272  : 
; 273  :     {   BYTE const fhdByte = ip[minInputSize-1];
; 274  :         size_t pos = minInputSize;
; 275  :         U32 const dictIDSizeCode = fhdByte&3;
; 276  :         U32 const checksumFlag = (fhdByte>>2)&1;
; 277  :         U32 const singleSegment = (fhdByte>>5)&1;
; 278  :         U32 const fcsID = fhdByte>>6;
; 279  :         U64 windowSize = 0;
; 280  :         U32 dictID = 0;
; 281  :         U64 frameContentSize = ZSTD_CONTENTSIZE_UNKNOWN;

	mov	r8, -1
	movzx	eax, BYTE PTR [r10+rdx-1]
	mov	r14d, eax
	mov	QWORD PTR [rsp+16], rbp
	shr	r14d, 2
	mov	ebx, eax
	mov	r9d, eax
	and	r14d, 1
	and	ebx, 3
	shr	r9d, 6
	mov	esi, eax
	mov	ebp, edi

; 282  :         RETURN_ERROR_IF((fhdByte & 0x08) != 0, frameParameter_unsupported,

	test	al, 8
	je	SHORT $LN17@ZSTD_getFr
	lea	rax, QWORD PTR [r8-13]
	jmp	$LN48@ZSTD_getFr
$LN17@ZSTD_getFr:

; 283  :                         "reserved bits, must be zero");
; 284  : 
; 285  :         if (!singleSegment) {

	and	esi, 32					; 00000020H
	jne	SHORT $LN19@ZSTD_getFr

; 286  :             BYTE const wlByte = ip[pos++];

	movzx	eax, BYTE PTR [r10+rdx]
	inc	r10

; 287  :             U32 const windowLog = (wlByte >> 3) + ZSTD_WINDOWLOG_ABSOLUTEMIN;

	mov	ecx, eax
	shr	ecx, 3
	add	ecx, 10

; 288  :             RETURN_ERROR_IF(windowLog > ZSTD_WINDOWLOG_MAX, frameParameter_windowTooLarge, "");

	cmp	ecx, 31
	jbe	SHORT $LN20@ZSTD_getFr
	mov	rax, -16
	jmp	$LN48@ZSTD_getFr
$LN20@ZSTD_getFr:

; 289  :             windowSize = (1ULL << windowLog);

	mov	edi, 1
	shl	rdi, cl

; 290  :             windowSize += (windowSize >> 3) * (wlByte&7);

	mov	rcx, rax
	mov	rax, rdi
	and	ecx, 7
	shr	rax, 3
	imul	rcx, rax
	add	rdi, rcx
$LN19@ZSTD_getFr:

; 291  :         }
; 292  :         switch(dictIDSizeCode)

	sub	ebx, 1
	je	SHORT $LN24@ZSTD_getFr
	sub	ebx, 1
	je	SHORT $LN25@ZSTD_getFr
	cmp	ebx, 1
	jne	SHORT $LN5@ZSTD_getFr

; 298  :             case 3 : dictID = MEM_readLE32(ip+pos); pos+=4; break;

	mov	ebp, DWORD PTR [r10+rdx]
	add	r10, 4
	jmp	SHORT $LN5@ZSTD_getFr
$LN25@ZSTD_getFr:

; 297  :             case 2 : dictID = MEM_readLE16(ip+pos); pos+=2; break;

	movzx	ebp, WORD PTR [r10+rdx]
	add	r10, 2
	jmp	SHORT $LN5@ZSTD_getFr
$LN24@ZSTD_getFr:

; 293  :         {
; 294  :             default: assert(0);  /* impossible */
; 295  :             case 0 : break;
; 296  :             case 1 : dictID = ip[pos]; pos++; break;

	movzx	ebp, BYTE PTR [r10+rdx]
	inc	r10
$LN5@ZSTD_getFr:

; 299  :         }
; 300  :         switch(fcsID)

	test	r9d, r9d
	je	SHORT $LN27@ZSTD_getFr
	sub	r9d, 1
	je	SHORT $LN30@ZSTD_getFr
	sub	r9d, 1
	je	SHORT $LN31@ZSTD_getFr
	cmp	r9d, 1
	jne	SHORT $LN27@ZSTD_getFr

; 306  :             case 3 : frameContentSize = MEM_readLE64(ip+pos); break;

	mov	r8, QWORD PTR [r10+rdx]
	jmp	SHORT $LN29@ZSTD_getFr
$LN31@ZSTD_getFr:

; 305  :             case 2 : frameContentSize = MEM_readLE32(ip+pos); break;

	mov	r8d, DWORD PTR [r10+rdx]
	jmp	SHORT $LN29@ZSTD_getFr
$LN30@ZSTD_getFr:

; 304  :             case 1 : frameContentSize = MEM_readLE16(ip+pos)+256; break;

	movzx	r8d, WORD PTR [r10+rdx]
	add	r8, 256					; 00000100H
	jmp	SHORT $LN29@ZSTD_getFr
$LN27@ZSTD_getFr:

; 301  :         {
; 302  :             default: assert(0);  /* impossible */
; 303  :             case 0 : if (singleSegment) frameContentSize = ip[pos]; break;

	test	esi, esi
	je	SHORT $LN29@ZSTD_getFr
	movzx	r8d, BYTE PTR [r10+rdx]
$LN29@ZSTD_getFr:

; 307  :         }
; 308  :         if (singleSegment) windowSize = frameContentSize;
; 309  : 
; 310  :         zfhPtr->frameType = ZSTD_frame;

	test	esi, esi

; 311  :         zfhPtr->frameContentSize = frameContentSize;

	mov	QWORD PTR [r11], r8

; 312  :         zfhPtr->windowSize = windowSize;
; 313  :         zfhPtr->blockSizeMax = (unsigned) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);

	mov	eax, 131072				; 00020000H

; 314  :         zfhPtr->dictID = dictID;

	mov	DWORD PTR [r11+28], ebp
	mov	rcx, r8

; 315  :         zfhPtr->checksumFlag = checksumFlag;

	mov	DWORD PTR [r11+32], r14d
	cmove	rcx, rdi
	cmp	rcx, rax
	mov	QWORD PTR [r11+8], rcx
	cmovb	eax, ecx
	mov	DWORD PTR [r11+16], eax

; 316  :     }
; 317  :     return 0;

	xor	eax, eax
$LN48@ZSTD_getFr:
	mov	rbp, QWORD PTR [rsp+16]
$LN47@ZSTD_getFr:
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]

; 318  : }

	pop	rbx
	ret	0
ZSTD_getFrameHeader_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zfhPtr$ = 8
src$ = 16
srcSize$ = 24
ZSTD_getFrameHeader PROC

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	xor	r9d, r9d
	jmp	ZSTD_getFrameHeader_advanced
ZSTD_getFrameHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zfh$1 = 32
src$ = 96
srcSize$ = 104
ZSTD_getFrameContentSize PROC

; 338  : {

$LN9:
	sub	rsp, 88					; 00000058H

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	mov	r8, rdx
	xor	r9d, r9d
	mov	rdx, rcx
	lea	rcx, QWORD PTR zfh$1[rsp]
	call	ZSTD_getFrameHeader_advanced

; 339  : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
; 340  :     if (ZSTD_isLegacy(src, srcSize)) {
; 341  :         unsigned long long const ret = ZSTD_getDecompressedSize_legacy(src, srcSize);
; 342  :         return ret == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : ret;
; 343  :     }
; 344  : #endif
; 345  :     {   ZSTD_frameHeader zfh;
; 346  :         if (ZSTD_getFrameHeader(&zfh, src, srcSize) != 0)

	test	rax, rax
	je	SHORT $LN2@ZSTD_getFr

; 347  :             return ZSTD_CONTENTSIZE_ERROR;

	mov	rax, -2

; 349  :             return 0;
; 350  :         } else {
; 351  :             return zfh.frameContentSize;
; 352  :     }   }
; 353  : }

	add	rsp, 88					; 00000058H
	ret	0
$LN2@ZSTD_getFr:

; 348  :         if (zfh.frameType == ZSTD_skippableFrame) {

	mov	rax, QWORD PTR zfh$1[rsp]
	xor	ecx, ecx
	cmp	DWORD PTR zfh$1[rsp+20], 1
	cmove	rax, rcx

; 349  :             return 0;
; 350  :         } else {
; 351  :             return zfh.frameContentSize;
; 352  :     }   }
; 353  : }

	add	rsp, 88					; 00000058H
	ret	0
ZSTD_getFrameContentSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
src$ = 8
srcSize$ = 16
readSkippableFrameSize PROC

; 357  :     size_t const skippableHeaderSize = ZSTD_SKIPPABLEHEADERSIZE;
; 358  :     U32 sizeU32;
; 359  : 
; 360  :     RETURN_ERROR_IF(srcSize < ZSTD_SKIPPABLEHEADERSIZE, srcSize_wrong, "");

	cmp	rdx, 8
	jb	SHORT $LN9@readSkippa

; 361  : 
; 362  :     sizeU32 = MEM_readLE32((BYTE const*)src + ZSTD_FRAMEIDSIZE);

	mov	ecx, DWORD PTR [rcx+4]

; 363  :     RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) < sizeU32,

	lea	eax, DWORD PTR [rcx+8]
	cmp	eax, ecx
	jae	SHORT $LN4@readSkippa
	mov	rax, -14

; 368  :         return skippableSize;
; 369  :     }
; 370  : }

	ret	0
$LN4@readSkippa:

; 364  :                     frameParameter_unsupported, "");
; 365  :     {
; 366  :         size_t const skippableSize = skippableHeaderSize + sizeU32;

	lea	rax, QWORD PTR [rcx+8]

; 367  :         RETURN_ERROR_IF(skippableSize > srcSize, srcSize_wrong, "");

	cmp	rax, rdx
	jbe	SHORT $LN1@readSkippa
$LN9@readSkippa:
	mov	rax, -72				; ffffffffffffffb8H
$LN1@readSkippa:

; 368  :         return skippableSize;
; 369  :     }
; 370  : }

	ret	0
readSkippableFrameSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\xxhash.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
state$1 = 32
dctx$ = 144
src$ = 152
headerSize$ = 160
ZSTD_decodeFrameHeader PROC

; 438  : {

	push	rbx
	sub	rsp, 128				; 00000080H
	mov	rbx, rcx

; 439  :     size_t const result = ZSTD_getFrameHeader_advanced(&(dctx->fParams), src, headerSize, dctx->format);

	add	rcx, 28784				; 00007070H
	mov	r9d, DWORD PTR [rbx+28944]
	call	ZSTD_getFrameHeader_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 440  :     if (ZSTD_isError(result)) return result;    /* invalid header */

	ja	$LN1@ZSTD_decod

; 441  :     RETURN_ERROR_IF(result>0, srcSize_wrong, "headerSize too small");

	test	rax, rax
	je	SHORT $LN3@ZSTD_decod
	mov	rax, -72				; ffffffffffffffb8H

; 451  : }

	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
$LN3@ZSTD_decod:

; 442  : #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 443  :     /* Skip the dictID check in fuzzing mode, because it makes the search
; 444  :      * harder.
; 445  :      */
; 446  :     RETURN_ERROR_IF(dctx->fParams.dictID && (dctx->dictID != dctx->fParams.dictID),

	mov	eax, DWORD PTR [rbx+28812]
	test	eax, eax
	je	SHORT $LN5@ZSTD_decod
	cmp	DWORD PTR [rbx+29032], eax
	je	SHORT $LN5@ZSTD_decod
	mov	rax, -32				; ffffffffffffffe0H

; 451  : }

	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
$LN5@ZSTD_decod:

; 447  :                     dictionary_wrong, "");
; 448  : #endif
; 449  :     if (dctx->fParams.checksumFlag) XXH64_reset(&dctx->xxhState, 0);

	cmp	DWORD PTR [rbx+28816], 0
	je	$LN7@ZSTD_decod
; File E:\dev\pyzstd\lib\common\xxhash.c

; 570  :     memset(&state, 0, sizeof(state)-8);   /* do not write into reserved, for future removal */

	xor	ecx, ecx

; 571  :     state.v1 = seed + PRIME64_1 + PRIME64_2;

	mov	rax, 6983438078262162902		; 60ea27eeadc0b5d6H
	mov	QWORD PTR state$1[rsp+8], rax
	xorps	xmm2, xmm2

; 572  :     state.v2 = seed + PRIME64_2;

	mov	rax, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	QWORD PTR state$1[rsp], rcx

; 573  :     state.v3 = seed + 0;
; 574  :     state.v4 = seed - PRIME64_1;
; 575  :     memcpy(statePtr, &state, sizeof(state));

	movaps	xmm0, XMMWORD PTR state$1[rsp]
	xorps	xmm3, xmm3
	movups	XMMWORD PTR [rbx+28848], xmm0
	mov	QWORD PTR state$1[rsp+16], rax
	mov	rax, 7046029288634856825		; 61c8864e7a143579H
	mov	QWORD PTR state$1[rsp+24], rcx
	movaps	xmm1, XMMWORD PTR state$1[rsp+16]
	movups	XMMWORD PTR [rbx+28864], xmm1
	mov	QWORD PTR state$1[rsp+32], rax
	mov	QWORD PTR state$1[rsp+40], rcx
	movaps	xmm0, XMMWORD PTR state$1[rsp+32]
	movups	XMMWORD PTR [rbx+28880], xmm0
	movsd	xmm0, QWORD PTR state$1[rsp+80]
	movups	XMMWORD PTR [rbx+28896], xmm2
	movups	XMMWORD PTR [rbx+28912], xmm3
	movsd	QWORD PTR [rbx+28928], xmm0
$LN7@ZSTD_decod:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 450  :     return 0;

	xor	eax, eax
$LN1@ZSTD_decod:

; 451  : }

	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
ZSTD_decodeFrameHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 8
ret$ = 16
ZSTD_errorFrameSizeInfo PROC

; 455  :     ZSTD_frameSizeInfo frameSizeInfo;
; 456  :     frameSizeInfo.compressedSize = ret;

	mov	QWORD PTR [rcx], rdx

; 457  :     frameSizeInfo.decompressedBound = ZSTD_CONTENTSIZE_ERROR;
; 458  :     return frameSizeInfo;

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], -2

; 459  : }

	ret	0
ZSTD_errorFrameSizeInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
frameSizeInfo$ = 32
zfh$2 = 48
$T3 = 112
src$ = 120
srcSize$ = 128
ZSTD_findFrameSizeInfo PROC

; 462  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 96					; 00000060H

; 463  :     ZSTD_frameSizeInfo frameSizeInfo;
; 464  :     memset(&frameSizeInfo, 0, sizeof(ZSTD_frameSizeInfo));

	xor	esi, esi
	mov	rdi, r8
	mov	QWORD PTR frameSizeInfo$[rsp], rsi
	mov	r14, rdx
	mov	QWORD PTR frameSizeInfo$[rsp+8], rsi
	mov	rbx, rcx

; 465  : 
; 466  : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
; 467  :     if (ZSTD_isLegacy(src, srcSize))
; 468  :         return ZSTD_findFrameSizeInfoLegacy(src, srcSize);
; 469  : #endif
; 470  : 
; 471  :     if ((srcSize >= ZSTD_SKIPPABLEHEADERSIZE)
; 472  :         && (MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {

	cmp	r8, 8
	jb	SHORT $LN4@ZSTD_findF
	mov	eax, DWORD PTR [rdx]
	and	eax, -16				; fffffff0H
	cmp	eax, 407710288				; 184d2a50H
	jne	SHORT $LN4@ZSTD_findF

; 362  :     sizeU32 = MEM_readLE32((BYTE const*)src + ZSTD_FRAMEIDSIZE);

	mov	ecx, DWORD PTR [rdx+4]

; 363  :     RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) < sizeU32,

	lea	eax, DWORD PTR [rcx+8]
	cmp	eax, ecx
	jae	SHORT $LN19@ZSTD_findF
	mov	rcx, -14

; 473  :         frameSizeInfo.compressedSize = readSkippableFrameSize(src, srcSize);
; 474  :         assert(ZSTD_isError(frameSizeInfo.compressedSize) ||
; 475  :                frameSizeInfo.compressedSize <= srcSize);
; 476  :         return frameSizeInfo;

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rsi
	jmp	$LN59@ZSTD_findF
$LN19@ZSTD_findF:

; 366  :         size_t const skippableSize = skippableHeaderSize + sizeU32;

	add	rcx, 8

; 367  :         RETURN_ERROR_IF(skippableSize > srcSize, srcSize_wrong, "");

	mov	rax, -72				; ffffffffffffffb8H
	cmp	rcx, rdi
	cmova	rcx, rax

; 473  :         frameSizeInfo.compressedSize = readSkippableFrameSize(src, srcSize);
; 474  :         assert(ZSTD_isError(frameSizeInfo.compressedSize) ||
; 475  :                frameSizeInfo.compressedSize <= srcSize);
; 476  :         return frameSizeInfo;

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rsi
	jmp	$LN59@ZSTD_findF
$LN4@ZSTD_findF:

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	xor	r9d, r9d
	lea	rcx, QWORD PTR zfh$2[rsp]
	call	ZSTD_getFrameHeader_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 486  :             if (ZSTD_isError(ret))

	ja	$LN51@ZSTD_findF

; 487  :                 return ZSTD_errorFrameSizeInfo(ret);
; 488  :             if (ret > 0)

	test	rax, rax
	jne	$LN57@ZSTD_findF

; 489  :                 return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));
; 490  :         }
; 491  : 
; 492  :         ip += zfh.headerSize;

	mov	eax, DWORD PTR zfh$2[rsp+24]
	add	rdx, rax

; 493  :         remainingSize -= zfh.headerSize;

	sub	rdi, rax
$LL2@ZSTD_findF:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 59   :     RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, "");

	cmp	rdi, 3
	jb	$LN57@ZSTD_findF
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	eax, WORD PTR [rdx]
	movzx	ecx, BYTE PTR [rdx+2]
	shl	ecx, 16
	add	ecx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 63   :         bpPtr->lastBlock = cBlockHeader & 1;

	mov	r8d, ecx

; 64   :         bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);

	mov	eax, ecx
	and	r8d, 1
	and	al, 6
	cmp	al, 2

; 65   :         bpPtr->origSize = cSize;   /* only useful for RLE */
; 66   :         if (bpPtr->blockType == bt_rle) return 1;

	jne	SHORT $LN35@ZSTD_findF
	mov	ecx, 1
	jmp	SHORT $LN56@ZSTD_findF
$LN35@ZSTD_findF:

; 67   :         RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, "");

	mov	eax, ecx
	and	eax, 6
	cmp	al, 6
	je	SHORT $LN58@ZSTD_findF

; 60   : 
; 61   :     {   U32 const cBlockHeader = MEM_readLE24(src);
; 62   :         U32 const cSize = cBlockHeader >> 3;

	shr	rcx, 3
$LN56@ZSTD_findF:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 502  :             if (ZSTD_blockHeaderSize + cBlockSize > remainingSize)

	lea	rax, QWORD PTR [rcx+3]
	cmp	rax, rdi
	ja	SHORT $LN57@ZSTD_findF

; 503  :                 return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));
; 504  : 
; 505  :             ip += ZSTD_blockHeaderSize + cBlockSize;

	add	rdx, 3

; 506  :             remainingSize -= ZSTD_blockHeaderSize + cBlockSize;

	mov	rax, -3
	sub	rax, rcx
	add	rdx, rcx
	add	rdi, rax

; 507  :             nbBlocks++;

	inc	rsi

; 508  : 
; 509  :             if (blockProperties.lastBlock) break;

	test	r8d, r8d
	je	SHORT $LL2@ZSTD_findF

; 510  :         }
; 511  : 
; 512  :         /* Final frame content checksum */
; 513  :         if (zfh.checksumFlag) {

	cmp	DWORD PTR zfh$2[rsp+32], 0
	je	SHORT $LN11@ZSTD_findF

; 514  :             if (remainingSize < 4)

	cmp	rdi, 4
	jb	SHORT $LN57@ZSTD_findF

; 515  :                 return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));
; 516  :             ip += 4;

	add	rdx, 4
$LN11@ZSTD_findF:

; 517  :         }
; 518  : 
; 519  :         frameSizeInfo.compressedSize = ip - ipstart;
; 520  :         frameSizeInfo.decompressedBound = (zfh.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN)

	mov	rax, QWORD PTR zfh$2[rsp]
	sub	rdx, r14
	mov	QWORD PTR frameSizeInfo$[rsp], rdx
	cmp	rax, -1
	jne	SHORT $LN60@ZSTD_findF
	mov	eax, DWORD PTR zfh$2[rsp+16]
	imul	rax, rsi
$LN60@ZSTD_findF:

; 521  :                                         ? zfh.frameContentSize
; 522  :                                         : nbBlocks * zfh.blockSizeMax;
; 523  :         return frameSizeInfo;

	mov	QWORD PTR frameSizeInfo$[rsp+8], rax
	movups	xmm0, XMMWORD PTR frameSizeInfo$[rsp]
	movups	XMMWORD PTR [rbx], xmm0
	jmp	SHORT $LN59@ZSTD_findF
$LN58@ZSTD_findF:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 67   :         RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, "");

	mov	rax, -20
	jmp	SHORT $LN51@ZSTD_findF
$LN57@ZSTD_findF:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 525  : }

	mov	rax, -72				; ffffffffffffffb8H
$LN51@ZSTD_findF:
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], -2
$LN59@ZSTD_findF:
	mov	rsi, QWORD PTR [rsp+120]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	r14
	ret	0
ZSTD_findFrameSizeInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 32
src$ = 64
srcSize$ = 72
ZSTD_findFrameCompressedSize PROC

; 533  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 534  :     ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);

	mov	r8, rdx
	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	ZSTD_findFrameSizeInfo

; 535  :     return frameSizeInfo.compressedSize;

	mov	rax, QWORD PTR [rax]

; 536  : }

	add	rsp, 56					; 00000038H
	ret	0
ZSTD_findFrameCompressedSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
src$ = 64
srcSize$ = 72
ZSTD_copyRawBlock PROC

; 580  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rax, r8

; 581  :     DEBUGLOG(5, "ZSTD_copyRawBlock");
; 582  :     if (dst == NULL) {

	test	rcx, rcx
	jne	SHORT $LN3@ZSTD_copyR

; 583  :         if (srcSize == 0) return 0;

	neg	rbx
	sbb	rax, rax
	and	rax, -74				; ffffffffffffffb6H

; 589  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@ZSTD_copyR:

; 584  :         RETURN_ERROR(dstBuffer_null, "");
; 585  :     }
; 586  :     RETURN_ERROR_IF(srcSize > dstCapacity, dstSize_tooSmall, "");

	cmp	rbx, rdx
	jbe	SHORT $LN8@ZSTD_copyR
	mov	rax, -70				; ffffffffffffffbaH

; 589  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@ZSTD_copyR:

; 587  :     memcpy(dst, src, srcSize);

	mov	r8, rbx
	mov	rdx, rax
	call	memcpy

; 588  :     return srcSize;

	mov	rax, rbx

; 589  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_copyRawBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
b$ = 64
regenSize$ = 72
ZSTD_setRleBlock PROC

; 594  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r9

; 595  :     if (dst == NULL) {

	test	rcx, rcx
	jne	SHORT $LN3@ZSTD_setRl

; 596  :         if (regenSize == 0) return 0;

	neg	rbx
	sbb	rax, rax
	and	rax, -74				; ffffffffffffffb6H

; 602  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@ZSTD_setRl:

; 597  :         RETURN_ERROR(dstBuffer_null, "");
; 598  :     }
; 599  :     RETURN_ERROR_IF(regenSize > dstCapacity, dstSize_tooSmall, "");

	cmp	rbx, rdx
	jbe	SHORT $LN8@ZSTD_setRl
	mov	rax, -70				; ffffffffffffffbaH

; 602  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@ZSTD_setRl:

; 600  :     memset(dst, b, regenSize);

	movzx	edx, r8b
	mov	r8, rbx
	call	memset

; 601  :     return regenSize;

	mov	rax, rbx

; 602  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_setRleBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 112
dst$ = 120
dstCapacity$ = 128
srcPtr$ = 136
srcSizePtr$ = 144
ZSTD_decompressFrame PROC

; 612  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 613  :     const BYTE* ip = (const BYTE*)(*srcPtr);

	mov	rbp, QWORD PTR [r9]

; 614  :     BYTE* const ostart = (BYTE* const)dst;
; 615  :     BYTE* const oend = dstCapacity != 0 ? ostart + dstCapacity : ostart;
; 616  :     BYTE* op = ostart;

	lea	r12, QWORD PTR [rdx+r8]

; 617  :     size_t remainingSrcSize = *srcSizePtr;

	mov	r14, QWORD PTR srcSizePtr$[rsp]
	test	r8, r8

; 618  : 
; 619  :     DEBUGLOG(4, "ZSTD_decompressFrame (srcSize:%i)", (int)*srcSizePtr);
; 620  : 
; 621  :     /* check */
; 622  :     RETURN_ERROR_IF(

	mov	r8d, DWORD PTR [rcx+28944]
	mov	r9d, 5
	cmove	r12, rdx
	mov	r15, rcx
	test	r8d, r8d
	mov	eax, r9d
	mov	r14, QWORD PTR [r14]
	mov	ecx, 9
	cmove	eax, ecx
	mov	rdi, rdx
	cmp	r14, rax
	jb	$LN375@ZSTD_decom

; 623  :         remainingSrcSize < ZSTD_FRAMEHEADERSIZE_MIN(dctx->format)+ZSTD_blockHeaderSize,
; 624  :         srcSize_wrong, "");
; 625  : 
; 626  :     /* Frame Header */
; 627  :     {   size_t const frameHeaderSize = ZSTD_frameHeaderSize_internal(

	test	r8d, r8d
	mov	edx, 1
	mov	rcx, rbp
	cmove	edx, r9d
	call	ZSTD_frameHeaderSize_internal
	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 629  :         if (ZSTD_isError(frameHeaderSize)) return frameHeaderSize;

	ja	$LN1@ZSTD_decom

; 630  :         RETURN_ERROR_IF(remainingSrcSize < frameHeaderSize+ZSTD_blockHeaderSize,

	add	rax, 3
	cmp	r14, rax
	jb	$LN375@ZSTD_decom

; 632  :         FORWARD_IF_ERROR( ZSTD_decodeFrameHeader(dctx, ip, frameHeaderSize) , "");

	mov	r8, rbx
	mov	rdx, rbp
	mov	rcx, r15
	call	ZSTD_decodeFrameHeader
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 632  :         FORWARD_IF_ERROR( ZSTD_decodeFrameHeader(dctx, ip, frameHeaderSize) , "");

	ja	$LN1@ZSTD_decom

; 633  :         ip += frameHeaderSize; remainingSrcSize -= frameHeaderSize;

	add	rbp, rbx
	sub	r14, rbx
	npad	3
$LL5@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 59   :     RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, "");

	cmp	r14, 3
	jb	$LN375@ZSTD_decom
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	eax, WORD PTR [rbp]
	movzx	ecx, BYTE PTR [rbp+2]
	shl	ecx, 16
	add	ecx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 62   :         U32 const cSize = cBlockHeader >> 3;

	mov	eax, ecx

; 63   :         bpPtr->lastBlock = cBlockHeader & 1;

	mov	r13d, ecx

; 64   :         bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);

	shr	ecx, 1
	and	r13d, 1
	and	ecx, 3
	shr	eax, 3

; 65   :         bpPtr->origSize = cSize;   /* only useful for RLE */

	cmp	ecx, 1

; 66   :         if (bpPtr->blockType == bt_rle) return 1;

	jne	SHORT $LN49@ZSTD_decom
	mov	esi, ecx
	jmp	SHORT $LN391@ZSTD_decom
$LN49@ZSTD_decom:

; 67   :         RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, "");

	cmp	ecx, 3
	je	$LN388@ZSTD_decom

; 68   :         return cSize;

	mov	esi, eax
$LN391@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 643  :         ip += ZSTD_blockHeaderSize;

	add	rbp, 3
	mov	ebx, eax

; 644  :         remainingSrcSize -= ZSTD_blockHeaderSize;

	sub	r14, 3

; 645  :         RETURN_ERROR_IF(cBlockSize > remainingSrcSize, srcSize_wrong, "");

	cmp	rsi, r14
	ja	$LN375@ZSTD_decom

; 646  : 
; 647  :         switch(blockProperties.blockType)

	test	ecx, ecx
	je	SHORT $LN23@ZSTD_decom
	sub	ecx, 1
	je	SHORT $LN24@ZSTD_decom
	cmp	ecx, 1
	jne	$LN388@ZSTD_decom

; 648  :         {
; 649  :         case bt_compressed:
; 650  :             decodedSize = ZSTD_decompressBlock_internal(dctx, op, oend-op, ip, cBlockSize, /* frame */ 1);

	mov	r8, r12
	mov	QWORD PTR [rsp+32], rsi
	sub	r8, rdi
	mov	r9, rbp
	mov	rdx, rdi
	mov	rcx, r15
	call	ZSTD_decompressBlock_internal
	mov	rbx, rax

; 651  :             break;

	jmp	SHORT $LN10@ZSTD_decom
$LN24@ZSTD_decom:

; 595  :     if (dst == NULL) {

	test	rdi, rdi
	jne	SHORT $LN69@ZSTD_decom

; 596  :         if (regenSize == 0) return 0;

	test	rbx, rbx
	jne	$LN70@ZSTD_decom
	jmp	SHORT $LN381@ZSTD_decom
$LN69@ZSTD_decom:

; 654  :             break;
; 655  :         case bt_rle :
; 656  :             decodedSize = ZSTD_setRleBlock(op, oend-op, *ip, blockProperties.origSize);

	mov	rax, r12
	sub	rax, rdi

; 599  :     RETURN_ERROR_IF(regenSize > dstCapacity, dstSize_tooSmall, "");

	cmp	rbx, rax
	ja	$LN385@ZSTD_decom

; 600  :     memset(dst, b, regenSize);

	movzx	edx, BYTE PTR [rbp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memset

; 657  :             break;

	jmp	SHORT $LN10@ZSTD_decom
$LN23@ZSTD_decom:

; 582  :     if (dst == NULL) {

	test	rdi, rdi
	jne	SHORT $LN59@ZSTD_decom

; 583  :         if (srcSize == 0) return 0;

	test	rsi, rsi
	jne	$LN70@ZSTD_decom
	xor	ebx, ebx
	jmp	SHORT $LN381@ZSTD_decom
$LN59@ZSTD_decom:

; 652  :         case bt_raw :
; 653  :             decodedSize = ZSTD_copyRawBlock(op, oend-op, ip, cBlockSize);

	mov	rax, r12
	sub	rax, rdi

; 586  :     RETURN_ERROR_IF(srcSize > dstCapacity, dstSize_tooSmall, "");

	cmp	rsi, rax
	ja	$LN385@ZSTD_decom

; 587  :     memcpy(dst, src, srcSize);

	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, rdi
	call	memcpy

; 588  :     return srcSize;

	mov	rbx, rsi
$LN10@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 663  :         if (ZSTD_isError(decodedSize)) return decodedSize;

	ja	$LN376@ZSTD_decom
$LN381@ZSTD_decom:

; 664  :         if (dctx->fParams.checksumFlag)

	cmp	DWORD PTR [r15+28816], 0
	je	SHORT $LN386@ZSTD_decom

; 665  :             XXH64_update(&dctx->xxhState, op, decodedSize);

	lea	rcx, QWORD PTR [r15+28848]
	mov	r8, rbx
	mov	rdx, rdi
	call	XXH64_update
$LN386@ZSTD_decom:

; 666  :         if (decodedSize != 0)
; 667  :             op += decodedSize;
; 668  :         assert(ip != NULL);
; 669  :         ip += cBlockSize;

	test	rbx, rbx
	lea	rax, QWORD PTR [rbx+rdi]
	cmove	rax, rdi
	add	rbp, rsi

; 670  :         remainingSrcSize -= cBlockSize;

	sub	r14, rsi
	mov	rdi, rax

; 671  :         if (blockProperties.lastBlock) break;

	test	r13d, r13d
	je	$LL5@ZSTD_decom

; 672  :     }
; 673  : 
; 674  :     if (dctx->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN) {

	mov	rcx, QWORD PTR [r15+28784]
	mov	rbx, QWORD PTR dst$[rsp]
	cmp	rcx, -1
	je	SHORT $LN32@ZSTD_decom

; 675  :         RETURN_ERROR_IF((U64)(op-ostart) != dctx->fParams.frameContentSize,

	sub	rax, rbx
	cmp	rax, rcx
	je	SHORT $LN32@ZSTD_decom
$LN388@ZSTD_decom:

; 692  : }

	mov	rax, -20
	jmp	SHORT $LN1@ZSTD_decom
$LN70@ZSTD_decom:

; 663  :         if (ZSTD_isError(decodedSize)) return decodedSize;

	mov	rbx, -74				; ffffffffffffffb6H
	mov	rax, rbx
	jmp	SHORT $LN1@ZSTD_decom
$LN32@ZSTD_decom:

; 676  :                         corruption_detected, "");
; 677  :     }
; 678  :     if (dctx->fParams.checksumFlag) { /* Frame content checksum verification */

	cmp	DWORD PTR [r15+28816], 0
	je	SHORT $LN34@ZSTD_decom

; 680  :         U32 checkRead;
; 681  :         RETURN_ERROR_IF(remainingSrcSize<4, checksum_wrong, "");

	cmp	r14, 4
	jb	SHORT $LN387@ZSTD_decom

; 679  :         U32 const checkCalc = (U32)XXH64_digest(&dctx->xxhState);

	lea	rcx, QWORD PTR [r15+28848]
	call	XXH64_digest

; 682  :         checkRead = MEM_readLE32(ip);
; 683  :         RETURN_ERROR_IF(checkRead != checkCalc, checksum_wrong, "");

	cmp	DWORD PTR [rbp], eax
	jne	SHORT $LN387@ZSTD_decom

; 684  :         ip += 4;

	add	rbp, 4

; 685  :         remainingSrcSize -= 4;

	sub	r14, 4
$LN34@ZSTD_decom:

; 686  :     }
; 687  : 
; 688  :     /* Allow caller to get size read */
; 689  :     *srcPtr = ip;

	mov	rax, QWORD PTR srcPtr$[rsp]

; 690  :     *srcSizePtr = remainingSrcSize;
; 691  :     return op-ostart;

	sub	rdi, rbx
	mov	QWORD PTR [rax], rbp
	mov	rax, QWORD PTR srcSizePtr$[rsp]
	mov	QWORD PTR [rax], r14
	mov	rax, rdi
	jmp	SHORT $LN1@ZSTD_decom
$LN387@ZSTD_decom:

; 682  :         checkRead = MEM_readLE32(ip);
; 683  :         RETURN_ERROR_IF(checkRead != checkCalc, checksum_wrong, "");

	mov	rax, -22
	jmp	SHORT $LN1@ZSTD_decom
$LN385@ZSTD_decom:

; 663  :         if (ZSTD_isError(decodedSize)) return decodedSize;

	mov	rbx, -70				; ffffffffffffffbaH
$LN376@ZSTD_decom:
	mov	rax, rbx
	jmp	SHORT $LN1@ZSTD_decom
$LN375@ZSTD_decom:

; 692  : }

	mov	rax, -72				; ffffffffffffffb8H
$LN1@ZSTD_decom:
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_decompressFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 96
dst$ = 104
dstCapacity$ = 112
src$ = 120
srcSize$ = 128
dict$dead$ = 136
dictSize$dead$ = 144
ddict$ = 152
ZSTD_decompressMultiFrame PROC

; 699  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 700  :     void* const dststart = dst;
; 701  :     int moreThan1Frame = 0;
; 702  : 
; 703  :     DEBUGLOG(5, "ZSTD_decompressMultiFrame");
; 704  :     assert(dict==NULL || ddict==NULL);  /* either dict or ddict set, not both */
; 705  : 
; 706  :     if (ddict) {

	mov	r14, QWORD PTR ddict$[rsp]
	mov	rsi, rdx
	xor	edx, edx
	mov	r15, r8
	mov	rbx, rcx
	mov	ebp, edx
	mov	edi, edx
	mov	r13, rsi
	mov	r12d, edx
	test	r14, r14
	je	SHORT $LN91@ZSTD_decom

; 707  :         dict = ZSTD_DDict_dictContent(ddict);

	mov	rdi, QWORD PTR [r14+8]

; 708  :         dictSize = ZSTD_DDict_dictSize(ddict);

	mov	rbp, QWORD PTR [r14+16]
$LN91@ZSTD_decom:

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	mov	r8d, DWORD PTR [rcx+28944]
	mov	eax, 1

; 709  :     }
; 710  : 
; 711  :     while (srcSize >= ZSTD_startingInputLength(dctx->format)) {

	mov	rcx, QWORD PTR srcSize$[rsp]

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	test	r8d, r8d
	mov	r10d, 5
	cmove	eax, r10d

; 709  :     }
; 710  : 
; 711  :     while (srcSize >= ZSTD_startingInputLength(dctx->format)) {

	cmp	rcx, rax
	jb	$LN3@ZSTD_decom
	npad	11
$LL2@ZSTD_decom:

; 712  : 
; 713  : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
; 714  :         if (ZSTD_isLegacy(src, srcSize)) {
; 715  :             size_t decodedSize;
; 716  :             size_t const frameSize = ZSTD_findFrameCompressedSizeLegacy(src, srcSize);
; 717  :             if (ZSTD_isError(frameSize)) return frameSize;
; 718  :             RETURN_ERROR_IF(dctx->staticSize, memory_allocation,
; 719  :                 "legacy support is not compatible with static dctx");
; 720  : 
; 721  :             decodedSize = ZSTD_decompressLegacy(dst, dstCapacity, src, frameSize, dict, dictSize);
; 722  :             if (ZSTD_isError(decodedSize)) return decodedSize;
; 723  : 
; 724  :             assert(decodedSize <=- dstCapacity);
; 725  :             dst = (BYTE*)dst + decodedSize;
; 726  :             dstCapacity -= decodedSize;
; 727  : 
; 728  :             src = (const BYTE*)src + frameSize;
; 729  :             srcSize -= frameSize;
; 730  : 
; 731  :             continue;
; 732  :         }
; 733  : #endif
; 734  : 
; 735  :         {   U32 const magicNumber = MEM_readLE32(src);
; 736  :             DEBUGLOG(4, "reading magic number %08X (expecting %08X)",
; 737  :                         (unsigned)magicNumber, ZSTD_MAGICNUMBER);
; 738  :             if ((magicNumber & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {

	mov	eax, DWORD PTR [r9]
	and	eax, -16				; fffffff0H
	cmp	eax, 407710288				; 184d2a50H
	jne	SHORT $LN14@ZSTD_decom

; 360  :     RETURN_ERROR_IF(srcSize < ZSTD_SKIPPABLEHEADERSIZE, srcSize_wrong, "");

	cmp	rcx, 8
	jb	$LN104@ZSTD_decom

; 361  : 
; 362  :     sizeU32 = MEM_readLE32((BYTE const*)src + ZSTD_FRAMEIDSIZE);

	mov	edx, DWORD PTR [r9+4]

; 363  :     RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) < sizeU32,

	lea	eax, DWORD PTR [rdx+8]
	cmp	eax, edx
	jb	$LN105@ZSTD_decom

; 364  :                     frameParameter_unsupported, "");
; 365  :     {
; 366  :         size_t const skippableSize = skippableHeaderSize + sizeU32;

	lea	rax, QWORD PTR [rdx+8]

; 367  :         RETURN_ERROR_IF(skippableSize > srcSize, srcSize_wrong, "");

	cmp	rax, rcx
	ja	$LN104@ZSTD_decom

; 739  :                 size_t const skippableSize = readSkippableFrameSize(src, srcSize);
; 740  :                 FORWARD_IF_ERROR(skippableSize, "readSkippableFrameSize failed");
; 741  :                 assert(skippableSize <= srcSize);
; 742  : 
; 743  :                 src = (const BYTE *)src + skippableSize;
; 744  :                 srcSize -= skippableSize;

	add	r9, rax
	sub	rcx, rax
	mov	QWORD PTR src$[rsp], r9
	mov	QWORD PTR srcSize$[rsp], rcx

; 745  :                 continue;

	jmp	$LN97@ZSTD_decom
$LN14@ZSTD_decom:

; 746  :         }   }
; 747  : 
; 748  :         if (ddict) {

	test	r14, r14
	je	SHORT $LN12@ZSTD_decom

; 750  :             FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(dctx, ddict), "");

	mov	rdx, r14
	mov	rcx, rbx
	call	ZSTD_decompressBegin_usingDDict
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 750  :             FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(dctx, ddict), "");

	ja	$LN1@ZSTD_decom

; 751  :         } else {

	mov	rcx, QWORD PTR [rbx+28744]
	jmp	$LN11@ZSTD_decom
$LN12@ZSTD_decom:

; 1168 :     dctx->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */

	lea	rcx, QWORD PTR [rbx+10296]
	mov	QWORD PTR [rbx+28744], rdx
	mov	QWORD PTR [rbx+28752], rdx

; 1174 :     dctx->LLTptr = dctx->entropy.LLTable;

	lea	r9, QWORD PTR [rbx+32]
	mov	QWORD PTR [rbx+28760], rdx

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	test	r8d, r8d

; 1167 :     dctx->dictEnd = NULL;

	mov	QWORD PTR [rbx+28768], rdx

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	mov	eax, 1

; 1168 :     dctx->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */

	mov	DWORD PTR [rcx], 201326604		; 0c00000cH

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	cmove	rax, r10

; 1161 :     dctx->expected = ZSTD_startingInputLength(dctx->format);  /* dctx->format must be properly set */

	mov	QWORD PTR [rbx+28776], rax

; 1169 :     dctx->litEntropy = dctx->fseEntropy = 0;
; 1170 :     dctx->dictID = 0;
; 1171 :     dctx->bType = bt_reserved;

	mov	QWORD PTR [rbx+28832], 3
	mov	QWORD PTR [rbx+28824], rdx
	mov	QWORD PTR [rbx+28840], 0
	mov	DWORD PTR [rbx+29032], edx

; 1172 :     ZSTD_STATIC_ASSERT(sizeof(dctx->entropy.rep) == sizeof(repStartValue));
; 1173 :     memcpy(dctx->entropy.rep, repStartValue, sizeof(repStartValue));  /* initial repcodes */

	movsd	xmm0, QWORD PTR repStartValue
	movsd	QWORD PTR [rbx+26684], xmm0
	mov	eax, DWORD PTR repStartValue+8
	mov	DWORD PTR [rbx+26692], eax

; 1175 :     dctx->MLTptr = dctx->entropy.MLTable;

	lea	rax, QWORD PTR [rbx+6192]
	mov	QWORD PTR [rbx+8], rax

; 1176 :     dctx->OFTptr = dctx->entropy.OFTable;

	lea	rax, QWORD PTR [rbx+4136]

; 1177 :     dctx->HUFptr = dctx->entropy.hufTable;

	mov	QWORD PTR [rbx+24], rcx
	mov	rcx, rdx
	mov	QWORD PTR [rbx+16], rax
	mov	QWORD PTR [rbx], r9

; 1184 :     if (dict && dictSize)

	test	rdi, rdi
	je	$LN11@ZSTD_decom
	test	rbp, rbp
	je	$LN11@ZSTD_decom

; 1139 :     if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);

	cmp	rbp, 8
	jae	SHORT $LN61@ZSTD_decom

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	QWORD PTR [rbx+28760], rdi

; 1043 :     dctx->prefixStart = dict;

	mov	QWORD PTR [rbx+28752], rdi

; 1139 :     if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);

	jmp	SHORT $LN108@ZSTD_decom
$LN61@ZSTD_decom:

; 1140 :     {   U32 const magic = MEM_readLE32(dict);
; 1141 :         if (magic != ZSTD_MAGIC_DICTIONARY) {

	cmp	DWORD PTR [rdi], -332356553		; ec30a437H
	je	SHORT $LN62@ZSTD_decom

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	QWORD PTR [rbx+28760], rdi

; 1043 :     dctx->prefixStart = dict;

	mov	QWORD PTR [rbx+28752], rdi

; 1142 :             return ZSTD_refDictContent(dctx, dict, dictSize);   /* pure content mode */

	jmp	SHORT $LN108@ZSTD_decom
$LN62@ZSTD_decom:

; 1143 :     }   }
; 1144 :     dctx->dictID = MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);

	mov	eax, DWORD PTR [rdi+4]

; 1145 : 
; 1146 :     /* load entropy tables */
; 1147 :     {   size_t const eSize = ZSTD_loadDEntropy(&dctx->entropy, dict, dictSize);

	mov	r8, rbp
	mov	rdx, rdi
	mov	DWORD PTR [rbx+29032], eax
	mov	rcx, r9
	call	ZSTD_loadDEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1148 :         RETURN_ERROR_IF(ZSTD_isError(eSize), dictionary_corrupted, "");

	ja	$LN94@ZSTD_decom

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rcx, QWORD PTR [rbx+28752]

; 1149 :         dict = (const char*)dict + eSize;

	lea	rdx, QWORD PTR [rax+rdi]

; 1041 :     dctx->dictEnd = dctx->previousDstEnd;

	mov	rax, QWORD PTR [rbx+28744]

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	sub	rcx, rax

; 1152 :     dctx->litEntropy = dctx->fseEntropy = 1;

	mov	DWORD PTR [rbx+28844], 1

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	add	rcx, rdx

; 1152 :     dctx->litEntropy = dctx->fseEntropy = 1;

	mov	DWORD PTR [rbx+28840], 1

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	QWORD PTR [rbx+28760], rcx
	mov	QWORD PTR [rbx+28768], rax

; 1043 :     dctx->prefixStart = dict;

	mov	QWORD PTR [rbx+28752], rdx
$LN108@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1414 :     if (dst != dctx->previousDstEnd) {   /* not contiguous */

	lea	rcx, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx+28744], rcx
$LN11@ZSTD_decom:
	cmp	rsi, rcx
	je	SHORT $LN79@ZSTD_decom

; 1415 :         dctx->dictEnd = dctx->previousDstEnd;
; 1416 :         dctx->virtualStart = (const char*)dst - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rax, QWORD PTR [rbx+28752]
	sub	rax, rcx
	mov	QWORD PTR [rbx+28768], rcx
	add	rax, rsi

; 1417 :         dctx->prefixStart = dst;

	mov	QWORD PTR [rbx+28752], rsi
	mov	QWORD PTR [rbx+28760], rax

; 1418 :         dctx->previousDstEnd = dst;

	mov	QWORD PTR [rbx+28744], rsi
$LN79@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 758  :         {   const size_t res = ZSTD_decompressFrame(dctx, dst, dstCapacity,

	lea	rax, QWORD PTR srcSize$[rsp]
	mov	r8, r15
	lea	r9, QWORD PTR src$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rsi
	mov	rcx, rbx
	call	ZSTD_decompressFrame
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H

; 58   : ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }

	ja	SHORT $LN84@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 775  :             if (res != 0)

	test	rax, rax
	je	SHORT $LN26@ZSTD_decom

; 776  :                 dst = (BYTE*)dst + res;

	add	rsi, rax
$LN26@ZSTD_decom:

; 777  :             dstCapacity -= res;
; 778  :         }
; 779  :         moreThan1Frame = 1;

	mov	r8d, DWORD PTR [rbx+28944]
	sub	r15, rax
	mov	rcx, QWORD PTR srcSize$[rsp]
	mov	r12d, 1
	mov	r9, QWORD PTR src$[rsp]
	mov	r10d, 5
$LN97@ZSTD_decom:

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	test	r8d, r8d
	mov	eax, 1
	cmove	rax, r10

; 709  :     }
; 710  : 
; 711  :     while (srcSize >= ZSTD_startingInputLength(dctx->format)) {

	cmp	rcx, rax
	jb	SHORT $LN3@ZSTD_decom
	xor	edx, edx
	jmp	$LL2@ZSTD_decom
$LN105@ZSTD_decom:

; 363  :     RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) < sizeU32,

	mov	rax, -14
	jmp	SHORT $LN1@ZSTD_decom
$LN104@ZSTD_decom:

; 785  : }

	mov	rax, -72				; ffffffffffffffb8H
	jmp	SHORT $LN1@ZSTD_decom
$LN94@ZSTD_decom:

; 752  :             /* this will initialize correctly with no dict if dict == NULL, so
; 753  :              * use this in all cases but ddict */
; 754  :             FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDict(dctx, dict, dictSize), "");

	mov	rax, -30
	jmp	SHORT $LN1@ZSTD_decom
$LN84@ZSTD_decom:

; 759  :                                                     &src, &srcSize);
; 760  :             RETURN_ERROR_IF(

	cmp	eax, -10
	jne	SHORT $LN1@ZSTD_decom
	cmp	r12d, 1
	je	SHORT $LN104@ZSTD_decom

; 761  :                 (ZSTD_getErrorCode(res) == ZSTD_error_prefix_unknown)
; 762  :              && (moreThan1Frame==1),
; 763  :                 srcSize_wrong,
; 764  :                 "at least one frame successfully completed, but following "
; 765  :                 "bytes are garbage: it's more likely to be a srcSize error, "
; 766  :                 "specifying more bytes than compressed size of frame(s). This "
; 767  :                 "error message replaces ERROR(prefix_unknown), which would be "
; 768  :                 "confusing, as the first header is actually correct. Note that "
; 769  :                 "one could be unlucky, it might be a corruption error instead, "
; 770  :                 "happening right at the place where we expect zstd magic "
; 771  :                 "bytes. But this is _much_ less likely than a srcSize field "
; 772  :                 "error.");
; 773  :             if (ZSTD_isError(res)) return res;

	jmp	SHORT $LN1@ZSTD_decom
$LN3@ZSTD_decom:

; 780  :     }  /* while (srcSize >= ZSTD_frameHeaderSize_prefix) */
; 781  : 
; 782  :     RETURN_ERROR_IF(srcSize, srcSize_wrong, "input not entirely consumed");

	test	rcx, rcx
	jne	SHORT $LN104@ZSTD_decom

; 783  : 
; 784  :     return (BYTE*)dst - (BYTE*)dststart;

	sub	rsi, r13
	mov	rax, rsi
$LN1@ZSTD_decom:

; 785  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
ZSTD_decompressMultiFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 48
ZSTD_getDDict PROC

; 797  : {

	sub	rsp, 40					; 00000028H

; 798  :     switch (dctx->dictUses) {

	mov	eax, DWORD PTR [rcx+29040]
	cmp	eax, -1
	je	SHORT $LN6@ZSTD_getDD
	cmp	eax, 1
	jne	SHORT $LN5@ZSTD_getDD

; 805  :     case ZSTD_use_indefinitely:
; 806  :         return dctx->ddict;
; 807  :     case ZSTD_use_once:
; 808  :         dctx->dictUses = ZSTD_dont_use;

	mov	DWORD PTR [rcx+29040], 0
$LN6@ZSTD_getDD:

; 809  :         return dctx->ddict;
; 810  :     }
; 811  : }

	mov	rax, QWORD PTR [rcx+29024]
	add	rsp, 40					; 00000028H
	ret	0
$LN5@ZSTD_getDD:

; 799  :     default:
; 800  :         assert(0 /* Impossible */);
; 801  :         /* fall-through */
; 802  :     case ZSTD_dont_use:
; 803  :         ZSTD_clearDict(dctx);

	call	ZSTD_clearDict

; 804  :         return NULL;

	xor	eax, eax

; 809  :         return dctx->ddict;
; 810  :     }
; 811  : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_getDDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
ZSTD_nextSrcSizeToDecompress PROC

; 840  : size_t ZSTD_nextSrcSizeToDecompress(ZSTD_DCtx* dctx) { return dctx->expected; }

	mov	rax, QWORD PTR [rcx+28776]
	ret	0
ZSTD_nextSrcSizeToDecompress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
inputSize$ = 16
ZSTD_nextSrcSizeToDecompressWithInputSize PROC

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	mov	eax, DWORD PTR [rcx+28836]
	sub	eax, 3
	cmp	eax, 1
	mov	rax, QWORD PTR [rcx+28776]
	ja	SHORT $LN1@ZSTD_nextS

; 854  :         return dctx->expected;
; 855  :     if (dctx->bType != bt_raw)

	cmp	DWORD PTR [rcx+28832], 0
	jne	SHORT $LN1@ZSTD_nextS

; 856  :         return dctx->expected;
; 857  :     return MIN(MAX(inputSize, 1), dctx->expected);

	mov	ecx, 1
	cmp	rdx, rcx
	cmova	rcx, rdx
	cmp	rcx, rax
	cmovb	rax, rcx
$LN1@ZSTD_nextS:

; 858  : }

	ret	0
ZSTD_nextSrcSizeToDecompressWithInputSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
ZSTD_nextInputType PROC

; 861  :     switch(dctx->stage)

	movsxd	rax, DWORD PTR [rcx+28836]
	cmp	eax, 7
	ja	SHORT $LN4@ZSTD_nextI
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN12@ZSTD_nextI[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN6@ZSTD_nextI:

; 868  :     case ZSTDds_decodeBlockHeader:
; 869  :         return ZSTDnit_blockHeader;

	mov	eax, 1

; 879  :     }
; 880  : }

	ret	0
$LN7@ZSTD_nextI:

; 870  :     case ZSTDds_decompressBlock:
; 871  :         return ZSTDnit_block;

	mov	eax, 2

; 879  :     }
; 880  : }

	ret	0
$LN8@ZSTD_nextI:

; 872  :     case ZSTDds_decompressLastBlock:
; 873  :         return ZSTDnit_lastBlock;

	mov	eax, 3

; 879  :     }
; 880  : }

	ret	0
$LN9@ZSTD_nextI:

; 874  :     case ZSTDds_checkChecksum:
; 875  :         return ZSTDnit_checksum;

	mov	eax, 4

; 879  :     }
; 880  : }

	ret	0
$LN10@ZSTD_nextI:

; 876  :     case ZSTDds_decodeSkippableHeader:
; 877  :     case ZSTDds_skipFrame:
; 878  :         return ZSTDnit_skippableFrame;

	mov	eax, 5

; 879  :     }
; 880  : }

	ret	0
$LN4@ZSTD_nextI:

; 862  :     {
; 863  :     default:   /* should not happen */
; 864  :         assert(0);
; 865  :     case ZSTDds_getFrameHeaderSize:
; 866  :     case ZSTDds_decodeFrameHeader:
; 867  :         return ZSTDnit_frameHeader;

	xor	eax, eax

; 879  :     }
; 880  : }

	ret	0
$LN12@ZSTD_nextI:
	DD	$LN4@ZSTD_nextI
	DD	$LN4@ZSTD_nextI
	DD	$LN6@ZSTD_nextI
	DD	$LN7@ZSTD_nextI
	DD	$LN8@ZSTD_nextI
	DD	$LN9@ZSTD_nextI
	DD	$LN10@ZSTD_nextI
	DD	$LN10@ZSTD_nextI
ZSTD_nextInputType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
ZSTD_isSkipFrame PROC

; 882  : static int ZSTD_isSkipFrame(ZSTD_DCtx* dctx) { return dctx->stage == ZSTDds_skipFrame; }

	xor	eax, eax
	cmp	DWORD PTR [rcx+28836], 7
	sete	al
	ret	0
ZSTD_isSkipFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
ZSTD_decompressContinue PROC

; 889  : {

$LN416:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	mov	rdi, QWORD PTR srcSize$[rsp]
	lea	rsi, QWORD PTR [rcx+28776]

; 889  : {

	mov	rbp, rdx

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	mov	r15d, 1
	movsxd	rdx, DWORD PTR [rcx+28836]

; 889  : {

	mov	rbx, rcx

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	mov	rcx, QWORD PTR [rsi]

; 889  : {

	mov	r14, r9

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	lea	eax, DWORD PTR [rdx-3]
	cmp	eax, r15d
	ja	SHORT $LN72@ZSTD_decom

; 854  :         return dctx->expected;
; 855  :     if (dctx->bType != bt_raw)

	cmp	DWORD PTR [rbx+28832], 0
	jne	SHORT $LN72@ZSTD_decom

; 856  :         return dctx->expected;
; 857  :     return MIN(MAX(inputSize, 1), dctx->expected);

	mov	eax, r15d
	cmp	rdi, rax
	cmova	rax, rdi
	cmp	rax, rcx
	cmovb	rcx, rax
$LN72@ZSTD_decom:

; 890  :     DEBUGLOG(5, "ZSTD_decompressContinue (srcSize:%u)", (unsigned)srcSize);
; 891  :     /* Sanity check */
; 892  :     RETURN_ERROR_IF(srcSize != ZSTD_nextSrcSizeToDecompressWithInputSize(dctx, srcSize), srcSize_wrong, "not allowed");

	cmp	rdi, rcx
	je	SHORT $LN21@ZSTD_decom
	mov	rax, -72				; ffffffffffffffb8H
	jmp	$LN19@ZSTD_decom
$LN21@ZSTD_decom:

; 893  :     if (dstCapacity) ZSTD_checkContinuity(dctx, dst);

	test	r8, r8
	je	SHORT $LN75@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1414 :     if (dst != dctx->previousDstEnd) {   /* not contiguous */

	mov	rcx, QWORD PTR [rbx+28744]
	cmp	rbp, rcx
	je	SHORT $LN75@ZSTD_decom

; 1415 :         dctx->dictEnd = dctx->previousDstEnd;
; 1416 :         dctx->virtualStart = (const char*)dst - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rax, QWORD PTR [rbx+28752]
	sub	rax, rcx
	mov	QWORD PTR [rbx+28768], rcx
	add	rax, rbp

; 1417 :         dctx->prefixStart = dst;

	mov	QWORD PTR [rbx+28752], rbp
	mov	QWORD PTR [rbx+28760], rax

; 1418 :         dctx->previousDstEnd = dst;

	mov	QWORD PTR [rbx+28744], rbp
$LN75@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 895  :     switch (dctx->stage)

	cmp	edx, 7
	ja	$LN20@ZSTD_decom
	mov	rax, rdx
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN413@ZSTD_decom[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN24@ZSTD_decom:

; 896  :     {
; 897  :     case ZSTDds_getFrameHeaderSize :
; 898  :         assert(src != NULL);
; 899  :         if (dctx->format == ZSTD_f_zstd1) {  /* allows header */

	mov	r8d, DWORD PTR [rbx+28944]
	test	r8d, r8d
	jne	SHORT $LN26@ZSTD_decom

; 900  :             assert(srcSize >= ZSTD_FRAMEIDSIZE);  /* to read skippable magic number */
; 901  :             if ((MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {        /* skippable frame */

	mov	eax, DWORD PTR [r9]
	and	eax, -16				; fffffff0H
	cmp	eax, 407710288				; 184d2a50H
	jne	SHORT $LN26@ZSTD_decom

; 902  :                 memcpy(dctx->headerBuffer, src, srcSize);

	lea	rcx, QWORD PTR [rbx+160280]
	mov	r8, rdi
	mov	rdx, r14
	call	memcpy

; 903  :                 dctx->expected = ZSTD_SKIPPABLEHEADERSIZE - srcSize;  /* remaining to load to get full skippable frame header */

	mov	eax, 8

; 904  :                 dctx->stage = ZSTDds_decodeSkippableHeader;

	mov	DWORD PTR [rbx+28836], 6
	sub	rax, rdi
	mov	QWORD PTR [rsi], rax

; 905  :                 return 0;

	xor	eax, eax
	jmp	$LN19@ZSTD_decom
$LN26@ZSTD_decom:

; 906  :         }   }
; 907  :         dctx->headerSize = ZSTD_frameHeaderSize_internal(src, srcSize, dctx->format);

	mov	rdx, rdi
	mov	rcx, r14
	call	ZSTD_frameHeaderSize_internal
	mov	QWORD PTR [rbx+28936], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 908  :         if (ZSTD_isError(dctx->headerSize)) return dctx->headerSize;

	ja	$LN19@ZSTD_decom

; 909  :         memcpy(dctx->headerBuffer, src, srcSize);

	lea	rcx, QWORD PTR [rbx+160280]
	mov	r8, rdi
	mov	rdx, r14
	call	memcpy

; 910  :         dctx->expected = dctx->headerSize - srcSize;

	mov	rax, QWORD PTR [rbx+28936]
	sub	rax, rdi

; 911  :         dctx->stage = ZSTDds_decodeFrameHeader;

	mov	DWORD PTR [rbx+28836], r15d
	mov	QWORD PTR [rsi], rax

; 912  :         return 0;

	xor	eax, eax
	jmp	$LN19@ZSTD_decom
$LN28@ZSTD_decom:

; 913  : 
; 914  :     case ZSTDds_decodeFrameHeader:
; 915  :         assert(src != NULL);
; 916  :         memcpy(dctx->headerBuffer + (dctx->headerSize - srcSize), src, srcSize);

	mov	rax, QWORD PTR [rbx+28936]
	mov	rcx, rbx
	sub	rcx, rdi
	add	rax, 160280				; 00027218H
	add	rcx, rax
	mov	r8, rdi
	mov	rdx, r14
	call	memcpy

; 917  :         FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(dctx, dctx->headerBuffer, dctx->headerSize), "");

	mov	r8, QWORD PTR [rbx+28936]
	lea	rdx, QWORD PTR [rbx+160280]
	mov	rcx, rbx
	call	ZSTD_decodeFrameHeader
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 917  :         FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(dctx, dctx->headerBuffer, dctx->headerSize), "");

	ja	$LN19@ZSTD_decom

; 918  :         dctx->expected = ZSTD_blockHeaderSize;
; 919  :         dctx->stage = ZSTDds_decodeBlockHeader;

	mov	eax, 2
	mov	ecx, 3
	mov	DWORD PTR [rbx+28836], eax

; 920  :         return 0;

	xor	eax, eax
	mov	QWORD PTR [rsi], rcx
	jmp	$LN19@ZSTD_decom
$LN31@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	eax, WORD PTR [r9]
	movzx	ecx, BYTE PTR [r9+2]
	shl	ecx, 16
	add	ecx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 62   :         U32 const cSize = cBlockHeader >> 3;

	mov	eax, ecx

; 63   :         bpPtr->lastBlock = cBlockHeader & 1;

	mov	edx, ecx

; 64   :         bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);

	shr	ecx, 1
	and	edx, r15d
	and	ecx, 3
	shr	eax, 3

; 65   :         bpPtr->origSize = cSize;   /* only useful for RLE */

	cmp	ecx, r15d

; 66   :         if (bpPtr->blockType == bt_rle) return 1;

	je	SHORT $LN414@ZSTD_decom

; 67   :         RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, "");

	cmp	ecx, 3
	jne	SHORT $LN85@ZSTD_decom
$LN411@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1036 : }

	mov	rax, -20
	jmp	$LN19@ZSTD_decom
$LN85@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 68   :         return cSize;

	mov	r15d, eax
$LN414@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 926  :             RETURN_ERROR_IF(cBlockSize > dctx->fParams.blockSizeMax, corruption_detected, "Block Size Exceeds Maximum");

	mov	r8d, eax
	mov	eax, DWORD PTR [rbx+28800]
	cmp	r15, rax
	ja	SHORT $LN411@ZSTD_decom

; 927  :             dctx->expected = cBlockSize;

	mov	QWORD PTR [rsi], r15

; 928  :             dctx->bType = bp.blockType;

	mov	DWORD PTR [rbx+28832], ecx

; 929  :             dctx->rleSize = bp.origSize;

	mov	QWORD PTR [rbx+28992], r8

; 930  :             if (cBlockSize) {

	test	r15, r15
	je	SHORT $LN35@ZSTD_decom

; 931  :                 dctx->stage = bp.lastBlock ? ZSTDds_decompressLastBlock : ZSTDds_decompressBlock;

	lea	eax, DWORD PTR [rdx+3]
	mov	DWORD PTR [rbx+28836], eax

; 932  :                 return 0;

	xor	eax, eax
	jmp	$LN19@ZSTD_decom
$LN35@ZSTD_decom:

; 933  :             }
; 934  :             /* empty block */
; 935  :             if (bp.lastBlock) {

	test	edx, edx
	je	SHORT $LN36@ZSTD_decom

; 936  :                 if (dctx->fParams.checksumFlag) {

	mov	ecx, DWORD PTR [rbx+28816]

; 937  :                     dctx->expected = 4;
; 938  :                     dctx->stage = ZSTDds_checkChecksum;
; 939  :                 } else {
; 940  :                     dctx->expected = 0; /* end of frame */
; 941  :                     dctx->stage = ZSTDds_getFrameHeaderSize;
; 942  :                 }
; 943  :             } else {

	mov	eax, ecx
	neg	eax
	sbb	eax, eax
	and	eax, 5
	neg	ecx
	sbb	rcx, rcx
	and	ecx, 4

; 946  :             }
; 947  :             return 0;

	mov	QWORD PTR [rsi], rcx
	mov	DWORD PTR [rbx+28836], eax
	xor	eax, eax
	jmp	$LN19@ZSTD_decom
$LN36@ZSTD_decom:

; 944  :                 dctx->expected = ZSTD_blockHeaderSize;  /* jump to next header */
; 945  :                 dctx->stage = ZSTDds_decodeBlockHeader;

	mov	eax, 2
	mov	ecx, 3

; 946  :             }
; 947  :             return 0;

	mov	QWORD PTR [rsi], rcx
	mov	DWORD PTR [rbx+28836], eax
	xor	eax, eax
	jmp	$LN19@ZSTD_decom
$LN40@ZSTD_decom:

; 948  :         }
; 949  : 
; 950  :     case ZSTDds_decompressLastBlock:
; 951  :     case ZSTDds_decompressBlock:
; 952  :         DEBUGLOG(5, "ZSTD_decompressContinue: case ZSTDds_decompressBlock");
; 953  :         {   size_t rSize;
; 954  :             switch(dctx->bType)

	mov	ecx, DWORD PTR [rbx+28832]
	test	ecx, ecx
	je	SHORT $LN42@ZSTD_decom
	sub	ecx, r15d
	je	SHORT $LN45@ZSTD_decom
	cmp	ecx, r15d
	jne	$LN411@ZSTD_decom

; 955  :             {
; 956  :             case bt_compressed:
; 957  :                 DEBUGLOG(5, "ZSTD_decompressContinue: case bt_compressed");
; 958  :                 rSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize, /* frame */ 1);

	mov	rdx, rbp
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, rbx
	call	ZSTD_decompressBlock_internal
	mov	rdi, rax

; 959  :                 dctx->expected = 0;  /* Streaming not supported */
; 960  :                 break;

	jmp	SHORT $LN104@ZSTD_decom
$LN45@ZSTD_decom:

; 967  :                 break;
; 968  :             case bt_rle :
; 969  :                 rSize = ZSTD_setRleBlock(dst, dstCapacity, *(const BYTE*)src, dctx->rleSize);

	mov	rdi, QWORD PTR [rbx+28992]

; 595  :     if (dst == NULL) {

	test	rbp, rbp
	jne	SHORT $LN106@ZSTD_decom

; 596  :         if (regenSize == 0) return 0;

	neg	rdi
	sbb	rdi, rdi
	and	rdi, -74				; ffffffffffffffb6H

; 597  :         RETURN_ERROR(dstBuffer_null, "");

	jmp	SHORT $LN104@ZSTD_decom
$LN106@ZSTD_decom:

; 598  :     }
; 599  :     RETURN_ERROR_IF(regenSize > dstCapacity, dstSize_tooSmall, "");

	cmp	rdi, r8
	jbe	SHORT $LN111@ZSTD_decom
	mov	rdi, -70				; ffffffffffffffbaH
	jmp	SHORT $LN104@ZSTD_decom
$LN111@ZSTD_decom:

; 600  :     memset(dst, b, regenSize);

	movzx	edx, BYTE PTR [r9]
	mov	r8, rdi
	mov	rcx, rbp
	call	memset
$LN104@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	ecx, ecx
	mov	rdx, rsi
	mov	eax, ecx
	mov	QWORD PTR [rdx], rcx
	cmp	rdi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 976  :             FORWARD_IF_ERROR(rSize, "");

	jbe	SHORT $LN15@ZSTD_decom
$LN410@ZSTD_decom:

; 1036 : }

	mov	rax, rdi
	jmp	$LN19@ZSTD_decom
$LN42@ZSTD_decom:

; 582  :     if (dst == NULL) {

	test	rbp, rbp
	jne	SHORT $LN94@ZSTD_decom

; 583  :         if (srcSize == 0) return 0;

	test	rdi, rdi
	jne	SHORT $LN95@ZSTD_decom
	xor	ecx, ecx
	mov	edi, ecx
	jmp	SHORT $LN9@ZSTD_decom
$LN95@ZSTD_decom:

; 584  :         RETURN_ERROR(dstBuffer_null, "");

	mov	rdi, -74				; ffffffffffffffb6H

; 1036 : }

	mov	rax, rdi
	jmp	$LN19@ZSTD_decom
$LN94@ZSTD_decom:

; 586  :     RETURN_ERROR_IF(srcSize > dstCapacity, dstSize_tooSmall, "");

	cmp	rdi, r8
	jbe	SHORT $LN99@ZSTD_decom
	mov	rdi, -70				; ffffffffffffffbaH

; 1036 : }

	mov	rax, rdi
	jmp	$LN19@ZSTD_decom
$LN99@ZSTD_decom:

; 587  :     memcpy(dst, src, srcSize);

	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rbp
	call	memcpy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 964  :                 FORWARD_IF_ERROR(rSize, "ZSTD_copyRawBlock failed");

	ja	SHORT $LN410@ZSTD_decom
$LN9@ZSTD_decom:

; 965  :                 assert(rSize == srcSize);
; 966  :                 dctx->expected -= rSize;

	sub	QWORD PTR [rsi], rdi
	mov	rcx, QWORD PTR [rsi]
$LN15@ZSTD_decom:

; 977  :             RETURN_ERROR_IF(rSize > dctx->fParams.blockSizeMax, corruption_detected, "Decompressed Block Size Exceeds Maximum");

	mov	eax, DWORD PTR [rbx+28800]
	cmp	rdi, rax
	ja	$LN411@ZSTD_decom

; 978  :             DEBUGLOG(5, "ZSTD_decompressContinue: decoded size from block : %u", (unsigned)rSize);
; 979  :             dctx->decodedSize += rSize;

	add	QWORD PTR [rbx+28824], rdi

; 980  :             if (dctx->fParams.checksumFlag) XXH64_update(&dctx->xxhState, dst, rSize);

	cmp	DWORD PTR [rbx+28816], 0
	je	SHORT $LN52@ZSTD_decom
	lea	rcx, QWORD PTR [rbx+28848]
	mov	r8, rdi
	mov	rdx, rbp
	call	XXH64_update
	mov	rcx, QWORD PTR [rsi]
$LN52@ZSTD_decom:

; 981  :             dctx->previousDstEnd = (char*)dst + rSize;

	lea	rax, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx+28744], rax

; 982  : 
; 983  :             /* Stay on the same stage until we are finished streaming the block. */
; 984  :             if (dctx->expected > 0) {

	test	rcx, rcx
	jne	$LN410@ZSTD_decom

; 985  :                 return rSize;
; 986  :             }
; 987  : 
; 988  :             if (dctx->stage == ZSTDds_decompressLastBlock) {   /* end of frame */

	cmp	DWORD PTR [rbx+28836], 4
	jne	SHORT $LN54@ZSTD_decom

; 989  :                 DEBUGLOG(4, "ZSTD_decompressContinue: decoded size from frame : %u", (unsigned)dctx->decodedSize);
; 990  :                 RETURN_ERROR_IF(

	mov	rax, QWORD PTR [rbx+28784]
	cmp	rax, -1
	je	SHORT $LN56@ZSTD_decom
	cmp	QWORD PTR [rbx+28824], rax
	jne	$LN411@ZSTD_decom
$LN56@ZSTD_decom:

; 991  :                     dctx->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
; 992  :                  && dctx->decodedSize != dctx->fParams.frameContentSize,
; 993  :                     corruption_detected, "");
; 994  :                 if (dctx->fParams.checksumFlag) {  /* another round for frame checksum */

	mov	ecx, DWORD PTR [rbx+28816]

; 995  :                     dctx->expected = 4;
; 996  :                     dctx->stage = ZSTDds_checkChecksum;
; 997  :                 } else {
; 998  :                     dctx->expected = 0;   /* ends here */
; 999  :                     dctx->stage = ZSTDds_getFrameHeaderSize;
; 1000 :                 }
; 1001 :             } else {

	mov	eax, ecx
	neg	eax
	sbb	eax, eax
	and	eax, 5
	neg	ecx
	sbb	rcx, rcx
	and	ecx, 4

; 1004 :             }
; 1005 :             return rSize;

	mov	QWORD PTR [rsi], rcx
	mov	DWORD PTR [rbx+28836], eax
	mov	rax, rdi
	jmp	SHORT $LN19@ZSTD_decom
$LN54@ZSTD_decom:

; 1002 :                 dctx->stage = ZSTDds_decodeBlockHeader;
; 1003 :                 dctx->expected = ZSTD_blockHeaderSize;

	mov	eax, 2
	mov	ecx, 3

; 1004 :             }
; 1005 :             return rSize;

	mov	QWORD PTR [rsi], rcx
	mov	DWORD PTR [rbx+28836], eax
	mov	rax, rdi
	jmp	SHORT $LN19@ZSTD_decom
$LN60@ZSTD_decom:

; 1006 :         }
; 1007 : 
; 1008 :     case ZSTDds_checkChecksum:
; 1009 :         assert(srcSize == 4);  /* guaranteed by dctx->expected */
; 1010 :         {   U32 const h32 = (U32)XXH64_digest(&dctx->xxhState);

	lea	rcx, QWORD PTR [rbx+28848]
	call	XXH64_digest

; 1011 :             U32 const check32 = MEM_readLE32(src);
; 1012 :             DEBUGLOG(4, "ZSTD_decompressContinue: checksum : calculated %08X :: %08X read", (unsigned)h32, (unsigned)check32);
; 1013 :             RETURN_ERROR_IF(check32 != h32, checksum_wrong, "");

	cmp	DWORD PTR [r14], eax
	je	SHORT $LN64@ZSTD_decom
	mov	rax, -22
	jmp	SHORT $LN19@ZSTD_decom
$LN63@ZSTD_decom:

; 1014 :             dctx->expected = 0;
; 1015 :             dctx->stage = ZSTDds_getFrameHeaderSize;
; 1016 :             return 0;
; 1017 :         }
; 1018 : 
; 1019 :     case ZSTDds_decodeSkippableHeader:
; 1020 :         assert(src != NULL);
; 1021 :         assert(srcSize <= ZSTD_SKIPPABLEHEADERSIZE);
; 1022 :         memcpy(dctx->headerBuffer + (ZSTD_SKIPPABLEHEADERSIZE - srcSize), src, srcSize);   /* complete skippable header */

	mov	rcx, rbx
	mov	r8, rdi
	sub	rcx, rdi
	mov	rdx, r14
	add	rcx, 160288				; 00027220H
	call	memcpy

; 1023 :         dctx->expected = MEM_readLE32(dctx->headerBuffer + ZSTD_FRAMEIDSIZE);   /* note : dctx->expected can grow seriously large, beyond local buffer size */

	mov	eax, DWORD PTR [rbx+160284]
	mov	QWORD PTR [rsi], rax

; 1024 :         dctx->stage = ZSTDds_skipFrame;
; 1025 :         return 0;

	xor	eax, eax
	mov	DWORD PTR [rbx+28836], 7
	jmp	SHORT $LN19@ZSTD_decom
$LN64@ZSTD_decom:

; 1026 : 
; 1027 :     case ZSTDds_skipFrame:
; 1028 :         dctx->expected = 0;

	xor	ecx, ecx
	mov	QWORD PTR [rsi], rcx

; 1029 :         dctx->stage = ZSTDds_getFrameHeaderSize;
; 1030 :         return 0;

	xor	eax, eax
	mov	DWORD PTR [rbx+28836], ecx
	jmp	SHORT $LN19@ZSTD_decom
$LN20@ZSTD_decom:

; 1031 : 
; 1032 :     default:
; 1033 :         assert(0);   /* impossible */
; 1034 :         RETURN_ERROR(GENERIC, "impossible to reach");   /* some compiler require default to do something */

	mov	rax, -1
$LN19@ZSTD_decom:

; 1036 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
	npad	3
$LN413@ZSTD_decom:
	DD	$LN24@ZSTD_decom
	DD	$LN28@ZSTD_decom
	DD	$LN31@ZSTD_decom
	DD	$LN40@ZSTD_decom
	DD	$LN40@ZSTD_decom
	DD	$LN60@ZSTD_decom
	DD	$LN63@ZSTD_decom
	DD	$LN64@ZSTD_decom
ZSTD_decompressContinue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
dict$ = 16
dictSize$ = 24
ZSTD_refDictContent PROC

; 1041 :     dctx->dictEnd = dctx->previousDstEnd;

	mov	rax, QWORD PTR [rcx+28744]

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	r9, QWORD PTR [rcx+28752]
	sub	r9, rax
	mov	QWORD PTR [rcx+28768], rax

; 1043 :     dctx->prefixStart = dict;
; 1044 :     dctx->previousDstEnd = (const char*)dict + dictSize;

	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR [rcx+28752], rdx
	add	r9, rdx
	mov	QWORD PTR [rcx+28744], rax
	mov	QWORD PTR [rcx+28760], r9

; 1045 : #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 1046 :     dctx->dictContentBeginForFuzzing = dctx->prefixStart;
; 1047 :     dctx->dictContentEndForFuzzing = dctx->previousDstEnd;
; 1048 : #endif
; 1049 :     return 0;

	xor	eax, eax

; 1050 : }

	ret	0
ZSTD_refDictContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
DTableH$1 = 48
r$2 = 48
DTableH$3 = 48
r$4 = 48
DTableH$5 = 48
litlengthLog$6 = 48
litlengthMaxValue$7 = 56
matchlengthLog$8 = 56
offcodeLog$9 = 56
entropy$GSCopy$1$ = 64
offcodeMaxValue$10 = 72
offcodeHeaderSize$1$ = 80
matchlengthMaxValue$11 = 80
dictContentSize$1$ = 88
litlengthHeaderSize$1$ = 96
matchlengthHeaderSize$1$ = 96
dict$GSCopy$1$ = 104
litlengthNCount$12 = 112
matchlengthNCount$13 = 112
offcodeNCount$14 = 112
symbolNext$15 = 224
symbolNext$16 = 336
symbolNext$17 = 448
__$ArrayPad$ = 560
entropy$ = 640
dict$ = 648
dictSize$ = 656
ZSTD_loadDEntropy PROC

; 1058 : {

$LN173:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-320]
	sub	rsp, 576				; 00000240H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR dict$GSCopy$1$[rsp], rdx

; 1059 :     const BYTE* dictPtr = (const BYTE*)dict;
; 1060 :     const BYTE* const dictEnd = dictPtr + dictSize;

	lea	rbx, QWORD PTR [r8+rdx]
	mov	QWORD PTR dictContentSize$1$[rsp], rbx
	mov	rax, rcx
	mov	QWORD PTR entropy$GSCopy$1$[rsp], rcx

; 1061 : 
; 1062 :     RETURN_ERROR_IF(dictSize <= 8, dictionary_corrupted, "dict is too small");

	cmp	r8, 8
	jbe	$LN120@ZSTD_loadD

; 1063 :     assert(MEM_readLE32(dict) == ZSTD_MAGIC_DICTIONARY);   /* dict must be valid */
; 1064 :     dictPtr += 8;   /* skip header = magic + dictID */

	lea	r12, QWORD PTR [rdx+8]

; 1065 : 
; 1066 :     ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, OFTable) == offsetof(ZSTD_entropyDTables_t, LLTable) + sizeof(entropy->LLTable));
; 1067 :     ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, MLTable) == offsetof(ZSTD_entropyDTables_t, OFTable) + sizeof(entropy->OFTable));
; 1068 :     ZSTD_STATIC_ASSERT(sizeof(entropy->LLTable) + sizeof(entropy->OFTable) + sizeof(entropy->MLTable) >= HUF_DECOMPRESS_WORKSPACE_SIZE);
; 1069 :     {   void* const workspace = &entropy->LLTable;   /* use fse tables as temporary workspace; implies fse tables are grouped together */
; 1070 :         size_t const workspaceSize = sizeof(entropy->LLTable) + sizeof(entropy->OFTable) + sizeof(entropy->MLTable);
; 1071 : #ifdef HUF_FORCE_DECOMPRESS_X1
; 1072 :         /* in minimal huffman, we always use X1 variants */
; 1073 :         size_t const hSize = HUF_readDTableX1_wksp(entropy->hufTable,
; 1074 :                                                 dictPtr, dictEnd - dictPtr,
; 1075 :                                                 workspace, workspaceSize);
; 1076 : #else
; 1077 :         size_t const hSize = HUF_readDTableX2_wksp(entropy->hufTable,

	mov	QWORD PTR [rsp+32], 10264		; 00002818H
	mov	r8, rbx
	mov	rdx, r12
	sub	r8, r12
	add	rcx, 10264				; 00002818H
	mov	r9, rax
	call	HUF_readDTableX2_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1081 :         RETURN_ERROR_IF(HUF_isError(hSize), dictionary_corrupted, "");

	ja	$LN120@ZSTD_loadD

; 1082 :         dictPtr += hSize;

	add	r12, rax

; 1083 :     }
; 1084 : 
; 1085 :     {   short offcodeNCount[MaxOff+1];
; 1086 :         unsigned offcodeMaxValue = MaxOff, offcodeLog;

	mov	DWORD PTR offcodeMaxValue$10[rsp], 31

; 1087 :         size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dictPtr, dictEnd-dictPtr);

	mov	rax, rbx
	lea	r8, QWORD PTR offcodeLog$9[rsp]
	sub	rax, r12
	lea	rdx, QWORD PTR offcodeMaxValue$10[rsp]
	mov	r9, r12
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR offcodeNCount$14[rsp]
	call	FSE_readNCount
	mov	QWORD PTR offcodeHeaderSize$1$[rsp], rax
	mov	r15, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1088 :         RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, "");

	ja	$LN120@ZSTD_loadD

; 1089 :         RETURN_ERROR_IF(offcodeMaxValue > MaxOff, dictionary_corrupted, "");

	mov	ecx, DWORD PTR offcodeMaxValue$10[rsp]
	cmp	ecx, 31
	ja	$LN120@ZSTD_loadD

; 1090 :         RETURN_ERROR_IF(offcodeLog > OffFSELog, dictionary_corrupted, "");

	mov	r14d, DWORD PTR offcodeLog$9[rsp]
	cmp	r14d, 8
	ja	$LN120@ZSTD_loadD
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	eax, 1

; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$5[rsp+4], r14d
	lea	edi, DWORD PTR [rcx+1]

; 387  :         DTableH.fastMode = 1;

	mov	DWORD PTR DTableH$5[rsp], eax
	mov	ecx, r14d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1091 :         ZSTD_buildFSETable( entropy->OFTable,

	xor	r13d, r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	esi, eax

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	r11d, eax
	shl	esi, cl
	mov	edx, eax
	lea	ecx, DWORD PTR [r14-1]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1091 :         ZSTD_buildFSETable( entropy->OFTable,

	mov	r9d, r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	shl	r11w, cl
	lea	r8d, DWORD PTR [rsi-1]

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	test	edi, edi
	je	$LN39@ZSTD_loadD
	mov	r10, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	ecx, r13d
	mov	ebx, eax
	npad	5
$LL40@ZSTD_loadD:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR offcodeNCount$14[rsp+rcx]
	cmp	ax, -1
	jne	SHORT $LN52@ZSTD_loadD

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	DWORD PTR [r10+r8*8+4116], r9d

; 393  :                     symbolNext[s] = 1;

	movzx	eax, bx
	dec	r8d

; 394  :                 } else {

	jmp	SHORT $LN38@ZSTD_loadD
$LN52@ZSTD_loadD:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r11w
	cmovge	edx, r13d
	mov	DWORD PTR DTableH$5[rsp], edx
$LN38@ZSTD_loadD:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR symbolNext$15[rbp+rcx-256], ax
	inc	r9d
	add	rcx, 2
	cmp	r9d, edi
	jb	SHORT $LL40@ZSTD_loadD
	mov	rax, QWORD PTR DTableH$5[rsp]
	lea	rbx, QWORD PTR offcodeNCount$14[rsp]
	mov	r15, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	r9d, esi
	shr	r9d, 1
	mov	ecx, esi
	add	r9d, 3
	shr	ecx, 3
	mov	QWORD PTR [r10+4104], rax
	add	r9d, ecx
	mov	edx, r13d
	lea	r10d, DWORD PTR [rsi-1]
	mov	r11d, r13d
	npad	6
$LL43@ZSTD_loadD:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	eax, WORD PTR [rbx]
	test	eax, eax
	jle	SHORT $LN41@ZSTD_loadD
	mov	ecx, eax
	npad	7
$LL46@ZSTD_loadD:

; 409  :                 tableDecode[position].baseValue = s;

	mov	eax, edx

; 410  :                 position = (position + step) & tableMask;

	add	edx, r9d
	and	edx, r10d
	mov	DWORD PTR [r15+rax*8+4116], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	edx, r8d
	jbe	SHORT $LN44@ZSTD_loadD
$LL47@ZSTD_loadD:
	add	edx, r9d
	and	edx, r10d
	cmp	edx, r8d
	ja	SHORT $LL47@ZSTD_loadD
$LN44@ZSTD_loadD:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rcx, 1
	jne	SHORT $LL46@ZSTD_loadD
$LN41@ZSTD_loadD:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rbx, 2
	cmp	r11d, edi
	jb	SHORT $LL43@ZSTD_loadD
	mov	r15, QWORD PTR offcodeHeaderSize$1$[rsp]
	mov	rbx, QWORD PTR dictContentSize$1$[rsp]
	mov	rcx, QWORD PTR entropy$GSCopy$1$[rsp]
	jmp	SHORT $LN42@ZSTD_loadD
$LN39@ZSTD_loadD:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rcx, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	rax, QWORD PTR DTableH$5[rsp]
	mov	QWORD PTR [rcx+4104], rax
$LN42@ZSTD_loadD:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	lea	rdi, OFFSET FLAT:__ImageBase
	test	esi, esi
	je	SHORT $LN50@ZSTD_loadD
	lea	r10, QWORD PTR [rcx+4116]
	mov	r11d, esi
	npad	7
$LL51@ZSTD_loadD:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, r13d
	mov	DWORD PTR r$4[rsp], r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r14b
	movzx	r8d, WORD PTR symbolNext$15[rbp+r9*2-256]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$15[rbp+r9*2-256], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, si
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR OF_bits[rdi+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR OF_base[rdi+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, 1
	jne	SHORT $LL51@ZSTD_loadD
$LN50@ZSTD_loadD:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1095 :         dictPtr += offcodeHeaderSize;

	add	r12, r15

; 1096 :     }
; 1097 : 
; 1098 :     {   short matchlengthNCount[MaxML+1];
; 1099 :         unsigned matchlengthMaxValue = MaxML, matchlengthLog;

	mov	DWORD PTR matchlengthMaxValue$11[rsp], 52 ; 00000034H

; 1100 :         size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, dictEnd-dictPtr);

	mov	rax, rbx
	lea	r8, QWORD PTR matchlengthLog$8[rsp]
	sub	rax, r12
	lea	rdx, QWORD PTR matchlengthMaxValue$11[rsp]
	mov	r9, r12
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR matchlengthNCount$13[rsp]
	call	FSE_readNCount
	mov	QWORD PTR matchlengthHeaderSize$1$[rsp], rax
	mov	r15, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1101 :         RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, "");

	ja	$LN120@ZSTD_loadD

; 1102 :         RETURN_ERROR_IF(matchlengthMaxValue > MaxML, dictionary_corrupted, "");

	mov	ecx, DWORD PTR matchlengthMaxValue$11[rsp]
	cmp	ecx, 52					; 00000034H
	ja	$LN120@ZSTD_loadD

; 1103 :         RETURN_ERROR_IF(matchlengthLog > MLFSELog, dictionary_corrupted, "");

	mov	r14d, DWORD PTR matchlengthLog$8[rsp]
	cmp	r14d, 9
	ja	$LN120@ZSTD_loadD
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	eax, 1

; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$3[rsp+4], r14d
	lea	edi, DWORD PTR [rcx+1]

; 387  :         DTableH.fastMode = 1;

	mov	DWORD PTR DTableH$3[rsp], eax
	mov	ecx, r14d
	mov	esi, eax
	shl	esi, cl

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	r11d, eax
	lea	ecx, DWORD PTR [r14-1]
	mov	edx, eax
	shl	r11w, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1104 :         ZSTD_buildFSETable( entropy->MLTable,

	mov	r9d, r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 378  :     U32 highThreshold = tableSize-1;

	lea	r8d, DWORD PTR [rsi-1]

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	test	edi, edi
	je	$LN62@ZSTD_loadD
	mov	r10, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	rcx, r13
	mov	ebx, eax
	npad	8
$LL63@ZSTD_loadD:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR matchlengthNCount$13[rsp+rcx]
	cmp	ax, -1
	jne	SHORT $LN75@ZSTD_loadD

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	DWORD PTR [r10+r8*8+6172], r9d

; 393  :                     symbolNext[s] = 1;

	movzx	eax, bx
	dec	r8d

; 394  :                 } else {

	jmp	SHORT $LN61@ZSTD_loadD
$LN75@ZSTD_loadD:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r11w
	cmovge	edx, r13d
	mov	DWORD PTR DTableH$3[rsp], edx
$LN61@ZSTD_loadD:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR symbolNext$16[rbp+rcx-256], ax
	inc	r9d
	add	rcx, 2
	cmp	r9d, edi
	jb	SHORT $LL63@ZSTD_loadD
	mov	rax, QWORD PTR DTableH$3[rsp]
	lea	rbx, QWORD PTR matchlengthNCount$13[rsp]
	mov	r15, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	r9d, esi
	shr	r9d, 1
	mov	ecx, esi
	add	r9d, 3
	shr	ecx, 3
	mov	QWORD PTR [r10+6160], rax
	add	r9d, ecx
	mov	edx, r13d
	lea	r10d, DWORD PTR [rsi-1]
	mov	r11d, r13d
	npad	6
$LL66@ZSTD_loadD:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	eax, WORD PTR [rbx]
	test	eax, eax
	jle	SHORT $LN64@ZSTD_loadD
	mov	ecx, eax
	npad	7
$LL69@ZSTD_loadD:

; 409  :                 tableDecode[position].baseValue = s;

	mov	eax, edx

; 410  :                 position = (position + step) & tableMask;

	add	edx, r9d
	and	edx, r10d
	mov	DWORD PTR [r15+rax*8+6172], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	edx, r8d
	jbe	SHORT $LN67@ZSTD_loadD
$LL70@ZSTD_loadD:
	add	edx, r9d
	and	edx, r10d
	cmp	edx, r8d
	ja	SHORT $LL70@ZSTD_loadD
$LN67@ZSTD_loadD:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rcx, 1
	jne	SHORT $LL69@ZSTD_loadD
$LN64@ZSTD_loadD:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rbx, 2
	cmp	r11d, edi
	jb	SHORT $LL66@ZSTD_loadD
	mov	r15, QWORD PTR matchlengthHeaderSize$1$[rsp]
	mov	rbx, QWORD PTR dictContentSize$1$[rsp]
	mov	rcx, QWORD PTR entropy$GSCopy$1$[rsp]
	jmp	SHORT $LN65@ZSTD_loadD
$LN62@ZSTD_loadD:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rcx, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	rax, QWORD PTR DTableH$3[rsp]
	mov	QWORD PTR [rcx+6160], rax
$LN65@ZSTD_loadD:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	test	esi, esi
	je	SHORT $LN73@ZSTD_loadD
	lea	r10, QWORD PTR [rcx+6172]
	mov	r11d, esi
	lea	rdi, OFFSET FLAT:__ImageBase
	npad	7
$LL74@ZSTD_loadD:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, r13d
	mov	DWORD PTR r$2[rsp], r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r14b
	movzx	r8d, WORD PTR symbolNext$16[rbp+r9*2-256]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$16[rbp+r9*2-256], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, si
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR ML_bits[rdi+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR ML_base[rdi+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, 1
	jne	SHORT $LL74@ZSTD_loadD
$LN73@ZSTD_loadD:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1108 :         dictPtr += matchlengthHeaderSize;

	add	r12, r15

; 1109 :     }
; 1110 : 
; 1111 :     {   short litlengthNCount[MaxLL+1];
; 1112 :         unsigned litlengthMaxValue = MaxLL, litlengthLog;

	mov	DWORD PTR litlengthMaxValue$7[rsp], 35	; 00000023H

; 1113 :         size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, dictEnd-dictPtr);

	mov	rax, rbx
	lea	r8, QWORD PTR litlengthLog$6[rsp]
	sub	rax, r12
	lea	rdx, QWORD PTR litlengthMaxValue$7[rsp]
	mov	r9, r12
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR litlengthNCount$12[rsp]
	call	FSE_readNCount
	mov	QWORD PTR litlengthHeaderSize$1$[rsp], rax
	mov	r15, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1114 :         RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, "");

	ja	$LN120@ZSTD_loadD

; 1115 :         RETURN_ERROR_IF(litlengthMaxValue > MaxLL, dictionary_corrupted, "");

	mov	ecx, DWORD PTR litlengthMaxValue$7[rsp]
	cmp	ecx, 35					; 00000023H
	ja	$LN120@ZSTD_loadD

; 1116 :         RETURN_ERROR_IF(litlengthLog > LLFSELog, dictionary_corrupted, "");

	mov	r14d, DWORD PTR litlengthLog$6[rsp]
	cmp	r14d, 9
	ja	$LN120@ZSTD_loadD
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	eax, 1

; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$1[rsp+4], r14d
	lea	edi, DWORD PTR [rcx+1]

; 387  :         DTableH.fastMode = 1;

	mov	DWORD PTR DTableH$1[rsp], eax
	mov	ecx, r14d
	mov	esi, eax
	shl	esi, cl

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	r11d, eax
	lea	ecx, DWORD PTR [r14-1]
	mov	edx, eax
	shl	r11w, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1117 :         ZSTD_buildFSETable( entropy->LLTable,

	mov	r9d, r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 378  :     U32 highThreshold = tableSize-1;

	lea	r8d, DWORD PTR [rsi-1]

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	test	edi, edi
	je	$LN85@ZSTD_loadD
	mov	r10, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	rcx, r13
	mov	ebx, eax
	npad	8
$LL86@ZSTD_loadD:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR litlengthNCount$12[rsp+rcx]
	cmp	ax, -1
	jne	SHORT $LN98@ZSTD_loadD

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	DWORD PTR [r10+r8*8+12], r9d

; 393  :                     symbolNext[s] = 1;

	movzx	eax, bx
	dec	r8d

; 394  :                 } else {

	jmp	SHORT $LN84@ZSTD_loadD
$LN98@ZSTD_loadD:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r11w
	cmovge	edx, r13d
	mov	DWORD PTR DTableH$1[rsp], edx
$LN84@ZSTD_loadD:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR symbolNext$17[rbp+rcx-256], ax
	inc	r9d
	add	rcx, 2
	cmp	r9d, edi
	jb	SHORT $LL86@ZSTD_loadD
	mov	rax, QWORD PTR DTableH$1[rsp]
	lea	rbx, QWORD PTR litlengthNCount$12[rsp]
	mov	r15, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	r9d, esi
	shr	r9d, 1
	mov	edx, esi
	mov	QWORD PTR [r10], rax
	add	r9d, 3
	shr	edx, 3
	lea	r10d, DWORD PTR [rsi-1]
	add	r9d, edx
	mov	eax, r13d
	mov	r11d, r13d
$LL89@ZSTD_loadD:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	ecx, WORD PTR [rbx]
	test	ecx, ecx
	jle	SHORT $LN87@ZSTD_loadD
	mov	edx, ecx
	npad	1
$LL92@ZSTD_loadD:

; 409  :                 tableDecode[position].baseValue = s;

	mov	ecx, eax

; 410  :                 position = (position + step) & tableMask;

	add	eax, r9d
	and	eax, r10d
	mov	DWORD PTR [r15+rcx*8+12], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	eax, r8d
	jbe	SHORT $LN90@ZSTD_loadD
$LL93@ZSTD_loadD:
	add	eax, r9d
	and	eax, r10d
	cmp	eax, r8d
	ja	SHORT $LL93@ZSTD_loadD
$LN90@ZSTD_loadD:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rdx, 1
	jne	SHORT $LL92@ZSTD_loadD
$LN87@ZSTD_loadD:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rbx, 2
	cmp	r11d, edi
	jb	SHORT $LL89@ZSTD_loadD
	mov	r15, QWORD PTR litlengthHeaderSize$1$[rsp]
	mov	rbx, QWORD PTR dictContentSize$1$[rsp]
	mov	rdi, QWORD PTR entropy$GSCopy$1$[rsp]
	jmp	SHORT $LN88@ZSTD_loadD
$LN85@ZSTD_loadD:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rdi, QWORD PTR entropy$GSCopy$1$[rsp]
	mov	rax, QWORD PTR DTableH$1[rsp]
	mov	QWORD PTR [rdi], rax
$LN88@ZSTD_loadD:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	test	esi, esi
	je	SHORT $LN96@ZSTD_loadD
	lea	r10, QWORD PTR [rdi+12]
	mov	r11d, esi
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	1
$LL97@ZSTD_loadD:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, r13d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r14b
	movzx	r8d, WORD PTR symbolNext$17[rbp+r9*2-256]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$17[rbp+r9*2-256], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, si
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR LL_bits[rbx+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR LL_base[rbx+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, 1
	jne	SHORT $LL97@ZSTD_loadD
	mov	rbx, QWORD PTR dictContentSize$1$[rsp]
$LN96@ZSTD_loadD:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1121 :         dictPtr += litlengthHeaderSize;

	add	r12, r15

; 1122 :     }
; 1123 : 
; 1124 :     RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, "");

	lea	rax, QWORD PTR [r12+12]
	cmp	rax, rbx
	ja	SHORT $LN120@ZSTD_loadD

; 1125 :     {   int i;
; 1126 :         size_t const dictContentSize = (size_t)(dictEnd - (dictPtr+12));

	sub	rbx, r12
	lea	r8, QWORD PTR [rdi+26652]
	sub	rbx, 12
$LL4@ZSTD_loadD:

; 1127 :         for (i=0; i<3; i++) {
; 1128 :             U32 const rep = MEM_readLE32(dictPtr); dictPtr += 4;

	mov	edx, DWORD PTR [r12]
	add	r12, 4

; 1129 :             RETURN_ERROR_IF(rep==0 || rep > dictContentSize,

	test	edx, edx
	je	SHORT $LN120@ZSTD_loadD
	cmp	rdx, rbx
	ja	SHORT $LN120@ZSTD_loadD

; 1130 :                             dictionary_corrupted, "");
; 1131 :             entropy->rep[i] = rep;

	mov	DWORD PTR [r8], edx
	inc	r13
	add	r8, 4
	cmp	r13, 3
	jl	SHORT $LL4@ZSTD_loadD

; 1132 :     }   }
; 1133 : 
; 1134 :     return dictPtr - (const BYTE*)dict;

	sub	r12, QWORD PTR dict$GSCopy$1$[rsp]
	mov	rax, r12
	jmp	SHORT $LN1@ZSTD_loadD
$LN120@ZSTD_loadD:

; 1129 :             RETURN_ERROR_IF(rep==0 || rep > dictContentSize,

	mov	rax, -30
$LN1@ZSTD_loadD:

; 1135 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+664]
	add	rsp, 576				; 00000240H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_loadDEntropy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 48
dict$ = 56
dictSize$ = 64
ZSTD_decompress_insertDictionary PROC

; 1138 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	mov	r14, rdx

; 1139 :     if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);

	cmp	r8, 8
	jae	SHORT $LN2@ZSTD_decom

; 1041 :     dctx->dictEnd = dctx->previousDstEnd;

	mov	rax, QWORD PTR [rcx+28744]

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	r9, QWORD PTR [rcx+28752]
	sub	r9, rax
	mov	QWORD PTR [rcx+28768], rax
	add	r9, rdx

; 1043 :     dctx->prefixStart = dict;

	mov	QWORD PTR [rcx+28752], rdx

; 1044 :     dctx->previousDstEnd = (const char*)dict + dictSize;

	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR [rcx+28760], r9
	mov	QWORD PTR [rcx+28744], rax

; 1139 :     if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);

	jmp	$LN15@ZSTD_decom
$LN2@ZSTD_decom:

; 1140 :     {   U32 const magic = MEM_readLE32(dict);
; 1141 :         if (magic != ZSTD_MAGIC_DICTIONARY) {

	cmp	DWORD PTR [rdx], -332356553		; ec30a437H
	je	SHORT $LN3@ZSTD_decom

; 1041 :     dctx->dictEnd = dctx->previousDstEnd;

	mov	rax, QWORD PTR [rcx+28744]
	mov	QWORD PTR [rcx+28768], rax

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rcx, QWORD PTR [rcx+28752]
	sub	rcx, rax

; 1044 :     dctx->previousDstEnd = (const char*)dict + dictSize;

	lea	rax, QWORD PTR [rdx+r8]

; 1142 :             return ZSTD_refDictContent(dctx, dict, dictSize);   /* pure content mode */

	jmp	SHORT $LN16@ZSTD_decom
$LN3@ZSTD_decom:

; 1143 :     }   }
; 1144 :     dctx->dictID = MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+29032], eax

; 1145 : 
; 1146 :     /* load entropy tables */
; 1147 :     {   size_t const eSize = ZSTD_loadDEntropy(&dctx->entropy, dict, dictSize);

	add	rcx, 32					; 00000020H
	call	ZSTD_loadDEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1148 :         RETURN_ERROR_IF(ZSTD_isError(eSize), dictionary_corrupted, "");

	jbe	SHORT $LN4@ZSTD_decom
	mov	rax, -30
	jmp	SHORT $LN1@ZSTD_decom
$LN4@ZSTD_decom:

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rcx, QWORD PTR [rbx+28752]

; 1149 :         dict = (const char*)dict + eSize;

	add	rdi, rax

; 1041 :     dctx->dictEnd = dctx->previousDstEnd;

	mov	rax, QWORD PTR [rbx+28744]
	mov	QWORD PTR [rbx+28768], rax

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	sub	rcx, rax

; 1044 :     dctx->previousDstEnd = (const char*)dict + dictSize;

	lea	rax, QWORD PTR [r14+rsi]

; 1150 :         dictSize -= eSize;
; 1151 :     }
; 1152 :     dctx->litEntropy = dctx->fseEntropy = 1;

	mov	DWORD PTR [rbx+28844], 1
	mov	DWORD PTR [rbx+28840], 1
$LN16@ZSTD_decom:

; 1153 : 
; 1154 :     /* reference dictionary content */
; 1155 :     return ZSTD_refDictContent(dctx, dict, dictSize);
; 1156 : }

	add	rcx, rdi
	mov	QWORD PTR [rbx+28744], rax
	mov	QWORD PTR [rbx+28760], rcx
	mov	QWORD PTR [rbx+28752], rdi
$LN15@ZSTD_decom:
	xor	eax, eax
$LN1@ZSTD_decom:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
ZSTD_decompress_insertDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
ZSTD_decompressBegin PROC

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	cmp	DWORD PTR [rcx+28944], 0
	mov	edx, 5

; 1171 :     dctx->bType = bt_reserved;

	mov	DWORD PTR [rcx+28832], 3

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	mov	eax, 1
	cmove	eax, edx

; 1160 :     assert(dctx != NULL);
; 1161 :     dctx->expected = ZSTD_startingInputLength(dctx->format);  /* dctx->format must be properly set */
; 1162 :     dctx->stage = ZSTDds_getFrameHeaderSize;
; 1163 :     dctx->decodedSize = 0;
; 1164 :     dctx->previousDstEnd = NULL;
; 1165 :     dctx->prefixStart = NULL;
; 1166 :     dctx->virtualStart = NULL;
; 1167 :     dctx->dictEnd = NULL;
; 1168 :     dctx->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */

	lea	rdx, QWORD PTR [rcx+10296]
	mov	DWORD PTR [rdx], 201326604		; 0c00000cH
	mov	QWORD PTR [rcx+28776], rax
	xor	eax, eax
	mov	QWORD PTR [rcx+28836], rax
	mov	QWORD PTR [rcx+28824], rax
	mov	QWORD PTR [rcx+28744], rax
	mov	QWORD PTR [rcx+28752], rax
	mov	QWORD PTR [rcx+28760], rax
	mov	QWORD PTR [rcx+28768], rax

; 1169 :     dctx->litEntropy = dctx->fseEntropy = 0;

	mov	DWORD PTR [rcx+28844], eax

; 1170 :     dctx->dictID = 0;

	mov	DWORD PTR [rcx+29032], eax

; 1172 :     ZSTD_STATIC_ASSERT(sizeof(dctx->entropy.rep) == sizeof(repStartValue));
; 1173 :     memcpy(dctx->entropy.rep, repStartValue, sizeof(repStartValue));  /* initial repcodes */

	movsd	xmm0, QWORD PTR repStartValue
	movsd	QWORD PTR [rcx+26684], xmm0
	mov	eax, DWORD PTR repStartValue+8
	mov	DWORD PTR [rcx+26692], eax

; 1174 :     dctx->LLTptr = dctx->entropy.LLTable;

	lea	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR [rcx], rax

; 1175 :     dctx->MLTptr = dctx->entropy.MLTable;

	lea	rax, QWORD PTR [rcx+6192]
	mov	QWORD PTR [rcx+8], rax

; 1176 :     dctx->OFTptr = dctx->entropy.OFTable;

	lea	rax, QWORD PTR [rcx+4136]
	mov	QWORD PTR [rcx+16], rax

; 1177 :     dctx->HUFptr = dctx->entropy.hufTable;
; 1178 :     return 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rdx

; 1179 : }

	ret	0
ZSTD_decompressBegin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 48
dict$ = 56
dictSize$ = 64
ZSTD_decompressBegin_usingDict PROC

; 1182 : {

$LN37:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	mov	eax, 1
	mov	ecx, 5

; 1182 : {

	mov	rsi, r8
	mov	rdi, rdx

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	cmp	DWORD PTR [rbx+28944], 0

; 1174 :     dctx->LLTptr = dctx->entropy.LLTable;

	lea	r9, QWORD PTR [rbx+32]
	mov	QWORD PTR [rbx+28832], 3

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	cmove	eax, ecx

; 1168 :     dctx->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */

	lea	rcx, QWORD PTR [rbx+10296]
	mov	QWORD PTR [rbx+28776], rax
	xor	eax, eax
	mov	QWORD PTR [rbx+28744], rax
	mov	QWORD PTR [rbx+28752], rax
	mov	QWORD PTR [rbx+28760], rax
	mov	QWORD PTR [rbx+28768], rax
	mov	DWORD PTR [rcx], 201326604		; 0c00000cH

; 1169 :     dctx->litEntropy = dctx->fseEntropy = 0;

	mov	QWORD PTR [rbx+28840], rax

; 1170 :     dctx->dictID = 0;

	mov	DWORD PTR [rbx+29032], eax
	mov	QWORD PTR [rbx+28824], rax

; 1171 :     dctx->bType = bt_reserved;
; 1172 :     ZSTD_STATIC_ASSERT(sizeof(dctx->entropy.rep) == sizeof(repStartValue));
; 1173 :     memcpy(dctx->entropy.rep, repStartValue, sizeof(repStartValue));  /* initial repcodes */

	movsd	xmm0, QWORD PTR repStartValue
	movsd	QWORD PTR [rbx+26684], xmm0
	mov	eax, DWORD PTR repStartValue+8
	mov	DWORD PTR [rbx+26692], eax

; 1175 :     dctx->MLTptr = dctx->entropy.MLTable;

	lea	rax, QWORD PTR [rbx+6192]
	mov	QWORD PTR [rbx+8], rax

; 1176 :     dctx->OFTptr = dctx->entropy.OFTable;

	lea	rax, QWORD PTR [rbx+4136]
	mov	QWORD PTR [rbx+16], rax
	mov	QWORD PTR [rbx], r9

; 1177 :     dctx->HUFptr = dctx->entropy.hufTable;

	mov	QWORD PTR [rbx+24], rcx

; 1183 :     FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , "");
; 1184 :     if (dict && dictSize)

	test	rdx, rdx
	je	SHORT $LN8@ZSTD_decom
	test	r8, r8
	je	SHORT $LN8@ZSTD_decom

; 1139 :     if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);

	cmp	r8, 8
	jae	SHORT $LN18@ZSTD_decom
$LN34@ZSTD_decom:

; 1185 :         RETURN_ERROR_IF(
; 1186 :             ZSTD_isError(ZSTD_decompress_insertDictionary(dctx, dict, dictSize)),
; 1187 :             dictionary_corrupted, "");
; 1188 :     return 0;

	mov	QWORD PTR [rbx+28760], rdi
	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR [rbx+28752], rdi
$LN35@ZSTD_decom:
	mov	QWORD PTR [rbx+28744], rax
$LN8@ZSTD_decom:
	xor	eax, eax

; 1189 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@ZSTD_decom:

; 1141 :         if (magic != ZSTD_MAGIC_DICTIONARY) {

	cmp	DWORD PTR [rdx], -332356553		; ec30a437H
	jne	SHORT $LN34@ZSTD_decom

; 1142 :             return ZSTD_refDictContent(dctx, dict, dictSize);   /* pure content mode */
; 1143 :     }   }
; 1144 :     dctx->dictID = MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);

	mov	eax, DWORD PTR [rdx+4]

; 1145 : 
; 1146 :     /* load entropy tables */
; 1147 :     {   size_t const eSize = ZSTD_loadDEntropy(&dctx->entropy, dict, dictSize);

	mov	rcx, r9
	mov	DWORD PTR [rbx+29032], eax
	call	ZSTD_loadDEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1148 :         RETURN_ERROR_IF(ZSTD_isError(eSize), dictionary_corrupted, "");

	ja	SHORT $LN33@ZSTD_decom

; 1149 :         dict = (const char*)dict + eSize;

	lea	rdx, QWORD PTR [rax+rdi]

; 1150 :         dictSize -= eSize;
; 1151 :     }
; 1152 :     dctx->litEntropy = dctx->fseEntropy = 1;

	mov	DWORD PTR [rbx+28844], 1

; 1041 :     dctx->dictEnd = dctx->previousDstEnd;

	mov	rax, QWORD PTR [rbx+28744]

; 1042 :     dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rcx, rdx
	sub	rcx, rax
	mov	QWORD PTR [rbx+28768], rax
	add	rcx, QWORD PTR [rbx+28752]

; 1044 :     dctx->previousDstEnd = (const char*)dict + dictSize;

	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR [rbx+28760], rcx

; 1152 :     dctx->litEntropy = dctx->fseEntropy = 1;

	mov	DWORD PTR [rbx+28840], 1

; 1043 :     dctx->prefixStart = dict;

	mov	QWORD PTR [rbx+28752], rdx
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	jmp	SHORT $LN35@ZSTD_decom
$LN33@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1189 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, -30
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_decompressBegin_usingDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
ddict$ = 16
ZSTD_decompressBegin_usingDDict PROC

; 1195 : {

	mov	r10, rdx
	mov	r9, rcx

; 1196 :     DEBUGLOG(4, "ZSTD_decompressBegin_usingDDict");
; 1197 :     assert(dctx != NULL);
; 1198 :     if (ddict) {

	xor	edx, edx
	test	r10, r10
	je	SHORT $LN4@ZSTD_decom

; 1199 :         const char* const dictStart = (const char*)ZSTD_DDict_dictContent(ddict);
; 1200 :         size_t const dictSize = ZSTD_DDict_dictSize(ddict);
; 1201 :         const void* const dictEnd = dictStart + dictSize;

	mov	rax, QWORD PTR [r10+16]

; 1202 :         dctx->ddictIsCold = (dctx->dictEnd != dictEnd);

	mov	r8d, edx
	add	rax, QWORD PTR [r10+8]
	cmp	QWORD PTR [rcx+28768], rax
	setne	r8b
	mov	DWORD PTR [rcx+29036], r8d
$LN4@ZSTD_decom:

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	cmp	DWORD PTR [r9+28944], edx
	mov	ecx, 5

; 1164 :     dctx->previousDstEnd = NULL;

	mov	QWORD PTR [r9+28744], rdx

; 91   :     size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);

	mov	eax, 1
	cmove	eax, ecx

; 1165 :     dctx->prefixStart = NULL;

	mov	QWORD PTR [r9+28752], rdx
	mov	QWORD PTR [r9+28776], rax

; 1166 :     dctx->virtualStart = NULL;
; 1167 :     dctx->dictEnd = NULL;
; 1168 :     dctx->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */

	lea	rcx, QWORD PTR [r9+10296]
	mov	QWORD PTR [r9+28760], rdx
	mov	QWORD PTR [r9+28768], rdx
	mov	DWORD PTR [rcx], 201326604		; 0c00000cH

; 1169 :     dctx->litEntropy = dctx->fseEntropy = 0;

	mov	QWORD PTR [r9+28840], rdx

; 1170 :     dctx->dictID = 0;

	mov	DWORD PTR [r9+29032], edx

; 1171 :     dctx->bType = bt_reserved;

	mov	QWORD PTR [r9+28832], 3
	mov	QWORD PTR [r9+28824], rdx

; 1172 :     ZSTD_STATIC_ASSERT(sizeof(dctx->entropy.rep) == sizeof(repStartValue));
; 1173 :     memcpy(dctx->entropy.rep, repStartValue, sizeof(repStartValue));  /* initial repcodes */

	movsd	xmm0, QWORD PTR repStartValue
	movsd	QWORD PTR [r9+26684], xmm0
	mov	eax, DWORD PTR repStartValue+8
	mov	DWORD PTR [r9+26692], eax

; 1174 :     dctx->LLTptr = dctx->entropy.LLTable;

	lea	rax, QWORD PTR [r9+32]
	mov	QWORD PTR [r9], rax

; 1175 :     dctx->MLTptr = dctx->entropy.MLTable;

	lea	rax, QWORD PTR [r9+6192]
	mov	QWORD PTR [r9+8], rax

; 1176 :     dctx->OFTptr = dctx->entropy.OFTable;

	lea	rax, QWORD PTR [r9+4136]
	mov	QWORD PTR [r9+16], rax

; 1177 :     dctx->HUFptr = dctx->entropy.hufTable;

	mov	QWORD PTR [r9+24], rcx

; 1203 :         DEBUGLOG(4, "DDict is %s",
; 1204 :                     dctx->ddictIsCold ? "~cold~" : "hot!");
; 1205 :     }
; 1206 :     FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , "");
; 1207 :     if (ddict) {   /* NULL ddict is equivalent to no dictionary */

	test	r10, r10
	je	$LN21@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 63   :     dctx->dictID = ddict->dictID;

	mov	eax, DWORD PTR [r10+26688]
	mov	DWORD PTR [r9+29032], eax

; 64   :     dctx->prefixStart = ddict->dictContent;

	mov	rax, QWORD PTR [r10+8]
	mov	QWORD PTR [r9+28752], rax

; 65   :     dctx->virtualStart = ddict->dictContent;

	mov	rax, QWORD PTR [r10+8]
	mov	QWORD PTR [r9+28760], rax

; 66   :     dctx->dictEnd = (const BYTE*)ddict->dictContent + ddict->dictSize;

	mov	rdx, QWORD PTR [r10+16]
	add	rdx, QWORD PTR [r10+8]
	mov	QWORD PTR [r9+28768], rdx

; 67   :     dctx->previousDstEnd = dctx->dictEnd;

	mov	QWORD PTR [r9+28744], rdx

; 68   : #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 69   :     dctx->dictContentBeginForFuzzing = dctx->prefixStart;
; 70   :     dctx->dictContentEndForFuzzing = dctx->previousDstEnd;
; 71   : #endif
; 72   :     if (ddict->entropyPresent) {

	cmp	DWORD PTR [r10+26692], 0
	je	SHORT $LN21@ZSTD_decom

; 73   :         dctx->litEntropy = 1;

	mov	DWORD PTR [r9+28840], 1

; 74   :         dctx->fseEntropy = 1;
; 75   :         dctx->LLTptr = ddict->entropy.LLTable;

	lea	rax, QWORD PTR [r10+24]
	mov	QWORD PTR [r9], rax

; 76   :         dctx->MLTptr = ddict->entropy.MLTable;

	lea	rax, QWORD PTR [r10+6184]
	mov	DWORD PTR [r9+28844], 1
	mov	QWORD PTR [r9+8], rax

; 77   :         dctx->OFTptr = ddict->entropy.OFTable;

	lea	rax, QWORD PTR [r10+4128]
	mov	QWORD PTR [r9+16], rax

; 78   :         dctx->HUFptr = ddict->entropy.hufTable;

	lea	rax, QWORD PTR [r10+10288]
	mov	QWORD PTR [r9+24], rax

; 79   :         dctx->entropy.rep[0] = ddict->entropy.rep[0];

	mov	eax, DWORD PTR [r10+26676]
	mov	DWORD PTR [r9+26684], eax

; 80   :         dctx->entropy.rep[1] = ddict->entropy.rep[1];

	mov	eax, DWORD PTR [r10+26680]
	mov	DWORD PTR [r9+26688], eax

; 81   :         dctx->entropy.rep[2] = ddict->entropy.rep[2];

	mov	eax, DWORD PTR [r10+26684]
	mov	DWORD PTR [r9+26692], eax
$LN21@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1211 : }

	xor	eax, eax
	ret	0
ZSTD_decompressBegin_usingDDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zfp$ = 32
src$ = 96
srcSize$ = 104
ZSTD_getDictID_fromFrame PROC

; 1238 : {

$LN9:
	push	rbx
	sub	rsp, 80					; 00000050H

; 1239 :     ZSTD_frameHeader zfp = { 0, 0, 0, ZSTD_frame, 0, 0, 0 };

	xor	ebx, ebx

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	mov	r8, rdx
	mov	rdx, rcx

; 1239 :     ZSTD_frameHeader zfp = { 0, 0, 0, ZSTD_frame, 0, 0, 0 };

	mov	QWORD PTR zfp$[rsp], rbx

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	lea	rcx, QWORD PTR zfp$[rsp]

; 1239 :     ZSTD_frameHeader zfp = { 0, 0, 0, ZSTD_frame, 0, 0, 0 };

	mov	QWORD PTR zfp$[rsp+8], rbx

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	xor	r9d, r9d

; 1239 :     ZSTD_frameHeader zfp = { 0, 0, 0, ZSTD_frame, 0, 0, 0 };

	mov	QWORD PTR zfp$[rsp+16], rbx
	mov	QWORD PTR zfp$[rsp+24], rbx
	mov	DWORD PTR zfp$[rsp+32], ebx

; 328  :     return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);

	call	ZSTD_getFrameHeader_advanced

; 1241 :     if (ZSTD_isError(hError)) return 0;

	mov	ecx, DWORD PTR zfp$[rsp+28]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1241 :     if (ZSTD_isError(hError)) return 0;

	cmova	ecx, ebx
	mov	eax, ecx

; 1242 :     return zfp.dictID;
; 1243 : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
ZSTD_getDictID_fromFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
ddict$ = 120
ZSTD_decompress_usingDDict PROC

; 1253 : {

$LN4:
	sub	rsp, 72					; 00000048H

; 1254 :     /* pass content and size in case legacy frames are encountered */
; 1255 :     return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize,

	mov	rax, QWORD PTR ddict$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR srcSize$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_decompressMultiFrame

; 1256 :                                      NULL, 0,
; 1257 :                                      ddict);
; 1258 : }

	add	rsp, 72					; 00000048H
	ret	0
ZSTD_decompress_usingDDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 48
ddict$ = 56
ZSTD_DCtx_refDDict PROC

; 1370 : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1371 :     RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");

	cmp	DWORD PTR [rcx+29044], 0
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN2@ZSTD_DCtx_
	mov	rax, -60				; ffffffffffffffc4H

; 1376 :     }
; 1377 :     return 0;
; 1378 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@ZSTD_DCtx_:

; 1372 :     ZSTD_clearDict(dctx);

	call	ZSTD_clearDict

; 1373 :     if (ddict) {

	test	rdi, rdi
	je	SHORT $LN4@ZSTD_DCtx_

; 1374 :         dctx->ddict = ddict;

	mov	QWORD PTR [rbx+29024], rdi

; 1375 :         dctx->dictUses = ZSTD_use_indefinitely;

	mov	DWORD PTR [rbx+29040], -1
$LN4@ZSTD_DCtx_:

; 1376 :     }
; 1377 :     return 0;
; 1378 : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_DCtx_refDDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 8
dParam$ = 16
ZSTD_dParam_getBounds PROC

; 1402 :     ZSTD_bounds bounds = { 0, 0, 0 };

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 1403 :     switch(dParam) {

	sub	edx, 100				; 00000064H
	je	SHORT $LN4@ZSTD_dPara
	sub	edx, 900				; 00000384H
	je	SHORT $LN5@ZSTD_dPara
	cmp	edx, 1
	je	SHORT $LN5@ZSTD_dPara

; 1411 :             ZSTD_STATIC_ASSERT(ZSTD_f_zstd1 < ZSTD_f_zstd1_magicless);
; 1412 :             return bounds;
; 1413 :         case ZSTD_d_stableOutBuffer:
; 1414 :             bounds.lowerBound = (int)ZSTD_obm_buffered;
; 1415 :             bounds.upperBound = (int)ZSTD_obm_stable;
; 1416 :             return bounds;
; 1417 :         default:;
; 1418 :     }
; 1419 :     bounds.error = ERROR(parameter_unsupported);

	mov	QWORD PTR [rcx], -40			; ffffffffffffffd8H

; 1420 :     return bounds;
; 1421 : }

	mov	rax, rcx
	ret	0
$LN5@ZSTD_dPara:

; 1406 :             bounds.upperBound = ZSTD_WINDOWLOG_MAX;
; 1407 :             return bounds;
; 1408 :         case ZSTD_d_format:
; 1409 :             bounds.lowerBound = (int)ZSTD_f_zstd1;
; 1410 :             bounds.upperBound = (int)ZSTD_f_zstd1_magicless;

	mov	DWORD PTR [rcx+12], 1

; 1420 :     return bounds;
; 1421 : }

	mov	rax, rcx
	ret	0
$LN4@ZSTD_dPara:

; 1404 :         case ZSTD_d_windowLogMax:
; 1405 :             bounds.lowerBound = ZSTD_WINDOWLOG_ABSOLUTEMIN;

	mov	DWORD PTR [rcx+8], 10

; 1420 :     return bounds;
; 1421 : }

	mov	rax, rcx
	mov	DWORD PTR [rcx+12], 31
	ret	0
ZSTD_dParam_getBounds ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 0
dParam$ = 32
value$ = 40
ZSTD_dParam_withinBounds PROC

; 1427 : {

	sub	rsp, 24

; 1402 :     ZSTD_bounds bounds = { 0, 0, 0 };

	xor	r8d, r8d
	mov	QWORD PTR $T1[rsp+8], r8

; 1403 :     switch(dParam) {

	sub	ecx, 100				; 00000064H
	je	SHORT $LN9@ZSTD_dPara
	sub	ecx, 900				; 00000384H
	je	SHORT $LN10@ZSTD_dPara
	cmp	ecx, 1
	jne	SHORT $LN17@ZSTD_dPara
$LN10@ZSTD_dPara:

; 1428 :     ZSTD_bounds const bounds = ZSTD_dParam_getBounds(dParam);
; 1429 :     if (ZSTD_isError(bounds.error)) return 0;
; 1430 :     if (value < bounds.lowerBound) return 0;

	mov	DWORD PTR $T1[rsp+12], 1
	jmp	SHORT $LN18@ZSTD_dPara
$LN9@ZSTD_dPara:

; 1405 :             bounds.lowerBound = ZSTD_WINDOWLOG_ABSOLUTEMIN;

	mov	r8d, 10

; 1406 :             bounds.upperBound = ZSTD_WINDOWLOG_MAX;

	mov	DWORD PTR $T1[rsp+12], 31
$LN18@ZSTD_dPara:

; 1428 :     ZSTD_bounds const bounds = ZSTD_dParam_getBounds(dParam);
; 1429 :     if (ZSTD_isError(bounds.error)) return 0;
; 1430 :     if (value < bounds.lowerBound) return 0;

	mov	DWORD PTR $T1[rsp+8], r8d
	cmp	edx, r8d
	jl	SHORT $LN17@ZSTD_dPara

; 1431 :     if (value > bounds.upperBound) return 0;

	mov	rcx, QWORD PTR $T1[rsp+8]
	shr	rcx, 32					; 00000020H
	cmp	edx, ecx
	jg	SHORT $LN17@ZSTD_dPara

; 1432 :     return 1;

	mov	eax, 1

; 1433 : }

	add	rsp, 24
	ret	0
$LN17@ZSTD_dPara:

; 1431 :     if (value > bounds.upperBound) return 0;

	xor	eax, eax

; 1433 : }

	add	rsp, 24
	ret	0
ZSTD_dParam_withinBounds ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
$T3 = 0
dctx$ = 32
dParam$ = 40
value$ = 48
ZSTD_DCtx_setParameter PROC

; 1440 : {

$LN71:
	sub	rsp, 24

; 1441 :     RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");

	cmp	DWORD PTR [rcx+29044], 0
	mov	r9, rcx
	je	SHORT $LN7@ZSTD_DCtx_
	mov	rax, -60				; ffffffffffffffc4H

; 1459 : }

	add	rsp, 24
	ret	0
$LN7@ZSTD_DCtx_:

; 1442 :     switch(dParam) {

	sub	edx, 100				; 00000064H
	je	$LN9@ZSTD_DCtx_
	sub	edx, 900				; 00000384H
	je	SHORT $LN13@ZSTD_DCtx_
	cmp	edx, 1
	je	SHORT $LN16@ZSTD_DCtx_

; 1456 :         default:;
; 1457 :     }
; 1458 :     RETURN_ERROR(parameter_unsupported, "");

	mov	rax, -40				; ffffffffffffffd8H

; 1459 : }

	add	rsp, 24
	ret	0
$LN16@ZSTD_DCtx_:

; 1414 :             bounds.lowerBound = (int)ZSTD_obm_buffered;

	mov	DWORD PTR $T1[rsp+8], 0

; 1415 :             bounds.upperBound = (int)ZSTD_obm_stable;

	mov	eax, 1
	mov	DWORD PTR $T1[rsp+12], eax

; 1430 :     if (value < bounds.lowerBound) return 0;

	test	r8d, r8d
	js	$LN69@ZSTD_DCtx_

; 1431 :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T1[rsp+8]
	shr	rax, 32					; 00000020H
	cmp	r8d, eax
	jg	$LN69@ZSTD_DCtx_

; 1452 :         case ZSTD_d_stableOutBuffer:
; 1453 :             CHECK_DBOUNDS(ZSTD_d_stableOutBuffer, value);
; 1454 :             dctx->outBufferMode = (ZSTD_outBufferMode_e)value;
; 1455 :             return 0;

	mov	DWORD PTR [rcx+29144], r8d
	xor	eax, eax

; 1459 : }

	add	rsp, 24
	ret	0
$LN13@ZSTD_DCtx_:

; 1409 :             bounds.lowerBound = (int)ZSTD_f_zstd1;

	mov	DWORD PTR $T2[rsp+8], 0

; 1410 :             bounds.upperBound = (int)ZSTD_f_zstd1_magicless;

	mov	eax, 1
	mov	DWORD PTR $T2[rsp+12], eax

; 1430 :     if (value < bounds.lowerBound) return 0;

	test	r8d, r8d
	js	SHORT $LN69@ZSTD_DCtx_

; 1431 :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T2[rsp+8]
	shr	rax, 32					; 00000020H
	cmp	r8d, eax
	jg	SHORT $LN69@ZSTD_DCtx_

; 1448 :         case ZSTD_d_format:
; 1449 :             CHECK_DBOUNDS(ZSTD_d_format, value);
; 1450 :             dctx->format = (ZSTD_format_e)value;
; 1451 :             return 0;

	mov	DWORD PTR [rcx+28944], r8d
	xor	eax, eax

; 1459 : }

	add	rsp, 24
	ret	0
$LN9@ZSTD_DCtx_:

; 1402 :     ZSTD_bounds bounds = { 0, 0, 0 };

	test	r8d, r8d

; 1403 :     switch(dParam) {
; 1404 :         case ZSTD_d_windowLogMax:
; 1405 :             bounds.lowerBound = ZSTD_WINDOWLOG_ABSOLUTEMIN;

	mov	DWORD PTR $T3[rsp+8], 10
	mov	ecx, 27

; 1406 :             bounds.upperBound = ZSTD_WINDOWLOG_MAX;

	mov	DWORD PTR $T3[rsp+12], 31
	cmovne	ecx, r8d

; 1430 :     if (value < bounds.lowerBound) return 0;

	cmp	ecx, 10
	jl	SHORT $LN69@ZSTD_DCtx_

; 1431 :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T3[rsp+8]
	shr	rax, 32					; 00000020H
	cmp	ecx, eax
	jg	SHORT $LN69@ZSTD_DCtx_

; 1446 :             dctx->maxWindowSize = ((size_t)1) << value;

	mov	eax, 1
	shl	rax, cl
	mov	QWORD PTR [r9+29072], rax

; 1447 :             return 0;

	xor	eax, eax

; 1459 : }

	add	rsp, 24
	ret	0
$LN69@ZSTD_DCtx_:

; 1443 :         case ZSTD_d_windowLogMax:
; 1444 :             if (value == 0) value = ZSTD_WINDOWLOG_LIMIT_DEFAULT;
; 1445 :             CHECK_DBOUNDS(ZSTD_d_windowLogMax, value);

	mov	rax, -42				; ffffffffffffffd6H

; 1459 : }

	add	rsp, 24
	ret	0
ZSTD_DCtx_setParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
dctx$ = 8
reset$dead$ = 16
ZSTD_DCtx_reset PROC

; 1463 :     if ( (reset == ZSTD_reset_session_only)
; 1464 :       || (reset == ZSTD_reset_session_and_parameters) ) {
; 1465 :         dctx->streamStage = zdss_init;

	xor	eax, eax
	mov	DWORD PTR [rcx+29044], eax

; 1466 :         dctx->noForwardProgress = 0;

	mov	DWORD PTR [rcx+29140], eax

; 1467 :     }
; 1468 :     if ( (reset == ZSTD_reset_parameters)
; 1469 :       || (reset == ZSTD_reset_session_and_parameters) ) {
; 1470 :         RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");
; 1471 :         ZSTD_clearDict(dctx);
; 1472 :         dctx->format = ZSTD_f_zstd1;
; 1473 :         dctx->maxWindowSize = ZSTD_MAXWINDOWSIZE_DEFAULT;
; 1474 :     }
; 1475 :     return 0;
; 1476 : }

	ret	0
ZSTD_DCtx_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
windowSize$ = 8
frameContentSize$ = 16
ZSTD_decodingBufferSize_min PROC

; 1486 :     size_t const blockSize = (size_t) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);

	mov	eax, 131072				; 00020000H
	cmp	rcx, rax
	cmovb	rax, rcx

; 1487 :     unsigned long long const neededRBSize = windowSize + blockSize + (WILDCOPY_OVERLENGTH * 2);

	add	rax, 64					; 00000040H
	add	rax, rcx

; 1488 :     unsigned long long const neededSize = MIN(frameContentSize, neededRBSize);

	cmp	rdx, rax
	cmovb	rax, rdx

; 1489 :     size_t const minRBSize = (size_t) neededSize;
; 1490 :     RETURN_ERROR_IF((unsigned long long)minRBSize != neededSize,
; 1491 :                     frameParameter_windowTooLarge, "");
; 1492 :     return minRBSize;
; 1493 : }

	ret	0
ZSTD_decodingBufferSize_min ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zds$ = 8
neededInBuffSize$ = 16
neededOutBuffSize$ = 24
ZSTD_DCtx_isOverflow PROC

; 1520 :     return (zds->inBuffSize + zds->outBuffSize) >= (neededInBuffSize + neededOutBuffSize) * ZSTD_WORKSPACETOOLARGE_FACTOR;

	mov	r9, QWORD PTR [rcx+29088]
	lea	rax, QWORD PTR [rdx+r8]
	add	r9, QWORD PTR [rcx+29056]
	lea	rcx, QWORD PTR [rax+rax*2]
	xor	eax, eax
	cmp	r9, rcx
	setae	al

; 1521 : }

	ret	0
ZSTD_DCtx_isOverflow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zds$ = 8
neededInBuffSize$ = 16
neededOutBuffSize$ = 24
ZSTD_DCtx_updateOversizedDuration PROC

; 1520 :     return (zds->inBuffSize + zds->outBuffSize) >= (neededInBuffSize + neededOutBuffSize) * ZSTD_WORKSPACETOOLARGE_FACTOR;

	mov	r9, QWORD PTR [rcx+29088]
	lea	rax, QWORD PTR [rdx+r8]
	add	r9, QWORD PTR [rcx+29056]
	lea	rdx, QWORD PTR [rax+rax*2]
	cmp	r9, rdx

; 1525 :     if (ZSTD_DCtx_isOverflow(zds, neededInBuffSize, neededOutBuffSize))

	jb	SHORT $LN2@ZSTD_DCtx_

; 1526 :         zds->oversizedDuration++;

	inc	QWORD PTR [rcx+160304]

; 1529 : }

	ret	0
$LN2@ZSTD_DCtx_:

; 1527 :     else 
; 1528 :         zds->oversizedDuration = 0;

	mov	QWORD PTR [rcx+160304], 0

; 1529 : }

	ret	0
ZSTD_DCtx_updateOversizedDuration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zds$ = 8
ZSTD_DCtx_isOversizedTooLong PROC

; 1533 :     return zds->oversizedDuration >= ZSTD_WORKSPACETOOLARGE_MAXDURATION;

	xor	eax, eax
	cmp	QWORD PTR [rcx+160304], 128		; 00000080H
	setae	al

; 1534 : }

	ret	0
ZSTD_DCtx_isOversizedTooLong ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
expect$ = 0
zds$ = 48
output$ = 56
ZSTD_checkOutBuffer PROC

; 1538 : {

	sub	rsp, 40					; 00000028H

; 1539 :     ZSTD_outBuffer const expect = zds->expectedOutBuffer;
; 1540 :     /* No requirement when ZSTD_obm_stable is not enabled. */
; 1541 :     if (zds->outBufferMode != ZSTD_obm_stable)

	cmp	DWORD PTR [rcx+29144], 1
	movups	xmm0, XMMWORD PTR [rcx+29152]
	movsd	xmm1, QWORD PTR [rcx+29168]
	movups	XMMWORD PTR expect$[rsp], xmm0
	movsd	QWORD PTR expect$[rsp+16], xmm1
	jne	SHORT $LN10@ZSTD_check

; 1542 :         return 0;
; 1543 :     /* Any buffer is allowed in zdss_init, this must be the same for every other call until
; 1544 :      * the context is reset.
; 1545 :      */
; 1546 :     if (zds->streamStage == zdss_init)

	cmp	DWORD PTR [rcx+29044], 0
	je	SHORT $LN10@ZSTD_check

; 1547 :         return 0;
; 1548 :     /* The buffer must match our expectation exactly. */
; 1549 :     if (expect.dst == output->dst && expect.pos == output->pos && expect.size == output->size)

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR expect$[rsp], rax
	jne	SHORT $LN4@ZSTD_check
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR expect$[rsp+16], rax
	jne	SHORT $LN4@ZSTD_check
	mov	rax, QWORD PTR [rdx+8]
	cmp	QWORD PTR expect$[rsp+8], rax
	je	SHORT $LN10@ZSTD_check
$LN4@ZSTD_check:

; 1551 :     RETURN_ERROR(dstBuffer_wrong, "ZSTD_obm_stable enabled but output differs!");

	mov	rax, -104				; ffffffffffffff98H

; 1552 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@ZSTD_check:

; 1550 :         return 0;

	xor	eax, eax

; 1552 : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_checkOutBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
zds$ = 64
op$ = 72
oend$ = 80
src$ = 88
srcSize$ = 96
ZSTD_decompressContinueStream PROC

; 1561 :             void const* src, size_t srcSize) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 1562 :     int const isSkipFrame = ZSTD_isSkipFrame(zds);
; 1563 :     if (zds->outBufferMode == ZSTD_obm_buffered) {

	cmp	DWORD PTR [rcx+29144], 0
	mov	rdi, rdx

; 882  : static int ZSTD_isSkipFrame(ZSTD_DCtx* dctx) { return dctx->stage == ZSTDds_skipFrame; }

	mov	esi, DWORD PTR [rcx+28836]

; 1561 :             void const* src, size_t srcSize) {

	mov	rbx, rcx

; 1562 :     int const isSkipFrame = ZSTD_isSkipFrame(zds);
; 1563 :     if (zds->outBufferMode == ZSTD_obm_buffered) {

	jne	SHORT $LN8@ZSTD_decom

; 1564 :         size_t const dstSize = isSkipFrame ? 0 : zds->outBuffSize - zds->outStart;

	mov	rcx, QWORD PTR [rcx+29096]
	cmp	esi, 7
	jne	SHORT $LN17@ZSTD_decom
	xor	r8d, r8d
	jmp	SHORT $LN18@ZSTD_decom
$LN17@ZSTD_decom:
	mov	r8, QWORD PTR [rbx+29088]
	sub	r8, rcx
$LN18@ZSTD_decom:

; 1565 :         size_t const decodedSize = ZSTD_decompressContinue(zds,

	mov	rdx, QWORD PTR [rbx+29080]
	mov	rax, QWORD PTR srcSize$[rsp]
	add	rdx, rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_decompressContinue
	mov	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1567 :         FORWARD_IF_ERROR(decodedSize, "");

	ja	SHORT $LN1@ZSTD_decom

; 1568 :         if (!decodedSize && !isSkipFrame) {

	test	rax, rax
	jne	SHORT $LN12@ZSTD_decom
	cmp	esi, 7
	jne	SHORT $LN27@ZSTD_decom
$LN12@ZSTD_decom:

; 1569 :             zds->streamStage = zdss_read;
; 1570 :         } else {
; 1571 :             zds->outEnd = zds->outStart + decodedSize;

	add	rcx, QWORD PTR [rbx+29096]

; 1572 :             zds->streamStage = zdss_flush;

	mov	eax, 4
	mov	QWORD PTR [rbx+29104], rcx

; 1573 :         }
; 1574 :     } else {

	jmp	SHORT $LN9@ZSTD_decom
$LN8@ZSTD_decom:

; 1575 :         /* Write directly into the output buffer */
; 1576 :         size_t const dstSize = isSkipFrame ? 0 : oend - *op;

	mov	rdx, QWORD PTR [rdx]
	cmp	esi, 7
	jne	SHORT $LN19@ZSTD_decom
	xor	r8d, r8d
	jmp	SHORT $LN20@ZSTD_decom
$LN19@ZSTD_decom:
	sub	r8, rdx
$LN20@ZSTD_decom:

; 1577 :         size_t const decodedSize = ZSTD_decompressContinue(zds, *op, dstSize, src, srcSize);

	mov	rax, QWORD PTR srcSize$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_decompressContinue
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1578 :         FORWARD_IF_ERROR(decodedSize, "");

	ja	SHORT $LN1@ZSTD_decom

; 1579 :         *op += decodedSize;

	add	QWORD PTR [rdi], rax
$LN27@ZSTD_decom:

; 1580 :         /* Flushing is not needed. */
; 1581 :         zds->streamStage = zdss_read;
; 1582 :         assert(*op <= oend);
; 1583 :         assert(zds->outBufferMode == ZSTD_obm_stable);
; 1584 :     }
; 1585 :     return 0;

	mov	eax, 2
$LN9@ZSTD_decom:
	mov	DWORD PTR [rbx+29044], eax
	xor	eax, eax
$LN1@ZSTD_decom:

; 1586 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ZSTD_decompressContinueStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c
_TEXT	SEGMENT
tv1837 = 64
tv1840 = 72
op$1$ = 80
op$ = 88
tv1838 = 96
$T1 = 112
$T2 = 144
$T3 = 176
zds$ = 256
output$ = 264
input$ = 272
tv1839 = 280
ZSTD_decompressStream PROC

; 1589 : {

$LN231:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR [r8]
	mov	r10, rdx

; 1590 :     const char* const src = (const char*)input->src;
; 1591 :     const char* const istart = input->pos != 0 ? src + input->pos : src;

	mov	r9, QWORD PTR [r8+16]
	mov	rbx, rcx

; 1592 :     const char* const iend = input->size != 0 ? src + input->size : src;

	mov	rcx, QWORD PTR [r8+8]
	test	r9, r9

; 1593 :     const char* ip = istart;
; 1594 :     char* const dst = (char*)output->dst;
; 1595 :     char* const ostart = output->pos != 0 ? dst + output->pos : dst;
; 1596 :     char* const oend = output->size != 0 ? dst + output->size : dst;

	mov	r8, QWORD PTR [r10+8]
	lea	rdi, QWORD PTR [r9+rax]
	cmove	rdi, rax
	lea	rsi, QWORD PTR [rcx+rax]
	test	rcx, rcx
	mov	QWORD PTR tv1840[rsp], rdi
	mov	r13, rdi
	cmove	rsi, rax
	mov	rax, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [rdx+16]
	test	rdx, rdx
	mov	QWORD PTR tv1839[rsp], rsi

; 1597 :     char* op = ostart;

	lea	r12, QWORD PTR [r8+rax]
	lea	r11, QWORD PTR [rdx+rax]
	cmove	r11, rax
	test	r8, r8
	mov	QWORD PTR tv1838[rsp], r11
	mov	rbp, r11
	cmove	r12, rax
	mov	QWORD PTR op$1$[rsp], r11
	mov	QWORD PTR tv1837[rsp], r12
	mov	QWORD PTR op$[rsp], r11

; 1598 :     U32 someMoreWork = 1;
; 1599 : 
; 1600 :     DEBUGLOG(5, "ZSTD_decompressStream");
; 1601 :     RETURN_ERROR_IF(

	cmp	r9, rcx
	ja	$LN214@ZSTD_decom

; 1602 :         input->pos > input->size,
; 1603 :         srcSize_wrong,
; 1604 :         "forbidden. in: pos: %u   vs size: %u",
; 1605 :         (U32)input->pos, (U32)input->size);
; 1606 :     RETURN_ERROR_IF(

	cmp	rdx, r8
	ja	$LN213@ZSTD_decom

; 1612 :     FORWARD_IF_ERROR(ZSTD_checkOutBuffer(zds, output), "");

	mov	rdx, r10
	mov	rcx, rbx
	call	ZSTD_checkOutBuffer
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1612 :     FORWARD_IF_ERROR(ZSTD_checkOutBuffer(zds, output), "");

	ja	$LN1@ZSTD_decom
	xor	r14d, r14d
$LN227@ZSTD_decom:

; 1615 :         switch(zds->streamStage)

	mov	r15d, 2
$LN228@ZSTD_decom:
	mov	r9d, 3
	lea	r8d, QWORD PTR [r9-2]
	npad	6
$LL5@ZSTD_decom:
	mov	ecx, DWORD PTR [rbx+29044]
	test	ecx, ecx
	je	$LN33@ZSTD_decom
	sub	ecx, 1
	je	$LN34@ZSTD_decom
	sub	ecx, 1
	je	$LN60@ZSTD_decom
	sub	ecx, 1
	je	$LN66@ZSTD_decom
	cmp	ecx, 1
	jne	$LN26@ZSTD_decom

; 1802 :                 /* Function modifies the stage so we must break */
; 1803 :                 break;
; 1804 :             }
; 1805 :         case zdss_flush:
; 1806 :             {   size_t const toFlushSize = zds->outEnd - zds->outStart;

	mov	rcx, QWORD PTR [rbx+29096]

; 1807 :                 size_t const flushedSize = ZSTD_limitCopy(op, oend-op, zds->outBuff + zds->outStart, toFlushSize);

	mov	rax, r12
	mov	rsi, QWORD PTR [rbx+29104]
	sub	rax, rbp
	sub	rsi, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 306  :     size_t const length = MIN(dstCapacity, srcSize);

	cmp	rax, rsi
	mov	rdi, rsi
	cmovb	rdi, rax

; 307  :     if (length > 0) {

	test	rdi, rdi
	je	SHORT $LN178@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1807 :                 size_t const flushedSize = ZSTD_limitCopy(op, oend-op, zds->outBuff + zds->outStart, toFlushSize);

	mov	rdx, QWORD PTR [rbx+29080]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 308  :         memcpy(dst, src, length);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1807 :                 size_t const flushedSize = ZSTD_limitCopy(op, oend-op, zds->outBuff + zds->outStart, toFlushSize);

	add	rdx, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 308  :         memcpy(dst, src, length);

	mov	rcx, rbp
	call	memcpy
	mov	rcx, QWORD PTR [rbx+29096]
	mov	r8d, 1
	mov	r10, QWORD PTR output$[rsp]
	lea	r9d, QWORD PTR [r8+2]
$LN178@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1808 :                 op += flushedSize;

	add	rbp, rdi

; 1809 :                 zds->outStart += flushedSize;

	lea	rdx, QWORD PTR [rdi+rcx]

; 1810 :                 if (flushedSize == toFlushSize) {  /* flush completed */

	cmp	rdi, rsi
	mov	QWORD PTR op$1$[rsp], rbp
	mov	rsi, QWORD PTR tv1839[rsp]
	mov	QWORD PTR op$[rsp], rbp
	mov	QWORD PTR [rbx+29096], rdx
	jne	$LN226@ZSTD_decom

; 1811 :                     zds->streamStage = zdss_read;
; 1812 :                     if ( (zds->outBuffSize < zds->fParams.frameContentSize)
; 1813 :                       && (zds->outStart + zds->fParams.blockSizeMax > zds->outBuffSize) ) {

	mov	rcx, QWORD PTR [rbx+29088]
	mov	DWORD PTR [rbx+29044], r15d
	cmp	rcx, QWORD PTR [rbx+28784]
	jae	$LL5@ZSTD_decom
	mov	eax, DWORD PTR [rbx+28800]
	add	rax, rdx
	cmp	rax, rcx
	jbe	$LL5@ZSTD_decom

; 1814 :                         DEBUGLOG(5, "restart filling outBuff from beginning (left:%i, needed:%u)",
; 1815 :                                 (int)(zds->outBuffSize - zds->outStart),
; 1816 :                                 (U32)zds->fParams.blockSizeMax);
; 1817 :                         zds->outStart = zds->outEnd = 0;

	mov	QWORD PTR [rbx+29104], r14
	mov	QWORD PTR [rbx+29096], r14

; 1818 :                     }
; 1819 :                     break;

	jmp	$LL5@ZSTD_decom
$LN33@ZSTD_decom:

; 1616 :         {
; 1617 :         case zdss_init :
; 1618 :             DEBUGLOG(5, "stage zdss_init => transparent reset ");
; 1619 :             zds->streamStage = zdss_loadHeader;
; 1620 :             zds->lhSize = zds->inPos = zds->outStart = zds->outEnd = 0;
; 1621 :             zds->legacyVersion = 0;
; 1622 :             zds->hostageByte = 0;
; 1623 :             zds->expectedOutBuffer = *output;

	movups	xmm0, XMMWORD PTR [r10]
	mov	DWORD PTR [rbx+29044], r8d
	movsd	xmm1, QWORD PTR [r10+16]
	movups	XMMWORD PTR [rbx+29152], xmm0
	mov	QWORD PTR [rbx+29104], r14
	movsd	QWORD PTR [rbx+29168], xmm1
	mov	QWORD PTR [rbx+29096], r14
	mov	QWORD PTR [rbx+29064], r14
	mov	QWORD PTR [rbx+29112], r14
	mov	QWORD PTR [rbx+29132], r14
$LN34@ZSTD_decom:

; 1624 :             /* fall-through */
; 1625 : 
; 1626 :         case zdss_loadHeader :
; 1627 :             DEBUGLOG(5, "stage zdss_loadHeader (srcSize : %u)", (U32)(iend - ip));
; 1628 : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
; 1629 :             if (zds->legacyVersion) {
; 1630 :                 RETURN_ERROR_IF(zds->staticSize, memory_allocation,
; 1631 :                     "legacy support is incompatible with static dctx");
; 1632 :                 {   size_t const hint = ZSTD_decompressLegacyStream(zds->legacyContext, zds->legacyVersion, output, input);
; 1633 :                     if (hint==0) zds->streamStage = zdss_init;
; 1634 :                     return hint;
; 1635 :             }   }
; 1636 : #endif
; 1637 :             {   size_t const hSize = ZSTD_getFrameHeader_advanced(&zds->fParams, zds->headerBuffer, zds->lhSize, zds->format);

	mov	r9d, DWORD PTR [rbx+28944]
	lea	rdx, QWORD PTR [rbx+160280]
	mov	r8, QWORD PTR [rbx+29112]
	lea	rcx, QWORD PTR [rbx+28784]
	call	ZSTD_getFrameHeader_advanced
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1639 :                 if (ZSTD_isError(hSize)) {

	ja	$LN1@ZSTD_decom

; 1640 : #if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
; 1641 :                     U32 const legacyVersion = ZSTD_isLegacy(istart, iend-istart);
; 1642 :                     if (legacyVersion) {
; 1643 :                         ZSTD_DDict const* const ddict = ZSTD_getDDict(zds);
; 1644 :                         const void* const dict = ddict ? ZSTD_DDict_dictContent(ddict) : NULL;
; 1645 :                         size_t const dictSize = ddict ? ZSTD_DDict_dictSize(ddict) : 0;
; 1646 :                         DEBUGLOG(5, "ZSTD_decompressStream: detected legacy version v0.%u", legacyVersion);
; 1647 :                         RETURN_ERROR_IF(zds->staticSize, memory_allocation,
; 1648 :                             "legacy support is incompatible with static dctx");
; 1649 :                         FORWARD_IF_ERROR(ZSTD_initLegacyStream(&zds->legacyContext,
; 1650 :                                     zds->previousLegacyVersion, legacyVersion,
; 1651 :                                     dict, dictSize), "");
; 1652 :                         zds->legacyVersion = zds->previousLegacyVersion = legacyVersion;
; 1653 :                         {   size_t const hint = ZSTD_decompressLegacyStream(zds->legacyContext, legacyVersion, output, input);
; 1654 :                             if (hint==0) zds->streamStage = zdss_init;   /* or stay in stage zdss_loadHeader */
; 1655 :                             return hint;
; 1656 :                     }   }
; 1657 : #endif
; 1658 :                     return hSize;   /* error */
; 1659 :                 }
; 1660 :                 if (hSize != 0) {   /* need more input */

	test	rax, rax
	je	SHORT $LN36@ZSTD_decom

; 1661 :                     size_t const toLoad = hSize - zds->lhSize;   /* if hSize!=0, hSize > zds->lhSize */

	mov	rcx, QWORD PTR [rbx+29112]
	mov	rbp, rax
	sub	rbp, rcx

; 1662 :                     size_t const remainingInput = (size_t)(iend-ip);

	sub	rsi, r13

; 1663 :                     assert(iend >= ip);
; 1664 :                     if (toLoad > remainingInput) {   /* not enough input to load full header */

	cmp	rbp, rsi
	ja	$LN193@ZSTD_decom

; 1671 :                     }
; 1672 :                     assert(ip != NULL);
; 1673 :                     memcpy(zds->headerBuffer + zds->lhSize, ip, toLoad); zds->lhSize = hSize; ip += toLoad;

	add	rcx, 160280				; 00027218H
	mov	r8, rbp
	add	rcx, rbx
	mov	rdx, r13
	call	memcpy

; 1674 :                     break;

	mov	rsi, QWORD PTR tv1839[rsp]
	add	r13, rbp
	mov	rbp, QWORD PTR op$1$[rsp]
	mov	r12, QWORD PTR tv1837[rsp]
	mov	r10, QWORD PTR output$[rsp]
	mov	QWORD PTR [rbx+29112], rdi
	jmp	$LN227@ZSTD_decom
$LN36@ZSTD_decom:

; 1675 :             }   }
; 1676 : 
; 1677 :             /* check for single-pass mode opportunity */
; 1678 :             if (zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
; 1679 :                 && zds->fParams.frameType != ZSTD_skippableFrame
; 1680 :                 && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {

	mov	rcx, QWORD PTR [rbx+28784]
	mov	rdx, QWORD PTR tv1837[rsp]
	cmp	rcx, -1
	je	SHORT $LN40@ZSTD_decom
	cmp	DWORD PTR [rbx+28804], 1
	je	SHORT $LN40@ZSTD_decom
	mov	rax, rdx
	sub	rax, rbp
	cmp	rax, rcx
	jb	SHORT $LN40@ZSTD_decom

; 534  :     ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);

	mov	rdx, QWORD PTR tv1840[rsp]
	lea	rcx, QWORD PTR $T3[rsp]

; 1681 :                 size_t const cSize = ZSTD_findFrameCompressedSize(istart, iend-istart);

	mov	rdi, rsi
	sub	rdi, QWORD PTR tv1840[rsp]

; 534  :     ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);

	mov	r8, rdi
	call	ZSTD_findFrameSizeInfo

; 1681 :                 size_t const cSize = ZSTD_findFrameCompressedSize(istart, iend-istart);

	mov	rsi, QWORD PTR [rax]

; 1682 :                 if (cSize <= (size_t)(iend-istart)) {

	cmp	rsi, rdi
	jbe	$LN207@ZSTD_decom

; 1675 :             }   }
; 1676 : 
; 1677 :             /* check for single-pass mode opportunity */
; 1678 :             if (zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
; 1679 :                 && zds->fParams.frameType != ZSTD_skippableFrame
; 1680 :                 && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {

	mov	rdx, QWORD PTR tv1837[rsp]
$LN40@ZSTD_decom:

; 1693 :             }   }
; 1694 : 
; 1695 :             /* Check output buffer is large enough for ZSTD_odm_stable. */
; 1696 :             if (zds->outBufferMode == ZSTD_obm_stable
; 1697 :                 && zds->fParams.frameType != ZSTD_skippableFrame
; 1698 :                 && zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
; 1699 :                 && (U64)(size_t)(oend-op) < zds->fParams.frameContentSize) {

	cmp	DWORD PTR [rbx+29144], 1
	jne	SHORT $LN10@ZSTD_decom
	cmp	DWORD PTR [rbx+28804], 1
	je	SHORT $LN10@ZSTD_decom
	mov	rcx, QWORD PTR [rbx+28784]
	cmp	rcx, -1
	je	SHORT $LN10@ZSTD_decom
	mov	rax, rdx
	sub	rax, rbp
	cmp	rax, rcx
	jb	$LN213@ZSTD_decom
$LN10@ZSTD_decom:

; 798  :     switch (dctx->dictUses) {

	mov	eax, DWORD PTR [rbx+29040]
	cmp	eax, -1
	je	SHORT $LN135@ZSTD_decom
	cmp	eax, 1
	jne	SHORT $LN134@ZSTD_decom

; 805  :     case ZSTD_use_indefinitely:
; 806  :         return dctx->ddict;
; 807  :     case ZSTD_use_once:
; 808  :         dctx->dictUses = ZSTD_dont_use;

	mov	DWORD PTR [rbx+29040], r14d
$LN135@ZSTD_decom:

; 1705 :             FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(zds, ZSTD_getDDict(zds)), "");

	mov	rdx, QWORD PTR [rbx+29024]
$LN130@ZSTD_decom:
	mov	rcx, rbx
	call	ZSTD_decompressBegin_usingDDict
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1705 :             FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(zds, ZSTD_getDDict(zds)), "");

	ja	$LN1@ZSTD_decom

; 1706 : 
; 1707 :             if ((MEM_readLE32(zds->headerBuffer) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {  /* skippable frame */

	mov	eax, DWORD PTR [rbx+160280]
	and	eax, -16				; fffffff0H
	cmp	eax, 407710288				; 184d2a50H
	jne	SHORT $LN17@ZSTD_decom

; 1708 :                 zds->expected = MEM_readLE32(zds->headerBuffer + ZSTD_FRAMEIDSIZE);

	mov	ecx, DWORD PTR [rbx+160284]

; 1709 :                 zds->stage = ZSTDds_skipFrame;

	mov	eax, 7

; 1710 :             } else {

	lea	r15d, QWORD PTR [rax-5]
	jmp	SHORT $LN47@ZSTD_decom
$LN134@ZSTD_decom:

; 803  :         ZSTD_clearDict(dctx);

	mov	rcx, rbx
	call	ZSTD_clearDict

; 804  :         return NULL;

	mov	rdx, r14
	jmp	SHORT $LN130@ZSTD_decom
$LN17@ZSTD_decom:

; 1711 :                 FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(zds, zds->headerBuffer, zds->lhSize), "");

	mov	r8, QWORD PTR [rbx+29112]
	lea	rdx, QWORD PTR [rbx+160280]
	mov	rcx, rbx
	call	ZSTD_decodeFrameHeader
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1711 :                 FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(zds, zds->headerBuffer, zds->lhSize), "");

	ja	$LN1@ZSTD_decom

; 1712 :                 zds->expected = ZSTD_blockHeaderSize;
; 1713 :                 zds->stage = ZSTDds_decodeBlockHeader;

	mov	r15d, 2
	mov	ecx, 3
	mov	eax, r15d
$LN47@ZSTD_decom:

; 1714 :             }
; 1715 : 
; 1716 :             /* control buffer memory usage */
; 1717 :             DEBUGLOG(4, "Control max memory usage (%u KB <= max %u KB)",
; 1718 :                         (U32)(zds->fParams.windowSize >>10),
; 1719 :                         (U32)(zds->maxWindowSize >> 10) );
; 1720 :             zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);

	mov	QWORD PTR [rbx+28776], rcx
	mov	edx, 1024				; 00000400H
	mov	DWORD PTR [rbx+28836], eax
	mov	rax, QWORD PTR [rbx+28792]
	cmp	rax, rdx
	cmova	rdx, rax
	mov	QWORD PTR [rbx+28792], rdx

; 1721 :             RETURN_ERROR_IF(zds->fParams.windowSize > zds->maxWindowSize,

	cmp	rdx, QWORD PTR [rbx+29072]
	ja	$LN198@ZSTD_decom

; 1722 :                             frameParameter_windowTooLarge, "");
; 1723 : 
; 1724 :             /* Adapt buffer sizes to frame header instructions */
; 1725 :             {   size_t const neededInBuffSize = MAX(zds->fParams.blockSizeMax, 4 /* frame checksum */);

	mov	ecx, DWORD PTR [rbx+28800]
	mov	ebp, 4
	cmp	ecx, ebp
	cmova	ebp, ecx

; 1726 :                 size_t const neededOutBuffSize = zds->outBufferMode == ZSTD_obm_buffered

	cmp	DWORD PTR [rbx+29144], r14d
	jne	SHORT $LN106@ZSTD_decom

; 1486 :     size_t const blockSize = (size_t) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);

	mov	eax, 131072				; 00020000H

; 1487 :     unsigned long long const neededRBSize = windowSize + blockSize + (WILDCOPY_OVERLENGTH * 2);

	lea	rdi, QWORD PTR [rdx+64]
	cmp	rdx, rax
	cmovb	rax, rdx
	add	rdi, rax

; 1488 :     unsigned long long const neededSize = MIN(frameContentSize, neededRBSize);

	cmp	QWORD PTR [rbx+28784], rdi
	cmovb	rdi, QWORD PTR [rbx+28784]

; 1489 :     size_t const minRBSize = (size_t) neededSize;
; 1490 :     RETURN_ERROR_IF((unsigned long long)minRBSize != neededSize,
; 1491 :                     frameParameter_windowTooLarge, "");
; 1492 :     return minRBSize;
; 1493 : }

	jmp	SHORT $LN107@ZSTD_decom
$LN106@ZSTD_decom:

; 1726 :                 size_t const neededOutBuffSize = zds->outBufferMode == ZSTD_obm_buffered

	mov	rdi, r14
$LN107@ZSTD_decom:

; 1520 :     return (zds->inBuffSize + zds->outBuffSize) >= (neededInBuffSize + neededOutBuffSize) * ZSTD_WORKSPACETOOLARGE_FACTOR;

	mov	r8, QWORD PTR [rbx+29088]
	lea	rsi, QWORD PTR [rdi+rbp]
	mov	rdx, QWORD PTR [rbx+29056]
	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	rcx, QWORD PTR [r8+rdx]
	cmp	rcx, rax

; 1525 :     if (ZSTD_DCtx_isOverflow(zds, neededInBuffSize, neededOutBuffSize))

	jb	SHORT $LN147@ZSTD_decom

; 1526 :         zds->oversizedDuration++;

	inc	QWORD PTR [rbx+160304]
	mov	rax, QWORD PTR [rbx+160304]
	jmp	SHORT $LN148@ZSTD_decom
$LN147@ZSTD_decom:

; 1527 :     else 
; 1528 :         zds->oversizedDuration = 0;

	mov	QWORD PTR [rbx+160304], r14
	mov	rax, r14
$LN148@ZSTD_decom:

; 1727 :                         ? ZSTD_decodingBufferSize_min(zds->fParams.windowSize, zds->fParams.frameContentSize)
; 1728 :                         : 0;
; 1729 : 
; 1730 :                 ZSTD_DCtx_updateOversizedDuration(zds, neededInBuffSize, neededOutBuffSize);
; 1731 : 
; 1732 :                 {   int const tooSmall = (zds->inBuffSize < neededInBuffSize) || (zds->outBuffSize < neededOutBuffSize);

	cmp	rdx, rbp
	jb	SHORT $LN53@ZSTD_decom
	cmp	r8, rdi
	jb	SHORT $LN53@ZSTD_decom

; 1533 :     return zds->oversizedDuration >= ZSTD_WORKSPACETOOLARGE_MAXDURATION;

	cmp	rax, 128				; 00000080H

; 1733 :                     int const tooLarge = ZSTD_DCtx_isOversizedTooLong(zds);
; 1734 :                     
; 1735 :                     if (tooSmall || tooLarge) {

	jb	$LN52@ZSTD_decom
$LN53@ZSTD_decom:

; 1736 :                         size_t const bufferSize = neededInBuffSize + neededOutBuffSize;
; 1737 :                         DEBUGLOG(4, "inBuff  : from %u to %u",
; 1738 :                                     (U32)zds->inBuffSize, (U32)neededInBuffSize);
; 1739 :                         DEBUGLOG(4, "outBuff : from %u to %u",
; 1740 :                                     (U32)zds->outBuffSize, (U32)neededOutBuffSize);
; 1741 :                         if (zds->staticSize) {  /* static DCtx */

	mov	rax, QWORD PTR [rbx+29000]
	test	rax, rax
	je	SHORT $LN54@ZSTD_decom

; 1742 :                             DEBUGLOG(4, "staticSize : %u", (U32)zds->staticSize);
; 1743 :                             assert(zds->staticSize >= sizeof(ZSTD_DCtx));  /* controlled at init */
; 1744 :                             RETURN_ERROR_IF(

	add	rax, -160312				; fffffffffffd8dc8H
	cmp	rsi, rax
	ja	$LN200@ZSTD_decom

; 1745 :                                 bufferSize > zds->staticSize - sizeof(ZSTD_DCtx),
; 1746 :                                 memory_allocation, "");
; 1747 :                         } else {

	mov	rax, QWORD PTR [rbx+29048]
	jmp	$LN58@ZSTD_decom
$LN54@ZSTD_decom:

; 1748 :                             ZSTD_free(zds->inBuff, zds->customMem);

	movups	xmm0, XMMWORD PTR [rbx+28960]
	mov	rcx, QWORD PTR [rbx+29048]
	movsd	xmm1, QWORD PTR [rbx+28976]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN157@ZSTD_decom

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN156@ZSTD_decom

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN157@ZSTD_decom
$LN156@ZSTD_decom:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN157@ZSTD_decom:

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx+28960]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1751 :                             zds->inBuff = (char*)ZSTD_malloc(bufferSize, zds->customMem);

	movsd	xmm0, QWORD PTR [rbx+28976]
	mov	QWORD PTR [rbx+29056], r14
	mov	QWORD PTR [rbx+29088], r14
	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN160@ZSTD_decom

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rsi
	call	rax
	jmp	SHORT $LN159@ZSTD_decom
$LN160@ZSTD_decom:

; 60   :     return malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
$LN159@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1751 :                             zds->inBuff = (char*)ZSTD_malloc(bufferSize, zds->customMem);

	mov	QWORD PTR [rbx+29048], rax

; 1752 :                             RETURN_ERROR_IF(zds->inBuff == NULL, memory_allocation, "");

	test	rax, rax
	je	$LN200@ZSTD_decom
$LN58@ZSTD_decom:

; 1753 :                         }
; 1754 :                         zds->inBuffSize = neededInBuffSize;
; 1755 :                         zds->outBuff = zds->inBuff + zds->inBuffSize;

	add	rax, rbp
	mov	QWORD PTR [rbx+29056], rbp
	mov	QWORD PTR [rbx+29080], rax

; 1756 :                         zds->outBuffSize = neededOutBuffSize;

	mov	QWORD PTR [rbx+29088], rdi
$LN52@ZSTD_decom:

; 1757 :             }   }   }
; 1758 :             zds->streamStage = zdss_read;

	mov	rsi, QWORD PTR tv1839[rsp]
	mov	r8d, 1
	mov	r12, QWORD PTR tv1837[rsp]
	mov	DWORD PTR [rbx+29044], r15d
	lea	r9d, QWORD PTR [r8+2]
$LN60@ZSTD_decom:

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	mov	eax, DWORD PTR [rbx+28836]

; 1759 :             /* fall-through */
; 1760 : 
; 1761 :         case zdss_read:
; 1762 :             DEBUGLOG(5, "stage zdss_read");
; 1763 :             {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompressWithInputSize(zds, iend - ip);

	mov	rcx, rsi

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	mov	rdi, QWORD PTR [rbx+28776]

; 1759 :             /* fall-through */
; 1760 : 
; 1761 :         case zdss_read:
; 1762 :             DEBUGLOG(5, "stage zdss_read");
; 1763 :             {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompressWithInputSize(zds, iend - ip);

	sub	rcx, r13

; 853  :     if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))

	sub	eax, 3
	cmp	eax, 1
	ja	SHORT $LN166@ZSTD_decom

; 854  :         return dctx->expected;
; 855  :     if (dctx->bType != bt_raw)

	cmp	DWORD PTR [rbx+28832], r14d
	jne	SHORT $LN166@ZSTD_decom

; 856  :         return dctx->expected;
; 857  :     return MIN(MAX(inputSize, 1), dctx->expected);

	cmp	rcx, 1
	mov	rax, r8
	cmova	rax, rcx
	cmp	rax, rdi
	cmovb	rdi, rax
$LN166@ZSTD_decom:

; 1764 :                 DEBUGLOG(5, "neededInSize = %u", (U32)neededInSize);
; 1765 :                 if (neededInSize==0) {  /* end of frame */

	test	rdi, rdi
	je	$LN208@ZSTD_decom

; 1767 :                     someMoreWork = 0;
; 1768 :                     break;
; 1769 :                 }
; 1770 :                 if ((size_t)(iend-ip) >= neededInSize) {  /* decode directly from src */

	cmp	rcx, rdi
	jb	SHORT $LN62@ZSTD_decom

; 1771 :                     FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, ip, neededInSize), "");

	mov	r9, r13
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, r12
	lea	rdx, QWORD PTR op$[rsp]
	mov	rcx, rbx
	call	ZSTD_decompressContinueStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1771 :                     FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, ip, neededInSize), "");

	ja	$LN1@ZSTD_decom

; 1772 :                     ip += neededInSize;
; 1773 :                     /* Function modifies the stage so we must break */
; 1774 :                     break;

	mov	rbp, QWORD PTR op$[rsp]
	add	r13, rdi
	mov	r10, QWORD PTR output$[rsp]
	mov	QWORD PTR op$1$[rsp], rbp
	jmp	$LN228@ZSTD_decom
$LN62@ZSTD_decom:

; 1775 :             }   }
; 1776 :             if (ip==iend) { someMoreWork = 0; break; }   /* no more input */

	cmp	r13, rsi
	je	$LN226@ZSTD_decom

; 1777 :             zds->streamStage = zdss_load;

	mov	DWORD PTR [rbx+29044], r9d
$LN66@ZSTD_decom:

; 1778 :             /* fall-through */
; 1779 : 
; 1780 :         case zdss_load:
; 1781 :             {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompress(zds);

	mov	rbp, QWORD PTR [rbx+28776]

; 1782 :                 size_t const toLoad = neededInSize - zds->inPos;

	mov	rcx, QWORD PTR [rbx+29064]
	mov	rsi, rbp
	sub	rsi, rcx

; 882  : static int ZSTD_isSkipFrame(ZSTD_DCtx* dctx) { return dctx->stage == ZSTDds_skipFrame; }

	cmp	DWORD PTR [rbx+28836], 7

; 1783 :                 int const isSkipFrame = ZSTD_isSkipFrame(zds);
; 1784 :                 size_t loadedSize;
; 1785 :                 /* At this point we shouldn't be decompressing a block that we can stream. */
; 1786 :                 assert(neededInSize == ZSTD_nextSrcSizeToDecompressWithInputSize(zds, iend - ip));
; 1787 :                 if (isSkipFrame) {

	jne	SHORT $LN67@ZSTD_decom

; 1788 :                     loadedSize = MIN(toLoad, (size_t)(iend-ip));

	mov	rax, QWORD PTR tv1839[rsp]

; 1789 :                 } else {

	mov	rdi, rsi
	sub	rax, r13
	cmp	rsi, rax
	cmovae	rdi, rax
	jmp	SHORT $LN173@ZSTD_decom
$LN67@ZSTD_decom:

; 1790 :                     RETURN_ERROR_IF(toLoad > zds->inBuffSize - zds->inPos,

	mov	rax, QWORD PTR [rbx+29056]
	sub	rax, rcx
	cmp	rsi, rax
	ja	$LN202@ZSTD_decom

; 1793 :                     loadedSize = ZSTD_limitCopy(zds->inBuff + zds->inPos, toLoad, ip, iend-ip);

	mov	rdi, QWORD PTR tv1839[rsp]
	sub	rdi, r13
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 306  :     size_t const length = MIN(dstCapacity, srcSize);

	cmp	rsi, rdi
	cmovb	rdi, rsi

; 307  :     if (length > 0) {

	test	rdi, rdi
	je	SHORT $LN173@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1793 :                     loadedSize = ZSTD_limitCopy(zds->inBuff + zds->inPos, toLoad, ip, iend-ip);

	add	rcx, QWORD PTR [rbx+29048]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 308  :         memcpy(dst, src, length);

	mov	r8, rdi
	mov	rdx, r13
	call	memcpy
	mov	rcx, QWORD PTR [rbx+29064]
$LN173@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1795 :                 ip += loadedSize;

	add	r13, rdi

; 1796 :                 zds->inPos += loadedSize;

	lea	rax, QWORD PTR [rcx+rdi]
	mov	QWORD PTR [rbx+29064], rax

; 1797 :                 if (loadedSize < toLoad) { someMoreWork = 0; break; }   /* not enough input, wait for more */

	cmp	rdi, rsi
	jb	$LN222@ZSTD_decom

; 1801 :                 FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, zds->inBuff, neededInSize), "");

	mov	r9, QWORD PTR [rbx+29048]
	lea	rdx, QWORD PTR op$[rsp]
	mov	r8, r12
	mov	QWORD PTR [rbx+29064], r14
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rbp
	call	ZSTD_decompressContinueStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1801 :                 FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, zds->inBuff, neededInSize), "");

	ja	$LN1@ZSTD_decom

; 1613 : 
; 1614 :     while (someMoreWork) {

	mov	rbp, QWORD PTR op$[rsp]
	mov	rsi, QWORD PTR tv1839[rsp]
	mov	r10, QWORD PTR output$[rsp]
	mov	QWORD PTR op$1$[rsp], rbp
	jmp	$LN228@ZSTD_decom
$LN26@ZSTD_decom:

; 1820 :             }   }
; 1821 :             /* cannot complete flush */
; 1822 :             someMoreWork = 0;
; 1823 :             break;
; 1824 : 
; 1825 :         default:
; 1826 :             assert(0);    /* impossible */
; 1827 :             RETURN_ERROR(GENERIC, "impossible to reach");   /* some compiler require default to do something */

	mov	rax, -1
	jmp	$LN1@ZSTD_decom
$LN193@ZSTD_decom:

; 1665 :                         if (remainingInput > 0) {

	test	rsi, rsi
	je	SHORT $LN38@ZSTD_decom

; 1666 :                             memcpy(zds->headerBuffer + zds->lhSize, ip, remainingInput);

	add	rcx, 160280				; 00027218H
	mov	r8, rsi
	add	rcx, rbx
	mov	rdx, r13
	call	memcpy

; 1667 :                             zds->lhSize += remainingInput;

	add	QWORD PTR [rbx+29112], rsi
	mov	rcx, QWORD PTR [rbx+29112]
$LN38@ZSTD_decom:

; 1668 :                         }
; 1669 :                         input->pos = input->size;
; 1670 :                         return (MAX((size_t)ZSTD_FRAMEHEADERSIZE_MIN(zds->format), hSize) - zds->lhSize) + ZSTD_blockHeaderSize;   /* remaining header bytes + next block header */

	cmp	DWORD PTR [rbx+28944], r14d
	mov	edx, 6
	mov	r9, QWORD PTR input$[rsp]
	mov	rax, QWORD PTR [r9+8]
	mov	QWORD PTR [r9+16], rax
	mov	eax, 2
	cmove	eax, edx
	cmp	rax, rdi
	cmova	rdi, rax
	sub	rdi, rcx
	lea	rax, QWORD PTR [rdi+3]
	jmp	$LN1@ZSTD_decom
$LN207@ZSTD_decom:

; 798  :     switch (dctx->dictUses) {

	mov	eax, DWORD PTR [rbx+29040]
	cmp	eax, -1
	je	SHORT $LN123@ZSTD_decom
	cmp	eax, 1
	jne	SHORT $LN122@ZSTD_decom

; 805  :     case ZSTD_use_indefinitely:
; 806  :         return dctx->ddict;
; 807  :     case ZSTD_use_once:
; 808  :         dctx->dictUses = ZSTD_dont_use;

	mov	DWORD PTR [rbx+29040], r14d
$LN123@ZSTD_decom:

; 1683 :                     /* shortcut : using single-pass mode */
; 1684 :                     size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, oend-op, istart, cSize, ZSTD_getDDict(zds));

	mov	rax, QWORD PTR [rbx+29024]
$LN118@ZSTD_decom:
	mov	r12, QWORD PTR tv1837[rsp]

; 1255 :     return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize,

	mov	rdx, rbp
	mov	rdi, QWORD PTR tv1840[rsp]

; 1683 :                     /* shortcut : using single-pass mode */
; 1684 :                     size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, oend-op, istart, cSize, ZSTD_getDDict(zds));

	mov	r8, r12

; 1255 :     return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize,

	mov	QWORD PTR [rsp+56], rax

; 1683 :                     /* shortcut : using single-pass mode */
; 1684 :                     size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, oend-op, istart, cSize, ZSTD_getDDict(zds));

	sub	r8, rbp

; 1255 :     return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize,

	mov	r9, rdi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	ZSTD_decompressMultiFrame
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress.c

; 1685 :                     if (ZSTD_isError(decompressedSize)) return decompressedSize;

	ja	$LN1@ZSTD_decom

; 1686 :                     DEBUGLOG(4, "shortcut to single-pass ZSTD_decompress_usingDDict()")
; 1687 :                     ip = istart + cSize;
; 1688 :                     op += decompressedSize;

	add	rbp, rax

; 1689 :                     zds->expected = 0;

	mov	QWORD PTR [rbx+28776], r14
	lea	r13, QWORD PTR [rdi+rsi]
	mov	QWORD PTR op$1$[rsp], rbp

; 1690 :                     zds->streamStage = zdss_init;
; 1691 :                     someMoreWork = 0;
; 1692 :                     break;

	mov	rsi, QWORD PTR tv1839[rsp]
	mov	DWORD PTR [rbx+29044], r14d
	jmp	SHORT $LN210@ZSTD_decom
$LN122@ZSTD_decom:

; 803  :         ZSTD_clearDict(dctx);

	mov	rcx, rbx
	call	ZSTD_clearDict

; 804  :         return NULL;

	mov	rax, r14
	jmp	SHORT $LN118@ZSTD_decom
$LN202@ZSTD_decom:

; 1790 :                     RETURN_ERROR_IF(toLoad > zds->inBuffSize - zds->inPos,

	mov	rax, -20
	jmp	$LN1@ZSTD_decom
$LN208@ZSTD_decom:

; 1766 :                     zds->streamStage = zdss_init;

	mov	DWORD PTR [rbx+29044], r14d

; 1810 :                 if (flushedSize == toFlushSize) {  /* flush completed */

	jmp	SHORT $LN226@ZSTD_decom
$LN222@ZSTD_decom:

; 1797 :                 if (loadedSize < toLoad) { someMoreWork = 0; break; }   /* not enough input, wait for more */

	mov	rsi, QWORD PTR tv1839[rsp]
$LN226@ZSTD_decom:

; 1828 :     }   }
; 1829 : 
; 1830 :     /* result */
; 1831 :     input->pos = (size_t)(ip - (const char*)(input->src));

	mov	rdi, QWORD PTR tv1840[rsp]
$LN210@ZSTD_decom:

; 1832 :     output->pos = (size_t)(op - (char*)(output->dst));

	mov	r8, QWORD PTR output$[rsp]
	mov	rdx, r13
	mov	r9, QWORD PTR input$[rsp]
	mov	rcx, QWORD PTR op$1$[rsp]
	mov	rax, rcx
	sub	rax, QWORD PTR [r8]
	sub	rdx, QWORD PTR [r9]
	mov	QWORD PTR [r8+16], rax

; 1833 : 
; 1834 :     /* Update the expected output buffer for ZSTD_obm_stable. */
; 1835 :     zds->expectedOutBuffer = *output;

	movsd	xmm1, QWORD PTR [r8+16]
	mov	QWORD PTR [r9+16], rdx
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rbx+29152], xmm0
	movsd	QWORD PTR [rbx+29168], xmm1

; 1836 : 
; 1837 :     if ((ip==istart) && (op==ostart)) {  /* no forward progress */

	cmp	r13, rdi
	jne	SHORT $LN79@ZSTD_decom
	cmp	rcx, QWORD PTR tv1838[rsp]
	jne	SHORT $LN79@ZSTD_decom

; 1838 :         zds->noForwardProgress ++;

	inc	DWORD PTR [rbx+29140]

; 1839 :         if (zds->noForwardProgress >= ZSTD_NO_FORWARD_PROGRESS_MAX) {

	cmp	DWORD PTR [rbx+29140], 16
	jl	SHORT $LN80@ZSTD_decom

; 1840 :             RETURN_ERROR_IF(op==oend, dstSize_tooSmall, "");

	cmp	rcx, r12
	je	$LN213@ZSTD_decom

; 1841 :             RETURN_ERROR_IF(ip==iend, srcSize_wrong, "");

	cmp	r13, rsi
	jne	SHORT $LN80@ZSTD_decom
$LN214@ZSTD_decom:
	mov	rax, -72				; ffffffffffffffb8H
$LN1@ZSTD_decom:

; 1870 :     }
; 1871 : }

	mov	rbx, QWORD PTR [rsp+256]
	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN79@ZSTD_decom:

; 1842 :             assert(0);
; 1843 :         }
; 1844 :     } else {
; 1845 :         zds->noForwardProgress = 0;

	mov	DWORD PTR [rbx+29140], r14d
$LN80@ZSTD_decom:

; 1846 :     }
; 1847 :     {   size_t nextSrcSizeHint = ZSTD_nextSrcSizeToDecompress(zds);

	mov	r8, QWORD PTR [rbx+28776]

; 1848 :         if (!nextSrcSizeHint) {   /* frame fully decoded */

	test	r8, r8
	jne	SHORT $LN86@ZSTD_decom

; 1849 :             if (zds->outEnd == zds->outStart) {  /* output fully flushed */

	mov	rcx, QWORD PTR [rbx+29096]
	mov	r8d, DWORD PTR [rbx+29136]
	cmp	QWORD PTR [rbx+29104], rcx
	jne	SHORT $LN87@ZSTD_decom

; 1850 :                 if (zds->hostageByte) {

	test	r8d, r8d
	je	SHORT $LN88@ZSTD_decom

; 1851 :                     if (input->pos >= input->size) {

	cmp	rdx, QWORD PTR [r9+8]
	jb	SHORT $LN89@ZSTD_decom

; 1852 :                         /* can't release hostage (not present) */
; 1853 :                         zds->streamStage = zdss_read;

	mov	eax, 2
	mov	DWORD PTR [rbx+29044], eax
$LN220@ZSTD_decom:

; 1870 :     }
; 1871 : }

	mov	eax, 1
	jmp	SHORT $LN1@ZSTD_decom
$LN89@ZSTD_decom:

; 1854 :                         return 1;
; 1855 :                     }
; 1856 :                     input->pos++;  /* release hostage */

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [r9+16], rax
$LN88@ZSTD_decom:

; 1857 :                 }   /* zds->hostageByte */
; 1858 :                 return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_decom
$LN87@ZSTD_decom:

; 1859 :             }  /* zds->outEnd == zds->outStart */
; 1860 :             if (!zds->hostageByte) { /* output not fully flushed; keep last byte as hostage; will be released when all output is flushed */

	test	r8d, r8d
	jne	SHORT $LN220@ZSTD_decom

; 1861 :                 input->pos--;   /* note : pos > 0, otherwise, impossible to finish reading last block */

	lea	rax, QWORD PTR [rdx-1]
	mov	QWORD PTR [r9+16], rax

; 1862 :                 zds->hostageByte=1;

	mov	eax, 1
	mov	DWORD PTR [rbx+29136], eax
	jmp	$LN1@ZSTD_decom
$LN86@ZSTD_decom:

; 861  :     switch(dctx->stage)

	movsxd	rax, DWORD PTR [rbx+28836]
	cmp	eax, 7
	ja	SHORT $LN183@ZSTD_decom
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN218@ZSTD_decom[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN185@ZSTD_decom:

; 868  :     case ZSTDds_decodeBlockHeader:
; 869  :         return ZSTDnit_blockHeader;

	mov	eax, 1
	jmp	SHORT $LN229@ZSTD_decom
$LN186@ZSTD_decom:

; 870  :     case ZSTDds_decompressBlock:
; 871  :         return ZSTDnit_block;

	mov	eax, 2
	jmp	SHORT $LN229@ZSTD_decom
$LN187@ZSTD_decom:

; 872  :     case ZSTDds_decompressLastBlock:
; 873  :         return ZSTDnit_lastBlock;

	mov	ecx, 3
	mov	eax, ecx
	jmp	SHORT $LN180@ZSTD_decom
$LN188@ZSTD_decom:

; 874  :     case ZSTDds_checkChecksum:
; 875  :         return ZSTDnit_checksum;

	mov	eax, 4
	jmp	SHORT $LN229@ZSTD_decom
$LN189@ZSTD_decom:

; 876  :     case ZSTDds_decodeSkippableHeader:
; 877  :     case ZSTDds_skipFrame:
; 878  :         return ZSTDnit_skippableFrame;

	mov	eax, 5
	jmp	SHORT $LN229@ZSTD_decom
$LN183@ZSTD_decom:

; 862  :     {
; 863  :     default:   /* should not happen */
; 864  :         assert(0);
; 865  :     case ZSTDds_getFrameHeaderSize:
; 866  :     case ZSTDds_decodeFrameHeader:
; 867  :         return ZSTDnit_frameHeader;

	mov	eax, r14d
$LN229@ZSTD_decom:

; 1863 :             }
; 1864 :             return 1;
; 1865 :         }  /* nextSrcSizeHint==0 */
; 1866 :         nextSrcSizeHint += ZSTD_blockHeaderSize * (ZSTD_nextInputType(zds) == ZSTDnit_block);   /* preload header of next block */

	mov	ecx, 3
$LN180@ZSTD_decom:
	cmp	eax, 2
	cmove	r14, rcx
	sub	r14, QWORD PTR [rbx+29064]

; 1867 :         assert(zds->inPos <= nextSrcSizeHint);
; 1868 :         nextSrcSizeHint -= zds->inPos;   /* part already loaded*/

	lea	rax, QWORD PTR [r8+r14]

; 1869 :         return nextSrcSizeHint;

	jmp	$LN1@ZSTD_decom
$LN200@ZSTD_decom:

; 1752 :                             RETURN_ERROR_IF(zds->inBuff == NULL, memory_allocation, "");

	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN1@ZSTD_decom
$LN198@ZSTD_decom:

; 1721 :             RETURN_ERROR_IF(zds->fParams.windowSize > zds->maxWindowSize,

	mov	rax, -16
	jmp	$LN1@ZSTD_decom
$LN213@ZSTD_decom:

; 1840 :             RETURN_ERROR_IF(op==oend, dstSize_tooSmall, "");

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN1@ZSTD_decom
	npad	3
$LN218@ZSTD_decom:

; 1870 :     }
; 1871 : }

	DD	$LN183@ZSTD_decom
	DD	$LN183@ZSTD_decom
	DD	$LN185@ZSTD_decom
	DD	$LN186@ZSTD_decom
	DD	$LN187@ZSTD_decom
	DD	$LN188@ZSTD_decom
	DD	$LN189@ZSTD_decom
	DD	$LN189@ZSTD_decom
ZSTD_decompressStream ENDP
_TEXT	ENDS
END
