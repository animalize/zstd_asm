; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

prime3bytes DD	01e35a7bdH
?ML_deltaCode@?1??ZSTD_MLcode@@9@9 DD 024H		; `ZSTD_MLcode'::`2'::ML_deltaCode
prime8bytes DQ	cf1bbcdcb7a56463H
LL_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
?ML_Code@?1??ZSTD_MLcode@@9@9 DB 00H			; `ZSTD_MLcode'::`2'::ML_Code
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	020H
	DB	021H
	DB	021H
	DB	022H
	DB	022H
	DB	023H
	DB	023H
	DB	024H
	DB	024H
	DB	024H
	DB	024H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
?LL_Code@?1??ZSTD_LLcode@@9@9 DB 00H			; `ZSTD_LLcode'::`2'::LL_Code
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
?LL_deltaCode@?1??ZSTD_LLcode@@9@9 DD 013H		; `ZSTD_LLcode'::`2'::LL_deltaCode
prime4bytes DD	09e3779b1H
prime5bytes DQ	000000cf1bbcdcbbH
ML_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
prime7bytes DQ	00cf1bbcdcbfa563H
prime6bytes DQ	0000cf1bbcdcbf9bH
PUBLIC	ZSTD_compressBlock_btopt_extDict
PUBLIC	ZSTD_compressBlock_btultra
PUBLIC	ZSTD_compressBlock_btultra2
PUBLIC	ZSTD_compressBlock_btultra_dictMatchState
PUBLIC	ZSTD_compressBlock_btultra_extDict
PUBLIC	ZSTD_compressBlock_btopt
PUBLIC	ZSTD_compressBlock_btopt_dictMatchState
PUBLIC	ZSTD_updateTree
pdata	SEGMENT
$pdata$ZSTD_initStats_ultra DD imagerel ZSTD_initStats_ultra
	DD	imagerel ZSTD_initStats_ultra+9640
	DD	imagerel $unwind$ZSTD_initStats_ultra
$pdata$ZSTD_upscaleStats DD imagerel ZSTD_upscaleStats
	DD	imagerel ZSTD_upscaleStats+89
	DD	imagerel $unwind$ZSTD_upscaleStats
$pdata$ZSTD_compressBlock_opt_generic DD imagerel ZSTD_compressBlock_opt_generic
	DD	imagerel ZSTD_compressBlock_opt_generic+218
	DD	imagerel $unwind$ZSTD_compressBlock_opt_generic
$pdata$0$ZSTD_compressBlock_opt_generic DD imagerel ZSTD_compressBlock_opt_generic+218
	DD	imagerel ZSTD_compressBlock_opt_generic+17978
	DD	imagerel $chain$0$ZSTD_compressBlock_opt_generic
$pdata$1$ZSTD_compressBlock_opt_generic DD imagerel ZSTD_compressBlock_opt_generic+17978
	DD	imagerel ZSTD_compressBlock_opt_generic+18002
	DD	imagerel $chain$1$ZSTD_compressBlock_opt_generic
$pdata$ZSTD_BtGetAllMatches DD imagerel ZSTD_BtGetAllMatches
	DD	imagerel ZSTD_BtGetAllMatches+10377
	DD	imagerel $unwind$ZSTD_BtGetAllMatches
$pdata$ZSTD_insertBtAndGetAllMatches DD imagerel ZSTD_insertBtAndGetAllMatches
	DD	imagerel ZSTD_insertBtAndGetAllMatches+3252
	DD	imagerel $unwind$ZSTD_insertBtAndGetAllMatches
$pdata$ZSTD_updateTree_internal DD imagerel ZSTD_updateTree_internal
	DD	imagerel ZSTD_updateTree_internal+51
	DD	imagerel $unwind$ZSTD_updateTree_internal
$pdata$0$ZSTD_updateTree_internal DD imagerel ZSTD_updateTree_internal+51
	DD	imagerel ZSTD_updateTree_internal+119
	DD	imagerel $chain$0$ZSTD_updateTree_internal
$pdata$1$ZSTD_updateTree_internal DD imagerel ZSTD_updateTree_internal+119
	DD	imagerel ZSTD_updateTree_internal+148
	DD	imagerel $chain$1$ZSTD_updateTree_internal
$pdata$ZSTD_insertBt1 DD imagerel ZSTD_insertBt1
	DD	imagerel ZSTD_insertBt1+1030
	DD	imagerel $unwind$ZSTD_insertBt1
$pdata$ZSTD_insertAndFindFirstIndexHash3 DD imagerel ZSTD_insertAndFindFirstIndexHash3
	DD	imagerel ZSTD_insertAndFindFirstIndexHash3+115
	DD	imagerel $unwind$ZSTD_insertAndFindFirstIndexHash3
$pdata$ZSTD_updateStats DD imagerel ZSTD_updateStats
	DD	imagerel ZSTD_updateStats+197
	DD	imagerel $unwind$ZSTD_updateStats
$pdata$ZSTD_getMatchPrice DD imagerel ZSTD_getMatchPrice
	DD	imagerel ZSTD_getMatchPrice+331
	DD	imagerel $unwind$ZSTD_getMatchPrice
$pdata$ZSTD_rescaleFreqs DD imagerel ZSTD_rescaleFreqs
	DD	imagerel ZSTD_rescaleFreqs+83
	DD	imagerel $unwind$ZSTD_rescaleFreqs
$pdata$0$ZSTD_rescaleFreqs DD imagerel ZSTD_rescaleFreqs+83
	DD	imagerel ZSTD_rescaleFreqs+1221
	DD	imagerel $chain$0$ZSTD_rescaleFreqs
$pdata$1$ZSTD_rescaleFreqs DD imagerel ZSTD_rescaleFreqs+1221
	DD	imagerel ZSTD_rescaleFreqs+2783
	DD	imagerel $chain$1$ZSTD_rescaleFreqs
$pdata$ZSTD_downscaleStat DD imagerel ZSTD_downscaleStat
	DD	imagerel ZSTD_downscaleStat+244
	DD	imagerel $unwind$ZSTD_downscaleStat
$pdata$ZSTD_count_2segments DD imagerel ZSTD_count_2segments
	DD	imagerel ZSTD_count_2segments+106
	DD	imagerel $unwind$ZSTD_count_2segments
$pdata$ZSTD_storeSeq DD imagerel ZSTD_storeSeq
	DD	imagerel ZSTD_storeSeq+271
	DD	imagerel $unwind$ZSTD_storeSeq
$pdata$ZSTD_compressBlock_btopt_extDict DD imagerel $LN2008
	DD	imagerel $LN2008+11705
	DD	imagerel $unwind$ZSTD_compressBlock_btopt_extDict
$pdata$ZSTD_compressBlock_btultra DD imagerel $LN1990
	DD	imagerel $LN1990+9832
	DD	imagerel $unwind$ZSTD_compressBlock_btultra
$pdata$ZSTD_compressBlock_btultra2 DD imagerel $LN3566
	DD	imagerel $LN3566+9911
	DD	imagerel $unwind$ZSTD_compressBlock_btultra2
$pdata$ZSTD_compressBlock_btultra_dictMatchState DD imagerel $LN2055
	DD	imagerel $LN2055+216
	DD	imagerel $unwind$ZSTD_compressBlock_btultra_dictMatchState
$pdata$0$ZSTD_compressBlock_btultra_dictMatchState DD imagerel $LN2055+216
	DD	imagerel $LN2055+14504
	DD	imagerel $chain$0$ZSTD_compressBlock_btultra_dictMatchState
$pdata$1$ZSTD_compressBlock_btultra_dictMatchState DD imagerel $LN2055+14504
	DD	imagerel $LN2055+14528
	DD	imagerel $chain$1$ZSTD_compressBlock_btultra_dictMatchState
$pdata$ZSTD_compressBlock_btultra_extDict DD imagerel $LN2010
	DD	imagerel $LN2010+11615
	DD	imagerel $unwind$ZSTD_compressBlock_btultra_extDict
$pdata$ZSTD_compressBlock_btopt DD imagerel $LN1991
	DD	imagerel $LN1991+9881
	DD	imagerel $unwind$ZSTD_compressBlock_btopt
$pdata$ZSTD_compressBlock_btopt_dictMatchState DD imagerel $LN2055
	DD	imagerel $LN2055+207
	DD	imagerel $unwind$ZSTD_compressBlock_btopt_dictMatchState
$pdata$0$ZSTD_compressBlock_btopt_dictMatchState DD imagerel $LN2055+207
	DD	imagerel $LN2055+14644
	DD	imagerel $chain$0$ZSTD_compressBlock_btopt_dictMatchState
$pdata$1$ZSTD_compressBlock_btopt_dictMatchState DD imagerel $LN2055+14644
	DD	imagerel $LN2055+14668
	DD	imagerel $chain$1$ZSTD_compressBlock_btopt_dictMatchState
$pdata$ZSTD_updateTree DD imagerel $LN13
	DD	imagerel $LN13+53
	DD	imagerel $unwind$ZSTD_updateTree
$pdata$0$ZSTD_updateTree DD imagerel $LN13+53
	DD	imagerel $LN13+104
	DD	imagerel $chain$0$ZSTD_updateTree
$pdata$1$ZSTD_updateTree DD imagerel $LN13+104
	DD	imagerel $LN13+132
	DD	imagerel $chain$1$ZSTD_updateTree
xdata	SEGMENT
$unwind$ZSTD_initStats_ultra DD 0a2d19H
	DD	037011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$ZSTD_upscaleStats DD 010401H
	DD	04204H
$unwind$ZSTD_compressBlock_opt_generic DD 092d01H
	DD	03e012dH
	DD	0d01cf01eH
	DD	07018c01aH
	DD	030166017H
	DD	05015H
$chain$0$ZSTD_compressBlock_opt_generic DD 020821H
	DD	03de408H
	DD	imagerel ZSTD_compressBlock_opt_generic
	DD	imagerel ZSTD_compressBlock_opt_generic+218
	DD	imagerel $unwind$ZSTD_compressBlock_opt_generic
$chain$1$ZSTD_compressBlock_opt_generic DD 021H
	DD	imagerel ZSTD_compressBlock_opt_generic
	DD	imagerel ZSTD_compressBlock_opt_generic+218
	DD	imagerel $unwind$ZSTD_compressBlock_opt_generic
$unwind$ZSTD_BtGetAllMatches DD 0d7601H
	DD	021d476H
	DD	0227467H
	DD	023645cH
	DD	0240128H
	DD	0e01af01cH
	DD	03016c018H
	DD	05015H
$unwind$ZSTD_insertBtAndGetAllMatches DD 0a2701H
	DD	01f0127H
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
$unwind$ZSTD_updateTree_internal DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b3419H
	DD	0f0155219H
	DD	0c011e013H
$chain$0$ZSTD_updateTree_internal DD 020521H
	DD	0a5405H
	DD	imagerel ZSTD_updateTree_internal
	DD	imagerel ZSTD_updateTree_internal+51
	DD	imagerel $unwind$ZSTD_updateTree_internal
$chain$1$ZSTD_updateTree_internal DD 021H
	DD	imagerel ZSTD_updateTree_internal
	DD	imagerel ZSTD_updateTree_internal+51
	DD	imagerel $unwind$ZSTD_updateTree_internal
$unwind$ZSTD_insertBt1 DD 0b1c01H
	DD	01e341cH
	DD	014011cH
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$ZSTD_insertAndFindFirstIndexHash3 DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
$unwind$ZSTD_updateStats DD 020501H
	DD	013405H
$unwind$ZSTD_getMatchPrice DD 036b01H
	DD	03746bH
	DD	03002H
$unwind$ZSTD_rescaleFreqs DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0700be00dH
$chain$0$ZSTD_rescaleFreqs DD 020521H
	DD	096405H
	DD	imagerel ZSTD_rescaleFreqs
	DD	imagerel ZSTD_rescaleFreqs+83
	DD	imagerel $unwind$ZSTD_rescaleFreqs
$chain$1$ZSTD_rescaleFreqs DD 021H
	DD	imagerel ZSTD_rescaleFreqs
	DD	imagerel ZSTD_rescaleFreqs+83
	DD	imagerel $unwind$ZSTD_rescaleFreqs
$unwind$ZSTD_downscaleStat DD 020501H
	DD	013405H
$unwind$ZSTD_count_2segments DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$ZSTD_storeSeq DD 020501H
	DD	013405H
$unwind$ZSTD_compressBlock_btopt_extDict DD 0a2f01H
	DD	035012fH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$ZSTD_compressBlock_btultra DD 0a2c01H
	DD	02f012cH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$ZSTD_compressBlock_btultra2 DD 0a2c01H
	DD	02f012cH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$ZSTD_compressBlock_btultra_dictMatchState DD 092d01H
	DD	03c012dH
	DD	0d01cf01eH
	DD	07018c01aH
	DD	030166017H
	DD	05015H
$chain$0$ZSTD_compressBlock_btultra_dictMatchState DD 020821H
	DD	03be408H
	DD	imagerel $LN2055
	DD	imagerel $LN2055+216
	DD	imagerel $unwind$ZSTD_compressBlock_btultra_dictMatchState
$chain$1$ZSTD_compressBlock_btultra_dictMatchState DD 021H
	DD	imagerel $LN2055
	DD	imagerel $LN2055+216
	DD	imagerel $unwind$ZSTD_compressBlock_btultra_dictMatchState
$unwind$ZSTD_compressBlock_btultra_extDict DD 0a2f01H
	DD	035012fH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$ZSTD_compressBlock_btopt DD 0a2c01H
	DD	02f012cH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$ZSTD_compressBlock_btopt_dictMatchState DD 092d01H
	DD	03c012dH
	DD	0d01cf01eH
	DD	07018c01aH
	DD	030166017H
	DD	05015H
$chain$0$ZSTD_compressBlock_btopt_dictMatchState DD 020821H
	DD	03be408H
	DD	imagerel $LN2055
	DD	imagerel $LN2055+207
	DD	imagerel $unwind$ZSTD_compressBlock_btopt_dictMatchState
$chain$1$ZSTD_compressBlock_btopt_dictMatchState DD 021H
	DD	imagerel $LN2055
	DD	imagerel $LN2055+207
	DD	imagerel $unwind$ZSTD_compressBlock_btopt_dictMatchState
$unwind$ZSTD_updateTree DD 0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0b3418H
	DD	0f0145218H
	DD	07010e012H
$chain$0$ZSTD_updateTree DD 020521H
	DD	0ac405H
	DD	imagerel $LN13
	DD	imagerel $LN13+53
	DD	imagerel $unwind$ZSTD_updateTree
$chain$1$ZSTD_updateTree DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+53
	DD	imagerel $unwind$ZSTD_updateTree
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
ms$ = 80
ip$ = 88
iend$ = 96
ZSTD_updateTree PROC

; 504  : void ZSTD_updateTree(ZSTD_matchState_t* ms, const BYTE* ip, const BYTE* iend) {

$LN13:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 488  :     const BYTE* const base = ms->window.base;

	mov	rbp, QWORD PTR [rcx+8]

; 504  : void ZSTD_updateTree(ZSTD_matchState_t* ms, const BYTE* ip, const BYTE* iend) {

	mov	rdi, rdx

; 490  :     U32 idx = ms->nextToUpdate;

	mov	ebx, DWORD PTR [rcx+36]
	sub	edi, ebp

; 505  :     ZSTD_updateTree_internal(ms, ip, iend, ms->cParams.minMatch, ZSTD_noDict);

	mov	r15d, DWORD PTR [rcx+200]
	mov	r14, r8
	mov	rsi, rcx

; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN11@ZSTD_updat
	mov	QWORD PTR [rsp+80], r12
	xor	r12d, r12d
	npad	3
$LL4@ZSTD_updat:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, r15d
	add	rdx, rbp
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, r14
	mov	rcx, rsi
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL4@ZSTD_updat

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	r12, QWORD PTR [rsp+80]
	mov	DWORD PTR [rsi+36], edi
	jmp	SHORT $LN5@ZSTD_updat
$LN11@ZSTD_updat:
	mov	DWORD PTR [rcx+36], edi
$LN5@ZSTD_updat:

; 506  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
ZSTD_updateTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
current$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchLow$1$ = 52
dmsIndexDelta$1$ = 52
dmsIndexDelta$1$ = 52
dmsIndexDelta$1$ = 52
tv13686 = 52
iend$1$ = 56
dmsIndexDelta$1$ = 64
dmsIndexDelta$1$ = 64
dmsIndexDelta$1$ = 64
matchEndIdx$1$ = 64
windowLow$1$ = 64
windowLow$1$ = 64
windowLow$1$ = 64
dmsIndexDelta$1$ = 64
current$1$ = 68
current$1$ = 68
current$1$ = 68
matchLow$1$ = 68
seqPos$1$ = 68
dmsLowLimit$1$ = 72
dmsLowLimit$1$ = 72
dmsLowLimit$1$ = 72
dmsIndexDelta$1$ = 72
sufficient_len$1$ = 72
matchNb$1$ = 72
tv13689 = 72
tv13688 = 72
tv13687 = 72
smallerPtr$1$ = 80
smallerPtr$1$ = 80
smallerPtr$1$ = 80
bestLength$1$ = 80
smallerPtr$1$ = 80
smallerPtr$1$ = 80
smallerPtr$1$ = 80
smallerPtr$1$ = 80
ip$1$ = 88
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
smallerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
base$1$ = 104
base$1$ = 104
base$1$ = 104
base$1$ = 104
commonLengthSmaller$2$ = 104
commonLengthSmaller$1$ = 104
commonLengthSmaller$2$ = 104
commonLengthSmaller$1$ = 104
commonLengthSmaller$2$ = 104
commonLengthSmaller$1$ = 104
base$1$ = 104
tv13700 = 104
tv13691 = 104
dmsLowLimit$1$ = 112
dmsLowLimit$1$ = 112
dmsLowLimit$1$ = 112
dmsLowLimit$1$ = 112
ll0$1$ = 112
commonLengthSmaller$2$ = 120
commonLengthSmaller$1$ = 120
dmsEnd$1$ = 120
dmsEnd$1$ = 120
largerPtr$1$ = 120
bestLength$1$ = 120
bestLength$1$ = 120
bestLength$1$ = 120
commonLengthSmaller$2$ = 120
commonLengthSmaller$1$ = 120
tv13874 = 120
btMask$1$ = 128
current$1$ = 128
cur$1$ = 128
tv13756 = 128
tv13752 = 128
bestLength$1$ = 136
bestLength$1$ = 136
bestLength$1$ = 136
prefixStart$1$ = 136
prefixStart$1$ = 136
prefixStart$1$ = 136
dmsBase$1$ = 136
offset$1$ = 136
tv13714 = 136
dmsBtMask$1$ = 144
sufficient_len$1$ = 144
matchLow$1$ = 144
dmsHighLimit$1$ = 144
dmsHighLimit$1$ = 144
dmsHighLimit$1$ = 144
tv13724 = 144
tv13718 = 144
dmsHashLog$1$ = 148
dmsHighLimit$1$ = 148
dmsHighLimit$1$ = 148
dmsBtMask$1$ = 148
dmsBtMask$1$ = 148
dmsBtMask$1$ = 148
tv13856 = 148
tv13682 = 148
btMask$1$ = 152
dmsBtMask$1$ = 152
dmsBtMask$1$ = 152
dmsLowLimit$1$ = 152
sufficient_len$1$ = 152
dmsHashLog$1$ = 152
dmsHashLog$1$ = 152
dmsHashLog$1$ = 152
dictLimit$1$ = 156
dictLimit$1$ = 156
dictLimit$1$ = 156
lastR$1$ = 156
litlen$1$ = 156
matchLow$1$ = 160
dmsHashLog$1$ = 160
dmsHashLog$1$ = 160
dmsHighLimit$1$ = 160
dmsHashLog$1$ = 160
btMask$1$ = 160
btMask$1$ = 160
btMask$1$ = 160
btMask$1$ = 164
btMask$1$ = 164
dmsBtMask$1$ = 164
dmsBtMask$1$ = 164
matchLow$1$ = 164
matchLow$1$ = 164
tv13826 = 164
tv13810 = 164
sufficient_len$1$ = 168
matchLow$1$ = 168
matchLow$1$ = 168
dmsHashLog$1$ = 168
dmsHighLimit$1$ = 168
dictLimit$1$ = 168
tv13846 = 168
tv13836 = 168
dictLimit$1$ = 172
btMask$1$ = 172
sufficient_len$1$ = 172
sufficient_len$1$ = 172
windowLow$1$ = 172
tv13800 = 172
tv13790 = 172
tv13760 = 172
lastR$1$ = 176
litlen$1$ = 176
tv13685 = 176
tv13684 = 176
tv13683 = 176
matches$1$ = 184
windowLow$1$ = 192
windowLow$1$ = 192
windowLow$1$ = 192
dmsEnd$1$ = 192
dmsEnd$1$ = 192
dmsEnd$1$ = 192
prefixStart$1$ = 192
tv13728 = 192
dummy32$1 = 192
dummy32$2 = 192
dummy32$3 = 192
r$4 = 192
r$5 = 192
r$6 = 192
prefixStart$1$ = 200
commonLengthLarger$1$ = 200
commonLengthSmaller$2$ = 200
commonLengthLarger$1$ = 200
commonLengthSmaller$2$ = 200
commonLengthLarger$1$ = 200
commonLengthSmaller$2$ = 200
dms$1$ = 200
dms$1$ = 200
dms$1$ = 200
dms$1$ = 200
dmsEnd$1$ = 208
commonLengthLarger$2$ = 208
commonLengthSmaller$1$ = 208
commonLengthLarger$2$ = 208
commonLengthSmaller$1$ = 208
commonLengthLarger$2$ = 208
commonLengthSmaller$1$ = 208
bt$1$ = 208
bt$1$ = 208
bt$1$ = 208
bt$1$ = 208
dms$1$ = 216
dms$1$ = 216
dmsEnd$1$ = 216
dmsBt$1$ = 216
dmsBt$1$ = 216
dmsBt$1$ = 216
dmsBt$1$ = 216
tv13862 = 216
tv13849 = 216
tv13839 = 216
tv13829 = 216
tv13813 = 216
rep$1$ = 224
commonLengthLarger$1$ = 224
commonLengthLarger$1$ = 224
commonLengthLarger$1$ = 224
bestLength$1$ = 224
windowLow$1$ = 232
sufficient_len$1$ = 232
sufficient_len$1$ = 232
tv13780 = 232
tv13748 = 232
dummy32$7 = 232
dmsHighLimit$1$ = 240
dictLimit$1$ = 240
dictLimit$1$ = 240
dictLimit$1$ = 240
base$1$ = 240
base$1$ = 240
base$1$ = 240
dmsEnd$1$ = 240
opt$1$ = 248
commonLengthLarger$2$ = 256
commonLengthLarger$1$ = 256
prefixStart$1$ = 256
prefixStart$1$ = 256
prefixStart$1$ = 256
dmsBase$1$ = 264
dmsBase$1$ = 264
dmsBase$1$ = 264
commonLengthLarger$1$ = 264
basePrice$1$ = 264
dmsBt$1$ = 272
dms$1$ = 272
dmsBt$1$ = 272
dmsBt$1$ = 272
tv13803 = 272
tv13793 = 272
tv13783 = 272
minMatch$1$ = 280
optStatePtr$1$ = 288
dmsBase$1$ = 296
dmsBase$1$ = 296
dmsBase$1$ = 296
dmsBase$1$ = 296
tv13857 = 304
lastSequence$5$ = 312
bt$1$ = 320
bt$1$ = 320
bt$1$ = 320
bt$1$ = 320
nextToUpdate3$8 = 328
sufficient_len$1$ = 332
dmsBt$1$ = 336
dms$1$ = 336
lastSequence$9 = 344
lastSequence$4$ = 376
ilimit$1$ = 384
$T10 = 432
$T11 = 448
ms$ = 544
seqStore$ = 552
rep$ = 560
src$ = 568
nbMatches$1$ = 576
nextPtr$1$ = 576
nextPtr$1$ = 576
nextPtr$1$ = 576
nbCompares$1$ = 576
commonLengthLarger$2$ = 576
commonLengthLarger$2$ = 576
commonLengthLarger$2$ = 576
commonLengthLarger$2$ = 576
inr$1$ = 576
ll0$1$ = 576
dummy32$12 = 576
r$13 = 576
dummy32$14 = 576
dummy32$15 = 576
r$16 = 576
dummy32$17 = 576
r$18 = 576
srcSize$ = 576
ZSTD_compressBlock_btopt_dictMatchState PROC

; 1173 : {

$LN2055:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rsp-224]
	sub	rsp, 480				; 000001e0H

; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [rcx+204]
	lea	r13, QWORD PTR [rcx+72]
	mov	ebx, DWORD PTR [rcx+24]
	mov	edx, 4095				; 00000fffH
	add	rbx, QWORD PTR [rcx+8]

; 1173 : {

	mov	rdi, r9

; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, edx
	mov	QWORD PTR optStatePtr$1$[rbp-256], r13
	cmovb	edx, eax

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	r12d, r12d
	cmp	DWORD PTR [rcx+200], 3
	mov	eax, r12d
	lea	r15, QWORD PTR [r9+r8]
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx
	setne	al
	mov	QWORD PTR iend$1$[rsp], r15
	add	eax, 3
	lea	rsi, QWORD PTR [r15-8]
	mov	DWORD PTR minMatch$1$[rbp-256], eax

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	xor	r9d, r9d
	mov	eax, DWORD PTR [rcx+36]
	mov	rdx, rdi
	mov	DWORD PTR nextToUpdate3$8[rbp-256], eax
	mov	rcx, r13
	mov	rax, QWORD PTR [r13+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [r13+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r12d
	sete	al
	lea	r9, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r9
	cmp	r9, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$9[rbp-240]
	mov	eax, DWORD PTR lastSequence$9[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	QWORD PTR [rsp+472], r14
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	6
$LL4@ZSTD_compr:

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	r13, QWORD PTR ms$[rbp-256]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r9d
	sub	eax, edi
	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r12d
	sete	al

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]
	mov	r14, QWORD PTR [r13+8]
	mov	esi, DWORD PTR [r13+200]

; 834  :             U32 const ll0 = !litlen;

	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r9, rax
	jb	$LN1905@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r9d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN129@ZSTD_compr
	npad	15
$LL128@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL128@ZSTD_compr
	mov	r9, QWORD PTR ip$1$[rsp]
$LN129@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN122@ZSTD_compr
	mov	r15, QWORD PTR [r13+8]
	mov	r14d, r9d
	mov	QWORD PTR base$1$[rbp-256], r15
	cmp	esi, 5
	je	$LN124@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN123@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	sub	r14d, r15d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r14d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r14d
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	dec	ecx
	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv13862[rbp-256], rax
	mov	ebx, 1
	mov	eax, DWORD PTR [r13+24]
	shl	ebx, cl
	mov	ecx, r12d
	mov	DWORD PTR dictLimit$1$[rbp-256], eax
	dec	ebx
	add	rax, r15
	mov	QWORD PTR bt$1$[rbp-256], rdi
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r14d
	sub	eax, ebx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv13689[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r9d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r9d, r9d
	mov	eax, 1

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	cmovne	eax, r9d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	edi, r12d
	add	rax, 4
	mov	r12d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r14+9]
	shl	r12d, cl
	mov	rcx, QWORD PTR [r13+176]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	QWORD PTR dms$1$[rbp-256], rcx
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	mov	r10d, eax
	sub	r10d, edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	eax, r9d
	mov	QWORD PTR dmsBase$1$[rbp-256], rdx
	mov	edx, DWORD PTR [rcx+28]
	sub	eax, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+192]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r8d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	dec	r8d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	sub	ecx, r8d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], r8d
	sub	eax, edx
	cmp	r8d, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	cmovae	ecx, edx
	dec	eax
	mov	DWORD PTR tv13760[rbp-256], ecx
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r14d
	sub	edx, DWORD PTR dictLimit$1$[rbp-256]
	mov	r13d, eax
	mov	QWORD PTR tv13857[rbp-256], rax
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13856[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r15d, DWORD PTR [rax+3]
	lea	r14, QWORD PTR [rcx+rax*4]
	npad	3
$LL644@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN711@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN712@ZSTD_compr
$LN711@ZSTD_compr:
	mov	ecx, DWORD PTR [r14]
$LN712@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, DWORD PTR current$1$[rsp]

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	r11d, edx
	jae	SHORT $LN649@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r9d
	setae	al
	test	ecx, eax
	je	$LN653@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1980@ZSTD_compr
$LN649@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1980@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1979@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1980@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR ip$1$[rsp]
$LN1979@ZSTD_compr:
	mov	r9d, DWORD PTR windowLow$1$[rsp]
$LN653@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN642@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, edi

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN642@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13856[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r14, 4
	cmp	ebx, r15d
	jb	$LL644@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13862[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1767@ZSTD_compr
	npad	7
$LL645@ZSTD_compr:
	dec	r12d
	cmp	esi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1972@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r11]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2004@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN669@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rsi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN669@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN670@ZSTD_compr
$LN1716@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	jmp	$LN1963@ZSTD_compr
$LN2004@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
$LN670@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r11]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN672@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13689[rsp]
	jbe	$LN1717@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r15

; 685  :         } else {

	jmp	SHORT $LN2036@ZSTD_compr
$LN672@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13689[rsp]
	jbe	$LN1718@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2036@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	jne	$LL645@ZSTD_compr
$LN1767@ZSTD_compr:
	dec	r12d
$LN1972@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN2037@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN646@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1963@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 6
	mov	rcx, r11
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	npad	11
$LL647@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1963@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r15]
	cmp	rcx, rax
	jb	SHORT $LN1985@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	esi, eax
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r15
	jmp	SHORT $LN677@ZSTD_compr
$LN1717@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$12[rbp-256]
	jmp	$LN646@ZSTD_compr
$LN1718@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$12[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2037@ZSTD_compr
$LN1985@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN677@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2024@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1843@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1843@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1963@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN680@ZSTD_compr
$LN2024@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN680@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13760[rbp-256]
	jbe	$LN1963@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN682@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rbx
	jmp	SHORT $LN683@ZSTD_compr
$LN682@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rsp]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN683@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL647@ZSTD_compr

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN1963@ZSTD_compr
$LN123@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	sub	r14d, r15d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r14d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r14d
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	dec	ecx
	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv13849[rbp-256], rax
	mov	ebx, 1
	mov	eax, DWORD PTR [r13+24]
	shl	ebx, cl
	mov	ecx, r12d
	mov	DWORD PTR dictLimit$1$[rbp-256], eax
	dec	ebx
	add	rax, r15
	mov	QWORD PTR bt$1$[rbp-256], rdi
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r14d
	sub	eax, ebx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv13688[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r9d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r9d, r9d
	mov	eax, 1

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	cmovne	eax, r9d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	edi, r12d
	add	rax, 4
	mov	r12d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r14+9]
	shl	r12d, cl
	mov	rcx, QWORD PTR [r13+176]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	QWORD PTR dms$1$[rbp-256], rcx
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	mov	r10d, eax
	sub	r10d, edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	eax, r9d
	mov	QWORD PTR dmsBase$1$[rbp-256], rdx
	mov	edx, DWORD PTR [rcx+28]
	sub	eax, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+192]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r8d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	dec	r8d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	sub	ecx, r8d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], r8d
	sub	eax, edx
	cmp	r8d, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	cmovae	ecx, edx
	dec	eax
	mov	DWORD PTR tv13756[rbp-256], ecx
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r14d
	sub	edx, DWORD PTR dictLimit$1$[rbp-256]
	mov	r13d, eax
	mov	QWORD PTR tv13857[rbp-256], rax
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13846[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r15d, DWORD PTR [rax+3]
	lea	r14, QWORD PTR [rcx+rax*4]
	npad	3
$LL304@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN371@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN372@ZSTD_compr
$LN371@ZSTD_compr:
	mov	ecx, DWORD PTR [r14]
$LN372@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, DWORD PTR current$1$[rsp]

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	r11d, edx
	jae	SHORT $LN309@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r9d
	setae	al
	test	ecx, eax
	je	$LN313@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1982@ZSTD_compr
$LN309@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1982@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1981@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1982@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR ip$1$[rsp]
$LN1981@ZSTD_compr:
	mov	r9d, DWORD PTR windowLow$1$[rsp]
$LN313@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN302@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, edi

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN302@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13846[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r14, 4
	cmp	ebx, r15d
	jb	$LL304@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13849[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1770@ZSTD_compr
	npad	7
$LL305@ZSTD_compr:
	dec	r12d
	cmp	esi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1973@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r11]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2006@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN329@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rsi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN329@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1716@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN330@ZSTD_compr
$LN2006@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
$LN330@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r11]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN332@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13688[rsp]
	jbe	$LN1723@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r15

; 685  :         } else {

	jmp	SHORT $LN2038@ZSTD_compr
$LN332@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13688[rsp]
	jbe	$LN1724@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2038@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	jne	$LL305@ZSTD_compr
$LN1770@ZSTD_compr:
	dec	r12d
$LN1973@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN2039@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN306@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1963@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 4
	mov	rcx, r11
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	npad	10
$LL307@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1963@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r15]
	cmp	rcx, rax
	jb	SHORT $LN1986@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	esi, eax
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r15
	jmp	SHORT $LN337@ZSTD_compr
$LN1723@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$15[rbp-256]
	jmp	$LN306@ZSTD_compr
$LN1724@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$15[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2039@ZSTD_compr
$LN1986@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN337@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2025@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1845@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1845@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1963@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN340@ZSTD_compr
$LN2025@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN340@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13756[rbp-256]
	jbe	$LN1963@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN342@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rbx
	jmp	SHORT $LN343@ZSTD_compr
$LN342@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rsp]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN343@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL307@ZSTD_compr

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN1963@ZSTD_compr
$LN124@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmp	eax, ecx
	cmovb	ecx, eax
	sub	r14d, r15d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r14d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r14d
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	dec	ecx
	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv13839[rbp-256], rax
	mov	ebx, 1
	mov	eax, DWORD PTR [r13+24]
	shl	ebx, cl
	mov	ecx, r12d
	mov	DWORD PTR dictLimit$1$[rbp-256], eax
	dec	ebx
	add	rax, r15
	mov	QWORD PTR bt$1$[rbp-256], rdi
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r14d
	sub	eax, ebx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv13687[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r9d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r9d, r9d
	mov	eax, 1

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	cmovne	eax, r9d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	edi, r12d
	add	rax, 4
	mov	r12d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r14+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	shl	r12d, cl
	mov	rcx, QWORD PTR [r13+176]
	mov	QWORD PTR dms$1$[rbp-256], rcx
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	mov	r10d, eax
	sub	r10d, edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	eax, r9d
	mov	QWORD PTR dmsBase$1$[rbp-256], rdx
	mov	edx, DWORD PTR [rcx+28]
	sub	eax, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+192]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r8d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	dec	r8d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d
	sub	eax, edx
	mov	DWORD PTR dmsBtMask$1$[rbp-256], r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	sub	ecx, r8d
	cmp	r8d, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	dec	eax
	cmovae	ecx, edx
	mov	QWORD PTR tv13857[rbp-256], rax
	mov	edx, r14d
	mov	DWORD PTR tv13752[rbp-256], ecx
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	r13d, eax
	sub	edx, DWORD PTR dictLimit$1$[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13836[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r15d, DWORD PTR [rax+3]
	lea	r14, QWORD PTR [rcx+rax*4]
$LL474@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN541@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN542@ZSTD_compr
$LN541@ZSTD_compr:
	mov	ecx, DWORD PTR [r14]
$LN542@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, DWORD PTR current$1$[rsp]

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	r11d, edx
	jae	SHORT $LN479@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r9d
	setae	al
	test	ecx, eax
	je	$LN483@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1984@ZSTD_compr
$LN479@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1984@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1983@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1984@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR ip$1$[rsp]
$LN1983@ZSTD_compr:
	mov	r9d, DWORD PTR windowLow$1$[rsp]
$LN483@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN472@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, edi

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN472@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13836[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r14, 4
	cmp	ebx, r15d
	jb	$LL474@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13839[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1773@ZSTD_compr
	npad	3
$LL475@ZSTD_compr:
	dec	r12d
	cmp	esi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1974@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r11]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2008@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN499@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rsi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN499@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1716@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN500@ZSTD_compr
$LN2008@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
$LN500@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r11]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN502@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13687[rsp]
	jbe	$LN1729@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r15

; 685  :         } else {

	jmp	SHORT $LN2040@ZSTD_compr
$LN502@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13687[rsp]
	jbe	$LN1730@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2040@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	jne	$LL475@ZSTD_compr
$LN1773@ZSTD_compr:
	dec	r12d
$LN1974@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN2041@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN476@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1963@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 5
	mov	rcx, r11
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	npad	10
$LL477@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1963@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r15+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1987@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r15+rax]
	add	rsi, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN507@ZSTD_compr
$LN1729@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$14[rbp-256]
	jmp	$LN476@ZSTD_compr
$LN1730@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$14[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2041@ZSTD_compr
$LN1987@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN507@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2026@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1847@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1847@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1963@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN510@ZSTD_compr
$LN2026@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN510@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13752[rbp-256]
	jbe	$LN1963@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN512@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rbx
	jmp	SHORT $LN513@ZSTD_compr
$LN512@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rsp]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN513@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL477@ZSTD_compr

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN1963@ZSTD_compr
$LN122@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, r9d
	mov	r12, QWORD PTR [r13+8]
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	mov	QWORD PTR base$1$[rsp], r12
	cmovb	ecx, eax
	sub	r15d, r12d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rbp-256], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r14d, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv13829[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	lea	rax, QWORD PTR [r12+r14]
	xor	ecx, ecx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	dec	ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR bt$1$[rbp-256], rdi
	cmp	ebx, r15d
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	mov	DWORD PTR dictLimit$1$[rbp-256], r14d
	cmovb	ecx, eax
	mov	DWORD PTR tv13686[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	cmovne	eax, edx
	and	ecx, r15d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rsp], eax
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	xor	edi, edi
	add	rax, 4
	shl	r12d, cl
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [r13+176]
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	sub	eax, r8d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	ecx, edx
	cmp	edx, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	dec	eax
	mov	edx, r15d
	cmovae	ecx, r8d
	mov	QWORD PTR tv13857[rbp-256], rax
	sub	edx, r14d
	mov	QWORD PTR bestLength$1$[rbp-256], rax
	mov	r13d, eax
	mov	DWORD PTR tv13748[rbp-256], ecx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]
	mov	rcx, QWORD PTR rep$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13826[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	r14, QWORD PTR [rcx+rax*4]
	npad	6
$LL134@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN201@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN202@ZSTD_compr
$LN201@ZSTD_compr:
	mov	eax, DWORD PTR [r14]
$LN202@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r15d

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r10d, eax
	xor	r8d, r8d
	cmp	ecx, edx
	jae	SHORT $LN139@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rcx, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, eax
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rcx]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rcx]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	$LN2030@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r9
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2051@ZSTD_compr
$LN139@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, r15d
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN2030@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r10, QWORD PTR ip$1$[rsp]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	mov	ecx, DWORD PTR [r10]
	shl	ecx, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN143@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r10+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2051@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
$LN2030@ZSTD_compr:
	mov	r10, QWORD PTR ip$1$[rsp]
$LN143@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN132@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+rdi*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r10]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	cmp	rax, r9
	mov	r13d, edx
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN132@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	ebx
	add	r14, 4
	cmp	ebx, r11d
	jae	SHORT $LN1936@ZSTD_compr
	mov	edx, DWORD PTR tv13826[rbp-256]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL134@ZSTD_compr
$LN1936@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN1990@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r14, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$8[rbp-256]
	mov	rcx, r14
	mov	r8, r10
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	r11d, r11d
	mov	edx, r11d
	mov	ecx, r11d
	mov	ebx, r15d
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	SHORT $LN2011@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	xor	r11d, r11d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1991@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rbx+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, r11d
	mov	QWORD PTR bestLength$1$[rbp-256], rax
	mov	r13, rax
	lea	edi, QWORD PTR [r11+1]
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+r10]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	mov	edx, r11d
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1991@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]
	mov	DWORD PTR [r14+36], eax

; 635  :                     return 1;

	jmp	$LN131@ZSTD_compr
$LN1990@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	r11d, r11d
	jmp	SHORT $LN152@ZSTD_compr
$LN1991@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN152@ZSTD_compr
$LN2011@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	r10, QWORD PTR ip$1$[rsp]
$LN152@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv13829[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1776@ZSTD_compr
$LL135@ZSTD_compr:
	dec	r12d
	cmp	esi, r8d
	jb	$LN1975@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rbx+r10]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2010@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN159@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rsi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN159@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rbp-256]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r10]
	cmp	rax, r9
	mov	ecx, r11d
	mov	eax, r11d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN160@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN1963@ZSTD_compr
$LN2010@ZSTD_compr:

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
	mov	r10, QWORD PTR ip$1$[rsp]
$LN160@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r10]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN162@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13686[rsp]
	jbe	SHORT $LN1735@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r15

; 685  :         } else {

	jmp	SHORT $LN2042@ZSTD_compr
$LN162@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13686[rsp]
	jbe	SHORT $LN1736@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2042@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	je	SHORT $LN1776@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL135@ZSTD_compr
$LN1735@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$17[rbp-256]
	jmp	SHORT $LN136@ZSTD_compr
$LN1736@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$17[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	SHORT $LN1975@ZSTD_compr
$LN1776@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r12d
$LN1975@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN136@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1963@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 3
	mov	rcx, r10
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	npad	8
$LL137@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1963@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r15+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1989@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r15+rax]
	add	rsi, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN167@ZSTD_compr
$LN1989@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN167@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2027@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1849@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1849@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rbp-256]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1963@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN170@ZSTD_compr
$LN2027@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN170@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13748[rbp-256]
	jbe	SHORT $LN1963@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN172@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rbx
	jmp	SHORT $LN173@ZSTD_compr
$LN172@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rsp]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN173@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL137@ZSTD_compr
$LN1963@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN131@ZSTD_compr:
	test	edi, edi
	je	$LN2028@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	rcx, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */

	xor	r15d, r15d
	mov	rsi, QWORD PTR rep$[rbp-256]

; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rdx, r13
	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [rcx+16], eax
	mov	eax, DWORD PTR [rsi+4]
	mov	DWORD PTR [rcx+20], eax
	mov	eax, DWORD PTR [rsi+8]
	mov	DWORD PTR [rcx+24], eax
	mov	DWORD PTR [rcx+8], r15d
	mov	DWORD PTR [rcx+12], ebx
	mov	ecx, ebx
	call	ZSTD_litLengthPrice
	mov	r10, QWORD PTR opt$1$[rbp-256]

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r14, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [r10], eax
	lea	eax, DWORD PTR [rdi-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r14+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	SHORT $LN35@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;

	mov	DWORD PTR lastSequence$9[rbp-248], eax

; 858  :                     lastSequence.off = maxOffset;

	mov	eax, DWORD PTR [r14+rcx*8]

; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	r14d, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$9[rbp-252], eax
	mov	DWORD PTR lastSequence$9[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$9[rbp-256]
	jmp	$LN2043@ZSTD_compr
$LN35@ZSTD_compr:

; 864  :             }   }
; 865  : 
; 866  :             /* set prices for first matches starting position == 0 */
; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	r10, QWORD PTR opt$1$[rbp-256]
	mov	rdx, QWORD PTR tv13857[rbp-256]
	mov	rcx, rdx
	mov	esi, DWORD PTR [r10]
	add	esi, eax
	lea	ebx, DWORD PTR [rdx+1]
	lea	rax, QWORD PTR [r10+28]
	npad	11
$LL11@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rax], 1073741824		; 40000000H
	lea	rax, QWORD PTR [rax+28]
	sub	rcx, 1
	jne	SHORT $LL11@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	edi, edi
	je	$LN13@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	mov	eax, edi
	mov	r13, r14
	mov	QWORD PTR tv13874[rsp], rax
	mov	QWORD PTR tv13700[rsp], r14
	npad	9
$LL14@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [r13+4]
	mov	r14d, DWORD PTR [r13]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	ebx, r15d
	ja	$LN12@ZSTD_compr
	mov	r13d, DWORD PTR litlen$1$[rbp-256]
	lea	r12d, DWORD PTR [r14+1]
	mov	r11, QWORD PTR optStatePtr$1$[rbp-256]
	npad	3
$LL17@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edx, edx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	r8d, edx
	mov	DWORD PTR r$18[rbp-256], edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	DWORD PTR r$16[rbp-256], edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [r11+80], 1
	jne	SHORT $LN856@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	lea	eax, DWORD PTR [rbx-2]
	bsr	ecx, eax
	mov	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	edx, DWORD PTR [r8+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	edx, eax
	shl	edx, 8
	add	edx, esi
	jmp	$LN855@ZSTD_compr
$LN856@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [r11+24]
	mov	edi, r8d
	mov	eax, DWORD PTR [rax+r8*4]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	edi, eax
	shl	edi, 8
	add	edi, DWORD PTR [r11+76]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r8d, 20
	jb	SHORT $LN857@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r8d, 9
	add	edi, -9728				; ffffda00H
	add	edi, r8d
$LN857@ZSTD_compr:

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rbx-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r11, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
	mov	r10, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	mov	eax, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$13[rbp-256], r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r11+16]
	mov	eax, DWORD PTR [rdx+rax]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 283  :     return price;

	lea	rcx, OFFSET FLAT:ML_bits
	mov	edx, DWORD PTR [rdx+rcx]
	sub	edx, eax
	shl	edx, 8
	add	edx, 51					; 00000033H
	add	edx, DWORD PTR [r11+72]
	add	edx, esi
	add	edx, edi
$LN855@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+r10+8], ebx
	inc	ebx

; 882  :                         opt[pos].off = offset;

	mov	DWORD PTR [rcx+r10+4], r14d

; 883  :                         opt[pos].litlen = litlen;

	mov	DWORD PTR [rcx+r10+12], r13d

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+r10], edx
	cmp	ebx, r15d
	jbe	$LL17@ZSTD_compr
	mov	r13, QWORD PTR tv13700[rsp]
	mov	rax, QWORD PTR tv13874[rsp]
$LN12@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	r13, 8
	sub	rax, 1
	mov	QWORD PTR tv13700[rsp], r13
	mov	QWORD PTR tv13874[rsp], rax
	jne	$LL14@ZSTD_compr
	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
$LN13@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;

	dec	ebx

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r8d, 1
	mov	DWORD PTR seqPos$1$[rsp], ebx
	mov	DWORD PTR cur$1$[rbp-256], r8d
	cmp	ebx, r8d
	jb	$LN1943@ZSTD_compr
	npad	1
$LL20@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r15d, DWORD PTR [r8-1]
	imul	rdi, r15, 28
	mov	r12d, r8d
	add	rsi, r12
	add	rdi, r10
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN57@ZSTD_compr
	mov	r14d, DWORD PTR [rdi+12]
	inc	r14d
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	r14d, 1
$LN58@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	lea	ecx, DWORD PTR [r14-1]
	xor	r8d, r8d
	mov	rdx, r13
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	xor	r9d, r9d
	mov	r8, r13
	sub	edi, eax
	lea	edx, QWORD PTR [r9+1]
	call	ZSTD_rawLiteralsCost
	xor	r8d, r8d
	mov	rdx, r13
	mov	ecx, r14d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	add	eax, edi
	imul	rdi, r12, 28
	xor	r12d, r12d
	add	rdi, r10
	cmp	eax, DWORD PTR [rdi]
	jg	SHORT $LN1926@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [rdi+4], r12

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [rdi+12], r14d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [rdi], eax
$LN1926@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [rdi+8]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;

	mov	eax, DWORD PTR cur$1$[rbp-256]

; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	lea	rdx, QWORD PTR [r10+16]
	cmp	DWORD PTR [rdi+12], 0
	mov	r9d, r12d
	mov	r8d, DWORD PTR [rdi+4]
	sete	r9b
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));
; 929  :             } else {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rdi+16], xmm0
	mov	DWORD PTR [rdi+24], ecx
	jmp	SHORT $LN39@ZSTD_compr
$LN38@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r15, 28
	movsd	xmm0, QWORD PTR [rax+r10+16]
	mov	eax, DWORD PTR [rax+r10+24]
	movsd	QWORD PTR [rdi+16], xmm0
	mov	DWORD PTR [rdi+24], eax
$LN39@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	mov	r8d, DWORD PTR cur$1$[rbp-256]
	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r8d, ebx
	je	$LN1943@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {

	mov	r14d, DWORD PTR [rdi]
	lea	ecx, DWORD PTR [r8+1]
	imul	rdx, rcx, 28
	lea	eax, DWORD PTR [r14+128]
	cmp	DWORD PTR [rdx+r10], eax
	jle	$LN18@ZSTD_compr

; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [rdi+8]
	mov	ecx, r12d
	test	eax, eax
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_compr
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN60@ZSTD_compr
$LN59@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], r12d
$LN60@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;
; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	add	eax, r14d

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	rdi, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	rax, QWORD PTR ms$[rbp-256]

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	mov	QWORD PTR rep$1$[rbp-256], rdi

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [rax+36]
	mov	r12, QWORD PTR [rax+8]
	mov	r15d, DWORD PTR [rax+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN2032@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN933@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	rbx, rax
	npad	6
$LL932@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rsi
	mov	rcx, rbx
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL932@ZSTD_compr
	mov	ebx, DWORD PTR seqPos$1$[rsp]
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN933@ZSTD_compr:

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	r12, QWORD PTR ms$[rbp-256]

; 756  :     switch(matchLengthSearch)

	mov	ecx, 4095				; 00000fffH
	mov	rdi, QWORD PTR [r12+48]

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], r14d

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r12+192]
	cmp	r15d, 3
	je	$LN926@ZSTD_compr
	mov	r13d, esi
	cmp	r15d, 5
	je	$LN928@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN927@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13813[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rsp]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13685[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rbp-256], eax

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r11d, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r13d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r13d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	eax, r8d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13857[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8, QWORD PTR rep$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13728[rbp-256], ecx
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	edx, ecx
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r12d, DWORD PTR [rax+3]
	mov	DWORD PTR tv13810[rbp-256], edx

; 521  :     const BYTE* const base = ms->window.base;

	lea	r15, QWORD PTR [r8+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1448@ZSTD_compr
	npad	1
$LL1994@ZSTD_compr:
	mov	ecx, DWORD PTR current$1$[rsp]
$LN1448@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1515@ZSTD_compr
	mov	eax, DWORD PTR [r8]
	dec	eax
	jmp	SHORT $LN1516@ZSTD_compr
$LN1515@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1516@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, ecx

; 569  :             U32 repLen = 0;

	xor	r8d, r8d
	sub	r10d, eax

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	jae	SHORT $LN1453@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r9d, eax
	neg	r9
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	cl
	xor	r10d, r10d
	cmp	edx, DWORD PTR [r9+rsi]
	mov	eax, r10d
	sete	al
	test	ecx, eax
	je	$LN1457@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2044@ZSTD_compr
$LN1453@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	r10d, r10d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r10d
	setae	al
	test	edx, eax
	je	SHORT $LN1457@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1457@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2044@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR nbMatches$1$[rbp-256]
	xor	r10d, r10d
$LN1457@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1446@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, r11d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r11d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, edi
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, r9
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r10d
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	sete	cl
	mov	eax, r10d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1446@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13810[rbp-256]
	inc	edi
	mov	r8, QWORD PTR rep$1$[rbp-256]
	add	r15, 4
	cmp	edi, r12d
	jb	$LL1994@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13813[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r13d, r13d
	je	$LN1784@ZSTD_compr
	npad	6
$LL1449@ZSTD_compr:
	dec	r13d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1976@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rsi+rdi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN2015@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1473@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1473@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r10d, r10d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r10d
	mov	eax, r10d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1474@ZSTD_compr
$LN1740@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2046@ZSTD_compr
$LN2015@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
$LN1474@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1476@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13685[rbp-256]
	jbe	$LN1741@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r12, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r12

; 685  :         } else {

	jmp	SHORT $LN2045@ZSTD_compr
$LN1476@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13685[rbp-256]
	jbe	$LN1742@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN2045@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, DWORD PTR [r12]
	test	r13d, r13d
	jne	$LL1449@ZSTD_compr
$LN1784@ZSTD_compr:
	dec	r13d
$LN1976@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1450@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r13d, r13d
	je	$LN1743@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 6
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r15d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	npad	11
$LL1451@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r13d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1964@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	mov	eax, DWORD PTR dmsBtMask$1$[rbp-256]

; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rdi, rcx

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	and	eax, r15d

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	add	eax, eax
	cmp	rdx, rcx
	mov	r12d, r15d
	cmovb	rdi, rdx
	add	r14, r12
	lea	rax, QWORD PTR [r8+rax*4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rsi+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rcx, rax
	jb	SHORT $LN1997@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	r14d, eax
	add	r14, QWORD PTR base$1$[rsp]
	add	r14, r12
	jmp	SHORT $LN1481@ZSTD_compr
$LN1741@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$7[rbp-256]
	jmp	$LN1450@ZSTD_compr
$LN1742@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$7[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN1976@ZSTD_compr
$LN1997@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN1481@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1484@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+r15]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1852@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1852@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, ebx
	inc	ebx
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], edi
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rsi+rdi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1964@ZSTD_compr
$LN1484@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13728[rbp-256]
	jbe	SHORT $LN1964@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN1486@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rdx, rdi

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	jmp	SHORT $LN1487@ZSTD_compr
$LN1486@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rcx, rdi
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rsp]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
$LN1487@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r13d, r13d
	jne	$LL1451@ZSTD_compr
$LN1964@ZSTD_compr:
	mov	DWORD PTR nbMatches$1$[rbp-256], ebx
	mov	ebx, DWORD PTR seqPos$1$[rsp]
$LN1743@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2046@ZSTD_compr
$LN927@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13803[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rsp]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13684[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rbp-256], eax

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r11d, r11d
	mov	r9d, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r13d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r13d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r10d, ecx
	sub	r10d, r8d
	mov	QWORD PTR dmsEnd$1$[rsp], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	sub	eax, r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13857[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8d, DWORD PTR current$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13724[rbp-256], ecx
	mov	edx, r8d

; 521  :     const BYTE* const base = ms->window.base;

	mov	rcx, QWORD PTR rep$1$[rbp-256]
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r12d, DWORD PTR [rax+3]
	mov	DWORD PTR tv13800[rbp-256], edx

; 521  :     const BYTE* const base = ms->window.base;

	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1108@ZSTD_compr
$LL1995@ZSTD_compr:
	mov	r8d, DWORD PTR current$1$[rsp]
$LN1108@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1175@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1176@ZSTD_compr
$LN1175@ZSTD_compr:
	mov	ecx, DWORD PTR [r15]
$LN1176@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;

	mov	r8d, r11d
	sub	r10d, ecx

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	cmp	r11d, edx
	jae	SHORT $LN1113@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	r11d, r11d
	mov	edx, ecx
	mov	ecx, r11d
	neg	rdx
	cmp	eax, DWORD PTR [rsi+rdx]
	mov	eax, r11d
	sete	cl
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	$LN1117@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2052@ZSTD_compr
$LN1113@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	SHORT $LN1971@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1971@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2052@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	r11d, r11d
$LN1971@ZSTD_compr:
	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
$LN1117@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1106@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, r9d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, edi
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	cmp	rax, r10
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	sete	cl
	mov	eax, r11d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1106@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13800[rbp-256]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	add	r15, 4
	cmp	edi, r12d
	jb	$LL1995@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13803[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r13d, r13d
	je	$LN1787@ZSTD_compr
	npad	2
$LL1109@ZSTD_compr:
	dec	r13d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1977@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN2013@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1133@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1133@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r11d
	mov	eax, r11d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1134@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2046@ZSTD_compr
$LN2013@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
$LN1134@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1136@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13684[rbp-256]
	jbe	$LN1747@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r12, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r12

; 685  :         } else {

	jmp	SHORT $LN2047@ZSTD_compr
$LN1136@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13684[rbp-256]
	jbe	$LN1748@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN2047@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, DWORD PTR [r12]
	test	r13d, r13d
	jne	$LL1109@ZSTD_compr
$LN1787@ZSTD_compr:
	dec	r13d
$LN1977@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1110@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r13d, r13d
	je	$LN1743@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 4
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r15d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL1111@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r13d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1964@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	mov	rdi, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r12d, r15d
	cmp	rdx, rcx
	cmovb	rdi, rdx
	add	r14, r12
	lea	rax, QWORD PTR [r8+rax*4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rdi+rsi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rcx, rax
	jb	SHORT $LN1998@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	r14, QWORD PTR [r12+rax]
	add	r14, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN1141@ZSTD_compr
$LN1747@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$2[rbp-256]
	jmp	$LN1110@ZSTD_compr
$LN1748@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$2[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN1977@ZSTD_compr
$LN1998@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN1141@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1144@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1854@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1854@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, ebx
	inc	ebx
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], edi
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1964@ZSTD_compr
$LN1144@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13724[rbp-256]
	jbe	$LN1964@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN1146@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rdx, rdi

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
	jmp	SHORT $LN1147@ZSTD_compr
$LN1146@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rcx, rdi
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
$LN1147@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r13d, r13d
	jne	$LL1111@ZSTD_compr

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR nbMatches$1$[rbp-256], ebx
	mov	ebx, DWORD PTR seqPos$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2046@ZSTD_compr
$LN928@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmp	eax, ecx
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13793[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rsp]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13683[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rbp-256], eax

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r11d, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r13d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r13d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rsp], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	sub	eax, r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13857[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8, QWORD PTR rep$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13718[rbp-256], ecx
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	edx, ecx
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r12d, DWORD PTR [rax+3]
	mov	DWORD PTR tv13790[rbp-256], edx

; 521  :     const BYTE* const base = ms->window.base;

	lea	r15, QWORD PTR [r8+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1278@ZSTD_compr
	npad	6
$LL1996@ZSTD_compr:
	mov	ecx, DWORD PTR current$1$[rsp]
$LN1278@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1345@ZSTD_compr
	mov	eax, DWORD PTR [r8]
	dec	eax
	jmp	SHORT $LN1346@ZSTD_compr
$LN1345@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1346@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, ecx

; 569  :             U32 repLen = 0;

	xor	r8d, r8d
	sub	r10d, eax

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	jae	SHORT $LN1283@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r9d, eax
	neg	r9
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	cl
	xor	r10d, r10d
	cmp	edx, DWORD PTR [r9+rsi]
	mov	eax, r10d
	sete	al
	test	ecx, eax
	je	$LN1287@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2048@ZSTD_compr
$LN1283@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	r10d, r10d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r10d
	setae	al
	test	edx, eax
	je	SHORT $LN1287@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1287@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2048@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR nbMatches$1$[rbp-256]
	xor	r10d, r10d
$LN1287@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1276@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, r11d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r11d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, edi
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, r9
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r10d
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	sete	cl
	mov	eax, r10d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1276@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13790[rbp-256]
	inc	edi
	mov	r8, QWORD PTR rep$1$[rbp-256]
	add	r15, 4
	cmp	edi, r12d
	jb	$LL1996@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13793[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r13d, r13d
	je	$LN1790@ZSTD_compr
	npad	5
$LL1279@ZSTD_compr:
	dec	r13d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1978@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2017@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1303@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1303@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r10d, r10d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r10d
	mov	eax, r10d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1740@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1304@ZSTD_compr
$LN2017@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
$LN1304@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1306@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13683[rbp-256]
	jbe	$LN1753@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r12, 4
	mov	QWORD PTR smallerPtr$1$[rsp], r12

; 685  :         } else {

	jmp	SHORT $LN2049@ZSTD_compr
$LN1306@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13683[rbp-256]
	jbe	$LN1754@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN2049@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, DWORD PTR [r12]
	test	r13d, r13d
	jne	$LL1279@ZSTD_compr
$LN1790@ZSTD_compr:
	dec	r13d
$LN1978@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1280@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r13d, r13d
	je	$LN1743@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 5
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r15d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
	npad	6
$LL1281@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r13d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1964@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	mov	rdi, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r12d, r15d
	cmp	rdx, rcx
	cmovb	rdi, rdx
	add	r14, r12
	lea	rax, QWORD PTR [r8+rax*4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rdi+rsi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rcx, rax
	jb	SHORT $LN1999@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	r14, QWORD PTR [r12+rax]
	add	r14, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN1311@ZSTD_compr
$LN1753@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$1[rbp-256]
	jmp	$LN1280@ZSTD_compr
$LN1754@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$1[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN1978@ZSTD_compr
$LN1999@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN1311@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1314@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1856@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1856@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, ebx
	inc	ebx
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], edi
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1964@ZSTD_compr
$LN1314@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13718[rbp-256]
	jbe	$LN1964@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN1316@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rdx, rdi

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
	jmp	SHORT $LN1317@ZSTD_compr
$LN1316@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rcx, rdi
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
$LN1317@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r13d, r13d
	jne	$LL1281@ZSTD_compr

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR nbMatches$1$[rbp-256], ebx
	mov	ebx, DWORD PTR seqPos$1$[rsp]

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN2046@ZSTD_compr
$LN926@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r14d, DWORD PTR [rdi+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	ecx, DWORD PTR [r12+188]
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r12d, DWORD PTR [r12+24]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR tv13783[rbp-256], rax
	mov	edi, 1
	shl	edi, cl
	mov	eax, r12d
	add	rax, QWORD PTR base$1$[rsp]
	xor	ecx, ecx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR btMask$1$[rbp-256], edi
	cmovb	ecx, eax
	mov	DWORD PTR dictLimit$1$[rbp-256], r12d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR tv13682[rbp-256], ecx
	mov	rcx, rax
	mov	r8d, DWORD PTR [rax+184]
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r15d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rsp], eax
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r13d, 1
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	xor	r15d, r15d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR nbMatches$1$[rbp-256], r15d
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r13d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [rax+188]
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	dec	ecx
	mov	r8d, DWORD PTR [rax+28]
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsLowLimit$1$[rbp-256], r8d
	shl	edx, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	dec	edx
	sub	eax, r8d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13857[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8, QWORD PTR rep$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13714[rbp-256], ecx
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	edx, ecx
	sub	edx, r12d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	r12, QWORD PTR [r8+rax*4]
	mov	DWORD PTR tv13780[rbp-256], edx
$LL938@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1005@ZSTD_compr
	mov	eax, DWORD PTR [r8]
	dec	eax
	jmp	SHORT $LN1006@ZSTD_compr
$LN1005@ZSTD_compr:
	mov	eax, DWORD PTR [r12]
$LN1006@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, ecx

; 569  :             U32 repLen = 0;

	xor	r8d, r8d
	sub	r10d, eax

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	jae	SHORT $LN943@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r9d, eax
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [rsi+r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	$LN2035@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2053@ZSTD_compr
$LN943@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rbp-256]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	r10d, r10d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r10d
	setae	al
	test	edx, eax
	je	SHORT $LN947@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [rsi]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN947@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2053@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
$LN2035@ZSTD_compr:
	xor	r10d, r10d
$LN947@ZSTD_compr:
	mov	r9, QWORD PTR bestLength$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r9
	jbe	SHORT $LN936@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r15*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r15d
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r10d
	mov	eax, r10d
	mov	QWORD PTR bestLength$1$[rsp], rdx
	sete	cl
	mov	DWORD PTR nbMatches$1$[rbp-256], r15d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	mov	r9d, edx
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN936@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	edi
	add	r12, 4
	cmp	edi, r11d
	jae	SHORT $LN1941@ZSTD_compr
	mov	edx, DWORD PTR tv13780[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	r8, QWORD PTR rep$1$[rbp-256]
	jmp	$LL938@ZSTD_compr
$LN1941@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r9, 3
	jae	$LN1993@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r12, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$8[rbp-256]
	mov	rcx, r12
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	r10d, r10d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r10d
	mov	ecx, r10d
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN2020@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
	cmp	rax, 3
	jb	$LN2001@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rdi+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, r10d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	DWORD PTR nbMatches$1$[rbp-256], 1
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+rsi]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	mov	edx, r10d
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	$LN2001@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], 1
	mov	DWORD PTR [r12+36], eax
	jmp	$LN935@ZSTD_compr
$LN1993@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
$LN2020@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN956@ZSTD_compr:
	mov	rax, QWORD PTR tv13783[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r13d, r13d
	je	$LN1793@ZSTD_compr
$LL939@ZSTD_compr:
	dec	r13d
	cmp	r14d, r8d
	jb	$LN1988@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	$LN2019@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN963@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN963@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r10d, r10d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r10d
	mov	eax, r10d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN964@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN1761@ZSTD_compr
$LN2001@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LN956@ZSTD_compr
$LN2019@ZSTD_compr:

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
$LN964@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN966@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13682[rbp-256]
	jbe	SHORT $LN1759@ZSTD_compr

; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN967@ZSTD_compr
$LN966@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13682[rbp-256]
	jbe	SHORT $LN1760@ZSTD_compr

; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN967@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r13d, r13d
	je	SHORT $LN1793@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL939@ZSTD_compr
$LN1759@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$3[rbp-256]
	jmp	SHORT $LN940@ZSTD_compr
$LN1760@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$3[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	SHORT $LN1988@ZSTD_compr
$LN1793@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r13d
$LN1988@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN940@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r13d, r13d
	je	$LN1969@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 3
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r15d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL941@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r13d
	mov	DWORD PTR nbCompares$1$[rbp-256], r13d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rbp-256]
	jbe	$LN1967@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	mov	rdi, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	add	eax, eax
	cmp	rdx, rcx
	mov	r12d, r15d
	cmovb	rdi, rdx
	add	r14, r12
	lea	r13, QWORD PTR [r8+rax*4]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rdi]
	lea	rcx, QWORD PTR [rdi+rsi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+r12]
	cmp	rcx, rax
	jb	SHORT $LN2000@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	r14d, eax
	add	r14, QWORD PTR base$1$[rsp]
	add	r14, r12
	jmp	SHORT $LN971@ZSTD_compr
$LN2000@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN971@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN974@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1858@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1858@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, ebx
	inc	ebx
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], edi
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1967@ZSTD_compr
$LN974@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13714[rbp-256]
	jbe	SHORT $LN1967@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r14+rdi], al
	jae	SHORT $LN976@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [r13+4]
	mov	rdx, rdi

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
	jmp	SHORT $LN977@ZSTD_compr
$LN976@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	rcx, rdi
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
$LN977@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r13d, DWORD PTR nbCompares$1$[rbp-256]
	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r13d, r13d
	jne	$LL941@ZSTD_compr
$LN1967@ZSTD_compr:
	mov	DWORD PTR nbMatches$1$[rbp-256], ebx
	mov	ebx, DWORD PTR seqPos$1$[rsp]
$LN1969@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
$LN1761@ZSTD_compr:
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
$LN2046@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR ms$[rbp-256]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN935@ZSTD_compr:
	mov	r13d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r8d, DWORD PTR cur$1$[rbp-256]
	test	r13d, r13d
	je	$LN2022@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r14, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r13-1]
	mov	edx, eax
	mov	ecx, DWORD PTR [r14+rax*8+4]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1764@ZSTD_compr
	lea	eax, DWORD PTR [rcx+r8]
	cmp	eax, 4096				; 00001000H
	jae	$LN1764@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	esi, esi
	mov	eax, esi
	mov	DWORD PTR matchNb$1$[rsp], eax
	test	r13d, r13d
	je	$LN2022@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	mov	rcx, r14
	mov	QWORD PTR tv13691[rsp], rcx
	npad	8
$LL23@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	r10d, DWORD PTR [rcx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rcx+4]
	mov	DWORD PTR offset$1$[rbp-256], r10d

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	eax, eax
	je	SHORT $LN63@ZSTD_compr
	mov	rcx, QWORD PTR tv13691[rsp]
	dec	eax
	mov	r12d, DWORD PTR [r14+rax*8+4]
	mov	eax, DWORD PTR matchNb$1$[rsp]
	inc	r12d
	jmp	SHORT $LN64@ZSTD_compr
$LN63@ZSTD_compr:
	mov	r12d, DWORD PTR minMatch$1$[rbp-256]
$LN64@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	cmp	edx, r12d
	jb	$LN21@ZSTD_compr
	mov	r11, QWORD PTR optStatePtr$1$[rbp-256]
	lea	r13d, DWORD PTR [r10+1]
	mov	r15d, r8d
	lea	edi, DWORD PTR [rdx+r8]
	neg	r15d
$LL26@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r13d
	mov	r8d, esi
	mov	DWORD PTR r$6[rbp-256], esi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r14d, DWORD PTR [r15+rdi]

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	DWORD PTR r$5[rbp-256], esi
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [r11+80], 1
	jne	SHORT $LN1618@ZSTD_compr

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	lea	eax, DWORD PTR [r14-2]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, esi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r8+16]
	add	ecx, eax
	shl	ecx, 8
	jmp	SHORT $LN1617@ZSTD_compr
$LN1618@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [r11+24]
	mov	eax, DWORD PTR [rax+r8*4]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, esi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	esi, r8d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	esi, eax
	shl	esi, 8
	add	esi, DWORD PTR [r11+76]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r8d, 20
	jb	SHORT $LN1619@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r8d, 9
	add	esi, -9728				; ffffda00H
	add	esi, r8d
$LN1619@ZSTD_compr:

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r14-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r11, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
	mov	r10d, DWORD PTR offset$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	mov	eax, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$4[rbp-256], r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r11+16]
	mov	eax, DWORD PTR [rdx+rax]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdx+rcx]
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, 51					; 00000033H
	add	ecx, DWORD PTR [r11+72]
	add	ecx, esi
	xor	esi, esi
$LN1617@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]
	add	edx, ecx

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	cmp	edi, ebx
	ja	SHORT $LN1956@ZSTD_compr
	mov	eax, edi
	imul	rcx, rax, 28
	mov	rax, QWORD PTR opt$1$[rbp-256]
	cmp	edx, DWORD PTR [rcx+rax]
	jge	SHORT $LN1968@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN28@ZSTD_compr
$LN1956@ZSTD_compr:
	mov	r13, QWORD PTR opt$1$[rbp-256]
	npad	14
$LL27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+r13], 1073741824		; 40000000H
	cmp	ebx, edi
	jb	SHORT $LL27@ZSTD_compr
	mov	DWORD PTR seqPos$1$[rsp], ebx
	lea	r13d, DWORD PTR [r10+1]
$LN28@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;
; 989  :                             opt[pos].off = offset;
; 990  :                             opt[pos].litlen = litlen;

	mov	r8d, DWORD PTR litlen$1$[rbp-256]
	mov	eax, edi
	dec	edi
	imul	rcx, rax, 28
	mov	rax, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR [rcx+rax+8], r14d
	mov	DWORD PTR [rcx+rax+4], r10d
	mov	DWORD PTR [rcx+rax+12], r8d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rax], edx
	lea	eax, DWORD PTR [r15+rdi]
	cmp	eax, r12d
	jae	$LL26@ZSTD_compr
$LN1968@ZSTD_compr:
	mov	r13d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR matchNb$1$[rsp]
	mov	rcx, QWORD PTR tv13691[rsp]
	mov	r14, QWORD PTR matches$1$[rbp-256]
	mov	r8d, DWORD PTR cur$1$[rbp-256]
$LN21@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	inc	eax
	add	rcx, 8
	mov	DWORD PTR matchNb$1$[rsp], eax
	mov	QWORD PTR tv13691[rsp], rcx
	cmp	eax, r13d
	jb	$LL23@ZSTD_compr
$LN2022@ZSTD_compr:

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
	jmp	SHORT $LN18@ZSTD_compr
$LN2032@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r8d, DWORD PTR cur$1$[rbp-256]
$LN18@ZSTD_compr:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	inc	r8d
	mov	DWORD PTR cur$1$[rbp-256], r8d
	cmp	r8d, ebx
	jbe	$LL20@ZSTD_compr
$LN1943@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	rsi, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+r10]
	mov	r14d, DWORD PTR [rdx+r10+24]
	movsd	xmm0, QWORD PTR [rdx+r10+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$9[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], r14d

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	SHORT $LN65@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r15d, r15d
	jmp	SHORT $_shortestPath$2056
$LN1764@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r14+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r15d, r15d
	mov	r10, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$9[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$9[rbp-244], eax
	mov	eax, r8d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$9[rbp-248], ecx
	cmp	DWORD PTR [rax+r10+8], r15d
	jne	SHORT $LN61@ZSTD_compr
	mov	eax, DWORD PTR [rax+r10+12]
	jmp	SHORT $LN62@ZSTD_compr
$LN61@ZSTD_compr:
	mov	eax, r15d
$LN62@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$9[rbp-256]
	mov	rsi, QWORD PTR rep$[rbp-256]
	sub	r8d, eax
	mov	r14d, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r8d, 4096				; 00001000H
	mov	ebx, r15d
	cmovbe	ebx, r8d
	jmp	SHORT $_shortestPath$2056
$LN65@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	xor	r15d, r15d
$LN2043@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	mov	ebx, r15d
$_shortestPath$2056:
	mov	eax, ebx
	lea	rdx, QWORD PTR [r10+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$9[rbp-248], 0
	je	SHORT $LN51@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T11[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r15d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));
; 1014 :         } else {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rsi], xmm0
	mov	DWORD PTR [rsi+8], ecx
	jmp	SHORT $LN52@ZSTD_compr
$LN51@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rsi+8], eax
$LN52@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	movups	xmm0, XMMWORD PTR lastSequence$9[rbp-256]
	lea	r12d, DWORD PTR [rbx+1]
	mov	eax, r12d
	mov	edi, r12d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r10], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r10+16], xmm0
	mov	DWORD PTR [rcx+r10+24], r14d

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_compr
	npad	9
$LL29@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r10
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r10], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r10+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r10+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r15d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_compr
$LN30@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
	cmp	edi, r12d
	ja	$LN32@ZSTD_compr
	mov	r8, QWORD PTR src$[rbp-256]
	npad	13
$LL33@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r10+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r10+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r10+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	jne	SHORT $LN53@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */

	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR ip$1$[rsp], rax

; 1051 :                         continue;   /* will finish */

	jmp	$LN31@ZSTD_compr
$LN53@ZSTD_compr:

; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, r13
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rdx, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+rdx]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1654@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1655@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [rdx+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
$LL1668@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1668@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN2050@ZSTD_compr
$LN1654@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
$LN2050@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	mov	rdx, QWORD PTR src$[rbp-256]
$LN1655@ZSTD_compr:
	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1861@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN1861@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1928@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN1928@ZSTD_compr:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
	mov	r10, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	eax, r15d
	add	rdx, rax
	mov	QWORD PTR src$[rbp-256], rdx
	mov	r8, rdx
	mov	QWORD PTR ip$1$[rsp], rdx
$LN31@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	inc	edi
	cmp	edi, r12d
	jbe	$LL33@ZSTD_compr
$LN32@ZSTD_compr:

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	xor	edx, edx
	mov	rcx, r13
	call	ZSTD_setBasePrices
	mov	r9, QWORD PTR ip$1$[rsp]
	jmp	SHORT $LN1801@ZSTD_compr
$LN2028@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r9, QWORD PTR ip$1$[rsp]
$LN1905@ZSTD_compr:
	inc	r9
	mov	QWORD PTR ip$1$[rsp], r9
$LN1801@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r12d, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r9, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL4@ZSTD_compr
	mov	r14, QWORD PTR [rsp+472]
$LN5@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rdi

; 1174 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0 /*optLevel*/, ZSTD_dictMatchState);

	mov	rax, r15

; 1175 : }

	add	rsp, 480				; 000001e0H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btopt_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchLow$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
current$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
tv11180 = 52
btMask$1$ = 56
matchEndIdx$1$ = 56
sufficient_len$1$ = 56
matchNb$1$ = 56
tv11183 = 56
tv11182 = 56
tv11181 = 56
tv11179 = 56
tv11177 = 56
iend$1$ = 64
smallerPtr$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
commonLengthLarger$1$ = 72
commonLengthLarger$1$ = 72
commonLengthLarger$1$ = 72
commonLengthSmaller$1$ = 72
tv11332 = 72
btMask$1$ = 80
nbCompares$1$ = 80
windowLow$1$ = 80
lastR$1$ = 80
nbCompares$1$ = 80
nbCompares$1$ = 80
windowLow$1$ = 80
offset$1$ = 80
dummy32$1 = 80
btMask$1$ = 84
btMask$1$ = 84
btMask$1$ = 84
matchLow$1$ = 84
ll0$1$ = 84
rep$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
matchLow$1$ = 96
matchLow$1$ = 96
matchLow$1$ = 96
current$1$ = 96
cur$1$ = 96
largerPtr$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
commonLengthSmaller$1$ = 104
commonLengthSmaller$1$ = 104
commonLengthSmaller$1$ = 104
base$1$ = 104
tv11194 = 104
tv11185 = 104
ip$1$ = 112
sufficient_len$1$ = 120
btMask$1$ = 120
matchLow$1$ = 120
sufficient_len$1$ = 120
btMask$1$ = 120
tv11310 = 120
tv11303 = 120
tv11296 = 120
windowLow$1$ = 124
matchLow$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
lastR$1$ = 124
tv11269 = 124
tv11176 = 124
windowLow$1$ = 128
windowLow$1$ = 128
windowLow$1$ = 128
litlen$1$ = 128
tv11289 = 128
lastR$1$ = 132
lastR$1$ = 132
lastR$1$ = 132
litlen$1$ = 132
tv11178 = 132
matchLow$1$ = 136
sufficient_len$1$ = 136
windowLow$1$ = 136
tv11255 = 136
r$2 = 136
r$3 = 136
r$4 = 136
lastR$1$ = 140
lastR$1$ = 140
lastR$1$ = 140
windowLow$1$ = 140
seqPos$1$ = 140
matches$1$ = 144
nbCompares$1$ = 152
sufficient_len$1$ = 152
btMask$1$ = 152
tv11276 = 152
tv11262 = 152
commonLengthLarger$1$ = 160
commonLengthSmaller$1$ = 160
commonLengthSmaller$1$ = 160
base$1$ = 160
bt$1$ = 160
bt$1$ = 160
bt$1$ = 160
bt$1$ = 160
commonLengthSmaller$1$ = 168
commonLengthLarger$1$ = 168
commonLengthLarger$1$ = 168
commonLengthSmaller$1$ = 168
base$1$ = 168
base$1$ = 168
base$1$ = 168
base$1$ = 176
base$1$ = 176
commonLengthLarger$1$ = 176
tv11314 = 176
tv11305 = 176
tv11298 = 176
tv11291 = 176
tv11278 = 176
minMatch$1$ = 184
opt$1$ = 192
tv11311 = 200
optStatePtr$1$ = 208
lastSequence$5$ = 216
bt$1$ = 224
bt$1$ = 224
bt$1$ = 224
bt$1$ = 224
base$1$ = 232
tv11271 = 232
tv11264 = 232
tv11257 = 232
nextToUpdate3$5 = 240
sufficient_len$1$ = 244
commonLengthLarger$1$ = 248
basePrice$1$ = 248
lastSequence$6 = 256
lastSequence$4$ = 288
ilimit$1$ = 296
$T7 = 336
$T8 = 352
ms$ = 448
seqStore$ = 456
rep$ = 464
src$ = 472
nbCompares$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
nbMatches$1$ = 480
inr$1$ = 480
ll0$1$ = 480
dummy32$9 = 480
dummy32$10 = 480
r$11 = 480
r$12 = 480
dummy32$13 = 480
r$14 = 480
srcSize$ = 480
ZSTD_compressBlock_btopt PROC

; 1072 : {

$LN1991:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-120]
	sub	rsp, 376				; 00000178H

; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]

; 1072 : {

	mov	r13, rcx

; 803  :     optState_t* const optStatePtr = &ms->opt;

	add	rcx, 72					; 00000048H

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH

; 1072 : {

	mov	rdi, r9

; 803  :     optState_t* const optStatePtr = &ms->opt;

	mov	QWORD PTR optStatePtr$1$[rbp-256], rcx

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]
	lea	r15, QWORD PTR [r9+r8]
	mov	ebx, DWORD PTR [r13+24]
	lea	rsi, QWORD PTR [r15-8]
	add	rbx, QWORD PTR [r13+8]
	cmp	eax, edx
	mov	QWORD PTR iend$1$[rsp], r15
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	cmovb	edx, eax

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	r14d, r14d
	cmp	DWORD PTR [r13+200], 3
	mov	eax, r14d
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	rdx, rdi
	setne	al
	xor	r9d, r9d
	add	eax, 3
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR nextToUpdate3$5[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r14d
	sete	al
	lea	r12, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	r12, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$6[rbp-240]
	mov	eax, DWORD PTR lastSequence$6[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	14
$LL4@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r12d

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r13+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, edi
	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r14d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r13+8]

; 834  :             U32 const ll0 = !litlen;

	sete	al
	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r12, rax
	jb	$LN1857@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r12d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN129@ZSTD_compr
	xor	r12d, r12d
	npad	3
$LL128@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL128@ZSTD_compr
	mov	r12, QWORD PTR ip$1$[rsp]
$LN129@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN122@ZSTD_compr
	cmp	esi, 5
	je	$LN124@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	mov	esi, r12d
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN123@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11314[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11183[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	esi, r12d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11311[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11310[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL644@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN711@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN712@ZSTD_compr
$LN711@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN712@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN651@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN651@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN651@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN642@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, esi
	inc	esi
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, r14d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN642@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11310[rsp]
	inc	r14d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	r14d, r10d
	jb	$LL644@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11314[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1922@ZSTD_compr
	npad	10
$LL645@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1922@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	r14d, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1955@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN669@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN669@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, esi
	inc	esi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN670@ZSTD_compr
$LN1922@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rax, QWORD PTR largerPtr$1$[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN1980@ZSTD_compr
$LN1955@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
$LN670@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN672@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11183[rsp]
	jbe	SHORT $LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN673@ZSTD_compr
$LN672@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11183[rsp]
	jbe	SHORT $LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN673@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL645@ZSTD_compr
	jmp	SHORT $LN1922@ZSTD_compr
$LN1709@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	lea	r13, QWORD PTR dummy32$10[rbp-256]
	jmp	SHORT $LN1922@ZSTD_compr
$LN1710@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$10[rbp-256]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN1980@ZSTD_compr
$LN123@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11305[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11182[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	esi, r12d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11311[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11303[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL304@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN371@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN372@ZSTD_compr
$LN371@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN372@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN311@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN311@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN311@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN302@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, esi
	inc	esi
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, r14d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN302@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11303[rsp]
	inc	r14d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	r14d, r10d
	jb	$LL304@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11305[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1922@ZSTD_compr
	npad	7
$LL305@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1922@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	r14d, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1957@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN329@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN329@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, esi
	inc	esi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1922@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN330@ZSTD_compr
$LN1957@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN330@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN332@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11182[rsp]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN333@ZSTD_compr
$LN332@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11182[rsp]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN333@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL305@ZSTD_compr
	jmp	$LN1922@ZSTD_compr
$LN124@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11298[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11181[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	esi, r12d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11311[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11296[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
	npad	4
$LL474@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN541@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN542@ZSTD_compr
$LN541@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN542@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN481@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN481@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN481@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN472@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, esi
	inc	esi
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, r14d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN472@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11296[rsp]
	inc	r14d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	r14d, r10d
	jb	$LL474@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11298[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1922@ZSTD_compr
$LL475@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1922@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	r14d, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1959@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN499@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN499@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, esi
	inc	esi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1922@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN500@ZSTD_compr
$LN1959@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN500@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN502@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11181[rsp]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN503@ZSTD_compr
$LN502@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11181[rsp]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN503@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL475@ZSTD_compr
	jmp	$LN1922@ZSTD_compr
$LN122@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11291[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11180[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	eax, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax
	mov	ecx, 1
	cmovne	ecx, eax
	mov	r9d, edx
	mov	DWORD PTR matchLow$1$[rsp], ecx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	and	ecx, esi
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	esi, r12d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	r9d, ebx
	mov	QWORD PTR tv11311[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11289[rbp-256], r9d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, eax
	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r11d
	lea	rbx, QWORD PTR [rcx+rax*4]
	npad	7
$LL134@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN201@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN202@ZSTD_compr
$LN201@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN202@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	xor	edx, edx
	sub	r10d, ecx
	mov	r8d, edx
	cmp	eax, r9d
	jae	SHORT $LN141@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rax]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rax]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN1932@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r9
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	mov	r11d, DWORD PTR lastR$1$[rsp]
	xor	edx, edx
	lea	r8d, DWORD PTR [rax+3]
$LN1932@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR tv11289[rbp-256]
$LN141@ZSTD_compr:
	mov	r10, QWORD PTR ip$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN132@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, r10
	mov	ecx, esi
	lea	rdx, QWORD PTR [rdx+rcx*8]
	inc	esi
	mov	ecx, r14d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN132@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r14d
	add	rbx, 4
	cmp	r14d, r11d
	jae	SHORT $LN1882@ZSTD_compr
	mov	edx, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL134@ZSTD_compr
$LN1882@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r12, 3
	jae	$LN1931@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$5[rbp-256]
	mov	r8, r10
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r14d, DWORD PTR current$1$[rsp]
	xor	edx, edx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	ebx, r14d
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	xor	ecx, ecx
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	SHORT $LN1962@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1941@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rbx+2]

; 632  :                 if ( (mlen > sufficient_len) |

	xor	r8d, r8d
	mov	r12, rax
	mov	esi, 1
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+r10]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	xor	edx, edx
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1941@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r14+1]

; 635  :                     return 1;

	jmp	$LN1983@ZSTD_compr
$LN1931@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r14d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1984@ZSTD_compr
$LN1941@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN152@ZSTD_compr
$LN1962@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR ip$1$[rsp]
	xor	edx, edx
$LN1984@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN152@ZSTD_compr:
	mov	rax, QWORD PTR tv11291[rbp-256]
	mov	DWORD PTR [rax], r14d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1936@ZSTD_compr
	npad	11
$LL135@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, r8d
	jb	$LN1936@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	r14d, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	r14, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rbx+r10]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	$LN1961@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN159@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN159@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, esi
	inc	esi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r10]
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN160@ZSTD_compr
$LN1936@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR largerPtr$1$[rsp]
$LN1749@ZSTD_compr:
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], edx
$LN1980@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	add	eax, -8					; fffffff8H
$LN1983@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [rcx+36], eax
$LN131@ZSTD_compr:
	test	esi, esi
	je	$LN1971@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	r13, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */

	xor	r12d, r12d
	mov	r14, QWORD PTR rep$[rbp-256]

; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	ecx, ebx
	mov	rdi, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rdx, rdi
	mov	eax, DWORD PTR [r14]
	mov	DWORD PTR [r13+16], eax
	mov	eax, DWORD PTR [r14+4]
	mov	DWORD PTR [r13+20], eax
	mov	eax, DWORD PTR [r14+8]
	mov	DWORD PTR [r13+24], eax
	mov	DWORD PTR [r13+8], r12d
	mov	DWORD PTR [r13+12], ebx
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [r13], eax
	lea	eax, DWORD PTR [rsi-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r15+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	$LN35@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;
; 858  :                     lastSequence.off = maxOffset;
; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$6[rbp-248], eax
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR lastSequence$6[rbp-252], eax
	mov	DWORD PTR lastSequence$6[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$6[rbp-256]
	jmp	$LN1986@ZSTD_compr
$LN1961@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	edx, edx
	mov	r10, QWORD PTR ip$1$[rsp]
$LN160@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r10]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN162@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11180[rsp]
	jbe	SHORT $LN1721@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN163@ZSTD_compr
$LN162@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11180[rsp]
	jbe	SHORT $LN1722@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN163@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	je	$LN1936@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL135@ZSTD_compr
$LN1721@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	r13, QWORD PTR dummy32$13[rbp-256]
	jmp	$LN1936@ZSTD_compr
$LN1722@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$13[rbp-256]
	jmp	$LN1749@ZSTD_compr
$LN35@ZSTD_compr:

; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	rdx, rdi
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	rdx, QWORD PTR tv11311[rbp-256]
	mov	r14d, DWORD PTR [r13]
	mov	rcx, rdx
	add	r14d, eax
	lea	rax, QWORD PTR [r13+28]
	lea	ebx, DWORD PTR [rdx+1]
	npad	4
$LL11@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rax], 1073741824		; 40000000H
	lea	rax, QWORD PTR [rax+28]
	sub	rcx, 1
	jne	SHORT $LL11@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	esi, esi
	je	$LN13@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	eax, esi
	mov	r13, r15
	mov	QWORD PTR tv11332[rsp], rax
	mov	QWORD PTR tv11194[rsp], r15
	npad	9
$LL14@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [r13+4]
	mov	esi, DWORD PTR [r13]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	ebx, r15d
	ja	$LN12@ZSTD_compr
	mov	r13, QWORD PTR opt$1$[rbp-256]
	lea	r12d, DWORD PTR [rsi+1]
	xor	r10d, r10d
	npad	4
$LL17@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	r8d, r10d
	mov	DWORD PTR r$14[rbp-256], r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	DWORD PTR r$12[rbp-256], r10d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rdi+80], 1
	jne	SHORT $LN856@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	lea	eax, DWORD PTR [rbx-2]
	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	edx, DWORD PTR [r8+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	edx, eax
	shl	edx, 8
	add	edx, r14d
	jmp	$LN855@ZSTD_compr
$LN856@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rdi+24]
	mov	edx, r8d
	mov	edi, DWORD PTR [rdi+76]
	mov	eax, DWORD PTR [rax+r8*4]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	edx, eax
	shl	edx, 8
	add	edi, edx

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r8d, 20
	jb	SHORT $LN857@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r8d, 9
	add	edi, -9728				; ffffda00H
	add	edi, r8d
$LN857@ZSTD_compr:

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rbx-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r8, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	mov	eax, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$11[rbp-256], r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r8+16]
	mov	eax, DWORD PTR [rdx+rax]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 283  :     return price;

	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdx+rcx]
	lea	edx, DWORD PTR [r14+51]
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, DWORD PTR [r8+72]
	add	ecx, edi
	mov	rdi, r8
	add	edx, ecx
$LN855@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	eax, ebx
	imul	rcx, rax, 28

; 882  :                         opt[pos].off = offset;
; 883  :                         opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+r13+8], ebx
	inc	ebx
	mov	DWORD PTR [rcx+r13+4], esi
	mov	DWORD PTR [rcx+r13+12], eax

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+r13], edx
	cmp	ebx, r15d
	jbe	$LL17@ZSTD_compr
	mov	r13, QWORD PTR tv11194[rsp]
	mov	rax, QWORD PTR tv11332[rsp]
$LN12@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	r13, 8
	sub	rax, 1
	mov	QWORD PTR tv11194[rsp], r13
	mov	QWORD PTR tv11332[rsp], rax
	jne	$LL14@ZSTD_compr
	mov	r13, QWORD PTR opt$1$[rbp-256]
$LN13@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;

	dec	ebx

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	ecx, 1
	mov	DWORD PTR seqPos$1$[rbp-256], ebx
	mov	DWORD PTR cur$1$[rsp], ecx
	cmp	ebx, ecx
	jb	$LN1889@ZSTD_compr
	npad	14
$LL20@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;
; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r15d, DWORD PTR [rcx-1]
	mov	esi, ecx
	add	rsi, QWORD PTR ip$1$[rsp]
	imul	rdi, r15, 28
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+r13+8], 0
	jne	SHORT $LN57@ZSTD_compr
	mov	r14d, DWORD PTR [rdi+r13+12]
	inc	r14d
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	r14d, 1
$LN58@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	mov	r12, QWORD PTR optStatePtr$1$[rbp-256]
	lea	ecx, DWORD PTR [r14-1]
	mov	rdx, r12
	xor	r8d, r8d
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi+r13]
	lea	rcx, QWORD PTR [rsi-1]
	xor	r9d, r9d
	mov	r8, r12
	sub	edi, eax
	lea	edx, QWORD PTR [r9+1]
	call	ZSTD_rawLiteralsCost
	xor	r8d, r8d
	mov	rdx, r12
	mov	ecx, r14d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	mov	edx, DWORD PTR cur$1$[rsp]
	add	eax, edi
	imul	rdi, rdx, 28
	xor	r8d, r8d
	add	rdi, r13
	cmp	eax, DWORD PTR [rdi]
	jg	SHORT $LN1872@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [rdi+4], r8

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [rdi+12], r14d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [rdi], eax
$LN1872@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [rdi+8]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [rdi+12], 0
	mov	eax, edx
	mov	r9d, r8d
	mov	r8d, DWORD PTR [rdi+4]
	sete	r9b
	sub	eax, ecx
	imul	rdx, rax, 28
	lea	rcx, QWORD PTR $T7[rbp-256]
	add	rdx, 16
	add	rdx, r13
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));
; 929  :             } else {

	mov	edx, DWORD PTR cur$1$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rdi+16], xmm0
	mov	DWORD PTR [rdi+24], ecx
	jmp	SHORT $LN39@ZSTD_compr
$LN38@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r15, 28
	movsd	xmm0, QWORD PTR [rax+r13+16]
	mov	eax, DWORD PTR [rax+r13+24]
	movsd	QWORD PTR [rdi+16], xmm0
	mov	DWORD PTR [rdi+24], eax
$LN39@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	edx, ebx
	je	$LN1889@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {

	mov	r14d, DWORD PTR [rdi]
	lea	ecx, DWORD PTR [rdx+1]
	imul	rdx, rcx, 28
	lea	eax, DWORD PTR [r14+128]
	cmp	DWORD PTR [rdx+r13], eax
	jle	$LN18@ZSTD_compr

; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [rdi+8]
	xor	edx, edx
	test	eax, eax
	mov	ecx, edx
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_compr
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN60@ZSTD_compr
$LN59@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], edx
$LN60@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;
; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	rdx, r12
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	add	eax, r14d

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	rdi, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	rax, QWORD PTR ms$[rbp-256]

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	mov	QWORD PTR rep$1$[rsp], rdi

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [rax+36]
	mov	r12, QWORD PTR [rax+8]
	mov	r15d, DWORD PTR [rax+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN18@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN933@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	rbx, rax
$LL932@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rsi
	mov	rcx, rbx
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL932@ZSTD_compr
	mov	ebx, DWORD PTR seqPos$1$[rbp-256]
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN933@ZSTD_compr:

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	r12, QWORD PTR ms$[rbp-256]

; 756  :     switch(matchLengthSearch)

	mov	ecx, 4095				; 00000fffH
	mov	rdi, QWORD PTR [r12+48]

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], r14d

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r12+192]
	cmp	r15d, 3
	je	$LN926@ZSTD_compr
	cmp	r15d, 5
	je	$LN928@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	mov	r15d, esi
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN927@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$[rbp-256]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11278[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11179[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11311[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11276[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	5
$LL1448@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1515@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1516@ZSTD_compr
$LN1515@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1516@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1455@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN1946@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1946@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN1455@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1964@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1446@ZSTD_compr
$LN1964@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1446@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11276[rbp-256]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL1448@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11278[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1910@ZSTD_compr
	npad	10
$LL1449@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rbp-256], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1910@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+rdi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1963@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1473@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1473@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1910@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1474@ZSTD_compr
$LN1963@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1474@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1476@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11179[rsp]
	jbe	SHORT $LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1477@ZSTD_compr
$LN1476@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11179[rsp]
	jbe	SHORT $LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1477@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rbp-256]
	test	r12d, r12d
	jne	$LL1449@ZSTD_compr
	jmp	SHORT $LN1910@ZSTD_compr
$LN1725@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$1[rsp]
	xor	edx, edx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1987@ZSTD_compr
$LN1726@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$1[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1910@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1987@ZSTD_compr
$LN927@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$[rbp-256]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11271[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11178[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11311[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11269[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	6
$LL1108@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1175@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1176@ZSTD_compr
$LN1175@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1176@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1115@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	sete	cl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	ecx, eax
	je	SHORT $LN1115@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN1115@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1968@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r9*8]
	inc	r9d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1106@ZSTD_compr
$LN1968@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1106@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11269[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r10d
	jb	$LL1108@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11271[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1910@ZSTD_compr
	npad	12
$LL1109@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1910@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1967@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1133@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1133@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1910@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1134@ZSTD_compr
$LN1967@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1134@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1136@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11178[rbp-256]
	jbe	$LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1137@ZSTD_compr
$LN1136@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11178[rbp-256]
	jbe	$LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1137@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1109@ZSTD_compr
	jmp	$LN1910@ZSTD_compr
$LN928@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$[rbp-256]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11264[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11177[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11311[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11262[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL1278@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1345@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1346@ZSTD_compr
$LN1345@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1346@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1285@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN1947@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1947@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN1285@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1966@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1276@ZSTD_compr
$LN1966@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1276@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11262[rbp-256]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL1278@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11264[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1910@ZSTD_compr
	npad	6
$LL1279@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1910@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1965@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1303@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1303@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1910@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1304@ZSTD_compr
$LN1965@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1304@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1306@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11177[rsp]
	jbe	$LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1307@ZSTD_compr
$LN1306@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11177[rsp]
	jbe	$LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1307@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1279@ZSTD_compr
	jmp	$LN1910@ZSTD_compr
$LN926@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$[rbp-256]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11257[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11176[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rbp-256], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11311[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11255[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL938@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1005@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1006@ZSTD_compr
$LN1005@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1006@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1974@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]
	shl	edx, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, r11d
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN1948@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	mov	r9d, DWORD PTR lastR$1$[rbp-256]

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, DWORD PTR windowLow$1$[rsp]

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r8d, DWORD PTR [rax+3]
$LN1974@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	edx, edx
$LN945@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1954@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN936@ZSTD_compr
$LN1948@ZSTD_compr:

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
	jmp	SHORT $LN945@ZSTD_compr
$LN1954@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
$LN936@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r15d
	add	rdi, 4
	cmp	r15d, r9d
	jae	SHORT $LN1887@ZSTD_compr
	mov	edx, DWORD PTR tv11255[rbp-256]
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$1$[rsp]
	jmp	$LL938@ZSTD_compr
$LN1887@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN1949@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$5[rbp-256]
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	ecx, ecx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, ecx
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1953@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rbp-256]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1950@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rdi+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;

	mov	r10d, 1
	mov	r13, rax
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	DWORD PTR [rdx], ecx

; 632  :                 if ( (mlen > sufficient_len) |

	lea	rcx, QWORD PTR [rax+rsi]
	mov	DWORD PTR [rdx+4], eax
	xor	edx, edx
	cmp	rcx, r9
	mov	r8d, edx
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1951@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	jmp	$LN1988@ZSTD_compr
$LN1949@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1989@ZSTD_compr
$LN1950@ZSTD_compr:

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	jmp	SHORT $LN956@ZSTD_compr
$LN1951@ZSTD_compr:

; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN956@ZSTD_compr
$LN1953@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	edx, edx
$LN1989@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN956@ZSTD_compr:
	mov	rax, QWORD PTR tv11257[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1940@ZSTD_compr
$LL939@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, r8d
	jb	$LN1940@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1952@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN963@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN963@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r10*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r10d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1940@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN964@ZSTD_compr
$LN1952@ZSTD_compr:
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	edx, edx
	mov	r9, QWORD PTR iend$1$[rsp]
$LN964@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN966@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11176[rsp]
	jbe	SHORT $LN1737@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN967@ZSTD_compr
$LN966@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11176[rsp]
	jbe	SHORT $LN1738@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN967@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	je	SHORT $LN1940@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL939@ZSTD_compr
$LN1737@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	jmp	SHORT $LN1762@ZSTD_compr
$LN1738@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1940@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1762@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
$LN1987@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	add	eax, -8					; fffffff8H
$LN1988@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [rcx+36], eax
$LN935@ZSTD_compr:
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	test	r8d, r8d
	je	$LN1944@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	mov	r9d, DWORD PTR cur$1$[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR [r15+rax*8+4]
	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1740@ZSTD_compr
	lea	eax, DWORD PTR [rcx+r9]
	cmp	eax, 4096				; 00001000H
	jae	$LN1740@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	esi, esi
	mov	eax, esi
	mov	DWORD PTR matchNb$1$[rsp], eax
	test	r8d, r8d
	je	$LN1944@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rcx, r15
	mov	QWORD PTR tv11185[rsp], rcx
	npad	8
$LL23@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	r10d, DWORD PTR [rcx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rcx+4]
	mov	DWORD PTR offset$1$[rsp], r10d

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	eax, eax
	je	SHORT $LN63@ZSTD_compr
	mov	rcx, QWORD PTR tv11185[rsp]
	dec	eax
	mov	r12d, DWORD PTR [r15+rax*8+4]
	mov	eax, DWORD PTR matchNb$1$[rsp]
	inc	r12d
	jmp	SHORT $LN64@ZSTD_compr
$LN63@ZSTD_compr:
	mov	r12d, DWORD PTR minMatch$1$[rbp-256]
$LN64@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	mov	r13, QWORD PTR opt$1$[rbp-256]
	cmp	edx, r12d
	jb	$LN21@ZSTD_compr
	mov	r11, QWORD PTR optStatePtr$1$[rbp-256]
	lea	eax, DWORD PTR [r10+1]
	mov	r15d, r9d
	lea	edi, DWORD PTR [rdx+r9]
	neg	r15d
	npad	9
$LL26@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	r8d, esi
	mov	DWORD PTR r$4[rbp-256], esi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r14d, DWORD PTR [r15+rdi]

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	DWORD PTR r$3[rbp-256], esi
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [r11+80], 1
	jne	SHORT $LN1618@ZSTD_compr

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	lea	eax, DWORD PTR [r14-2]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, esi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r8+16]
	add	ecx, eax
	shl	ecx, 8
	jmp	$LN1617@ZSTD_compr
$LN1618@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [r11+24]
	mov	eax, DWORD PTR [rax+r8*4]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, esi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	esi, r8d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	esi, eax
	shl	esi, 8
	add	esi, DWORD PTR [r11+76]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r8d, 20
	jb	SHORT $LN1619@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r8d, 9
	add	esi, -9728				; ffffda00H
	add	esi, r8d
$LN1619@ZSTD_compr:

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r14-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r11, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
	mov	r10d, DWORD PTR offset$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	mov	eax, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$2[rbp-256], r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r11+16]
	mov	eax, DWORD PTR [rdx+rax]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdx+rcx]
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, 51					; 00000033H
	add	ecx, DWORD PTR [r11+72]
	add	ecx, esi
	xor	esi, esi
$LN1617@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]
	add	edx, ecx

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	cmp	edi, ebx
	ja	SHORT $LL27@ZSTD_compr
	mov	eax, edi
	imul	rcx, rax, 28
	cmp	edx, DWORD PTR [rcx+r13]
	jge	SHORT $LN1906@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN28@ZSTD_compr
	npad	4
$LL27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+r13], 1073741824		; 40000000H
	cmp	ebx, edi
	jb	SHORT $LL27@ZSTD_compr
	mov	DWORD PTR seqPos$1$[rbp-256], ebx
$LN28@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, edi
	dec	edi
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;
; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+r13+12], eax
	lea	eax, DWORD PTR [r15+rdi]
	cmp	eax, r12d
	mov	DWORD PTR [rcx+r13+8], r14d
	lea	eax, DWORD PTR [r10+1]
	mov	DWORD PTR [rcx+r13+4], r10d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+r13], edx
	jae	$LL26@ZSTD_compr
$LN1906@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	mov	eax, DWORD PTR matchNb$1$[rsp]
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	rcx, QWORD PTR tv11185[rsp]
	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rsp]
$LN21@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	inc	eax
	add	rcx, 8
	mov	DWORD PTR matchNb$1$[rsp], eax
	mov	QWORD PTR tv11185[rsp], rcx
	cmp	eax, r8d
	jb	$LL23@ZSTD_compr
	jmp	SHORT $LN18@ZSTD_compr
$LN1944@ZSTD_compr:

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r13, QWORD PTR opt$1$[rbp-256]
$LN18@ZSTD_compr:
	mov	ecx, DWORD PTR cur$1$[rsp]
	inc	ecx
	mov	DWORD PTR cur$1$[rsp], ecx
	cmp	ecx, ebx
	jbe	$LL20@ZSTD_compr
$LN1889@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	r14, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+r13]
	mov	esi, DWORD PTR [rdx+r13+24]
	movsd	xmm0, QWORD PTR [rdx+r13+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$6[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], esi

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	SHORT $LN65@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r12d, r12d
	jmp	SHORT $_shortestPath$1992
$LN1740@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r15+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r12d, r12d
	mov	r13, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$6[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$6[rbp-244], eax
	mov	eax, r9d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$6[rbp-248], ecx
	cmp	DWORD PTR [rax+r13+8], r12d
	jne	SHORT $LN61@ZSTD_compr
	mov	eax, DWORD PTR [rax+r13+12]
	jmp	SHORT $LN62@ZSTD_compr
$LN61@ZSTD_compr:
	mov	eax, r12d
$LN62@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$6[rbp-256]
	mov	r14, QWORD PTR rep$[rbp-256]
	sub	r9d, eax
	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r9d, 4096				; 00001000H
	mov	ebx, r12d
	cmovbe	ebx, r9d
	jmp	SHORT $_shortestPath$1992
$LN65@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	xor	r12d, r12d
$LN1986@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	mov	ebx, r12d
$_shortestPath$1992:
	mov	eax, ebx
	lea	rdx, QWORD PTR [r13+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$6[rbp-248], 0
	je	SHORT $LN51@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T8[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r12d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14], xmm0
	mov	DWORD PTR [r14+8], ecx

; 1014 :         } else {

	jmp	SHORT $LN52@ZSTD_compr
$LN51@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r14+8], eax
$LN52@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	mov	r9, QWORD PTR opt$1$[rbp-256]
	lea	r13d, DWORD PTR [rbx+1]
	movups	xmm0, XMMWORD PTR lastSequence$6[rbp-256]
	mov	eax, r13d
	mov	edi, r13d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r9+16], xmm0
	mov	DWORD PTR [rcx+r9+24], esi

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_compr
	npad	4
$LL29@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r9
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r9+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r9+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r12d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_compr
$LN30@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r13d
	ja	$LN1972@ZSTD_compr
	mov	r11, QWORD PTR src$[rbp-256]
	npad	1
$LL33@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	mov	r12, r11
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r9+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r9+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r9+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	je	$LN31@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
; 1051 :                         continue;   /* will finish */
; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	r9d, r14d
	mov	r8, r11
	mov	DWORD PTR [rsp+32], esi
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+r11]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1654@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r11]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1655@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r11+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
$LL1668@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1668@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1655@ZSTD_compr
$LN1654@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r11
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
	mov	r11, QWORD PTR src$[rbp-256]
$LN1655@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1821@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN1821@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1874@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN1874@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	r9, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	ebx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	add	r11, rbx
	mov	QWORD PTR src$[rbp-256], r11
$LN31@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	add	r12, rbx
	inc	edi
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	edi, r13d
	jbe	$LL33@ZSTD_compr

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	xor	edx, edx
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1972@ZSTD_compr:
	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	xor	edx, edx
	mov	r12, QWORD PTR ip$1$[rsp]
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1971@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r12, QWORD PTR ip$1$[rsp]
$LN1857@ZSTD_compr:
	inc	r12
	mov	QWORD PTR ip$1$[rsp], r12
$LN1769@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r14d, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	r13, QWORD PTR ms$[rbp-256]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r12, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL4@ZSTD_compr
$LN5@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rdi

; 1073 :     DEBUGLOG(5, "ZSTD_compressBlock_btopt");
; 1074 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0 /*optLevel*/, ZSTD_noDict);

	mov	rax, r15

; 1075 : }

	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btopt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
current$1$ = 48
current$1$ = 48
btMask$1$ = 48
matchLow$1$ = 48
lastR$1$ = 48
lastR$1$ = 48
lastR$1$ = 48
matchEndIdx$1$ = 48
nbCompares$1$ = 52
matchEndIdx$1$ = 52
current$1$ = 52
current$1$ = 52
btMask$1$ = 52
btMask$1$ = 52
btMask$1$ = 52
matchLow$1$ = 52
dictLimit$1$ = 56
nbCompares$1$ = 56
matchEndIdx$1$ = 56
dictLimit$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
nbCompares$1$ = 56
iend$1$ = 64
current$1$ = 72
current$1$ = 72
current$1$ = 72
current$1$ = 72
cur$1$ = 72
matchEndIdx$1$ = 76
sufficient_len$1$ = 76
matchNb$1$ = 76
tv11858 = 76
tv11848 = 76
tv11838 = 76
tv11706 = 76
tv11705 = 76
tv11704 = 76
matchEndIdx$1$ = 80
dictLimit$1$ = 80
nbCompares$1$ = 80
nbCompares$1$ = 80
matchLow$1$ = 80
matchLow$1$ = 80
matchLow$1$ = 80
tv11707 = 80
ip$1$ = 88
smallerPtr$1$ = 96
smallerPtr$1$ = 96
smallerPtr$1$ = 96
smallerPtr$1$ = 96
commonLengthSmaller$1$ = 96
commonLengthSmaller$1$ = 96
commonLengthSmaller$1$ = 96
largerPtr$1$ = 96
bestLength$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
bestLength$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
dictBase$1$ = 104
rep$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
sufficient_len$1$ = 120
matchLow$1$ = 120
dictLimit$1$ = 120
dictLimit$1$ = 120
dictLimit$1$ = 120
offset$1$ = 120
tv11828 = 120
tv11802 = 120
tv11703 = 120
btMask$1$ = 124
matchLow$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
btMask$1$ = 124
tv11812 = 124
lastR$1$ = 128
litlen$1$ = 128
tv11710 = 128
tv11709 = 128
tv11708 = 128
btMask$1$ = 132
sufficient_len$1$ = 132
dictLimit$1$ = 132
tv11782 = 132
tv11772 = 132
dummy32$1 = 132
dummy32$2 = 132
dummy32$3 = 132
largerPtr$1$ = 136
bestLength$1$ = 136
bestLength$1$ = 136
dictBase$1$ = 136
base$1$ = 136
base$1$ = 136
base$1$ = 136
commonLengthLarger$1$ = 136
prefixStart$1$ = 144
commonLengthSmaller$1$ = 144
prefixStart$1$ = 144
prefixStart$1$ = 144
prefixStart$1$ = 144
prefixStart$1$ = 144
commonLengthSmaller$1$ = 144
tv11874 = 144
tv11804 = 144
dictBase$1$ = 152
base$1$ = 152
dictEnd$1$ = 152
base$1$ = 152
dictBase$1$ = 152
dictBase$1$ = 152
dictBase$1$ = 152
tv11830 = 152
tv11721 = 152
dictEnd$1$ = 160
commonLengthLarger$1$ = 160
base$1$ = 160
largerPtr$1$ = 160
dictEnd$1$ = 160
dictEnd$1$ = 160
dictEnd$1$ = 160
prefixStart$1$ = 160
bt$1$ = 168
commonLengthSmaller$1$ = 168
base$1$ = 168
tv11861 = 168
tv11850 = 168
tv11840 = 168
tv11814 = 168
tv11784 = 168
ll0$1$ = 176
litlen$1$ = 176
matches$1$ = 184
dictBase$1$ = 192
commonLengthLarger$1$ = 192
commonLengthSmaller$1$ = 192
tv11864 = 192
tv11851 = 192
tv11841 = 192
tv11831 = 192
tv11815 = 192
tv11712 = 192
commonLengthLarger$1$ = 200
prefixStart$1$ = 200
bt$1$ = 200
commonLengthLarger$1$ = 200
bt$1$ = 200
bt$1$ = 200
bt$1$ = 200
bt$1$ = 200
matchLow$1$ = 208
sufficient_len$1$ = 208
btMask$1$ = 208
tv11792 = 208
r$4 = 208
optStatePtr$1$ = 216
opt$1$ = 224
minMatch$1$ = 232
commonLengthSmaller$1$ = 240
dictEnd$1$ = 240
dictBase$1$ = 240
bt$1$ = 240
commonLengthLarger$1$ = 248
commonLengthLarger$1$ = 248
commonLengthLarger$1$ = 248
basePrice$1$ = 248
tv11859 = 256
base$1$ = 264
prefixStart$1$ = 264
tv11794 = 264
lastSequence$5$ = 272
bt$1$ = 280
tv11805 = 280
tv11795 = 280
tv11785 = 280
sufficient_len$1$ = 288
nextToUpdate3$5 = 292
lastSequence$6 = 296
lastSequence$4$ = 328
ilimit$1$ = 336
$T7 = 384
$T8 = 400
ms$ = 496
seqStore$ = 504
rep$ = 512
src$ = 520
nbCompares$1$ = 528
nbCompares$1$ = 528
nbCompares$1$ = 528
nbMatches$1$ = 528
inr$1$ = 528
ll0$1$ = 528
dummy32$9 = 528
dummy32$10 = 528
dummy32$11 = 528
r$12 = 528
srcSize$ = 528
ZSTD_compressBlock_btultra_extDict PROC

; 1194 : {

$LN2010:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-168]
	sub	rsp, 424				; 000001a8H

; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]

; 1194 : {

	mov	r13, rcx

; 803  :     optState_t* const optStatePtr = &ms->opt;

	add	rcx, 72					; 00000048H

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH

; 1194 : {

	mov	rdi, r9

; 803  :     optState_t* const optStatePtr = &ms->opt;

	mov	QWORD PTR optStatePtr$1$[rbp-256], rcx

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]
	lea	r15, QWORD PTR [r9+r8]
	mov	ebx, DWORD PTR [r13+24]
	lea	rsi, QWORD PTR [r15-8]
	add	rbx, QWORD PTR [r13+8]
	cmp	eax, edx
	mov	QWORD PTR iend$1$[rsp], r15
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	cmovb	edx, eax

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	r14d, r14d
	cmp	DWORD PTR [r13+200], 3
	mov	eax, r14d
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	rdx, rdi
	setne	al
	add	eax, 3
	lea	r9d, QWORD PTR [r14+2]
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR nextToUpdate3$5[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r14d
	sete	al
	lea	r12, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	r12, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$6[rbp-240]
	mov	eax, DWORD PTR lastSequence$6[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	10
$LL4@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r12d

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r13+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, edi
	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r14d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r13+8]

; 834  :             U32 const ll0 = !litlen;

	sete	al
	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r12, rax
	jb	$LN1850@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r12d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN129@ZSTD_compr
	npad	6
$LL128@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], 1
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL128@ZSTD_compr
$LN129@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	r14, QWORD PTR [r13+8]
	mov	ecx, 4095				; 00000fffH
	mov	rbx, QWORD PTR [r13+48]

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN122@ZSTD_compr
	mov	QWORD PTR base$1$[rbp-256], r14
	mov	r15d, r12d
	cmp	esi, 5
	je	$LN124@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN123@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	sub	r15d, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11864[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	eax, esi
	mov	rcx, QWORD PTR [r13+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rsi
	mov	QWORD PTR tv11861[rbp-256], rax
	add	rax, r14
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	DWORD PTR tv11710[rbp-256], ecx
	mov	rcx, r13
	mov	DWORD PTR dictLimit$1$[rsp], esi
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	cmovne	eax, r14d
	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	r12d, r8d
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	r15d, 1

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, esi
	mov	QWORD PTR tv11859[rbp-256], rax
	mov	r13d, eax
	mov	DWORD PTR tv11858[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN644@ZSTD_compr
	npad	4
$LL1982@ZSTD_compr:
	xor	r8d, r8d
$LN644@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN711@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN712@ZSTD_compr
$LN711@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN712@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r9d, eax
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN649@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	SHORT $LN1985@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN1993@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN1985@ZSTD_compr:
	xor	r9d, r9d
$LN652@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, r13
	jbe	$LN1957@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, r12d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r11]
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	cmp	rax, r11
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN642@ZSTD_compr
$LN649@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	ecx, DWORD PTR dictLimit$1$[rsp]
	sub	eax, r14d
	xor	edx, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1918@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1918@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN1993@ZSTD_compr
$LN1918@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN652@ZSTD_compr
$LN1957@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN642@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11858[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL1982@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11864[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1909@ZSTD_compr
	npad	3
$LL645@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1909@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11861[rbp-256]
	jb	SHORT $LN663@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	rsi, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN667@ZSTD_compr
$LN663@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	r14, rsi
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11861[rbp-256]
	jb	SHORT $LN1975@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN1975@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	rsi, QWORD PTR ip$1$[rsp]
$LN667@ZSTD_compr:
	cmp	rbx, r13
	jbe	SHORT $LN1956@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN669@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN669@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	r13, rbx
	mov	eax, r12d
	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, r11
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1909@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN670@ZSTD_compr
$LN1956@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN670@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rsi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN672@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11710[rbp-256]
	jbe	SHORT $LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN673@ZSTD_compr
$LN672@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11710[rbp-256]
	jbe	SHORT $LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN673@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL645@ZSTD_compr
	jmp	SHORT $LN1909@ZSTD_compr
$LN1709@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$10[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1994@ZSTD_compr
$LN1710@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$10[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1909@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1994@ZSTD_compr
$LN123@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	sub	r15d, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11851[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	eax, esi
	mov	rcx, QWORD PTR [r13+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rsi
	mov	QWORD PTR tv11850[rbp-256], rax
	add	rax, r14
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	DWORD PTR tv11709[rbp-256], ecx
	mov	rcx, r13
	mov	DWORD PTR dictLimit$1$[rsp], esi
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	cmovne	eax, r14d
	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	r12d, r8d
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	r15d, 1

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, esi
	mov	QWORD PTR tv11859[rbp-256], rax
	mov	r13d, eax
	mov	DWORD PTR tv11848[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN304@ZSTD_compr
$LL1983@ZSTD_compr:
	xor	r8d, r8d
$LN304@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN371@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN372@ZSTD_compr
$LN371@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN372@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r9d, eax
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN309@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	SHORT $LN1986@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN1995@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN1986@ZSTD_compr:
	xor	r9d, r9d
$LN312@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, r13
	jbe	$LN1959@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, r12d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r11]
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	cmp	rax, r11
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN302@ZSTD_compr
$LN309@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	ecx, DWORD PTR dictLimit$1$[rsp]
	sub	eax, r14d
	xor	edx, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1920@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1920@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN1995@ZSTD_compr
$LN1920@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN312@ZSTD_compr
$LN1959@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN302@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11848[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL1983@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11851[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1909@ZSTD_compr
	npad	11
$LL305@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1909@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, QWORD PTR tv11850[rbp-256]
	jb	SHORT $LN323@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	rsi, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN327@ZSTD_compr
$LN323@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	r14, rsi
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, QWORD PTR tv11850[rbp-256]
	jb	SHORT $LN1976@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN1976@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	rsi, QWORD PTR ip$1$[rsp]
$LN327@ZSTD_compr:
	cmp	rbx, r13
	jbe	SHORT $LN1958@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN329@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN329@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	r13, rbx
	mov	eax, r12d
	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, r11
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1909@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN330@ZSTD_compr
$LN1958@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN330@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rsi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN332@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11709[rbp-256]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN333@ZSTD_compr
$LN332@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11709[rbp-256]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN333@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL305@ZSTD_compr
	jmp	$LN1909@ZSTD_compr
$LN124@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmp	eax, ecx
	cmovb	ecx, eax
	sub	r15d, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11841[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	eax, esi
	mov	rcx, QWORD PTR [r13+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rsi
	mov	QWORD PTR tv11840[rbp-256], rax
	add	rax, r14
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	DWORD PTR tv11708[rbp-256], ecx
	mov	rcx, r13
	mov	DWORD PTR dictLimit$1$[rsp], esi
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	cmovne	eax, r14d
	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	r12d, r8d
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	r15d, 1

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, esi
	mov	QWORD PTR tv11859[rbp-256], rax
	mov	r13d, eax
	mov	DWORD PTR tv11838[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN474@ZSTD_compr
	npad	6
$LL1984@ZSTD_compr:
	xor	r8d, r8d
$LN474@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN541@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN542@ZSTD_compr
$LN541@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN542@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r9d, eax
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN479@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	SHORT $LN1987@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN1996@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN1987@ZSTD_compr:
	xor	r9d, r9d
$LN482@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, r13
	jbe	$LN1961@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, r12d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r11]
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	cmp	rax, r11
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN472@ZSTD_compr
$LN479@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	ecx, DWORD PTR dictLimit$1$[rsp]
	sub	eax, r14d
	xor	edx, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1922@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1922@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN1996@ZSTD_compr
$LN1922@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN482@ZSTD_compr
$LN1961@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN472@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11838[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL1984@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11841[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1909@ZSTD_compr
	npad	3
$LL475@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1909@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11840[rbp-256]
	jb	SHORT $LN493@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	rsi, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN497@ZSTD_compr
$LN493@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	r14, rsi
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11840[rbp-256]
	jb	SHORT $LN1977@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN1977@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	rsi, QWORD PTR ip$1$[rsp]
$LN497@ZSTD_compr:
	cmp	rbx, r13
	jbe	SHORT $LN1960@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN499@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN499@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	r13, rbx
	mov	eax, r12d
	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, r11
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1909@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN500@ZSTD_compr
$LN1960@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN500@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rsi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN502@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11708[rbp-256]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN503@ZSTD_compr
$LN502@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11708[rbp-256]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN503@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL475@ZSTD_compr
	jmp	$LN1909@ZSTD_compr
$LN122@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx
	mov	QWORD PTR base$1$[rbp-256], r14

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	sub	esi, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r15d, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11831[rbp-256], rax
	mov	ebx, 1
	mov	rax, QWORD PTR [r13+16]
	shl	ebx, cl
	mov	ecx, edx
	mov	QWORD PTR dictBase$1$[rsp], rax
	dec	ebx
	lea	rax, QWORD PTR [r15+r14]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, esi
	sub	eax, ebx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, esi
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	edx, esi
	mov	DWORD PTR btMask$1$[rsp], ebx
	cmovb	ecx, eax
	mov	QWORD PTR tv11830[rbp-256], r15
	mov	DWORD PTR tv11707[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	mov	r10d, esi
	mov	edx, esi
	cmovne	eax, r14d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	mov	r12d, r8d
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	dec	eax
	mov	QWORD PTR tv11859[rbp-256], rax
	mov	r13d, eax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]
	sub	r10d, r15d

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv11828[rsp], r10d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	rsi, QWORD PTR [rcx+rax*4]
$LL134@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN201@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN202@ZSTD_compr
$LN201@ZSTD_compr:
	mov	eax, DWORD PTR [rsi]
$LN202@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, r10d
	jae	SHORT $LN139@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rcx, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r10d, eax
	neg	r10

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rcx]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10+rcx]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	$LN1979@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r10
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2008@ZSTD_compr
$LN139@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rsp]
	sub	eax, r14d
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, r15d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1979@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r9, QWORD PTR ip$1$[rsp]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	mov	ecx, DWORD PTR [r9]
	shl	ecx, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN142@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dictBase$1$[rsp]
	lea	rdx, QWORD PTR [r10+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	add	r9, r15
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2008@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
$LN1979@ZSTD_compr:
	mov	r9, QWORD PTR ip$1$[rsp]
$LN142@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN132@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, r12d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r9]
	xor	edx, edx
	cmp	rax, r10
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN132@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	ebx
	add	rsi, 4
	cmp	ebx, r11d
	jae	SHORT $LN1882@ZSTD_compr
	mov	edx, DWORD PTR current$1$[rsp]
	xor	r8d, r8d
	mov	r10d, DWORD PTR tv11828[rsp]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL134@ZSTD_compr
$LN1882@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN1924@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r14, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$5[rbp-256]
	mov	rcx, r14
	mov	r8, r9
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r9d
	mov	ecx, r9d
	mov	ebx, esi
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1963@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	mov	ecx, eax
	cmp	eax, r15d
	jb	SHORT $LN148@ZSTD_compr

; 615  :                 const BYTE* const match = base + matchIndex3;

	mov	rdx, QWORD PTR base$1$[rbp-256]

; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	add	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	call	ZSTD_count

; 617  :             } else {

	jmp	SHORT $LN1997@ZSTD_compr
$LN148@ZSTD_compr:

; 618  :                 const BYTE* const match = dictBase + matchIndex3;

	mov	r8, QWORD PTR dictBase$1$[rsp]

; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rcx+r8]
	mov	rcx, QWORD PTR ip$1$[rsp]
	lea	r9, QWORD PTR [r8+r15]
	mov	r8, QWORD PTR iend$1$[rsp]
	call	ZSTD_count_2segments
$LN1997@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r11, QWORD PTR ip$1$[rsp]
	xor	r9d, r9d
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r8, rax
	cmp	rax, 3
	jb	SHORT $LN1929@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;

	lea	r12d, QWORD PTR [r9+1]
	mov	r13, rax

; 632  :                 if ( (mlen > sufficient_len) |

	mov	edx, r9d
	lea	eax, DWORD PTR [rbx+2]
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [r13+r11]
	mov	DWORD PTR [rcx+4], r8d
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, DWORD PTR sufficient_len$1$[rsp]
	sete	dl
	cmp	r13, rax
	seta	cl
	or	edx, ecx
	je	SHORT $LN1929@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [rsi+1]
	mov	DWORD PTR [r14+36], eax

; 635  :                     return 1;

	jmp	$LN131@ZSTD_compr
$LN1924@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1998@ZSTD_compr
$LN1929@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN152@ZSTD_compr
$LN1963@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR iend$1$[rsp]
$LN1998@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r11, QWORD PTR ip$1$[rsp]
$LN152@ZSTD_compr:
	mov	rax, QWORD PTR tv11831[rbp-256]
	mov	DWORD PTR [rax], esi

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1928@ZSTD_compr
	npad	2
$LL135@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	edi, r8d
	jb	$LN1927@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r9, QWORD PTR tv11830[rbp-256]
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [rsi+rbx]
	lea	rcx, QWORD PTR [rbx+r11]
	cmp	rax, r9
	jb	SHORT $LN153@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	add	r14, rsi
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN157@ZSTD_compr
$LN153@ZSTD_compr:

; 654  :             match = dictBase + matchIndex;

	mov	r8, QWORD PTR dictBase$1$[rsp]

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	r9, r8
	mov	QWORD PTR [rsp+32], rax
	lea	r14, QWORD PTR [rsi+r8]
	mov	r8, r10
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11830[rbp-256]
	jb	SHORT $LN157@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN157@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN1962@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN159@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN159@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$1$[rsp]
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, r12d
	inc	r12d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r9]
	cmp	rax, r10
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1927@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN160@ZSTD_compr
$LN1962@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r9, QWORD PTR ip$1$[rsp]
$LN160@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN162@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11707[rsp]
	jbe	SHORT $LN1721@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN163@ZSTD_compr
$LN162@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11707[rsp]
	jbe	SHORT $LN1722@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN163@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	SHORT $LN1927@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
	jmp	$LL135@ZSTD_compr
$LN1721@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$11[rbp-256]
	xor	r9d, r9d
	jmp	SHORT $LN1749@ZSTD_compr
$LN1722@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$11[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1927@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN1928@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1749@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
$LN1994@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR ms$[rbp-256]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN131@ZSTD_compr:
	test	r12d, r12d
	je	$LN1980@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */
; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rsi, QWORD PTR rep$[rbp-256]
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	ecx, ebx
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rdx, r14
	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [rdi+16], eax
	mov	eax, DWORD PTR [rsi+4]
	mov	DWORD PTR [rdi+20], eax
	mov	eax, DWORD PTR [rsi+8]
	mov	DWORD PTR [rdi+24], eax
	mov	DWORD PTR [rdi+8], 0
	mov	DWORD PTR [rdi+12], ebx
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [rdi], eax
	lea	eax, DWORD PTR [r12-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r15+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	SHORT $LN35@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;
; 858  :                     lastSequence.off = maxOffset;
; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	r14d, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$6[rbp-248], eax
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR lastSequence$6[rbp-252], eax
	mov	DWORD PTR lastSequence$6[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$6[rbp-256]
$LN1999@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	xor	r15d, r15d
	mov	ebx, r15d
$_shortestPath$2011:
	mov	eax, ebx
	lea	rdx, QWORD PTR [rdi+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$6[rbp-248], 0
	je	$LN51@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T8[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r15d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rsi], xmm0
	mov	DWORD PTR [rsi+8], ecx

; 1014 :         } else {

	jmp	$LN52@ZSTD_compr
$LN35@ZSTD_compr:

; 864  :             }   }
; 865  : 
; 866  :             /* set prices for first matches starting position == 0 */
; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rdx, r14
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	rdx, QWORD PTR tv11859[rbp-256]
	lea	rcx, QWORD PTR [rdi+28]
	mov	r13d, eax
	mov	rax, rdx
	add	r13d, DWORD PTR [rdi]
	lea	esi, DWORD PTR [rdx+1]
	npad	8
$LL11@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	lea	rcx, QWORD PTR [rcx+28]
	sub	rax, 1
	jne	SHORT $LL11@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	r12d, r12d
	je	$LN13@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r15
	mov	ecx, r12d
	mov	QWORD PTR tv11721[rbp-256], rax
	mov	QWORD PTR tv11874[rbp-256], rcx
	npad	9
$LL14@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [rax+4]
	mov	r14d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	esi, r15d
	ja	$LN12@ZSTD_compr
	lea	r12d, DWORD PTR [r14+1]
	npad	12
$LL17@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ecx, ecx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	edi, ecx
	mov	DWORD PTR r$12[rbp-256], ecx
	cmovne	edi, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rax, QWORD PTR optStatePtr$1$[rbp-256]
	cmp	DWORD PTR [rax+80], 1
	jne	SHORT $LN856@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_fracWeight
	lea	edx, DWORD PTR [rdi+16]
	shl	edx, 8
	add	edx, eax
	jmp	SHORT $LN855@ZSTD_compr
$LN856@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rax+24]
	mov	ecx, DWORD PTR [rax+rdi*4]
	call	ZSTD_fracWeight
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rsi-3]
	shl	edi, 8
	add	edi, DWORD PTR [rdx+76]
	sub	edi, eax
	call	ZSTD_MLcode
	mov	eax, eax

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rbx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, DWORD PTR [rax+rbx]
	call	ZSTD_fracWeight
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rbx+rcx]
	shl	ecx, 8
	add	ecx, DWORD PTR [rdx+72]
	sub	ecx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	edx, DWORD PTR [rcx+51]
	add	edx, edi
$LN855@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 882  :                         opt[pos].off = offset;
; 883  :                         opt[pos].litlen = litlen;

	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	eax, esi
	imul	rcx, rax, 28
	lea	eax, DWORD PTR [rdx+r13]
	mov	DWORD PTR [rcx+rdi+8], esi
	inc	esi
	mov	DWORD PTR [rcx+rdi+4], r14d
	mov	DWORD PTR [rcx+rdi+12], ebx

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+rdi], eax
	cmp	esi, r15d
	jbe	$LL17@ZSTD_compr
	mov	rax, QWORD PTR tv11721[rbp-256]
	mov	rcx, QWORD PTR tv11874[rbp-256]
$LN12@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	rcx, 1
	mov	QWORD PTR tv11721[rbp-256], rax
	mov	QWORD PTR tv11874[rbp-256], rcx
	jne	$LL14@ZSTD_compr
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
$LN13@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;
; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	eax, 1
	lea	ebx, DWORD PTR [rsi-1]
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	ebx, eax
	jb	$LN1889@ZSTD_compr
	npad	12
$LL20@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r12d, DWORD PTR [rax-1]
	mov	r13d, eax
	imul	rax, r12, 28
	add	rsi, r13
	add	rdi, rax
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN57@ZSTD_compr
	mov	r15d, DWORD PTR [rdi+12]
	inc	r15d
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	r15d, 1
$LN58@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	lea	ecx, DWORD PTR [r15-1]
	mov	r8d, 2
	mov	rdx, r14
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	mov	r9d, 2
	mov	r8, r14
	sub	edi, eax
	lea	edx, QWORD PTR [r9-1]
	call	ZSTD_rawLiteralsCost
	mov	r8d, 2
	mov	rdx, r14
	mov	ecx, r15d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	imul	r14, r13, 28
	add	eax, edi
	xor	r13d, r13d
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	r14, rdi
	cmp	eax, DWORD PTR [r14]
	jg	SHORT $LN1871@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [r14+4], r13

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [r14+12], r15d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [r14], eax
$LN1871@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [r14+8]
	mov	r15d, DWORD PTR cur$1$[rsp]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [r14+12], 0
	lea	rdx, QWORD PTR [rdi+16]
	mov	r8d, DWORD PTR [r14+4]
	mov	eax, r15d
	mov	r9d, r13d
	sete	r9b
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], ecx

; 929  :             } else {

	jmp	SHORT $LN39@ZSTD_compr
$LN38@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r12, 28
	movsd	xmm0, QWORD PTR [rax+rdi+16]
	mov	eax, DWORD PTR [rax+rdi+24]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], eax
$LN39@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r15d, ebx
	je	$LN1889@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {
; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [r14+8]
	mov	ecx, r13d
	test	eax, eax
	setne	cl
	mov	DWORD PTR ll0$1$[rbp-256], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_compr
	mov	r13d, DWORD PTR [r14+12]
$LN59@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;
; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	r8d, 2
	mov	edi, DWORD PTR [r14]
	xor	ecx, ecx
	mov	DWORD PTR litlen$1$[rbp-256], r13d
	call	ZSTD_litLengthPrice

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	r13, QWORD PTR ms$[rbp-256]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	add	eax, edi

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	r14, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax
	mov	QWORD PTR rep$1$[rsp], r14

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [r13+36]
	mov	r12, QWORD PTR [r13+8]
	mov	r15d, DWORD PTR [r13+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN1954@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN933@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	npad	8
$LL932@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 1
	mov	r8, rsi
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL932@ZSTD_compr
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN933@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	r12, QWORD PTR [r13+8]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], r14d

; 756  :     switch(matchLengthSearch)

	cmp	r15d, 3
	je	$LN926@ZSTD_compr
	cmp	r15d, 5
	je	$LN928@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN927@ZSTD_compr

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [r13+192]
	cmp	eax, ecx
	mov	rdi, QWORD PTR [r13+48]
	mov	r15d, esi
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r12
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	sub	r15d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	r8d, 6
	call	ZSTD_hashPtr

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	mov	ecx, DWORD PTR [r9+188]
	mov	edi, 1

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	edi
	mov	QWORD PTR tv11815[rbp-256], rax
	mov	eax, DWORD PTR [r9+24]
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rax
	mov	DWORD PTR dictLimit$1$[rsp], eax
	mov	QWORD PTR tv11814[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	edi, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	edx, r15d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	cmovb	ecx, eax
	mov	DWORD PTR tv11706[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r15d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r11d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv11859[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11812[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1448@ZSTD_compr
$LL1989@ZSTD_compr:
	xor	r8d, r8d
$LN1448@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1515@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1516@ZSTD_compr
$LN1515@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1516@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, edx
	jae	SHORT $LN1453@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r10d, eax
	neg	r10
	cmp	r9d, r12d
	setae	cl
	xor	r9d, r9d
	cmp	edx, DWORD PTR [r10+rsi]
	mov	eax, r9d
	sete	al
	test	ecx, eax
	je	SHORT $LN1456@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2000@ZSTD_compr
$LN1453@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	ecx, eax
	mov	ecx, r11d
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1456@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1456@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2000@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	xor	r9d, r9d
$LN1456@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1446@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r10
	mov	QWORD PTR bestLength$1$[rsp], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1446@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11812[rsp]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rsp]
	add	r15, 4
	cmp	edi, r13d
	jb	$LL1989@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11815[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1934@ZSTD_compr
	npad	7
$LL1449@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1934@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [r15+rdi]
	lea	rcx, QWORD PTR [rsi+rdi]
	cmp	rax, QWORD PTR tv11814[rbp-256]
	jb	SHORT $LN1467@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	SHORT $LN1471@ZSTD_compr
$LN1467@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r12, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r12, r15
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r15+rdi]
	cmp	rax, QWORD PTR tv11814[rbp-256]
	jb	SHORT $LN1471@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN1471@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1967@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1473@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1473@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1934@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1474@ZSTD_compr
$LN1967@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN1474@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN1476@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11706[rsp]
	jbe	SHORT $LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1477@ZSTD_compr
$LN1476@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11706[rsp]
	jbe	SHORT $LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN1477@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	jne	$LL1449@ZSTD_compr
	jmp	SHORT $LN1934@ZSTD_compr
$LN1725@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	lea	rax, QWORD PTR dummy32$1[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2001@ZSTD_compr
$LN1726@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$1[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
$LN1934@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2001@ZSTD_compr
$LN927@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 521  :     const BYTE* const base = ms->window.base;

	mov	QWORD PTR base$1$[rbp-256], r12

; 522  :     U32 const current = (U32)(ip-base);

	mov	r13d, esi

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	r13d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	edx, DWORD PTR [rax+192]
	mov	rdi, QWORD PTR [rax+48]
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	edi
	mov	QWORD PTR tv11805[rbp-256], rax
	mov	rax, QWORD PTR [r9+64]
	mov	QWORD PTR bt$1$[rbp-256], rax
	mov	eax, r15d
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, r15
	mov	QWORD PTR tv11804[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	edx, r13d
	mov	eax, r13d
	mov	DWORD PTR btMask$1$[rsp], edi
	sub	eax, edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmp	edi, r13d
	cmovb	ecx, eax
	mov	DWORD PTR tv11705[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r10d, DWORD PTR current$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r10d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r13d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	mov	rax, QWORD PTR bt$1$[rbp-256]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r15d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv11859[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11802[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1108@ZSTD_compr
	npad	3
$LL1990@ZSTD_compr:
	xor	r8d, r8d
$LN1108@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1175@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1176@ZSTD_compr
$LN1175@ZSTD_compr:
	mov	ecx, DWORD PTR [r15]
$LN1176@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r10d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN1113@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	r11d, r11d
	mov	edx, ecx
	mov	ecx, r11d
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	mov	eax, r11d
	sete	cl
	cmp	r9d, r12d
	setae	al
	test	ecx, eax
	je	SHORT $LN1992@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN2002@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR current$1$[rsp]
$LN1992@ZSTD_compr:
	xor	r9d, r9d
$LN1116@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1106@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r11
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1106@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11802[rsp]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rsp]
	add	r15, 4
	cmp	edi, r13d
	jb	$LL1990@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11805[rbp-256]
	mov	DWORD PTR [rax], r10d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1938@ZSTD_compr
	npad	8
$LL1109@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1938@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [r15+rdi]
	lea	rcx, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR tv11804[rbp-256]
	jb	SHORT $LN1127@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	$LN1131@ZSTD_compr
$LN1113@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1948@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1948@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN2002@ZSTD_compr
$LN1948@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR current$1$[rsp]
	jmp	$LN1116@ZSTD_compr
$LN1127@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r12, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r12, r15
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r15+rdi]
	cmp	rax, QWORD PTR tv11804[rbp-256]
	jb	SHORT $LN1131@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN1131@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1965@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1133@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1133@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r11
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1938@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1134@ZSTD_compr
$LN1965@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN1134@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN1136@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11705[rsp]
	jbe	SHORT $LN1729@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1137@ZSTD_compr
$LN1136@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11705[rsp]
	jbe	SHORT $LN1730@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rsp], r13
$LN1137@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	jne	$LL1109@ZSTD_compr
	jmp	SHORT $LN1938@ZSTD_compr
$LN1729@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$3[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2001@ZSTD_compr
$LN1730@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$3[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1938@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2001@ZSTD_compr
$LN928@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [r13+192]
	cmp	eax, ecx
	mov	rdi, QWORD PTR [r13+48]
	mov	r8d, 5
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r12
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	r15d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	mov	ecx, DWORD PTR [r9+188]
	mov	edi, 1

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	edi
	mov	QWORD PTR tv11795[rbp-256], rax
	mov	eax, DWORD PTR [r9+24]
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rax
	mov	DWORD PTR dictLimit$1$[rsp], eax
	mov	QWORD PTR tv11794[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	edi, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	edx, r15d
	mov	DWORD PTR btMask$1$[rsp], edi
	cmovb	ecx, eax
	mov	DWORD PTR tv11704[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r15d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r11d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv11859[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11792[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1278@ZSTD_compr
$LL1991@ZSTD_compr:
	xor	r8d, r8d
$LN1278@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1345@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1346@ZSTD_compr
$LN1345@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1346@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, edx
	jae	SHORT $LN1283@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r10d, eax
	neg	r10
	cmp	r9d, r12d
	setae	cl
	xor	r9d, r9d
	cmp	edx, DWORD PTR [r10+rsi]
	mov	eax, r9d
	sete	al
	test	ecx, eax
	je	SHORT $LN1286@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2003@ZSTD_compr
$LN1283@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	ecx, eax
	mov	ecx, r11d
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1286@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1286@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2003@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	xor	r9d, r9d
$LN1286@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1276@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r10
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1276@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11792[rbp-256]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rsp]
	add	r15, 4
	cmp	edi, r13d
	jb	$LL1991@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11795[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1942@ZSTD_compr
$LL1279@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1942@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [rdi+r15]
	lea	rcx, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR tv11794[rbp-256]
	jb	SHORT $LN1297@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	SHORT $LN1301@ZSTD_compr
$LN1297@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r12, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r12, r15
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rdi+r15]
	cmp	rax, QWORD PTR tv11794[rbp-256]
	jb	SHORT $LN1301@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN1301@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1969@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1303@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1303@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1942@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1304@ZSTD_compr
$LN1969@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN1304@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN1306@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11704[rsp]
	jbe	SHORT $LN1733@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1307@ZSTD_compr
$LN1306@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11704[rsp]
	jbe	SHORT $LN1734@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rsp], r13
$LN1307@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	jne	$LL1279@ZSTD_compr
	jmp	SHORT $LN1942@ZSTD_compr
$LN1733@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$2[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN2001@ZSTD_compr
$LN1734@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$2[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1942@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN2001@ZSTD_compr
$LN926@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [r13+192]
	cmp	eax, ecx
	mov	rdi, QWORD PTR [r13+48]
	mov	r8d, 3
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r12
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	sub	r15d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r8d, r8d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r8

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	edx, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	dec	ecx
	mov	QWORD PTR tv11785[rbp-256], rax
	mov	rax, QWORD PTR [r9+16]
	shl	edi, cl

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	ecx, r8d
	mov	QWORD PTR dictBase$1$[rbp-256], rax
	dec	edi
	lea	rax, QWORD PTR [r12+rdx]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r8
	mov	r8d, DWORD PTR [r9+184]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, edi
	mov	DWORD PTR dictLimit$1$[rsp], edx
	mov	QWORD PTR tv11784[rbp-256], rdx
	cmp	edi, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR tv11703[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r15d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r11d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv11859[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11782[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]
$LL938@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1005@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1006@ZSTD_compr
$LN1005@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1006@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, edx
	jae	SHORT $LN943@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r10d, eax
	neg	r10

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r9d, r12d
	setae	al
	test	ecx, eax
	je	$LN946@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2004@ZSTD_compr
$LN943@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	ecx, eax
	mov	ecx, r11d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN946@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [rsi]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN946@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+3]
	mov	r9, QWORD PTR dictBase$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+3]
	add	r9, QWORD PTR tv11784[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2004@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
$LN946@ZSTD_compr:
	mov	r9, QWORD PTR bestLength$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r9
	jbe	SHORT $LN1973@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	r9d, edx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r10d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR bestLength$1$[rsp], rdx
	xor	edx, edx
	cmp	rax, r10
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN936@ZSTD_compr
$LN1973@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN936@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	edi
	add	r15, 4
	cmp	edi, r13d
	jae	SHORT $LN1887@ZSTD_compr
	mov	edx, DWORD PTR tv11782[rbp-256]
	xor	r8d, r8d
	mov	rcx, QWORD PTR rep$1$[rsp]
	jmp	$LL938@ZSTD_compr
$LN1887@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r9, 3
	jae	$LN1947@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r13, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$5[rbp-256]
	mov	rcx, r13
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	r11d, r11d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r11d
	mov	ecx, r11d
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1972@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	mov	ecx, eax
	cmp	eax, DWORD PTR dictLimit$1$[rsp]
	jb	SHORT $LN952@ZSTD_compr

; 615  :                 const BYTE* const match = base + matchIndex3;

	mov	rdx, QWORD PTR base$1$[rbp-256]

; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	add	rdx, rcx
	mov	rcx, rsi
	call	ZSTD_count

; 617  :             } else {

	jmp	SHORT $LN2005@ZSTD_compr
$LN952@ZSTD_compr:

; 618  :                 const BYTE* const match = dictBase + matchIndex3;

	mov	r8, QWORD PTR dictBase$1$[rbp-256]

; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r9, QWORD PTR tv11784[rbp-256]
	add	r9, r8
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r8+rcx]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	call	ZSTD_count_2segments
$LN2005@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
	mov	r8, rax
	cmp	rax, 3
	jb	SHORT $LN1950@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 632  :                 if ( (mlen > sufficient_len) |

	mov	edx, r11d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	r9d, 1
	lea	eax, DWORD PTR [rdi+2]
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, r10
	mov	DWORD PTR [rcx+4], r8d
	mov	eax, DWORD PTR sufficient_len$1$[rsp]
	mov	ecx, r11d
	sete	dl
	cmp	r8, rax
	seta	cl
	or	edx, ecx
	je	SHORT $LN1951@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	DWORD PTR [r13+36], eax
	jmp	$LN935@ZSTD_compr
$LN1947@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	r11d, r11d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN2006@ZSTD_compr
$LN1950@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN2006@ZSTD_compr
$LN1951@ZSTD_compr:

; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN956@ZSTD_compr
$LN1972@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR iend$1$[rsp]
$LN2006@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
$LN956@ZSTD_compr:
	mov	rax, QWORD PTR tv11785[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1946@ZSTD_compr
	npad	11
$LL939@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, r8d
	jb	$LN1946@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, QWORD PTR tv11784[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [rdi+r15]
	lea	rcx, QWORD PTR [rdi+rsi]
	cmp	rax, r8
	jb	SHORT $LN957@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	add	r12, r15
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	SHORT $LN961@ZSTD_compr
$LN957@ZSTD_compr:

; 654  :             match = dictBase + matchIndex;

	mov	r9, QWORD PTR dictBase$1$[rbp-256]

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	r12, QWORD PTR [r9+r15]
	add	r9, r8
	lea	rdx, QWORD PTR [r12+rdi]
	mov	r8, r10
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rdi+r15]
	cmp	rax, QWORD PTR tv11784[rbp-256]
	jb	SHORT $LN961@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN961@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1971@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN963@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN963@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r9*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r9d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	ecx, r11d
	mov	eax, r11d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1946@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN964@ZSTD_compr
$LN1971@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
$LN964@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN966@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11703[rsp]
	jbe	SHORT $LN1737@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN967@ZSTD_compr
$LN966@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11703[rsp]
	jbe	SHORT $LN1738@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN967@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	SHORT $LN1946@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL939@ZSTD_compr
$LN1737@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	jmp	SHORT $LN1762@ZSTD_compr
$LN1738@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
$LN1946@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1762@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
$LN2001@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR ms$[rbp-256]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN935@ZSTD_compr:
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	test	r8d, r8d
	je	$LN1954@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	mov	r9d, DWORD PTR cur$1$[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR [r15+rax*8+4]
	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1740@ZSTD_compr
	lea	eax, DWORD PTR [rcx+r9]
	cmp	eax, 4096				; 00001000H
	jae	$LN1740@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r10d, r10d
	mov	ecx, r10d
	mov	DWORD PTR matchNb$1$[rsp], ecx
	test	r8d, r8d
	je	$LN1954@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rdx, r15
	mov	QWORD PTR tv11712[rbp-256], rdx
	npad	7
$LL23@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	eax, DWORD PTR [rdx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR offset$1$[rsp], eax

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	ecx, ecx
	je	SHORT $LN63@ZSTD_compr
	lea	eax, DWORD PTR [rcx-1]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r13d, DWORD PTR [r15+rax*8+4]
	mov	eax, DWORD PTR offset$1$[rsp]
	inc	r13d
	jmp	SHORT $LN64@ZSTD_compr
$LN63@ZSTD_compr:
	mov	r13d, DWORD PTR minMatch$1$[rbp-256]
$LN64@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	cmp	edx, r13d
	jb	$LN1955@ZSTD_compr
	inc	eax
	lea	esi, DWORD PTR [rdx+r9]
	mov	r12d, r9d
	mov	DWORD PTR tv11772[rbp-256], eax
	neg	r12d
	npad	2
$LL26@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	r14d, r10d
	mov	DWORD PTR r$4[rbp-256], r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r15d, DWORD PTR [r12+rsi]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r14d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rax, QWORD PTR optStatePtr$1$[rbp-256]
	cmp	DWORD PTR [rax+80], 1
	jne	SHORT $LN1618@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r15-3]
	call	ZSTD_fracWeight
	lea	ecx, DWORD PTR [r14+16]
	shl	ecx, 8
	add	eax, ecx
	jmp	SHORT $LN1617@ZSTD_compr
$LN1618@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rax+24]
	mov	ecx, DWORD PTR [rax+r14*4]
	call	ZSTD_fracWeight
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r15-3]
	shl	r14d, 8
	add	r14d, DWORD PTR [rdx+76]
	sub	r14d, eax
	call	ZSTD_MLcode
	mov	eax, eax

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdi, QWORD PTR [rax*4]
	mov	rax, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rax, QWORD PTR [rax+16]
	mov	ecx, DWORD PTR [rax+rdi]
	call	ZSTD_fracWeight
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdi+rcx]
	shl	ecx, 8
	add	ecx, DWORD PTR [rdx+72]
	sub	ecx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	eax, DWORD PTR [rcx+51]
	add	eax, r14d
$LN1617@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	edx, eax
	cmp	esi, ebx
	ja	SHORT $LL27@ZSTD_compr
	mov	eax, esi
	imul	rcx, rax, 28
	cmp	edx, DWORD PTR [rcx+rdi]
	jge	SHORT $LN24@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN28@ZSTD_compr
	npad	11
$LL27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+rdi], 1073741824		; 40000000H
	cmp	ebx, esi
	jb	SHORT $LL27@ZSTD_compr
$LN28@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, esi
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;

	mov	eax, DWORD PTR offset$1$[rsp]
	mov	DWORD PTR [rcx+rdi+4], eax

; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+rdi+12], eax
	mov	DWORD PTR [rcx+rdi+8], r15d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rdi], edx
$LN24@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	dec	esi
	mov	r10d, 0
	lea	eax, DWORD PTR [r12+rsi]
	cmp	eax, r13d
	mov	eax, DWORD PTR tv11772[rbp-256]
	jae	$LL26@ZSTD_compr
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rsp]
	mov	r15, QWORD PTR matches$1$[rbp-256]
	jmp	SHORT $LN21@ZSTD_compr
$LN1955@ZSTD_compr:
	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN21@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	mov	rdx, QWORD PTR tv11712[rbp-256]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR matchNb$1$[rsp], ecx
	mov	QWORD PTR tv11712[rbp-256], rdx
	cmp	ecx, r8d
	jb	$LL23@ZSTD_compr

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	jmp	SHORT $LN18@ZSTD_compr
$LN1954@ZSTD_compr:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN18@ZSTD_compr:
	mov	eax, DWORD PTR cur$1$[rsp]
	inc	eax
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	eax, ebx
	ja	SHORT $LN1889@ZSTD_compr
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	jmp	$LL20@ZSTD_compr
$LN1740@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r15+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r15d, r15d
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$6[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$6[rbp-244], eax
	mov	eax, r9d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$6[rbp-248], ecx
	cmp	DWORD PTR [rax+rdi+8], r15d
	jne	SHORT $LN61@ZSTD_compr
	mov	eax, DWORD PTR [rax+rdi+12]
	jmp	SHORT $LN62@ZSTD_compr
$LN61@ZSTD_compr:
	mov	eax, r15d
$LN62@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$6[rbp-256]
	mov	rsi, QWORD PTR rep$[rbp-256]
	sub	r9d, eax
	mov	r14d, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r9d, 4096				; 00001000H
	mov	ebx, r15d
	cmovbe	ebx, r9d
	jmp	$_shortestPath$2011
$LN1889@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	rsi, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+rdi]
	mov	r14d, DWORD PTR [rdx+rdi+24]
	movsd	xmm0, QWORD PTR [rdx+rdi+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$6[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], r14d

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	$LN1999@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r15d, r15d
	jmp	$_shortestPath$2011
$LN51@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rsi+8], eax
$LN52@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	mov	r9, QWORD PTR opt$1$[rbp-256]
	lea	r13d, DWORD PTR [rbx+1]
	movups	xmm0, XMMWORD PTR lastSequence$6[rbp-256]
	mov	eax, r13d
	mov	edi, r13d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r9+16], xmm0
	mov	DWORD PTR [rcx+r9+24], r14d

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_compr
	npad	10
$LL29@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r9
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r9+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r9+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r15d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_compr
$LN30@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r13d
	ja	$LN1981@ZSTD_compr
	mov	r11, QWORD PTR src$[rbp-256]
	npad	1
$LL33@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	mov	r12, r11
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r9+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r9+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r9+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	je	$LN31@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
; 1051 :                         continue;   /* will finish */
; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	r9d, r14d
	mov	r8, r11
	mov	DWORD PTR [rsp+32], esi
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+r11]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1654@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r11]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1655@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r11+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
$LL1668@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1668@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1655@ZSTD_compr
$LN1654@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r11
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
	mov	r11, QWORD PTR src$[rbp-256]
$LN1655@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1814@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN1814@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1874@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN1874@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	r9, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	ebx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	add	r11, rbx
	mov	QWORD PTR src$[rbp-256], r11
$LN31@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	add	r12, rbx
	inc	edi
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	edi, r13d
	jbe	$LL33@ZSTD_compr

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	edx, 2
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1981@ZSTD_compr:
	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	edx, 2
	mov	r12, QWORD PTR ip$1$[rsp]
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1980@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r12, QWORD PTR ip$1$[rsp]
$LN1850@ZSTD_compr:
	inc	r12
	mov	QWORD PTR ip$1$[rsp], r12
$LN1769@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r14d, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	r13, QWORD PTR ms$[rbp-256]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r12, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL4@ZSTD_compr
$LN5@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rdi

; 1195 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2 /*optLevel*/, ZSTD_extDict);

	mov	rax, r15

; 1196 : }

	add	rsp, 424				; 000001a8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btultra_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
matchEndIdx$1$ = 48
matchEndIdx$1$ = 48
lastR$1$ = 48
nbCompares$1$ = 48
matchEndIdx$1$ = 48
dmsIndexDelta$1$ = 48
dmsIndexDelta$1$ = 48
dmsIndexDelta$1$ = 48
tv13429 = 48
current$1$ = 52
current$1$ = 52
current$1$ = 52
current$1$ = 52
dmsLowLimit$1$ = 52
dmsLowLimit$1$ = 52
dmsLowLimit$1$ = 52
dmsLowLimit$1$ = 52
dmsIndexDelta$1$ = 56
nbCompares$1$ = 56
matchEndIdx$1$ = 56
matchLow$1$ = 56
windowLow$1$ = 56
windowLow$1$ = 56
windowLow$1$ = 56
dmsIndexDelta$1$ = 56
iend$1$ = 64
matchEndIdx$1$ = 72
matchEndIdx$1$ = 72
matchEndIdx$1$ = 72
matchEndIdx$1$ = 72
cur$1$ = 72
current$1$ = 76
current$1$ = 76
current$1$ = 76
matchLow$1$ = 76
seqPos$1$ = 76
dmsIndexDelta$1$ = 80
dmsIndexDelta$1$ = 80
dmsIndexDelta$1$ = 80
sufficient_len$1$ = 80
matchNb$1$ = 80
tv13432 = 80
tv13431 = 80
tv13430 = 80
tv13428 = 80
ip$1$ = 88
largerPtr$1$ = 96
bestLength$1$ = 96
largerPtr$1$ = 96
smallerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
nbCompares$1$ = 104
btMask$1$ = 104
current$1$ = 104
ll0$1$ = 104
tv13496 = 104
tv13492 = 104
dmsHashLog$1$ = 108
dmsLowLimit$1$ = 108
lastR$1$ = 108
dmsBtMask$1$ = 108
dmsBtMask$1$ = 108
dmsBtMask$1$ = 108
offset$1$ = 108
tv13595 = 108
tv13467 = 108
base$1$ = 112
largerPtr$1$ = 112
base$1$ = 112
largerPtr$1$ = 112
bestLength$1$ = 112
bestLength$1$ = 112
bestLength$1$ = 112
base$1$ = 112
tv13674 = 112
bestLength$1$ = 120
smallerPtr$1$ = 120
smallerPtr$1$ = 120
base$1$ = 120
commonLengthLarger$1$ = 120
commonLengthLarger$1$ = 120
commonLengthLarger$1$ = 120
bestLength$1$ = 120
dmsLowLimit$1$ = 128
lastR$1$ = 128
sufficient_len$1$ = 128
matchLow$1$ = 128
dmsHighLimit$1$ = 128
dmsHighLimit$1$ = 128
dmsHighLimit$1$ = 128
tv13427 = 128
btMask$1$ = 132
dmsHighLimit$1$ = 132
dmsHighLimit$1$ = 132
dmsLowLimit$1$ = 132
sufficient_len$1$ = 132
dmsHashLog$1$ = 132
dmsHashLog$1$ = 132
dmsHashLog$1$ = 132
startML$1$ = 132
rep$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
commonLengthSmaller$1$ = 144
base$1$ = 144
dmsEnd$1$ = 144
commonLengthSmaller$2$ = 144
commonLengthSmaller$1$ = 144
commonLengthSmaller$2$ = 144
commonLengthSmaller$1$ = 144
commonLengthSmaller$2$ = 144
commonLengthSmaller$1$ = 144
commonLengthSmaller$2$ = 144
commonLengthSmaller$1$ = 144
tv13443 = 144
smallerPtr$1$ = 152
bestLength$1$ = 152
windowLow$1$ = 152
prefixStart$1$ = 152
prefixStart$1$ = 152
prefixStart$1$ = 152
dmsBase$1$ = 152
tv13512 = 152
tv13461 = 152
dummy32$1 = 152
dictLimit$1$ = 160
dictLimit$1$ = 160
dictLimit$1$ = 160
lastR$1$ = 160
litlen$1$ = 160
dmsHashLog$1$ = 164
dmsHashLog$1$ = 164
dmsBtMask$1$ = 164
matchLow$1$ = 164
matchLow$1$ = 164
tv13565 = 164
tv13550 = 164
tv13456 = 164
sufficient_len$1$ = 168
btMask$1$ = 168
btMask$1$ = 168
dmsHighLimit$1$ = 168
dmsHighLimit$1$ = 168
dictLimit$1$ = 168
tv13585 = 168
tv13575 = 168
dictLimit$1$ = 172
matchLow$1$ = 172
matchLow$1$ = 172
dmsBtMask$1$ = 172
sufficient_len$1$ = 172
sufficient_len$1$ = 172
windowLow$1$ = 172
tv13500 = 172
dmsEnd$1$ = 176
dms$1$ = 176
nextPtr$1$ = 176
commonLengthSmaller$1$ = 176
dmsBt$1$ = 176
dmsBt$1$ = 176
dmsBt$1$ = 176
dmsBt$1$ = 176
tv13601 = 176
tv13588 = 176
tv13578 = 176
tv13568 = 176
tv13553 = 176
tv13434 = 176
lastR$1$ = 184
dmsLowLimit$1$ = 184
litlen$1$ = 184
tv13426 = 184
tv13425 = 184
matches$1$ = 192
dmsEnd$1$ = 200
commonLengthSmaller$2$ = 200
commonLengthSmaller$1$ = 200
commonLengthSmaller$2$ = 200
commonLengthSmaller$1$ = 200
commonLengthLarger$1$ = 200
commonLengthSmaller$2$ = 200
bt$1$ = 200
bt$1$ = 200
bt$1$ = 200
bt$1$ = 200
windowLow$1$ = 208
windowLow$1$ = 208
dictLimit$1$ = 208
dmsEnd$1$ = 208
dmsEnd$1$ = 208
dmsEnd$1$ = 208
prefixStart$1$ = 208
tv13471 = 208
dummy32$2 = 208
dummy32$3 = 208
r$4 = 208
windowLow$1$ = 216
dmsHashLog$1$ = 216
tv13540 = 216
tv13530 = 216
tv13488 = 216
dummy32$5 = 216
matchLow$1$ = 224
dmsBtMask$1$ = 224
dmsBtMask$1$ = 224
bestLength$1$ = 224
dmsHashLog$1$ = 224
btMask$1$ = 224
btMask$1$ = 224
btMask$1$ = 224
dmsHighLimit$1$ = 232
dictLimit$1$ = 232
dictLimit$1$ = 232
base$1$ = 232
base$1$ = 232
base$1$ = 232
dmsEnd$1$ = 232
tv13520 = 232
prefixStart$1$ = 240
commonLengthLarger$1$ = 240
commonLengthLarger$1$ = 240
dmsBase$1$ = 240
dms$1$ = 240
dms$1$ = 240
dms$1$ = 240
dms$1$ = 240
dmsBtMask$1$ = 248
sufficient_len$1$ = 248
sufficient_len$1$ = 248
btMask$1$ = 248
dmsBase$1$ = 256
dmsBase$1$ = 256
dmsBase$1$ = 256
commonLengthLarger$1$ = 256
basePrice$1$ = 256
r$6 = 256
opt$1$ = 264
commonLengthLarger$1$ = 272
commonLengthSmaller$2$ = 272
prefixStart$1$ = 272
prefixStart$1$ = 272
dmsEnd$1$ = 272
optStatePtr$1$ = 280
dmsBase$1$ = 288
dmsBase$1$ = 288
dmsBase$1$ = 288
prefixStart$1$ = 288
minMatch$1$ = 296
dmsBt$1$ = 304
dms$1$ = 304
dmsBt$1$ = 304
bt$1$ = 304
tv13543 = 304
tv13533 = 304
tv13596 = 312
lastSequence$5$ = 320
bt$1$ = 328
bt$1$ = 328
bt$1$ = 328
dms$1$ = 328
dmsBt$1$ = 336
dms$1$ = 336
dmsBt$1$ = 336
tv13523 = 336
sufficient_len$1$ = 344
nextToUpdate3$7 = 348
lastSequence$8 = 352
lastSequence$4$ = 384
ilimit$1$ = 392
$T9 = 432
$T10 = 448
ms$ = 544
seqStore$ = 552
rep$ = 560
src$ = 568
nbMatches$1$ = 576
nextPtr$1$ = 576
nextPtr$1$ = 576
nextPtr$1$ = 576
nbCompares$1$ = 576
commonLengthLarger$2$ = 576
commonLengthLarger$2$ = 576
commonLengthLarger$2$ = 576
commonLengthLarger$2$ = 576
inr$1$ = 576
literalsPrice$1$ = 576
ll0$1$ = 576
dummy32$11 = 576
dummy32$12 = 576
dummy32$13 = 576
dummy32$14 = 576
srcSize$ = 576
ZSTD_compressBlock_btultra_dictMatchState PROC

; 1180 : {

$LN2055:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rsp-224]
	sub	rsp, 480				; 000001e0H

; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]

; 1180 : {

	mov	r13, rcx

; 803  :     optState_t* const optStatePtr = &ms->opt;

	add	rcx, 72					; 00000048H

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH

; 1180 : {

	mov	rdi, r9

; 803  :     optState_t* const optStatePtr = &ms->opt;

	mov	QWORD PTR optStatePtr$1$[rbp-256], rcx

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]
	lea	r15, QWORD PTR [r9+r8]
	mov	ebx, DWORD PTR [r13+24]
	lea	rsi, QWORD PTR [r15-8]
	add	rbx, QWORD PTR [r13+8]
	cmp	eax, edx
	mov	QWORD PTR iend$1$[rsp], r15
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	cmovb	edx, eax

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	r12d, r12d
	cmp	DWORD PTR [r13+200], 3
	mov	eax, r12d
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	rdx, rdi
	setne	al
	add	eax, 3
	lea	r9d, QWORD PTR [r12+2]
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR nextToUpdate3$7[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r12d
	sete	al
	lea	r9, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r9
	cmp	r9, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$8[rbp-240]
	mov	eax, DWORD PTR lastSequence$8[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	QWORD PTR [rsp+472], r14
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
$LL4@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r9d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r13+8]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, edi

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r13+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r12d
	sete	al
	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r9, rax
	jb	$LN1906@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r9d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN129@ZSTD_compr
	npad	3
$LL128@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL128@ZSTD_compr
	mov	r9, QWORD PTR ip$1$[rsp]
$LN129@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN122@ZSTD_compr
	mov	r15, QWORD PTR [r13+8]
	mov	r14d, r9d
	mov	QWORD PTR base$1$[rbp-256], r15
	cmp	esi, 5
	je	$LN124@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN123@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	sub	r14d, r15d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r14d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r14d
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	dec	ecx
	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv13601[rbp-256], rax
	mov	ebx, 1
	mov	eax, DWORD PTR [r13+24]
	shl	ebx, cl
	mov	ecx, r12d
	mov	DWORD PTR dictLimit$1$[rbp-256], eax
	dec	ebx
	add	rax, r15
	mov	QWORD PTR bt$1$[rbp-256], rdi
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r14d
	sub	eax, ebx
	mov	DWORD PTR btMask$1$[rsp], ebx
	cmp	ebx, r14d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv13432[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r9d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r9d, r9d
	mov	eax, 1

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	cmovne	eax, r9d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	mov	edi, r12d
	add	rax, 4
	mov	r12d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r14+9]
	shl	r12d, cl
	mov	rcx, QWORD PTR [r13+176]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	QWORD PTR dms$1$[rbp-256], rcx
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	mov	r10d, eax
	sub	r10d, edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	eax, r9d
	mov	QWORD PTR dmsBase$1$[rbp-256], rdx
	mov	edx, DWORD PTR [rcx+28]
	sub	eax, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+192]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r8d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	dec	r8d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	sub	ecx, r8d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], r8d
	sub	eax, edx
	cmp	r8d, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	cmovae	ecx, edx
	dec	eax
	mov	DWORD PTR tv13500[rbp-256], ecx
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r14d
	sub	edx, DWORD PTR dictLimit$1$[rbp-256]
	mov	r13d, eax
	mov	QWORD PTR tv13596[rbp-256], rax
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13595[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r15d, DWORD PTR [rax+3]
	lea	r14, QWORD PTR [rcx+rax*4]
	npad	2
$LL644@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN711@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN712@ZSTD_compr
$LN711@ZSTD_compr:
	mov	ecx, DWORD PTR [r14]
$LN712@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, DWORD PTR current$1$[rsp]

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	r11d, edx
	jae	SHORT $LN649@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r9d
	setae	al
	test	ecx, eax
	je	$LN653@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1978@ZSTD_compr
$LN649@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1978@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1977@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1978@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR ip$1$[rsp]
$LN1977@ZSTD_compr:
	mov	r9d, DWORD PTR windowLow$1$[rsp]
$LN653@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN642@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, edi

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN642@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13595[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r14, 4
	cmp	ebx, r15d
	jb	$LL644@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13601[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1767@ZSTD_compr
	npad	6
$LL645@ZSTD_compr:
	dec	r12d
	cmp	esi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1970@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r11]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2009@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN669@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rsi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN669@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN670@ZSTD_compr
$LN1716@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	jmp	$LN1965@ZSTD_compr
$LN2009@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
$LN670@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r11]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN672@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13432[rsp]
	jbe	$LN1717@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rbp-256], r15

; 685  :         } else {

	jmp	SHORT $LN2036@ZSTD_compr
$LN672@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13432[rsp]
	jbe	$LN1718@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2036@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	jne	$LL645@ZSTD_compr
$LN1767@ZSTD_compr:
	dec	r12d
$LN1970@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN2037@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN646@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1965@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 6
	mov	rcx, r11
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL647@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1965@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r15+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1983@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r15+rax]
	add	rsi, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN677@ZSTD_compr
$LN1717@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$11[rbp-256]
	jmp	$LN646@ZSTD_compr
$LN1718@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$11[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2037@ZSTD_compr
$LN1983@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN677@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2026@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1843@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1843@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx
	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	mov	ecx, r9d
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1965@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN680@ZSTD_compr
$LN2026@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN680@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13500[rbp-256]
	jbe	$LN1965@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN682@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN683@ZSTD_compr
$LN682@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN683@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL647@ZSTD_compr

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN1965@ZSTD_compr
$LN123@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	sub	r14d, r15d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r14d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r14d
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	dec	ecx
	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv13588[rbp-256], rax
	mov	ebx, 1
	mov	eax, DWORD PTR [r13+24]
	shl	ebx, cl
	mov	ecx, r12d
	mov	DWORD PTR dictLimit$1$[rbp-256], eax
	dec	ebx
	add	rax, r15
	mov	QWORD PTR bt$1$[rbp-256], rdi
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r14d
	sub	eax, ebx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv13431[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r9d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r9d, r9d
	mov	eax, 1

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	cmovne	eax, r9d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	mov	edi, r12d
	add	rax, 4
	mov	r12d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r14+9]
	shl	r12d, cl
	mov	rcx, QWORD PTR [r13+176]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	QWORD PTR dms$1$[rbp-256], rcx
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	mov	r10d, eax
	sub	r10d, edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	eax, r9d
	mov	QWORD PTR dmsBase$1$[rbp-256], rdx
	mov	edx, DWORD PTR [rcx+28]
	sub	eax, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+192]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r8d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	dec	r8d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	sub	ecx, r8d
	mov	DWORD PTR dmsBtMask$1$[rsp], r8d
	sub	eax, edx
	cmp	r8d, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	cmovae	ecx, edx
	dec	eax
	mov	DWORD PTR tv13496[rsp], ecx
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r14d
	sub	edx, DWORD PTR dictLimit$1$[rbp-256]
	mov	r13d, eax
	mov	QWORD PTR tv13596[rbp-256], rax
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13585[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r15d, DWORD PTR [rax+3]
	lea	r14, QWORD PTR [rcx+rax*4]
$LL304@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN371@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN372@ZSTD_compr
$LN371@ZSTD_compr:
	mov	ecx, DWORD PTR [r14]
$LN372@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, DWORD PTR current$1$[rsp]

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	r11d, edx
	jae	SHORT $LN309@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r9d
	setae	al
	test	ecx, eax
	je	$LN313@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1980@ZSTD_compr
$LN309@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1980@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1979@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1980@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR ip$1$[rsp]
$LN1979@ZSTD_compr:
	mov	r9d, DWORD PTR windowLow$1$[rsp]
$LN313@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN302@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, edi

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN302@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13585[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r14, 4
	cmp	ebx, r15d
	jb	$LL304@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13588[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1770@ZSTD_compr
	npad	7
$LL305@ZSTD_compr:
	dec	r12d
	cmp	esi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1971@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r11]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2011@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN329@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rsi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN329@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1716@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN330@ZSTD_compr
$LN2011@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
$LN330@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r11]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN332@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13431[rsp]
	jbe	$LN1723@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rbp-256], r15

; 685  :         } else {

	jmp	SHORT $LN2038@ZSTD_compr
$LN332@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13431[rsp]
	jbe	$LN1724@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2038@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	jne	$LL305@ZSTD_compr
$LN1770@ZSTD_compr:
	dec	r12d
$LN1971@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN2039@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN306@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1965@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 4
	mov	rcx, r11
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL307@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1965@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r15]
	cmp	rcx, rax
	jb	SHORT $LN1984@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	esi, eax
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r15
	jmp	SHORT $LN337@ZSTD_compr
$LN1723@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$13[rbp-256]
	jmp	$LN306@ZSTD_compr
$LN1724@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$13[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2039@ZSTD_compr
$LN1984@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN337@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2027@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1845@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1845@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx
	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	mov	ecx, r9d
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1965@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN340@ZSTD_compr
$LN2027@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN340@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13496[rsp]
	jbe	$LN1965@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN342@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN343@ZSTD_compr
$LN342@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN343@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL307@ZSTD_compr

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN1965@ZSTD_compr
$LN124@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmp	eax, ecx
	cmovb	ecx, eax
	sub	r14d, r15d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r14d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r14d
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	dec	ecx
	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv13578[rbp-256], rax
	mov	ebx, 1
	mov	eax, DWORD PTR [r13+24]
	shl	ebx, cl
	mov	ecx, r12d
	mov	DWORD PTR dictLimit$1$[rbp-256], eax
	dec	ebx
	add	rax, r15
	mov	QWORD PTR bt$1$[rbp-256], rdi
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r14d
	sub	eax, ebx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv13430[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r9d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r9d, r9d
	mov	eax, 1

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	cmovne	eax, r9d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	mov	edi, r12d
	add	rax, 4
	mov	r12d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r14+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	shl	r12d, cl
	mov	rcx, QWORD PTR [r13+176]
	mov	QWORD PTR dms$1$[rbp-256], rcx
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+8]
	mov	r10d, eax
	sub	r10d, edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	eax, r9d
	mov	QWORD PTR dmsBase$1$[rbp-256], rdx
	mov	edx, DWORD PTR [rcx+28]
	sub	eax, r10d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+192]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r8d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r10d
	dec	r8d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r10d
	sub	eax, edx
	mov	DWORD PTR dmsBtMask$1$[rsp], r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r10d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	sub	ecx, r8d
	cmp	r8d, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	dec	eax
	cmovae	ecx, edx
	mov	QWORD PTR tv13596[rbp-256], rax
	mov	edx, r14d
	mov	DWORD PTR tv13492[rsp], ecx
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	r13d, eax
	sub	edx, DWORD PTR dictLimit$1$[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13575[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r15d, DWORD PTR [rax+3]
	lea	r14, QWORD PTR [rcx+rax*4]
	npad	5
$LL474@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN541@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN542@ZSTD_compr
$LN541@ZSTD_compr:
	mov	ecx, DWORD PTR [r14]
$LN542@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, DWORD PTR current$1$[rsp]

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	r11d, edx
	jae	SHORT $LN479@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r9d
	setae	al
	test	ecx, eax
	je	$LN483@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1982@ZSTD_compr
$LN479@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1982@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1981@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1982@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR ip$1$[rsp]
$LN1981@ZSTD_compr:
	mov	r9d, DWORD PTR windowLow$1$[rsp]
$LN483@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN472@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13d, edx
	mov	eax, edi

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, ebx
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN472@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13575[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r14, 4
	cmp	ebx, r15d
	jb	$LL474@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13578[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1773@ZSTD_compr
	npad	7
$LL475@ZSTD_compr:
	dec	r12d
	cmp	esi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1972@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r11]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2013@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN499@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rsi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN499@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r10
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1716@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN500@ZSTD_compr
$LN2013@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r11, QWORD PTR ip$1$[rsp]
$LN500@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r11]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN502@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13430[rsp]
	jbe	$LN1729@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rbp-256], r15

; 685  :         } else {

	jmp	SHORT $LN2040@ZSTD_compr
$LN502@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13430[rsp]
	jbe	$LN1730@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2040@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	jne	$LL475@ZSTD_compr
$LN1773@ZSTD_compr:
	dec	r12d
$LN1972@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN2041@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN476@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1965@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 5
	mov	rcx, r11
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL477@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1965@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r15+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1985@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r15+rax]
	add	rsi, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN507@ZSTD_compr
$LN1729@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$12[rbp-256]
	jmp	$LN476@ZSTD_compr
$LN1730@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$12[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2041@ZSTD_compr
$LN1985@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN507@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2028@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1847@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1847@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx
	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	mov	ecx, r9d
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1965@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN510@ZSTD_compr
$LN2028@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN510@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13492[rsp]
	jbe	$LN1965@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN512@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN513@ZSTD_compr
$LN512@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN513@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL477@ZSTD_compr

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN1965@ZSTD_compr
$LN122@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, r9d
	mov	r12, QWORD PTR [r13+8]
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	mov	QWORD PTR base$1$[rsp], r12
	cmovb	ecx, eax
	sub	r15d, r12d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	esi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r14d, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	rdi, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv13568[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	lea	rax, QWORD PTR [r12+r14]
	xor	ecx, ecx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	dec	ebx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR bt$1$[rbp-256], rdi
	cmp	ebx, r15d
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	mov	DWORD PTR dictLimit$1$[rbp-256], r14d
	cmovb	ecx, eax
	mov	DWORD PTR tv13429[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	cmovne	eax, edx
	and	ecx, r15d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rsp], eax
	lea	rax, QWORD PTR [rdi+rcx*4]
	mov	ecx, DWORD PTR [r13+196]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	xor	edi, edi
	add	rax, 4
	shl	r12d, cl
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [r13+176]
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	sub	eax, r8d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	ecx, edx
	cmp	edx, eax
	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	dec	eax
	mov	edx, r15d
	cmovae	ecx, r8d
	mov	QWORD PTR tv13596[rbp-256], rax
	sub	edx, r14d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	r13d, eax
	mov	DWORD PTR tv13488[rbp-256], ecx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]
	mov	rcx, QWORD PTR rep$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv13565[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	r14, QWORD PTR [rcx+rax*4]
$LL134@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN201@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN202@ZSTD_compr
$LN201@ZSTD_compr:
	mov	eax, DWORD PTR [r14]
$LN202@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r15d

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r10d, eax
	xor	r8d, r8d
	cmp	ecx, edx
	jae	SHORT $LN139@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rcx, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, eax
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rcx]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rcx]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	$LN2032@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r9
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2051@ZSTD_compr
$LN139@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, r15d
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN2032@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r10, QWORD PTR ip$1$[rsp]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	mov	ecx, DWORD PTR [r10]
	shl	ecx, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN143@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r10+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2051@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
$LN2032@ZSTD_compr:
	mov	r10, QWORD PTR ip$1$[rsp]
$LN143@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN132@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+rdi*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	edi
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r10]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r9
	mov	r13d, edx
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN132@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	ebx
	add	r14, 4
	cmp	ebx, r11d
	jae	SHORT $LN1938@ZSTD_compr
	mov	edx, DWORD PTR tv13565[rbp-256]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL134@ZSTD_compr
$LN1938@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN1988@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r14, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$7[rbp-256]
	mov	rcx, r14
	mov	r8, r10
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	r11d, r11d
	mov	edx, r11d
	mov	ecx, r11d
	mov	ebx, r15d
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN2016@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	xor	r11d, r11d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1989@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rbx+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, r11d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	r13, rax
	lea	edi, QWORD PTR [r11+1]
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+r10]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	mov	edx, r11d
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1989@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]
	mov	DWORD PTR [r14+36], eax

; 635  :                     return 1;

	jmp	$LN131@ZSTD_compr
$LN1988@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	r11d, r11d
	jmp	SHORT $LN152@ZSTD_compr
$LN1989@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN152@ZSTD_compr
$LN2016@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	r10, QWORD PTR ip$1$[rsp]
$LN152@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv13568[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1776@ZSTD_compr
	npad	7
$LL135@ZSTD_compr:
	dec	r12d
	cmp	esi, r8d
	jb	$LN1973@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, esi
	add	eax, eax
	mov	r14d, esi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r14, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rbx+r10]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2015@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, esi
	cmp	rbx, rax
	jbe	SHORT $LN159@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rsi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN159@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r13, rbx
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, esi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r10]
	cmp	rax, r9
	mov	ecx, r11d
	mov	eax, r11d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN160@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN1965@ZSTD_compr
$LN2015@ZSTD_compr:

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
	mov	r10, QWORD PTR ip$1$[rsp]
$LN160@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r10]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN162@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], esi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13429[rsp]
	jbe	SHORT $LN1735@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */

	add	r15, 4
	mov	QWORD PTR smallerPtr$1$[rbp-256], r15

; 685  :         } else {

	jmp	SHORT $LN2042@ZSTD_compr
$LN162@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], esi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv13429[rsp]
	jbe	SHORT $LN1736@ZSTD_compr

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2042@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	esi, DWORD PTR [r15]
	test	r12d, r12d
	je	SHORT $LN1776@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL135@ZSTD_compr
$LN1735@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$14[rbp-256]
	jmp	SHORT $LN136@ZSTD_compr
$LN1736@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$14[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	SHORT $LN1973@ZSTD_compr
$LN1776@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r12d
$LN1973@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN136@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1965@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 3
	mov	rcx, r10
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	r14d, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL137@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1965@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	mov	r15d, r14d
	cmp	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, rdx
	add	rsi, r15
	lea	r13, QWORD PTR [r8+rax*4]
	add	rcx, rbx
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r15+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1987@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r15+rax]
	add	rsi, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN167@ZSTD_compr
$LN1987@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN167@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2029@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1849@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1849@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, edi
	inc	edi
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], ebx
	mov	rdx, QWORD PTR ip$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	mov	ecx, r9d
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rdx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1965@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN170@ZSTD_compr
$LN2029@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN170@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13488[rbp-256]
	jbe	SHORT $LN1965@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN172@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [r13+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN173@ZSTD_compr
$LN172@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN173@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL137@ZSTD_compr
$LN1965@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN131@ZSTD_compr:
	test	edi, edi
	je	$LN2030@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	r14, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */
; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rsi, QWORD PTR rep$[rbp-256]
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	ecx, ebx
	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rdx, r13
	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [r14+16], eax
	mov	eax, DWORD PTR [rsi+4]
	mov	DWORD PTR [r14+20], eax
	mov	eax, DWORD PTR [rsi+8]
	mov	DWORD PTR [r14+24], eax
	mov	DWORD PTR [r14+8], 0
	mov	DWORD PTR [r14+12], ebx
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [r14], eax
	lea	eax, DWORD PTR [rdi-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r15+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	SHORT $LN35@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;

	mov	DWORD PTR lastSequence$8[rbp-248], eax

; 858  :                     lastSequence.off = maxOffset;

	mov	eax, DWORD PTR [r15+rcx*8]

; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	r15d, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$8[rbp-252], eax
	mov	DWORD PTR lastSequence$8[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$8[rbp-256]
$LN2043@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	xor	r13d, r13d
	mov	ebx, r13d
$_shortestPath$2056:
	mov	eax, ebx
	lea	rdx, QWORD PTR [r14+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$8[rbp-248], 0
	je	$LN51@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T10[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r13d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rsi], xmm0
	mov	DWORD PTR [rsi+8], ecx

; 1014 :         } else {

	jmp	$LN52@ZSTD_compr
$LN35@ZSTD_compr:

; 864  :             }   }
; 865  : 
; 866  :             /* set prices for first matches starting position == 0 */
; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	rdx, QWORD PTR tv13596[rbp-256]
	lea	rcx, QWORD PTR [r14+28]
	add	eax, DWORD PTR [r14]
	mov	DWORD PTR literalsPrice$1$[rbp-256], eax
	mov	rax, rdx
	lea	esi, DWORD PTR [rdx+1]
	npad	2
$LL11@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	lea	rcx, QWORD PTR [rcx+28]
	sub	rax, 1
	jne	SHORT $LL11@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	edi, edi
	je	$LN13@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r15
	mov	ecx, edi
	mov	QWORD PTR tv13443[rbp-256], rax
	mov	QWORD PTR tv13674[rsp], rcx
	npad	10
$LL14@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r12d, DWORD PTR [rax+4]
	mov	r15d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	esi, r12d
	ja	$LN12@ZSTD_compr
	mov	rdi, QWORD PTR optStatePtr$1$[rbp-256]
	lea	r13d, DWORD PTR [r15+1]
	npad	8
$LL17@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ecx, ecx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r13d
	mov	edx, ecx
	mov	DWORD PTR r$6[rbp-256], ecx
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	ebx, edx
	shl	ebx, 8
	cmp	DWORD PTR [rdi+80], 1
	jne	SHORT $LN856@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_fracWeight
	lea	edx, DWORD PTR [rbx+4096]
	add	edx, eax
	jmp	SHORT $LN855@ZSTD_compr
$LN856@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rdi+24]
	mov	ecx, DWORD PTR [rax+rdx*4]
	call	ZSTD_fracWeight
	mov	edi, DWORD PTR [rdi+76]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rsi-3]
	sub	edi, eax
	add	edi, ebx
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	mov	eax, eax
	lea	rbx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r14+16]
	mov	ecx, DWORD PTR [rax+rbx]
	call	ZSTD_fracWeight
	lea	rcx, OFFSET FLAT:ML_bits
	mov	edx, DWORD PTR [rbx+rcx]
	shl	edx, 8
	add	edx, DWORD PTR [r14+72]
	sub	edx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	add	edx, 51					; 00000033H
	add	edx, edi
	mov	rdi, r14
$LN855@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	r14, QWORD PTR opt$1$[rbp-256]

; 882  :                         opt[pos].off = offset;
; 883  :                         opt[pos].litlen = litlen;

	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	eax, esi
	imul	rcx, rax, 28
	mov	eax, DWORD PTR literalsPrice$1$[rbp-256]
	add	eax, edx
	mov	DWORD PTR [rcx+r14+8], esi
	inc	esi
	mov	DWORD PTR [rcx+r14+4], r15d
	mov	DWORD PTR [rcx+r14+12], ebx

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+r14], eax
	cmp	esi, r12d
	jbe	$LL17@ZSTD_compr
	mov	rax, QWORD PTR tv13443[rbp-256]
	mov	rcx, QWORD PTR tv13674[rsp]
$LN12@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	rcx, 1
	mov	QWORD PTR tv13443[rbp-256], rax
	mov	QWORD PTR tv13674[rsp], rcx
	jne	$LL14@ZSTD_compr
	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
$LN13@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;

	lea	ebx, DWORD PTR [rsi-1]

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	ecx, 1
	mov	DWORD PTR seqPos$1$[rsp], ebx
	mov	DWORD PTR cur$1$[rsp], ecx
	cmp	ebx, ecx
	jb	$LN1945@ZSTD_compr
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	npad	2
$LL20@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r12d, DWORD PTR [rcx-1]
	imul	rax, r12, 28
	mov	r14d, ecx
	add	rsi, r14
	add	rdi, rax
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN57@ZSTD_compr
	mov	r15d, DWORD PTR [rdi+12]
	inc	r15d
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	r15d, 1
$LN58@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	lea	ecx, DWORD PTR [r15-1]
	mov	r8d, 2
	mov	rdx, r13
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	mov	r9d, 2
	mov	r8, r13
	sub	edi, eax
	lea	edx, QWORD PTR [r9-1]
	call	ZSTD_rawLiteralsCost
	mov	r8d, 2
	mov	rdx, r13
	mov	ecx, r15d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	imul	r14, r14, 28
	add	eax, edi
	xor	edx, edx
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	r14, rdi
	cmp	eax, DWORD PTR [r14]
	jg	SHORT $LN1927@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [r14+4], rdx

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [r14+12], r15d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [r14], eax
$LN1927@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [r14+8]
	mov	r15d, DWORD PTR cur$1$[rsp]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [r14+12], 0
	mov	r9d, edx
	mov	r8d, DWORD PTR [r14+4]
	lea	rdx, QWORD PTR [rdi+16]
	sete	r9b
	mov	eax, r15d
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], ecx

; 929  :             } else {

	jmp	SHORT $LN39@ZSTD_compr
$LN38@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r12, 28
	movsd	xmm0, QWORD PTR [rax+rdi+16]
	mov	eax, DWORD PTR [rax+rdi+24]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], eax
$LN39@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r15d, ebx
	je	$LN2003@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {
; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [r14+8]
	xor	ecx, ecx
	test	eax, eax
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_compr
	mov	eax, DWORD PTR [r14+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN60@ZSTD_compr
$LN59@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], 0
$LN60@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;

	mov	edi, DWORD PTR [r14]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	add	eax, edi

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	r14, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	rax, QWORD PTR ms$[rbp-256]

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	mov	QWORD PTR rep$1$[rbp-256], r14

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [rax+36]
	mov	r12, QWORD PTR [rax+8]
	mov	r15d, DWORD PTR [rax+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN2005@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN933@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	rbx, rax
	npad	14
$LL932@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rsi
	mov	rcx, rbx
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL932@ZSTD_compr
	mov	ebx, DWORD PTR seqPos$1$[rsp]
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN933@ZSTD_compr:

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	r12, QWORD PTR ms$[rbp-256]

; 756  :     switch(matchLengthSearch)

	mov	ecx, 4095				; 00000fffH
	mov	r13d, esi
	mov	rdi, QWORD PTR [r12+48]

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], r14d

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r12+192]
	cmp	r15d, 3
	je	$LN926@ZSTD_compr
	cmp	r15d, 5
	je	$LN928@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN927@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13553[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rsp]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13428[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	xor	r13d, r13d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r12d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rsp], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	mov	DWORD PTR dmsLowLimit$1$[rbp-256], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	eax, r8d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13596[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8, QWORD PTR rep$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13471[rbp-256], ecx
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	edx, ecx
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	r15, QWORD PTR [r8+rax*4]
	mov	DWORD PTR tv13550[rbp-256], edx

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1448@ZSTD_compr
$LL1994@ZSTD_compr:
	mov	ecx, DWORD PTR current$1$[rsp]
$LN1448@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1515@ZSTD_compr
	mov	eax, DWORD PTR [r8]
	dec	eax
	jmp	SHORT $LN1516@ZSTD_compr
$LN1515@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1516@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, ecx

; 569  :             U32 repLen = 0;

	xor	r8d, r8d
	sub	r10d, eax

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	jae	SHORT $LN1453@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r9d, eax
	neg	r9
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	cl
	xor	r10d, r10d
	cmp	edx, DWORD PTR [r9+rsi]
	mov	eax, r10d
	sete	al
	test	ecx, eax
	je	$LN1457@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2044@ZSTD_compr
$LN1453@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rbp-256]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	r10d, r10d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r10d
	setae	al
	test	edx, eax
	je	SHORT $LN1457@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1457@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2044@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
	xor	r10d, r10d
$LN1457@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1446@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rsi+r8]
	cmp	rax, r9
	mov	QWORD PTR bestLength$1$[rsp], rdx
	mov	ecx, r10d
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	sete	cl
	mov	eax, r10d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1446@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13550[rbp-256]
	inc	edi
	mov	r8, QWORD PTR rep$1$[rbp-256]
	add	r15, 4
	cmp	edi, r11d
	jb	$LL1994@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13553[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1784@ZSTD_compr
	npad	8
$LL1449@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1974@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rsi+rdi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2020@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1473@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1473@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r10d, r10d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r13d
	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	mov	ecx, r10d
	mov	eax, r10d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1474@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN1743@ZSTD_compr
$LN2020@ZSTD_compr:

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
$LN1474@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1476@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13428[rsp]
	jbe	$LN1741@ZSTD_compr

; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1477@ZSTD_compr
$LN1476@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13428[rsp]
	jbe	$LN1742@ZSTD_compr

; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1477@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1449@ZSTD_compr
$LN1784@ZSTD_compr:
	dec	r12d
$LN1974@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN1450@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1743@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	mov	r8d, 6
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ebx, ebx
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
	npad	7
$LL1451@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rbp-256]
	jbe	$LN1969@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	mov	eax, DWORD PTR dmsBtMask$1$[rbp-256]

; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rdi, rbx

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	and	eax, r15d

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rbx
	mov	r12d, r15d
	cmovb	rdi, rcx
	add	r14, r12
	lea	rax, QWORD PTR [rdx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rsi+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rcx, rax
	jb	SHORT $LN1997@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	r14d, eax
	add	r14, QWORD PTR base$1$[rsp]
	add	r14, r12
	jmp	SHORT $LN1481@ZSTD_compr
$LN1741@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$5[rbp-256]
	jmp	$LN1450@ZSTD_compr
$LN1742@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$5[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN1974@ZSTD_compr
$LN1997@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN1481@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1484@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+r15]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1852@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1852@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r8d, r8d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx
	add	eax, 2
	mov	DWORD PTR [rcx+r13*8+4], edi
	lea	rcx, QWORD PTR [rcx+r13*8]
	inc	r13d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rsi+rdi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	mov	QWORD PTR bestLength$1$[rsp], rdi
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1969@ZSTD_compr
$LN1484@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13471[rbp-256]
	jbe	$LN1969@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN1486@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rcx, rdi
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx

; 728  :             } else {

	jmp	SHORT $LN1487@ZSTD_compr
$LN1486@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rbx, rdi
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1487@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL1451@ZSTD_compr

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN1969@ZSTD_compr
$LN927@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13543[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rsp]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13427[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rbp-256], eax

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r11d, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	r13d, r11d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r12d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsLowLimit$1$[rbp-256], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	sub	eax, r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13596[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8d, DWORD PTR current$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13467[rsp], ecx
	mov	edx, r8d

; 521  :     const BYTE* const base = ms->window.base;

	mov	rcx, QWORD PTR rep$1$[rbp-256]
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR tv13540[rbp-256], edx
	mov	DWORD PTR lastR$1$[rsp], r9d
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1108@ZSTD_compr
	npad	5
$LL1995@ZSTD_compr:
	mov	r8d, DWORD PTR current$1$[rsp]
$LN1108@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1175@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1176@ZSTD_compr
$LN1175@ZSTD_compr:
	mov	ecx, DWORD PTR [r15]
$LN1176@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;

	mov	r8d, r11d
	sub	r10d, ecx

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	cmp	r11d, edx
	jae	SHORT $LN1113@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	r11d, r11d
	mov	edx, ecx
	mov	ecx, r11d
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	mov	eax, r11d
	sete	cl
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	$LN1117@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2052@ZSTD_compr
$LN1113@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	xor	edx, edx
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, ecx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rbp-256]
	sub	r9, rcx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	SHORT $LN1992@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1992@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2052@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	r11d, r11d
$LN1992@ZSTD_compr:
	mov	r9d, DWORD PTR lastR$1$[rsp]
$LN1117@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1106@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, r13d

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, edi
	mov	DWORD PTR [rcx+4], r8d
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	cmp	rax, r10
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	sete	cl
	mov	eax, r11d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1106@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13540[rbp-256]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	add	r15, 4
	cmp	edi, r9d
	jb	$LL1995@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13543[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1787@ZSTD_compr
	npad	7
$LL1109@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1975@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2018@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1133@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1133@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, r13d
	inc	r13d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, r14d
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	mov	ecx, r11d
	mov	eax, r11d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1134@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2045@ZSTD_compr
$LN2018@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
$LN1134@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1136@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13427[rbp-256]
	jbe	$LN1747@ZSTD_compr

; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1137@ZSTD_compr
$LN1136@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13427[rbp-256]
	jbe	$LN1748@ZSTD_compr

; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1137@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1109@ZSTD_compr
$LN1787@ZSTD_compr:
	dec	r12d
$LN1975@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1110@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1749@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 4
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ebx, ebx
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
	npad	1
$LL1111@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rbp-256]
	jbe	$LN1967@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	mov	rdi, rbx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rbx
	mov	r12d, r15d
	cmovb	rdi, rcx
	add	r14, r12
	lea	rax, QWORD PTR [rdx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rdi+rsi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rcx, rax
	jb	SHORT $LN1998@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	r14, QWORD PTR [r12+rax]
	add	r14, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN1141@ZSTD_compr
$LN1747@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$3[rbp-256]
	jmp	$LN1110@ZSTD_compr
$LN1748@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$3[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN1975@ZSTD_compr
$LN1998@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN1141@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1144@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1854@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1854@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r8d, r8d
	mov	eax, r13d
	inc	r13d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], edi
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1967@ZSTD_compr
$LN1144@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13467[rsp]
	jbe	SHORT $LN1967@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN1146@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rcx, rdi
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx

; 728  :             } else {

	jmp	SHORT $LN1147@ZSTD_compr
$LN1146@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rbx, rdi
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1147@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL1111@ZSTD_compr
$LN1967@ZSTD_compr:
	mov	ebx, DWORD PTR seqPos$1$[rsp]
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
$LN1749@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2045@ZSTD_compr
$LN928@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmp	eax, ecx
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13533[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rbp-256]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13426[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	xor	r13d, r13d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r12d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	sub	eax, r8d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13596[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8, QWORD PTR rep$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13461[rbp-256], ecx
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	edx, ecx
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	r15, QWORD PTR [r8+rax*4]
	mov	DWORD PTR tv13530[rbp-256], edx

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1278@ZSTD_compr
$LL1996@ZSTD_compr:
	mov	ecx, DWORD PTR current$1$[rsp]
$LN1278@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1345@ZSTD_compr
	mov	eax, DWORD PTR [r8]
	dec	eax
	jmp	SHORT $LN1346@ZSTD_compr
$LN1345@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1346@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, ecx

; 569  :             U32 repLen = 0;

	xor	r8d, r8d
	sub	r10d, eax

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	jae	SHORT $LN1283@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r9d, eax
	neg	r9
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	cl
	xor	r10d, r10d
	cmp	edx, DWORD PTR [r9+rsi]
	mov	eax, r10d
	sete	al
	test	ecx, eax
	je	$LN1287@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2046@ZSTD_compr
$LN1283@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	r10d, r10d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r10d
	setae	al
	test	edx, eax
	je	SHORT $LN1287@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r9]
	jne	SHORT $LN1287@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2046@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
	xor	r10d, r10d
$LN1287@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1276@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, r9
	mov	QWORD PTR bestLength$1$[rsp], rdx
	mov	ecx, r10d
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	sete	cl
	mov	eax, r10d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1276@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv13530[rbp-256]
	inc	edi
	mov	r8, QWORD PTR rep$1$[rbp-256]
	add	r15, 4
	cmp	edi, r11d
	jb	$LL1996@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv13533[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1790@ZSTD_compr
	npad	9
$LL1279@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1976@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2022@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1303@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1303@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r10d, r10d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r13d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	mov	ecx, r10d
	mov	eax, r10d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1304@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN1743@ZSTD_compr
$LN2022@ZSTD_compr:

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
$LN1304@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1306@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13426[rbp-256]
	jbe	$LN1753@ZSTD_compr

; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1307@ZSTD_compr
$LN1306@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13426[rbp-256]
	jbe	$LN1754@ZSTD_compr

; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1307@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1279@ZSTD_compr
$LN1790@ZSTD_compr:
	dec	r12d
$LN1976@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1280@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1743@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 5
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ebx, ebx
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
	npad	7
$LL1281@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1969@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	mov	rdi, rbx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rbx
	mov	r12d, r15d
	cmovb	rdi, rcx
	add	r14, r12
	lea	rax, QWORD PTR [rdx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rdi+rsi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+r12]
	cmp	rcx, rax
	jb	SHORT $LN1999@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	r14, QWORD PTR [r12+rax]
	add	r14, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN1311@ZSTD_compr
$LN1753@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$2[rbp-256]
	jmp	$LN1280@ZSTD_compr
$LN1754@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$2[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN1976@ZSTD_compr
$LN1999@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN1311@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1314@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1856@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1856@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r8d, r8d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx
	add	eax, 2
	mov	DWORD PTR [rcx+r13*8+4], edi
	lea	rcx, QWORD PTR [rcx+r13*8]
	inc	r13d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	mov	QWORD PTR bestLength$1$[rsp], rdi
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1969@ZSTD_compr
$LN1314@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13461[rbp-256]
	jbe	$LN1969@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN1316@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rcx, rdi
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx

; 728  :             } else {

	jmp	SHORT $LN1317@ZSTD_compr
$LN1316@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rbx, rdi
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1317@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL1281@ZSTD_compr

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN1969@ZSTD_compr
$LN926@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmp	eax, ecx
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r12+8]
	sub	r13d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r13d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r12, QWORD PTR [r12+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	xor	ecx, ecx
	mov	QWORD PTR tv13523[rbp-256], rax
	dec	edi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	add	rax, QWORD PTR base$1$[rsp]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r13d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	edi, r13d
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR dictLimit$1$[rbp-256], r15d
	cmovb	ecx, eax
	mov	DWORD PTR tv13425[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	edx, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	edx, edx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	mov	eax, 1
	cmovne	eax, edx
	and	ecx, r13d
	add	ecx, ecx
	mov	DWORD PTR matchLow$1$[rsp], eax
	lea	rax, QWORD PTR [r12+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	xor	r13d, r13d
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	rax, QWORD PTR [rax+176]
	shl	r12d, cl
	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;

	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]

; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;

	mov	r9d, ecx
	sub	r9d, r8d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rcx

; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [rax+192]
	sub	edx, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [rax+188]
	dec	ecx
	mov	QWORD PTR dmsBase$1$[rbp-256], r8
	mov	r8d, DWORD PTR [rax+28]
	shl	edx, cl
	dec	edx
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r9d
	mov	DWORD PTR dmsBtMask$1$[rbp-256], edx
	mov	DWORD PTR dmsLowLimit$1$[rbp-256], r8d

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	ecx, r9d
	sub	eax, r8d
	sub	ecx, edx
	cmp	edx, eax
	mov	rax, QWORD PTR tv13596[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	cmovae	ecx, r8d
	mov	r8, QWORD PTR rep$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv13456[rbp-256], ecx
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	edx, ecx
	sub	edx, r15d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r11d
	lea	r15, QWORD PTR [r8+rax*4]
	mov	DWORD PTR tv13520[rbp-256], edx
$LL938@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1005@ZSTD_compr
	mov	eax, DWORD PTR [r8]
	dec	eax
	jmp	SHORT $LN1006@ZSTD_compr
$LN1005@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1006@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, ecx

; 569  :             U32 repLen = 0;

	xor	r8d, r8d
	sub	r10d, eax

; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	jae	SHORT $LN943@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r9d, eax
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	$LN2035@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2053@ZSTD_compr
$LN943@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	r9d, r10d
	sub	eax, DWORD PTR dmsLowLimit$1$[rbp-256]
	sub	r9, rdx
	add	r9, QWORD PTR dmsBase$1$[rbp-256]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	setb	dl
	sub	ecx, r10d
	xor	r10d, r10d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r10d
	setae	al
	test	edx, eax
	je	SHORT $LN947@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [rsi]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN947@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2053@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rsp]
$LN2035@ZSTD_compr:
	xor	r10d, r10d
$LN947@ZSTD_compr:
	mov	r9, QWORD PTR bestLength$1$[rbp-256]
	mov	edx, r8d
	cmp	rdx, r9
	jbe	SHORT $LN936@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r10d
	mov	eax, r10d
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	sete	cl
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	mov	r9d, edx
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN936@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	edi
	add	r15, 4
	cmp	edi, r11d
	jae	SHORT $LN1943@ZSTD_compr
	mov	edx, DWORD PTR tv13520[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	r8, QWORD PTR rep$1$[rbp-256]
	jmp	$LL938@ZSTD_compr
$LN1943@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r9, 3
	jae	$LN1993@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$7[rbp-256]
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	r10d, r10d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r10d
	mov	ecx, r10d
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	SHORT $LN2025@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
	cmp	rax, 3
	jb	$LN2001@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rdi+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, r10d
	mov	QWORD PTR bestLength$1$[rbp-256], rax
	lea	r13d, QWORD PTR [r10+1]
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+rsi]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	mov	edx, r10d
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	$LN2001@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
	jmp	$LN2047@ZSTD_compr
$LN1993@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
$LN2025@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN956@ZSTD_compr:
	mov	rax, QWORD PTR tv13523[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1793@ZSTD_compr
	npad	8
$LL939@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rbp-256], r12d
	cmp	r14d, r8d
	jb	$LN1986@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2024@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN963@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN963@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r10d, r10d
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r13d
	inc	r13d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, r14d
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	ecx, r10d
	mov	eax, r10d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN964@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN1761@ZSTD_compr
$LN2001@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LN956@ZSTD_compr
$LN2024@ZSTD_compr:

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	r10d, r10d
$LN964@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN966@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13425[rbp-256]
	jbe	SHORT $LN1759@ZSTD_compr

; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN967@ZSTD_compr
$LN966@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv13425[rbp-256]
	jbe	SHORT $LN1760@ZSTD_compr

; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN967@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rbp-256]
	test	r12d, r12d
	je	SHORT $LN1793@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL939@ZSTD_compr
$LN1759@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rbp-256]
	lea	rax, QWORD PTR dummy32$1[rbp-256]
	jmp	SHORT $LN940@ZSTD_compr
$LN1760@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r12d, DWORD PTR nbCompares$1$[rbp-256]
	lea	rax, QWORD PTR dummy32$1[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	SHORT $LN1986@ZSTD_compr
$LN1793@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r12d
$LN1986@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN940@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r10d
	mov	DWORD PTR [rax], r10d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	test	r12d, r12d
	je	$LN1761@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 3
	mov	rcx, rsi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ebx, ebx
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
	npad	2
$LL941@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r12d
	mov	DWORD PTR nbCompares$1$[rbp-256], r12d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rbp-256]
	jbe	$LN1969@ZSTD_compr

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$1$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	mov	rdi, rbx

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$1$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rbx
	mov	r12d, r15d
	cmovb	rdi, rcx
	add	r14, r12
	lea	rax, QWORD PTR [rdx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rdi+rsi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+r12]
	cmp	rcx, rax
	jb	SHORT $LN2000@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	r14, QWORD PTR [r12+rax]
	add	r14, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN971@ZSTD_compr
$LN2000@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN971@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN974@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rdi, rax
	jbe	SHORT $LN1858@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1858@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r8d, r8d
	mov	eax, r13d
	inc	r13d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edx
	mov	DWORD PTR [rcx+4], edi
	add	eax, 2
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1969@ZSTD_compr
$LN974@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv13456[rbp-256]
	jbe	SHORT $LN1969@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r14+rdi], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN976@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [rax+4]
	mov	rcx, rdi
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx

; 728  :             } else {

	jmp	SHORT $LN977@ZSTD_compr
$LN976@ZSTD_compr:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [rax]
	mov	rbx, rdi
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN977@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r12d, DWORD PTR nbCompares$1$[rbp-256]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r12d, r12d
	jne	$LL941@ZSTD_compr
$LN1969@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	ebx, DWORD PTR seqPos$1$[rsp]
$LN1761@ZSTD_compr:
	mov	DWORD PTR nbMatches$1$[rbp-256], r13d
$LN1743@ZSTD_compr:
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
$LN2045@ZSTD_compr:
	add	eax, -8					; fffffff8H
$LN2047@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [rcx+36], eax
$LN935@ZSTD_compr:
	test	r13d, r13d
	je	$LN2007@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r13-1]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	mov	r8d, DWORD PTR cur$1$[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR [r15+rax*8+4]
	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1764@ZSTD_compr
	lea	eax, DWORD PTR [rcx+r8]
	cmp	eax, 4096				; 00001000H
	jae	$LN1764@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r9d, r9d
	mov	ecx, r9d
	mov	DWORD PTR matchNb$1$[rsp], ecx
	test	r13d, r13d
	je	$LN2007@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	mov	rdx, r15
	mov	QWORD PTR tv13434[rbp-256], rdx
$LL23@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	eax, DWORD PTR [rdx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR offset$1$[rsp], eax

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	ecx, ecx
	je	SHORT $LN63@ZSTD_compr
	lea	eax, DWORD PTR [rcx-1]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	esi, DWORD PTR [r15+rax*8+4]
	mov	eax, DWORD PTR offset$1$[rsp]
	inc	esi
	jmp	SHORT $LN2048@ZSTD_compr
$LN63@ZSTD_compr:
	mov	esi, DWORD PTR minMatch$1$[rbp-256]
$LN2048@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	mov	DWORD PTR startML$1$[rbp-256], esi
	cmp	edx, esi
	jb	$LN2008@ZSTD_compr
	inc	eax
	lea	r14d, DWORD PTR [rdx+r8]
	mov	r12d, r8d
	mov	DWORD PTR tv13512[rbp-256], eax
	neg	r12d
$LL26@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	edx, r9d
	mov	DWORD PTR r$4[rbp-256], r9d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r13d, DWORD PTR [r12+r14]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rax, QWORD PTR optStatePtr$1$[rbp-256]
	mov	edi, edx
	shl	edi, 8
	cmp	DWORD PTR [rax+80], 1
	jne	SHORT $LN1618@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r13-3]
	call	ZSTD_fracWeight
	lea	ecx, DWORD PTR [rdi+4096]
	add	ecx, eax
	jmp	SHORT $LN1617@ZSTD_compr
$LN1618@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rax+24]
	mov	ecx, DWORD PTR [rax+rdx*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	esi, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r13-3]
	sub	esi, eax
	add	esi, edi
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r15, QWORD PTR optStatePtr$1$[rbp-256]
	mov	eax, eax
	lea	rdi, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r15+16]
	mov	ecx, DWORD PTR [rax+rdi]
	call	ZSTD_fracWeight
	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdi+rcx]
	shl	ecx, 8
	add	ecx, DWORD PTR [r15+72]
	sub	ecx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	add	ecx, 51					; 00000033H
	add	ecx, esi
	mov	esi, DWORD PTR startML$1$[rbp-256]
$LN1617@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	edx, ecx
	cmp	r14d, ebx
	ja	SHORT $LL27@ZSTD_compr
	mov	eax, r14d
	imul	rcx, rax, 28
	cmp	edx, DWORD PTR [rcx+rdi]
	jge	SHORT $LN24@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN28@ZSTD_compr
	npad	6
$LL27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+rdi], 1073741824		; 40000000H
	cmp	ebx, r14d
	jb	SHORT $LL27@ZSTD_compr
	mov	DWORD PTR seqPos$1$[rsp], ebx
$LN28@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, r14d
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;

	mov	eax, DWORD PTR offset$1$[rsp]
	mov	DWORD PTR [rcx+rdi+4], eax

; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+rdi+12], eax
	mov	DWORD PTR [rcx+rdi+8], r13d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rdi], edx
$LN24@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	dec	r14d
	mov	r9d, 0
	lea	eax, DWORD PTR [r12+r14]
	cmp	eax, esi
	mov	eax, DWORD PTR tv13512[rbp-256]
	jae	$LL26@ZSTD_compr
	mov	r13d, DWORD PTR nbMatches$1$[rbp-256]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	r8d, DWORD PTR cur$1$[rsp]
	jmp	SHORT $LN21@ZSTD_compr
$LN2008@ZSTD_compr:
	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN21@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	mov	rdx, QWORD PTR tv13434[rbp-256]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR matchNb$1$[rsp], ecx
	mov	QWORD PTR tv13434[rbp-256], rdx
	cmp	ecx, r13d
	jb	$LL23@ZSTD_compr

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	jmp	SHORT $LN2049@ZSTD_compr
$LN2005@ZSTD_compr:
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	jmp	SHORT $LN18@ZSTD_compr
$LN2007@ZSTD_compr:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN2049@ZSTD_compr:
	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
$LN18@ZSTD_compr:
	mov	ecx, DWORD PTR cur$1$[rsp]
	inc	ecx
	mov	DWORD PTR cur$1$[rsp], ecx
	cmp	ecx, ebx
	jbe	$LL20@ZSTD_compr
	mov	r14, QWORD PTR opt$1$[rbp-256]
$LN1945@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	rsi, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+r14]
	mov	r15d, DWORD PTR [rdx+r14+24]
	movsd	xmm0, QWORD PTR [rdx+r14+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$8[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], r15d

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	$LN2043@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r13d, r13d
	jmp	$_shortestPath$2056
$LN1764@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r15+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r13d, r13d
	mov	r14, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$8[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$8[rbp-244], eax
	mov	eax, r8d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$8[rbp-248], ecx
	cmp	DWORD PTR [rax+r14+8], r13d
	jne	SHORT $LN61@ZSTD_compr
	mov	eax, DWORD PTR [rax+r14+12]
	jmp	SHORT $LN62@ZSTD_compr
$LN61@ZSTD_compr:
	mov	eax, r13d
$LN62@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$8[rbp-256]
	mov	rsi, QWORD PTR rep$[rbp-256]
	sub	r8d, eax
	mov	r15d, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r8d, 4096				; 00001000H
	mov	ebx, r13d
	cmovbe	ebx, r8d
	jmp	$_shortestPath$2056
$LN2003@ZSTD_compr:

; 935  : 
; 936  :             if (cur == last_pos) break;

	mov	r14, rdi
	jmp	$LN1945@ZSTD_compr
$LN51@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rsi+8], eax
$LN52@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	movups	xmm0, XMMWORD PTR lastSequence$8[rbp-256]
	lea	r12d, DWORD PTR [rbx+1]
	mov	eax, r12d
	mov	edi, r12d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r14], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r14+16], xmm0
	mov	DWORD PTR [rcx+r14+24], r15d

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_compr
	npad	14
$LL29@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r14
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r14], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r14+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r14+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r13d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_compr
$LN30@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r12d
	ja	$LN32@ZSTD_compr
	mov	r8, QWORD PTR src$[rbp-256]
	npad	1
$LL33@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r14+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r14+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r14+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	jne	SHORT $LN53@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */

	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR ip$1$[rsp], rax

; 1051 :                         continue;   /* will finish */

	jmp	$LN31@ZSTD_compr
$LN53@ZSTD_compr:

; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], esi
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rdx, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r13, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+rdx]
	mov	rcx, QWORD PTR [r13+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1654@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1655@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r13+24]
	lea	rcx, QWORD PTR [rdx+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
	npad	13
$LL1668@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1668@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN2050@ZSTD_compr
$LN1654@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	call	ZSTD_safecopyLiterals
$LN2050@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	mov	rdx, QWORD PTR src$[rbp-256]
$LN1655@ZSTD_compr:
	add	QWORD PTR [r13+24], rbx
	mov	rcx, QWORD PTR [r13+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1862@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r13+72], 1
	sub	rax, QWORD PTR [r13]
	sar	rax, 3
	mov	DWORD PTR [r13+76], eax
$LN1862@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r13+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1930@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r13+8]
	sub	rax, QWORD PTR [r13]
	sar	rax, 3
	mov	DWORD PTR [r13+76], eax
	mov	DWORD PTR [r13+72], 2
$LN1930@ZSTD_compr:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r13+8]
	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r13+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	eax, r15d
	add	rdx, rax
	mov	QWORD PTR src$[rbp-256], rdx
	mov	r8, rdx
	mov	QWORD PTR ip$1$[rsp], rdx
$LN31@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	mov	r14, QWORD PTR opt$1$[rbp-256]
	inc	edi
	cmp	edi, r12d
	jbe	$LL33@ZSTD_compr
$LN32@ZSTD_compr:

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	edx, 2
	call	ZSTD_setBasePrices
	mov	r9, QWORD PTR ip$1$[rsp]
	jmp	SHORT $LN1801@ZSTD_compr
$LN2030@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r9, QWORD PTR ip$1$[rsp]
$LN1906@ZSTD_compr:
	inc	r9
	mov	QWORD PTR ip$1$[rsp], r9
$LN1801@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r12d, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	r13, QWORD PTR ms$[rbp-256]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r9, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL4@ZSTD_compr
	mov	r14, QWORD PTR [rsp+472]
$LN5@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rdi

; 1181 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2 /*optLevel*/, ZSTD_dictMatchState);

	mov	rax, r15

; 1182 : }

	add	rsp, 480				; 000001e0H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btultra_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
matchEndIdx$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchLow$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
current$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
tv12482 = 52
sufficient_len$1$ = 56
matchNb$1$ = 56
matchEndIdx$1$ = 56
btMask$1$ = 56
btMask$1$ = 56
tv12485 = 56
tv12484 = 56
tv12483 = 56
tv12481 = 56
iend$1$ = 64
commonLengthSmaller$1$ = 72
commonLengthLarger$1$ = 72
commonLengthLarger$1$ = 72
commonLengthLarger$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
tv12641 = 72
windowLow$1$ = 80
nbCompares$1$ = 80
nbCompares$1$ = 80
lastR$1$ = 80
nbCompares$1$ = 80
lastR$1$ = 80
btMask$1$ = 80
tv12548 = 80
dummy32$1 = 80
ll0$1$ = 84
matchLow$1$ = 84
btMask$1$ = 84
btMask$1$ = 84
matchLow$1$ = 84
rep$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
current$1$ = 96
matchLow$1$ = 96
matchLow$1$ = 96
cur$1$ = 96
tv12608 = 96
offset$1$ = 100
lastR$1$ = 100
sufficient_len$1$ = 100
sufficient_len$1$ = 100
windowLow$1$ = 100
sufficient_len$1$ = 100
tv12568 = 100
tv12561 = 100
tv12478 = 100
ip$1$ = 104
windowLow$1$ = 112
lastR$1$ = 112
lastR$1$ = 112
btMask$1$ = 112
btMask$1$ = 112
sufficient_len$1$ = 112
sufficient_len$1$ = 112
windowLow$1$ = 112
nbCompares$1$ = 112
base$1$ = 120
commonLengthSmaller$1$ = 120
commonLengthSmaller$1$ = 120
commonLengthSmaller$1$ = 120
largerPtr$1$ = 120
largerPtr$1$ = 120
largerPtr$1$ = 120
largerPtr$1$ = 120
tv12497 = 120
btMask$1$ = 128
sufficient_len$1$ = 128
sufficient_len$1$ = 128
matchLow$1$ = 128
matchLow$1$ = 128
tv12601 = 128
tv12594 = 128
tv12575 = 128
litlen$1$ = 132
windowLow$1$ = 132
windowLow$1$ = 132
lastR$1$ = 132
tv12587 = 132
lastR$1$ = 136
lastR$1$ = 136
litlen$1$ = 136
tv12480 = 136
tv12479 = 136
matches$1$ = 144
bt$1$ = 152
bt$1$ = 152
bt$1$ = 152
bt$1$ = 152
base$1$ = 152
commonLengthSmaller$1$ = 152
commonLengthSmaller$1$ = 152
commonLengthLarger$1$ = 152
commonLengthLarger$1$ = 160
base$1$ = 160
base$1$ = 160
tv12612 = 160
tv12603 = 160
tv12596 = 160
tv12589 = 160
tv12577 = 160
tv12487 = 160
windowLow$1$ = 168
windowLow$1$ = 168
matchLow$1$ = 168
tv12554 = 168
r$2 = 168
base$1$ = 176
base$1$ = 176
base$1$ = 176
commonLengthSmaller$1$ = 176
commonLengthLarger$1$ = 176
commonLengthLarger$1$ = 176
commonLengthSmaller$1$ = 176
opt$1$ = 184
minMatch$1$ = 192
tv12609 = 200
lastSequence$5$ = 208
bt$1$ = 216
bt$1$ = 216
bt$1$ = 216
bt$1$ = 216
base$1$ = 224
tv12570 = 224
tv12563 = 224
tv12556 = 224
nextToUpdate3$3 = 232
sufficient_len$1$ = 236
basePrice$1$ = 240
commonLengthLarger$1$ = 240
lastSequence$4 = 248
lastSequence$4$ = 280
ilimit$1$ = 288
$T5 = 336
$T6 = 352
ms$ = 448
seqStore$ = 456
rep$ = 464
src$ = 472
nbMatches$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
ll0$1$ = 480
inr$1$ = 480
r$7 = 480
dummy32$8 = 480
dummy32$9 = 480
dummy32$10 = 480
srcSize$ = 480
ZSTD_compressBlock_btultra2 PROC

; 1145 : {

$LN3566:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-120]
	sub	rsp, 376				; 00000178H

; 1147 :     DEBUGLOG(5, "ZSTD_compressBlock_btultra2 (srcSize=%zu)", srcSize);
; 1148 : 
; 1149 :     /* 2-pass strategy:
; 1150 :      * this strategy makes a first pass over first block to collect statistics
; 1151 :      * and seed next round's statistics with it.
; 1152 :      * After 1st pass, function forgets everything, and starts a new block.
; 1153 :      * Consequently, this can only work if no data has been previously loaded in tables,
; 1154 :      * aka, no dictionary, no prefix, no ldm preprocessing.
; 1155 :      * The compression ratio gain is generally small (~0.5% on first block),
; 1156 :      * the cost is 2x cpu time on first block. */
; 1157 :     assert(srcSize <= ZSTD_BLOCKSIZE_MAX);
; 1158 :     if ( (ms->opt.litLengthSum==0)   /* first block */
; 1159 :       && (seqStore->sequences == seqStore->sequencesStart)  /* no ldm */
; 1160 :       && (ms->window.dictLimit == ms->window.lowLimit)   /* no dictionary */
; 1161 :       && (current == ms->window.dictLimit)   /* start of frame, nothing already loaded nor skipped */
; 1162 :       && (srcSize > ZSTD_PREDEF_THRESHOLD)

	cmp	DWORD PTR [rcx+124], 0
	mov	rsi, r9
	mov	rdi, QWORD PTR srcSize$[rbp-256]
	mov	r10, r8
	mov	r13, rcx
	jne	SHORT $LN2@ZSTD_compr
	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rdx+8], rax
	jne	SHORT $LN2@ZSTD_compr
	mov	r8d, DWORD PTR [rcx+24]
	cmp	r8d, DWORD PTR [rcx+28]
	jne	SHORT $LN2@ZSTD_compr

; 1146 :     U32 const current = (U32)((const BYTE*)src - ms->window.base);

	mov	eax, esi
	sub	eax, DWORD PTR [rcx+8]

; 1147 :     DEBUGLOG(5, "ZSTD_compressBlock_btultra2 (srcSize=%zu)", srcSize);
; 1148 : 
; 1149 :     /* 2-pass strategy:
; 1150 :      * this strategy makes a first pass over first block to collect statistics
; 1151 :      * and seed next round's statistics with it.
; 1152 :      * After 1st pass, function forgets everything, and starts a new block.
; 1153 :      * Consequently, this can only work if no data has been previously loaded in tables,
; 1154 :      * aka, no dictionary, no prefix, no ldm preprocessing.
; 1155 :      * The compression ratio gain is generally small (~0.5% on first block),
; 1156 :      * the cost is 2x cpu time on first block. */
; 1157 :     assert(srcSize <= ZSTD_BLOCKSIZE_MAX);
; 1158 :     if ( (ms->opt.litLengthSum==0)   /* first block */
; 1159 :       && (seqStore->sequences == seqStore->sequencesStart)  /* no ldm */
; 1160 :       && (ms->window.dictLimit == ms->window.lowLimit)   /* no dictionary */
; 1161 :       && (current == ms->window.dictLimit)   /* start of frame, nothing already loaded nor skipped */
; 1162 :       && (srcSize > ZSTD_PREDEF_THRESHOLD)

	cmp	eax, r8d
	jne	SHORT $LN2@ZSTD_compr
	cmp	rdi, 1024				; 00000400H
	jbe	SHORT $LN2@ZSTD_compr

; 1163 :       ) {
; 1164 :         ZSTD_initStats_ultra(ms, seqStore, rep, src, srcSize);

	mov	r8, r10
	mov	QWORD PTR [rsp+32], rdi
	call	ZSTD_initStats_ultra
$LN2@ZSTD_compr:

; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]
	lea	rcx, QWORD PTR [r13+72]
	mov	ebx, DWORD PTR [r13+24]
	lea	r15, QWORD PTR [rsi+rdi]
	add	rbx, QWORD PTR [r13+8]
	lea	r14, QWORD PTR [r15-8]
	mov	edx, 4095				; 00000fffH
	mov	QWORD PTR iend$1$[rsp], r15
	cmp	eax, edx
	mov	QWORD PTR ilimit$1$[rbp-256], r14

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;
; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	r9d, 2
	mov	r8, rdi
	cmovb	edx, eax
	xor	eax, eax
	cmp	DWORD PTR [r13+200], 3
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx
	mov	rdx, rsi
	setne	al
	add	eax, 3
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR nextToUpdate3$3[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs

; 826  :     ip += (ip==prefixStart);

	xor	ecx, ecx
	cmp	rsi, rbx
	mov	eax, ecx
	sete	al
	lea	r12, QWORD PTR [rax+rsi]
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	r12, r14

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN1601@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$4[rbp-240]
	mov	eax, DWORD PTR lastSequence$4[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	3
$LL1600@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r12d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r13+8]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, esi

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r13+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, ecx
	sete	al
	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r12, rax
	jb	$LN3433@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r12d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN1725@ZSTD_compr
	xor	r12d, r12d
	npad	4
$LL1724@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL1724@ZSTD_compr
	mov	r12, QWORD PTR ip$1$[rsp]
$LN1725@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN1718@ZSTD_compr
	cmp	esi, 5
	je	$LN1720@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	mov	esi, r12d
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN1719@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv12612[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv12485[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, esi
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv12609[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv12608[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL2240@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN2307@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN2308@ZSTD_compr
$LN2307@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN2308@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN3548@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	neg	r9

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	cmp	r10d, r11d
	mov	ecx, eax
	mov	r10, QWORD PTR ip$1$[rsp]
	setae	cl
	cmp	edx, DWORD PTR [r9+r10]
	sete	al
	test	ecx, eax
	je	SHORT $LN3499@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	add	rdx, r9
	lea	rcx, QWORD PTR [r10+4]
	call	ZSTD_count
	mov	r9d, DWORD PTR lastR$1$[rbp-256]

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, DWORD PTR windowLow$1$[rsp]

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r8d, DWORD PTR [rax+4]
$LN3548@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10, QWORD PTR ip$1$[rsp]
$LN2247@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN3533@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, r10
	mov	ecx, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rdx+rcx*8]
	inc	r14d
	mov	DWORD PTR [rdx+4], r8d
	mov	ecx, esi
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r10
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN1727@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN2238@ZSTD_compr
$LN3499@ZSTD_compr:

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
	jmp	SHORT $LN2247@ZSTD_compr
$LN3533@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
$LN2238@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12608[rsp]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	esi, r9d
	jb	$LL2240@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv12612[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN3503@ZSTD_compr
	npad	11
$LL2241@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN3503@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, edi
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rbx+rsi]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN3532@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN2265@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2265@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN2266@ZSTD_compr
$LN3503@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rax, QWORD PTR largerPtr$1$[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN3554@ZSTD_compr
$LN3532@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
$LN2266@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rbx+rsi], al
	jae	SHORT $LN2268@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12485[rsp]
	jbe	SHORT $LN3284@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN2269@ZSTD_compr
$LN2268@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12485[rsp]
	jbe	SHORT $LN3285@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2269@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL2241@ZSTD_compr
	jmp	SHORT $LN3503@ZSTD_compr
$LN3284@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	lea	r13, QWORD PTR dummy32$10[rbp-256]
	jmp	SHORT $LN3503@ZSTD_compr
$LN3285@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$10[rbp-256]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN3554@ZSTD_compr
$LN1719@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv12603[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv12484[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, esi
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv12609[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv12601[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL1900@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN1967@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1968@ZSTD_compr
$LN1967@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN1968@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1907@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [r11+rdx]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN1907@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1907@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN1898@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, r14d
	inc	r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN1727@ZSTD_compr
$LN1898@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12601[rbp-256]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	esi, r10d
	jb	$LL1900@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv12603[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN3503@ZSTD_compr
	npad	9
$LL1901@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN3503@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, edi
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rbx+rsi]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN3534@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN1925@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1925@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN3503@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1926@ZSTD_compr
$LN3534@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1926@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rbx+rsi], al
	jae	SHORT $LN1928@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12484[rsp]
	jbe	$LN3284@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN1929@ZSTD_compr
$LN1928@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12484[rsp]
	jbe	$LN3285@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN1929@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL1901@ZSTD_compr
	jmp	$LN3503@ZSTD_compr
$LN1720@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv12596[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv12483[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, esi
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv12609[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv12594[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
	npad	5
$LL2070@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN2137@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN2138@ZSTD_compr
$LN2137@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN2138@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN2077@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [r11+rdx]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN2077@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN2077@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN2068@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, r14d
	inc	r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN1727@ZSTD_compr
$LN2068@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12594[rbp-256]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	esi, r10d
	jb	$LL2070@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv12596[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN3503@ZSTD_compr
$LL2071@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN3503@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, edi
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rbx+rsi]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN3536@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN2095@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2095@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN3503@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN2096@ZSTD_compr
$LN3536@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN2096@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rbx+rsi], al
	jae	SHORT $LN2098@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12483[rsp]
	jbe	$LN3284@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN2099@ZSTD_compr
$LN2098@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12483[rsp]
	jbe	$LN3285@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN2099@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL2071@ZSTD_compr
	jmp	$LN3503@ZSTD_compr
$LN1718@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv12589[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rbp-256], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv12482[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	eax, eax
	mov	DWORD PTR windowLow$1$[rsp], eax
	mov	ecx, 1
	cmovne	ecx, eax
	mov	r9d, edx
	mov	DWORD PTR matchLow$1$[rsp], ecx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	and	ecx, esi

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	r9d, ebx
	mov	QWORD PTR tv12609[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv12587[rbp-256], r9d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r11d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL1730@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN1797@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1798@ZSTD_compr
$LN1797@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN1798@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	xor	edx, edx
	sub	r10d, ecx
	mov	r8d, edx
	cmp	eax, r9d
	jae	SHORT $LN1737@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rax]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rax]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, DWORD PTR windowLow$1$[rsp]
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN3513@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r9
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	mov	r11d, DWORD PTR lastR$1$[rsp]
	xor	edx, edx
	lea	r8d, DWORD PTR [rax+3]
$LN3513@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR tv12587[rbp-256]
$LN1737@ZSTD_compr:
	mov	r10, QWORD PTR ip$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN1728@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, r10
	mov	ecx, r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	inc	r14d
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN1727@ZSTD_compr
$LN1728@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	esi
	add	rbx, 4
	cmp	esi, r11d
	jae	SHORT $LN3459@ZSTD_compr
	mov	edx, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL1730@ZSTD_compr
$LN3459@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r12, 3
	jae	$LN3512@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$3[rbp-256]
	mov	r8, r10
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	ecx, ecx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, ecx
	mov	ebx, esi
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	SHORT $LN3539@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN3522@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rbx+2]

; 632  :                 if ( (mlen > sufficient_len) |

	xor	r8d, r8d
	mov	r12, rax
	mov	r14d, 1
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+r10]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	xor	edx, edx
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN3522@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [rsi+1]

; 635  :                     return 1;

	jmp	$LN3557@ZSTD_compr
$LN3512@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	esi, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN3558@ZSTD_compr
$LN3522@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN1748@ZSTD_compr
$LN3539@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR ip$1$[rsp]
	xor	edx, edx
$LN3558@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN1748@ZSTD_compr:
	mov	rax, QWORD PTR tv12589[rbp-256]
	mov	DWORD PTR [rax], esi

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN3517@ZSTD_compr
	npad	8
$LL1731@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, r8d
	jb	$LN3517@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, edi
	and	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rbx+r10]
	lea	rdx, QWORD PTR [rbx+rsi]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	$LN3538@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN1755@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1755@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r10]
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN1756@ZSTD_compr
$LN3517@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR largerPtr$1$[rsp]
$LN3324@ZSTD_compr:
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], edx
$LN3554@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	add	eax, -8					; fffffff8H
$LN3557@ZSTD_compr:
	mov	r8, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [r8+36], eax
$LN1727@ZSTD_compr:
	test	r14d, r14d
	je	$LN3549@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */
; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	mov	r8d, 2
	mov	r12, QWORD PTR rep$[rbp-256]
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	ecx, ebx
	mov	rsi, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR [r12]
	mov	DWORD PTR [rdi+16], eax
	mov	eax, DWORD PTR [r12+4]
	lea	rdx, QWORD PTR [rsi+72]
	mov	DWORD PTR [rdi+20], eax
	mov	eax, DWORD PTR [r12+8]
	mov	DWORD PTR [rdi+24], eax
	mov	DWORD PTR [rdi+8], 0
	mov	DWORD PTR [rdi+12], ebx
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [rdi], eax
	lea	eax, DWORD PTR [r14-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r15+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	$LN1631@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;
; 858  :                     lastSequence.off = maxOffset;
; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$4[rbp-248], eax
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR lastSequence$4[rbp-252], eax
	mov	DWORD PTR lastSequence$4[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$4[rbp-256]
$LN3560@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	xor	r14d, r14d
	mov	ebx, r14d
$_shortestPath$3567:
	mov	eax, ebx
	lea	rdx, QWORD PTR [rdi+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$4[rbp-248], 0
	je	$LN1647@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T6[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r14d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r12], xmm0
	mov	DWORD PTR [r12+8], ecx

; 1014 :         } else {

	jmp	$LN1648@ZSTD_compr
$LN3538@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	edx, edx
	mov	r10, QWORD PTR ip$1$[rsp]
$LN1756@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r10]
	cmp	BYTE PTR [rbx+rsi], al
	jae	SHORT $LN1758@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12482[rsp]
	jbe	SHORT $LN3296@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN1759@ZSTD_compr
$LN1758@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv12482[rsp]
	jbe	SHORT $LN3297@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN1759@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	je	$LN3517@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL1731@ZSTD_compr
$LN3296@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	r13, QWORD PTR dummy32$8[rbp-256]
	jmp	$LN3517@ZSTD_compr
$LN3297@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$8[rbp-256]
	jmp	$LN3324@ZSTD_compr
$LN1631@ZSTD_compr:

; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	lea	rdx, QWORD PTR [rsi+72]
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	r13d, eax
	lea	rcx, QWORD PTR [rdi+28]
	mov	rax, QWORD PTR tv12609[rbp-256]
	add	r13d, DWORD PTR [rdi]
	mov	rdx, rax
	lea	esi, DWORD PTR [rax+1]
	npad	15
$LL1607@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	lea	rcx, QWORD PTR [rcx+28]
	sub	rdx, 1
	jne	SHORT $LL1607@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	r14d, r14d
	je	$LN1609@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r15
	mov	ecx, r14d
	mov	QWORD PTR tv12497[rsp], rax
	mov	QWORD PTR tv12641[rsp], rcx
	npad	7
$LL1610@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [rax+4]
	mov	r14d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	esi, r15d
	ja	$LN1608@ZSTD_compr
	lea	r12d, DWORD PTR [r14+1]
	npad	12
$LL1613@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ecx, ecx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	edi, ecx
	mov	DWORD PTR r$7[rbp-256], ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rcx, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edi, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rcx+152], 1
	jne	SHORT $LN2452@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_fracWeight
	lea	edx, DWORD PTR [rdi+16]
	shl	edx, 8
	add	edx, eax
	jmp	SHORT $LN2451@ZSTD_compr
$LN2452@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rax+rdi*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$[rbp-256]
	shl	edi, 8
	add	edi, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rsi-3]
	sub	edi, eax
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	ecx, eax
	lea	rbx, QWORD PTR [rcx*4]
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax+rbx]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR ms$[rbp-256]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	edx, DWORD PTR [rbx+rcx]
	shl	edx, 8
	add	edx, DWORD PTR [r8+144]
	sub	edx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	add	edx, 51					; 00000033H
	add	edx, edi
$LN2451@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 882  :                         opt[pos].off = offset;
; 883  :                         opt[pos].litlen = litlen;

	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	eax, esi
	imul	rcx, rax, 28
	lea	eax, DWORD PTR [rdx+r13]
	mov	DWORD PTR [rcx+rdi+8], esi
	inc	esi
	mov	DWORD PTR [rcx+rdi+4], r14d
	mov	DWORD PTR [rcx+rdi+12], ebx

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+rdi], eax
	cmp	esi, r15d
	jbe	$LL1613@ZSTD_compr
	mov	rax, QWORD PTR tv12497[rsp]
	mov	rcx, QWORD PTR tv12641[rsp]
$LN1608@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	rcx, 1
	mov	QWORD PTR tv12497[rsp], rax
	mov	QWORD PTR tv12641[rsp], rcx
	jne	$LL1610@ZSTD_compr
$LN1609@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;
; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	eax, 1
	lea	ebx, DWORD PTR [rsi-1]
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	ebx, eax
	jb	$LN3466@ZSTD_compr
	npad	6
$LL1616@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r12d, DWORD PTR [rax-1]
	mov	r14d, eax
	imul	rax, r12, 28
	add	rsi, r14
	add	rdi, rax
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN1653@ZSTD_compr
	mov	r15d, DWORD PTR [rdi+12]
	inc	r15d
	jmp	SHORT $LN1654@ZSTD_compr
$LN1653@ZSTD_compr:
	mov	r15d, 1
$LN1654@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	mov	r13, QWORD PTR ms$[rbp-256]
	lea	ecx, DWORD PTR [r15-1]
	add	r13, 72					; 00000048H
	mov	r8d, 2
	mov	rdx, r13
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	mov	r9d, 2
	mov	r8, r13
	sub	edi, eax
	lea	edx, QWORD PTR [r9-1]
	call	ZSTD_rawLiteralsCost
	mov	r8d, 2
	mov	rdx, r13
	mov	ecx, r15d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	imul	r14, r14, 28
	add	eax, edi
	xor	edx, edx
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	r14, rdi
	cmp	eax, DWORD PTR [r14]
	jg	SHORT $LN3448@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [r14+4], rdx

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [r14+12], r15d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [r14], eax
$LN3448@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [r14+8]
	mov	r15d, DWORD PTR cur$1$[rsp]
	test	ecx, ecx
	je	SHORT $LN1634@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [r14+12], 0
	mov	r9d, edx
	mov	r8d, DWORD PTR [r14+4]
	lea	rdx, QWORD PTR [rdi+16]
	sete	r9b
	mov	eax, r15d
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], ecx

; 929  :             } else {

	jmp	SHORT $LN1635@ZSTD_compr
$LN1634@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r12, 28
	movsd	xmm0, QWORD PTR [rax+rdi+16]
	mov	eax, DWORD PTR [rax+rdi+24]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], eax
$LN1635@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN1614@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r15d, ebx
	je	$LN3466@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {
; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [r14+8]
	xor	edx, edx
	test	eax, eax
	mov	ecx, edx
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN1655@ZSTD_compr
	mov	eax, DWORD PTR [r14+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN1656@ZSTD_compr
$LN1655@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], edx
$LN1656@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;

	mov	edi, DWORD PTR [r14]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	r13, QWORD PTR ms$[rbp-256]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	add	eax, edi

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	r14, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax
	mov	QWORD PTR rep$1$[rsp], r14

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [r13+36]
	mov	r12, QWORD PTR [r13+8]
	mov	r15d, DWORD PTR [r13+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN3485@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN2508@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	npad	12
$LL2507@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rsi
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL2507@ZSTD_compr
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN2508@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rdi, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], r14d

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	r15d, 3
	je	$LN2501@ZSTD_compr
	cmp	r15d, 5
	je	$LN2503@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	mov	r15d, esi
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN2502@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv12577[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv12481[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r15d
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r12d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	lea	rax, QWORD PTR [rcx*4]
	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv12609[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv12575[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	6
$LL3023@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN3090@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN3091@ZSTD_compr
$LN3090@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN3091@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN3030@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN3524@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN3524@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN3030@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN3541@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN2510@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN3021@ZSTD_compr
$LN3541@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN3021@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12575[rbp-256]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL3023@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv12577[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN3490@ZSTD_compr
	npad	10
$LL3024@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN3490@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [rdi+r15]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN3540@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN3048@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN3048@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN3490@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN3049@ZSTD_compr
$LN3540@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN3049@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [rdi+r15], al
	jae	SHORT $LN3051@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12481[rsp]
	jbe	SHORT $LN3300@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN3052@ZSTD_compr
$LN3051@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12481[rsp]
	jbe	SHORT $LN3301@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN3052@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL3024@ZSTD_compr
	jmp	SHORT $LN3490@ZSTD_compr
$LN3300@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$1[rsp]
	xor	edx, edx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN3561@ZSTD_compr
$LN3301@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$1[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN3490@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN3561@ZSTD_compr
$LN2502@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv12570[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv12480[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r15d
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r12d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	lea	rax, QWORD PTR [rcx*4]
	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv12609[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv12568[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	7
$LL2683@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN2750@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN2751@ZSTD_compr
$LN2750@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN2751@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN2690@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	sete	cl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	ecx, eax
	je	SHORT $LN2690@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN2690@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN3543@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r9*8]
	inc	r9d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN2510@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN2681@ZSTD_compr
$LN3543@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN2681@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12568[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r10d
	jb	$LL2683@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv12570[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN3490@ZSTD_compr
	npad	11
$LL2684@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN3490@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+rdi]
	lea	rdx, QWORD PTR [rdi+r15]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN3542@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN2708@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2708@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN3490@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN2709@ZSTD_compr
$LN3542@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN2709@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [rdi+r15], al
	jae	SHORT $LN2711@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12480[rbp-256]
	jbe	$LN3300@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN2712@ZSTD_compr
$LN2711@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12480[rbp-256]
	jbe	$LN3301@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN2712@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL2684@ZSTD_compr
	jmp	$LN3490@ZSTD_compr
$LN2503@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv12563[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv12479[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv12609[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv12561[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL2853@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN2920@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN2921@ZSTD_compr
$LN2920@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN2921@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN2860@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	sete	cl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	ecx, eax
	je	SHORT $LN2860@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN2860@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN3545@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r9*8]
	inc	r9d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN2510@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN2851@ZSTD_compr
$LN3545@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN2851@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12561[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r10d
	jb	$LL2853@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv12563[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN3490@ZSTD_compr
	npad	11
$LL2854@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN3490@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [rdi+r15]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN3544@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN2878@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2878@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN3490@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN2879@ZSTD_compr
$LN3544@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN2879@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [rdi+r15], al
	jae	SHORT $LN2881@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12479[rbp-256]
	jbe	$LN3300@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN2882@ZSTD_compr
$LN2881@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12479[rbp-256]
	jbe	$LN3301@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN2882@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL2854@ZSTD_compr
	jmp	$LN3490@ZSTD_compr
$LN2501@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv12556[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv12478[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r15d
	test	r11d, r11d
	mov	eax, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r12d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	lea	rax, QWORD PTR [rcx*4]
	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv12609[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv12554[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL2513@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN2580@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN2581@ZSTD_compr
$LN2580@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN2581@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN3552@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]
	shl	edx, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, r11d
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN3525@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	mov	r9d, DWORD PTR lastR$1$[rbp-256]

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, DWORD PTR windowLow$1$[rsp]

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r8d, DWORD PTR [rax+3]
$LN3552@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	edx, edx
$LN2520@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN3531@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN2510@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN2511@ZSTD_compr
$LN3525@ZSTD_compr:

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
	jmp	SHORT $LN2520@ZSTD_compr
$LN3531@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
$LN2511@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r15d
	add	rdi, 4
	cmp	r15d, r9d
	jae	SHORT $LN3464@ZSTD_compr
	mov	edx, DWORD PTR tv12554[rbp-256]
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$1$[rsp]
	jmp	$LL2513@ZSTD_compr
$LN3464@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN3526@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$3[rbp-256]
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	ecx, ecx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, ecx
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN3530@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rbp-256]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN3527@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rdi+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;

	mov	r10d, 1
	mov	r13, rax
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	DWORD PTR [rdx], ecx

; 632  :                 if ( (mlen > sufficient_len) |

	lea	rcx, QWORD PTR [rax+rsi]
	mov	DWORD PTR [rdx+4], eax
	xor	edx, edx
	cmp	rcx, r9
	mov	r8d, edx
	mov	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN3528@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	jmp	$LN3562@ZSTD_compr
$LN3526@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN3563@ZSTD_compr
$LN3527@ZSTD_compr:

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	jmp	SHORT $LN2531@ZSTD_compr
$LN3528@ZSTD_compr:

; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN2531@ZSTD_compr
$LN3530@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	edx, edx
$LN3563@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN2531@ZSTD_compr:
	mov	rax, QWORD PTR tv12556[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN3521@ZSTD_compr
	npad	7
$LL2514@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, r8d
	jb	$LN3521@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, r14d
	and	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [rdi+r15]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN3529@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN2538@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2538@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r10*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r10d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN3521@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN2539@ZSTD_compr
$LN3529@ZSTD_compr:
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	edx, edx
	mov	r9, QWORD PTR iend$1$[rsp]
$LN2539@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [rdi+r15], al
	jae	SHORT $LN2541@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12478[rsp]
	jbe	SHORT $LN3312@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN2542@ZSTD_compr
$LN2541@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv12478[rsp]
	jbe	SHORT $LN3313@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN2542@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	je	SHORT $LN3521@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL2514@ZSTD_compr
$LN3312@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	jmp	SHORT $LN3337@ZSTD_compr
$LN3313@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN3521@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN3337@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
$LN3561@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	add	eax, -8					; fffffff8H
$LN3562@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [rcx+36], eax
$LN2510@ZSTD_compr:
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	test	r8d, r8d
	je	$LN3485@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	mov	r9d, DWORD PTR cur$1$[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR [r15+rax*8+4]
	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN3315@ZSTD_compr
	lea	eax, DWORD PTR [r9+rcx]
	cmp	eax, 4096				; 00001000H
	jae	$LN3315@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r10d, r10d
	mov	ecx, r10d
	mov	DWORD PTR matchNb$1$[rsp], ecx
	test	r8d, r8d
	je	$LN3485@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rdx, r15
	mov	QWORD PTR tv12487[rbp-256], rdx
	npad	8
$LL1619@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	eax, DWORD PTR [rdx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR offset$1$[rsp], eax

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	ecx, ecx
	je	SHORT $LN1659@ZSTD_compr
	lea	eax, DWORD PTR [rcx-1]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r13d, DWORD PTR [r15+rax*8+4]
	mov	eax, DWORD PTR offset$1$[rsp]
	inc	r13d
	jmp	SHORT $LN1660@ZSTD_compr
$LN1659@ZSTD_compr:
	mov	r13d, DWORD PTR minMatch$1$[rbp-256]
$LN1660@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	cmp	edx, r13d
	jb	$LN3486@ZSTD_compr
	inc	eax
	lea	esi, DWORD PTR [r9+rdx]
	mov	r12d, r9d
	mov	DWORD PTR tv12548[rsp], eax
	neg	r12d
	npad	1
$LL1622@ZSTD_compr:

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	r15d, DWORD PTR [r12+rsi]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	r14d, r10d
	mov	DWORD PTR r$2[rbp-256], r10d
	cmovne	r14d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rcx+152], 1
	jne	SHORT $LN3193@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r15-3]
	call	ZSTD_fracWeight
	lea	ecx, DWORD PTR [r14+16]
	shl	ecx, 8
	add	eax, ecx
	jmp	SHORT $LN3192@ZSTD_compr
$LN3193@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rax+r14*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$[rbp-256]
	shl	r14d, 8
	add	r14d, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r15-3]
	sub	r14d, eax
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, eax
	lea	rdi, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax+rdi]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR ms$[rbp-256]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdi+rcx]
	shl	ecx, 8
	add	ecx, DWORD PTR [r8+144]
	sub	ecx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	eax, DWORD PTR [rcx+51]
	add	eax, r14d
$LN3192@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	edx, eax
	cmp	esi, ebx
	ja	SHORT $LL1623@ZSTD_compr
	mov	eax, esi
	imul	rcx, rax, 28
	cmp	edx, DWORD PTR [rcx+rdi]
	jge	SHORT $LN1620@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN1624@ZSTD_compr
	npad	5
$LL1623@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+rdi], 1073741824		; 40000000H
	cmp	ebx, esi
	jb	SHORT $LL1623@ZSTD_compr
$LN1624@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, esi
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;

	mov	eax, DWORD PTR offset$1$[rsp]
	mov	DWORD PTR [rcx+rdi+4], eax

; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+rdi+12], eax
	mov	DWORD PTR [rcx+rdi+8], r15d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rdi], edx
$LN1620@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	dec	esi
	mov	r10d, 0
	lea	eax, DWORD PTR [r12+rsi]
	cmp	eax, r13d
	mov	eax, DWORD PTR tv12548[rsp]
	jae	$LL1622@ZSTD_compr
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rsp]
	jmp	SHORT $LN1617@ZSTD_compr
$LN3486@ZSTD_compr:
	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN1617@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	mov	rdx, QWORD PTR tv12487[rbp-256]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR matchNb$1$[rsp], ecx
	mov	QWORD PTR tv12487[rbp-256], rdx
	cmp	ecx, r8d
	jb	$LL1619@ZSTD_compr

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	jmp	SHORT $LN1614@ZSTD_compr
$LN3485@ZSTD_compr:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN1614@ZSTD_compr:
	mov	eax, DWORD PTR cur$1$[rsp]
	inc	eax
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	eax, ebx
	jbe	$LL1616@ZSTD_compr
$LN3466@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	r12, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+rdi]
	mov	esi, DWORD PTR [rdx+rdi+24]
	movsd	xmm0, QWORD PTR [rdx+rdi+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$4[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], esi

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	$LN3560@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r14d, r14d
	jmp	$_shortestPath$3567
$LN3315@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r15+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r14d, r14d
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$4[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$4[rbp-244], eax
	mov	eax, r9d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$4[rbp-248], ecx
	cmp	DWORD PTR [rax+rdi+8], r14d
	jne	SHORT $LN1657@ZSTD_compr
	mov	eax, DWORD PTR [rax+rdi+12]
	jmp	SHORT $LN1658@ZSTD_compr
$LN1657@ZSTD_compr:
	mov	eax, r14d
$LN1658@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$4[rbp-256]
	mov	r12, QWORD PTR rep$[rbp-256]
	sub	r9d, eax
	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r9d, 4096				; 00001000H
	mov	ebx, r14d
	cmovbe	ebx, r9d
	jmp	$_shortestPath$3567
$LN1647@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [r12], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r12+8], eax
$LN1648@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	mov	r9, QWORD PTR opt$1$[rbp-256]
	lea	r13d, DWORD PTR [rbx+1]
	movups	xmm0, XMMWORD PTR lastSequence$4[rbp-256]
	mov	eax, r13d
	mov	edi, r13d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r9+16], xmm0
	mov	DWORD PTR [rcx+r9+24], esi

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN1626@ZSTD_compr
	npad	13
$LL1625@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r9
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r9+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r9+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r14d
	test	ebx, ebx
	jne	SHORT $LL1625@ZSTD_compr
$LN1626@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r13d
	ja	$LN3550@ZSTD_compr
	mov	r11, QWORD PTR src$[rbp-256]
	npad	1
$LL1629@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	mov	r12, r11
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r9+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r9+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r9+4]
	lea	r15d, DWORD PTR [rdx+rsi]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	je	$LN1627@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
; 1051 :                         continue;   /* will finish */
; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	r9d, r14d
	add	rcx, 72					; 00000048H
	mov	DWORD PTR [rsp+32], esi
	mov	r8, r11
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [r11+rbx]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN3229@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r11]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN3230@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r11+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
	npad	9
$LL3243@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL3243@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN3230@ZSTD_compr
$LN3229@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r11
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
	mov	r11, QWORD PTR src$[rbp-256]
$LN3230@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN3397@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN3397@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN3451@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN3451@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	r9, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	ebx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	add	r11, rbx
	mov	QWORD PTR src$[rbp-256], r11
$LN1627@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	add	r12, rbx
	inc	edi
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	edi, r13d
	jbe	$LL1629@ZSTD_compr
	jmp	SHORT $LN1628@ZSTD_compr
$LN3550@ZSTD_compr:
	mov	r12, QWORD PTR ip$1$[rsp]
$LN1628@ZSTD_compr:

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	r13, QWORD PTR ms$[rbp-256]
	mov	edx, 2
	lea	rcx, QWORD PTR [r13+72]
	call	ZSTD_setBasePrices
	jmp	SHORT $LN3344@ZSTD_compr
$LN3549@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r12, QWORD PTR ip$1$[rsp]
	mov	r13, QWORD PTR ms$[rbp-256]
$LN3433@ZSTD_compr:
	inc	r12
	mov	QWORD PTR ip$1$[rsp], r12
$LN3344@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	ecx, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	rsi, QWORD PTR src$[rbp-256]
	cmp	r12, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL1600@ZSTD_compr
$LN1601@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rsi

; 1165 :     }
; 1166 : 
; 1167 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2 /*optLevel*/, ZSTD_noDict);

	mov	rax, r15

; 1168 : }

	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btultra2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchLow$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
current$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
matchEndIdx$1$ = 52
tv11041 = 52
btMask$1$ = 56
matchEndIdx$1$ = 56
sufficient_len$1$ = 56
matchNb$1$ = 56
tv11044 = 56
tv11043 = 56
tv11042 = 56
tv11040 = 56
tv11038 = 56
iend$1$ = 64
smallerPtr$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
smallerPtr$1$ = 72
commonLengthLarger$1$ = 72
commonLengthLarger$1$ = 72
commonLengthLarger$1$ = 72
commonLengthSmaller$1$ = 72
tv11214 = 72
btMask$1$ = 80
nbCompares$1$ = 80
windowLow$1$ = 80
lastR$1$ = 80
nbCompares$1$ = 80
nbCompares$1$ = 80
windowLow$1$ = 80
tv11107 = 80
dummy32$1 = 80
matchLow$1$ = 84
btMask$1$ = 84
btMask$1$ = 84
matchLow$1$ = 84
ll0$1$ = 84
rep$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
largerPtr$1$ = 88
matchLow$1$ = 96
matchLow$1$ = 96
current$1$ = 96
cur$1$ = 96
tv11167 = 96
sufficient_len$1$ = 100
matchLow$1$ = 100
lastR$1$ = 100
sufficient_len$1$ = 100
sufficient_len$1$ = 100
lastR$1$ = 100
offset$1$ = 100
tv11127 = 100
tv11037 = 100
ip$1$ = 104
nbCompares$1$ = 112
windowLow$1$ = 112
sufficient_len$1$ = 112
btMask$1$ = 112
btMask$1$ = 112
lastR$1$ = 112
lastR$1$ = 112
windowLow$1$ = 112
tv11120 = 112
largerPtr$1$ = 120
largerPtr$1$ = 120
largerPtr$1$ = 120
largerPtr$1$ = 120
commonLengthSmaller$1$ = 120
commonLengthSmaller$1$ = 120
commonLengthSmaller$1$ = 120
base$1$ = 120
tv11056 = 120
btMask$1$ = 128
matchLow$1$ = 128
sufficient_len$1$ = 128
sufficient_len$1$ = 128
btMask$1$ = 128
tv11160 = 128
tv11153 = 128
tv11134 = 128
windowLow$1$ = 132
windowLow$1$ = 132
windowLow$1$ = 132
litlen$1$ = 132
tv11146 = 132
lastR$1$ = 136
lastR$1$ = 136
lastR$1$ = 136
litlen$1$ = 136
tv11039 = 136
matches$1$ = 144
commonLengthLarger$1$ = 152
commonLengthSmaller$1$ = 152
commonLengthSmaller$1$ = 152
base$1$ = 152
bt$1$ = 152
bt$1$ = 152
bt$1$ = 152
bt$1$ = 152
base$1$ = 160
base$1$ = 160
commonLengthLarger$1$ = 160
tv11171 = 160
tv11162 = 160
tv11155 = 160
tv11148 = 160
tv11136 = 160
tv11046 = 160
matchLow$1$ = 168
sufficient_len$1$ = 168
windowLow$1$ = 168
tv11113 = 168
r$2 = 168
commonLengthSmaller$1$ = 176
commonLengthLarger$1$ = 176
commonLengthLarger$1$ = 176
commonLengthSmaller$1$ = 176
base$1$ = 176
base$1$ = 176
base$1$ = 176
opt$1$ = 184
minMatch$1$ = 192
tv11168 = 200
lastSequence$5$ = 208
bt$1$ = 216
bt$1$ = 216
bt$1$ = 216
bt$1$ = 216
base$1$ = 224
tv11129 = 224
tv11122 = 224
tv11115 = 224
nextToUpdate3$3 = 232
sufficient_len$1$ = 236
commonLengthLarger$1$ = 240
basePrice$1$ = 240
lastSequence$4 = 248
lastSequence$4$ = 280
ilimit$1$ = 288
$T5 = 336
$T6 = 352
ms$ = 448
seqStore$ = 456
rep$ = 464
src$ = 472
nbCompares$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
nbCompares$1$ = 480
nbMatches$1$ = 480
inr$1$ = 480
ll0$1$ = 480
dummy32$7 = 480
dummy32$8 = 480
dummy32$9 = 480
r$10 = 480
srcSize$ = 480
ZSTD_compressBlock_btultra PROC

; 1137 : {

$LN1990:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-120]
	sub	rsp, 376				; 00000178H

; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]

; 1137 : {

	mov	r13, rcx

; 803  :     optState_t* const optStatePtr = &ms->opt;

	add	rcx, 72					; 00000048H

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH

; 1137 : {

	mov	rdi, r9

; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]
	lea	r15, QWORD PTR [r9+r8]
	mov	ebx, DWORD PTR [r13+24]
	lea	rsi, QWORD PTR [r15-8]
	add	rbx, QWORD PTR [r13+8]
	cmp	eax, edx
	mov	QWORD PTR iend$1$[rsp], r15
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	cmovb	edx, eax

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	r14d, r14d
	cmp	DWORD PTR [r13+200], 3
	mov	eax, r14d
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	rdx, rdi
	setne	al
	add	eax, 3
	lea	r9d, QWORD PTR [r14+2]
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR nextToUpdate3$3[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r14d
	sete	al
	lea	r12, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	r12, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$4[rbp-240]
	mov	eax, DWORD PTR lastSequence$4[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	1
$LL4@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r12d

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r13+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, edi
	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r14d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r13+8]

; 834  :             U32 const ll0 = !litlen;

	sete	al
	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r12, rax
	jb	$LN1858@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r12d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN129@ZSTD_compr
	xor	r12d, r12d
	npad	3
$LL128@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL128@ZSTD_compr
	mov	r12, QWORD PTR ip$1$[rsp]
$LN129@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN122@ZSTD_compr
	cmp	esi, 5
	je	$LN124@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	mov	esi, r12d
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN123@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11171[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11044[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	test	r11d, r11d
	mov	eax, 1

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11168[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11167[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL644@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN711@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN712@ZSTD_compr
$LN711@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN712@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN651@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN651@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN651@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN642@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, r14d
	inc	r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN642@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11167[rsp]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	esi, r10d
	jb	$LL644@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11171[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1927@ZSTD_compr
	npad	12
$LL645@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1927@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1957@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN669@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN669@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN670@ZSTD_compr
$LN1927@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rax, QWORD PTR largerPtr$1$[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN1978@ZSTD_compr
$LN1957@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
$LN670@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN672@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11044[rsp]
	jbe	SHORT $LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN673@ZSTD_compr
$LN672@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11044[rsp]
	jbe	SHORT $LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN673@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL645@ZSTD_compr
	jmp	SHORT $LN1927@ZSTD_compr
$LN1709@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	lea	r13, QWORD PTR dummy32$8[rbp-256]
	jmp	SHORT $LN1927@ZSTD_compr
$LN1710@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$8[rbp-256]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN1978@ZSTD_compr
$LN123@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11162[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11043[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	test	r11d, r11d
	mov	eax, 1

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11168[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11160[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL304@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN371@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN372@ZSTD_compr
$LN371@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN372@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN311@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN311@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN311@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN302@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, r14d
	inc	r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN302@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11160[rbp-256]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	esi, r10d
	jb	$LL304@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11162[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1927@ZSTD_compr
	npad	9
$LL305@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1927@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1959@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN329@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN329@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1927@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN330@ZSTD_compr
$LN1959@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN330@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN332@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11043[rsp]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN333@ZSTD_compr
$LN332@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11043[rsp]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN333@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL305@ZSTD_compr
	jmp	$LN1927@ZSTD_compr
$LN124@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11155[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11042[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	test	r11d, r11d
	mov	eax, 1

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11168[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11153[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rcx+rax*4]
	npad	5
$LL474@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN541@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN542@ZSTD_compr
$LN541@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN542@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN481@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rbp-256]
	setae	al
	test	ecx, eax
	je	SHORT $LN481@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN481@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN472@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	mov	ecx, r14d
	inc	r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN472@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11153[rbp-256]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	mov	rcx, QWORD PTR rep$[rbp-256]
	cmp	esi, r10d
	jb	$LL474@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11155[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1927@ZSTD_compr
$LL475@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1927@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1961@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN499@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN499@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	mov	ecx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rbx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1927@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN500@ZSTD_compr
$LN1961@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN500@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN502@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11042[rsp]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN503@ZSTD_compr
$LN502@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11042[rsp]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN503@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL475@ZSTD_compr
	jmp	$LN1927@ZSTD_compr
$LN122@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	esi, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	mov	QWORD PTR base$1$[rsp], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r12d, r12d
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r13+64]
	mov	r14d, 1

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r13+24]
	mov	edx, esi
	shl	r14d, cl
	mov	ecx, r12d
	mov	QWORD PTR tv11148[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rbp-256], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR tv11041[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	eax, eax
	mov	DWORD PTR windowLow$1$[rsp], eax
	mov	ecx, 1
	cmovne	ecx, eax
	mov	r9d, edx
	mov	DWORD PTR matchLow$1$[rsp], ecx

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	and	ecx, esi

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	mov	r14d, r12d
	add	ecx, ecx
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	r9d, ebx
	mov	QWORD PTR tv11168[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11146[rbp-256], r9d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r11d
	lea	rbx, QWORD PTR [rcx+rax*4]
$LL134@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN201@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN202@ZSTD_compr
$LN201@ZSTD_compr:
	mov	ecx, DWORD PTR [rbx]
$LN202@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	xor	edx, edx
	sub	r10d, ecx
	mov	r8d, edx
	cmp	eax, r9d
	jae	SHORT $LN141@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rax]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rax]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, DWORD PTR windowLow$1$[rsp]
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN1937@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r9
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	mov	r11d, DWORD PTR lastR$1$[rsp]
	xor	edx, edx
	lea	r8d, DWORD PTR [rax+3]
$LN1937@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR tv11146[rbp-256]
$LN141@ZSTD_compr:
	mov	r10, QWORD PTR ip$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN132@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, r10
	mov	ecx, r14d
	lea	rdx, QWORD PTR [rdx+rcx*8]
	inc	r14d
	mov	ecx, esi
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rbp-256]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN132@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	esi
	add	rbx, 4
	cmp	esi, r11d
	jae	SHORT $LN1884@ZSTD_compr
	mov	edx, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL134@ZSTD_compr
$LN1884@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r12, 3
	jae	$LN1936@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$3[rbp-256]
	mov	r8, r10
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	edx, edx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	ebx, esi
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	xor	ecx, ecx
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	SHORT $LN1964@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rsp]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1946@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rbx+2]

; 632  :                 if ( (mlen > sufficient_len) |

	xor	r8d, r8d
	mov	r12, rax
	mov	r14d, 1
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+r10]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	xor	edx, edx
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1946@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [rsi+1]

; 635  :                     return 1;

	jmp	$LN1981@ZSTD_compr
$LN1936@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	esi, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1982@ZSTD_compr
$LN1946@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN152@ZSTD_compr
$LN1964@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR ip$1$[rsp]
	xor	edx, edx
$LN1982@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN152@ZSTD_compr:
	mov	rax, QWORD PTR tv11148[rbp-256]
	mov	DWORD PTR [rax], esi

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1941@ZSTD_compr
	npad	8
$LL135@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, r8d
	jb	$LN1941@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	add	rsi, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rbx+r10]
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	$LN1963@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN159@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN159@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r10]
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN160@ZSTD_compr
$LN1941@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR largerPtr$1$[rsp]
$LN1749@ZSTD_compr:
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], edx
$LN1978@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	add	eax, -8					; fffffff8H
$LN1981@ZSTD_compr:
	mov	r8, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [r8+36], eax
$LN131@ZSTD_compr:
	test	r14d, r14d
	je	$LN1973@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */
; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	mov	r8d, 2
	mov	r12, QWORD PTR rep$[rbp-256]
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	ecx, ebx
	mov	rsi, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR [r12]
	mov	DWORD PTR [rdi+16], eax
	mov	eax, DWORD PTR [r12+4]
	lea	rdx, QWORD PTR [rsi+72]
	mov	DWORD PTR [rdi+20], eax
	mov	eax, DWORD PTR [r12+8]
	mov	DWORD PTR [rdi+24], eax
	mov	DWORD PTR [rdi+8], 0
	mov	DWORD PTR [rdi+12], ebx
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [rdi], eax
	lea	eax, DWORD PTR [r14-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r15+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	$LN35@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;
; 858  :                     lastSequence.off = maxOffset;
; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$4[rbp-248], eax
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR lastSequence$4[rbp-252], eax
	mov	DWORD PTR lastSequence$4[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$4[rbp-256]
$LN1984@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	xor	r14d, r14d
	mov	ebx, r14d
$_shortestPath$1991:
	mov	eax, ebx
	lea	rdx, QWORD PTR [rdi+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$4[rbp-248], 0
	je	$LN51@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T6[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r14d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r12], xmm0
	mov	DWORD PTR [r12+8], ecx

; 1014 :         } else {

	jmp	$LN52@ZSTD_compr
$LN1963@ZSTD_compr:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	edx, edx
	mov	r10, QWORD PTR ip$1$[rsp]
$LN160@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r10]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN162@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11041[rsp]
	jbe	SHORT $LN1721@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN163@ZSTD_compr
$LN162@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11041[rsp]
	jbe	SHORT $LN1722@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN163@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	je	$LN1941@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL135@ZSTD_compr
$LN1721@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	r13, QWORD PTR dummy32$9[rbp-256]
	jmp	$LN1941@ZSTD_compr
$LN1722@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$9[rbp-256]
	jmp	$LN1749@ZSTD_compr
$LN35@ZSTD_compr:

; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	lea	rdx, QWORD PTR [rsi+72]
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	r13d, eax
	lea	rcx, QWORD PTR [rdi+28]
	mov	rax, QWORD PTR tv11168[rbp-256]
	add	r13d, DWORD PTR [rdi]
	mov	rdx, rax
	lea	esi, DWORD PTR [rax+1]
	npad	15
$LL11@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	lea	rcx, QWORD PTR [rcx+28]
	sub	rdx, 1
	jne	SHORT $LL11@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	r14d, r14d
	je	$LN13@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r15
	mov	ecx, r14d
	mov	QWORD PTR tv11056[rsp], rax
	mov	QWORD PTR tv11214[rsp], rcx
	npad	7
$LL14@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [rax+4]
	mov	r14d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	esi, r15d
	ja	$LN12@ZSTD_compr
	lea	r12d, DWORD PTR [r14+1]
	npad	12
$LL17@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ecx, ecx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	edi, ecx
	mov	DWORD PTR r$10[rbp-256], ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rcx, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edi, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rcx+152], 1
	jne	SHORT $LN856@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_fracWeight
	lea	edx, DWORD PTR [rdi+16]
	shl	edx, 8
	add	edx, eax
	jmp	SHORT $LN855@ZSTD_compr
$LN856@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rax+rdi*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$[rbp-256]
	shl	edi, 8
	add	edi, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rsi-3]
	sub	edi, eax
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, eax
	lea	rbx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax+rbx]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR ms$[rbp-256]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	edx, DWORD PTR [rbx+rcx]
	shl	edx, 8
	add	edx, DWORD PTR [r8+144]
	sub	edx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	add	edx, 51					; 00000033H
	add	edx, edi
$LN855@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 882  :                         opt[pos].off = offset;
; 883  :                         opt[pos].litlen = litlen;

	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	eax, esi
	imul	rcx, rax, 28
	lea	eax, DWORD PTR [rdx+r13]
	mov	DWORD PTR [rcx+rdi+8], esi
	inc	esi
	mov	DWORD PTR [rcx+rdi+4], r14d
	mov	DWORD PTR [rcx+rdi+12], ebx

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+rdi], eax
	cmp	esi, r15d
	jbe	$LL17@ZSTD_compr
	mov	rax, QWORD PTR tv11056[rsp]
	mov	rcx, QWORD PTR tv11214[rsp]
$LN12@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	rcx, 1
	mov	QWORD PTR tv11056[rsp], rax
	mov	QWORD PTR tv11214[rsp], rcx
	jne	$LL14@ZSTD_compr
$LN13@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;
; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	eax, 1
	lea	ebx, DWORD PTR [rsi-1]
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	ebx, eax
	jb	$LN1891@ZSTD_compr
	npad	6
$LL20@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r12d, DWORD PTR [rax-1]
	mov	r14d, eax
	imul	rax, r12, 28
	add	rsi, r14
	add	rdi, rax
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN57@ZSTD_compr
	mov	r15d, DWORD PTR [rdi+12]
	inc	r15d
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	r15d, 1
$LN58@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	mov	r13, QWORD PTR ms$[rbp-256]
	lea	ecx, DWORD PTR [r15-1]
	add	r13, 72					; 00000048H
	mov	r8d, 2
	mov	rdx, r13
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	mov	r9d, 2
	mov	r8, r13
	sub	edi, eax
	lea	edx, QWORD PTR [r9-1]
	call	ZSTD_rawLiteralsCost
	mov	r8d, 2
	mov	rdx, r13
	mov	ecx, r15d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	imul	r14, r14, 28
	add	eax, edi
	xor	edx, edx
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	r14, rdi
	cmp	eax, DWORD PTR [r14]
	jg	SHORT $LN1873@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [r14+4], rdx

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [r14+12], r15d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [r14], eax
$LN1873@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [r14+8]
	mov	r15d, DWORD PTR cur$1$[rsp]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [r14+12], 0
	mov	r9d, edx
	mov	r8d, DWORD PTR [r14+4]
	lea	rdx, QWORD PTR [rdi+16]
	sete	r9b
	mov	eax, r15d
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], ecx

; 929  :             } else {

	jmp	SHORT $LN39@ZSTD_compr
$LN38@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r12, 28
	movsd	xmm0, QWORD PTR [rax+rdi+16]
	mov	eax, DWORD PTR [rax+rdi+24]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], eax
$LN39@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r15d, ebx
	je	$LN1891@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {
; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [r14+8]
	xor	edx, edx
	test	eax, eax
	mov	ecx, edx
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_compr
	mov	eax, DWORD PTR [r14+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN60@ZSTD_compr
$LN59@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], edx
$LN60@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;

	mov	edi, DWORD PTR [r14]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	r13, QWORD PTR ms$[rbp-256]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	add	eax, edi

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	r14, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax
	mov	QWORD PTR rep$1$[rsp], r14

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [r13+36]
	mov	r12, QWORD PTR [r13+8]
	mov	r15d, DWORD PTR [r13+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN1910@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN933@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	npad	12
$LL932@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rsi
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL932@ZSTD_compr
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN933@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rdi, QWORD PTR [r13+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], r14d

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	r15d, 3
	je	$LN926@ZSTD_compr
	cmp	r15d, 5
	je	$LN928@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	mov	r15d, esi
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN927@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11136[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv11040[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11168[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11134[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	6
$LL1448@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1515@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1516@ZSTD_compr
$LN1515@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1516@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1455@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN1948@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1948@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN1455@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1966@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1446@ZSTD_compr
$LN1966@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1446@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11134[rbp-256]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL1448@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11136[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1915@ZSTD_compr
	npad	10
$LL1449@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1915@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+rdi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1965@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1473@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1473@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1915@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1474@ZSTD_compr
$LN1965@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1474@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1476@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11040[rsp]
	jbe	SHORT $LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1477@ZSTD_compr
$LN1476@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11040[rsp]
	jbe	SHORT $LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1477@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1449@ZSTD_compr
	jmp	SHORT $LN1915@ZSTD_compr
$LN1725@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$1[rsp]
	xor	edx, edx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1985@ZSTD_compr
$LN1726@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$1[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1915@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1985@ZSTD_compr
$LN927@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11129[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv11039[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11168[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11127[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	7
$LL1108@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1175@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1176@ZSTD_compr
$LN1175@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1176@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1115@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	sete	cl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	ecx, eax
	je	SHORT $LN1115@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN1115@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1970@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r9*8]
	inc	r9d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1106@ZSTD_compr
$LN1970@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1106@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11127[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r10d
	jb	$LL1108@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11129[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1915@ZSTD_compr
	npad	11
$LL1109@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1915@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1969@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1133@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1133@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1915@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1134@ZSTD_compr
$LN1969@ZSTD_compr:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1134@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1136@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11039[rbp-256]
	jbe	$LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1137@ZSTD_compr
$LN1136@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11039[rbp-256]
	jbe	$LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1137@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1109@ZSTD_compr
	jmp	$LN1915@ZSTD_compr
$LN928@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11122[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rbp-256], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv11038[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11168[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11120[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL1278@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1345@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1346@ZSTD_compr
$LN1345@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1346@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1285@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN1949@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1949@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN1285@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1968@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1276@ZSTD_compr
$LN1968@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1276@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11120[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL1278@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11122[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1915@ZSTD_compr
	npad	10
$LL1279@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1915@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1967@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1303@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1303@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1915@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1304@ZSTD_compr
$LN1967@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1304@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1306@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11038[rsp]
	jbe	$LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1307@ZSTD_compr
$LN1306@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11038[rsp]
	jbe	$LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN1307@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1279@ZSTD_compr
	jmp	$LN1915@ZSTD_compr
$LN926@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	mov	rax, QWORD PTR [r13+8]
	sub	r15d, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	QWORD PTR base$1$[rbp-256], rax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	ecx, DWORD PTR [r9+188]
	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	mov	edi, DWORD PTR [r9+24]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11115[rbp-256], rax
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	eax, r15d
	sub	eax, r12d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmovb	ecx, eax
	mov	DWORD PTR tv11037[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rbp-256], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11168[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11113[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL938@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1005@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1006@ZSTD_compr
$LN1005@ZSTD_compr:
	mov	ecx, DWORD PTR [rdi]
$LN1006@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1976@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]
	shl	edx, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, r11d
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN1950@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	mov	r9d, DWORD PTR lastR$1$[rbp-256]

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, DWORD PTR windowLow$1$[rsp]

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r8d, DWORD PTR [rax+3]
$LN1976@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	edx, edx
$LN945@ZSTD_compr:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1956@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN936@ZSTD_compr
$LN1950@ZSTD_compr:

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
	jmp	SHORT $LN945@ZSTD_compr
$LN1956@ZSTD_compr:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
$LN936@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r15d
	add	rdi, 4
	cmp	r15d, r9d
	jae	SHORT $LN1889@ZSTD_compr
	mov	edx, DWORD PTR tv11113[rbp-256]
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$1$[rsp]
	jmp	$LL938@ZSTD_compr
$LN1889@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN1951@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$3[rbp-256]
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	ecx, ecx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, ecx
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1955@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rbp-256]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1952@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rdi+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;

	mov	r10d, 1
	mov	r13, rax
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	DWORD PTR [rdx], ecx

; 632  :                 if ( (mlen > sufficient_len) |

	lea	rcx, QWORD PTR [rax+rsi]
	mov	DWORD PTR [rdx+4], eax
	xor	edx, edx
	cmp	rcx, r9
	mov	r8d, edx
	mov	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1953@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	jmp	$LN1986@ZSTD_compr
$LN1951@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1987@ZSTD_compr
$LN1952@ZSTD_compr:

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	jmp	SHORT $LN956@ZSTD_compr
$LN1953@ZSTD_compr:

; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN956@ZSTD_compr
$LN1955@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	edx, edx
$LN1987@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN956@ZSTD_compr:
	mov	rax, QWORD PTR tv11115[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1945@ZSTD_compr
	npad	5
$LL939@ZSTD_compr:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, r8d
	jb	$LN1945@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1954@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN963@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN963@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r10*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r10d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1945@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN964@ZSTD_compr
$LN1954@ZSTD_compr:
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	edx, edx
	mov	r9, QWORD PTR iend$1$[rsp]
$LN964@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN966@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11037[rsp]
	jbe	SHORT $LN1737@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN967@ZSTD_compr
$LN966@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11037[rsp]
	jbe	SHORT $LN1738@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN967@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	je	SHORT $LN1945@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL939@ZSTD_compr
$LN1737@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$7[rbp-256]
	jmp	SHORT $LN1762@ZSTD_compr
$LN1738@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$7[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1945@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1762@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
$LN1985@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	add	eax, -8					; fffffff8H
$LN1986@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [rcx+36], eax
$LN935@ZSTD_compr:
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	test	r8d, r8d
	je	$LN1910@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	mov	r9d, DWORD PTR cur$1$[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR [r15+rax*8+4]
	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1740@ZSTD_compr
	lea	eax, DWORD PTR [rcx+r9]
	cmp	eax, 4096				; 00001000H
	jae	$LN1740@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r10d, r10d
	mov	ecx, r10d
	mov	DWORD PTR matchNb$1$[rsp], ecx
	test	r8d, r8d
	je	$LN1910@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rdx, r15
	mov	QWORD PTR tv11046[rbp-256], rdx
	npad	8
$LL23@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	eax, DWORD PTR [rdx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR offset$1$[rsp], eax

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	ecx, ecx
	je	SHORT $LN63@ZSTD_compr
	lea	eax, DWORD PTR [rcx-1]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r13d, DWORD PTR [r15+rax*8+4]
	mov	eax, DWORD PTR offset$1$[rsp]
	inc	r13d
	jmp	SHORT $LN64@ZSTD_compr
$LN63@ZSTD_compr:
	mov	r13d, DWORD PTR minMatch$1$[rbp-256]
$LN64@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	cmp	edx, r13d
	jb	$LN1911@ZSTD_compr
	inc	eax
	lea	esi, DWORD PTR [rdx+r9]
	mov	r12d, r9d
	mov	DWORD PTR tv11107[rsp], eax
	neg	r12d
	npad	1
$LL26@ZSTD_compr:

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	r15d, DWORD PTR [r12+rsi]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	r14d, r10d
	mov	DWORD PTR r$2[rbp-256], r10d
	cmovne	r14d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rcx+152], 1
	jne	SHORT $LN1618@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r15-3]
	call	ZSTD_fracWeight
	lea	ecx, DWORD PTR [r14+16]
	shl	ecx, 8
	add	eax, ecx
	jmp	SHORT $LN1617@ZSTD_compr
$LN1618@ZSTD_compr:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rax+r14*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$[rbp-256]
	shl	r14d, 8
	add	r14d, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r15-3]
	sub	r14d, eax
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, eax
	lea	rdi, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax+rdi]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR ms$[rbp-256]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdi+rcx]
	shl	ecx, 8
	add	ecx, DWORD PTR [r8+144]
	sub	ecx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	eax, DWORD PTR [rcx+51]
	add	eax, r14d
$LN1617@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	edx, eax
	cmp	esi, ebx
	ja	SHORT $LL27@ZSTD_compr
	mov	eax, esi
	imul	rcx, rax, 28
	cmp	edx, DWORD PTR [rcx+rdi]
	jge	SHORT $LN24@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN28@ZSTD_compr
	npad	5
$LL27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+rdi], 1073741824		; 40000000H
	cmp	ebx, esi
	jb	SHORT $LL27@ZSTD_compr
$LN28@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, esi
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;

	mov	eax, DWORD PTR offset$1$[rsp]
	mov	DWORD PTR [rcx+rdi+4], eax

; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+rdi+12], eax
	mov	DWORD PTR [rcx+rdi+8], r15d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rdi], edx
$LN24@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	dec	esi
	mov	r10d, 0
	lea	eax, DWORD PTR [r12+rsi]
	cmp	eax, r13d
	mov	eax, DWORD PTR tv11107[rsp]
	jae	$LL26@ZSTD_compr
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rsp]
	jmp	SHORT $LN21@ZSTD_compr
$LN1911@ZSTD_compr:
	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN21@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	mov	rdx, QWORD PTR tv11046[rbp-256]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR matchNb$1$[rsp], ecx
	mov	QWORD PTR tv11046[rbp-256], rdx
	cmp	ecx, r8d
	jb	$LL23@ZSTD_compr

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	jmp	SHORT $LN18@ZSTD_compr
$LN1910@ZSTD_compr:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN18@ZSTD_compr:
	mov	eax, DWORD PTR cur$1$[rsp]
	inc	eax
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	eax, ebx
	jbe	$LL20@ZSTD_compr
$LN1891@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	r12, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+rdi]
	mov	esi, DWORD PTR [rdx+rdi+24]
	movsd	xmm0, QWORD PTR [rdx+rdi+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$4[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], esi

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	$LN1984@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r14d, r14d
	jmp	$_shortestPath$1991
$LN1740@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r15+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r14d, r14d
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$4[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$4[rbp-244], eax
	mov	eax, r9d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$4[rbp-248], ecx
	cmp	DWORD PTR [rax+rdi+8], r14d
	jne	SHORT $LN61@ZSTD_compr
	mov	eax, DWORD PTR [rax+rdi+12]
	jmp	SHORT $LN62@ZSTD_compr
$LN61@ZSTD_compr:
	mov	eax, r14d
$LN62@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$4[rbp-256]
	mov	r12, QWORD PTR rep$[rbp-256]
	sub	r9d, eax
	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r9d, 4096				; 00001000H
	mov	ebx, r14d
	cmovbe	ebx, r9d
	jmp	$_shortestPath$1991
$LN51@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [r12], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r12+8], eax
$LN52@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	mov	r9, QWORD PTR opt$1$[rbp-256]
	lea	r13d, DWORD PTR [rbx+1]
	movups	xmm0, XMMWORD PTR lastSequence$4[rbp-256]
	mov	eax, r13d
	mov	edi, r13d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r9+16], xmm0
	mov	DWORD PTR [rcx+r9+24], esi

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_compr
	npad	13
$LL29@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r9
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r9+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r9+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r14d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_compr
$LN30@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r13d
	ja	$LN1974@ZSTD_compr
	mov	r11, QWORD PTR src$[rbp-256]
	npad	1
$LL33@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	mov	r12, r11
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r9+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r9+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r9+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	je	$LN31@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
; 1051 :                         continue;   /* will finish */
; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	r9d, r14d
	add	rcx, 72					; 00000048H
	mov	DWORD PTR [rsp+32], esi
	mov	r8, r11
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+r11]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1654@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r11]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1655@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r11+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
	npad	9
$LL1668@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1668@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1655@ZSTD_compr
$LN1654@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r11
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
	mov	r11, QWORD PTR src$[rbp-256]
$LN1655@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1822@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN1822@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1876@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN1876@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	r9, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	ebx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	add	r11, rbx
	mov	QWORD PTR src$[rbp-256], r11
$LN31@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	add	r12, rbx
	inc	edi
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	edi, r13d
	jbe	$LL33@ZSTD_compr
	jmp	SHORT $LN32@ZSTD_compr
$LN1974@ZSTD_compr:
	mov	r12, QWORD PTR ip$1$[rsp]
$LN32@ZSTD_compr:

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	r13, QWORD PTR ms$[rbp-256]
	mov	edx, 2
	lea	rcx, QWORD PTR [r13+72]
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1973@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r12, QWORD PTR ip$1$[rsp]
	mov	r13, QWORD PTR ms$[rbp-256]
$LN1858@ZSTD_compr:
	inc	r12
	mov	QWORD PTR ip$1$[rsp], r12
$LN1769@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r14d, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r12, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL4@ZSTD_compr
$LN5@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rdi

; 1138 :     DEBUGLOG(5, "ZSTD_compressBlock_btultra (srcSize=%zu)", srcSize);
; 1139 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2 /*optLevel*/, ZSTD_noDict);

	mov	rax, r15

; 1140 : }

	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btultra ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
nbCompares$1$ = 48
matchEndIdx$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 52
current$1$ = 52
btMask$1$ = 52
matchLow$1$ = 52
lastR$1$ = 52
lastR$1$ = 52
lastR$1$ = 52
matchEndIdx$1$ = 52
dictLimit$1$ = 56
nbCompares$1$ = 56
matchEndIdx$1$ = 56
dictLimit$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
nbCompares$1$ = 56
iend$1$ = 64
matchEndIdx$1$ = 72
sufficient_len$1$ = 72
matchNb$1$ = 72
tv12001 = 72
tv11991 = 72
tv11981 = 72
tv11845 = 72
tv11844 = 72
tv11843 = 72
matchEndIdx$1$ = 76
dictLimit$1$ = 76
nbCompares$1$ = 76
nbCompares$1$ = 76
matchLow$1$ = 76
matchLow$1$ = 76
matchLow$1$ = 76
tv11846 = 76
ip$1$ = 80
smallerPtr$1$ = 88
smallerPtr$1$ = 88
smallerPtr$1$ = 88
smallerPtr$1$ = 88
commonLengthSmaller$1$ = 88
commonLengthSmaller$1$ = 88
commonLengthSmaller$1$ = 88
largerPtr$1$ = 88
btMask$1$ = 96
btMask$1$ = 96
btMask$1$ = 96
matchLow$1$ = 96
ll0$1$ = 96
bestLength$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
bestLength$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
largerPtr$1$ = 104
dictBase$1$ = 104
rep$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
btMask$1$ = 120
sufficient_len$1$ = 120
dictLimit$1$ = 120
tv11924 = 120
dummy32$1 = 120
dummy32$2 = 120
dummy32$3 = 120
r$4 = 120
r$5 = 120
r$6 = 120
btMask$1$ = 124
matchLow$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
sufficient_len$1$ = 124
btMask$1$ = 124
tv11954 = 124
sufficient_len$1$ = 128
matchLow$1$ = 128
dictLimit$1$ = 128
dictLimit$1$ = 128
dictLimit$1$ = 128
tv11971 = 128
tv11944 = 128
tv11842 = 128
lastR$1$ = 132
litlen$1$ = 132
tv11849 = 132
tv11848 = 132
tv11847 = 132
largerPtr$1$ = 136
bestLength$1$ = 136
bestLength$1$ = 136
dictBase$1$ = 136
base$1$ = 136
base$1$ = 136
base$1$ = 136
commonLengthLarger$1$ = 136
dictBase$1$ = 144
base$1$ = 144
dictEnd$1$ = 144
base$1$ = 144
dictBase$1$ = 144
dictBase$1$ = 144
dictBase$1$ = 144
tv11973 = 144
tv11860 = 144
tv11851 = 144
prefixStart$1$ = 152
commonLengthSmaller$1$ = 152
prefixStart$1$ = 152
prefixStart$1$ = 152
prefixStart$1$ = 152
prefixStart$1$ = 152
commonLengthSmaller$1$ = 152
tv12038 = 152
tv11946 = 152
dictEnd$1$ = 160
commonLengthLarger$1$ = 160
base$1$ = 160
largerPtr$1$ = 160
dictEnd$1$ = 160
dictEnd$1$ = 160
dictEnd$1$ = 160
prefixStart$1$ = 160
cur$1$ = 168
litlen$1$ = 168
bt$1$ = 176
commonLengthSmaller$1$ = 176
base$1$ = 176
tv12004 = 176
tv11993 = 176
tv11983 = 176
tv11956 = 176
tv11926 = 176
matches$1$ = 184
commonLengthLarger$1$ = 192
prefixStart$1$ = 192
bt$1$ = 192
commonLengthLarger$1$ = 192
bt$1$ = 192
bt$1$ = 192
bt$1$ = 192
bt$1$ = 192
dictBase$1$ = 200
commonLengthLarger$1$ = 200
commonLengthSmaller$1$ = 200
tv12007 = 200
tv11994 = 200
tv11984 = 200
tv11974 = 200
tv11957 = 200
matchLow$1$ = 208
sufficient_len$1$ = 208
btMask$1$ = 208
tv11934 = 208
opt$1$ = 216
minMatch$1$ = 224
commonLengthLarger$1$ = 232
commonLengthLarger$1$ = 232
commonLengthLarger$1$ = 232
basePrice$1$ = 232
commonLengthSmaller$1$ = 240
dictEnd$1$ = 240
dictBase$1$ = 240
bt$1$ = 240
base$1$ = 248
prefixStart$1$ = 248
tv11936 = 248
tv12002 = 256
optStatePtr$1$ = 264
lastSequence$5$ = 272
bt$1$ = 280
tv11947 = 280
tv11937 = 280
tv11927 = 280
nextToUpdate3$7 = 288
sufficient_len$1$ = 292
lastSequence$8 = 296
lastSequence$4$ = 328
ilimit$1$ = 336
$T9 = 384
$T10 = 400
ms$ = 496
seqStore$ = 504
rep$ = 512
src$ = 520
nbCompares$1$ = 528
nbCompares$1$ = 528
nbCompares$1$ = 528
nbMatches$1$ = 528
inr$1$ = 528
ll0$1$ = 528
dummy32$11 = 528
dummy32$12 = 528
r$13 = 528
r$14 = 528
dummy32$15 = 528
r$16 = 528
srcSize$ = 528
ZSTD_compressBlock_btopt_extDict PROC

; 1187 : {

$LN2008:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-168]
	sub	rsp, 424				; 000001a8H

; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]

; 1187 : {

	mov	r13, rcx

; 803  :     optState_t* const optStatePtr = &ms->opt;

	add	rcx, 72					; 00000048H

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH

; 1187 : {

	mov	rdi, r9

; 803  :     optState_t* const optStatePtr = &ms->opt;

	mov	QWORD PTR optStatePtr$1$[rbp-256], rcx

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]
	lea	r15, QWORD PTR [r9+r8]
	mov	ebx, DWORD PTR [r13+24]
	lea	rsi, QWORD PTR [r15-8]
	add	rbx, QWORD PTR [r13+8]
	cmp	eax, edx
	mov	QWORD PTR iend$1$[rsp], r15
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	cmovb	edx, eax

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	r14d, r14d
	cmp	DWORD PTR [r13+200], 3
	mov	eax, r14d
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	rdx, rdi
	setne	al
	xor	r9d, r9d
	add	eax, 3
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR nextToUpdate3$7[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r14d
	sete	al
	lea	r12, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	r12, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$8[rbp-240]
	mov	eax, DWORD PTR lastSequence$8[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	11
$LL4@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r13+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r12d

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r13+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, edi
	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r14d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r13+8]

; 834  :             U32 const ll0 = !litlen;

	sete	al
	mov	DWORD PTR ll0$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r12, rax
	jb	$LN1849@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r12d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN129@ZSTD_compr
	npad	6
$LL128@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r14
	mov	DWORD PTR [rsp+32], 1
	mov	r8, r15
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL128@ZSTD_compr
$LN129@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	r14, QWORD PTR [r13+8]
	mov	ecx, 4095				; 00000fffH
	mov	rbx, QWORD PTR [r13+48]

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r13+192]
	cmp	esi, 3
	je	$LN122@ZSTD_compr
	mov	QWORD PTR base$1$[rbp-256], r14
	mov	r15d, r12d
	cmp	esi, 5
	je	$LN124@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN123@ZSTD_compr

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	sub	r15d, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv12007[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	eax, esi
	mov	rcx, QWORD PTR [r13+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rsi
	mov	QWORD PTR tv12004[rbp-256], rax
	add	rax, r14
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	DWORD PTR tv11849[rbp-256], ecx
	mov	rcx, r13
	mov	DWORD PTR dictLimit$1$[rbp-256], esi
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	cmovne	eax, r14d
	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	r13d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, esi
	mov	QWORD PTR tv12002[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv12001[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN644@ZSTD_compr
$LL1981@ZSTD_compr:
	xor	r8d, r8d
$LN644@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN711@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN712@ZSTD_compr
$LN711@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN712@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r9d, eax
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN649@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	SHORT $LN1984@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN1992@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN1984@ZSTD_compr:
	xor	r9d, r9d
$LN652@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, r12
	jbe	$LN1956@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r11]
	mov	DWORD PTR [rcx+4], r8d
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	cmp	rax, r11
	mov	r12d, edx
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN642@ZSTD_compr
$LN649@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	sub	eax, r14d
	xor	edx, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1917@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1917@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN1992@ZSTD_compr
$LN1917@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN652@ZSTD_compr
$LN1956@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN642@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv12001[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL1981@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv12007[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1908@ZSTD_compr
	npad	6
$LL645@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1908@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv12004[rbp-256]
	jb	SHORT $LN663@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	rsi, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN667@ZSTD_compr
$LN663@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	r14, rsi
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv12004[rbp-256]
	jb	SHORT $LN1974@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN1974@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	rsi, QWORD PTR ip$1$[rsp]
$LN667@ZSTD_compr:
	cmp	rbx, r12
	jbe	SHORT $LN1955@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN669@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN669@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r13d
	lea	rax, QWORD PTR [rbx+rsi]
	mov	ecx, r9d
	cmp	rax, r11
	mov	r12, rbx
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1908@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN670@ZSTD_compr
$LN1955@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN670@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rsi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN672@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11849[rbp-256]
	jbe	SHORT $LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN673@ZSTD_compr
$LN672@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11849[rbp-256]
	jbe	SHORT $LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN673@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL645@ZSTD_compr
	jmp	SHORT $LN1908@ZSTD_compr
$LN1709@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$12[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1993@ZSTD_compr
$LN1710@ZSTD_compr:
	lea	rax, QWORD PTR dummy32$12[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1908@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1993@ZSTD_compr
$LN123@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	sub	r15d, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11994[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	eax, esi
	mov	rcx, QWORD PTR [r13+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rsi
	mov	QWORD PTR tv11993[rbp-256], rax
	add	rax, r14
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	DWORD PTR tv11848[rbp-256], ecx
	mov	rcx, r13
	mov	DWORD PTR dictLimit$1$[rbp-256], esi
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	cmovne	eax, r14d
	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	r13d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, esi
	mov	QWORD PTR tv12002[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11991[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN304@ZSTD_compr
	npad	6
$LL1982@ZSTD_compr:
	xor	r8d, r8d
$LN304@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN371@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN372@ZSTD_compr
$LN371@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN372@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r9d, eax
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN309@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	SHORT $LN1985@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN1994@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN1985@ZSTD_compr:
	xor	r9d, r9d
$LN312@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, r12
	jbe	$LN1958@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r11]
	mov	DWORD PTR [rcx+4], r8d
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	cmp	rax, r11
	mov	r12d, edx
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN302@ZSTD_compr
$LN309@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	sub	eax, r14d
	xor	edx, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1919@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1919@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN1994@ZSTD_compr
$LN1919@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN312@ZSTD_compr
$LN1958@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN302@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11991[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL1982@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11994[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1908@ZSTD_compr
	npad	7
$LL305@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1908@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, QWORD PTR tv11993[rbp-256]
	jb	SHORT $LN323@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	rsi, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN327@ZSTD_compr
$LN323@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	r14, rsi
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rbx+rsi]
	cmp	rax, QWORD PTR tv11993[rbp-256]
	jb	SHORT $LN1975@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN1975@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	rsi, QWORD PTR ip$1$[rsp]
$LN327@ZSTD_compr:
	cmp	rbx, r12
	jbe	SHORT $LN1957@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN329@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN329@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r13d
	lea	rax, QWORD PTR [rbx+rsi]
	mov	ecx, r9d
	cmp	rax, r11
	mov	r12, rbx
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1908@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN330@ZSTD_compr
$LN1957@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN330@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rsi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN332@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11848[rbp-256]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN333@ZSTD_compr
$LN332@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11848[rbp-256]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN333@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL305@ZSTD_compr
	jmp	$LN1908@ZSTD_compr
$LN124@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmp	eax, ecx
	cmovb	ecx, eax
	sub	r15d, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11984[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	eax, esi
	mov	rcx, QWORD PTR [r13+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rsi
	mov	QWORD PTR tv11983[rbp-256], rax
	add	rax, r14
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, ebx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rdx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	DWORD PTR tv11847[rbp-256], ecx
	mov	rcx, r13
	mov	DWORD PTR dictLimit$1$[rbp-256], esi
	call	ZSTD_getLowestMatchIndex
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	cmovne	eax, r14d
	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	r13d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	sub	edx, esi
	mov	QWORD PTR tv12002[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11981[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN474@ZSTD_compr
	npad	4
$LL1983@ZSTD_compr:
	xor	r8d, r8d
$LN474@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN541@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN542@ZSTD_compr
$LN541@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN542@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r9d, eax
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN479@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	SHORT $LN1986@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN1995@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN1986@ZSTD_compr:
	xor	r9d, r9d
$LN482@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, r12
	jbe	$LN1960@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r11]
	mov	DWORD PTR [rcx+4], r8d
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	ecx, r9d
	cmp	rax, r11
	mov	r12d, edx
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN472@ZSTD_compr
$LN479@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	sub	eax, r14d
	xor	edx, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1921@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1921@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN1995@ZSTD_compr
$LN1921@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN482@ZSTD_compr
$LN1960@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN472@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11981[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL1983@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11984[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1908@ZSTD_compr
	npad	7
$LL475@ZSTD_compr:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1908@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11983[rbp-256]
	jb	SHORT $LN493@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	rsi, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rsi]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN497@ZSTD_compr
$LN493@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	r14, rsi
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11983[rbp-256]
	jb	SHORT $LN1976@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN1976@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	rsi, QWORD PTR ip$1$[rsp]
$LN497@ZSTD_compr:
	cmp	rbx, r12
	jbe	SHORT $LN1959@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN499@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN499@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r13d
	lea	rax, QWORD PTR [rbx+rsi]
	mov	ecx, r9d
	cmp	rax, r11
	mov	r12, rbx
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1908@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN500@ZSTD_compr
$LN1959@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN500@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rsi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN502@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11847[rbp-256]
	jbe	$LN1709@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN503@ZSTD_compr
$LN502@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11847[rbp-256]
	jbe	$LN1710@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN503@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL475@ZSTD_compr
	jmp	$LN1908@ZSTD_compr
$LN122@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r12d
	cmp	eax, ecx
	mov	QWORD PTR base$1$[rbp-256], r14

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	sub	esi, r14d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, r12
	mov	DWORD PTR current$1$[rsp], esi
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r15d, DWORD PTR [r13+24]
	mov	ecx, DWORD PTR [r13+188]
	mov	r12, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rbx+rax*4]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r13+184]
	dec	ecx
	mov	QWORD PTR tv11974[rbp-256], rax
	mov	ebx, 1
	mov	rax, QWORD PTR [r13+16]
	shl	ebx, cl
	mov	ecx, edx
	mov	QWORD PTR dictBase$1$[rsp], rax
	dec	ebx
	lea	rax, QWORD PTR [r15+r14]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, esi
	sub	eax, ebx
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	ebx, esi
	mov	QWORD PTR bt$1$[rbp-256], r12
	mov	edx, esi
	mov	DWORD PTR btMask$1$[rsp], ebx
	cmovb	ecx, eax
	mov	QWORD PTR tv11973[rbp-256], r15
	mov	DWORD PTR tv11846[rsp], ecx
	mov	rcx, r13
	call	ZSTD_getLowestMatchIndex
	mov	r14d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r14d, r14d
	mov	eax, 1
	mov	r10d, esi
	mov	edx, esi
	cmovne	eax, r14d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	r13d, r8d
	lea	rax, QWORD PTR [r12+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	dec	eax
	mov	QWORD PTR tv12002[rbp-256], rax
	mov	r12d, eax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rbp-256]
	sub	r10d, r15d

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv11971[rbp-256], r10d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	lea	rsi, QWORD PTR [rcx+rax*4]
$LL134@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN201@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN202@ZSTD_compr
$LN201@ZSTD_compr:
	mov	eax, DWORD PTR [rsi]
$LN202@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, r10d
	jae	SHORT $LN139@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rcx, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r10d, eax
	neg	r10

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rcx]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10+rcx]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r9d, r14d
	setae	al
	test	ecx, eax
	je	$LN1978@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r10
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2006@ZSTD_compr
$LN139@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, edx
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rsp]
	sub	eax, r14d
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, r15d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1978@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r9, QWORD PTR ip$1$[rsp]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	mov	ecx, DWORD PTR [r9]
	shl	ecx, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN142@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dictBase$1$[rsp]
	lea	rdx, QWORD PTR [r10+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	add	r9, r15
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2006@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR lastR$1$[rbp-256]
$LN1978@ZSTD_compr:
	mov	r9, QWORD PTR ip$1$[rsp]
$LN142@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r12
	jbe	SHORT $LN132@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	DWORD PTR [rcx], eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r13d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+r9]
	mov	DWORD PTR [rcx+4], r8d
	mov	r12d, edx
	xor	edx, edx
	cmp	rax, r10
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN131@ZSTD_compr
$LN132@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	ebx
	add	rsi, 4
	cmp	ebx, r11d
	jae	SHORT $LN1880@ZSTD_compr
	mov	edx, DWORD PTR current$1$[rsp]
	xor	r8d, r8d
	mov	r10d, DWORD PTR tv11971[rbp-256]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL134@ZSTD_compr
$LN1880@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r12, 3
	jae	$LN1923@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r14, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$7[rbp-256]
	mov	rcx, r14
	mov	r8, r9
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r9d
	mov	ecx, r9d
	mov	ebx, esi
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1962@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	mov	ecx, eax
	cmp	eax, r15d
	jb	SHORT $LN148@ZSTD_compr

; 615  :                 const BYTE* const match = base + matchIndex3;

	mov	rdx, QWORD PTR base$1$[rbp-256]

; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	add	rdx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	call	ZSTD_count

; 617  :             } else {

	jmp	SHORT $LN1996@ZSTD_compr
$LN148@ZSTD_compr:

; 618  :                 const BYTE* const match = dictBase + matchIndex3;

	mov	r8, QWORD PTR dictBase$1$[rsp]

; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rcx+r8]
	mov	rcx, QWORD PTR ip$1$[rsp]
	lea	r9, QWORD PTR [r8+r15]
	mov	r8, QWORD PTR iend$1$[rsp]
	call	ZSTD_count_2segments
$LN1996@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r11, QWORD PTR ip$1$[rsp]
	xor	r9d, r9d
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r8, rax
	cmp	rax, 3
	jb	SHORT $LN1928@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rax
	lea	eax, DWORD PTR [rbx+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;

	mov	r13d, 1

; 632  :                 if ( (mlen > sufficient_len) |

	mov	edx, r9d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [r12+r11]
	cmp	rax, r10
	mov	DWORD PTR [rcx+4], r8d
	mov	eax, DWORD PTR sufficient_len$1$[rsp]
	mov	ecx, r9d
	sete	dl
	cmp	r12, rax
	seta	cl
	or	edx, ecx
	je	SHORT $LN1928@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [rsi+1]

; 635  :                     return 1;

	mov	r13d, 1
	mov	DWORD PTR [r14+36], eax
	jmp	$LN131@ZSTD_compr
$LN1923@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1997@ZSTD_compr
$LN1928@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN152@ZSTD_compr
$LN1962@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR iend$1$[rsp]
$LN1997@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r11, QWORD PTR ip$1$[rsp]
$LN152@ZSTD_compr:
	mov	rax, QWORD PTR tv11974[rbp-256]
	mov	DWORD PTR [rax], esi

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1927@ZSTD_compr
	npad	13
$LL135@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	edi, r8d
	jb	$LN1926@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r9, QWORD PTR tv11973[rbp-256]
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [rsi+rbx]
	lea	rcx, QWORD PTR [rbx+r11]
	cmp	rax, r9
	jb	SHORT $LN153@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14, QWORD PTR base$1$[rbp-256]

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	add	r14, rsi
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {

	jmp	SHORT $LN157@ZSTD_compr
$LN153@ZSTD_compr:

; 654  :             match = dictBase + matchIndex;

	mov	r8, QWORD PTR dictBase$1$[rsp]

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	r9, r8
	mov	QWORD PTR [rsp+32], rax
	lea	r14, QWORD PTR [rsi+r8]
	mov	r8, r10
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv11973[rbp-256]
	jb	SHORT $LN157@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, rsi
$LN157@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1961@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN159@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN159@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r12, rbx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r13*8]
	mov	r10, QWORD PTR iend$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	inc	r13d
	mov	DWORD PTR [rcx+4], edx
	xor	edx, edx
	lea	rax, QWORD PTR [rbx+r9]
	mov	ecx, edx
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1926@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN160@ZSTD_compr
$LN1961@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r9, QWORD PTR ip$1$[rsp]
$LN160@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN162@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11846[rsp]
	jbe	SHORT $LN1721@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN163@ZSTD_compr
$LN162@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11846[rsp]
	jbe	SHORT $LN1722@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN163@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	SHORT $LN1926@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
	jmp	$LL135@ZSTD_compr
$LN1721@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$15[rbp-256]
	xor	r9d, r9d
	jmp	SHORT $LN1749@ZSTD_compr
$LN1722@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$15[rbp-256]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1926@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	xor	r9d, r9d
$LN1927@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1749@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
$LN1993@ZSTD_compr:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR ms$[rbp-256]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN131@ZSTD_compr:
	test	r13d, r13d
	je	$LN1979@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	rcx, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */

	xor	r15d, r15d
	mov	rsi, QWORD PTR rep$[rbp-256]

; 841  :             opt[0].litlen = litlen;
; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	rdi, QWORD PTR optStatePtr$1$[rbp-256]
	mov	rdx, rdi
	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [rcx+16], eax
	mov	eax, DWORD PTR [rsi+4]
	mov	DWORD PTR [rcx+20], eax
	mov	eax, DWORD PTR [rsi+8]
	mov	DWORD PTR [rcx+24], eax
	mov	DWORD PTR [rcx+8], r15d
	mov	DWORD PTR [rcx+12], ebx
	mov	ecx, ebx
	call	ZSTD_litLengthPrice
	mov	r10, QWORD PTR opt$1$[rbp-256]

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r14, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [r10], eax
	lea	eax, DWORD PTR [r13-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r14+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	SHORT $LN35@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;

	mov	DWORD PTR lastSequence$8[rbp-248], eax

; 858  :                     lastSequence.off = maxOffset;

	mov	eax, DWORD PTR [r14+rcx*8]

; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	r14d, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$8[rbp-252], eax
	mov	DWORD PTR lastSequence$8[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$8[rbp-256]
	jmp	$LN1998@ZSTD_compr
$LN35@ZSTD_compr:

; 864  :             }   }
; 865  : 
; 866  :             /* set prices for first matches starting position == 0 */
; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	rdx, rdi
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	r10, QWORD PTR opt$1$[rbp-256]
	mov	rdx, QWORD PTR tv12002[rbp-256]
	mov	rcx, rdx
	mov	esi, DWORD PTR [r10]
	add	esi, eax
	lea	ebx, DWORD PTR [rdx+1]
	lea	rax, QWORD PTR [r10+28]
	npad	5
$LL11@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rax], 1073741824		; 40000000H
	lea	rax, QWORD PTR [rax+28]
	sub	rcx, 1
	jne	SHORT $LL11@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	r13d, r13d
	je	$LN13@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r14
	mov	QWORD PTR tv12038[rbp-256], r13
	mov	QWORD PTR tv11860[rbp-256], rax
	npad	12
$LL14@ZSTD_compr:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [rax+4]
	mov	r14d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	ebx, r15d
	ja	$LN12@ZSTD_compr
	mov	r13d, DWORD PTR litlen$1$[rbp-256]
	lea	r12d, DWORD PTR [r14+1]
	xor	r11d, r11d
	npad	5
$LL17@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	r8d, r11d
	mov	DWORD PTR r$16[rbp-256], r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	DWORD PTR r$14[rbp-256], r11d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rdi+80], 1
	jne	SHORT $LN856@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	lea	eax, DWORD PTR [rbx-2]
	bsr	ecx, eax
	mov	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	edx, DWORD PTR [r8+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	edx, eax
	shl	edx, 8
	add	edx, esi
	jmp	$LN855@ZSTD_compr
$LN856@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rdi+24]
	mov	edx, r8d
	mov	edi, DWORD PTR [rdi+76]
	mov	eax, DWORD PTR [rax+r8*4]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	edx, eax
	shl	edx, 8
	add	edi, edx

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r8d, 20
	jb	SHORT $LN857@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r8d, 9
	add	edi, -9728				; ffffda00H
	add	edi, r8d
$LN857@ZSTD_compr:

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rbx-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r8, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r11d, r11d
	mov	r10, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	mov	eax, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$13[rbp-256], r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r8+16]
	mov	eax, DWORD PTR [rdx+rax]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 283  :     return price;

	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdx+rcx]
	lea	edx, DWORD PTR [rsi+51]
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, DWORD PTR [r8+72]
	add	ecx, edi
	mov	rdi, r8
	add	edx, ecx
$LN855@ZSTD_compr:

; 881  :                         opt[pos].mlen = pos;

	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+r10+8], ebx
	inc	ebx

; 882  :                         opt[pos].off = offset;

	mov	DWORD PTR [rcx+r10+4], r14d

; 883  :                         opt[pos].litlen = litlen;

	mov	DWORD PTR [rcx+r10+12], r13d

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+r10], edx
	cmp	ebx, r15d
	jbe	$LL17@ZSTD_compr
	mov	rax, QWORD PTR tv11860[rbp-256]
	mov	r13, QWORD PTR tv12038[rbp-256]
$LN12@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	r13, 1
	mov	QWORD PTR tv11860[rbp-256], rax
	mov	QWORD PTR tv12038[rbp-256], r13
	jne	$LL14@ZSTD_compr
$LN13@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;
; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r9d, 1
	dec	ebx
	mov	DWORD PTR cur$1$[rbp-256], r9d
	cmp	ebx, r9d
	jb	$LN1887@ZSTD_compr
	npad	8
$LL20@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r15d, DWORD PTR [r9-1]
	imul	rdi, r15, 28
	mov	r12d, r9d
	add	rsi, r12
	add	rdi, r10
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN57@ZSTD_compr
	mov	r14d, DWORD PTR [rdi+12]
	inc	r14d
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	r14d, 1
$LN58@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	mov	r13, QWORD PTR optStatePtr$1$[rbp-256]
	lea	ecx, DWORD PTR [r14-1]
	mov	rdx, r13
	xor	r8d, r8d
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	xor	r9d, r9d
	mov	r8, r13
	sub	edi, eax
	lea	edx, QWORD PTR [r9+1]
	call	ZSTD_rawLiteralsCost
	xor	r8d, r8d
	mov	rdx, r13
	mov	ecx, r14d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	add	eax, edi
	imul	rdi, r12, 28
	xor	r12d, r12d
	add	rdi, r10
	cmp	eax, DWORD PTR [rdi]
	jg	SHORT $LN1870@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [rdi+4], r12

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [rdi+12], r14d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [rdi], eax
$LN1870@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [rdi+8]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;

	mov	eax, DWORD PTR cur$1$[rbp-256]

; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	lea	rdx, QWORD PTR [r10+16]
	cmp	DWORD PTR [rdi+12], 0
	mov	r9d, r12d
	mov	r8d, DWORD PTR [rdi+4]
	sete	r9b
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));
; 929  :             } else {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rdi+16], xmm0
	mov	DWORD PTR [rdi+24], ecx
	jmp	SHORT $LN39@ZSTD_compr
$LN38@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r15, 28
	movsd	xmm0, QWORD PTR [rax+r10+16]
	mov	eax, DWORD PTR [rax+r10+24]
	movsd	QWORD PTR [rdi+16], xmm0
	mov	DWORD PTR [rdi+24], eax
$LN39@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	mov	r9d, DWORD PTR cur$1$[rbp-256]
	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r9d, ebx
	je	$LN1887@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {

	mov	r14d, DWORD PTR [rdi]
	lea	ecx, DWORD PTR [r9+1]
	imul	rdx, rcx, 28
	lea	eax, DWORD PTR [r14+128]
	cmp	DWORD PTR [rdx+r10], eax
	jle	$LN18@ZSTD_compr

; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [rdi+8]
	mov	ecx, r12d
	test	eax, eax
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_compr
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN60@ZSTD_compr
$LN59@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], r12d
$LN60@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;
; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	xor	r8d, r8d
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	r13, QWORD PTR ms$[rbp-256]

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	rdi, 16
	add	eax, r14d
	mov	QWORD PTR rep$1$[rsp], rdi
	mov	DWORD PTR basePrice$1$[rbp-256], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	edi, DWORD PTR [r13+36]
	mov	r12, QWORD PTR [r13+8]
	mov	r15d, DWORD PTR [r13+200]
	lea	rcx, QWORD PTR [r12+rdi]
	cmp	rsi, rcx
	jb	$LN1971@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN933@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	npad	6
$LL932@ZSTD_compr:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], 1
	mov	r8, rsi
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL932@ZSTD_compr
	mov	rsi, QWORD PTR inr$1$[rbp-256]
$LN933@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	r12, QWORD PTR [r13+8]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r13+36], r14d

; 756  :     switch(matchLengthSearch)

	cmp	r15d, 3
	je	$LN926@ZSTD_compr
	cmp	r15d, 5
	je	$LN928@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r13+204]
	ja	$LN927@ZSTD_compr

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [r13+192]
	cmp	eax, ecx
	mov	rdi, QWORD PTR [r13+48]
	mov	r15d, esi
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r12
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	r15d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	mov	r8d, 6
	call	ZSTD_hashPtr

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	mov	ecx, DWORD PTR [r9+188]
	mov	edi, 1

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	edi
	mov	QWORD PTR tv11957[rbp-256], rax
	mov	eax, DWORD PTR [r9+24]
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rax
	mov	DWORD PTR dictLimit$1$[rsp], eax
	mov	QWORD PTR tv11956[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	edi, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	edx, r15d
	mov	DWORD PTR btMask$1$[rsp], edi
	cmovb	ecx, eax
	mov	DWORD PTR tv11845[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r15d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r11d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv12002[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11954[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1448@ZSTD_compr
$LL1988@ZSTD_compr:
	xor	r8d, r8d
$LN1448@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1515@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1516@ZSTD_compr
$LN1515@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1516@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, edx
	jae	SHORT $LN1453@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r10d, eax
	neg	r10
	cmp	r9d, r12d
	setae	cl
	xor	r9d, r9d
	cmp	edx, DWORD PTR [rsi+r10]
	mov	eax, r9d
	sete	al
	test	ecx, eax
	je	SHORT $LN1456@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN1999@ZSTD_compr
$LN1453@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	ecx, eax
	mov	ecx, r11d
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1456@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1456@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN1999@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	xor	r9d, r9d
$LN1456@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1446@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r10
	mov	QWORD PTR bestLength$1$[rsp], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1446@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11954[rsp]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rsp]
	add	r15, 4
	cmp	edi, r13d
	jb	$LL1988@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11957[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1933@ZSTD_compr
	npad	6
$LL1449@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1933@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [r15+rdi]
	lea	rcx, QWORD PTR [rsi+rdi]
	cmp	rax, QWORD PTR tv11956[rbp-256]
	jb	SHORT $LN1467@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	SHORT $LN1471@ZSTD_compr
$LN1467@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r12, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r12, r15
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r15+rdi]
	cmp	rax, QWORD PTR tv11956[rbp-256]
	jb	SHORT $LN1471@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN1471@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1966@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1473@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1473@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1933@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1474@ZSTD_compr
$LN1966@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN1474@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN1476@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11845[rsp]
	jbe	SHORT $LN1725@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1477@ZSTD_compr
$LN1476@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11845[rsp]
	jbe	SHORT $LN1726@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN1477@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	jne	$LL1449@ZSTD_compr
	jmp	SHORT $LN1933@ZSTD_compr
$LN1725@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	lea	rax, QWORD PTR dummy32$1[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2000@ZSTD_compr
$LN1726@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$1[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
$LN1933@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2000@ZSTD_compr
$LN927@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 521  :     const BYTE* const base = ms->window.base;

	mov	QWORD PTR base$1$[rbp-256], r12

; 522  :     U32 const current = (U32)(ip-base);

	mov	r13d, esi

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	r13d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r13d
	mov	edx, DWORD PTR [rax+192]
	mov	rdi, QWORD PTR [rax+48]
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r15d, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	edi
	mov	QWORD PTR tv11947[rbp-256], rax
	mov	rax, QWORD PTR [r9+64]
	mov	QWORD PTR bt$1$[rbp-256], rax
	mov	eax, r15d
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, r15
	mov	QWORD PTR tv11946[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	edx, r13d
	mov	eax, r13d
	mov	DWORD PTR btMask$1$[rsp], edi
	sub	eax, edi
	mov	DWORD PTR dictLimit$1$[rsp], r15d
	cmp	edi, r13d
	cmovb	ecx, eax
	mov	DWORD PTR tv11844[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r10d, DWORD PTR current$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r10d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r13d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	mov	rax, QWORD PTR bt$1$[rbp-256]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r15d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv12002[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11944[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1108@ZSTD_compr
$LL1989@ZSTD_compr:
	xor	r8d, r8d
$LN1108@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1175@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1176@ZSTD_compr
$LN1175@ZSTD_compr:
	mov	ecx, DWORD PTR [r15]
$LN1176@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r10d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r9d, ecx
	cmp	r11d, edx
	jae	$LN1113@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	r11d, r11d
	mov	edx, ecx
	mov	ecx, r11d
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	mov	eax, r11d
	sete	cl
	cmp	r9d, r12d
	setae	al
	test	ecx, eax
	je	SHORT $LN1991@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN2001@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR current$1$[rsp]
$LN1991@ZSTD_compr:
	xor	r9d, r9d
$LN1116@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1106@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r11
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1106@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11944[rbp-256]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rsp]
	add	r15, 4
	cmp	edi, r13d
	jb	$LL1989@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11947[rbp-256]
	mov	DWORD PTR [rax], r10d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1937@ZSTD_compr
	npad	7
$LL1109@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1937@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [r15+rdi]
	lea	rcx, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR tv11946[rbp-256]
	jb	$LN1127@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	$LN1131@ZSTD_compr
$LN1113@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	mov	ecx, DWORD PTR dictLimit$1$[rsp]
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1947@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1947@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN2001@ZSTD_compr
$LN1947@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR current$1$[rsp]
	jmp	$LN1116@ZSTD_compr
$LN1127@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r12, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r12, r15
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r15+rdi]
	cmp	rax, QWORD PTR tv11946[rbp-256]
	jb	SHORT $LN1131@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN1131@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1964@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1133@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1133@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r11
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1937@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1134@ZSTD_compr
$LN1964@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN1134@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN1136@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11844[rsp]
	jbe	SHORT $LN1729@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1137@ZSTD_compr
$LN1136@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11844[rsp]
	jbe	SHORT $LN1730@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rsp], r13
$LN1137@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	jne	$LL1109@ZSTD_compr
	jmp	SHORT $LN1937@ZSTD_compr
$LN1729@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$3[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2000@ZSTD_compr
$LN1730@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$3[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1937@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2000@ZSTD_compr
$LN928@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [r13+192]
	cmp	eax, ecx
	mov	rdi, QWORD PTR [r13+48]
	mov	r8d, 5
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r12
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	sub	r15d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	mov	ecx, DWORD PTR [r9+188]
	mov	edi, 1

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	edi, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	edi
	mov	QWORD PTR tv11937[rbp-256], rax
	mov	eax, DWORD PTR [r9+24]
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, rax
	mov	DWORD PTR dictLimit$1$[rsp], eax
	mov	QWORD PTR tv11936[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, edi
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	cmp	edi, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	edx, r15d
	mov	DWORD PTR btMask$1$[rsp], edi
	cmovb	ecx, eax
	mov	DWORD PTR tv11843[rsp], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r15d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r11d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv12002[rbp-256]
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11934[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1278@ZSTD_compr
$LL1990@ZSTD_compr:
	xor	r8d, r8d
$LN1278@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1345@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1346@ZSTD_compr
$LN1345@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1346@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, edx
	jae	SHORT $LN1283@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r10d, eax
	neg	r10
	cmp	r9d, r12d
	setae	cl
	xor	r9d, r9d
	cmp	edx, DWORD PTR [r10+rsi]
	mov	eax, r9d
	sete	al
	test	ecx, eax
	je	SHORT $LN1286@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2002@ZSTD_compr
$LN1283@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	ecx, eax
	mov	ecx, r11d
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN1286@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN1286@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2002@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	xor	r9d, r9d
$LN1286@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1276@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r10
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr
$LN1276@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11934[rbp-256]
	inc	edi
	mov	rcx, QWORD PTR rep$1$[rsp]
	add	r15, 4
	cmp	edi, r13d
	jb	$LL1990@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11937[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1941@ZSTD_compr
	npad	6
$LL1279@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1941@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [rdi+r15]
	lea	rcx, QWORD PTR [rdi+rsi]
	cmp	rax, QWORD PTR tv11936[rbp-256]
	jb	SHORT $LN1297@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	SHORT $LN1301@ZSTD_compr
$LN1297@ZSTD_compr:

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r12, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r12, r15
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rdi+r15]
	cmp	rax, QWORD PTR tv11936[rbp-256]
	jb	SHORT $LN1301@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN1301@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1968@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1303@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1303@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rbp-256], rdi
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1941@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1304@ZSTD_compr
$LN1968@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN1304@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN1306@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11843[rsp]
	jbe	SHORT $LN1733@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN1307@ZSTD_compr
$LN1306@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11843[rsp]
	jbe	SHORT $LN1734@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rsp], r13
$LN1307@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	jne	$LL1279@ZSTD_compr
	jmp	SHORT $LN1941@ZSTD_compr
$LN1733@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR dummy32$2[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN2000@ZSTD_compr
$LN1734@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$2[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], rax
$LN1941@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN2000@ZSTD_compr
$LN926@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r13+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [r13+192]
	cmp	eax, ecx
	mov	rdi, QWORD PTR [r13+48]
	mov	r8d, 3
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r12
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	sub	r15d, r12d
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	r9, QWORD PTR ms$[rbp-256]

; 530  :     U32 const btMask= (1U << btLog) - 1;
; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r8d, r8d
	mov	r14d, DWORD PTR [rdi+rax*4]
	mov	r13, QWORD PTR [r13+64]
	lea	rax, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r8

; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	edx, DWORD PTR [r9+24]
	mov	edi, 1
	mov	ecx, DWORD PTR [r9+188]
	dec	ecx
	mov	QWORD PTR tv11927[rbp-256], rax
	mov	rax, QWORD PTR [r9+16]
	shl	edi, cl

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	ecx, r8d
	mov	QWORD PTR dictBase$1$[rbp-256], rax
	dec	edi
	lea	rax, QWORD PTR [r12+rdx]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r8
	mov	r8d, DWORD PTR [r9+184]
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, r15d
	sub	eax, edi
	mov	DWORD PTR dictLimit$1$[rsp], edx
	mov	QWORD PTR tv11926[rbp-256], rdx
	cmp	edi, r15d
	mov	edx, r15d
	mov	QWORD PTR bt$1$[rbp-256], r13
	cmovb	ecx, eax
	mov	DWORD PTR btMask$1$[rbp-256], edi
	mov	DWORD PTR tv11842[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, edi
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r15d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r12d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	mov	eax, 1
	shl	eax, cl
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, r11d
	mov	DWORD PTR nbCompares$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv12002[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, eax
	mov	DWORD PTR tv11924[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r13d, DWORD PTR [rax+3]
	lea	r15, QWORD PTR [rcx+rax*4]
$LL938@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	edi, 3
	jne	SHORT $LN1005@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1006@ZSTD_compr
$LN1005@ZSTD_compr:
	mov	eax, DWORD PTR [r15]
$LN1006@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	cmp	ecx, edx
	jae	SHORT $LN943@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	mov	r10d, eax
	neg	r10

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [rsi+r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r9d, r12d
	setae	al
	test	ecx, eax
	je	$LN946@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	SHORT $LN2003@ZSTD_compr
$LN943@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	mov	r10d, r9d
	add	r10, QWORD PTR dictBase$1$[rbp-256]
	cmp	ecx, eax
	mov	ecx, r11d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN946@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [rsi]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN946@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+3]
	mov	r9, QWORD PTR dictBase$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+3]
	add	r9, QWORD PTR tv11926[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2003@ZSTD_compr:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
$LN946@ZSTD_compr:
	mov	r9, QWORD PTR bestLength$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r9
	jbe	SHORT $LN1954@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, edi
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	r9d, edx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r10d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [rdx+rsi]
	mov	DWORD PTR [rcx+4], r8d
	mov	QWORD PTR bestLength$1$[rsp], rdx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN935@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN936@ZSTD_compr
$LN1954@ZSTD_compr:
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
$LN936@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	edi
	add	r15, 4
	cmp	edi, r13d
	jae	SHORT $LN1885@ZSTD_compr
	mov	edx, DWORD PTR tv11924[rsp]
	xor	r8d, r8d
	mov	rcx, QWORD PTR rep$1$[rsp]
	jmp	$LL938@ZSTD_compr
$LN1885@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r9, 3
	jae	$LN1946@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r13, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$7[rbp-256]
	mov	rcx, r13
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r9d
	mov	ecx, r9d
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1953@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	mov	ecx, eax
	cmp	eax, DWORD PTR dictLimit$1$[rsp]
	jb	SHORT $LN952@ZSTD_compr

; 615  :                 const BYTE* const match = base + matchIndex3;

	mov	rdx, QWORD PTR base$1$[rbp-256]

; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	add	rdx, rcx
	mov	rcx, rsi
	call	ZSTD_count

; 617  :             } else {

	jmp	SHORT $LN2004@ZSTD_compr
$LN952@ZSTD_compr:

; 618  :                 const BYTE* const match = dictBase + matchIndex3;

	mov	r8, QWORD PTR dictBase$1$[rbp-256]

; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r9, QWORD PTR tv11926[rbp-256]
	add	r9, r8
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r8+rcx]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	call	ZSTD_count_2segments
$LN2004@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
	mov	r8, rax
	cmp	rax, 3
	jb	SHORT $LN1949@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 632  :                 if ( (mlen > sufficient_len) |

	mov	edx, r9d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	r10d, 1
	lea	eax, DWORD PTR [rdi+2]
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [r8+rsi]
	cmp	rax, r11
	mov	DWORD PTR [rcx+4], r8d
	mov	eax, DWORD PTR sufficient_len$1$[rsp]
	mov	ecx, r9d
	sete	dl
	cmp	r8, rax
	seta	cl
	or	edx, ecx
	je	SHORT $LN1950@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	DWORD PTR [r13+36], eax
	jmp	$LN935@ZSTD_compr
$LN1946@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN2005@ZSTD_compr
$LN1949@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	jmp	SHORT $LN956@ZSTD_compr
$LN1950@ZSTD_compr:

; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN956@ZSTD_compr
$LN1953@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
$LN2005@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r11, QWORD PTR iend$1$[rsp]
$LN956@ZSTD_compr:
	mov	rax, QWORD PTR tv11927[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	$LN1945@ZSTD_compr
	npad	1
$LL939@ZSTD_compr:
	dec	eax
	mov	DWORD PTR nbCompares$1$[rsp], eax
	cmp	r14d, r8d
	jb	$LN1945@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	r8, QWORD PTR tv11926[rbp-256]
	add	eax, eax
	mov	r15d, r14d
	lea	r13, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	lea	rax, QWORD PTR [rdi+r15]
	lea	rcx, QWORD PTR [rdi+rsi]
	cmp	rax, r8
	jb	SHORT $LN957@ZSTD_compr

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r12, QWORD PTR base$1$[rbp-256]

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r11
	add	r12, r15
	lea	rdx, QWORD PTR [r12+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {

	jmp	SHORT $LN961@ZSTD_compr
$LN957@ZSTD_compr:

; 654  :             match = dictBase + matchIndex;

	mov	r9, QWORD PTR dictBase$1$[rbp-256]

; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	r12, QWORD PTR [r9+r15]
	add	r9, r8
	lea	rdx, QWORD PTR [r12+rdi]
	mov	r8, r11
	call	ZSTD_count_2segments
	add	rdi, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rdi+r15]
	cmp	rax, QWORD PTR tv11926[rbp-256]
	jb	SHORT $LN961@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r15
$LN961@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1952@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN963@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN963@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r10*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r10d
	lea	rax, QWORD PTR [rdi+rsi]
	mov	QWORD PTR bestLength$1$[rsp], rdi
	cmp	rax, r11
	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1945@ZSTD_compr

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN964@ZSTD_compr
$LN1952@ZSTD_compr:
	mov	r10d, DWORD PTR nbMatches$1$[rbp-256]
	xor	r9d, r9d
	mov	r11, QWORD PTR iend$1$[rsp]
$LN964@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r12+rdi], al
	jae	SHORT $LN966@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11842[rbp-256]
	jbe	SHORT $LN1737@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN967@ZSTD_compr
$LN966@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11842[rbp-256]
	jbe	SHORT $LN1738@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN967@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	eax, DWORD PTR nbCompares$1$[rsp]
	test	eax, eax
	je	SHORT $LN1945@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL939@ZSTD_compr
$LN1737@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$11[rbp-256]
	jmp	SHORT $LN1762@ZSTD_compr
$LN1738@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$11[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
$LN1945@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN1762@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r10d
$LN2000@ZSTD_compr:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR ms$[rbp-256]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN935@ZSTD_compr:
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rbp-256]
	test	r8d, r8d
	je	$LN18@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r14, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]
	mov	edx, eax
	mov	ecx, DWORD PTR [r14+rax*8+4]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1740@ZSTD_compr
	lea	eax, DWORD PTR [rcx+r9]
	cmp	eax, 4096				; 00001000H
	jae	$LN1740@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r11d, r11d
	mov	eax, r11d
	mov	DWORD PTR matchNb$1$[rsp], eax
	test	r8d, r8d
	je	$LN18@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rcx, r14
	mov	QWORD PTR tv11851[rbp-256], rcx
	npad	6
$LL23@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	r13d, DWORD PTR [rcx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rcx+4]

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	eax, eax
	je	SHORT $LN63@ZSTD_compr
	mov	rcx, QWORD PTR tv11851[rbp-256]
	dec	eax
	mov	r12d, DWORD PTR [r14+rax*8+4]
	mov	eax, DWORD PTR matchNb$1$[rsp]
	inc	r12d
	jmp	SHORT $LN64@ZSTD_compr
$LN63@ZSTD_compr:
	mov	r12d, DWORD PTR minMatch$1$[rbp-256]
$LN64@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	cmp	edx, r12d
	jb	$LN21@ZSTD_compr
	mov	r10, QWORD PTR optStatePtr$1$[rbp-256]
	lea	eax, DWORD PTR [r13+1]
	mov	r15d, r9d
	lea	edi, DWORD PTR [rdx+r9]
	neg	r15d
	npad	3
$LL26@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	r8d, r11d
	mov	DWORD PTR r$6[rsp], r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r14d, DWORD PTR [r15+rdi]

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	DWORD PTR r$5[rsp], r11d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [r10+80], 1
	jne	SHORT $LN1618@ZSTD_compr

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	lea	eax, DWORD PTR [r14-2]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r8+16]
	add	ecx, eax
	shl	ecx, 8
	jmp	SHORT $LN1617@ZSTD_compr
$LN1618@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [r10+24]
	mov	esi, r8d
	mov	eax, DWORD PTR [rax+r8*4]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	esi, eax
	shl	esi, 8
	add	esi, DWORD PTR [r10+76]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r8d, 20
	jb	SHORT $LN1619@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r8d, 9
	add	esi, -9728				; ffffda00H
	add	esi, r8d
$LN1619@ZSTD_compr:

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r14-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r10, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r11d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	mov	eax, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$4[rsp], r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r10+16]
	mov	eax, DWORD PTR [rdx+rax]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdx+rcx]
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, 51					; 00000033H
	add	ecx, DWORD PTR [r10+72]
	add	ecx, esi
$LN1617@ZSTD_compr:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]
	add	edx, ecx

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	cmp	edi, ebx
	ja	SHORT $LN1900@ZSTD_compr
	mov	eax, edi
	imul	rcx, rax, 28
	mov	rax, QWORD PTR opt$1$[rbp-256]
	cmp	edx, DWORD PTR [rcx+rax]
	jge	SHORT $LN1904@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	jmp	SHORT $LN28@ZSTD_compr
$LN1900@ZSTD_compr:
	mov	r14, QWORD PTR opt$1$[rbp-256]
$LL27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+r14], 1073741824		; 40000000H
	cmp	ebx, edi
	jb	SHORT $LL27@ZSTD_compr
	lea	r14d, DWORD PTR [r15+rdi]
$LN28@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;
; 989  :                             opt[pos].off = offset;
; 990  :                             opt[pos].litlen = litlen;

	mov	r8d, DWORD PTR litlen$1$[rbp-256]
	mov	eax, edi
	dec	edi
	imul	rcx, rax, 28
	mov	rax, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR [rcx+rax+8], r14d
	mov	DWORD PTR [rcx+rax+4], r13d
	mov	DWORD PTR [rcx+rax+12], r8d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rax], edx
	lea	eax, DWORD PTR [r15+rdi]
	cmp	eax, r12d
	lea	eax, DWORD PTR [r13+1]
	jae	$LL26@ZSTD_compr
$LN1904@ZSTD_compr:
	mov	eax, DWORD PTR matchNb$1$[rsp]
	mov	rcx, QWORD PTR tv11851[rbp-256]
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rbp-256]
	mov	r14, QWORD PTR matches$1$[rbp-256]
$LN21@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	inc	eax
	add	rcx, 8
	mov	DWORD PTR matchNb$1$[rsp], eax
	mov	QWORD PTR tv11851[rbp-256], rcx
	cmp	eax, r8d
	jb	$LL23@ZSTD_compr

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	jmp	SHORT $LN18@ZSTD_compr
$LN1971@ZSTD_compr:
	mov	r9d, DWORD PTR cur$1$[rbp-256]
$LN18@ZSTD_compr:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	inc	r9d
	mov	DWORD PTR cur$1$[rbp-256], r9d
	cmp	r9d, ebx
	jbe	$LL20@ZSTD_compr
$LN1887@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	rsi, QWORD PTR rep$[rbp-256]
	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+r10]
	mov	r14d, DWORD PTR [rdx+r10+24]
	movsd	xmm0, QWORD PTR [rdx+r10+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$8[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], r14d

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	SHORT $LN65@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r15d, r15d
	jmp	SHORT $_shortestPath$2009
$LN1740@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r14+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r15d, r15d
	mov	r10, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$8[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$8[rbp-244], eax
	mov	eax, r9d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$8[rbp-248], ecx
	cmp	DWORD PTR [rax+r10+8], r15d
	jne	SHORT $LN61@ZSTD_compr
	mov	eax, DWORD PTR [rax+r10+12]
	jmp	SHORT $LN62@ZSTD_compr
$LN61@ZSTD_compr:
	mov	eax, r15d
$LN62@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$8[rbp-256]
	mov	rsi, QWORD PTR rep$[rbp-256]
	sub	r9d, eax
	mov	r14d, DWORD PTR lastSequence$5$[rbp-256]
	cmp	r9d, 4096				; 00001000H
	mov	ebx, r15d
	cmovbe	ebx, r9d
	jmp	SHORT $_shortestPath$2009
$LN65@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	xor	r15d, r15d
$LN1998@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	mov	ebx, r15d
$_shortestPath$2009:
	mov	eax, ebx
	lea	rdx, QWORD PTR [r10+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$8[rbp-248], 0
	je	SHORT $LN51@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T10[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r15d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));
; 1014 :         } else {

	mov	r10, QWORD PTR opt$1$[rbp-256]
	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [rsi], xmm0
	mov	DWORD PTR [rsi+8], ecx
	jmp	SHORT $LN52@ZSTD_compr
$LN51@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rsi+8], eax
$LN52@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	movups	xmm0, XMMWORD PTR lastSequence$8[rbp-256]
	lea	r13d, DWORD PTR [rbx+1]
	mov	eax, r13d
	mov	edi, r13d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r10], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r10+16], xmm0
	mov	DWORD PTR [rcx+r10+24], r14d

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_compr
$LL29@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r10
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r10], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r10+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r10+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r15d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_compr
$LN30@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r13d
	ja	$LN1980@ZSTD_compr
	mov	r11, QWORD PTR src$[rbp-256]
$LL33@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	mov	r12, r11
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r10+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r10+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r10+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	je	$LN31@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
; 1051 :                         continue;   /* will finish */
; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	r9d, r14d
	mov	r8, r11
	mov	DWORD PTR [rsp+32], esi
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+r11]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1654@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r11]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1655@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r11+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
$LL1668@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1668@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1655@ZSTD_compr
$LN1654@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r11
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
	mov	r11, QWORD PTR src$[rbp-256]
$LN1655@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1813@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN1813@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1872@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN1872@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	ebx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
	mov	r10, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	add	r11, rbx
	mov	QWORD PTR src$[rbp-256], r11
$LN31@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	add	r12, rbx
	inc	edi
	mov	QWORD PTR ip$1$[rsp], r12
	cmp	edi, r13d
	jbe	$LL33@ZSTD_compr

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	xor	edx, edx
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1980@ZSTD_compr:
	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	xor	edx, edx
	mov	r12, QWORD PTR ip$1$[rsp]
	call	ZSTD_setBasePrices
	jmp	SHORT $LN1769@ZSTD_compr
$LN1979@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r12, QWORD PTR ip$1$[rsp]
$LN1849@ZSTD_compr:
	inc	r12
	mov	QWORD PTR ip$1$[rsp], r12
$LN1769@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r14d, 0
	mov	r15, QWORD PTR iend$1$[rsp]
	mov	r13, QWORD PTR ms$[rbp-256]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r12, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL4@ZSTD_compr
$LN5@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r15, rdi

; 1188 :     return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0 /*optLevel*/, ZSTD_extDict);

	mov	rax, r15

; 1189 : }

	add	rsp, 424				; 000001a8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_btopt_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_64bits PROC

; 184  : MEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }

	mov	eax, 1
	ret	0
MEM_64bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readST PROC

; 254  :     size_t val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 255  : }

	ret	0
MEM_readST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
statePtr$ = 8
ct$ = 16
FSE_initCState PROC

; 490  :     const void* ptr = ct;
; 491  :     const U16* u16ptr = (const U16*) ptr;
; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	r10d, WORD PTR [rdx]
	mov	r9, rcx

; 493  :     statePtr->value = (ptrdiff_t)1<<tableLog;

	mov	r8d, 1
	mov	ecx, r10d
	mov	eax, r8d
	shl	rax, cl
	mov	QWORD PTR [r9], rax

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rax, QWORD PTR [rdx+4]
	mov	QWORD PTR [r9+8], rax

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	r10d, r10d
	je	SHORT $LN3@FSE_initCS
	lea	ecx, DWORD PTR [r10-1]
	shl	r8d, cl
$LN3@FSE_initCS:
	movsxd	rcx, r8d
	inc	rcx

; 496  :     statePtr->stateLog = tableLog;

	mov	DWORD PTR [r9+24], r10d
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	QWORD PTR [r9+16], rcx

; 497  : }

	ret	0
FSE_initCState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
symbolTTPtr$ = 8
symbolValue$ = 16
FSE_getMaxNbBits PROC

; 537  :     const FSE_symbolCompressionTransform* symbolTT = (const FSE_symbolCompressionTransform*) symbolTTPtr;
; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	mov	eax, edx
	mov	eax, DWORD PTR [rcx+rax*8+4]
	add	eax, 65535				; 0000ffffH
	shr	eax, 16

; 539  : }

	ret	0
FSE_getMaxNbBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy8 PROC

; 231  : #ifdef __aarch64__
; 232  :     vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));
; 233  : #else
; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 235  : #endif
; 236  : }

	ret	0
ZSTD_copy8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy16 PROC

; 240  : #ifdef __aarch64__
; 241  :     vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));
; 242  : #else
; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 244  : #endif
; 245  : }

	ret	0
ZSTD_copy16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
length$ = 24
ovtype$dead$ = 32
ZSTD_wildcopy PROC

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;
; 268  :     const BYTE* ip = (const BYTE*)src;
; 269  :     BYTE* op = (BYTE*)dst;
; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [rcx+r8]
	sub	rdx, rcx
	npad	9
$LL7@ZSTD_wildc:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {
; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)
; 278  :         } while (op < oend);
; 279  :     } else {
; 280  :         assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);
; 281  :         /* Separate out the first COPY16() call because the copy length is
; 282  :          * almost certain to be short, so the branches have different
; 283  :          * probabilities. Since it is almost certain to be short, only do
; 284  :          * one COPY16() in the first call. Then, do two calls per loop since
; 285  :          * at that point it is more likely to have a high trip count.
; 286  :          */
; 287  : #ifndef __aarch64__
; 288  :         do {
; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL7@ZSTD_wildc

; 292  : #else
; 293  :         COPY16(op, ip);
; 294  :         if (op >= oend) return;
; 295  :         do {
; 296  :             COPY16(op, ip);
; 297  :             COPY16(op, ip);
; 298  :         }
; 299  :         while (op < oend);
; 300  : #endif
; 301  :     }
; 302  : }

	ret	0
ZSTD_wildcopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
val$ = 8
ZSTD_highbit32 PROC

; 394  :     assert(val != 0);
; 395  :     {
; 396  : #   if defined(_MSC_VER)   /* Visual */
; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 399  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
; 400  :         return __builtin_clz (val) ^ 31;
; 401  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 402  :         return 31 - __CLZ(val);
; 403  : #   else   /* Software version */
; 404  :         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
; 405  :         U32 v = val;
; 406  :         v |= v >> 1;
; 407  :         v |= v >> 2;
; 408  :         v |= v >> 4;
; 409  :         v |= v >> 8;
; 410  :         v |= v >> 16;
; 411  :         return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];
; 412  : #   endif
; 413  :     }
; 414  : }

	ret	0
ZSTD_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
litLength$ = 8
ZSTD_LLcode PROC

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	cmp	ecx, 63					; 0000003fH
	jbe	SHORT $LN3@ZSTD_LLcod
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, ecx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	add	eax, 19

; 310  : }

	ret	0
$LN3@ZSTD_LLcod:

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	mov	eax, ecx
	lea	rcx, OFFSET FLAT:?LL_Code@?1??ZSTD_LLcode@@9@9
	movzx	eax, BYTE PTR [rax+rcx]

; 310  : }

	ret	0
ZSTD_LLcode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
mlBase$ = 8
ZSTD_MLcode PROC

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	cmp	ecx, 127				; 0000007fH
	jbe	SHORT $LN3@ZSTD_MLcod
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, ecx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	add	eax, 36					; 00000024H

; 327  : }

	ret	0
$LN3@ZSTD_MLcod:

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	mov	eax, ecx
	lea	rcx, OFFSET FLAT:?ML_Code@?1??ZSTD_MLcode@@9@9
	movzx	eax, BYTE PTR [rax+rcx]

; 327  : }

	ret	0
ZSTD_MLcode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
$T1 = 8
rep$ = 16
offset$ = 24
ll0$ = 32
ZSTD_updateRep PROC

; 335  :     repcodes_t newReps;
; 336  :     if (offset >= ZSTD_REP_NUM) {  /* full offset */

	cmp	r8d, 3
	jb	SHORT $LN2@ZSTD_updat

; 337  :         newReps.rep[2] = rep[1];

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+8], eax

; 338  :         newReps.rep[1] = rep[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+4], eax

; 339  :         newReps.rep[0] = offset - ZSTD_REP_MOVE;

	lea	eax, DWORD PTR [r8-2]
	mov	DWORD PTR [rcx], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	ret	0
$LN2@ZSTD_updat:

; 340  :     } else {   /* repcode */
; 341  :         U32 const repCode = offset + ll0;

	add	r8d, r9d

; 342  :         if (repCode > 0) {  /* note : if repCode==0, no change */

	je	SHORT $LN4@ZSTD_updat

; 343  :             U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	mov	eax, DWORD PTR [rdx]
	cmp	r8d, 3
	jne	SHORT $LN7@ZSTD_updat

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	mov	r8d, DWORD PTR [rdx+4]
	lea	r9d, DWORD PTR [rax-1]

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR [rcx+4], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rcx+8], r8d
	ret	0
$LN7@ZSTD_updat:

; 343  :             U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	mov	r9d, DWORD PTR [rdx+r8*4]

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	cmp	r8d, 2
	jb	SHORT $LN9@ZSTD_updat
	mov	r8d, DWORD PTR [rdx+4]

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR [rcx+4], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	mov	DWORD PTR [rcx+8], r8d
	mov	DWORD PTR [rcx], r9d
	ret	0
$LN9@ZSTD_updat:

; 344  :             newReps.rep[2] = (repCode >= 2) ? rep[1] : rep[2];

	mov	r8d, DWORD PTR [rdx+8]

; 345  :             newReps.rep[1] = rep[0];

	mov	DWORD PTR [rcx+4], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	mov	DWORD PTR [rcx+8], r8d
	mov	DWORD PTR [rcx], r9d
	ret	0
$LN4@ZSTD_updat:

; 346  :             newReps.rep[0] = currentOffset;
; 347  :         } else {   /* repCode == 0 */
; 348  :             memcpy(&newReps, rep, sizeof(newReps));

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+8], eax

; 349  :         }
; 350  :     }
; 351  :     return newReps;
; 352  : }

	mov	rax, rcx
	ret	0
ZSTD_updateRep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
op$ = 8
ip$ = 16
iend$ = 24
ilimit_w$ = 32
ZSTD_safecopyLiterals PROC

; 423  :     assert(iend > ilimit_w);
; 424  :     if (ip <= ilimit_w) {

	cmp	rdx, r9
	ja	SHORT $LN19@ZSTD_safec
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r10, rcx
	sub	r10, rdx
	add	r10, r9
	sub	rdx, rcx
	npad	15
$LL12@ZSTD_safec:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL12@ZSTD_safec
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	mov	rdx, r9
$LN19@ZSTD_safec:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdx, r8
	jae	SHORT $LN3@ZSTD_safec
	npad	5
$LL21@ZSTD_safec:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	cmp	rdx, r8
	jb	SHORT $LL21@ZSTD_safec
$LN3@ZSTD_safec:

; 430  : }

	ret	0
ZSTD_safecopyLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
seqStorePtr$ = 8
litLength$ = 16
literals$ = 24
litLimit$ = 32
offCode$ = 40
mlBase$ = 48
ZSTD_storeSeq PROC

; 440  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	r10, rcx

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rcx, QWORD PTR [rdx+r8]
	mov	r11, rdx
	mov	r9, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	rcx, rbx
	ja	SHORT $LN2@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r9], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	SHORT $LN24@ZSTD_store

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rdx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r8, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	3
$LL16@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]

; 289  :             COPY16(op, ip);

	lea	r8, QWORD PTR [r8+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL16@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN24@ZSTD_store
$LN2@ZSTD_store:

; 424  :     if (ip <= ilimit_w) {

	cmp	r8, rbx
	ja	SHORT $LN41@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, r9
	sub	rdx, r8
	add	rdx, rbx
	sub	r8, r9
	npad	9
$LL33@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+r9]
	movups	XMMWORD PTR [r9], xmm0

; 289  :             COPY16(op, ip);

	add	r9, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	r9, rdx
	jb	SHORT $LL33@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	r9, rdx
	mov	r8, rbx
$LN41@ZSTD_store:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r8, rcx
	jae	SHORT $LN24@ZSTD_store
	sub	r9, r8
$LL43@ZSTD_store:
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r9+r8], al
	inc	r8
	cmp	r8, rcx
	jb	SHORT $LL43@ZSTD_store
$LN24@ZSTD_store:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);
; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], r11
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r11, 65535				; 0000ffffH
	jbe	SHORT $LN48@ZSTD_store

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN48@ZSTD_store:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;
; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;
; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	mov	rdx, QWORD PTR mlBase$[rsp]
	mov	WORD PTR [rcx+4], r11w
	mov	ecx, DWORD PTR offCode$[rsp]
	mov	rax, QWORD PTR [r10+8]
	inc	ecx
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r10+8]
	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN53@ZSTD_store

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 2
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN53@ZSTD_store:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;
; 488  : 
; 489  :     seqStorePtr->sequences++;
; 490  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	WORD PTR [rcx+6], dx
	add	QWORD PTR [r10+8], 8
	ret	0
ZSTD_storeSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
val$ = 8
r$1 = 16
ZSTD_NbCommonBytes PROC

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN9@ZSTD_NbCom
	shr	eax, 3

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
$LN9@ZSTD_NbCom:

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
ZSTD_NbCommonBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
r$1 = 8
r$2 = 8
pIn$ = 8
pMatch$ = 16
pInLimit$ = 24
ZSTD_count PROC

; 563  :     const BYTE* const pStart = pIn;
; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r9, QWORD PTR [r8-7]
	mov	r10, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN5@ZSTD_count

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN20@ZSTD_count
	shr	eax, 3

; 580  : }

	ret	0
$LN20@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 580  : }

	ret	0
$LN5@ZSTD_count:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count
$LL2@ZSTD_count:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN6@ZSTD_count
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r9
	jb	SHORT $LL2@ZSTD_count
$LN3@ZSTD_count:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r8-3]
	cmp	rcx, rax
	jae	SHORT $LN7@ZSTD_count
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN7@ZSTD_count
	add	rcx, 4
	add	rdx, 4
$LN7@ZSTD_count:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r8-1]
	cmp	rcx, rax
	jae	SHORT $LN8@ZSTD_count
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN8@ZSTD_count
	add	rcx, 2
	add	rdx, 2
$LN8@ZSTD_count:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r8
	jae	SHORT $LN9@ZSTD_count
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN9@ZSTD_count
	inc	rcx
$LN9@ZSTD_count:

; 579  :     return (size_t)(pIn - pStart);

	sub	rcx, r10
	mov	rax, rcx

; 580  : }

	ret	0
$LN6@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN36@ZSTD_count
	shr	edx, 3

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
$LN36@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
ZSTD_count ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ip$ = 48
match$ = 56
iEnd$ = 64
mEnd$ = 72
iStart$ = 80
ZSTD_count_2segments PROC

; 589  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r10, rcx
	mov	rsi, r8
	sub	r10, rdx
	mov	rbx, r9
	add	r10, r9
	mov	r11, rdx
	cmp	r10, r8
	mov	rbp, rcx
	cmovb	r8, r10

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	call	ZSTD_count
	mov	rdi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	jne	SHORT $LN1@ZSTD_count

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR iStart$[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	mov	r8, rsi
	call	ZSTD_count
	add	rax, rdi
$LN1@ZSTD_count:

; 599  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_count_2segments ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash3 PROC

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	imul	eax, ecx, 900185344			; 35a7bd00H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	eax, cl
	ret	0
ZSTD_hash3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ptr$ = 8
h$ = 16
ZSTD_hash3Ptr PROC

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], 900185344		; 35a7bd00H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	rax, cl

; 607  : MEM_STATIC size_t ZSTD_hash3Ptr(const void* ptr, U32 h) { return ZSTD_hash3(MEM_readLE32(ptr), h); } /* only in zstd_opt.h */

	ret	0
ZSTD_hash3Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash4 PROC

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, ecx, -1640531535			; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	eax, cl
	ret	0
ZSTD_hash4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ptr$ = 8
h$ = 16
ZSTD_hash4Ptr PROC

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	rax, cl

; 611  : static size_t ZSTD_hash4Ptr(const void* ptr, U32 h) { return ZSTD_hash4(MEM_read32(ptr), h); }

	ret	0
ZSTD_hash4Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash5 PROC

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash5 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash5Ptr PROC

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 615  : static size_t ZSTD_hash5Ptr(const void* p, U32 h) { return ZSTD_hash5(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash5Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash6 PROC

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash6Ptr PROC

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 619  : static size_t ZSTD_hash6Ptr(const void* p, U32 h) { return ZSTD_hash6(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash6Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash7 PROC

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash7 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash7Ptr PROC

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 623  : static size_t ZSTD_hash7Ptr(const void* p, U32 h) { return ZSTD_hash7(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash7Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash8 PROC

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash8Ptr PROC

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 627  : static size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash8Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
hBits$ = 16
mls$ = 24
ZSTD_hashPtr PROC

; 631  :     switch(mls)

	sub	r8d, 5
	je	SHORT $LN5@ZSTD_hashP
	sub	r8d, 1
	je	SHORT $LN6@ZSTD_hashP
	sub	r8d, 1
	je	SHORT $LN7@ZSTD_hashP
	cmp	r8d, 1
	je	SHORT $LN8@ZSTD_hashP

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN8@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN7@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN6@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN5@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hashPtr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 8
current$ = 16
windowLog$ = 24
ZSTD_getLowestMatchIndex PROC

; 977  : {

	mov	rax, rcx

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r8d
	mov	r8d, 1
	shl	r8d, cl

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r9d, DWORD PTR [rax+28]

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;
; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, DWORD PTR [rax+32]
	mov	eax, edx
	sub	edx, r8d
	sub	eax, r9d
	cmp	eax, r8d
	cmovbe	edx, r9d
	test	ecx, ecx

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	edx, r9d

; 983  :     return matchLowest;

	mov	eax, edx

; 984  : }

	ret	0
ZSTD_getLowestMatchIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
stat$ = 8
ZSTD_bitWeight PROC
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	ecx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	eax, 8

; 44   : }

	ret	0
ZSTD_bitWeight ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
rawStat$ = 8
ZSTD_fracWeight PROC

; 48   :     U32 const stat = rawStat + 1;

	lea	eax, DWORD PTR [rcx+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edx, edx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	eax, 8
	mov	ecx, edx
	shl	edx, 8
	shr	eax, cl

; 52   :     U32 const weight = BWeight + FWeight;

	add	eax, edx

; 53   :     assert(hb + BITCOST_ACCURACY < 31);
; 54   :     return weight;
; 55   : }

	ret	0
ZSTD_fracWeight ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
optPtr$ = 8
ZSTD_compressedLiterals PROC

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	xor	eax, eax
	cmp	DWORD PTR [rcx+96], 2
	setne	al

; 70   : }

	ret	0
ZSTD_compressedLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
optPtr$ = 8
optLevel$ = 16
ZSTD_setBasePrices PROC

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	xor	r8d, r8d

; 73   : {

	mov	r9, rcx

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	cmp	DWORD PTR [rcx+96], 2

; 74   :     if (ZSTD_compressedLiterals(optPtr))

	je	SHORT $LN2@ZSTD_setBa

; 75   :         optPtr->litSumBasePrice = WEIGHT(optPtr->litSum, optLevel);

	mov	eax, DWORD PTR [rcx+48]
	test	edx, edx
	je	SHORT $LN4@ZSTD_setBa

; 48   :     U32 const stat = rawStat + 1;

	lea	r10d, DWORD PTR [rax+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r8d
	bsr	eax, r10d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	r10d, 8
	shr	r10d, cl
	shl	ecx, 8

; 52   :     U32 const weight = BWeight + FWeight;

	add	r10d, ecx

; 75   :         optPtr->litSumBasePrice = WEIGHT(optPtr->litSum, optLevel);

	jmp	SHORT $LN5@ZSTD_setBa
$LN4@ZSTD_setBa:

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	r10d, r8d
	bsr	ecx, eax
	cmovne	r10d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	r10d, 8
$LN5@ZSTD_setBa:

; 75   :         optPtr->litSumBasePrice = WEIGHT(optPtr->litSum, optLevel);

	mov	DWORD PTR [r9+64], r10d
$LN2@ZSTD_setBa:

; 76   :     optPtr->litLengthSumBasePrice = WEIGHT(optPtr->litLengthSum, optLevel);

	mov	eax, DWORD PTR [r9+52]
	test	edx, edx
	je	SHORT $LN6@ZSTD_setBa

; 48   :     U32 const stat = rawStat + 1;

	lea	edx, DWORD PTR [rax+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r8d
	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	shr	edx, cl
	shl	ecx, 8

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, ecx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 52   :     U32 const weight = BWeight + FWeight;

	mov	DWORD PTR [r9+68], edx
	mov	edx, DWORD PTR [r9+56]

; 48   :     U32 const stat = rawStat + 1;

	inc	edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	shr	edx, cl
	shl	ecx, 8

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, ecx
	mov	DWORD PTR [r9+72], edx
	mov	edx, DWORD PTR [r9+60]

; 48   :     U32 const stat = rawStat + 1;

	inc	edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	mov	ecx, r8d
	shl	r8d, 8
	shr	edx, cl

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, r8d

; 78   :     optPtr->offCodeSumBasePrice = WEIGHT(optPtr->offCodeSum, optLevel);

	mov	DWORD PTR [r9+76], edx

; 79   : }

	ret	0
$LN6@ZSTD_setBa:

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	eax, 8

; 76   :     optPtr->litLengthSumBasePrice = WEIGHT(optPtr->litLengthSum, optLevel);

	mov	DWORD PTR [r9+68], eax
	mov	eax, DWORD PTR [r9+56]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	eax, 8

; 77   :     optPtr->matchLengthSumBasePrice = WEIGHT(optPtr->matchLengthSum, optLevel);

	mov	DWORD PTR [r9+72], eax
	mov	eax, DWORD PTR [r9+60]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	r8d, 8

; 78   :     optPtr->offCodeSumBasePrice = WEIGHT(optPtr->offCodeSum, optLevel);

	mov	DWORD PTR [r9+76], r8d

; 79   : }

	ret	0
ZSTD_setBasePrices ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
table$ = 8
lastEltIndex$ = 16
malus$ = 24
ZSTD_downscaleStat PROC

; 86   : {

	mov	QWORD PTR [rsp+8], rbx

; 87   :     U32 s, sum=0;

	xor	r9d, r9d

; 88   :     DEBUGLOG(5, "ZSTD_downscaleStat (nbElts=%u)", (unsigned)lastEltIndex+1);
; 89   :     assert(ZSTD_FREQ_DIV+malus > 0 && ZSTD_FREQ_DIV+malus < 31);
; 90   :     for (s=0; s<lastEltIndex+1; s++) {

	lea	r10d, DWORD PTR [rdx+1]
	mov	r11d, r8d
	mov	edx, r9d
	test	r10d, r10d
	je	$LN17@ZSTD_downs
	cmp	r10d, 8
	jb	$LN15@ZSTD_downs

; 91   :         table[s] = 1 + (table[s] >> (ZSTD_FREQ_DIV+malus));

	movdqa	xmm4, XMMWORD PTR __xmm@00000001000000010000000100000001
	lea	eax, DWORD PTR [r8+4]
	mov	r8d, r10d
	movd	xmm3, eax
	and	r8d, -8					; fffffff8H
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	npad	14
$LL4@ZSTD_downs:
	mov	eax, edx
	movdqu	xmm0, XMMWORD PTR [rcx+rax*4]
	psrld	xmm0, xmm3
	paddd	xmm0, xmm4
	movdqu	XMMWORD PTR [rcx+rax*4], xmm0
	lea	eax, DWORD PTR [rdx+4]
	add	edx, 8

; 92   :         sum += table[s];

	paddd	xmm0, xmm2
	movdqa	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rcx+rax*4]
	psrld	xmm0, xmm3
	paddd	xmm0, xmm4
	movdqu	XMMWORD PTR [rcx+rax*4], xmm0
	paddd	xmm0, xmm1
	movdqa	xmm1, xmm0
	cmp	edx, r8d
	jb	SHORT $LL4@ZSTD_downs

; 87   :     U32 s, sum=0;

	paddd	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	r9d, xmm1

; 88   :     DEBUGLOG(5, "ZSTD_downscaleStat (nbElts=%u)", (unsigned)lastEltIndex+1);
; 89   :     assert(ZSTD_FREQ_DIV+malus > 0 && ZSTD_FREQ_DIV+malus < 31);
; 90   :     for (s=0; s<lastEltIndex+1; s++) {

	cmp	edx, r10d
	jae	SHORT $LN17@ZSTD_downs
$LN15@ZSTD_downs:

; 91   :         table[s] = 1 + (table[s] >> (ZSTD_FREQ_DIV+malus));

	mov	eax, edx
	sub	r10d, edx
	mov	r8d, r10d
	lea	rax, QWORD PTR [rcx+rax*4]
	npad	11
$LL8@ZSTD_downs:
	mov	edx, DWORD PTR [rax]
	lea	ecx, DWORD PTR [r11+4]
	shr	edx, cl
	lea	rax, QWORD PTR [rax+4]
	lea	ecx, DWORD PTR [rdx+1]

; 92   :         sum += table[s];

	add	r9d, ecx
	mov	DWORD PTR [rax-4], ecx
	sub	r8, 1
	jne	SHORT $LL8@ZSTD_downs
$LN17@ZSTD_downs:

; 93   :     }
; 94   :     return sum;
; 95   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	eax, r9d
	ret	0
ZSTD_downscaleStat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
lit$3 = 64
optPtr$ = 64
src$ = 72
srcSize$ = 80
optLevel$ = 88
ZSTD_rescaleFreqs PROC

; 107  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 108  :     int const compressedLiterals = ZSTD_compressedLiterals(optPtr);
; 109  :     DEBUGLOG(5, "ZSTD_rescaleFreqs (srcSize=%u)", (unsigned)srcSize);
; 110  :     optPtr->priceType = zop_dynamic;

	xor	r14d, r14d

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	mov	ecx, DWORD PTR [rcx+96]

; 107  : {

	mov	r15d, r9d

; 108  :     int const compressedLiterals = ZSTD_compressedLiterals(optPtr);
; 109  :     DEBUGLOG(5, "ZSTD_rescaleFreqs (srcSize=%u)", (unsigned)srcSize);
; 110  :     optPtr->priceType = zop_dynamic;

	mov	DWORD PTR [rdi+80], r14d

; 111  : 
; 112  :     if (optPtr->litLengthSum == 0) {  /* first block : init */

	cmp	DWORD PTR [rdi+52], r14d
	jne	$LN23@ZSTD_resca

; 113  :         if (srcSize <= ZSTD_PREDEF_THRESHOLD) {  /* heuristic */

	cmp	r8, 1024				; 00000400H
	mov	eax, r14d
	mov	ebx, 1
	cmovbe	eax, ebx
	mov	DWORD PTR [rdi+80], eax

; 114  :             DEBUGLOG(5, "(srcSize <= ZSTD_PREDEF_THRESHOLD) => zop_predef");
; 115  :             optPtr->priceType = zop_predef;
; 116  :         }
; 117  : 
; 118  :         assert(optPtr->symbolCosts != NULL);
; 119  :         if (optPtr->symbolCosts->huf.repeatMode == HUF_repeat_valid) {

	mov	rax, QWORD PTR [rdi+88]
	cmp	DWORD PTR [rax+1024], 2
	jne	$LN26@ZSTD_resca

; 120  :             /* huffman table presumed generated by dictionary */
; 121  :             optPtr->priceType = zop_dynamic;

	mov	QWORD PTR [rsp+72], rsi
	mov	DWORD PTR [rdi+80], r14d

; 122  : 
; 123  :             if (compressedLiterals) {

	cmp	ecx, 2
	je	SHORT $LN3@ZSTD_resca

; 124  :                 unsigned lit;
; 125  :                 assert(optPtr->litFreq != NULL);
; 126  :                 optPtr->litSum = 0;

	mov	r9, QWORD PTR [rdi]
	mov	edx, r14d
	mov	DWORD PTR [rdi+48], r14d
	mov	r10d, 256				; 00000100H
	npad	15
$LL4@ZSTD_resca:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 204  :     return table[symbolValue].nbBits;

	mov	rax, QWORD PTR [rdi+88]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 131  :                     optPtr->litFreq[lit] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	mov	r8d, ebx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 204  :     return table[symbolValue].nbBits;

	movzx	ecx, BYTE PTR [rdx+rax+2]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 131  :                     optPtr->litFreq[lit] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN33@ZSTD_resca
	mov	eax, 11
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN33@ZSTD_resca:
	mov	DWORD PTR [rdx+r9], r8d

; 132  :                     optPtr->litSum += optPtr->litFreq[lit];

	mov	r9, QWORD PTR [rdi]
	mov	eax, DWORD PTR [rdx+r9]
	add	rdx, 4
	add	DWORD PTR [rdi+48], eax
	sub	r10, rbx
	jne	SHORT $LL4@ZSTD_resca
	mov	rax, QWORD PTR [rdi+88]
$LN3@ZSTD_resca:

; 133  :             }   }
; 134  : 
; 135  :             {   unsigned ll;
; 136  :                 FSE_CState_t llstate;
; 137  :                 FSE_initCState(&llstate, optPtr->symbolCosts->fse.litlengthCTable);

	lea	rdx, QWORD PTR [rax+3252]
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	eax, ebx
	movzx	ecx, WORD PTR [rdx]
	test	ecx, ecx
	je	SHORT $LN47@ZSTD_resca
	dec	ecx
	shl	eax, cl
$LN47@ZSTD_resca:
	cdqe
	mov	ebp, 2
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 138  :                 optPtr->litLengthSum = 0;

	mov	DWORD PTR [rdi+52], r14d
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	r8d, ebp
	lea	rsi, QWORD PTR [rdx+rax*4]
	npad	2
$LL7@ZSTD_resca:

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8-2]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	mov	edx, ebx
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	mov	r9d, eax
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN35@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN35@ZSTD_resca:
	mov	rax, QWORD PTR [rdi+8]
	mov	DWORD PTR [rax+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8-1]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN87@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN87@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	mov	r9d, r8d
	mov	ecx, DWORD PTR [rsi+r9*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN90@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN90@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+1]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN93@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN93@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+2]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN96@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN96@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+3]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN99@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN99@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+4]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN102@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN102@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+5]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN105@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN105@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+6]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN108@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN108@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+7]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN111@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN111@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+8]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN114@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN114@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+9]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN117@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN117@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+10]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN120@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN120@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+11]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN123@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN123@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+12]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN126@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN126@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+13]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN129@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN129@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r10, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+14]
	mov	r11d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN132@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN132@ZSTD_resca:
	mov	DWORD PTR [r10+r11*4], edx
	mov	edx, ebx

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	r9, QWORD PTR [rdi+8]
	mov	eax, DWORD PTR [r9+r11*4]
	add	DWORD PTR [rdi+52], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [r8+15]
	mov	r10d, eax
	mov	ecx, DWORD PTR [rsi+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 143  :                     optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN135@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN135@ZSTD_resca:
	mov	DWORD PTR [r9+r10*4], edx
	add	r8d, 18

; 144  :                     optPtr->litLengthSum += optPtr->litLengthFreq[ll];

	mov	rax, QWORD PTR [rdi+8]
	mov	ecx, DWORD PTR [rax+r10*4]
	lea	eax, DWORD PTR [r8-2]
	add	DWORD PTR [rdi+52], ecx
	cmp	eax, 35					; 00000023H
	jbe	$LL7@ZSTD_resca
	mov	rdx, QWORD PTR [rdi+88]
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	eax, ebx
	mov	rsi, QWORD PTR [rsp+72]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 149  :                 FSE_initCState(&mlstate, optPtr->symbolCosts->fse.matchlengthCTable);

	add	rdx, 1800				; 00000708H
; File E:\dev\pyzstd\lib\common\fse.h

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	ecx, WORD PTR [rdx]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	ecx, ecx
	je	SHORT $LN53@ZSTD_resca
	dec	ecx
	shl	eax, cl
$LN53@ZSTD_resca:
	mov	r10, QWORD PTR [rdi+16]
	mov	r8, r14
	movsxd	r9, eax
	mov	r11d, 53				; 00000035H
	add	r9, rbp
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 150  :                 optPtr->matchLengthSum = 0;

	mov	DWORD PTR [rdi+56], r14d
	lea	r9, QWORD PTR [rdx+r9*4]
	npad	12
$LL10@ZSTD_resca:
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	mov	ecx, DWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 155  :                     optPtr->matchLengthFreq[ml] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	mov	edx, ebx
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 155  :                     optPtr->matchLengthFreq[ml] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN37@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	edx, cl
$LN37@ZSTD_resca:
	mov	DWORD PTR [r10+r8], edx
	add	r9, 8

; 156  :                     optPtr->matchLengthSum += optPtr->matchLengthFreq[ml];

	mov	r10, QWORD PTR [rdi+16]
	mov	eax, DWORD PTR [r10+r8]
	add	r8, 4
	add	DWORD PTR [rdi+56], eax
	sub	r11, rbx
	jne	SHORT $LL10@ZSTD_resca
	mov	rdx, QWORD PTR [rdi+88]
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	eax, ebx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 161  :                 FSE_initCState(&ofstate, optPtr->symbolCosts->fse.offcodeCTable);

	add	rdx, 1028				; 00000404H
; File E:\dev\pyzstd\lib\common\fse.h

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	ecx, WORD PTR [rdx]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	ecx, ecx
	je	SHORT $LN59@ZSTD_resca
	dec	ecx
	shl	eax, cl
$LN59@ZSTD_resca:
	cdqe
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 162  :                 optPtr->offCodeSum = 0;

	mov	DWORD PTR [rdi+60], r14d
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	lea	rdx, QWORD PTR [rdx+rax*4]
	npad	4
$LL13@ZSTD_resca:

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp-2]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	mov	r8d, ebx
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	mov	r9d, eax
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN39@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN39@ZSTD_resca:
	mov	rax, QWORD PTR [rdi+24]
	mov	DWORD PTR [rax+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp-1]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN138@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN138@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	mov	r9d, ebp
	mov	ecx, DWORD PTR [rdx+r9*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN141@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN141@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+1]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN144@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN144@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+2]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN147@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN147@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+3]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN150@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN150@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+4]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN153@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN153@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+5]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN156@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN156@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+6]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN159@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN159@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+7]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN162@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN162@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+8]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN165@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN165@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+9]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN168@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN168@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+10]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN171@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN171@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+11]
	mov	r9d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN174@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN174@ZSTD_resca:
	mov	DWORD PTR [r10+r9*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r10, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r10+r9*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+12]
	mov	r11d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN177@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN177@ZSTD_resca:
	mov	DWORD PTR [r10+r11*4], r8d
	mov	r8d, ebx

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	r9, QWORD PTR [rdi+24]
	mov	eax, DWORD PTR [r9+r11*4]
	add	DWORD PTR [rdi+60], eax
; File E:\dev\pyzstd\lib\common\fse.h

; 538  :     return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;

	lea	eax, DWORD PTR [rbp+13]
	mov	r10d, eax
	mov	ecx, DWORD PTR [rdx+rax*8+8]
	add	ecx, 65535				; 0000ffffH
	shr	ecx, 16
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 167  :                     optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;

	test	ecx, ecx
	je	SHORT $LN180@ZSTD_resca
	mov	eax, 10
	sub	eax, ecx
	movzx	ecx, al
	shl	r8d, cl
$LN180@ZSTD_resca:
	mov	DWORD PTR [r9+r10*4], r8d
	add	ebp, 16

; 168  :                     optPtr->offCodeSum += optPtr->offCodeFreq[of];

	mov	rax, QWORD PTR [rdi+24]
	mov	ecx, DWORD PTR [rax+r10*4]
	lea	eax, DWORD PTR [rbp-2]
	add	DWORD PTR [rdi+60], ecx
	cmp	eax, 31
	jbe	$LL13@ZSTD_resca

; 169  :             }   }
; 170  : 
; 171  :         } else {  /* not a dictionary */

	jmp	$LN24@ZSTD_resca
$LN26@ZSTD_resca:

; 172  : 
; 173  :             assert(optPtr->litFreq != NULL);
; 174  :             if (compressedLiterals) {

	cmp	ecx, 2
	je	SHORT $LN29@ZSTD_resca

; 175  :                 unsigned lit = MaxLit;
; 176  :                 HIST_count_simple(optPtr->litFreq, &lit, src, srcSize);   /* use raw first block to init statistics */

	mov	rcx, QWORD PTR [rdi]
	mov	r9, r8
	mov	r8, rdx
	mov	DWORD PTR lit$3[rsp], 255		; 000000ffH
	lea	rdx, QWORD PTR lit$3[rsp]
	call	HIST_count_simple

; 177  :                 optPtr->litSum = ZSTD_downscaleStat(optPtr->litFreq, MaxLit, 1);

	mov	rcx, QWORD PTR [rdi]
	mov	r8d, ebx
	mov	edx, 255				; 000000ffH
	call	ZSTD_downscaleStat
	mov	DWORD PTR [rdi+48], eax
$LN29@ZSTD_resca:

; 182  :                     optPtr->litLengthFreq[ll] = 1;

	mov	rax, QWORD PTR [rdi+8]
	lea	r8, QWORD PTR [rdi+8]
	mov	r9, 4294967297				; 0000000100000001H
	lea	rcx, QWORD PTR [rax+140]
	cmp	rax, r8
	ja	SHORT $LN78@ZSTD_resca

; 178  :             }
; 179  : 
; 180  :             {   unsigned ll;
; 181  :                 for (ll=0; ll<=MaxLL; ll++)

	cmp	rcx, r8
	jb	SHORT $LN78@ZSTD_resca
	mov	rcx, r14
	mov	edx, 36					; 00000024H
	npad	12
$LL201@ZSTD_resca:

; 182  :                     optPtr->litLengthFreq[ll] = 1;

	mov	rax, QWORD PTR [r8]
	lea	rcx, QWORD PTR [rcx+4]
	mov	DWORD PTR [rcx+rax-4], ebx
	sub	rdx, rbx
	jne	SHORT $LL201@ZSTD_resca

; 178  :             }
; 179  : 
; 180  :             {   unsigned ll;
; 181  :                 for (ll=0; ll<=MaxLL; ll++)

	jmp	SHORT $LN15@ZSTD_resca
$LN78@ZSTD_resca:
	mov	ebp, 2
	npad	9
$LL216@ZSTD_resca:
	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
	mov	QWORD PTR [rax+16], r9
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r9
	mov	QWORD PTR [rax-32], r9
	mov	QWORD PTR [rax-24], r9
	mov	QWORD PTR [rax-16], r9
	mov	QWORD PTR [rax-8], r9
	sub	rbp, 1
	jne	SHORT $LL216@ZSTD_resca
	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
$LN15@ZSTD_resca:

; 185  : 
; 186  :             {   unsigned ml;
; 187  :                 for (ml=0; ml<=MaxML; ml++)
; 188  :                     optPtr->matchLengthFreq[ml] = 1;

	mov	rax, QWORD PTR [rdi+16]
	lea	r8, QWORD PTR [rdi+16]
	mov	DWORD PTR [rdi+52], 36			; 00000024H
	mov	edx, r14d
	lea	rcx, QWORD PTR [rax+208]
	cmp	rax, r8
	ja	SHORT $LN81@ZSTD_resca

; 183  :             }
; 184  :             optPtr->litLengthSum = MaxLL+1;

	cmp	rcx, r8
	jae	SHORT $LL221@ZSTD_resca
$LN81@ZSTD_resca:
	mov	edx, 52					; 00000034H
	lea	ecx, QWORD PTR [rdx-49]
	npad	5
$LL215@ZSTD_resca:
	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
	mov	QWORD PTR [rax+16], r9
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r9
	mov	QWORD PTR [rax-32], r9
	mov	QWORD PTR [rax-24], r9
	mov	QWORD PTR [rax-16], r9
	mov	QWORD PTR [rax-8], r9
	sub	rcx, rbx
	jne	SHORT $LL215@ZSTD_resca
	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
	npad	1
$LL221@ZSTD_resca:

; 185  : 
; 186  :             {   unsigned ml;
; 187  :                 for (ml=0; ml<=MaxML; ml++)
; 188  :                     optPtr->matchLengthFreq[ml] = 1;

	mov	rax, QWORD PTR [r8]
	mov	ecx, edx
	inc	edx
	mov	DWORD PTR [rax+rcx*4], ebx
	cmp	edx, 52					; 00000034H
	jbe	SHORT $LL221@ZSTD_resca

; 191  : 
; 192  :             {   unsigned of;
; 193  :                 for (of=0; of<=MaxOff; of++)
; 194  :                     optPtr->offCodeFreq[of] = 1;

	mov	rax, QWORD PTR [rdi+24]
	lea	rdx, QWORD PTR [rdi+24]
	mov	r11d, 53				; 00000035H
	mov	DWORD PTR [rdi+56], r11d
	lea	rcx, QWORD PTR [rax+124]
	cmp	rax, rdx
	ja	SHORT $LN84@ZSTD_resca

; 189  :             }
; 190  :             optPtr->matchLengthSum = MaxML+1;

	cmp	rcx, rdx
	jb	SHORT $LN84@ZSTD_resca
	mov	ecx, 32					; 00000020H
	npad	12
$LL203@ZSTD_resca:

; 191  : 
; 192  :             {   unsigned of;
; 193  :                 for (of=0; of<=MaxOff; of++)
; 194  :                     optPtr->offCodeFreq[of] = 1;

	mov	rax, QWORD PTR [rdx]
	lea	r14, QWORD PTR [r14+4]
	mov	DWORD PTR [r14+rax-4], ebx
	sub	rcx, rbx
	jne	SHORT $LL203@ZSTD_resca

; 195  :             }
; 196  :             optPtr->offCodeSum = MaxOff+1;

	mov	DWORD PTR [rdi+60], 32			; 00000020H

; 197  : 
; 198  :         }
; 199  : 
; 200  :     } else {   /* new block : re-use previous statistics, scaled down */

	jmp	$LN24@ZSTD_resca
$LN84@ZSTD_resca:

; 189  :             }
; 190  :             optPtr->matchLengthSum = MaxML+1;

	movdqa	xmm0, XMMWORD PTR __xmm@00000001000000010000000100000001
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
	movups	XMMWORD PTR [rax+96], xmm0
	movups	XMMWORD PTR [rax+112], xmm0

; 195  :             }
; 196  :             optPtr->offCodeSum = MaxOff+1;

	mov	DWORD PTR [rdi+60], 32			; 00000020H

; 197  : 
; 198  :         }
; 199  : 
; 200  :     } else {   /* new block : re-use previous statistics, scaled down */

	jmp	SHORT $LN24@ZSTD_resca
$LN23@ZSTD_resca:

; 201  : 
; 202  :         if (compressedLiterals)

	cmp	ecx, 2
	je	SHORT $LN30@ZSTD_resca

; 203  :             optPtr->litSum = ZSTD_downscaleStat(optPtr->litFreq, MaxLit, 1);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 255				; 000000ffH
	mov	r8d, 1
	call	ZSTD_downscaleStat
	mov	DWORD PTR [rdi+48], eax
$LN30@ZSTD_resca:

; 204  :         optPtr->litLengthSum = ZSTD_downscaleStat(optPtr->litLengthFreq, MaxLL, 0);

	mov	rcx, QWORD PTR [rdi+8]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+35]
	call	ZSTD_downscaleStat

; 205  :         optPtr->matchLengthSum = ZSTD_downscaleStat(optPtr->matchLengthFreq, MaxML, 0);

	mov	rcx, QWORD PTR [rdi+16]
	xor	r8d, r8d
	mov	DWORD PTR [rdi+52], eax
	lea	edx, QWORD PTR [r8+52]
	call	ZSTD_downscaleStat

; 206  :         optPtr->offCodeSum = ZSTD_downscaleStat(optPtr->offCodeFreq, MaxOff, 0);

	mov	rcx, QWORD PTR [rdi+24]
	xor	r8d, r8d
	mov	DWORD PTR [rdi+56], eax
	lea	edx, QWORD PTR [r8+31]
	call	ZSTD_downscaleStat
	mov	DWORD PTR [rdi+60], eax
$LN24@ZSTD_resca:

; 207  :     }
; 208  : 
; 209  :     ZSTD_setBasePrices(optPtr, optLevel);

	mov	edx, r15d
	mov	rcx, rdi

; 210  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi

; 207  :     }
; 208  : 
; 209  :     ZSTD_setBasePrices(optPtr, optLevel);

	jmp	ZSTD_setBasePrices
ZSTD_rescaleFreqs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
literals$ = 8
litLength$dead$ = 16
optPtr$ = 24
optLevel$ = 32
ZSTD_rawLiteralsCost PROC

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	cmp	DWORD PTR [r8+96], 2

; 218  : {

	mov	eax, r9d

; 219  :     if (litLength == 0) return 0;
; 220  : 
; 221  :     if (!ZSTD_compressedLiterals(optPtr))

	jne	SHORT $LN6@ZSTD_rawLi

; 222  :         return (litLength << 3) * BITCOST_MULTIPLIER;  /* Uncompressed - 8 bytes per literal. */

	mov	eax, 2048				; 00000800H

; 235  :     }
; 236  : }

	ret	0
$LN6@ZSTD_rawLi:

; 223  : 
; 224  :     if (optPtr->priceType == zop_predef)

	cmp	DWORD PTR [r8+80], 1
	jne	SHORT $LN7@ZSTD_rawLi

; 225  :         return (litLength*6) * BITCOST_MULTIPLIER;  /* 6 bit per literal - no statistic used */

	mov	eax, 1536				; 00000600H

; 235  :     }
; 236  : }

	ret	0
$LN7@ZSTD_rawLi:

; 226  : 
; 227  :     /* dynamic statistics */
; 228  :     {   U32 price = litLength * optPtr->litSumBasePrice;

	mov	r9d, DWORD PTR [r8+64]
	mov	rdx, QWORD PTR [r8]
	movzx	r8d, BYTE PTR [rcx]

; 229  :         U32 u;
; 230  :         for (u=0; u < litLength; u++) {
; 231  :             assert(WEIGHT(optPtr->litFreq[literals[u]], optLevel) <= optPtr->litSumBasePrice);   /* literal cost should never be negative */
; 232  :             price -= WEIGHT(optPtr->litFreq[literals[u]], optLevel);

	test	eax, eax
	je	SHORT $LN9@ZSTD_rawLi

; 48   :     U32 const stat = rawStat + 1;

	mov	edx, DWORD PTR [rdx+r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 48   :     U32 const stat = rawStat + 1;

	inc	edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	mov	ecx, r8d
	shl	r8d, 8
	shr	edx, cl

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, r8d

; 229  :         U32 u;
; 230  :         for (u=0; u < litLength; u++) {
; 231  :             assert(WEIGHT(optPtr->litFreq[literals[u]], optLevel) <= optPtr->litSumBasePrice);   /* literal cost should never be negative */
; 232  :             price -= WEIGHT(optPtr->litFreq[literals[u]], optLevel);

	sub	r9d, edx

; 233  :         }
; 234  :         return price;

	mov	eax, r9d

; 235  :     }
; 236  : }

	ret	0
$LN9@ZSTD_rawLi:

; 229  :         U32 u;
; 230  :         for (u=0; u < litLength; u++) {
; 231  :             assert(WEIGHT(optPtr->litFreq[literals[u]], optLevel) <= optPtr->litSumBasePrice);   /* literal cost should never be negative */
; 232  :             price -= WEIGHT(optPtr->litFreq[literals[u]], optLevel);

	mov	ecx, DWORD PTR [rdx+r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	ecx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	r8d, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	r8d, 8

; 229  :         U32 u;
; 230  :         for (u=0; u < litLength; u++) {
; 231  :             assert(WEIGHT(optPtr->litFreq[literals[u]], optLevel) <= optPtr->litSumBasePrice);   /* literal cost should never be negative */
; 232  :             price -= WEIGHT(optPtr->litFreq[literals[u]], optLevel);

	mov	edx, r8d
	sub	r9d, edx

; 233  :         }
; 234  :         return price;

	mov	eax, r9d

; 235  :     }
; 236  : }

	ret	0
ZSTD_rawLiteralsCost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
litLength$ = 8
optPtr$ = 16
optLevel$ = 24
ZSTD_litLengthPrice PROC

; 242  :     if (optPtr->priceType == zop_predef) return WEIGHT(litLength, optLevel);

	cmp	DWORD PTR [rdx+80], 1
	mov	r9, rdx
	jne	SHORT $LN2@ZSTD_litLe
	xor	edx, edx
	lea	r9d, DWORD PTR [rcx+1]
	test	r8d, r8d
	je	SHORT $LN4@ZSTD_litLe
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r9d
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	r9d, 8
	mov	ecx, edx
	shl	edx, 8
	shr	r9d, cl

; 52   :     U32 const weight = BWeight + FWeight;

	add	r9d, edx

; 242  :     if (optPtr->priceType == zop_predef) return WEIGHT(litLength, optLevel);

	mov	eax, r9d

; 247  :              + optPtr->litLengthSumBasePrice
; 248  :              - WEIGHT(optPtr->litLengthFreq[llCode], optLevel);
; 249  :     }
; 250  : }

	ret	0
$LN4@ZSTD_litLe:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r9d
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	edx, 8

; 242  :     if (optPtr->priceType == zop_predef) return WEIGHT(litLength, optLevel);

	mov	r9d, edx
	mov	eax, edx

; 247  :              + optPtr->litLengthSumBasePrice
; 248  :              - WEIGHT(optPtr->litLengthFreq[llCode], optLevel);
; 249  :     }
; 250  : }

	ret	0
$LN2@ZSTD_litLe:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	xor	edx, edx
	lea	r11, OFFSET FLAT:__ImageBase
	cmp	ecx, 63					; 0000003fH
	jbe	SHORT $LN18@ZSTD_litLe
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, ecx
	mov	ecx, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	add	ecx, 19
	jmp	SHORT $LN19@ZSTD_litLe
$LN18@ZSTD_litLe:
	mov	eax, ecx
	movzx	ecx, BYTE PTR ?LL_Code@?1??ZSTD_LLcode@@9@9[rax+r11]
$LN19@ZSTD_litLe:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	lea	r10, QWORD PTR [rcx*4]
	mov	rcx, QWORD PTR [r9+8]
	test	r8d, r8d
	je	SHORT $LN6@ZSTD_litLe

; 48   :     U32 const stat = rawStat + 1;

	mov	r8d, DWORD PTR [rcx+r10]
	inc	r8d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r8d
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	mov	eax, DWORD PTR LL_bits[r10+r11]

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	r8d, 8
	mov	ecx, edx
	shr	r8d, cl
	shl	edx, 8

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	shl	eax, 8

; 52   :     U32 const weight = BWeight + FWeight;

	add	r8d, edx

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	add	eax, DWORD PTR [r9+68]
	sub	eax, r8d

; 247  :              + optPtr->litLengthSumBasePrice
; 248  :              - WEIGHT(optPtr->litLengthFreq[llCode], optLevel);
; 249  :     }
; 250  : }

	ret	0
$LN6@ZSTD_litLe:

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	mov	eax, DWORD PTR [rcx+r10]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	mov	eax, DWORD PTR LL_bits[r10+r11]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	shl	eax, 8
	add	eax, DWORD PTR [r9+68]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	edx, 8

; 246  :         return (LL_bits[llCode] * BITCOST_MULTIPLIER)

	sub	eax, edx
	mov	r8d, edx

; 247  :              + optPtr->litLengthSumBasePrice
; 248  :              - WEIGHT(optPtr->litLengthFreq[llCode], optLevel);
; 249  :     }
; 250  : }

	ret	0
ZSTD_litLengthPrice ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
offset$ = 16
matchLength$ = 24
optPtr$ = 32
optLevel$ = 40
ZSTD_getMatchPrice PROC

; 261  : {

	push	rbx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 263  :     U32 const offCode = ZSTD_highbit32(offset+1);

	lea	eax, DWORD PTR [rcx+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 261  : {

	mov	rbx, r8
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	r11d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r8d, DWORD PTR [rdx-3]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	r11d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rbx+80], 1
	jne	SHORT $LN2@ZSTD_getMa

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	edx, DWORD PTR [r8+1]
	test	r9d, r9d
	je	SHORT $LN5@ZSTD_getMa
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	r10d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	mov	ecx, r10d

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	eax, DWORD PTR [r11+16]

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shr	edx, cl
	shl	r10d, 8

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, r10d

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	shl	eax, 8
	add	eax, edx

; 284  : }

	pop	rbx
	ret	0
$LN5@ZSTD_getMa:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	r10d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	eax, DWORD PTR [r11+16]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	r10d, 8

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	mov	edx, r10d
	shl	eax, 8
	add	eax, edx

; 284  : }

	pop	rbx
	ret	0
$LN2@ZSTD_getMa:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rsp+24], rdi
	mov	eax, DWORD PTR [rax+r11*4]
	test	r9d, r9d
	je	SHORT $LN7@ZSTD_getMa

; 48   :     U32 const stat = rawStat + 1;

	lea	edx, DWORD PTR [rax+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r10d
	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	shr	edx, cl
	shl	ecx, 8

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, ecx

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	ecx, r11d
	shl	ecx, 8
	add	ecx, DWORD PTR [rbx+76]
	sub	ecx, edx
	mov	edi, ecx

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r9d, 2
	jge	SHORT $LN3@ZSTD_getMa
	jmp	SHORT $LN43@ZSTD_getMa
$LN7@ZSTD_getMa:

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	ecx, r11d
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, DWORD PTR [rbx+76]
	mov	edi, ecx
$LN43@ZSTD_getMa:

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	r11d, 20
	jb	SHORT $LN3@ZSTD_getMa

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	r11d, 9
	lea	edi, DWORD PTR [r11-9728]
	add	edi, ecx
$LN3@ZSTD_getMa:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	lea	r11, OFFSET FLAT:__ImageBase
	cmp	r8d, 127				; 0000007fH
	jbe	SHORT $LN31@ZSTD_getMa
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r8d
	mov	ecx, r10d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	add	ecx, 36					; 00000024H
	jmp	SHORT $LN32@ZSTD_getMa
$LN31@ZSTD_getMa:
	movzx	ecx, BYTE PTR ?ML_Code@?1??ZSTD_MLcode@@9@9[r8+r11]
$LN32@ZSTD_getMa:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	rax, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rcx*4]
	mov	eax, DWORD PTR [r8+rax]
	test	r9d, r9d
	je	SHORT $LN9@ZSTD_getMa

; 48   :     U32 const stat = rawStat + 1;

	lea	edx, DWORD PTR [rax+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	r10d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 51   :     U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;

	shl	edx, 8
	mov	ecx, r10d
	shl	r10d, 8
	shr	edx, cl

; 52   :     U32 const weight = BWeight + FWeight;

	add	edx, r10d

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	jmp	SHORT $LN10@ZSTD_getMa
$LN9@ZSTD_getMa:

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	r10d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	r10d, 8

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	edx, r10d
$LN10@ZSTD_getMa:
	mov	eax, DWORD PTR ML_bits[r8+r11]

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	add	edi, 51					; 00000033H
	shl	eax, 8
	add	eax, DWORD PTR [rbx+72]
	sub	eax, edx
	add	eax, edi

; 281  : 
; 282  :     DEBUGLOG(8, "ZSTD_getMatchPrice(ml:%u) = %u", matchLength, price);
; 283  :     return price;

	mov	rdi, QWORD PTR [rsp+24]

; 284  : }

	pop	rbx
	ret	0
ZSTD_getMatchPrice ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
optPtr$ = 8
litLength$ = 16
literals$ = 24
offsetCode$ = 32
matchLength$ = 40
ZSTD_updateStats PROC

; 291  : {

	mov	QWORD PTR [rsp+8], rbx

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	cmp	DWORD PTR [rcx+96], 2

; 291  : {

	mov	r10, r8
	mov	ebx, edx
	mov	r11, rcx

; 292  :     /* literals */
; 293  :     if (ZSTD_compressedLiterals(optPtr)) {

	je	SHORT $LN5@ZSTD_updat

; 294  :         U32 u;
; 295  :         for (u=0; u < litLength; u++)

	test	edx, edx
	je	SHORT $LN3@ZSTD_updat
	mov	ecx, ebx
	npad	7
$LL4@ZSTD_updat:

; 296  :             optPtr->litFreq[literals[u]] += ZSTD_LITFREQ_ADD;

	movzx	r8d, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	mov	rax, QWORD PTR [r11]
	add	DWORD PTR [rax+r8*4], 2
	sub	rcx, 1
	jne	SHORT $LL4@ZSTD_updat
$LN3@ZSTD_updat:

; 297  :         optPtr->litSum += litLength*ZSTD_LITFREQ_ADD;

	lea	eax, DWORD PTR [rbx+rbx]
	add	DWORD PTR [r11+48], eax
$LN5@ZSTD_updat:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	xor	edx, edx
	lea	r8, OFFSET FLAT:__ImageBase
	cmp	ebx, 63					; 0000003fH
	jbe	SHORT $LN11@ZSTD_updat
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, ebx
	mov	ecx, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	add	ecx, 19
	jmp	SHORT $LN12@ZSTD_updat
$LN11@ZSTD_updat:
	movzx	ecx, BYTE PTR ?LL_Code@?1??ZSTD_LLcode@@9@9[rbx+r8]
$LN12@ZSTD_updat:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 302  :         optPtr->litLengthFreq[llCode]++;

	mov	rax, QWORD PTR [r11+8]
	inc	DWORD PTR [rax+rcx*4]

; 303  :         optPtr->litLengthSum++;
; 304  :     }
; 305  : 
; 306  :     /* match offset code (0-2=>repCode; 3+=>offset+2) */
; 307  :     {   U32 const offCode = ZSTD_highbit32(offsetCode+1);

	lea	eax, DWORD PTR [r9+1]
	inc	DWORD PTR [r11+52]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 309  :         optPtr->offCodeFreq[offCode]++;

	mov	ecx, eax
	mov	rax, QWORD PTR [r11+24]
	inc	DWORD PTR [rax+rcx*4]

; 310  :         optPtr->offCodeSum++;
; 311  :     }
; 312  : 
; 313  :     /* match Length */
; 314  :     {   U32 const mlBase = matchLength - MINMATCH;

	mov	eax, DWORD PTR matchLength$[rsp]
	inc	DWORD PTR [r11+60]
	add	eax, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	cmp	eax, 127				; 0000007fH
	jbe	SHORT $LN19@ZSTD_updat
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 316  :         optPtr->matchLengthFreq[mlCode]++;

	mov	rax, QWORD PTR [r11+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	add	edx, 36					; 00000024H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 316  :         optPtr->matchLengthFreq[mlCode]++;

	inc	DWORD PTR [rax+rdx*4]

; 317  :         optPtr->matchLengthSum++;

	inc	DWORD PTR [r11+56]

; 318  :     }
; 319  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN19@ZSTD_updat:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	movzx	edx, BYTE PTR ?ML_Code@?1??ZSTD_MLcode@@9@9[rax+r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 316  :         optPtr->matchLengthFreq[mlCode]++;

	mov	rax, QWORD PTR [r11+16]

; 318  :     }
; 319  : }

	mov	rbx, QWORD PTR [rsp+8]
	inc	DWORD PTR [rax+rdx*4]
	inc	DWORD PTR [r11+56]
	ret	0
ZSTD_updateStats ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
memPtr$ = 8
length$ = 16
ZSTD_readMINMATCH PROC

; 326  : {

	mov	eax, DWORD PTR [rcx]

; 327  :     switch (length)

	cmp	edx, 3
	jne	SHORT $LN7@ZSTD_readM

; 328  :     {
; 329  :     default :
; 330  :     case 4 : return MEM_read32(memPtr);
; 331  :     case 3 : if (MEM_isLittleEndian())
; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
$LN7@ZSTD_readM:

; 333  :              else
; 334  :                 return MEM_read32(memPtr)>>8;
; 335  :     }
; 336  : }

	ret	0
ZSTD_readMINMATCH ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
ms$ = 8
nextToUpdate3$ = 16
ip$ = 24
ZSTD_insertAndFindFirstIndexHash3 PROC

; 344  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	imul	edi, DWORD PTR [r8], 900185344		; 35a7bd00H
	mov	eax, 32					; 00000020H
	sub	eax, DWORD PTR [rcx+40]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 349  :     U32 const target = (U32)(ip - base);

	mov	r10d, r8d
	mov	r9, QWORD PTR [rcx+8]
	mov	rsi, rdx
	mov	r11, QWORD PTR [rcx+56]
	sub	r10d, r9d
	mov	edx, DWORD PTR [rdx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	mov	ecx, eax
	shr	rdi, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 350  :     size_t const hash3 = ZSTD_hash3Ptr(ip, hashLog3);

	mov	ebx, eax

; 351  :     assert(hashLog3 > 0);
; 352  : 
; 353  :     while(idx < target) {

	cmp	edx, r10d
	jae	SHORT $LN17@ZSTD_inser
	add	r9, rdx
$LL2@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	imul	r8d, DWORD PTR [r9], 900185344		; 35a7bd00H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 355  :         idx++;

	lea	r9, QWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	mov	rcx, rbx
	shr	r8, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 354  :         hashTable3[ZSTD_hash3Ptr(base+idx, hashLog3)] = idx;

	mov	DWORD PTR [r11+r8*4], edx

; 355  :         idx++;

	inc	edx
	cmp	edx, r10d
	jb	SHORT $LL2@ZSTD_inser
$LN17@ZSTD_inser:

; 356  :     }
; 357  : 
; 358  :     *nextToUpdate3 = target;
; 359  :     return hashTable3[hash3];
; 360  : }

	mov	eax, DWORD PTR [r11+rdi*4]
	mov	rdi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+8]
	mov	DWORD PTR [rsi], r10d
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
ZSTD_insertAndFindFirstIndexHash3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
nbCompares$1$ = 32
r$1 = 32
r$2 = 32
matchEndIdx$1$ = 36
largerPtr$1$ = 40
tv818 = 48
btMask$1$ = 52
windowLow$1$ = 56
smallerPtr$1$ = 64
bestLength$1$ = 72
dictEnd$1$ = 80
base$1$ = 88
nextPtr$1$ = 96
commonLengthLarger$1$ = 104
commonLengthSmaller$1$ = 112
tv825 = 120
bt$1$ = 128
dictBase$1$ = 136
prefixStart$1$ = 144
current$1$ = 224
ms$ = 224
dummy32$ = 232
ip$ = 232
iend$ = 240
mls$ = 248
extDict$ = 256
ZSTD_insertBt1 PROC

; 373  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H

; 374  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 375  :     U32*   const hashTable = ms->hashTable;

	mov	r10, QWORD PTR [rcx+48]
	mov	r14, rdx

; 376  :     U32    const hashLog = cParams->hashLog;
; 377  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [rcx+192]
	mov	r13, r8
	mov	r11, rcx
	mov	r8d, r9d
	mov	rcx, r14
	call	ZSTD_hashPtr

; 378  :     U32*   const bt = ms->chainTable;

	mov	rcx, QWORD PTR [r11+64]

; 379  :     U32    const btLog  = cParams->chainLog - 1;
; 380  :     U32    const btMask = (1 << btLog) - 1;
; 381  :     U32 matchIndex = hashTable[h];

	lea	rdx, QWORD PTR [r10+rax*4]

; 382  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 383  :     const BYTE* const base = ms->window.base;

	mov	rax, QWORD PTR [r11+8]
	xor	r12d, r12d

; 384  :     const BYTE* const dictBase = ms->window.dictBase;
; 385  :     const U32 dictLimit = ms->window.dictLimit;
; 386  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	r15d, DWORD PTR [r11+24]
	mov	ebp, 1
	mov	edi, DWORD PTR [rdx]
	mov	ebx, ebp
	mov	QWORD PTR bt$1$[rsp], rcx

; 387  :     const BYTE* const prefixStart = base + dictLimit;
; 388  :     const BYTE* match;
; 389  :     const U32 current = (U32)(ip-base);

	mov	r8d, r14d
	mov	ecx, DWORD PTR [r11+188]
	sub	r8d, eax

; 390  :     const U32 btLow = btMask >= current ? 0 : current - btMask;
; 391  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	r10, QWORD PTR bt$1$[rsp]
	dec	ecx
	shl	ebx, cl
	mov	r9d, r12d
	mov	rcx, QWORD PTR [r11+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rsp], rcx
	mov	esi, r12d
	add	rcx, r15
	mov	QWORD PTR base$1$[rsp], rax
	mov	QWORD PTR dictEnd$1$[rsp], rcx
	lea	rcx, QWORD PTR [r15+rax]
	mov	QWORD PTR prefixStart$1$[rsp], rcx
	mov	eax, r8d
	sub	eax, ebx
	mov	DWORD PTR current$1$[rsp], r8d
	cmp	ebx, r8d
	mov	DWORD PTR btMask$1$[rsp], ebx
	mov	ecx, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r12
	cmovb	ecx, eax
	mov	QWORD PTR commonLengthLarger$1$[rsp], r12
	mov	eax, r8d
	mov	DWORD PTR tv818[rsp], ecx
	and	eax, ebx
	mov	QWORD PTR tv825[rsp], r15
	add	eax, eax

; 392  :     U32* largerPtr  = smallerPtr + 1;
; 393  :     U32 dummy32;   /* to be nullified at the end */
; 394  :     U32 const windowLow = ms->window.lowLimit;
; 395  :     U32 matchEndIdx = current+8+1;
; 396  :     size_t bestLength = 8;

	mov	QWORD PTR bestLength$1$[rsp], 8
	add	r8d, 9
	mov	DWORD PTR matchEndIdx$1$[rsp], r8d
	lea	r14, QWORD PTR [r10+rax*4]
	mov	eax, DWORD PTR [r11+28]
	lea	rcx, QWORD PTR [r14+4]
	mov	QWORD PTR smallerPtr$1$[rsp], r14
	mov	QWORD PTR largerPtr$1$[rsp], rcx

; 397  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r11+196]
	shl	ebp, cl

; 398  : #ifdef ZSTD_C_PREDICT
; 399  :     U32 predictedSmall = *(bt + 2*((current-1)&btMask) + 0);
; 400  :     U32 predictedLarge = *(bt + 2*((current-1)&btMask) + 1);
; 401  :     predictedSmall += (predictedSmall>0);
; 402  :     predictedLarge += (predictedLarge>0);
; 403  : #endif /* ZSTD_C_PREDICT */
; 404  : 
; 405  :     DEBUGLOG(8, "ZSTD_insertBt1 (%u)", current);
; 406  : 
; 407  :     assert(ip <= iend-8);   /* required for h calculation */
; 408  :     hashTable[h] = current;   /* Update Hash Table */

	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR windowLow$1$[rsp], eax
	mov	DWORD PTR [rdx], ecx

; 409  : 
; 410  :     assert(windowLow > 0);
; 411  :     while (nbCompares-- && (matchIndex >= windowLow)) {

	test	ebp, ebp
	je	$LN88@ZSTD_inser
	mov	r11, QWORD PTR ip$[rsp]
	npad	10
$LL2@ZSTD_inser:
	dec	ebp
	mov	DWORD PTR nbCompares$1$[rsp], ebp
	cmp	edi, eax
	jb	$LN87@ZSTD_inser

; 412  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, edi
	and	eax, ebx

; 413  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rbx, rsi
	add	eax, eax
	cmp	r9, rsi
	cmovb	rbx, r9
	lea	r10, QWORD PTR [r10+rax*4]
	mov	QWORD PTR nextPtr$1$[rsp], r10

; 414  :         assert(matchIndex < current);
; 415  : 
; 416  : #ifdef ZSTD_C_PREDICT   /* note : can create issues when hlog small <= 11 */
; 417  :         const U32* predictPtr = bt + 2*((matchIndex-1) & btMask);   /* written this way, as bt is a roll buffer */
; 418  :         if (matchIndex == predictedSmall) {
; 419  :             /* no need to check length, result known */
; 420  :             *smallerPtr = matchIndex;
; 421  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
; 422  :             smallerPtr = nextPtr+1;               /* new "smaller" => larger of match */
; 423  :             matchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 424  :             predictedSmall = predictPtr[1] + (predictPtr[1]>0);
; 425  :             continue;
; 426  :         }
; 427  :         if (matchIndex == predictedLarge) {
; 428  :             *largerPtr = matchIndex;
; 429  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
; 430  :             largerPtr = nextPtr;
; 431  :             matchIndex = nextPtr[0];
; 432  :             predictedLarge = predictPtr[0] + (predictPtr[0]>0);
; 433  :             continue;
; 434  :         }
; 435  : #endif
; 436  : 
; 437  :         if (!extDict || (matchIndex+matchLength >= dictLimit)) {

	cmp	DWORD PTR extDict$[rsp], r12d
	je	$LN6@ZSTD_inser
	mov	esi, edi
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, r15
	jae	$LN6@ZSTD_inser

; 441  :         } else {
; 442  :             match = dictBase + matchIndex;

	mov	r15, QWORD PTR dictBase$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 443  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	mov	rbp, QWORD PTR ip$[rsp]
	add	r15, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 443  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	add	rbp, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rbp
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 443  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r15+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN66@ZSTD_inser

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	mov	r8, r13
	call	ZSTD_count
	add	r14, rax
$LN66@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 444  :             if (matchIndex+matchLength >= dictLimit)

	mov	r10, QWORD PTR nextPtr$1$[rsp]
	add	rbx, r14
	mov	r14, QWORD PTR smallerPtr$1$[rsp]
	mov	ebp, DWORD PTR nbCompares$1$[rsp]
	mov	r11, QWORD PTR ip$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, QWORD PTR tv825[rsp]
	jb	$LN7@ZSTD_inser

; 445  :                 match = base + matchIndex;   /* to prepare for next usage of match[matchLength] */

	mov	r15, QWORD PTR base$1$[rsp]
	add	r15, rsi
	jmp	$LN7@ZSTD_inser
$LN6@ZSTD_inser:

; 440  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	lea	rax, QWORD PTR [rbx+r11]
	mov	r15d, edi
	add	r15, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [r13-7]
	mov	r9, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 440  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	lea	rdx, QWORD PTR [r15+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN25@ZSTD_inser

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN27@ZSTD_inser

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$2[rsp], r12d
	je	SHORT $LN42@ZSTD_inser
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN23@ZSTD_inser
$LN42@ZSTD_inser:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, r12d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN23@ZSTD_inser
$LN27@ZSTD_inser:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN25@ZSTD_inser
	npad	11
$LL24@ZSTD_inser:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN28@ZSTD_inser
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL24@ZSTD_inser
$LN25@ZSTD_inser:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r13-3]
	cmp	rax, rcx
	jae	SHORT $LN29@ZSTD_inser
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN29@ZSTD_inser
	add	rax, 4
	add	rdx, 4
$LN29@ZSTD_inser:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r13-1]
	cmp	rax, rcx
	jae	SHORT $LN30@ZSTD_inser
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN30@ZSTD_inser
	add	rax, 2
	add	rdx, 2
$LN30@ZSTD_inser:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r13
	jae	SHORT $LN31@ZSTD_inser
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN31@ZSTD_inser
	inc	rax
$LN31@ZSTD_inser:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r9
$LN23@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 440  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	add	rbx, rcx
$LN7@ZSTD_inser:

; 446  :         }
; 447  : 
; 448  :         if (matchLength > bestLength) {

	mov	r8d, DWORD PTR matchEndIdx$1$[rsp]
	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN9@ZSTD_inser

; 449  :             bestLength = matchLength;
; 450  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, r8d
	mov	QWORD PTR bestLength$1$[rsp], rbx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN9@ZSTD_inser

; 451  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	r8d, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], r8d
$LN9@ZSTD_inser:

; 452  :         }
; 453  : 
; 454  :         if (ip+matchLength == iend) {   /* equal : no way to know if inf or sup */

	lea	rax, QWORD PTR [rbx+r11]
	cmp	rax, r13
	je	$LN87@ZSTD_inser

; 455  :             break;   /* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */
; 456  :         }
; 457  : 
; 458  :         if (match[matchLength] < ip[matchLength]) {  /* necessarily within buffer */

	movzx	eax, BYTE PTR [rax]
	cmp	BYTE PTR [r15+rbx], al
	jae	SHORT $LN11@ZSTD_inser

; 459  :             /* match is smaller than current */
; 460  :             *smallerPtr = matchIndex;             /* update smaller idx */
; 461  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	r9, rbx
	mov	DWORD PTR [r14], edi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 462  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	cmp	edi, DWORD PTR tv818[rsp]
	jbe	$LN74@ZSTD_inser

; 463  :             smallerPtr = nextPtr+1;               /* new "candidate" => larger than match, which was smaller than target */
; 464  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous and closer to current */

	mov	edi, DWORD PTR [r10+4]
	lea	r14, QWORD PTR [r10+4]

; 465  :         } else {

	mov	rsi, QWORD PTR commonLengthLarger$1$[rsp]
	mov	QWORD PTR smallerPtr$1$[rsp], r14
	jmp	SHORT $LN12@ZSTD_inser
$LN28@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$1[rsp], r12d
	je	SHORT $LN58@ZSTD_inser
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	SHORT $LN23@ZSTD_inser
$LN58@ZSTD_inser:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r12d

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	$LN23@ZSTD_inser
$LN11@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 468  :             commonLengthLarger = matchLength;

	mov	rsi, rbx
	mov	rax, QWORD PTR largerPtr$1$[rsp]
	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], edi

; 469  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	cmp	edi, DWORD PTR tv818[rsp]
	jbe	$LN75@ZSTD_inser

; 470  :             largerPtr = nextPtr;
; 471  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r10]
	mov	r9, QWORD PTR commonLengthSmaller$1$[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], r10
$LN12@ZSTD_inser:

; 409  : 
; 410  :     assert(windowLow > 0);
; 411  :     while (nbCompares-- && (matchIndex >= windowLow)) {

	test	ebp, ebp
	je	SHORT $LN87@ZSTD_inser
	mov	r15, QWORD PTR tv825[rsp]
	mov	ebx, DWORD PTR btMask$1$[rsp]
	mov	eax, DWORD PTR windowLow$1$[rsp]
	mov	r10, QWORD PTR bt$1$[rsp]
	jmp	$LL2@ZSTD_inser
$LN74@ZSTD_inser:

; 462  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	lea	r14, QWORD PTR dummy32$[rsp]
$LN87@ZSTD_inser:

; 472  :     }   }
; 473  : 
; 474  :     *smallerPtr = *largerPtr = 0;

	mov	ecx, DWORD PTR current$1$[rsp]
$LN88@ZSTD_inser:
	mov	rax, QWORD PTR largerPtr$1$[rsp]
$LN77@ZSTD_inser:
	mov	DWORD PTR [rax], r12d

; 475  :     {   U32 positions = 0;
; 476  :         if (bestLength > 384) positions = MIN(192, (U32)(bestLength - 384));   /* speed optimization */

	mov	rax, QWORD PTR bestLength$1$[rsp]
	mov	DWORD PTR [r14], r12d
	cmp	rax, 384				; 00000180H
	jbe	SHORT $LN19@ZSTD_inser
	add	eax, -384				; fffffe80H
	mov	edx, 192				; 000000c0H
	cmp	eax, edx
	cmova	eax, edx
	mov	r12d, eax
$LN19@ZSTD_inser:

; 477  :         assert(matchEndIdx > current + 8);
; 478  :         return MAX(positions, matchEndIdx - (current + 8));
; 479  :     }
; 480  : }

	mov	rbx, QWORD PTR [rsp+240]
	sub	r8d, ecx
	lea	ecx, DWORD PTR [r8-8]
	cmp	r12d, ecx
	cmovbe	r12d, ecx
	mov	eax, r12d
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN75@ZSTD_inser:

; 409  : 
; 410  :     assert(windowLow > 0);
; 411  :     while (nbCompares-- && (matchIndex >= windowLow)) {

	mov	ecx, DWORD PTR current$1$[rsp]

; 469  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	lea	rax, QWORD PTR dummy32$[rsp]
	jmp	SHORT $LN77@ZSTD_inser
ZSTD_insertBt1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
ms$ = 80
ip$ = 88
iend$ = 96
mls$ = 104
dictMode$ = 112
ZSTD_updateTree_internal PROC

; 487  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 488  :     const BYTE* const base = ms->window.base;

	mov	r14, QWORD PTR [rcx+8]
	mov	rdi, rdx

; 489  :     U32 const target = (U32)(ip - base);
; 490  :     U32 idx = ms->nextToUpdate;

	mov	ebx, DWORD PTR [rcx+36]
	sub	edi, r14d
	mov	r15d, r9d
	mov	r12, r8
	mov	rsi, rcx

; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN9@ZSTD_updat

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	QWORD PTR [rsp+80], rbp
	xor	ebp, ebp
	cmp	DWORD PTR dictMode$[rsp], 1
	sete	bpl
	npad	13
$LL2@ZSTD_updat:
	mov	edx, ebx
	mov	r9d, r15d
	add	rdx, r14
	mov	DWORD PTR [rsp+32], ebp
	mov	r8, r12
	mov	rcx, rsi
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL2@ZSTD_updat

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	rbp, QWORD PTR [rsp+80]
	mov	DWORD PTR [rsi+36], edi
	jmp	SHORT $LN3@ZSTD_updat
$LN9@ZSTD_updat:
	mov	DWORD PTR [rcx+36], edi
$LN3@ZSTD_updat:

; 502  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
ZSTD_updateTree_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
mnum$1$ = 48
current$1$ = 52
matchLow$1$ = 56
nbCompares$1$ = 60
matchEndIdx$1$ = 64
dictLimit$1$ = 68
dmsIndexDelta$1$ = 72
base$1$ = 80
dmsLowLimit$1$ = 88
tv1933 = 96
bestLength$1$ = 104
dictBase$1$ = 112
smallerPtr$1$ = 120
windowLow$1$ = 128
sufficient_len$1$ = 132
tv1945 = 136
dmsHashLog$1$ = 140
dmsBtMask$1$ = 144
dmsHighLimit$1$ = 148
dmsBtLow$1$ = 152
dmsEnd$1$ = 160
commonLengthLarger$1$ = 168
commonLengthSmaller$2$ = 168
dms$1$ = 176
commonLengthLarger$2$ = 176
largerPtr$1$ = 184
btMask$1$ = 192
dmsBase$1$ = 200
dmsBt$1$ = 208
bt$1$ = 208
commonLengthSmaller$1$ = 216
tv1934 = 224
matches$ = 320
ms$ = 328
nextToUpdate3$ = 336
ip$ = 344
iLimit$ = 352
dictMode$ = 360
rep$ = 368
tv2176 = 376
r$1 = 376
r$2 = 376
dummy32$ = 376
ll0$ = 376
tv1930 = 384
lengthToBeat$ = 384
mls$ = 392
ZSTD_insertBtAndGetAllMatches PROC

; 518  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 248				; 000000f8H

; 519  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [rdx+204]
	mov	ecx, 4095				; 00000fffH

; 521  :     const BYTE* const base = ms->window.base;

	mov	r11, QWORD PTR [rdx+8]
	cmp	eax, ecx

; 522  :     U32 const current = (U32)(ip-base);
; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, DWORD PTR mls$[rsp]
	mov	r10d, r9d
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rsp], r11
	mov	eax, DWORD PTR [rdx+192]
	sub	r10d, r11d
	xor	ebx, ebx
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	cmp	DWORD PTR mls$[rsp], 3
	mov	esi, ebx
	mov	rbp, r9
	mov	DWORD PTR current$1$[rsp], r10d
	mov	r9, QWORD PTR [rdx+48]
	setne	sil
	mov	r13, rdx
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	mov	edx, eax
	mov	rcx, rbp
	add	esi, 3
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r12d, DWORD PTR [r9+rax*4]
	lea	rax, QWORD PTR [r9+rax*4]

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r13+188]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	xor	r11d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	r9, QWORD PTR [r13+64]

; 529  :     U32 const btLog = cParams->chainLog - 1;

	dec	ecx

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r15d, DWORD PTR [r13+24]
	mov	r8d, 1
	mov	QWORD PTR tv1934[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rax, QWORD PTR [r13+16]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	edi, 1
	mov	QWORD PTR dictBase$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	shl	r8d, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	dec	r8d

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	sub	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	r8d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	QWORD PTR bt$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ebx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	DWORD PTR btMask$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rsp], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	DWORD PTR tv1945[rsp], ecx

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r10d
	mov	ecx, DWORD PTR [r13+184]
	shl	edx, cl
	mov	ecx, DWORD PTR [r13+28]

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	ebx, edx
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	QWORD PTR tv1933[rsp], r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 543  :     U32 mnum = 0;

	mov	DWORD PTR mnum$1$[rsp], r11d
	mov	eax, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ebx, ecx
	cmp	DWORD PTR [r13+32], r11d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ebx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r13+196]
	test	ebx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR windowLow$1$[rsp], ebx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, ebx

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	shl	edi, cl
	mov	DWORD PTR matchLow$1$[rsp], eax
	mov	eax, r8d
	and	eax, r10d
	mov	DWORD PTR nbCompares$1$[rsp], edi
	add	eax, eax
	lea	rax, QWORD PTR [r9+rax*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rsp], 2
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [r10+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	jne	$LN49@ZSTD_inser
	mov	r8, QWORD PTR [r13+176]

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	eax, ebx
	mov	QWORD PTR dms$1$[rsp], r8
	mov	rdx, QWORD PTR [r8]
	mov	r11, QWORD PTR [r8+8]
	mov	r9d, edx

; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r8+188]
	sub	r9d, r11d
	sub	eax, r9d
	mov	QWORD PTR dmsEnd$1$[rsp], rdx
	mov	edx, DWORD PTR [r8+28]
	dec	ecx
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [r8+192]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, 1
	mov	DWORD PTR dmsHashLog$1$[rsp], eax

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r9d
	shl	r8d, cl
	sub	eax, edx
	dec	r8d
	mov	QWORD PTR dmsBase$1$[rsp], r11
	mov	DWORD PTR dmsHighLimit$1$[rsp], r9d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	DWORD PTR dmsBtMask$1$[rsp], r8d
	cmp	r8d, eax
	jae	SHORT $LN69@ZSTD_inser
	mov	ecx, r9d
	sub	ecx, r8d
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	jmp	SHORT $LN70@ZSTD_inser
$LN49@ZSTD_inser:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	edx, r11d
	mov	QWORD PTR dms$1$[rsp], r11
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	QWORD PTR dmsBase$1$[rsp], r11
	mov	QWORD PTR dmsEnd$1$[rsp], r11
	mov	DWORD PTR dmsHighLimit$1$[rsp], r11d

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	DWORD PTR dmsIndexDelta$1$[rsp], r11d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	DWORD PTR dmsBtMask$1$[rsp], r11d
$LN69@ZSTD_inser:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], edx
$LN70@ZSTD_inser:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;
; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	r11d, DWORD PTR ll0$[rsp]
	mov	r9d, DWORD PTR lengthToBeat$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, r11d
	mov	r13, QWORD PTR iLimit$[rsp]
	dec	r9d
	mov	QWORD PTR bestLength$1$[rsp], r9
	lea	eax, DWORD PTR [r11+3]
	cmp	r11d, eax
	jae	$LN280@ZSTD_inser
	mov	rcx, QWORD PTR rep$[rsp]
	mov	edx, r10d
	sub	edx, r15d
	mov	edi, r15d
	mov	DWORD PTR tv1930[rsp], edx
	lea	r15, QWORD PTR [rcx+r11*4]
	npad	2
$LL4@ZSTD_inser:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN71@ZSTD_inser
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN72@ZSTD_inser
$LN71@ZSTD_inser:
	mov	eax, DWORD PTR [r15]
$LN72@ZSTD_inser:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r10d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r10d, r10d
	cmp	ecx, edx
	jae	$LN9@ZSTD_inser

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, eax
	mov	edx, esi
	mov	rax, rbp
	mov	rcx, rbp
	sub	rax, r11
	mov	r8d, DWORD PTR [rax]
	call	ZSTD_readMINMATCH
	mov	ecx, r8d
	shl	ecx, 8
	cmp	DWORD PTR mls$[rsp], 3
	cmove	r8d, ecx
	xor	ecx, ecx
	cmp	eax, r8d
	sete	cl
	xor	eax, eax
	cmp	r9d, ebx
	setae	al
	test	ecx, eax
	je	$LN291@ZSTD_inser

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	rcx, QWORD PTR [rsi+rbp]
	mov	edx, esi
	sub	rdx, r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [r13-7]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	add	rdx, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r9, rcx

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN89@ZSTD_inser

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN91@ZSTD_inser

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN106@ZSTD_inser
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+rsi]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN291@ZSTD_inser
$LN106@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+rsi]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN291@ZSTD_inser
$LN91@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN89@ZSTD_inser
	npad	3
$LL88@ZSTD_inser:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN92@ZSTD_inser
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL88@ZSTD_inser
$LN89@ZSTD_inser:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r13-3]
	cmp	rcx, rax
	jae	SHORT $LN93@ZSTD_inser
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN93@ZSTD_inser
	add	rcx, 4
	add	rdx, 4
$LN93@ZSTD_inser:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r13-1]
	cmp	rcx, rax
	jae	SHORT $LN94@ZSTD_inser
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN94@ZSTD_inser
	add	rcx, 2
	add	rdx, 2
$LN94@ZSTD_inser:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r13
	jae	SHORT $LN95@ZSTD_inser
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN95@ZSTD_inser
	inc	rcx
$LN95@ZSTD_inser:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+rsi]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN291@ZSTD_inser
$LN92@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN122@ZSTD_inser
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+rsi]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN291@ZSTD_inser
$LN122@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+rsi]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN291@ZSTD_inser
$LN9@ZSTD_inser:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	eax, DWORD PTR dictMode$[rsp]
	mov	r8d, r9d
	cmp	eax, 2
	jne	$LN73@ZSTD_inser
	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	r8, rdx
	add	r8, QWORD PTR dmsBase$1$[rsp]
	sub	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, edi
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN13@ZSTD_inser

; 327  :     switch (length)

	cmp	DWORD PTR mls$[rsp], 3
	mov	eax, DWORD PTR [rbp]
	mov	ecx, DWORD PTR [r8]
	jne	SHORT $LN165@ZSTD_inser

; 328  :     {
; 329  :     default :
; 330  :     case 4 : return MEM_read32(memPtr);
; 331  :     case 3 : if (MEM_isLittleEndian())
; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	shl	ecx, 8
$LN165@ZSTD_inser:

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, ecx
	jne	$LN13@ZSTD_inser
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [rsi+r8]
	lea	rdi, QWORD PTR [rsi+rbp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
	mov	rax, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	sub	rax, r11
	add	rcx, rax
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, rdi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dmsEnd$1$[rsp]
	jne	$LN146@ZSTD_inser

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rax+rdi]
	add	rdx, QWORD PTR tv1933[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	jmp	$LN303@ZSTD_inser
$LN73@ZSTD_inser:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, r8

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, 1
	jne	$LN291@ZSTD_inser
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, ebx
	cmp	ecx, eax
	mov	ecx, edi
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN291@ZSTD_inser

; 327  :     switch (length)

	cmp	DWORD PTR mls$[rsp], 3
	mov	eax, DWORD PTR [rbp]
	mov	ecx, DWORD PTR [r11]
	jne	SHORT $LN144@ZSTD_inser

; 328  :     {
; 329  :     default :
; 330  :     case 4 : return MEM_read32(memPtr);
; 331  :     case 3 : if (MEM_isLittleEndian())
; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	shl	ecx, 8
$LN144@ZSTD_inser:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, ecx
	jne	SHORT $LN291@ZSTD_inser
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR tv1933[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	rdi, QWORD PTR [rsi+rbp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	add	rcx, QWORD PTR dictBase$1$[rsp]
	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	eax, esi
	add	r11, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rdi
	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, rdi
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	r9, QWORD PTR tv1933[rsp]
	mov	rbx, rax
	lea	rcx, QWORD PTR [rax+r11]
	mov	rax, QWORD PTR dictBase$1$[rsp]
	add	rax, r9
	cmp	rcx, rax
	jne	SHORT $LN146@ZSTD_inser

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR base$1$[rsp]
	lea	rcx, QWORD PTR [rbx+rdi]
	add	rdx, r9
$LN303@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	mov	r8, r13
	call	ZSTD_count
	add	rbx, rax
$LN146@ZSTD_inser:
	mov	edi, DWORD PTR dictLimit$1$[rsp]
	lea	r10d, DWORD PTR [rbx+rsi]
	mov	ebx, DWORD PTR windowLow$1$[rsp]
$LN291@ZSTD_inser:
	mov	r11d, DWORD PTR ll0$[rsp]
$LN13@ZSTD_inser:
	mov	r9, QWORD PTR bestLength$1$[rsp]
	mov	edx, r10d
	cmp	rdx, r9
	jbe	SHORT $LN2@ZSTD_inser

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, r14d
	mov	rcx, QWORD PTR matches$[rsp]
	sub	eax, r11d
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax
	mov	r9d, edx
	mov	DWORD PTR [rcx+4], r10d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r10+rbp]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, r13
	mov	DWORD PTR mnum$1$[rsp], r8d
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	SHORT $LN243@ZSTD_inser
$LN2@ZSTD_inser:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r14d
	lea	eax, DWORD PTR [r11+3]
	add	r15, 4
	cmp	r14d, eax
	jae	SHORT $LN287@ZSTD_inser
	mov	edx, DWORD PTR tv1930[rsp]
	mov	rcx, QWORD PTR rep$[rsp]
	mov	r10d, DWORD PTR current$1$[rsp]
	jmp	$LL4@ZSTD_inser
$LN243@ZSTD_inser:

; 605  :                     return mnum;

	mov	eax, r8d
	jmp	$LN1@ZSTD_inser
$LN287@ZSTD_inser:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edi, DWORD PTR nbCompares$1$[rsp]
	mov	r15d, DWORD PTR dictLimit$1$[rsp]
$LN280@ZSTD_inser:

; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	DWORD PTR mls$[rsp], 3
	jne	$LN293@ZSTD_inser
	cmp	r9, 3
	jae	$LN293@ZSTD_inser

; 345  :     U32* const hashTable3 = ms->hashTable3;

	mov	r14, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	imul	ebx, DWORD PTR [rbp], 900185344		; 35a7bd00H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 349  :     U32 const target = (U32)(ip - base);

	mov	r10d, ebp
	mov	rsi, QWORD PTR nextToUpdate3$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	sub	ecx, DWORD PTR [r14+40]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 347  :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [r14+8]
	mov	r8d, DWORD PTR [rsi]

; 349  :     U32 const target = (U32)(ip - base);

	sub	r10d, edx
	mov	r11, QWORD PTR [r14+56]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	shr	rbx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 353  :     while(idx < target) {

	cmp	r8d, r10d
	jae	SHORT $LN174@ZSTD_inser
	lea	r9, QWORD PTR [rdx+r8]
	npad	5
$LL173@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	imul	edx, DWORD PTR [r9], 900185344		; 35a7bd00H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 355  :         idx++;

	lea	r9, QWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 606  : static U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 354  :         hashTable3[ZSTD_hash3Ptr(base+idx, hashLog3)] = idx;

	mov	DWORD PTR [r11+rdx*4], r8d

; 355  :         idx++;

	inc	r8d
	cmp	r8d, r10d
	jb	SHORT $LL173@ZSTD_inser
$LN174@ZSTD_inser:

; 359  :     return hashTable3[hash3];

	mov	edx, DWORD PTR [r11+rbx*4]

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);
; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	xor	ecx, ecx
	mov	ebx, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	sub	ebx, edx
	cmp	edx, r8d

; 358  :     *nextToUpdate3 = target;

	mov	DWORD PTR [rsi], r10d

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);
; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR dictMode$[rsp]
	setae	cl
	xor	eax, eax
	cmp	ebx, 262144				; 00040000H
	setb	al
	test	ecx, eax
	je	$LN295@ZSTD_inser

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	test	esi, -3					; fffffffdH
	je	SHORT $LN20@ZSTD_inser
	cmp	edx, r15d
	jae	SHORT $LN20@ZSTD_inser

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;

	mov	r9, QWORD PTR dictBase$1$[rsp]

; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	rcx, rbp
	mov	rax, QWORD PTR base$1$[rsp]
	add	rdx, r9
	mov	r8d, r15d
	add	rax, r8
	add	r9, r8
	mov	r8, r13
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	jmp	SHORT $LN300@ZSTD_inser
$LN20@ZSTD_inser:

; 615  :                 const BYTE* const match = base + matchIndex3;

	add	rdx, QWORD PTR base$1$[rsp]

; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, r13
	mov	rcx, rbp
	call	ZSTD_count
$LN300@ZSTD_inser:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, rax
	cmp	rax, 3
	jb	SHORT $LN296@ZSTD_inser

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$[rsp]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	xor	r8d, r8d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	r11d, 1
	lea	eax, DWORD PTR [rbx+2]
	mov	DWORD PTR mnum$1$[rsp], r11d
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rcx+4], r9d
	lea	rcx, QWORD PTR [r9+rbp]
	cmp	rcx, r13
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	xor	edx, edx
	cmp	r9, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN299@ZSTD_inser

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	mov	ecx, DWORD PTR current$1$[rsp]
	inc	ecx
	mov	DWORD PTR [r14+36], ecx

; 635  :                     return 1;

	jmp	$LN301@ZSTD_inser
$LN293@ZSTD_inser:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	esi, DWORD PTR dictMode$[rsp]
$LN296@ZSTD_inser:
	mov	r11d, DWORD PTR mnum$1$[rsp]
$LN299@ZSTD_inser:
	mov	r8d, DWORD PTR matchLow$1$[rsp]
$LN22@ZSTD_inser:
	mov	rax, QWORD PTR tv1934[rsp]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	edi, edi
	je	$LN253@ZSTD_inser
	npad	11
$LL5@ZSTD_inser:
	dec	edi
	mov	DWORD PTR tv2176[rsp], edi
	mov	r10d, edi
	cmp	r12d, r8d
	jb	$LN297@ZSTD_inser

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]
	mov	rcx, QWORD PTR bt$1$[rsp]
	and	eax, r12d
	add	eax, eax
	lea	r15, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rsp]
	cmp	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rsp]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	esi, -3					; fffffffdH
	je	$LN25@ZSTD_inser
	mov	rdx, QWORD PTR tv1933[rsp]
	mov	esi, r12d
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, rdx
	jae	$LN25@ZSTD_inser

; 654  :             match = dictBase + matchIndex;

	mov	r8, QWORD PTR dictBase$1$[rsp]

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	add	rbp, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rbp
	lea	rcx, QWORD PTR [rdx+r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 654  :             match = dictBase + matchIndex;

	lea	r14, QWORD PTR [rsi+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r14+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	rdx, QWORD PTR tv1933[rsp]
	mov	rdi, rax
	lea	rcx, QWORD PTR [rax+r11]
	mov	rax, QWORD PTR dictBase$1$[rsp]
	mov	r11, QWORD PTR base$1$[rsp]
	add	rax, rdx
	cmp	rcx, rax
	jne	SHORT $LN227@ZSTD_inser

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rdi+rbp]
	mov	r8, r13
	add	rdx, r11
	call	ZSTD_count
	mov	rdx, QWORD PTR tv1933[rsp]
	add	rdi, rax
$LN227@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 657  :             if (matchIndex+matchLength >= dictLimit)

	mov	r10d, DWORD PTR tv2176[rsp]
	add	rbx, rdi
	mov	rbp, QWORD PTR ip$[rsp]
	mov	edi, r10d
	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rax, rdx
	jb	$LN27@ZSTD_inser

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	lea	r14, QWORD PTR [rsi+r11]
	jmp	$LN27@ZSTD_inser
$LN295@ZSTD_inser:

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);
; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r11d, DWORD PTR mnum$1$[rsp]
	jmp	$LN22@ZSTD_inser
$LN25@ZSTD_inser:

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rax, QWORD PTR [rbx+rbp]
	mov	r14d, r12d
	add	r14, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [r13-7]
	mov	r9, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r14+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN186@ZSTD_inser

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN188@ZSTD_inser

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN203@ZSTD_inser
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN184@ZSTD_inser
$LN203@ZSTD_inser:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN184@ZSTD_inser
$LN188@ZSTD_inser:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN186@ZSTD_inser
	npad	10
$LL185@ZSTD_inser:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN189@ZSTD_inser
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL185@ZSTD_inser
$LN186@ZSTD_inser:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r13-3]
	cmp	rax, rcx
	jae	SHORT $LN190@ZSTD_inser
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN190@ZSTD_inser
	add	rax, 4
	add	rdx, 4
$LN190@ZSTD_inser:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r13-1]
	cmp	rax, rcx
	jae	SHORT $LN191@ZSTD_inser
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN191@ZSTD_inser
	add	rax, 2
	add	rdx, 2
$LN191@ZSTD_inser:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r13
	jae	SHORT $LN192@ZSTD_inser
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN192@ZSTD_inser
	inc	rax
$LN192@ZSTD_inser:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r9
$LN184@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rcx
$LN27@ZSTD_inser:

; 661  :         if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	$LN292@ZSTD_inser

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r12d
	cmp	rbx, rax
	jbe	SHORT $LN29@ZSTD_inser

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+r12]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN29@ZSTD_inser:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r11d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rsp]
	sub	eax, r12d
	add	eax, 2

; 669  :             matches[mnum].len = (U32)matchLength;

	mov	DWORD PTR [rcx+r11*8+4], edx
	lea	rcx, QWORD PTR [rcx+r11*8]

; 670  :             mnum++;

	inc	r11d
	mov	DWORD PTR [rcx], eax

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	lea	rax, QWORD PTR [rbx+rbp]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	cmp	rax, r13
	mov	DWORD PTR mnum$1$[rsp], r11d
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN30@ZSTD_inser

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	mov	r14d, DWORD PTR dictMode$[rsp]
	xor	edi, edi
	cmp	r14d, 2
	cmovne	edi, r10d
	jmp	$LN302@ZSTD_inser
$LN189@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN219@ZSTD_inser
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	$LN184@ZSTD_inser
$LN219@ZSTD_inser:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	$LN184@ZSTD_inser
$LN292@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 661  :         if (matchLength > bestLength) {

	mov	r11d, DWORD PTR mnum$1$[rsp]
$LN30@ZSTD_inser:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rbp]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN32@ZSTD_inser

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], r12d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r12d, DWORD PTR tv1945[rsp]
	jbe	SHORT $LN245@ZSTD_inser

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r12d, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN33@ZSTD_inser
$LN32@ZSTD_inser:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rcx], r12d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r12d, DWORD PTR tv1945[rsp]
	jbe	SHORT $LN246@ZSTD_inser

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r12d, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN33@ZSTD_inser:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	edi, edi
	je	SHORT $LN253@ZSTD_inser
	mov	esi, DWORD PTR dictMode$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL5@ZSTD_inser
$LN245@ZSTD_inser:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r14d, DWORD PTR dictMode$[rsp]
	lea	rax, QWORD PTR dummy32$[rsp]
	jmp	SHORT $LN6@ZSTD_inser
$LN246@ZSTD_inser:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	SHORT $LN297@ZSTD_inser
$LN253@ZSTD_inser:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	edi
$LN297@ZSTD_inser:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	r14d, DWORD PTR dictMode$[rsp]
$LN302@ZSTD_inser:
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN6@ZSTD_inser:
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], 0
	mov	DWORD PTR [rax], 0

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	r14d, 2
	jne	$LN284@ZSTD_inser
	test	edi, edi
	je	$LN284@ZSTD_inser

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	r8d, DWORD PTR mls$[rsp]
	mov	rcx, rbp
	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rsp]
	mov	rcx, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rsp], r8
	mov	esi, DWORD PTR [rcx+rax*4]

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR commonLengthLarger$2$[rsp], rcx
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rdx
	npad	8
$LL7@ZSTD_inser:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	edi
	mov	DWORD PTR nbCompares$1$[rsp], edi
	cmp	esi, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN284@ZSTD_inser

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rdi, QWORD PTR dmsBase$1$[rsp]
	mov	rbx, rcx
	mov	eax, esi
	mov	r15d, esi
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	cmp	rdx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	cmovb	rbx, rdx

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	add	rdi, r15
	lea	r12, QWORD PTR [r8+rax*4]

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	add	rbp, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rbp
	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	lea	r11, QWORD PTR [rdi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR base$1$[rsp]
	cmp	rcx, QWORD PTR dmsEnd$1$[rsp]
	jne	SHORT $LN232@ZSTD_inser

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv1933[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	add	rdx, r11
	mov	r8, r13
	call	ZSTD_count
	add	r14, rax
$LN232@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rsp]
	add	rbx, r14
	lea	rcx, QWORD PTR [r15+rbx]
	cmp	rcx, rax
	jb	SHORT $LN298@ZSTD_inser

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rdi, QWORD PTR [r15+rax]
	add	rdi, r11
	jmp	SHORT $LN37@ZSTD_inser
$LN298@ZSTD_inser:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN37@ZSTD_inser:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN285@ZSTD_inser

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rsi+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	r8d, ebx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN39@ZSTD_inser

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN39@ZSTD_inser:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r11d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rsp]
	sub	eax, edx

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rbp, QWORD PTR ip$[rsp]
	lea	rcx, QWORD PTR [rcx+r11*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR [rcx], eax
	inc	r11d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+rbp]
	mov	DWORD PTR mnum$1$[rsp], r11d
	cmp	rax, r13
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN284@ZSTD_inser

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN40@ZSTD_inser
$LN285@ZSTD_inser:
	mov	rbp, QWORD PTR ip$[rsp]
	mov	r11d, DWORD PTR mnum$1$[rsp]
$LN40@ZSTD_inser:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR dmsBtLow$1$[rsp]
	jbe	SHORT $LN284@ZSTD_inser

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rbp]
	cmp	BYTE PTR [rdi+rbx], al
	jae	SHORT $LN42@ZSTD_inser

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	esi, DWORD PTR [r12+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rsp]
	mov	QWORD PTR commonLengthSmaller$2$[rsp], rbx
	jmp	SHORT $LN43@ZSTD_inser
$LN42@ZSTD_inser:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	esi, DWORD PTR [r12]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rsp]
	mov	QWORD PTR commonLengthLarger$2$[rsp], rbx
$LN43@ZSTD_inser:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	edi, DWORD PTR nbCompares$1$[rsp]
	mov	r8, QWORD PTR dmsBt$1$[rsp]
	test	edi, edi
	jne	$LL7@ZSTD_inser
$LN284@ZSTD_inser:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	rcx, QWORD PTR ms$[rsp]
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN301@ZSTD_inser:

; 738  :     return mnum;
; 739  : }

	mov	eax, r11d
$LN1@ZSTD_inser:
	add	rsp, 248				; 000000f8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_insertBtAndGetAllMatches ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
mnum$1$ = 48
mnum$1$ = 48
mnum$1$ = 48
current$1$ = 48
nbCompares$1$ = 52
nbCompares$1$ = 52
nbCompares$1$ = 52
tv8415 = 52
current$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 60
current$1$ = 60
dmsIndexDelta$1$ = 60
matchLow$1$ = 60
dmsBtMask$1$ = 64
$T1 = 64
nbCompares$1$ = 68
dmsBtLow$1$ = 68
current$1$ = 68
dmsHighLimit$1$ = 68
dmsLowLimit$1$ = 72
dmsIndexDelta$1$ = 72
dmsBtLow$1$ = 72
dmsIndexDelta$1$ = 72
r$2 = 76
r$3 = 76
r$4 = 76
r$5 = 76
r$6 = 76
r$7 = 76
r$8 = 76
r$9 = 76
r$10 = 76
r$11 = 76
dmsLowLimit$1$ = 80
dmsLowLimit$1$ = 80
dmsLowLimit$1$ = 80
tv8554 = 80
base$1$ = 88
smallerPtr$1$ = 88
smallerPtr$1$ = 88
smallerPtr$1$ = 88
btMask$1$ = 96
tv8494 = 96
tv8482 = 96
tv8469 = 96
dummy32$12 = 96
dummy32$13 = 96
dummy32$14 = 96
dummy32$15 = 96
smallerPtr$1$ = 104
base$1$ = 104
commonLengthSmaller$1$ = 104
base$1$ = 104
dmsEnd$2$ = 112
dmsEnd$1$ = 112
dmsBase$1$ = 112
bestLength$1$ = 112
bestLength$1$ = 120
bestLength$1$ = 120
dictBase$1$ = 120
tv8484 = 120
bestLength$1$ = 128
dmsEnd$1$ = 128
tv8514 = 128
tv8471 = 128
dmsBase$2$ = 136
commonLengthLarger$1$ = 136
commonLengthSmaller$2$ = 136
largerPtr$1$ = 136
commonLengthSmaller$2$ = 136
tv8496 = 136
windowLow$1$ = 144
dmsHighLimit$1$ = 144
dmsHighLimit$1$ = 144
dmsBtMask$1$ = 144
dictLimit$1$ = 148
dmsHashLog$1$ = 148
dmsHashLog$1$ = 148
dmsHashLog$1$ = 148
tv8416 = 152
tv8414 = 152
tv8413 = 152
tv8412 = 152
dmsHashLog$1$ = 156
dictLimit$1$ = 156
lastR$1$ = 156
lastR$1$ = 156
dmsBtLow$1$ = 160
windowLow$1$ = 160
dictLimit$1$ = 160
dictLimit$1$ = 160
dictBase$1$ = 168
dictBase$1$ = 168
dictBase$1$ = 168
dmsEnd$1$ = 168
dms$1$ = 176
commonLengthLarger$2$ = 176
nextPtr$1$ = 176
dms$1$ = 176
nextPtr$1$ = 176
nextPtr$1$ = 176
nextPtr$1$ = 176
commonLengthSmaller$1$ = 176
largerPtr$1$ = 184
commonLengthSmaller$2$ = 184
largerPtr$1$ = 184
largerPtr$1$ = 184
commonLengthLarger$1$ = 184
nextPtr$1$ = 192
nextPtr$1$ = 192
commonLengthSmaller$2$ = 192
commonLengthSmaller$1$ = 192
base$1$ = 192
dmsBase$1$ = 192
nextPtr$1$ = 200
commonLengthLarger$2$ = 200
dms$1$ = 200
commonLengthLarger$2$ = 200
nextPtr$1$ = 200
commonLengthLarger$2$ = 200
tv8515 = 200
sufficient_len$1$ = 208
btMask$1$ = 212
btMask$1$ = 212
dmsBtLow$1$ = 212
tv8507 = 212
commonLengthLarger$1$ = 216
dmsBase$1$ = 216
prefixStart$1$ = 216
dms$1$ = 216
matchLow$1$ = 224
matchLow$1$ = 224
matchLow$1$ = 224
btMask$1$ = 224
dmsBt$1$ = 232
dmsBt$1$ = 232
bt$1$ = 232
dmsBt$1$ = 232
tv8485 = 232
tv8472 = 232
dmsBt$1$ = 240
bt$1$ = 240
bt$1$ = 240
bt$1$ = 240
tv8497 = 240
commonLengthSmaller$1$ = 248
commonLengthLarger$1$ = 248
matches$ = 336
ms$ = 344
nextToUpdate3$ = 352
ip$ = 360
iHighLimit$ = 368
dictMode$ = 376
rep$ = 384
ll0$ = 392
lengthToBeat$ = 400
ZSTD_BtGetAllMatches PROC

; 750  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H

; 751  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 752  :     U32 const matchLengthSearch = cParams->minMatch;
; 753  :     DEBUGLOG(8, "ZSTD_BtGetAllMatches");
; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [rdx+36]
	mov	r12, rdx
	mov	r15, QWORD PTR [rdx+8]
	mov	r14d, DWORD PTR [rdx+200]
	lea	rax, QWORD PTR [r15+rbx]
	cmp	r9, rax
	jae	SHORT $LN4@ZSTD_BtGet
	xor	eax, eax

; 764  :     }
; 765  : }

	add	rsp, 288				; 00000120H
	pop	r15
	pop	r14
	pop	r12
	pop	rbx
	pop	rbp
	ret	0
$LN4@ZSTD_BtGet:
	mov	QWORD PTR [rsp+280], rsi

; 489  :     U32 const target = (U32)(ip - base);

	mov	esi, r9d
	mov	QWORD PTR [rsp+272], rdi
	sub	esi, r15d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	mov	rdi, QWORD PTR iHighLimit$[rbp-256]
	mov	QWORD PTR [rsp+264], r13
	cmp	ebx, esi
	jae	SHORT $LN12@ZSTD_BtGet
	mov	r13, QWORD PTR ms$[rbp-256]
	xor	r12d, r12d

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	cmp	DWORD PTR dictMode$[rbp-256], 1
	sete	r12b
	npad	7
$LL11@ZSTD_BtGet:
	mov	edx, ebx
	mov	r9d, r14d
	add	rdx, r15
	mov	DWORD PTR [rsp+32], r12d
	mov	r8, rdi
	mov	rcx, r13
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, esi
	jb	SHORT $LL11@ZSTD_BtGet
	mov	r9, QWORD PTR ip$[rbp-256]
	mov	r12, QWORD PTR ms$[rbp-256]
$LN12@ZSTD_BtGet:

; 755  :     ZSTD_updateTree_internal(ms, ip, iHighLimit, matchLengthSearch, dictMode);
; 756  :     switch(matchLengthSearch)

	mov	r11, QWORD PTR [r12+8]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], esi

; 755  :     ZSTD_updateTree_internal(ms, ip, iHighLimit, matchLengthSearch, dictMode);
; 756  :     switch(matchLengthSearch)

	mov	r10d, r9d
	cmp	r14d, 3
	je	$LN5@ZSTD_BtGet
	cmp	r14d, 5
	je	$LN7@ZSTD_BtGet
	mov	r8, QWORD PTR [r12+48]
	lea	eax, DWORD PTR [r14-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN6@ZSTD_BtGet

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	rsi, QWORD PTR [r12+64]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r14d, 1
	cmovb	ecx, eax

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	ebx, DWORD PTR [r12+24]
	sub	r10d, r11d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	ecx, DWORD PTR [r12+192]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rdx, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 523  :     U32 const hashLog = cParams->hashLog;

	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	eax, 64					; 00000040H
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 521  :     const BYTE* const base = ms->window.base;

	mov	QWORD PTR base$1$[rsp], r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	movzx	ecx, al
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	mov	DWORD PTR current$1$[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	shr	rdx, cl

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r11d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r13d, DWORD PTR [r8+rdx*4]
	lea	rax, QWORD PTR [r8+rdx*4]

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	QWORD PTR tv8515[rbp-256], rax
	dec	ecx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rax, QWORD PTR [r12+16]
	mov	r8d, r14d
	mov	QWORD PTR dictBase$1$[rbp-256], rax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r15d, r14d
	shl	r8d, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	dec	r8d

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	sub	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	r8d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	QWORD PTR bt$1$[rbp-256], rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	DWORD PTR btMask$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rbp-256], ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	DWORD PTR tv8416[rbp-256], ecx

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r10d
	mov	ecx, DWORD PTR [r12+184]
	mov	edx, r14d
	shl	edx, cl
	mov	ecx, DWORD PTR [r12+28]

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r11d, edx
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	QWORD PTR tv8514[rbp-256], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	mov	eax, r14d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r11d, ecx
	cmp	DWORD PTR [r12+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r11d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r12+196]
	test	r11d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR windowLow$1$[rbp-256], r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	shl	r15d, cl
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	mov	eax, r8d
	and	eax, r10d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	add	eax, eax
	lea	rax, QWORD PTR [rsi+rax*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r10+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	xor	eax, eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	DWORD PTR mnum$1$[rsp], eax
	jne	$LN936@ZSTD_BtGet
	mov	r14, QWORD PTR [r12+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r8d, r11d
	mov	QWORD PTR dms$1$[rbp-256], r14

; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	ecx, DWORD PTR [r14+192]
	mov	rdx, QWORD PTR [r14]
	mov	r12, QWORD PTR [r14+8]
	mov	eax, edx
	mov	esi, DWORD PTR [r14+28]
	sub	eax, r12d
	sub	r8d, eax
	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r14+188]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r14d, 1
	dec	ecx
	mov	DWORD PTR tv8554[rsp], eax
	shl	r14d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	sub	eax, esi
	dec	r14d
	mov	QWORD PTR dmsBase$2$[rbp-256], r12
	mov	QWORD PTR dmsEnd$2$[rsp], rdx
	mov	DWORD PTR dmsLowLimit$1$[rsp], esi
	mov	DWORD PTR tv8415[rsp], r8d
	mov	DWORD PTR dmsBtMask$1$[rsp], r14d
	cmp	r14d, eax
	jae	SHORT $LN952@ZSTD_BtGet
	mov	ecx, DWORD PTR tv8554[rsp]
	sub	ecx, r14d
	mov	QWORD PTR dmsBase$2$[rbp-256], r12
	mov	DWORD PTR dmsBtLow$1$[rbp-256], ecx
	mov	QWORD PTR dmsEnd$2$[rsp], rdx
	mov	DWORD PTR dmsLowLimit$1$[rsp], esi
	mov	DWORD PTR tv8415[rsp], r8d
	jmp	SHORT $LN953@ZSTD_BtGet
$LN936@ZSTD_BtGet:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv8554[rsp], eax

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	esi, eax
	mov	QWORD PTR dms$1$[rbp-256], rax
	mov	DWORD PTR dmsBtMask$1$[rsp], eax
	mov	QWORD PTR dmsBase$2$[rbp-256], rax
	mov	QWORD PTR dmsEnd$2$[rsp], rax
	mov	DWORD PTR dmsLowLimit$1$[rsp], eax
	mov	DWORD PTR tv8415[rsp], eax
$LN952@ZSTD_BtGet:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rbp-256], esi
$LN953@ZSTD_BtGet:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;
; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	r12d, DWORD PTR ll0$[rbp-256]
	mov	eax, DWORD PTR lengthToBeat$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, r12d
	dec	eax
	mov	QWORD PTR bestLength$1$[rsp], rax
	lea	esi, DWORD PTR [r12+3]
	cmp	r12d, esi
	jae	$LN886@ZSTD_BtGet
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r10d
	sub	edx, ebx
	mov	DWORD PTR tv8507[rbp-256], edx
	lea	r15, QWORD PTR [rcx+r12*4]
$LL887@ZSTD_BtGet:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN954@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN955@ZSTD_BtGet
$LN954@ZSTD_BtGet:
	mov	eax, DWORD PTR [r15]
$LN955@ZSTD_BtGet:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r10d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r10d, r10d
	cmp	ecx, edx
	jae	$LN892@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rdx, QWORD PTR ip$[rbp-256]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r8d, eax
	mov	rax, rdx
	sub	rax, r8

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	ecx, DWORD PTR [rdx]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	edx, edx
	cmp	ecx, DWORD PTR [rax]
	sete	dl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	edx, eax
	je	$LN1406@ZSTD_BtGet

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$[rbp-256]
	mov	rdx, rax
	sub	rdx, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	add	rdx, 4
	lea	rcx, QWORD PTR [rax+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r9, rcx

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN1009@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN1011@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN1026@ZSTD_BtGet
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1406@ZSTD_BtGet
$LN1026@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1406@ZSTD_BtGet
$LN1011@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN1009@ZSTD_BtGet
	npad	3
$LL1008@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN1012@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL1008@ZSTD_BtGet
$LN1009@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN1013@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN1013@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN1013@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN1014@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN1014@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN1014@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN1015@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN1015@ZSTD_BtGet
	inc	rcx
$LN1015@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1406@ZSTD_BtGet
$LN1012@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN1042@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1406@ZSTD_BtGet
$LN1042@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1406@ZSTD_BtGet
$LN892@ZSTD_BtGet:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	eax, DWORD PTR dictMode$[rbp-256]
	mov	r8d, r9d
	cmp	eax, 2
	jne	$LN956@ZSTD_BtGet
	mov	edx, DWORD PTR tv8415[rsp]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	r8, rdx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	add	r8, QWORD PTR dmsBase$2$[rbp-256]
	sub	eax, edx
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, ebx
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN1406@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r9, QWORD PTR ip$[rbp-256]
	mov	eax, DWORD PTR [r9]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8]
	jne	$LN896@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$2$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [r8+4]
	lea	rsi, QWORD PTR [r9+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
	mov	rax, rsi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	sub	rax, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dmsEnd$2$[rsp]
	jne	$LN1066@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv8514[rbp-256]
	lea	rcx, QWORD PTR [rax+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	jmp	$LN1426@ZSTD_BtGet
$LN956@ZSTD_BtGet:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, 1
	jne	$LN1406@ZSTD_BtGet
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r11d
	cmp	ecx, eax
	mov	ecx, ebx
	setb	dl
	sub	ecx, r9d
	mov	r9, QWORD PTR ip$[rbp-256]
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN896@ZSTD_BtGet
	mov	rcx, QWORD PTR dictBase$1$[rbp-256]

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r9]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8+rcx]
	jne	SHORT $LN896@ZSTD_BtGet

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [rcx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR tv8514[rbp-256]
	add	rcx, QWORD PTR dictBase$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	rsi, QWORD PTR [r9+4]
	add	r11, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rsi
	sub	rax, r11
	mov	r8, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	rdx, QWORD PTR tv8514[rbp-256]
	mov	rbx, rax
	lea	rcx, QWORD PTR [rax+r11]
	mov	rax, QWORD PTR dictBase$1$[rbp-256]
	add	rax, rdx
	cmp	rcx, rax
	jne	SHORT $LN1066@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rbx+rsi]
$LN1426@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	add	rdx, QWORD PTR base$1$[rsp]
	mov	r8, rdi
	call	ZSTD_count
	add	rbx, rax
$LN1066@ZSTD_BtGet:
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r10d, DWORD PTR [rbx+4]
	mov	ebx, DWORD PTR dictLimit$1$[rbp-256]
	lea	esi, DWORD PTR [r12+3]
$LN1406@ZSTD_BtGet:
	mov	r9, QWORD PTR ip$[rbp-256]
$LN896@ZSTD_BtGet:
	mov	edx, r10d
	cmp	rdx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN885@ZSTD_BtGet

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, r14d
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r12d
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r10+r9]
	mov	DWORD PTR [rcx+4], r10d
	xor	ecx, ecx
	cmp	rax, rdi
	mov	QWORD PTR bestLength$1$[rsp], rdx
	mov	DWORD PTR mnum$1$[rsp], r8d
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN594@ZSTD_BtGet
$LN885@ZSTD_BtGet:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv8507[rbp-256]
	inc	r14d
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r15, 4
	mov	r10d, DWORD PTR current$1$[rsp]
	cmp	r14d, esi
	jb	$LL887@ZSTD_BtGet
	mov	r15d, DWORD PTR nbCompares$1$[rsp]
$LN886@ZSTD_BtGet:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv8515[rbp-256]
	mov	DWORD PTR [rax], r10d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1247@ZSTD_BtGet
	mov	r11, QWORD PTR commonLengthSmaller$1$[rbp-256]
	mov	rsi, r11
	npad	1
$LL888@ZSTD_BtGet:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	r13d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1410@ZSTD_BtGet

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rbx, rsi
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r13d
	add	eax, eax
	cmp	r11, rsi
	cmovb	rbx, r11

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	lea	r10, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], r10
	je	$LN908@ZSTD_BtGet
	mov	rdx, QWORD PTR tv8514[rbp-256]
	mov	r14d, r13d
	lea	rax, QWORD PTR [rbx+r14]
	cmp	rax, rdx
	jae	$LN908@ZSTD_BtGet

; 654  :             match = dictBase + matchIndex;

	mov	r8, QWORD PTR dictBase$1$[rbp-256]

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r15, QWORD PTR [rbx+r9]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r15
	lea	rcx, QWORD PTR [rdx+r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 654  :             match = dictBase + matchIndex;

	lea	r12, QWORD PTR [r8+r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR tv8514[rbp-256]
	mov	rax, QWORD PTR dictBase$1$[rbp-256]
	add	rax, r11
	cmp	rcx, rax
	je	SHORT $LN1160@ZSTD_BtGet
	mov	r15, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN1159@ZSTD_BtGet
$LN1160@ZSTD_BtGet:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rsi+r15]
	mov	r8, rdi
	mov	r15, QWORD PTR base$1$[rsp]
	lea	rdx, QWORD PTR [r11+r15]
	call	ZSTD_count
	add	rsi, rax
$LN1159@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 657  :             if (matchIndex+matchLength >= dictLimit)

	mov	r10, QWORD PTR nextPtr$1$[rbp-256]
	add	rbx, rsi
	mov	rsi, QWORD PTR commonLengthLarger$1$[rbp-256]
	lea	rax, QWORD PTR [rbx+r14]
	cmp	rax, r11
	mov	r11, QWORD PTR commonLengthSmaller$1$[rbp-256]
	jb	SHORT $LN1377@ZSTD_BtGet

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	lea	r12, QWORD PTR [r15+r14]
$LN1377@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
$LN910@ZSTD_BtGet:
	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	$LN1402@ZSTD_BtGet

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r13d
	cmp	rbx, rax
	jbe	SHORT $LN912@ZSTD_BtGet

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+r13]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN912@ZSTD_BtGet:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r13d

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR mnum$1$[rsp], r8d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN913@ZSTD_BtGet

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	jne	$LN889@ZSTD_BtGet
	xor	r15d, r15d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN889@ZSTD_BtGet
$LN908@ZSTD_BtGet:

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+r9]
	mov	r12d, r13d
	add	r12, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN1118@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN1120@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$3[rsp], 0
	je	SHORT $LN1135@ZSTD_BtGet
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN910@ZSTD_BtGet
$LN1135@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN910@ZSTD_BtGet
$LN1120@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN1118@ZSTD_BtGet
$LL1117@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN1121@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL1117@ZSTD_BtGet
$LN1118@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN1122@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN1122@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN1122@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN1123@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN1123@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN1123@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN1124@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN1124@ZSTD_BtGet
	inc	rcx
$LN1124@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN910@ZSTD_BtGet
$LN1121@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN1151@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN910@ZSTD_BtGet
$LN1151@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN910@ZSTD_BtGet
$LN1402@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR ip$[rbp-256]
$LN913@ZSTD_BtGet:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [r12+rbx], al
	jae	SHORT $LN915@ZSTD_BtGet

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	r11, rbx
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r13d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8416[rbp-256]
	jbe	$LN1221@ZSTD_BtGet

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r13d, DWORD PTR [r10+4]
	lea	r8, QWORD PTR [r10+4]
	mov	QWORD PTR smallerPtr$1$[rsp], r8

; 685  :         } else {

	jmp	SHORT $LN916@ZSTD_BtGet
$LN915@ZSTD_BtGet:

; 687  :             commonLengthLarger = matchLength;

	mov	rsi, rbx
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r13d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8416[rbp-256]
	jbe	$LN1222@ZSTD_BtGet

; 690  :             matchIndex = nextPtr[0];

	mov	r13d, DWORD PTR [r10]
	mov	QWORD PTR largerPtr$1$[rbp-256], r10
$LN916@ZSTD_BtGet:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	jne	$LL888@ZSTD_BtGet
$LN1247@ZSTD_BtGet:
	dec	r15d
$LN1410@ZSTD_BtGet:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN889@ZSTD_BtGet:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], 0
	mov	DWORD PTR [rax], 0
	jne	$LN1372@ZSTD_BtGet
	test	r15d, r15d
	je	$LN1372@ZSTD_BtGet

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	rdx, QWORD PTR [r9]
	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR dmsHashLog$1$[rbp-256]
	imul	rdx, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rax, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	r14d, DWORD PTR [rax+rdx*4]
	xor	edx, edx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
	npad	1
$LL890@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1372@ZSTD_BtGet

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$2$[rbp-256]
	mov	rbx, rcx
	mov	eax, r14d
	mov	r12d, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	cmp	rdx, rcx
	cmovb	rbx, rdx
	add	rsi, r12
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rdx, QWORD PTR dmsEnd$2$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	lea	rax, QWORD PTR [r8+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	QWORD PTR dmsEnd$2$[rsp], rdx
	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	mov	QWORD PTR nextPtr$1$[rbp-256], rax

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	lea	r13, QWORD PTR [rbx+r9]
	lea	r11, QWORD PTR [rsi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r13
	sub	rcx, r11
	add	rcx, rdx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR base$1$[rsp]
	cmp	rcx, QWORD PTR dmsEnd$2$[rsp]
	jne	SHORT $LN1193@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv8514[rbp-256]
	lea	rcx, QWORD PTR [rax+r13]
	add	rdx, r11
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN1193@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv8554[rsp]
	add	rbx, r15
	lea	rcx, QWORD PTR [rbx+r12]
	cmp	rcx, rax
	jb	SHORT $LN1411@ZSTD_BtGet

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv8415[rsp]
	lea	rsi, QWORD PTR [r11+rax]
	add	rsi, r12
	jmp	SHORT $LN920@ZSTD_BtGet
$LN1221@ZSTD_BtGet:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$12[rsp]
	jmp	$LN889@ZSTD_BtGet
$LN1222@ZSTD_BtGet:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$12[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN1410@ZSTD_BtGet
$LN1411@ZSTD_BtGet:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv8415[rsp]
$LN920@ZSTD_BtGet:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1401@ZSTD_BtGet

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1286@ZSTD_BtGet

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1286@ZSTD_BtGet:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, edx

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR mnum$1$[rsp], r8d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1372@ZSTD_BtGet

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN923@ZSTD_BtGet
$LN1401@ZSTD_BtGet:
	mov	r9, QWORD PTR ip$[rbp-256]
$LN923@ZSTD_BtGet:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR dmsBtLow$1$[rbp-256]
	jbe	SHORT $LN1372@ZSTD_BtGet

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [rsi+rbx], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN925@ZSTD_BtGet

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [rax+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN926@ZSTD_BtGet
$LN925@ZSTD_BtGet:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [rax]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN926@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r15d, r15d
	jne	$LL890@ZSTD_BtGet
$LN1372@ZSTD_BtGet:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	ecx, DWORD PTR matchEndIdx$1$[rsp]

; 762  :     case 7 :
; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN1425@ZSTD_BtGet
$LN6@ZSTD_BtGet:

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	ebx, DWORD PTR [r12+24]
	cmp	eax, ecx
	mov	r14, QWORD PTR [r12+64]
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	sub	r10d, r11d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r15d, r15d
	mov	ecx, DWORD PTR [r12+192]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	eax, 32					; 00000020H
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 523  :     U32 const hashLog = cParams->hashLog;

	mov	DWORD PTR dmsHashLog$1$[rbp-256], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	movzx	ecx, al
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	mov	DWORD PTR current$1$[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r13d, DWORD PTR [r8+rdx*4]
	lea	rax, QWORD PTR [r8+rdx*4]

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r8d, r8d
	mov	QWORD PTR tv8497[rbp-256], rax
	dec	ecx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rax, QWORD PTR [r12+16]
	mov	edx, 1
	mov	QWORD PTR dictBase$1$[rbp-256], rax
	mov	esi, edx
	shl	esi, cl

; 535  :     const BYTE* const prefixStart = base + dictLimit;

	lea	rax, QWORD PTR [r11+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r11, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	dec	esi

; 535  :     const BYTE* const prefixStart = base + dictLimit;

	mov	QWORD PTR prefixStart$1$[rbp-256], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	xor	ecx, ecx
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	DWORD PTR btMask$1$[rbp-256], esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	sub	eax, esi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	QWORD PTR bt$1$[rbp-256], r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	esi, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthSmaller$1$[rsp], r8
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rbp-256], ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	DWORD PTR tv8414[rbp-256], ecx

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r10d
	mov	ecx, DWORD PTR [r12+184]
	shl	edx, cl
	mov	ecx, DWORD PTR [r12+28]
	sub	eax, ecx

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r12d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	QWORD PTR tv8496[rbp-256], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r12d, edx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	mov	edx, 1
	mov	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r12d, ecx
	cmp	DWORD PTR [r11+32], r8d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r12d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r11+196]
	test	r12d, r12d
	cmovne	eax, r12d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	mov	eax, esi
	and	eax, r10d
	mov	esi, edx
	add	eax, eax
	shl	esi, cl
	mov	DWORD PTR nbCompares$1$[rsp], esi
	lea	rax, QWORD PTR [r14+rax*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r10+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	xor	eax, eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	DWORD PTR mnum$1$[rsp], eax
	jne	SHORT $LN352@ZSTD_BtGet
	mov	r11, QWORD PTR [r11+176]

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	edx, r12d
	mov	QWORD PTR dms$1$[rbp-256], r11
	mov	r10, QWORD PTR [r11]
	mov	rax, QWORD PTR [r11+8]
	mov	r14d, r10d

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r11+188]
	sub	r14d, eax
	sub	edx, r14d
	mov	QWORD PTR dmsBase$1$[rsp], rax
	mov	eax, DWORD PTR [r11+192]
	dec	ecx
	mov	DWORD PTR dmsIndexDelta$1$[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r14d
	shl	edx, cl
	dec	edx
	mov	QWORD PTR dmsEnd$1$[rbp-256], r10
	mov	r10d, DWORD PTR [r11+28]
	sub	eax, r10d
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r14d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	cmp	edx, eax
	jae	SHORT $LN372@ZSTD_BtGet
	mov	ecx, r14d
	sub	ecx, edx
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	jmp	SHORT $LN373@ZSTD_BtGet
$LN352@ZSTD_BtGet:

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	QWORD PTR dms$1$[rbp-256], rax

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r10d, eax
	mov	QWORD PTR dmsBase$1$[rsp], rax
	mov	QWORD PTR dmsEnd$1$[rbp-256], rax
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], eax
	mov	DWORD PTR dmsLowLimit$1$[rsp], eax

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	DWORD PTR dmsBtMask$1$[rsp], eax
$LN372@ZSTD_BtGet:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], r10d
$LN373@ZSTD_BtGet:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;
; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	r10d, DWORD PTR ll0$[rbp-256]
	mov	eax, DWORD PTR lengthToBeat$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, r10d
	dec	eax
	mov	QWORD PTR bestLength$1$[rsp], rax
	lea	r11d, DWORD PTR [r10+3]
	mov	DWORD PTR lastR$1$[rbp-256], r11d
	cmp	r10d, r11d
	jae	$LN306@ZSTD_BtGet
	mov	esi, DWORD PTR current$1$[rsp]
	mov	edx, esi
	mov	rcx, QWORD PTR rep$[rbp-256]
	sub	edx, ebx
	mov	DWORD PTR tv8494[rsp], edx
	lea	r15, QWORD PTR [rcx+r10*4]
$LL307@ZSTD_BtGet:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN374@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN375@ZSTD_BtGet
$LN374@ZSTD_BtGet:
	mov	eax, DWORD PTR [r15]
$LN375@ZSTD_BtGet:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r8d, esi

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r8d, eax
	xor	r9d, r9d
	cmp	ecx, edx
	jae	$LN312@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rsi, QWORD PTR ip$[rbp-256]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	edx, edx
	mov	r10d, eax
	mov	rax, rsi
	sub	rax, r10

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	ecx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	ecx, DWORD PTR [rax]
	sete	dl
	xor	eax, eax
	cmp	r8d, r12d
	setae	al
	test	edx, eax
	je	$LN1380@ZSTD_BtGet

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	rcx, QWORD PTR [rsi+4]
	mov	rdx, rsi
	sub	rdx, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r9, rcx

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN429@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN431@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$9[rsp], 0
	je	SHORT $LN446@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR ll0$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r9d, DWORD PTR [rax+4]

; 596  :             if (repLen > bestLength) {

	jmp	$LN316@ZSTD_BtGet
$LN446@ZSTD_BtGet:
	mov	r10d, DWORD PTR ll0$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r9d, DWORD PTR [rax+4]

; 596  :             if (repLen > bestLength) {

	jmp	$LN316@ZSTD_BtGet
$LN431@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN429@ZSTD_BtGet
$LL428@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN432@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL428@ZSTD_BtGet
$LN429@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN433@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN433@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN433@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN434@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN434@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN434@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN435@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN435@ZSTD_BtGet
	inc	rcx
$LN435@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r9d, DWORD PTR [rax+4]
$LN1380@ZSTD_BtGet:

; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR ll0$[rbp-256]
	jmp	$LN316@ZSTD_BtGet
$LN432@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$8[rsp], 0
	je	SHORT $LN462@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR ll0$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r9d, DWORD PTR [rax+4]

; 596  :             if (repLen > bestLength) {

	jmp	$LN316@ZSTD_BtGet
$LN462@ZSTD_BtGet:
	mov	r10d, DWORD PTR ll0$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r9d, DWORD PTR [rax+4]

; 596  :             if (repLen > bestLength) {

	jmp	$LN316@ZSTD_BtGet
$LN312@ZSTD_BtGet:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	edx, r8d
	jne	$LN376@ZSTD_BtGet
	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	r11, QWORD PTR dmsBase$1$[rsp]
	sub	r11, rax

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, esi
	sub	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	add	r11, rdx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	mov	rsi, QWORD PTR ip$[rbp-256]
	cmp	ecx, eax
	mov	ecx, ebx
	setb	dl
	sub	ecx, r8d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN1386@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r11]
	jne	$LN1386@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	add	rsi, 4
	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rsi
	sub	rax, r11
	mov	r8, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dmsEnd$1$[rbp-256]
	jne	SHORT $LN507@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rax+rsi]
$LN1423@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	mov	rdx, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, rdi
	call	ZSTD_count
	add	rbx, rax
$LN507@ZSTD_BtGet:
	mov	r10d, DWORD PTR ll0$[rbp-256]
	lea	r9d, DWORD PTR [rbx+4]
	mov	ebx, DWORD PTR dictLimit$1$[rbp-256]
	mov	r11d, DWORD PTR lastR$1$[rbp-256]
	mov	rsi, QWORD PTR ip$[rbp-256]
	jmp	$LN316@ZSTD_BtGet
$LN376@ZSTD_BtGet:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r11, QWORD PTR dictBase$1$[rbp-256]
	add	r11, rdx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	SHORT $LN1382@ZSTD_BtGet
	xor	edx, edx
	mov	eax, esi
	mov	rsi, QWORD PTR ip$[rbp-256]
	sub	eax, r12d
	cmp	ecx, eax
	mov	ecx, ebx
	setb	dl
	sub	ecx, r8d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1386@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r11]
	jne	SHORT $LN1386@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictBase$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	add	rsi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	add	rcx, QWORD PTR tv8496[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rsi
	mov	r8, rdi
	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	rax, QWORD PTR dictBase$1$[rbp-256]
	add	rax, QWORD PTR tv8496[rbp-256]
	cmp	rcx, rax
	jne	$LN507@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rbx+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	jmp	$LN1423@ZSTD_BtGet
$LN1382@ZSTD_BtGet:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	rsi, QWORD PTR ip$[rbp-256]
$LN1386@ZSTD_BtGet:

; 596  :             if (repLen > bestLength) {

	lea	r11d, DWORD PTR [r10+3]
$LN316@ZSTD_BtGet:
	mov	edx, r9d
	cmp	rdx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN305@ZSTD_BtGet

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, r14d
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r10d
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r9+rsi]
	mov	DWORD PTR [rcx+4], r9d
	xor	ecx, ecx
	cmp	rax, rdi
	mov	QWORD PTR bestLength$1$[rsp], rdx
	mov	DWORD PTR mnum$1$[rsp], r8d
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN594@ZSTD_BtGet
$LN305@ZSTD_BtGet:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv8494[rsp]
	inc	r14d
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r15, 4
	mov	esi, DWORD PTR current$1$[rsp]
	cmp	r14d, r11d
	jb	$LL307@ZSTD_BtGet
	mov	r8, QWORD PTR commonLengthSmaller$1$[rsp]
	mov	r9, QWORD PTR ip$[rbp-256]
	mov	r15, r8
	mov	esi, DWORD PTR nbCompares$1$[rsp]
$LN306@ZSTD_BtGet:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv8497[rbp-256]
	mov	r11d, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], r11d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	esi, esi
	je	$LN1252@ZSTD_BtGet
	npad	11
$LL308@ZSTD_BtGet:
	dec	esi
	mov	DWORD PTR nbCompares$1$[rsp], esi
	cmp	r13d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1413@ZSTD_BtGet

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rbx, r15
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r13d
	add	eax, eax
	cmp	r8, r15
	cmovb	rbx, r8

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	lea	r10, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], r10
	je	$LN328@ZSTD_BtGet
	mov	rcx, QWORD PTR tv8496[rbp-256]
	mov	r14d, r13d
	lea	rax, QWORD PTR [rbx+r14]
	cmp	rax, rcx
	jae	$LN328@ZSTD_BtGet

; 654  :             match = dictBase + matchIndex;

	mov	rdx, QWORD PTR dictBase$1$[rbp-256]

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r15, QWORD PTR [rbx+r9]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
	lea	rax, QWORD PTR [rdx+rcx]
	mov	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 654  :             match = dictBase + matchIndex;

	lea	r12, QWORD PTR [rdx+r14]

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11
	sub	rax, r11
	add	rcx, r15
	add	rax, r15
	cmp	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	mov	rcx, r15
	cmovb	r8, rax
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR tv8496[rbp-256]
	mov	rax, QWORD PTR dictBase$1$[rbp-256]
	add	rax, r11
	cmp	rcx, rax
	jne	SHORT $LN555@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+r15]
	mov	r8, rdi
	call	ZSTD_count
	add	rsi, rax
$LN555@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 657  :             if (matchIndex+matchLength >= dictLimit)

	mov	r10, QWORD PTR nextPtr$1$[rbp-256]
	add	rbx, rsi
	mov	esi, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR [rbx+r14]
	cmp	rax, r11
	mov	r11d, DWORD PTR current$1$[rsp]
	jb	$LN330@ZSTD_BtGet

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r12, QWORD PTR base$1$[rbp-256]
	add	r12, r14
	jmp	$LN330@ZSTD_BtGet
$LN328@ZSTD_BtGet:

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+r9]
	mov	r12d, r13d
	add	r12, QWORD PTR base$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN514@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN516@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$7[rsp], 0
	je	SHORT $LN531@ZSTD_BtGet
	shr	eax, 3
	jmp	SHORT $LN512@ZSTD_BtGet
$LN531@ZSTD_BtGet:
	xor	eax, eax

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN512@ZSTD_BtGet
$LN516@ZSTD_BtGet:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN514@ZSTD_BtGet
$LL513@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN517@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL513@ZSTD_BtGet
$LN514@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN518@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN518@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN518@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN519@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN519@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN519@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN520@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN520@ZSTD_BtGet
	inc	rcx
$LN520@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
$LN512@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax
$LN330@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	$LN1400@ZSTD_BtGet

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r13d
	cmp	rbx, rax
	jbe	SHORT $LN332@ZSTD_BtGet

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+r13]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN332@ZSTD_BtGet:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r15d, DWORD PTR mnum$1$[rsp]
	mov	eax, r11d
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r13d

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r15*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r15d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR mnum$1$[rsp], r15d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN333@ZSTD_BtGet

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	jne	$LN309@ZSTD_BtGet
	xor	esi, esi

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN309@ZSTD_BtGet
$LN517@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$6[rsp], 0
	je	SHORT $LN547@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	$LN512@ZSTD_BtGet
$LN547@ZSTD_BtGet:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	$LN512@ZSTD_BtGet
$LN1400@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR ip$[rbp-256]
$LN333@ZSTD_BtGet:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [r12+rbx], al
	jae	SHORT $LN335@ZSTD_BtGet

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	r8, rbx
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx
	mov	DWORD PTR [rax], r13d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8414[rbp-256]
	jbe	$LN1227@ZSTD_BtGet

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r13d, DWORD PTR [r10+4]
	lea	rdx, QWORD PTR [r10+4]

; 685  :         } else {

	mov	r15, QWORD PTR commonLengthLarger$1$[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rsp], rdx
	jmp	SHORT $LN336@ZSTD_BtGet
$LN335@ZSTD_BtGet:

; 687  :             commonLengthLarger = matchLength;

	mov	r15, rbx
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r13d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8414[rbp-256]
	jbe	$LN1228@ZSTD_BtGet

; 690  :             matchIndex = nextPtr[0];

	mov	r13d, DWORD PTR [r10]
	mov	r8, QWORD PTR commonLengthSmaller$1$[rsp]

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rbp-256], r10
$LN336@ZSTD_BtGet:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	esi, esi
	jne	$LL308@ZSTD_BtGet
$LN1252@ZSTD_BtGet:
	dec	esi
$LN1413@ZSTD_BtGet:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN309@ZSTD_BtGet:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], 0
	mov	DWORD PTR [rax], 0
	jne	$LN1374@ZSTD_BtGet
	test	esi, esi
	je	$LN1374@ZSTD_BtGet

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR dmsHashLog$1$[rbp-256]
	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rax, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	r14d, DWORD PTR [rax+rdx*4]
	xor	edx, edx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL310@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	esi
	mov	DWORD PTR nbCompares$1$[rsp], esi
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1374@ZSTD_BtGet

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rsp]
	mov	rbx, rcx
	mov	eax, r14d
	mov	r13d, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	cmp	rdx, rcx
	cmovb	rbx, rdx
	add	rsi, r13
	lea	rax, QWORD PTR [r8+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	mov	QWORD PTR nextPtr$1$[rbp-256], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, QWORD PTR dmsEnd$1$[rbp-256]
	mov	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	lea	r12, QWORD PTR [rbx+r9]
	lea	r11, QWORD PTR [rsi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11
	sub	rax, r11
	add	rcx, r12
	add	rax, r12
	cmp	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	mov	rcx, r12
	cmovb	r8, rax
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dmsEnd$1$[rbp-256]
	jne	SHORT $LN589@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rax+r12]
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN589@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	add	rbx, r15
	lea	rcx, QWORD PTR [rbx+r13]
	cmp	rcx, rax
	jb	SHORT $LN1417@ZSTD_BtGet

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	esi, eax
	add	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r13
	jmp	SHORT $LN340@ZSTD_BtGet
$LN1227@ZSTD_BtGet:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$14[rsp]
	jmp	$LN309@ZSTD_BtGet
$LN1228@ZSTD_BtGet:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$14[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN1413@ZSTD_BtGet
$LN1417@ZSTD_BtGet:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN340@ZSTD_BtGet:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1399@ZSTD_BtGet

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1288@ZSTD_BtGet

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1288@ZSTD_BtGet:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, edx

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR mnum$1$[rsp], r8d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1374@ZSTD_BtGet

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN343@ZSTD_BtGet
$LN1399@ZSTD_BtGet:
	mov	r9, QWORD PTR ip$[rbp-256]
$LN343@ZSTD_BtGet:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR dmsBtLow$1$[rsp]
	jbe	$LN1374@ZSTD_BtGet

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [rsi+rbx], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN345@ZSTD_BtGet

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [rax+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN346@ZSTD_BtGet
$LN345@ZSTD_BtGet:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [rax]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN346@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	esi, DWORD PTR nbCompares$1$[rsp]
	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	esi, esi
	jne	$LL310@ZSTD_BtGet

; 759  :     default :
; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN1374@ZSTD_BtGet
$LN7@ZSTD_BtGet:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r15d, 1
	mov	r12d, DWORD PTR [r12+192]
	cmp	eax, ecx
	mov	r13, QWORD PTR ms$[rbp-256]
	mov	esi, r15d
	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	sub	r10d, r11d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	QWORD PTR base$1$[rsp], r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 525  :     U32* const hashTable = ms->hashTable;

	mov	r8, QWORD PTR [r13+48]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	ecx, 64					; 00000040H
	imul	rdx, rax
	sub	ecx, r12d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 523  :     U32 const hashLog = cParams->hashLog;

	mov	DWORD PTR dmsHashLog$1$[rbp-256], r12d

; 528  :     U32* const bt   = ms->chainTable;

	mov	r12, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r11d, r10d

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r13d, DWORD PTR [r8+rdx*4]
	lea	rax, QWORD PTR [r8+rdx*4]
	mov	QWORD PTR tv8485[rbp-256], rax

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	r8d, r8d

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rax, QWORD PTR [r12+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]
	mov	r14, QWORD PTR [r12+64]
	dec	ecx

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	ebx, DWORD PTR [r12+24]
	shl	esi, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	xor	ecx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	QWORD PTR dictBase$1$[rbp-256], rax
	dec	esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	DWORD PTR btMask$1$[rbp-256], esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	sub	eax, esi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	mov	DWORD PTR current$1$[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	esi, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	QWORD PTR bt$1$[rbp-256], r14

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	DWORD PTR tv8413[rbp-256], ecx

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r10d
	mov	ecx, DWORD PTR [r12+184]
	shl	edx, cl
	mov	ecx, DWORD PTR [r12+28]

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r11d, edx
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rbp-256], ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	QWORD PTR tv8484[rsp], rbx

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	mov	eax, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r11d, ecx
	cmp	DWORD PTR [r12+32], r8d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r11d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r12+196]
	test	r11d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR windowLow$1$[rbp-256], r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	shl	r15d, cl
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	mov	eax, esi
	and	eax, r10d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	add	eax, eax
	xor	esi, esi
	mov	DWORD PTR mnum$1$[rsp], esi
	lea	rax, QWORD PTR [r14+rax*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r10+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	jne	SHORT $LN642@ZSTD_BtGet
	mov	rsi, QWORD PTR [r12+176]

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	eax, r11d
	mov	QWORD PTR dms$1$[rbp-256], rsi
	mov	rdx, QWORD PTR [rsi]
	mov	r12, QWORD PTR [rsi+8]
	mov	r14d, edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [rsi+188]
	sub	r14d, r12d
	sub	eax, r14d
	mov	QWORD PTR dmsEnd$1$[rsp], rdx
	mov	edx, DWORD PTR [rsi+28]
	dec	ecx
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [rsi+192]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	esi, 1
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r14d
	shl	esi, cl
	sub	eax, edx
	dec	esi
	mov	QWORD PTR dmsBase$1$[rbp-256], r12
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], r14d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	DWORD PTR dmsBtMask$1$[rsp], esi
	cmp	esi, eax
	jae	SHORT $LN662@ZSTD_BtGet
	mov	ecx, r14d
	sub	ecx, esi
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	jmp	SHORT $LN663@ZSTD_BtGet
$LN642@ZSTD_BtGet:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	edx, esi
	mov	QWORD PTR dms$1$[rbp-256], rsi
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	QWORD PTR dmsBase$1$[rbp-256], rsi
	mov	QWORD PTR dmsEnd$1$[rsp], rsi
	mov	DWORD PTR dmsHighLimit$1$[rbp-256], esi

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	DWORD PTR dmsIndexDelta$1$[rsp], esi

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	DWORD PTR dmsBtMask$1$[rsp], esi
$LN662@ZSTD_BtGet:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], edx
$LN663@ZSTD_BtGet:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;
; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	r12d, DWORD PTR ll0$[rbp-256]
	mov	eax, DWORD PTR lengthToBeat$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, r12d
	dec	eax
	mov	QWORD PTR bestLength$1$[rbp-256], rax
	lea	esi, DWORD PTR [r12+3]
	cmp	r12d, esi
	jae	$LN596@ZSTD_BtGet
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r10d
	sub	edx, ebx
	mov	DWORD PTR tv8482[rsp], edx
	lea	r15, QWORD PTR [rcx+r12*4]
	npad	5
$LL597@ZSTD_BtGet:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN664@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN665@ZSTD_BtGet
$LN664@ZSTD_BtGet:
	mov	eax, DWORD PTR [r15]
$LN665@ZSTD_BtGet:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r10d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r10d, r10d
	cmp	ecx, edx
	jae	$LN602@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rdx, QWORD PTR ip$[rbp-256]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r8d, eax
	mov	rax, rdx
	sub	rax, r8

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	ecx, DWORD PTR [rdx]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	edx, edx
	cmp	ecx, DWORD PTR [rax]
	sete	dl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	edx, eax
	je	$LN1398@ZSTD_BtGet

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$[rbp-256]
	mov	rdx, rax
	sub	rdx, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	add	rdx, 4
	lea	rcx, QWORD PTR [rax+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r9, rcx

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN719@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN721@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN736@ZSTD_BtGet
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1398@ZSTD_BtGet
$LN736@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1398@ZSTD_BtGet
$LN721@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN719@ZSTD_BtGet
	npad	7
$LL718@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN722@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL718@ZSTD_BtGet
$LN719@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN723@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN723@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN723@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN724@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN724@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN724@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN725@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN725@ZSTD_BtGet
	inc	rcx
$LN725@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1398@ZSTD_BtGet
$LN722@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN752@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1398@ZSTD_BtGet
$LN752@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1398@ZSTD_BtGet
$LN602@ZSTD_BtGet:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	eax, DWORD PTR dictMode$[rbp-256]
	mov	r8d, r9d
	cmp	eax, 2
	jne	$LN666@ZSTD_BtGet
	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	r8, rdx
	add	r8, QWORD PTR dmsBase$1$[rbp-256]
	sub	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, ebx
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN1398@ZSTD_BtGet

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r9, QWORD PTR ip$[rbp-256]
	mov	eax, DWORD PTR [r9]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8]
	jne	$LN606@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [r8+4]
	lea	rsi, QWORD PTR [r9+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
	mov	rax, rsi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	sub	rax, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dmsEnd$1$[rsp]
	jne	$LN776@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv8484[rsp]
	lea	rcx, QWORD PTR [rax+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	jmp	$LN1427@ZSTD_BtGet
$LN666@ZSTD_BtGet:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, 1
	jne	$LN1398@ZSTD_BtGet
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r11d
	cmp	ecx, eax
	mov	ecx, ebx
	setb	dl
	sub	ecx, r9d
	mov	r9, QWORD PTR ip$[rbp-256]
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN606@ZSTD_BtGet
	mov	rcx, QWORD PTR dictBase$1$[rbp-256]

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r9]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8+rcx]
	jne	SHORT $LN606@ZSTD_BtGet

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [rcx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR tv8484[rsp]
	add	rcx, QWORD PTR dictBase$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	rsi, QWORD PTR [r9+4]
	add	r11, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rsi
	sub	rax, r11
	mov	r8, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	rdx, QWORD PTR tv8484[rsp]
	mov	rbx, rax
	lea	rcx, QWORD PTR [rax+r11]
	mov	rax, QWORD PTR dictBase$1$[rbp-256]
	add	rax, rdx
	cmp	rcx, rax
	jne	SHORT $LN776@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rbx+rsi]
$LN1427@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	add	rdx, QWORD PTR base$1$[rsp]
	mov	r8, rdi
	call	ZSTD_count
	add	rbx, rax
$LN776@ZSTD_BtGet:
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r10d, DWORD PTR [rbx+4]
	mov	ebx, DWORD PTR dictLimit$1$[rbp-256]
	lea	esi, DWORD PTR [r12+3]
$LN1398@ZSTD_BtGet:
	mov	r9, QWORD PTR ip$[rbp-256]
$LN606@ZSTD_BtGet:
	mov	edx, r10d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN595@ZSTD_BtGet

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, r14d
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r12d
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r10+r9]
	mov	DWORD PTR [rcx+4], r10d
	xor	ecx, ecx
	cmp	rax, rdi
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	DWORD PTR mnum$1$[rsp], r8d
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN594@ZSTD_BtGet
$LN595@ZSTD_BtGet:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv8482[rsp]
	inc	r14d
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	r15, 4
	mov	r10d, DWORD PTR current$1$[rsp]
	cmp	r14d, esi
	jb	$LL597@ZSTD_BtGet
	mov	r15d, DWORD PTR nbCompares$1$[rsp]
	mov	r8, QWORD PTR commonLengthSmaller$1$[rbp-256]
$LN596@ZSTD_BtGet:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv8485[rbp-256]
	mov	DWORD PTR [rax], r10d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1257@ZSTD_BtGet
	mov	r11, QWORD PTR commonLengthLarger$1$[rbp-256]
$LL598@ZSTD_BtGet:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	r13d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1408@ZSTD_BtGet

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rbx, r11
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r13d

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	mov	esi, DWORD PTR dictMode$[rbp-256]
	add	eax, eax
	cmp	r8, r11
	cmovb	rbx, r8
	lea	r10, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR nextPtr$1$[rbp-256], r10
	test	esi, -3					; fffffffdH
	je	$LN618@ZSTD_BtGet
	mov	rdx, QWORD PTR tv8484[rsp]
	mov	r14d, r13d
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, rdx
	jae	$LN618@ZSTD_BtGet

; 654  :             match = dictBase + matchIndex;

	mov	r8, QWORD PTR dictBase$1$[rbp-256]

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r15, QWORD PTR [rbx+r9]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r15
	lea	rcx, QWORD PTR [rdx+r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 654  :             match = dictBase + matchIndex;

	lea	r12, QWORD PTR [r14+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR tv8484[rsp]
	mov	rax, QWORD PTR dictBase$1$[rbp-256]
	add	rax, r11
	cmp	rcx, rax
	je	SHORT $LN846@ZSTD_BtGet
	mov	r15, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN845@ZSTD_BtGet
$LN846@ZSTD_BtGet:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rsi+r15]
	mov	r8, rdi
	mov	r15, QWORD PTR base$1$[rsp]
	lea	rdx, QWORD PTR [r11+r15]
	call	ZSTD_count
	add	rsi, rax
$LN845@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 657  :             if (matchIndex+matchLength >= dictLimit)

	mov	r10, QWORD PTR nextPtr$1$[rbp-256]
	add	rbx, rsi
	mov	esi, DWORD PTR dictMode$[rbp-256]
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, r11
	mov	r11, QWORD PTR commonLengthLarger$1$[rbp-256]
	jb	SHORT $LN1378@ZSTD_BtGet

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	lea	r12, QWORD PTR [r14+r15]
$LN1378@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
$LN620@ZSTD_BtGet:
	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN1394@ZSTD_BtGet

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r13d
	cmp	rbx, rax
	jbe	SHORT $LN622@ZSTD_BtGet

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+r13]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN622@ZSTD_BtGet:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r13d

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR mnum$1$[rsp], r8d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN623@ZSTD_BtGet

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	cmp	esi, 2
	jne	$LN599@ZSTD_BtGet
	xor	r15d, r15d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN599@ZSTD_BtGet
$LN618@ZSTD_BtGet:

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+r9]
	mov	r12d, r13d
	add	r12, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN804@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN806@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$5[rsp], 0
	je	SHORT $LN821@ZSTD_BtGet
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN620@ZSTD_BtGet
$LN821@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN620@ZSTD_BtGet
$LN806@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN804@ZSTD_BtGet
$LL803@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN807@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL803@ZSTD_BtGet
$LN804@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN808@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN808@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN808@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN809@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN809@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN809@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN810@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN810@ZSTD_BtGet
	inc	rcx
$LN810@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN620@ZSTD_BtGet
$LN807@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$4[rsp], 0
	je	SHORT $LN837@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN620@ZSTD_BtGet
$LN837@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN620@ZSTD_BtGet
$LN1394@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR ip$[rbp-256]
$LN623@ZSTD_BtGet:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [r12+rbx], al
	jae	SHORT $LN625@ZSTD_BtGet

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	r8, rbx
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r13d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8413[rbp-256]
	jbe	$LN1233@ZSTD_BtGet

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r13d, DWORD PTR [r10+4]
	lea	rdx, QWORD PTR [r10+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rdx

; 685  :         } else {

	jmp	SHORT $LN626@ZSTD_BtGet
$LN625@ZSTD_BtGet:

; 687  :             commonLengthLarger = matchLength;

	mov	r11, rbx
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r13d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8413[rbp-256]
	jbe	$LN1234@ZSTD_BtGet

; 690  :             matchIndex = nextPtr[0];

	mov	r13d, DWORD PTR [r10]
	mov	r8, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 689  :             largerPtr = nextPtr;

	mov	QWORD PTR largerPtr$1$[rbp-256], r10
$LN626@ZSTD_BtGet:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	jne	$LL598@ZSTD_BtGet
$LN1257@ZSTD_BtGet:
	dec	r15d
$LN1408@ZSTD_BtGet:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN599@ZSTD_BtGet:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], 0
	mov	DWORD PTR [rax], 0
	jne	$LN1374@ZSTD_BtGet
	test	r15d, r15d
	je	$LN1374@ZSTD_BtGet

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
	mov	rdx, QWORD PTR [r9]
	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR dmsHashLog$1$[rbp-256]
	imul	rdx, rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rax, QWORD PTR [r8+48]

; 698  :         const U32* const dmsBt = dms->chainTable;

	mov	r8, QWORD PTR [r8+64]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	r14d, DWORD PTR [rax+rdx*4]
	xor	edx, edx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
	npad	12
$LL600@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1374@ZSTD_BtGet

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx
	mov	eax, r14d
	mov	r12d, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	add	eax, eax
	cmp	rdx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	cmovb	rbx, rdx

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	add	rsi, r12
	lea	rax, QWORD PTR [r8+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	mov	QWORD PTR nextPtr$1$[rbp-256], rax

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	lea	r13, QWORD PTR [rbx+r9]
	lea	r11, QWORD PTR [rsi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r13
	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR base$1$[rsp]
	cmp	rcx, QWORD PTR dmsEnd$1$[rsp]
	jne	SHORT $LN879@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv8484[rsp]
	lea	rcx, QWORD PTR [rax+r13]
	add	rdx, r11
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN879@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rbp-256]
	add	rbx, r15
	lea	rcx, QWORD PTR [r12+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1416@ZSTD_BtGet

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r12+rax]
	add	rsi, r11
	jmp	SHORT $LN630@ZSTD_BtGet
$LN1233@ZSTD_BtGet:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$13[rsp]
	jmp	$LN599@ZSTD_BtGet
$LN1234@ZSTD_BtGet:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$13[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN1408@ZSTD_BtGet
$LN1416@ZSTD_BtGet:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN630@ZSTD_BtGet:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1393@ZSTD_BtGet

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1290@ZSTD_BtGet

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1290@ZSTD_BtGet:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, edx

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR mnum$1$[rsp], r8d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1374@ZSTD_BtGet

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN633@ZSTD_BtGet
$LN1393@ZSTD_BtGet:
	mov	r9, QWORD PTR ip$[rbp-256]
$LN633@ZSTD_BtGet:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR dmsBtLow$1$[rsp]
	jbe	SHORT $LN1374@ZSTD_BtGet

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [rsi+rbx], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN635@ZSTD_BtGet

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [rax+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN636@ZSTD_BtGet
$LN635@ZSTD_BtGet:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [rax]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN636@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r15d, r15d
	jne	$LL600@ZSTD_BtGet
$LN1374@ZSTD_BtGet:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	ecx, DWORD PTR matchEndIdx$1$[rsp]
$LN1425@ZSTD_BtGet:
	mov	r13, QWORD PTR ms$[rbp-256]
	add	ecx, -8					; fffffff8H
	mov	r8d, DWORD PTR mnum$1$[rsp]
	mov	DWORD PTR [r13+36], ecx
$LN594@ZSTD_BtGet:

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	mov	eax, r8d
	jmp	$LN1422@ZSTD_BtGet
$LN5@ZSTD_BtGet:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r14d, 1
	mov	ebx, DWORD PTR [r12+192]
	cmp	eax, ecx
	mov	r8, QWORD PTR [r12+48]
	cmovb	ecx, eax

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r12+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	sub	r10d, r11d

; 528  :     U32* const bt   = ms->chainTable;

	mov	r9, QWORD PTR [r12+64]
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	sub	ecx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 523  :     U32 const hashLog = cParams->hashLog;

	mov	DWORD PTR dmsHashLog$1$[rbp-256], ebx

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	ebx, ebx
	mov	QWORD PTR bt$1$[rbp-256], r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r13d, DWORD PTR [r8+rdx*4]
	lea	rax, QWORD PTR [r8+rdx*4]

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, r14d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	mov	QWORD PTR tv8472[rbp-256], rax

; 529  :     U32 const btLog = cParams->chainLog - 1;

	dec	ecx

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rax, QWORD PTR [r12+16]
	mov	r8d, r14d
	mov	QWORD PTR dictBase$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	shl	r8d, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	dec	r8d
	mov	QWORD PTR base$1$[rsp], r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	sub	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 522  :     U32 const current = (U32)(ip-base);

	mov	DWORD PTR current$1$[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	r8d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	DWORD PTR btMask$1$[rbp-256], r8d

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	DWORD PTR tv8412[rbp-256], ecx

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r10d
	mov	ecx, DWORD PTR [r12+184]
	shl	edx, cl
	mov	ecx, DWORD PTR [r12+28]
	sub	eax, ecx

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r12d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rbp-256], esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r12d, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	QWORD PTR tv8471[rbp-256], rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 543  :     U32 mnum = 0;

	mov	DWORD PTR $T1[rsp], ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	rdx, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	mov	eax, r14d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r12d, ecx
	cmp	DWORD PTR [rdx+32], ebx

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r12d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [rdx+196]
	test	r12d, r12d
	cmovne	eax, r12d
	mov	DWORD PTR matchLow$1$[rsp], eax
	mov	eax, r8d
	and	eax, r10d
	add	eax, eax
	lea	rax, QWORD PTR [r9+rax*4]
	mov	r9d, ebx
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r10+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	eax, r14d
	shl	eax, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	DWORD PTR nbCompares$1$[rsp], eax
	jne	SHORT $LN62@ZSTD_BtGet
	mov	r8, QWORD PTR [rdx+176]

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	eax, r12d
	mov	QWORD PTR dms$1$[rbp-256], r8
	mov	rdx, QWORD PTR [r8]
	mov	rbx, QWORD PTR [r8+8]
	mov	r11d, edx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r8+188]
	sub	r11d, ebx
	sub	eax, r11d
	mov	QWORD PTR dmsEnd$1$[rbp-256], rdx
	mov	edx, DWORD PTR [r8+28]
	dec	ecx
	mov	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	eax, DWORD PTR [r8+192]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, r14d
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r11d
	shl	r8d, cl
	sub	eax, edx
	dec	r8d
	mov	QWORD PTR dmsBase$1$[rbp-256], rbx
	mov	DWORD PTR dmsHighLimit$1$[rsp], r11d
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	DWORD PTR dmsBtMask$1$[rbp-256], r8d
	cmp	r8d, eax
	jae	SHORT $LN82@ZSTD_BtGet
	mov	ecx, r11d
	sub	ecx, r8d
	mov	DWORD PTR dmsBtLow$1$[rbp-256], ecx
	jmp	SHORT $LN83@ZSTD_BtGet
$LN62@ZSTD_BtGet:

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	mov	QWORD PTR dms$1$[rbp-256], rbx

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	edx, ebx
	mov	QWORD PTR dmsBase$1$[rbp-256], rbx
	mov	QWORD PTR dmsEnd$1$[rbp-256], rbx
	mov	DWORD PTR dmsHighLimit$1$[rsp], ebx
	mov	DWORD PTR dmsLowLimit$1$[rsp], ebx

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;

	mov	DWORD PTR dmsIndexDelta$1$[rsp], ebx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	DWORD PTR dmsBtMask$1$[rbp-256], ebx
$LN82@ZSTD_BtGet:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rbp-256], edx
$LN83@ZSTD_BtGet:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;
; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	r11d, DWORD PTR ll0$[rbp-256]
	mov	r8d, DWORD PTR lengthToBeat$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r14d, r11d
	dec	r8d
	mov	QWORD PTR bestLength$1$[rsp], r8
	lea	ebx, DWORD PTR [r11+3]
	mov	DWORD PTR lastR$1$[rbp-256], ebx
	cmp	r11d, ebx
	jae	$LN1365@ZSTD_BtGet
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	edx, r10d
	sub	edx, esi
	mov	DWORD PTR tv8469[rsp], edx
	lea	r15, QWORD PTR [rcx+r11*4]
$LL17@ZSTD_BtGet:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r14d, 3
	jne	SHORT $LN84@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN85@ZSTD_BtGet
$LN84@ZSTD_BtGet:
	mov	eax, DWORD PTR [r15]
$LN85@ZSTD_BtGet:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r10d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r10d, r10d
	cmp	ecx, edx
	jae	$LN22@ZSTD_BtGet

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rcx, QWORD PTR ip$[rbp-256]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	edx, edx
	mov	r11d, eax
	mov	rax, rcx
	sub	rax, r11

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r8d, DWORD PTR [rcx]
	shl	r8d, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	ecx, DWORD PTR [rax]
	shl	ecx, 8
	cmp	r8d, ecx
	sete	dl
	xor	eax, eax
	cmp	r9d, r12d
	setae	al
	test	edx, eax
	je	$LN1381@ZSTD_BtGet

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rdx, rax
	sub	rdx, r11
	add	rdx, 3
	lea	rcx, QWORD PTR [rax+3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r9, rcx

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN139@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN141@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN156@ZSTD_BtGet
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1381@ZSTD_BtGet
$LN156@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1381@ZSTD_BtGet
$LN141@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN139@ZSTD_BtGet
$LL138@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN142@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL138@ZSTD_BtGet
$LN139@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN143@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN143@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN143@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN144@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN144@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN144@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN145@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN145@ZSTD_BtGet
	inc	rcx
$LN145@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1381@ZSTD_BtGet
$LN142@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN172@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1381@ZSTD_BtGet
$LN172@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r10d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN1381@ZSTD_BtGet
$LN22@ZSTD_BtGet:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	eax, DWORD PTR dictMode$[rbp-256]
	mov	r8d, r9d
	cmp	eax, 2
	jne	$LN86@ZSTD_BtGet
	mov	edx, DWORD PTR dmsIndexDelta$1$[rsp]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	r8, rdx
	add	r8, QWORD PTR dmsBase$1$[rbp-256]
	sub	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, esi
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN26@ZSTD_BtGet

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r9, QWORD PTR ip$[rbp-256]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR [r8]
	shl	eax, 8

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [r9]
	shl	ecx, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	$LN26@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [r8+3]
	lea	rsi, QWORD PTR [r9+3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
	mov	rax, rsi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	sub	rax, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count
	mov	rbx, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dmsEnd$1$[rbp-256]
	jne	$LN196@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv8471[rbp-256]
	lea	rcx, QWORD PTR [rax+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	jmp	$LN1428@ZSTD_BtGet
$LN86@ZSTD_BtGet:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, 1
	jne	$LN26@ZSTD_BtGet
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r12d
	cmp	ecx, eax
	mov	ecx, esi
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN26@ZSTD_BtGet

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r9, QWORD PTR ip$[rbp-256]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	rdx, QWORD PTR dictBase$1$[rsp]

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [r9]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR [r8+rdx]

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	shl	eax, 8
	cmp	ecx, eax
	jne	SHORT $LN26@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR tv8471[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	r11, QWORD PTR [rdx+3]
	add	r11, r8
	lea	rsi, QWORD PTR [r9+3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	add	rcx, rdx
	mov	rax, rsi
	sub	rax, r11
	mov	r8, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, rsi
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	rdx, QWORD PTR tv8471[rbp-256]
	mov	rbx, rax
	lea	rcx, QWORD PTR [rax+r11]
	mov	rax, QWORD PTR dictBase$1$[rsp]
	add	rax, rdx
	cmp	rcx, rax
	jne	SHORT $LN196@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rbx+rsi]
$LN1428@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 596  :             if (repLen > bestLength) {

	add	rdx, QWORD PTR base$1$[rsp]
	mov	r8, rdi
	call	ZSTD_count
	add	rbx, rax
$LN196@ZSTD_BtGet:
	mov	esi, DWORD PTR dictLimit$1$[rbp-256]
	lea	r10d, DWORD PTR [rbx+3]
	mov	ebx, DWORD PTR lastR$1$[rbp-256]
$LN1381@ZSTD_BtGet:
	mov	r11d, DWORD PTR ll0$[rbp-256]
$LN26@ZSTD_BtGet:
	mov	r8, QWORD PTR bestLength$1$[rsp]
	mov	edx, r10d
	cmp	rdx, r8
	jbe	SHORT $LN1391@ZSTD_BtGet

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR $T1[rsp]
	mov	eax, r14d
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r11d
	mov	DWORD PTR [rcx+r9*8], eax
	lea	rcx, QWORD PTR [rcx+r9*8]

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	mov	rax, QWORD PTR ip$[rbp-256]
	inc	r9d
	add	rax, rdx
	mov	DWORD PTR [rcx+4], r10d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	rax, rdi
	mov	DWORD PTR $T1[rsp], r9d
	mov	r8d, edx
	sete	cl
	xor	eax, eax
	cmp	r10d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN14@ZSTD_BtGet

; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN15@ZSTD_BtGet
$LN1391@ZSTD_BtGet:
	mov	r9d, DWORD PTR $T1[rsp]
$LN15@ZSTD_BtGet:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r14d
	add	r15, 4
	cmp	r14d, ebx
	jae	SHORT $LN1365@ZSTD_BtGet
	mov	edx, DWORD PTR tv8469[rsp]
	mov	rcx, QWORD PTR rep$[rbp-256]
	mov	r10d, DWORD PTR current$1$[rsp]
	jmp	$LL17@ZSTD_BtGet
$LN1365@ZSTD_BtGet:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15, QWORD PTR ip$[rbp-256]
	cmp	r8, 3
	jae	$LN1392@ZSTD_BtGet

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r12, QWORD PTR ms$[rbp-256]
	mov	r8, r15
	mov	rdx, QWORD PTR nextToUpdate3$[rbp-256]
	mov	rcx, r12
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r11d, DWORD PTR current$1$[rsp]
	xor	edx, edx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	ebx, r11d
	mov	r14d, DWORD PTR dictMode$[rbp-256]
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	xor	ecx, ecx
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1389@ZSTD_BtGet

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	test	r14d, -3				; fffffffdH
	je	SHORT $LN33@ZSTD_BtGet
	cmp	eax, esi
	jae	SHORT $LN33@ZSTD_BtGet

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;

	mov	r9, QWORD PTR dictBase$1$[rsp]

; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	r8, rdi
	mov	edx, eax
	mov	rax, QWORD PTR base$1$[rsp]
	add	rdx, r9
	mov	ecx, esi
	add	rax, rcx
	add	r9, rcx
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	mov	r11d, DWORD PTR current$1$[rsp]
	jmp	SHORT $LN1424@ZSTD_BtGet
$LN33@ZSTD_BtGet:

; 615  :                 const BYTE* const match = base + matchIndex3;

	mov	edx, eax

; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, rdi
	add	rdx, QWORD PTR base$1$[rsp]
	mov	rcx, r15
	call	ZSTD_count
$LN1424@ZSTD_BtGet:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8, rax
	cmp	rax, 3
	jb	SHORT $LN1390@ZSTD_BtGet

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$[rbp-256]
	mov	rsi, rax

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	xor	edx, edx
	mov	QWORD PTR bestLength$1$[rsp], rax
	lea	eax, DWORD PTR [rbx+2]
	mov	r10d, 1
	mov	r9d, r10d
	mov	DWORD PTR $T1[rsp], r10d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rsi+r15]
	cmp	rax, rdi
	mov	DWORD PTR [rcx+4], r8d
	mov	eax, DWORD PTR sufficient_len$1$[rbp-256]
	sete	dl
	xor	ecx, ecx
	cmp	rsi, rax
	seta	cl
	or	edx, ecx
	je	SHORT $LN1419@ZSTD_BtGet

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r11+1]
	mov	DWORD PTR [r12+36], eax

; 635  :                     return 1;

	jmp	$LN14@ZSTD_BtGet
$LN1389@ZSTD_BtGet:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r9d, DWORD PTR $T1[rsp]
	mov	rsi, QWORD PTR bestLength$1$[rsp]
	jmp	SHORT $LN35@ZSTD_BtGet
$LN1390@ZSTD_BtGet:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9d, DWORD PTR $T1[rsp]
	jmp	SHORT $LN1429@ZSTD_BtGet
$LN1392@ZSTD_BtGet:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r14d, DWORD PTR dictMode$[rbp-256]
$LN1429@ZSTD_BtGet:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rsi, QWORD PTR bestLength$1$[rsp]
$LN1419@ZSTD_BtGet:
	mov	r8d, DWORD PTR matchLow$1$[rsp]
$LN35@ZSTD_BtGet:
	mov	rax, QWORD PTR tv8472[rbp-256]

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r11d, DWORD PTR nbCompares$1$[rsp]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx
	test	r11d, r11d
	je	$LN1262@ZSTD_BtGet
	npad	8
$LL18@ZSTD_BtGet:
	dec	r11d
	mov	DWORD PTR nbCompares$1$[rsp], r11d
	cmp	r13d, r8d
	jb	$LN1415@ZSTD_BtGet

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r13d
	add	eax, eax
	lea	r10, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	mov	QWORD PTR nextPtr$1$[rbp-256], r10
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	r14d, -3				; fffffffdH
	je	$LN38@ZSTD_BtGet
	mov	rdx, QWORD PTR tv8471[rbp-256]
	mov	r14d, r13d
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, rdx
	jae	$LN38@ZSTD_BtGet

; 654  :             match = dictBase + matchIndex;

	mov	r8, QWORD PTR dictBase$1$[rsp]

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	add	r15, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r15
	lea	rcx, QWORD PTR [rdx+r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 654  :             match = dictBase + matchIndex;

	lea	r12, QWORD PTR [r14+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR tv8471[rbp-256]
	mov	rax, QWORD PTR dictBase$1$[rsp]
	add	rax, r11
	cmp	rcx, rax
	je	SHORT $LN266@ZSTD_BtGet
	mov	r15, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN265@ZSTD_BtGet
$LN266@ZSTD_BtGet:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	lea	rcx, QWORD PTR [rsi+r15]
	mov	r8, rdi
	mov	r15, QWORD PTR base$1$[rsp]
	lea	rdx, QWORD PTR [r11+r15]
	call	ZSTD_count
	add	rsi, rax
$LN265@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 657  :             if (matchIndex+matchLength >= dictLimit)

	mov	r10, QWORD PTR nextPtr$1$[rbp-256]
	add	rbx, rsi
	mov	rsi, QWORD PTR bestLength$1$[rsp]
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, r11
	mov	r11d, DWORD PTR nbCompares$1$[rsp]
	jb	SHORT $LN1376@ZSTD_BtGet

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	lea	r12, QWORD PTR [r14+r15]
$LN1376@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	mov	r15, QWORD PTR ip$[rbp-256]
$LN40@ZSTD_BtGet:
	cmp	rbx, rsi
	jbe	$LN1388@ZSTD_BtGet

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r13d
	cmp	rbx, rax
	jbe	SHORT $LN42@ZSTD_BtGet

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+r13]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN42@ZSTD_BtGet:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r9d, DWORD PTR $T1[rsp]
	mov	rsi, rbx
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, r13d
	add	eax, 2

; 669  :             matches[mnum].len = (U32)matchLength;

	mov	DWORD PTR [rcx+r9*8+4], edx
	lea	rcx, QWORD PTR [rcx+r9*8]

; 670  :             mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	lea	rax, QWORD PTR [rbx+r15]
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	cmp	rax, rdi
	mov	DWORD PTR $T1[rsp], r9d
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN43@ZSTD_BtGet

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rax, QWORD PTR smallerPtr$1$[rsp]
	jne	$LN19@ZSTD_BtGet
	xor	r11d, r11d

; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	jmp	$LN19@ZSTD_BtGet
$LN38@ZSTD_BtGet:

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+r15]
	mov	r12d, r13d
	add	r12, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rdx, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN224@ZSTD_BtGet

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN226@ZSTD_BtGet

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$11[rsp], 0
	je	SHORT $LN241@ZSTD_BtGet
	shr	eax, 3
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN40@ZSTD_BtGet
$LN241@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN40@ZSTD_BtGet
$LN226@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN224@ZSTD_BtGet
	npad	7
$LL223@ZSTD_BtGet:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN227@ZSTD_BtGet
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL223@ZSTD_BtGet
$LN224@ZSTD_BtGet:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN228@ZSTD_BtGet
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN228@ZSTD_BtGet
	add	rcx, 4
	add	rdx, 4
$LN228@ZSTD_BtGet:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN229@ZSTD_BtGet
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN229@ZSTD_BtGet
	add	rcx, 2
	add	rdx, 2
$LN229@ZSTD_BtGet:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN230@ZSTD_BtGet
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN230@ZSTD_BtGet
	inc	rcx
$LN230@ZSTD_BtGet:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN40@ZSTD_BtGet
$LN227@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$10[rsp], 0
	je	SHORT $LN257@ZSTD_BtGet
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN40@ZSTD_BtGet
$LN257@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN40@ZSTD_BtGet
$LN1388@ZSTD_BtGet:

; 661  :         if (matchLength > bestLength) {

	mov	r9d, DWORD PTR $T1[rsp]
$LN43@ZSTD_BtGet:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r15]
	cmp	BYTE PTR [r12+rbx], al
	jae	SHORT $LN45@ZSTD_BtGet

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r13d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8412[rbp-256]
	jbe	SHORT $LN1239@ZSTD_BtGet

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r13d, DWORD PTR [r10+4]
	lea	rax, QWORD PTR [r10+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN46@ZSTD_BtGet
$LN45@ZSTD_BtGet:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r13d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r13d, DWORD PTR tv8412[rbp-256]
	jbe	SHORT $LN1240@ZSTD_BtGet

; 690  :             matchIndex = nextPtr[0];

	mov	r13d, DWORD PTR [r10]
	mov	QWORD PTR largerPtr$1$[rbp-256], r10
$LN46@ZSTD_BtGet:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r11d, r11d
	je	SHORT $LN1262@ZSTD_BtGet
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	r14d, DWORD PTR dictMode$[rbp-256]
	jmp	$LL18@ZSTD_BtGet
$LN1239@ZSTD_BtGet:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$15[rsp]
	jmp	SHORT $LN19@ZSTD_BtGet
$LN1240@ZSTD_BtGet:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$15[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	SHORT $LN1415@ZSTD_BtGet
$LN1262@ZSTD_BtGet:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r11d
$LN1415@ZSTD_BtGet:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN19@ZSTD_BtGet:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], 0
	mov	DWORD PTR [rax], 0
	jne	$LN1375@ZSTD_BtGet
	test	r11d, r11d
	je	$LN1375@ZSTD_BtGet
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r15], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR dmsHashLog$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	r8, QWORD PTR dms$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	ecx, ecx
	mov	rax, QWORD PTR [r8+48]
	mov	r8, QWORD PTR [r8+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], r8
	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rcx
	mov	r14d, DWORD PTR [rax+rdx*4]
	xor	edx, edx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rdx
$LL20@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r11d
	mov	DWORD PTR nbCompares$1$[rsp], r11d
	cmp	r14d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN1375@ZSTD_BtGet

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rsi, QWORD PTR dmsBase$1$[rbp-256]
	mov	rbx, rcx
	mov	eax, r14d
	mov	r12d, r14d
	and	eax, DWORD PTR dmsBtMask$1$[rbp-256]
	add	eax, eax
	cmp	rdx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dmsEnd$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	cmovb	rbx, rdx

; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	add	rsi, r12
	lea	rax, QWORD PTR [r8+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdi
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);

	mov	QWORD PTR nextPtr$1$[rbp-256], rax

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	lea	r13, QWORD PTR [rbx+r15]
	lea	r11, QWORD PTR [rsi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r13
	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	mov	r11, QWORD PTR base$1$[rsp]
	cmp	rcx, QWORD PTR dmsEnd$1$[rbp-256]
	jne	SHORT $LN299@ZSTD_BtGet

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR tv8471[rbp-256]
	lea	rcx, QWORD PTR [rax+r13]
	add	rdx, r11
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN299@ZSTD_BtGet:
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsHighLimit$1$[rsp]
	add	rbx, r15
	lea	rcx, QWORD PTR [r12+rbx]
	cmp	rcx, rax
	jb	SHORT $LN1418@ZSTD_BtGet

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	lea	rsi, QWORD PTR [r12+rax]
	add	rsi, r11
	jmp	SHORT $LN50@ZSTD_BtGet
$LN1418@ZSTD_BtGet:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR dmsIndexDelta$1$[rsp]
$LN50@ZSTD_BtGet:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN1387@ZSTD_BtGet

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r14+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN1292@ZSTD_BtGet

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1292@ZSTD_BtGet:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r9d, DWORD PTR $T1[rsp]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$[rbp-256]
	sub	eax, edx

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r15, QWORD PTR ip$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r9d
	xor	ecx, ecx
	mov	QWORD PTR bestLength$1$[rsp], rbx
	lea	rax, QWORD PTR [rbx+r15]
	mov	DWORD PTR $T1[rsp], r9d
	cmp	rax, rdi
	sete	cl
	xor	eax, eax
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1375@ZSTD_BtGet

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN53@ZSTD_BtGet
$LN1387@ZSTD_BtGet:
	mov	r9d, DWORD PTR $T1[rsp]
	mov	r15, QWORD PTR ip$[rbp-256]
$LN53@ZSTD_BtGet:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR dmsBtLow$1$[rbp-256]
	jbe	SHORT $LN1375@ZSTD_BtGet

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r15]
	cmp	BYTE PTR [rsi+rbx], al
	mov	rax, QWORD PTR nextPtr$1$[rbp-256]
	jae	SHORT $LN55@ZSTD_BtGet

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r14d, DWORD PTR [rax+4]
	mov	rdx, rbx

; 728  :             } else {

	mov	rcx, QWORD PTR commonLengthLarger$2$[rbp-256]
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx
	jmp	SHORT $LN56@ZSTD_BtGet
$LN55@ZSTD_BtGet:

; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [rax]
	mov	rcx, rbx
	mov	rdx, QWORD PTR commonLengthSmaller$2$[rbp-256]

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$2$[rbp-256], rbx
$LN56@ZSTD_BtGet:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r11d, DWORD PTR nbCompares$1$[rsp]
	mov	r8, QWORD PTR dmsBt$1$[rbp-256]
	test	r11d, r11d
	jne	$LL20@ZSTD_BtGet
$LN1375@ZSTD_BtGet:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	r13, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR matchEndIdx$1$[rsp]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [r13+36], ecx
$LN14@ZSTD_BtGet:

; 757  :     {
; 758  :     case 3 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 3);

	mov	eax, r9d
$LN1422@ZSTD_BtGet:
	mov	rdi, QWORD PTR [rsp+272]
	mov	rsi, QWORD PTR [rsp+280]
	mov	r13, QWORD PTR [rsp+264]

; 764  :     }
; 765  : }

	add	rsp, 288				; 00000120H
	pop	r15
	pop	r14
	pop	r12
	pop	rbx
	pop	rbp
	ret	0
ZSTD_BtGetAllMatches ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
sol$ = 8
ZSTD_totalLen PROC

; 775  :     return sol.litlen + sol.mlen;

	mov	eax, DWORD PTR [rcx+12]
	add	eax, DWORD PTR [rcx+8]

; 776  : }

	ret	0
ZSTD_totalLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
nbCompares$1$ = 48
current$1$ = 48
current$1$ = 48
matchEndIdx$1$ = 48
matchEndIdx$1$ = 48
nbCompares$1$ = 48
matchEndIdx$1$ = 48
tv16438 = 48
current$1$ = 52
lastR$1$ = 52
lastR$1$ = 52
current$1$ = 52
ll0$1$ = 52
iend$1$ = 56
dmsLowLimit$1$ = 64
matchEndIdx$1$ = 64
matchLow$1$ = 64
dmsLowLimit$1$ = 64
dmsLowLimit$1$ = 64
dmsLowLimit$1$ = 64
dmsLowLimit$1$ = 64
tv16440 = 64
current$1$ = 68
lastR$1$ = 68
lastR$1$ = 68
current$1$ = 68
ll0$1$ = 68
matchEndIdx$1$ = 72
nbCompares$1$ = 72
matchEndIdx$1$ = 72
matchEndIdx$1$ = 72
matchLow$1$ = 72
tv16448 = 72
tv16444 = 72
ip$1$ = 80
nbCompares$1$ = 88
cur$1$ = 88
tv16452 = 88
tv16450 = 88
tv16446 = 88
nbCompares$1$ = 92
current$1$ = 92
current$1$ = 92
nbCompares$1$ = 92
seqPos$1$ = 92
lastR$1$ = 96
dmsLowLimit$1$ = 96
dmsLowLimit$1$ = 96
dmsLowLimit$1$ = 96
lastR$1$ = 96
dmsBtLow$1$ = 96
dmsBtLow$1$ = 96
lastR$1$ = 96
matchEndIdx$1$ = 100
nbCompares$1$ = 100
nbCompares$1$ = 100
dmsBtLow$1$ = 100
tv16743 = 100
tv16442 = 100
dmsBtMask$1$ = 104
dmsBtMask$1$ = 104
dmsHashLog$1$ = 104
dmsHashLog$1$ = 104
dmsHashLog$1$ = 104
dmsHashLog$1$ = 104
matchNb$1$ = 104
tv16778 = 104
tv16447 = 104
dmsBtLow$1$ = 108
dictLimit$1$ = 108
dmsBtMask$1$ = 108
tv16779 = 108
tv16774 = 108
tv16773 = 108
tv16746 = 108
tv16741 = 108
dictBase$1$ = 112
dms$1$ = 112
dms$1$ = 112
bestLength$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
smallerPtr$1$ = 112
largerPtr$1$ = 112
dmsBtLow$1$ = 120
dmsBtMask$1$ = 120
dmsBtMask$1$ = 120
dmsBtMask$1$ = 120
dmsBtMask$1$ = 120
dmsBtMask$1$ = 120
dmsHashLog$1$ = 120
tv16680 = 120
btMask$1$ = 128
sufficient_len$1$ = 128
sufficient_len$1$ = 128
prefixStart$1$ = 128
dictBase$1$ = 128
prefixStart$1$ = 128
dmsBase$2$ = 128
tv18051 = 128
tv17982 = 128
tv17927 = 128
tv16543 = 128
tv16532 = 128
dummy32$1 = 128
dummy32$2 = 128
dummy32$3 = 128
dummy32$4 = 128
bestLength$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
largerPtr$1$ = 136
largerPtr$1$ = 136
largerPtr$1$ = 136
prefixStart$1$ = 136
smallerPtr$1$ = 144
bestLength$1$ = 144
bestLength$1$ = 144
prefixStart$1$ = 144
dmsBase$2$ = 144
dmsBase$2$ = 144
dmsBase$2$ = 144
bestLength$1$ = 144
dms$1$ = 152
commonLengthSmaller$2$ = 152
commonLengthSmaller$2$ = 152
bt$1$ = 152
commonLengthSmaller$2$ = 152
bt$1$ = 152
commonLengthSmaller$2$ = 152
bt$1$ = 152
dmsBt$1$ = 152
dmsBt$1$ = 152
dmsBt$1$ = 152
dmsBt$1$ = 152
tv16647 = 152
tv16629 = 152
tv16617 = 152
tv16605 = 152
tv16455 = 152
bestLength$1$ = 160
rep$1$ = 160
bestLength$1$ = 160
bestLength$1$ = 160
smallerPtr$1$ = 160
dictLimit$1$ = 168
dictLimit$1$ = 168
dmsBtLow$1$ = 168
sufficient_len$1$ = 168
btMask$1$ = 168
btMask$1$ = 168
btMask$1$ = 168
offset$1$ = 168
sufficient_len$1$ = 172
sufficient_len$1$ = 172
sufficient_len$1$ = 172
tv16602 = 172
tv16587 = 172
dummy32$5 = 172
dummy32$6 = 172
dummy32$7 = 172
dummy32$8 = 172
dmsEnd$2$ = 176
largerPtr$1$ = 176
largerPtr$1$ = 176
largerPtr$1$ = 176
base$1$ = 176
base$1$ = 176
base$1$ = 176
dictBase$1$ = 176
prefixStart$1$ = 184
dmsBase$2$ = 184
dmsBase$2$ = 184
dmsBase$2$ = 184
commonLengthSmaller$1$ = 184
dictEnd$1$ = 184
tv16644 = 184
tv16628 = 184
dmsBase$2$ = 192
prefixStart$1$ = 192
prefixStart$1$ = 192
dmsEnd$2$ = 192
commonLengthSmaller$1$ = 192
commonLengthLarger$1$ = 192
commonLengthSmaller$1$ = 192
commonLengthLarger$1$ = 192
sufficient_len$1$ = 200
litlen$1$ = 200
tv16453 = 200
tv16451 = 200
tv16449 = 200
windowLow$1$ = 204
dmsBtLow$1$ = 204
matchLow$1$ = 204
matchLow$1$ = 204
matchLow$1$ = 204
btMask$1$ = 204
startML$1$ = 204
matchLow$1$ = 208
btMask$1$ = 208
dmsEnd$2$ = 208
prefixStart$1$ = 208
dmsEnd$2$ = 208
dmsEnd$2$ = 208
tv16567 = 208
tv16555 = 208
r$9 = 208
r$10 = 208
r$11 = 208
r$12 = 208
largerPtr$1$ = 216
dmsEnd$2$ = 216
dmsEnd$2$ = 216
base$1$ = 216
commonLengthLarger$1$ = 216
dms$1$ = 216
commonLengthLarger$1$ = 216
dms$1$ = 216
base$1$ = 224
base$1$ = 224
base$1$ = 224
dictBase$1$ = 224
dictBase$1$ = 224
dictEnd$1$ = 224
dictBase$1$ = 224
tv16604 = 224
tv16464 = 224
dmsHashLog$1$ = 232
dmsHashLog$1$ = 232
dmsHashLog$1$ = 232
dmsBtLow$1$ = 232
tv16443 = 232
dictLimit$1$ = 236
litlen$1$ = 236
tv16445 = 236
tv16441 = 236
tv16439 = 236
matches$1$ = 240
dictEnd$1$ = 248
commonLengthSmaller$1$ = 248
commonLengthSmaller$1$ = 248
dictEnd$1$ = 248
dictEnd$1$ = 248
dictEnd$1$ = 248
commonLengthSmaller$1$ = 248
tv16764 = 248
tv16616 = 248
commonLengthLarger$1$ = 256
commonLengthLarger$1$ = 256
dms$1$ = 256
dms$1$ = 256
dms$1$ = 256
tv16463 = 256
commonLengthLarger$1$ = 264
dictBase$1$ = 264
dictBase$1$ = 264
bt$1$ = 264
bt$1$ = 264
bt$1$ = 264
bt$1$ = 264
tv16545 = 264
matchLow$1$ = 272
matchLow$1$ = 272
dmsEnd$2$ = 272
base$1$ = 272
tv17872 = 272
tv16580 = 272
dmsBt$1$ = 280
bt$1$ = 280
dmsBt$1$ = 280
dmsBt$1$ = 280
dmsBt$1$ = 280
tv16570 = 280
tv16558 = 280
tv16546 = 280
optStatePtr$1$ = 288
commonLengthLarger$1$ = 296
tv16584 = 296
tv16569 = 296
tv16557 = 296
commonLengthSmaller$1$ = 304
dictEnd$1$ = 304
dictEnd$1$ = 304
commonLengthSmaller$1$ = 304
sufficient_len$1$ = 312
btMask$1$ = 312
btMask$1$ = 312
minMatch$1$ = 316
opt$1$ = 320
tv16639 = 328
lastSequence$5$ = 336
nextToUpdate3$ = 340
sufficient_len$1$ = 344
lastSequence$ = 352
lastSequence$4$ = 384
ilimit$1$ = 392
tv16585 = 400
$T13 = 448
$T14 = 464
ms$ = 560
seqStore$ = 568
rep$ = 576
src$ = 584
nbMatches$1$ = 592
inr$1$ = 592
nbMatches$1$ = 592
r$15 = 592
r$16 = 592
r$17 = 592
r$18 = 592
srcSize$ = 592
optLevel$ = 600
dictMode$ = 608
ZSTD_compressBlock_opt_generic PROC

; 802  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rsp-240]
	sub	rsp, 496				; 000001f0H

; 803  :     optState_t* const optStatePtr = &ms->opt;
; 804  :     const BYTE* const istart = (const BYTE*)src;
; 805  :     const BYTE* ip = istart;
; 806  :     const BYTE* anchor = istart;
; 807  :     const BYTE* const iend = istart + srcSize;

	mov	r8, QWORD PTR srcSize$[rbp-256]
	mov	r15, rcx
	add	rcx, 72					; 00000048H

; 808  :     const BYTE* const ilimit = iend - 8;
; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH
	mov	rdi, r9
	mov	QWORD PTR optStatePtr$1$[rbp-256], rcx
	mov	eax, DWORD PTR [r15+204]
	lea	r13, QWORD PTR [r9+r8]
	mov	ebx, DWORD PTR [r15+24]
	lea	rsi, QWORD PTR [r13-8]
	add	rbx, QWORD PTR [r15+8]

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;
; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	r9d, DWORD PTR optLevel$[rbp-256]
	cmp	eax, edx
	mov	QWORD PTR iend$1$[rsp], r13
	cmovb	edx, eax
	mov	QWORD PTR ilimit$1$[rbp-256], rsi
	xor	r12d, r12d
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx
	cmp	DWORD PTR [r15+200], 3
	mov	eax, r12d
	mov	rdx, rdi
	setne	al
	add	eax, 3
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r15+36]
	mov	DWORD PTR nextToUpdate3$[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs
	cmp	rdi, rbx

; 826  :     ip += (ip==prefixStart);

	mov	eax, r12d
	sete	al
	lea	r9, QWORD PTR [rax+rdi]
	mov	QWORD PTR ip$1$[rsp], r9
	cmp	r9, rsi

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN3@ZSTD_compr
	movsd	xmm0, QWORD PTR lastSequence$[rbp-240]
	mov	eax, DWORD PTR lastSequence$[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	QWORD PTR [rsp+488], r14
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	11
$LL2@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r15+36]

; 830  :         U32 cur, last_pos = 0;
; 831  : 
; 832  :         /* find first match */
; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r9d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r14, QWORD PTR [r15+8]

; 830  :         U32 cur, last_pos = 0;
; 831  : 
; 832  :         /* find first match */
; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, edi

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r15+200]

; 830  :         U32 cur, last_pos = 0;
; 831  : 
; 832  :         /* find first match */
; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, r12d
	sete	al
	mov	DWORD PTR ll0$1$[rsp], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r14+rbx]
	cmp	r9, rax
	jb	$LN2535@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r9d
	sub	edi, r14d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, edi
	jae	SHORT $LN133@ZSTD_compr

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	cmp	DWORD PTR dictMode$[rbp-256], 1
	mov	r15d, r12d
	sete	r15b
	npad	10
$LL132@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	r9d, esi
	mov	edx, ebx
	mov	r8, r13
	add	rdx, r14
	mov	DWORD PTR [rsp+32], r15d
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL132@ZSTD_compr
	mov	r9, QWORD PTR ip$1$[rsp]
	mov	r15, QWORD PTR ms$[rbp-256]
$LN133@ZSTD_compr:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r15+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r15+36], edi

; 756  :     switch(matchLengthSearch)

	cmp	esi, 3
	je	$LN126@ZSTD_compr
	cmp	esi, 5
	je	$LN128@ZSTD_compr
	lea	eax, DWORD PTR [rsi-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r15+204]
	ja	$LN127@ZSTD_compr

; 521  :     const BYTE* const base = ms->window.base;

	mov	rsi, QWORD PTR [r15+8]
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;

	mov	r13d, DWORD PTR [r15+192]

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], rsi
	mov	eax, r9d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	eax, esi
	mov	DWORD PTR dmsHashLog$1$[rsp], r13d
	mov	edx, r13d
	mov	DWORD PTR current$1$[rsp], eax
	mov	rcx, r9
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	xor	r11d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r15+188]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
	mov	r8d, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 529  :     U32 const btLog = cParams->chainLog - 1;

	dec	ecx
	mov	r10, QWORD PTR [r15+64]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv16647[rbp-256], rax

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r9d, 1
	shl	r9d, cl

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r14d, 1
	mov	rcx, QWORD PTR [r15+16]
	dec	r9d
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	mov	r12d, DWORD PTR [r15+24]
	add	rcx, r12
	mov	QWORD PTR bt$1$[rbp-256], r10
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	eax, r12d
	mov	QWORD PTR tv16644[rbp-256], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r11d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 535  :     const BYTE* const prefixStart = base + dictLimit;

	add	rax, rsi
	mov	DWORD PTR btMask$1$[rbp-256], r9d
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	eax, r8d
	sub	eax, r9d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 543  :     U32 mnum = 0;

	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	r9d, r8d
	cmovb	ecx, eax

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	mov	DWORD PTR tv16453[rbp-256], ecx
	mov	ecx, DWORD PTR [r15+184]
	shl	edx, cl
	mov	ecx, DWORD PTR [r15+28]
	sub	eax, ecx

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r15d, r8d
	sub	r15d, edx
	cmp	eax, edx
	mov	rdx, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	mov	eax, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r15d, ecx
	cmp	DWORD PTR [rdx+32], r11d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r15d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [rdx+196]
	test	r15d, r15d
	cmovne	eax, r15d
	shl	r14d, cl
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	mov	eax, r9d
	and	eax, r8d
	add	eax, eax
	lea	rax, QWORD PTR [r10+rax*4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r8+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	jne	SHORT $LN776@ZSTD_compr
	mov	rdx, QWORD PTR [rdx+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r10d, r15d
	mov	QWORD PTR dms$1$[rbp-256], rdx
	mov	r11, QWORD PTR [rdx]
	mov	rbx, QWORD PTR [rdx+8]
	mov	esi, r11d
	mov	r9d, DWORD PTR [rdx+28]
	sub	esi, ebx

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	eax, DWORD PTR [rdx+192]
	sub	r10d, esi

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [rdx+188]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	shl	edx, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, esi
	dec	edx
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	eax, r9d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR tv16774[rsp], esi
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16452[rsp], r10d
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	cmp	edx, eax
	jae	SHORT $LN792@ZSTD_compr
	mov	ecx, esi
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	ecx, edx
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16452[rsp], r10d
	jmp	SHORT $LN793@ZSTD_compr
$LN776@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16774[rsp], r11d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, r11d
	mov	QWORD PTR dms$1$[rbp-256], r11
	mov	r10d, r11d
	mov	DWORD PTR dmsBtMask$1$[rsp], r11d
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsLowLimit$1$[rsp], r11d
	mov	DWORD PTR tv16452[rsp], r11d
$LN792@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], r9d
$LN793@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	mov	r13d, r8d
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	mov	QWORD PTR tv16639[rbp-256], rax
	sub	r13d, r12d
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r11d
	lea	rsi, QWORD PTR [rcx+rax*4]
	jmp	SHORT $LN727@ZSTD_compr
	npad	5
$LL2709@ZSTD_compr:
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r10d, DWORD PTR tv16452[rsp]
$LN727@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN794@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN795@ZSTD_compr
$LN794@ZSTD_compr:
	mov	eax, DWORD PTR [rsi]
$LN795@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r8d, r8d
	cmp	ecx, r13d
	jae	SHORT $LN732@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rcx, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r10d, eax
	neg	r10

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rcx]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx
	cmp	r9d, r15d
	mov	r9, QWORD PTR ip$1$[rsp]
	setae	cl
	xor	eax, eax
	cmp	edx, DWORD PTR [r10+r9]
	sete	al
	test	ecx, eax
	je	$LN736@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, r10
	lea	rcx, QWORD PTR [r9+4]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN2799@ZSTD_compr
$LN732@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	edx, r9d
	jne	SHORT $LN796@ZSTD_compr
	mov	eax, r10d
	mov	r10, QWORD PTR dmsBase$2$[rbp-256]
	sub	r10, rax

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, DWORD PTR tv16452[rsp]
	add	r10, rdx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, r12d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN2780@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r9, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r9]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN736@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	lea	rcx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	jmp	SHORT $LN2800@ZSTD_compr
$LN796@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	add	r10, rdx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	SHORT $LN2780@ZSTD_compr
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r15d
	cmp	ecx, eax
	mov	ecx, r12d
	setb	dl
	sub	ecx, r9d
	mov	r9, QWORD PTR ip$1$[rsp]
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN736@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r9]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN736@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	rcx, QWORD PTR [r9+4]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
$LN2800@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
$LN2799@ZSTD_compr:
	mov	r11d, DWORD PTR lastR$1$[rsp]
$LN2780@ZSTD_compr:
	mov	r9, QWORD PTR ip$1$[rsp]
$LN736@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2754@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	mov	r9, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	xor	edx, edx
	mov	ecx, edx
	lea	rax, QWORD PTR [r8+r9]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN475@ZSTD_compr

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN725@ZSTD_compr
$LN2754@ZSTD_compr:
	xor	edx, edx
$LN725@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	rcx, QWORD PTR rep$[rbp-256]
	inc	ebx
	add	rsi, 4
	cmp	ebx, r11d
	jb	$LL2709@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv16647[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r14d, r14d
	je	$LN2396@ZSTD_compr
	mov	r13, QWORD PTR bestLength$1$[rbp-256]
$LL728@ZSTD_compr:
	dec	r14d
	mov	r12d, r14d
	cmp	edi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN2706@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	lea	r15, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN748@ZSTD_compr
	mov	r14d, edi
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv16644[rbp-256]
	jae	SHORT $LN748@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r9]
	mov	rsi, QWORD PTR dictBase$1$[rbp-256]
	mov	r8, r10
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rsi, r14
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv16644[rbp-256]
	jb	SHORT $LN750@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r14
	jmp	SHORT $LN750@ZSTD_compr
$LN748@ZSTD_compr:

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	esi, edi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+r9]
	add	rsi, QWORD PTR base$1$[rbp-256]
	mov	r8, r10
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax
$LN750@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	SHORT $LN2753@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN752@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN752@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	mov	r10, QWORD PTR iend$1$[rsp]
	add	eax, 2
	mov	DWORD PTR [rcx], eax
	inc	r8d
	mov	DWORD PTR [rcx+4], edx
	xor	edx, edx
	lea	rax, QWORD PTR [rbx+r9]
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN2344@ZSTD_compr
	mov	r13, rbx

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN753@ZSTD_compr
$LN2753@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	xor	edx, edx
	mov	r9, QWORD PTR ip$1$[rsp]
$LN753@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN755@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16453[rbp-256]
	jbe	$LN2345@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN756@ZSTD_compr
$LN755@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16453[rbp-256]
	jbe	$LN2346@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rbp-256], r15
$LN756@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, r12d
	test	r12d, r12d
	jne	$LL728@ZSTD_compr
$LN2396@ZSTD_compr:
	dec	r14d
$LN2706@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN729@ZSTD_compr:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	jne	$LN2687@ZSTD_compr
	test	r14d, r14d
	je	$LN2687@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	mov	r8d, 6
	mov	rcx, r9
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	r12d, r12d
	mov	r9, QWORD PTR ip$1$[rsp]
	xor	r13d, r13d
	mov	rcx, QWORD PTR [rdx+48]
	mov	esi, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rcx
$LL730@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	cmp	esi, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2687@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rdi, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, esi
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, r12

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r8, QWORD PTR iend$1$[rsp]
	add	eax, eax
	cmp	r13, r12
	mov	r14d, esi
	cmovb	rbx, r13
	add	rdi, r14
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR [rbx+r9]
	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	lea	rdx, QWORD PTR [rdi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16774[rsp]
	lea	rcx, QWORD PTR [r14+rbx]
	cmp	rcx, rax
	jb	SHORT $LN2710@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16452[rsp]
	lea	rdi, QWORD PTR [r14+rax]
	add	rdi, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN760@ZSTD_compr
$LN2344@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r14d, edx
	cmovne	r14d, r12d
	jmp	$LN2706@ZSTD_compr
$LN2345@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$5[rbp-256]
	mov	r14d, r12d
	jmp	$LN729@ZSTD_compr
$LN2346@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$5[rbp-256]
	mov	r14d, r12d
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN2706@ZSTD_compr
$LN2710@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16452[rsp]
$LN760@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2777@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+rsi]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2472@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2472@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	lea	rax, QWORD PTR [rbx+r9]
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN2687@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN763@ZSTD_compr
$LN2777@ZSTD_compr:
	mov	r9, QWORD PTR ip$1$[rsp]
$LN763@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR dmsBtLow$1$[rsp]
	jbe	$LN2687@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [rdi+rbx], al
	jae	SHORT $LN765@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	esi, DWORD PTR [r15+4]
	mov	r13, rbx

; 728  :             } else {

	jmp	SHORT $LN766@ZSTD_compr
$LN765@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	esi, DWORD PTR [r15]
	mov	r12, rbx
$LN766@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	mov	rcx, QWORD PTR dmsBt$1$[rbp-256]
	test	r14d, r14d
	jne	$LL730@ZSTD_compr

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2687@ZSTD_compr
$LN127@ZSTD_compr:

; 521  :     const BYTE* const base = ms->window.base;

	mov	r14, QWORD PTR [r15+8]
	cmp	eax, ecx

; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r9d
	mov	QWORD PTR base$1$[rbp-256], r14
	cmovb	ecx, eax

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	mov	eax, DWORD PTR [r15+192]
	sub	esi, r14d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	edx, eax
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], esi
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	ecx, DWORD PTR [r15+188]
	mov	r13, QWORD PTR [r15+64]
	dec	ecx
	mov	r8d, DWORD PTR [r15+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv16629[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	rcx, QWORD PTR [r15+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	mov	r12d, DWORD PTR [r15+24]
	add	rcx, r12
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	eax, r12d
	mov	QWORD PTR tv16628[rbp-256], rax
	xor	ecx, ecx
	add	rax, r14
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, esi
	sub	eax, ebx
	cmp	ebx, esi
	cmovb	ecx, eax
	mov	DWORD PTR tv16451[rbp-256], ecx
	mov	rcx, r15
	call	ZSTD_getLowestMatchIndex
	mov	r15d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r15d, r15d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r14d, 1
	mov	edx, esi
	cmovne	eax, r15d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	shl	r14d, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	jne	$LN357@ZSTD_compr
	mov	r9, QWORD PTR [rax+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r8d, r15d
	mov	QWORD PTR dms$1$[rbp-256], r9
	mov	r11, QWORD PTR [r9]
	mov	rbx, QWORD PTR [r9+8]
	mov	esi, r11d
	mov	r10d, DWORD PTR [r9+28]
	sub	esi, ebx

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	eax, DWORD PTR [r9+192]
	sub	r8d, esi

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r9+188]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, 1
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	shl	r9d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, esi
	dec	r9d
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	eax, r10d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR tv16773[rsp], esi
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16450[rsp], r8d
	mov	DWORD PTR dmsBtMask$1$[rsp], r9d
	cmp	r9d, eax
	jae	SHORT $LN373@ZSTD_compr
	mov	ecx, esi
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	ecx, r9d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16450[rsp], r8d
	jmp	SHORT $LN374@ZSTD_compr
$LN357@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16773[rsp], r8d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r10d, r8d
	mov	QWORD PTR dms$1$[rbp-256], r8
	mov	DWORD PTR dmsBtMask$1$[rsp], r8d
	mov	QWORD PTR dmsBase$2$[rbp-256], r8
	mov	QWORD PTR dmsEnd$2$[rbp-256], r8
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d
	mov	DWORD PTR tv16450[rsp], r8d
$LN373@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], r10d
$LN374@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	mov	r13d, edx
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	mov	QWORD PTR tv16639[rbp-256], rax
	sub	r13d, r12d
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rsi, QWORD PTR [rcx+rax*4]
	npad	7
$LL308@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN375@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN376@ZSTD_compr
$LN375@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN376@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	r11d, r13d
	jae	$LN313@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, r15d
	setae	al
	test	ecx, eax
	je	SHORT $LN2782@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+4]
$LN2694@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11, QWORD PTR ip$1$[rsp]
$LN2782@ZSTD_compr:
	xor	r9d, r9d
$LN317@ZSTD_compr:
	mov	edx, r8d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN2750@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r8+r11]
	mov	r11, QWORD PTR iend$1$[rsp]
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	xor	r9d, r9d
	cmp	rax, r11
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN305@ZSTD_compr

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	$LN306@ZSTD_compr
$LN313@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	ecx, r9d
	jne	SHORT $LN377@ZSTD_compr
	mov	eax, DWORD PTR tv16450[rsp]
	mov	r10, QWORD PTR dmsBase$2$[rbp-256]
	sub	r10, rax

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	add	r10, rcx
	sub	eax, DWORD PTR tv16450[rsp]
	xor	edx, edx
	cmp	r11d, eax
	mov	ecx, r12d
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN2695@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN2695@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
$LN2801@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+4]
	jmp	$LN2694@ZSTD_compr
$LN377@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	add	r10, rcx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	$LN2694@ZSTD_compr
	mov	eax, edx
	mov	ecx, r12d
	sub	eax, r15d
	xor	edx, edx
	cmp	r11d, eax
	mov	r11, QWORD PTR ip$1$[rsp]
	setb	dl
	sub	ecx, r9d
	xor	r9d, r9d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r9d
	setae	al
	test	edx, eax
	je	SHORT $LN2695@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	SHORT $LN2695@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	jmp	SHORT $LN2801@ZSTD_compr
$LN2695@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR lastR$1$[rsp]
	jmp	$LN317@ZSTD_compr
$LN2750@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN306@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR current$1$[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r10d
	jb	$LL308@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv16629[rbp-256]
	mov	DWORD PTR [rax], edx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r14d, r14d
	je	$LN2399@ZSTD_compr
	mov	r13, QWORD PTR bestLength$1$[rbp-256]
	npad	2
$LL309@ZSTD_compr:
	dec	r14d
	mov	r12d, r14d
	cmp	edi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN2704@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	lea	r15, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	$LN329@ZSTD_compr
	mov	r14d, edi
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv16628[rbp-256]
	jae	$LN329@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	r8, r11
	mov	rsi, QWORD PTR dictBase$1$[rbp-256]
	mov	rcx, QWORD PTR ip$1$[rsp]
	add	rsi, r14
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv16628[rbp-256]
	jb	SHORT $LN2770@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r14
$LN2770@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r14, QWORD PTR ip$1$[rsp]
$LN331@ZSTD_compr:
	cmp	rbx, r13
	jbe	$LN2749@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN333@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN333@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r9d, r9d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi
	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	lea	rax, QWORD PTR [rbx+r14]
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	cmp	rax, r11
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	ecx, r9d
	mov	eax, r9d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN2350@ZSTD_compr
	mov	r13, rbx

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN334@ZSTD_compr
$LN329@ZSTD_compr:

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r14, QWORD PTR ip$1$[rsp]
	mov	r8, r11
	mov	esi, edi
	add	rsi, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r14]
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN331@ZSTD_compr
$LN2749@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r11, QWORD PTR iend$1$[rsp]
	xor	r9d, r9d
$LN334@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r14]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN336@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16451[rbp-256]
	jbe	$LN2351@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN337@ZSTD_compr
$LN336@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16451[rbp-256]
	jbe	$LN2352@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rbp-256], r15
$LN337@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, r12d
	test	r12d, r12d
	jne	$LL309@ZSTD_compr
$LN2399@ZSTD_compr:
	dec	r14d
$LN2704@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN310@ZSTD_compr:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r9d
	mov	DWORD PTR [rax], r9d
	jne	$LN2686@ZSTD_compr
	test	r14d, r14d
	je	$LN2686@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	mov	r8d, 4
	mov	rcx, QWORD PTR ip$1$[rsp]
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	r12d, r12d
	xor	r13d, r13d
	mov	rcx, QWORD PTR [rdx+48]
	mov	esi, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rcx
	npad	6
$LL311@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	cmp	esi, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2686@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rdi, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, esi
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, r12

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	r13, r12
	mov	r14d, esi
	cmovb	rbx, r13
	add	rdi, r14
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rdi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16773[rsp]
	lea	rcx, QWORD PTR [r14+rbx]
	cmp	rcx, rax
	jb	SHORT $LN2711@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16450[rsp]
	lea	rdi, QWORD PTR [r14+rax]
	add	rdi, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN341@ZSTD_compr
$LN2350@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r14d, r9d
	cmovne	r14d, r12d
	jmp	$LN2704@ZSTD_compr
$LN2351@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$7[rbp-256]
	mov	r14d, r12d
	jmp	$LN310@ZSTD_compr
$LN2352@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$7[rbp-256]
	mov	r14d, r12d
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN2704@ZSTD_compr
$LN2711@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16450[rsp]
$LN341@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2767@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rsi+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2474@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2474@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	xor	r8d, r8d
	lea	rax, QWORD PTR [rbx+rdx]
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2686@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN344@ZSTD_compr
$LN2767@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN344@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR dmsBtLow$1$[rsp]
	jbe	SHORT $LN2686@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rdi+rbx], al
	jae	SHORT $LN346@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	esi, DWORD PTR [r15+4]
	mov	r13, rbx

; 728  :             } else {

	jmp	SHORT $LN347@ZSTD_compr
$LN346@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	esi, DWORD PTR [r15]
	mov	r12, rbx
$LN347@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	mov	rcx, QWORD PTR dmsBt$1$[rbp-256]
	test	r14d, r14d
	jne	$LL311@ZSTD_compr
$LN2686@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN305@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
	jmp	$LN135@ZSTD_compr
$LN128@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r15+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r9d
	mov	r14, QWORD PTR [r15+8]
	cmp	eax, ecx

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	mov	QWORD PTR base$1$[rbp-256], r14
	cmovb	ecx, eax
	mov	eax, DWORD PTR [r15+192]
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	esi, r14d
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], esi
	mov	edx, eax
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	ecx, DWORD PTR [r15+188]
	mov	r13, QWORD PTR [r15+64]
	dec	ecx
	mov	r8d, DWORD PTR [r15+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv16617[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	rcx, QWORD PTR [r15+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	mov	r12d, DWORD PTR [r15+24]
	add	rcx, r12
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	eax, r12d
	mov	QWORD PTR tv16616[rbp-256], rax
	xor	ecx, ecx
	add	rax, r14
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, esi
	sub	eax, ebx
	cmp	ebx, esi
	cmovb	ecx, eax
	mov	DWORD PTR tv16449[rbp-256], ecx
	mov	rcx, r15
	call	ZSTD_getLowestMatchIndex
	mov	r15d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r15d, r15d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r14d, 1
	mov	edx, esi
	cmovne	eax, r15d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rsp], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	shl	r14d, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	jne	$LN527@ZSTD_compr
	mov	r9, QWORD PTR [rax+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r8d, r15d
	mov	QWORD PTR dms$1$[rbp-256], r9
	mov	r11, QWORD PTR [r9]
	mov	rbx, QWORD PTR [r9+8]
	mov	esi, r11d
	mov	r10d, DWORD PTR [r9+28]
	sub	esi, ebx

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	eax, DWORD PTR [r9+192]
	sub	r8d, esi

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r9+188]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, 1
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	shl	r9d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, esi
	dec	r9d
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	eax, r10d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR tv16741[rsp], esi
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16448[rsp], r8d
	mov	DWORD PTR dmsBtMask$1$[rsp], r9d
	cmp	r9d, eax
	jae	SHORT $LN543@ZSTD_compr
	mov	ecx, esi
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	ecx, r9d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16448[rsp], r8d
	jmp	SHORT $LN544@ZSTD_compr
$LN527@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16741[rsp], r8d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r10d, r8d
	mov	QWORD PTR dms$1$[rbp-256], r8
	mov	DWORD PTR dmsBtMask$1$[rsp], r8d
	mov	QWORD PTR dmsBase$2$[rbp-256], r8
	mov	QWORD PTR dmsEnd$2$[rbp-256], r8
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d
	mov	DWORD PTR tv16448[rsp], r8d
$LN543@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], r10d
$LN544@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	mov	r13d, edx
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	mov	QWORD PTR tv16639[rbp-256], rax
	sub	r13d, r12d
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	lea	r8d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r8d
	lea	rsi, QWORD PTR [rcx+rax*4]
$LL478@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN545@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN546@ZSTD_compr
$LN545@ZSTD_compr:
	mov	ecx, DWORD PTR [rsi]
$LN546@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r9d, r9d
	cmp	r11d, r13d
	jae	$LN483@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [r11]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r10d, r15d
	setae	al
	test	ecx, eax
	je	SHORT $LN2713@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r11+4]
	add	rdx, 4
	add	rdx, r11
	call	ZSTD_count
	lea	r9d, DWORD PTR [rax+4]
$LN2703@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r8d, DWORD PTR lastR$1$[rsp]
$LN2713@ZSTD_compr:
	mov	r10, QWORD PTR dictBase$1$[rbp-256]
$LN487@ZSTD_compr:
	mov	edx, r9d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN2752@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r11d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r11*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r11d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	mov	rax, QWORD PTR ip$1$[rsp]
	add	rax, rdx
	mov	DWORD PTR [rcx+4], r9d
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], r11d
	mov	r11, QWORD PTR iend$1$[rsp]
	cmp	rax, r11
	mov	eax, edx
	sete	cl
	cmp	r9d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN475@ZSTD_compr

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	$LN476@ZSTD_compr
$LN483@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	eax, DWORD PTR dictMode$[rbp-256]
	mov	r8d, r10d
	cmp	eax, 2
	jne	SHORT $LN547@ZSTD_compr
	mov	ecx, DWORD PTR tv16448[rsp]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, edx
	sub	eax, ecx
	sub	r8, rcx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	add	r8, QWORD PTR dmsBase$2$[rbp-256]
	mov	ecx, r12d
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN2703@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8]
	jne	$LN2703@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	lea	rdx, QWORD PTR [r8+4]
$LN2802@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [r11+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r9d, DWORD PTR [rax+4]
	jmp	$LN2703@ZSTD_compr
$LN547@ZSTD_compr:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, 1
	jne	$LN2703@ZSTD_compr
	mov	eax, edx
	mov	ecx, r12d
	sub	eax, r15d
	xor	edx, edx
	cmp	r11d, eax
	setb	dl
	sub	ecx, r10d
	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN2700@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	eax, DWORD PTR [r11]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8+r10]
	jne	SHORT $LN2700@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+4]
	add	rdx, r8
	jmp	SHORT $LN2802@ZSTD_compr
$LN2700@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r8d, DWORD PTR lastR$1$[rsp]
	jmp	$LN487@ZSTD_compr
$LN2752@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN476@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR current$1$[rsp]
	inc	ebx
	mov	rcx, QWORD PTR rep$[rbp-256]
	add	rsi, 4
	cmp	ebx, r8d
	jb	$LL478@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv16617[rbp-256]
	mov	DWORD PTR [rax], edx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r14d, r14d
	je	$LN2402@ZSTD_compr
	mov	r13, QWORD PTR bestLength$1$[rbp-256]
	npad	6
$LL479@ZSTD_compr:
	dec	r14d
	mov	r12d, r14d
	cmp	edi, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN2705@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	lea	r15, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	$LN499@ZSTD_compr
	mov	r14d, edi
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv16616[rbp-256]
	jae	$LN499@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rsi, QWORD PTR [r14+r10]
	mov	rcx, QWORD PTR ip$1$[rsp]
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rcx, rbx
	mov	r8, r11
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv16616[rbp-256]
	jb	SHORT $LN2771@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r14
$LN2771@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r14, QWORD PTR ip$1$[rsp]
$LN501@ZSTD_compr:
	cmp	rbx, r13
	jbe	$LN2751@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN503@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN503@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r11, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	lea	rax, QWORD PTR [rbx+r14]
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	cmp	rax, r11
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2356@ZSTD_compr
	mov	r13, rbx

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN504@ZSTD_compr
$LN499@ZSTD_compr:

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r14, QWORD PTR ip$1$[rsp]
	mov	r8, r11
	mov	esi, edi
	add	rsi, QWORD PTR base$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r14]
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	jmp	$LN501@ZSTD_compr
$LN2751@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r11, QWORD PTR iend$1$[rsp]
$LN504@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r14]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN506@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rsp]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16449[rbp-256]
	jbe	SHORT $LN2357@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rsp], rax

; 685  :         } else {

	jmp	SHORT $LN507@ZSTD_compr
$LN506@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16449[rbp-256]
	jbe	SHORT $LN2358@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rbp-256], r15
$LN507@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, r12d
	test	r12d, r12d
	je	SHORT $LN2402@ZSTD_compr
	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	jmp	$LL479@ZSTD_compr
$LN2356@ZSTD_compr:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r14d, edx
	cmovne	r14d, r12d
	jmp	SHORT $LN2705@ZSTD_compr
$LN2357@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$6[rbp-256]
	mov	r14d, r12d
	jmp	SHORT $LN480@ZSTD_compr
$LN2358@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$6[rbp-256]
	mov	r14d, r12d
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	SHORT $LN2705@ZSTD_compr
$LN2402@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r14d
$LN2705@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rsp]
$LN480@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	xor	ebx, ebx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	DWORD PTR [rcx], ebx
	mov	DWORD PTR [rax], ebx
	jne	$LN2687@ZSTD_compr
	test	r14d, r14d
	je	$LN2687@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	lea	r8d, QWORD PTR [rbx+5]
	mov	rcx, QWORD PTR ip$1$[rsp]
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	mov	r12d, ebx
	mov	r13d, ebx
	mov	rcx, QWORD PTR [rdx+48]
	mov	esi, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rcx
	npad	2
$LL481@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	cmp	esi, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2687@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rdi, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, esi
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, r12

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	r13, r12
	mov	r14d, esi
	cmovb	rbx, r13
	add	rdi, r14
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rdi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16741[rsp]
	lea	rcx, QWORD PTR [r14+rbx]
	cmp	rcx, rax
	jb	SHORT $LN2712@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16448[rsp]
	lea	rdi, QWORD PTR [r14+rax]
	add	rdi, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN511@ZSTD_compr
$LN2712@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16448[rsp]
$LN511@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2768@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+rsi]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2476@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2476@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	xor	r8d, r8d
	lea	rax, QWORD PTR [rbx+rdx]
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2687@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN514@ZSTD_compr
$LN2768@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN514@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR dmsBtLow$1$[rsp]
	jbe	SHORT $LN2687@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rdi+rbx], al
	jae	SHORT $LN516@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	esi, DWORD PTR [r15+4]
	mov	r13, rbx

; 728  :             } else {

	jmp	SHORT $LN517@ZSTD_compr
$LN516@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	esi, DWORD PTR [r15]
	mov	r12, rbx
$LN517@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	mov	rcx, QWORD PTR dmsBt$1$[rbp-256]
	test	r14d, r14d
	jne	$LL481@ZSTD_compr
$LN2687@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN475@ZSTD_compr:
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
	jmp	$LN135@ZSTD_compr
$LN126@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r15+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r9d
	mov	r14, QWORD PTR [r15+8]
	cmp	eax, ecx

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	mov	QWORD PTR base$1$[rbp-256], r14
	cmovb	ecx, eax
	mov	eax, DWORD PTR [r15+192]
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	sub	esi, r14d
	mov	rcx, r9
	mov	DWORD PTR current$1$[rsp], esi
	mov	edx, eax
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [rbx+rax*4]

; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	ecx, DWORD PTR [r15+188]
	mov	r13, QWORD PTR [r15+64]
	dec	ecx
	mov	r8d, DWORD PTR [r15+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR tv16605[rbp-256], rax
	mov	ebx, 1
	shl	ebx, cl
	mov	rcx, QWORD PTR [r15+16]
	dec	ebx
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r12
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r12
	mov	r12d, DWORD PTR [r15+24]
	add	rcx, r12
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	eax, r12d
	mov	QWORD PTR tv16604[rbp-256], rax
	xor	ecx, ecx
	add	rax, r14
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	eax, esi
	sub	eax, ebx
	cmp	ebx, esi
	cmovb	ecx, eax
	mov	DWORD PTR tv16447[rsp], ecx
	mov	rcx, r15
	call	ZSTD_getLowestMatchIndex
	mov	r15d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r15d, r15d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r14d, 1
	cmovne	eax, r15d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	xor	edx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], edx
	lea	rax, QWORD PTR [rcx*4]
	add	rax, r13
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	shl	r14d, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	jne	SHORT $LN187@ZSTD_compr
	mov	rdx, QWORD PTR [rax+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r10d, r15d
	mov	QWORD PTR dms$1$[rbp-256], rdx
	mov	r9, QWORD PTR [rdx]
	mov	r11, QWORD PTR [rdx+8]
	mov	ebx, r9d
	mov	r8d, DWORD PTR [rdx+28]
	sub	ebx, r11d

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	eax, DWORD PTR [rdx+192]
	sub	r10d, ebx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [rdx+188]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	edx, 1
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	shl	edx, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, ebx
	dec	edx
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	sub	eax, r8d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r9
	mov	DWORD PTR tv16743[rsp], ebx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d
	mov	DWORD PTR tv16446[rsp], r10d
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	cmp	edx, eax
	jae	SHORT $LN203@ZSTD_compr
	mov	ecx, ebx
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	sub	ecx, edx
	mov	QWORD PTR dmsEnd$2$[rbp-256], r9
	mov	DWORD PTR dmsBtLow$1$[rbp-256], ecx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d
	mov	DWORD PTR tv16446[rsp], r10d
	jmp	SHORT $LN204@ZSTD_compr
$LN187@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16743[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r8d, edx
	mov	QWORD PTR dms$1$[rbp-256], rdx
	mov	r10d, edx
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	mov	QWORD PTR dmsBase$2$[rbp-256], rdx
	mov	QWORD PTR dmsEnd$2$[rbp-256], rdx
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	DWORD PTR tv16446[rsp], edx
$LN203@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rbp-256], r8d
$LN204@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	mov	edx, esi
	mov	rcx, QWORD PTR rep$[rbp-256]
	dec	eax
	mov	QWORD PTR tv16639[rbp-256], rax
	mov	r13d, eax
	mov	QWORD PTR bestLength$1$[rbp-256], rax
	sub	edx, r12d

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv16602[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r11d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r11d
	lea	rsi, QWORD PTR [rcx+rax*4]
$LL138@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN205@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN206@ZSTD_compr
$LN205@ZSTD_compr:
	mov	eax, DWORD PTR [rsi]
$LN206@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r8d, r8d
	cmp	ecx, edx
	jae	SHORT $LN143@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rcx, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r10d, eax
	neg	r10

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rcx]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10+rcx]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	ecx, ecx

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	eax, eax
	cmp	r9d, r15d
	setae	al
	test	ecx, eax
	je	$LN2776@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r10
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	lea	r8d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN2803@ZSTD_compr
$LN143@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	edx, r9d
	jne	SHORT $LN207@ZSTD_compr
	mov	eax, r10d
	mov	r10, QWORD PTR dmsBase$2$[rbp-256]
	sub	r10, rax

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	add	r10, rdx
	sub	eax, DWORD PTR tv16446[rsp]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, r12d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN2776@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r9, QWORD PTR ip$1$[rsp]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8
	mov	ecx, DWORD PTR [r9]
	shl	ecx, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN147@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	lea	rcx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	jmp	SHORT $LN2804@ZSTD_compr
$LN207@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	add	r10, rdx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	SHORT $LN2776@ZSTD_compr
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, r15d
	cmp	ecx, eax
	mov	ecx, r12d
	setb	dl
	sub	ecx, r9d
	mov	r9, QWORD PTR ip$1$[rsp]
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN147@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [r9]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r10]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN147@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	rcx, QWORD PTR [r9+3]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
$LN2804@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r10+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r8d, DWORD PTR [rax+3]
$LN2803@ZSTD_compr:
	mov	r11d, DWORD PTR lastR$1$[rsp]
$LN2776@ZSTD_compr:
	mov	r9, QWORD PTR ip$1$[rsp]
$LN147@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	edx, r8d
	cmp	rdx, r13
	jbe	SHORT $LN136@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	r13d, edx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r9*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r9d
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rcx+4], r8d

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	xor	ecx, ecx
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	r9, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	lea	rax, QWORD PTR [r8+r9]
	cmp	rax, r10
	sete	cl
	xor	eax, eax
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN305@ZSTD_compr
$LN136@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	ebx
	add	rsi, 4
	cmp	ebx, r11d
	jae	SHORT $LN2647@ZSTD_compr
	mov	edx, DWORD PTR tv16602[rbp-256]
	mov	r10d, DWORD PTR tv16446[rsp]
	mov	rcx, QWORD PTR rep$[rbp-256]
	jmp	$LL138@ZSTD_compr
$LN2647@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN2707@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	r15, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$[rbp-256]
	mov	rcx, r15
	mov	r8, r9
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	r11d, r11d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r11d
	mov	ecx, r11d
	mov	ebx, esi
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN2718@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN154@ZSTD_compr
	cmp	eax, r12d
	jae	SHORT $LN154@ZSTD_compr

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	rdx, QWORD PTR dictBase$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	jmp	SHORT $LN2787@ZSTD_compr
$LN154@ZSTD_compr:

; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rbp-256]
	call	ZSTD_count
$LN2787@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR ip$1$[rsp]
	xor	r11d, r11d
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r8, rax
	cmp	rax, 3
	jb	SHORT $LN2715@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r13, rax
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	edx, r11d
	lea	eax, DWORD PTR [rbx+2]
	mov	ebx, 1
	mov	DWORD PTR nbMatches$1$[rbp-256], ebx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [r13+r9]
	cmp	rax, r10
	mov	DWORD PTR [rcx+4], r8d
	mov	eax, DWORD PTR sufficient_len$1$[rbp-256]
	mov	ecx, r11d
	sete	dl
	cmp	r13, rax
	seta	cl
	or	edx, ecx
	je	SHORT $LN2716@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [rsi+1]
	mov	DWORD PTR [r15+36], eax

; 635  :                     return 1;

	jmp	$LN135@ZSTD_compr
$LN2707@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	r11d, r11d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN2788@ZSTD_compr
$LN2715@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN2788@ZSTD_compr
$LN2716@ZSTD_compr:

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN156@ZSTD_compr
$LN2718@ZSTD_compr:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r9, QWORD PTR ip$1$[rsp]
$LN2788@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
$LN156@ZSTD_compr:
	mov	rax, QWORD PTR tv16605[rbp-256]
	mov	DWORD PTR [rax], esi

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r14d, r14d
	je	$LN2405@ZSTD_compr
	npad	7
$LL139@ZSTD_compr:
	dec	r14d
	mov	r12d, r14d
	cmp	edi, r8d
	jb	$LN2708@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	lea	r15, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN159@ZSTD_compr
	mov	r14d, edi
	lea	rax, QWORD PTR [rbx+r14]
	cmp	rax, QWORD PTR tv16604[rbp-256]
	jae	SHORT $LN159@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+r9]
	mov	rsi, QWORD PTR dictBase$1$[rbp-256]
	mov	r8, r10
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	rsi, r14
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rbx+r14]
	cmp	rax, QWORD PTR tv16604[rbp-256]
	jb	SHORT $LN161@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	rsi, QWORD PTR base$1$[rbp-256]
	add	rsi, r14
	jmp	SHORT $LN161@ZSTD_compr
$LN159@ZSTD_compr:

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	esi, edi

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+r9]
	add	rsi, QWORD PTR base$1$[rbp-256]
	mov	r8, r10
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax
$LN161@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r13
	jbe	$LN2755@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN163@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN163@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r9d, DWORD PTR nbMatches$1$[rbp-256]

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	r13, rbx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r9*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r9d
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
	mov	r9, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	lea	rax, QWORD PTR [rbx+r9]
	cmp	rax, r10
	mov	eax, r11d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN164@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r14d, r11d
	cmovne	r14d, r12d
$LN2708@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN2789@ZSTD_compr:
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
$LN140@ZSTD_compr:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rsp]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d
	jne	$LN2365@ZSTD_compr
	test	r14d, r14d
	je	$LN2365@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	mov	r8d, 3
	mov	rcx, r9
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	r12d, r12d
	xor	r13d, r13d
	mov	rcx, QWORD PTR [rdx+48]
	mov	esi, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rcx
	npad	8
$LL141@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	cmp	esi, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2688@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	rdi, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, esi
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, r12

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	r13, r12
	mov	r14d, esi
	cmovb	rbx, r13
	add	rdi, r14
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rdi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16743[rsp]
	lea	rcx, QWORD PTR [rbx+r14]
	cmp	rcx, rax
	jb	$LN2714@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16446[rsp]
	lea	rdi, QWORD PTR [r14+rax]
	add	rdi, QWORD PTR base$1$[rbp-256]
	jmp	$LN171@ZSTD_compr
$LN2755@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
	mov	r9, QWORD PTR ip$1$[rsp]
$LN164@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r9]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN166@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16447[rsp]
	jbe	SHORT $LN2363@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	rax, QWORD PTR [r15+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN167@ZSTD_compr
$LN166@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv16447[rsp]
	jbe	SHORT $LN2364@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN167@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, r12d
	test	r12d, r12d
	je	SHORT $LN2717@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL139@ZSTD_compr
$LN2363@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$8[rbp-256]
	mov	r14d, r12d
	jmp	$LN2789@ZSTD_compr
$LN2364@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$8[rbp-256]
	mov	r14d, r12d
	mov	QWORD PTR largerPtr$1$[rsp], rax
	jmp	$LN2708@ZSTD_compr
$LN2717@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
$LN2405@ZSTD_compr:
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
	dec	r14d
	jmp	$LN140@ZSTD_compr
$LN2714@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16446[rsp]
$LN171@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2769@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rsi+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2478@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2478@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	rdx, QWORD PTR ip$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax
	inc	r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	xor	r8d, r8d
	lea	rax, QWORD PTR [rbx+rdx]
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2688@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN174@ZSTD_compr
$LN2769@ZSTD_compr:
	mov	rdx, QWORD PTR ip$1$[rsp]
$LN174@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR dmsBtLow$1$[rbp-256]
	jbe	SHORT $LN2688@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	BYTE PTR [rdi+rbx], al
	jae	SHORT $LN176@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	esi, DWORD PTR [r15+4]
	mov	r13, rbx

; 728  :             } else {

	jmp	SHORT $LN177@ZSTD_compr
$LN176@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	esi, DWORD PTR [r15]
	mov	r12, rbx
$LN177@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	mov	rcx, QWORD PTR dmsBt$1$[rbp-256]
	test	r14d, r14d
	jne	$LL141@ZSTD_compr
$LN2688@ZSTD_compr:
	mov	ebx, DWORD PTR nbMatches$1$[rbp-256]
$LN2365@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [rcx+36], eax
$LN135@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	test	ebx, ebx
	je	$LN2772@ZSTD_compr

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	r13, QWORD PTR opt$1$[rbp-256]
	mov	r15, QWORD PTR rep$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */
; 841  :             opt[0].litlen = litlen;

	mov	edi, DWORD PTR litlen$1$[rbp-256]

; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	mov	ecx, edi
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	mov	esi, DWORD PTR optLevel$[rbp-256]
	mov	rdx, r14
	mov	eax, DWORD PTR [r15]
	mov	r8d, esi
	mov	DWORD PTR [r13+16], eax
	mov	eax, DWORD PTR [r15+4]
	mov	DWORD PTR [r13+20], eax
	mov	eax, DWORD PTR [r15+8]
	mov	DWORD PTR [r13+24], eax
	mov	DWORD PTR [r13+8], 0
	mov	DWORD PTR [r13+12], edi
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r12, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [r13], eax
	lea	eax, DWORD PTR [rbx-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r12+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	SHORT $LN33@ZSTD_compr

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;
; 858  :                     lastSequence.off = maxOffset;
; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	ebx, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$[rbp-248], eax
	mov	eax, DWORD PTR [r12+rcx*8]
	mov	DWORD PTR lastSequence$[rbp-252], eax
	mov	DWORD PTR lastSequence$[rbp-244], edi
	movups	xmm2, XMMWORD PTR lastSequence$[rbp-256]
$LN2790@ZSTD_compr:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	xor	r14d, r14d
	mov	esi, r14d
$_shortestPath$2810:
	mov	eax, esi
	lea	rdx, QWORD PTR [r13+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$[rbp-248], 0
	je	$LN49@ZSTD_compr

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T14[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r14d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r15], xmm0
	mov	DWORD PTR [r15+8], ecx

; 1014 :         } else {

	jmp	$LN50@ZSTD_compr
$LN33@ZSTD_compr:

; 864  :             }   }
; 865  : 
; 866  :             /* set prices for first matches starting position == 0 */
; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, esi
	mov	rdx, r14
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	rdx, QWORD PTR tv16639[rbp-256]
	mov	r15d, DWORD PTR [r13]
	mov	rcx, rdx
	add	r15d, eax
	lea	rax, QWORD PTR [r13+28]
	lea	esi, DWORD PTR [rdx+1]
	npad	9
$LL9@ZSTD_compr:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rax], 1073741824		; 40000000H
	lea	rax, QWORD PTR [rax+28]
	sub	rcx, 1
	jne	SHORT $LL9@ZSTD_compr

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	ebx, ebx
	je	$LN11@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r12
	mov	ecx, ebx
	mov	QWORD PTR tv16464[rbp-256], rax
	mov	QWORD PTR tv16764[rbp-256], rcx
	npad	11
$LL12@ZSTD_compr:

; 874  :                     U32 const offset = matches[matchNb].off;
; 875  :                     U32 const end = matches[matchNb].len;

	mov	r12d, DWORD PTR [rax+4]
	mov	r13d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	esi, r12d
	ja	$LN10@ZSTD_compr
	lea	eax, DWORD PTR [r13+1]
	npad	12
$LL15@ZSTD_compr:

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	ebx, r8d
	mov	DWORD PTR r$18[rbp-256], r8d
	cmovne	ebx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rdx+80], 1
	jne	SHORT $LN1038@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	cmp	DWORD PTR optLevel$[rbp-256], r8d
	je	SHORT $LN1041@ZSTD_compr
	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_fracWeight
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	add	ebx, 16
	shl	ebx, 8
	add	ebx, eax
	add	ebx, r15d
	jmp	$LN1037@ZSTD_compr
$LN1041@ZSTD_compr:
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	lea	eax, DWORD PTR [rsi-2]
	bsr	ecx, eax
	mov	eax, r8d
	mov	DWORD PTR r$17[rbp-256], r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	ebx, 16
	shl	ebx, 8

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	eax, 8

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	ebx, eax
	add	ebx, r15d
	jmp	$LN1037@ZSTD_compr
$LN1038@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rdx+24]
	mov	eax, DWORD PTR [rax+rbx*4]
	cmp	DWORD PTR optLevel$[rbp-256], r8d
	je	SHORT $LN1043@ZSTD_compr
	mov	ecx, eax
	call	ZSTD_fracWeight
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	ecx, ebx
	shl	ecx, 8
	add	ecx, DWORD PTR [rdx+76]
	sub	ecx, eax

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	DWORD PTR optLevel$[rbp-256], 2
	mov	edi, ecx
	jge	SHORT $LN1039@ZSTD_compr
	jmp	SHORT $LN2635@ZSTD_compr
$LN1043@ZSTD_compr:

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$15[rbp-256], r8d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	ecx, ebx
	sub	ecx, eax
	shl	ecx, 8
	add	ecx, DWORD PTR [rdx+76]
	mov	edi, ecx
$LN2635@ZSTD_compr:

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	ebx, 20
	jb	SHORT $LN1039@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	ebx, 9
	lea	edi, DWORD PTR [rcx-9728]
	add	edi, ebx
$LN1039@ZSTD_compr:

; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	cmp	DWORD PTR optLevel$[rbp-256], 0
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	mov	eax, eax
	lea	rbx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r14+16]
	mov	eax, DWORD PTR [rbx+rax]
	je	SHORT $LN1045@ZSTD_compr
	mov	ecx, eax
	call	ZSTD_fracWeight
	mov	edx, eax
	jmp	SHORT $LN1046@ZSTD_compr
$LN1045@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edx, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$16[rbp-256], edx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	edx, 8
$LN1046@ZSTD_compr:

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rax, OFFSET FLAT:ML_bits
	mov	ebx, DWORD PTR [rbx+rax]
	shl	ebx, 8
	add	ebx, DWORD PTR [r14+72]
	sub	ebx, edx

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */
; 281  : 
; 282  :     DEBUGLOG(8, "ZSTD_getMatchPrice(ml:%u) = %u", matchLength, price);
; 283  :     return price;

	add	ebx, 51					; 00000033H
	add	ebx, r15d
	add	ebx, edi
	mov	edi, DWORD PTR litlen$1$[rbp-256]
$LN1037@ZSTD_compr:

; 877  :                         U32 const matchPrice = ZSTD_getMatchPrice(offset, pos, optStatePtr, optLevel);
; 878  :                         U32 const sequencePrice = literalsPrice + matchPrice;
; 879  :                         DEBUGLOG(7, "rPos:%u => set initial price : %.2f",
; 880  :                                     pos, ZSTD_fCost(sequencePrice));
; 881  :                         opt[pos].mlen = pos;

	mov	eax, esi
	imul	rcx, rax, 28
	mov	rax, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR [rcx+rax+8], esi
	inc	esi

; 882  :                         opt[pos].off = offset;

	mov	DWORD PTR [rcx+rax+4], r13d

; 883  :                         opt[pos].litlen = litlen;

	mov	DWORD PTR [rcx+rax+12], edi

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+rax], ebx
	lea	eax, DWORD PTR [r13+1]
	cmp	esi, r12d
	jbe	$LL15@ZSTD_compr
	mov	rax, QWORD PTR tv16464[rbp-256]
	mov	rcx, QWORD PTR tv16764[rbp-256]
$LN10@ZSTD_compr:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	rcx, 1
	mov	QWORD PTR tv16464[rbp-256], rax
	mov	QWORD PTR tv16764[rbp-256], rcx
	jne	$LL12@ZSTD_compr
	mov	r13, QWORD PTR opt$1$[rbp-256]
$LN11@ZSTD_compr:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;

	dec	esi

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	ebx, 1
	mov	DWORD PTR seqPos$1$[rsp], esi
	mov	DWORD PTR cur$1$[rsp], ebx
	cmp	esi, ebx
	jb	$LN2654@ZSTD_compr
$LL18@ZSTD_compr:

; 892  :             const BYTE* const inr = ip + cur;

	mov	edi, ebx

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r12d, DWORD PTR [rbx-1]
	add	rdi, QWORD PTR ip$1$[rsp]
	imul	rbx, r12, 28
	mov	QWORD PTR inr$1$[rbp-256], rdi
	cmp	DWORD PTR [rbx+r13+8], 0
	jne	SHORT $LN55@ZSTD_compr
	mov	r15d, DWORD PTR [rbx+r13+12]
	inc	r15d
	jmp	SHORT $LN56@ZSTD_compr
$LN55@ZSTD_compr:
	mov	r15d, 1
$LN56@ZSTD_compr:

; 898  :                 int const price = opt[cur-1].price

	mov	r8d, DWORD PTR optLevel$[rbp-256]
	lea	ecx, DWORD PTR [r15-1]
	mov	rdx, r14
	call	ZSTD_litLengthPrice
	mov	ebx, DWORD PTR [rbx+r13]
	lea	rcx, QWORD PTR [rdi-1]
	mov	r9d, DWORD PTR optLevel$[rbp-256]
	mov	r8, r14
	mov	edx, 1
	sub	ebx, eax
	call	ZSTD_rawLiteralsCost
	mov	r8d, DWORD PTR optLevel$[rbp-256]
	mov	rdx, r14
	mov	ecx, r15d
	add	ebx, eax
	call	ZSTD_litLengthPrice
	add	eax, ebx

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	xor	edx, edx
	mov	ebx, DWORD PTR cur$1$[rsp]
	imul	r14, rbx, 28
	add	r14, r13
	cmp	eax, DWORD PTR [r14]
	jg	SHORT $LN2626@ZSTD_compr

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [r14+4], rdx

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [r14+12], r15d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [r14], eax
$LN2626@ZSTD_compr:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [r14+8]
	test	ecx, ecx
	je	SHORT $LN36@ZSTD_compr

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [r14+12], 0
	mov	r9d, edx
	mov	r8d, DWORD PTR [r14+4]
	mov	eax, ebx
	sete	r9b
	sub	eax, ecx
	imul	rdx, rax, 28
	lea	rcx, QWORD PTR $T13[rbp-256]
	add	rdx, 16
	add	rdx, r13
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], ecx

; 929  :             } else {

	jmp	SHORT $LN37@ZSTD_compr
$LN36@ZSTD_compr:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r12, 28
	movsd	xmm0, QWORD PTR [rax+r13+16]
	mov	eax, DWORD PTR [rax+r13+24]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], eax
$LN37@ZSTD_compr:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rdi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN16@ZSTD_compr

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	ebx, esi
	je	$LN2654@ZSTD_compr

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {

	mov	edx, DWORD PTR optLevel$[rbp-256]
	test	edx, edx
	jne	SHORT $LN2627@ZSTD_compr
	mov	eax, DWORD PTR [r14]
	lea	ecx, DWORD PTR [rbx+1]
	imul	rdx, rcx, 28
	sub	eax, -128				; ffffffffffffff80H
	cmp	DWORD PTR [rdx+r13], eax
	jle	$LN16@ZSTD_compr
	mov	edx, DWORD PTR optLevel$[rbp-256]
$LN2627@ZSTD_compr:

; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [r14+8]
	xor	ecx, ecx
	test	eax, eax
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN57@ZSTD_compr
	mov	eax, DWORD PTR [r14+12]
	mov	DWORD PTR litlen$1$[rbp-256], eax
	jmp	SHORT $LN58@ZSTD_compr
$LN57@ZSTD_compr:
	mov	DWORD PTR litlen$1$[rbp-256], 0
$LN58@ZSTD_compr:

; 946  :                 U32 const previousPrice = opt[cur].price;

	mov	ebx, DWORD PTR [r14]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, edx
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	add	eax, ebx

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	r14, 16
	mov	DWORD PTR tv16587[rbp-256], eax

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	rax, QWORD PTR ms$[rbp-256]

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	mov	QWORD PTR rep$1$[rbp-256], r14

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [rax+36]
	mov	r12, QWORD PTR [rax+8]
	mov	r15d, DWORD PTR [rax+200]
	lea	rax, QWORD PTR [r12+rbx]
	cmp	rdi, rax
	jb	$LN2766@ZSTD_compr

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, edi
	sub	r14d, r12d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, r14d
	jae	SHORT $LN1207@ZSTD_compr
	mov	rdi, QWORD PTR iend$1$[rsp]
	xor	r13d, r13d

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	cmp	DWORD PTR dictMode$[rbp-256], 1
	mov	rsi, QWORD PTR ms$[rbp-256]
	sete	r13b
	npad	10
$LL1206@ZSTD_compr:
	mov	edx, ebx
	mov	r9d, r15d
	add	rdx, r12
	mov	DWORD PTR [rsp+32], r13d
	mov	r8, rdi
	mov	rcx, rsi
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, r14d
	jb	SHORT $LL1206@ZSTD_compr
	mov	esi, DWORD PTR seqPos$1$[rsp]
	mov	rdi, QWORD PTR inr$1$[rbp-256]
$LN1207@ZSTD_compr:

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	r12, QWORD PTR ms$[rbp-256]

; 756  :     switch(matchLengthSearch)

	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], r14d

; 756  :     switch(matchLengthSearch)

	cmp	r15d, 3
	je	$LN1200@ZSTD_compr
	cmp	r15d, 5
	je	$LN1202@ZSTD_compr
	lea	eax, DWORD PTR [r15-6]
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN1201@ZSTD_compr

; 521  :     const BYTE* const base = ms->window.base;

	mov	r12, QWORD PTR [r12+8]
	cmp	eax, ecx

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	mov	QWORD PTR base$1$[rbp-256], r12
	cmovb	ecx, eax
	mov	eax, edi
	sub	eax, r12d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	DWORD PTR current$1$[rsp], eax
	mov	rcx, rdi
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	r13d, DWORD PTR [rax+192]
	mov	edx, r13d
	mov	rbx, QWORD PTR [rax+48]
	mov	DWORD PTR dmsHashLog$1$[rbp-256], r13d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r15d, DWORD PTR [rbx+rax*4]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r10d, 1
	mov	r13, QWORD PTR ms$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
	mov	r8d, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	lea	rax, QWORD PTR [rbx+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ebx, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 527  :     U32 matchIndex  = hashTable[h];

	mov	QWORD PTR tv16585[rbp-256], rax

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	eax, eax

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r14d, DWORD PTR [r13+24]
	mov	r9, QWORD PTR [r13+16]
	mov	ecx, DWORD PTR [r13+188]
	mov	r11, QWORD PTR [r13+64]
	dec	ecx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rax
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rax

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	eax, r14d
	mov	QWORD PTR tv16584[rbp-256], rax

; 535  :     const BYTE* const prefixStart = base + dictLimit;

	add	rax, r12
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	shl	r10d, cl

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	lea	rcx, QWORD PTR [r14+r9]
	dec	r10d
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	sub	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	QWORD PTR dictBase$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	xor	r9d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 528  :     U32* const bt   = ms->chainTable;

	mov	QWORD PTR bt$1$[rbp-256], r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmp	r10d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	DWORD PTR btMask$1$[rbp-256], r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r9d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	DWORD PTR dictLimit$1$[rbp-256], r14d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	cmovb	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 543  :     U32 mnum = 0;

	mov	DWORD PTR nbMatches$1$[rbp-256], r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	DWORD PTR tv16445[rbp-256], ecx

; 979  :     U32    const lowestValid = ms->window.lowLimit;
; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	mov	ecx, DWORD PTR [r13+184]
	shl	edx, cl
	mov	ecx, DWORD PTR [r13+28]

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	ebx, edx
	sub	eax, ecx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	mov	eax, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ebx, ecx
	cmp	DWORD PTR [r13+32], r9d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ebx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r13+196]
	test	ebx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR windowLow$1$[rbp-256], ebx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, ebx
	mov	DWORD PTR matchLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	eax, r8d
	and	eax, r10d
	add	eax, eax
	lea	rax, QWORD PTR [r11+rax*4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;

	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax

; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */

	lea	eax, DWORD PTR [r8+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	eax, 1
	shl	eax, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	DWORD PTR nbCompares$1$[rsp], eax
	jne	$LN1929@ZSTD_compr
	mov	r9, QWORD PTR [r13+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	edx, ebx
	mov	QWORD PTR dms$1$[rbp-256], r9
	mov	r11, QWORD PTR [r9]
	mov	r12, QWORD PTR [r9+8]
	mov	r13d, r11d
	mov	r10d, DWORD PTR [r9+28]
	sub	r13d, r12d

; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;

	mov	eax, DWORD PTR [r9+192]
	sub	edx, r13d

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r9+188]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, 1
	dec	ecx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	shl	r9d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	eax, r13d
	dec	r9d
	mov	QWORD PTR dmsBase$2$[rbp-256], r12
	sub	eax, r10d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR tv16680[rsp], r13d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16444[rsp], edx
	mov	DWORD PTR dmsBtMask$1$[rsp], r9d
	cmp	r9d, eax
	jae	SHORT $LN1945@ZSTD_compr
	mov	ecx, r13d
	mov	QWORD PTR dmsBase$2$[rbp-256], r12
	sub	ecx, r9d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsBtLow$1$[rsp], ecx
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16444[rsp], edx
	jmp	SHORT $LN1946@ZSTD_compr
$LN1929@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16680[rsp], r9d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r10d, r9d
	mov	QWORD PTR dms$1$[rbp-256], r9
	mov	DWORD PTR dmsBtMask$1$[rsp], r9d
	mov	QWORD PTR dmsBase$2$[rbp-256], r9
	mov	QWORD PTR dmsEnd$2$[rbp-256], r9
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16444[rsp], r9d
$LN1945@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], r10d
$LN1946@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv16639[rbp-256]
	mov	edx, r8d
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	sub	edx, r14d
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r13d, eax
	mov	DWORD PTR tv16580[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r12d, DWORD PTR [rax+3]
	lea	r11, QWORD PTR [rcx+rax*4]
	mov	DWORD PTR lastR$1$[rsp], r12d
	mov	QWORD PTR tv16463[rbp-256], r11

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	jmp	SHORT $LN1880@ZSTD_compr
	npad	1
$LL2736@ZSTD_compr:
	mov	r8d, DWORD PTR current$1$[rsp]
$LN1880@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r13d, 3
	jne	SHORT $LN1947@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	dec	eax
	jmp	SHORT $LN1948@ZSTD_compr
$LN1947@ZSTD_compr:
	mov	eax, DWORD PTR [r11]
$LN1948@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	ecx, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r10d, r10d
	cmp	ecx, edx
	jae	SHORT $LN1885@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rdi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r8d, eax
	xor	eax, eax
	neg	r8
	mov	ecx, eax
	cmp	r9d, ebx
	setae	cl
	cmp	edx, DWORD PTR [r8+rdi]
	sete	al
	test	ecx, eax
	je	$LN2743@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	rdx, QWORD PTR [r8+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	add	rdx, rdi
	lea	rcx, QWORD PTR [rdi+4]
	call	ZSTD_count
	lea	r10d, DWORD PTR [rax+4]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN2805@ZSTD_compr
$LN1885@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	eax, DWORD PTR dictMode$[rbp-256]
	mov	r8d, r9d
	cmp	eax, 2
	jne	SHORT $LN1949@ZSTD_compr
	mov	edx, DWORD PTR tv16444[rsp]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, DWORD PTR current$1$[rsp]
	sub	r8, rdx
	add	r8, QWORD PTR dmsBase$2$[rbp-256]
	sub	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	xor	edx, edx
	cmp	ecx, eax
	mov	ecx, r14d
	setb	dl
	sub	ecx, r9d
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN2743@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8]
	jne	$LN2743@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r8+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rdi+4]
	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r10d, DWORD PTR [rax+4]
	jmp	$LN2805@ZSTD_compr
$LN1949@ZSTD_compr:

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, 1
	jne	$LN2743@ZSTD_compr
	mov	eax, DWORD PTR current$1$[rsp]
	xor	edx, edx
	sub	eax, ebx
	cmp	ecx, eax
	mov	ecx, r14d
	setb	dl
	sub	ecx, r9d
	mov	r9, QWORD PTR dictBase$1$[rsp]
	xor	eax, eax
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN1889@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r8+r9]
	jne	SHORT $LN1889@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	rbx, QWORD PTR [r9+4]
	add	rbx, r8
	lea	r12, QWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r12
	sub	rax, rbx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rbx
	add	rcx, rax
	cmp	rcx, r8
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+rbx]
	cmp	rcx, QWORD PTR dictEnd$1$[rbp-256]
	jne	SHORT $LN2098@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rax+r12]
	mov	rdx, QWORD PTR prefixStart$1$[rbp-256]
	call	ZSTD_count
	add	r14, rax
$LN2098@ZSTD_compr:
	mov	ebx, DWORD PTR windowLow$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	lea	r10d, DWORD PTR [r14+4]
	mov	r14d, DWORD PTR dictLimit$1$[rbp-256]
	mov	r12d, DWORD PTR lastR$1$[rsp]
$LN2805@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r11, QWORD PTR tv16463[rbp-256]
$LN2743@ZSTD_compr:
	mov	r9, QWORD PTR dictBase$1$[rsp]
$LN1889@ZSTD_compr:
	mov	edx, r10d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2758@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, r13d
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r10+rdi]
	mov	DWORD PTR [rcx+4], r10d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	xor	edx, edx
	cmp	rax, r8
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r10d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN1209@ZSTD_compr

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1878@ZSTD_compr
$LN2758@ZSTD_compr:
	mov	r8, QWORD PTR iend$1$[rsp]
$LN1878@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv16580[rbp-256]
	add	r11, 4
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	inc	r13d
	mov	QWORD PTR tv16463[rbp-256], r11
	cmp	r13d, r12d
	jb	$LL2736@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv16585[rbp-256]

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	ebx, DWORD PTR nbCompares$1$[rsp]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx
	test	ebx, ebx
	je	$LN2413@ZSTD_compr
	npad	5
$LL1881@ZSTD_compr:
	dec	ebx
	mov	DWORD PTR nbCompares$1$[rsp], ebx
	mov	DWORD PTR tv17872[rbp-256], ebx
	cmp	r15d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN2732@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	rcx, QWORD PTR bt$1$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR btMask$1$[rbp-256]
	add	eax, eax
	lea	r13, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN1901@ZSTD_compr
	mov	r12d, r15d
	lea	rax, QWORD PTR [r12+rbx]
	cmp	rax, QWORD PTR tv16584[rbp-256]
	jae	SHORT $LN1901@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	r14, QWORD PTR [r12+r9]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rbx]
	lea	rcx, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r12+rbx]
	cmp	rax, QWORD PTR tv16584[rbp-256]
	jb	SHORT $LN1903@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1903@ZSTD_compr
$LN1901@ZSTD_compr:

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14d, r15d

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+rdi]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax
$LN1903@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2757@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r15d
	cmp	rbx, rax
	jbe	SHORT $LN1905@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r15+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1905@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r15d
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;

	inc	r8d
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	edx, edx
	lea	rax, QWORD PTR [rbx+rdi]
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	cmp	rax, r8
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1906@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	ebx, edx
	cmovne	ebx, DWORD PTR tv17872[rbp-256]
	jmp	SHORT $LN2732@ZSTD_compr
$LN2757@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r8, QWORD PTR iend$1$[rsp]
$LN1906@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1908@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r15d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16445[rbp-256]
	jbe	SHORT $LN2369@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r15d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1909@ZSTD_compr
$LN1908@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r15d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16445[rbp-256]
	jbe	SHORT $LN2370@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN1909@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	ebx, DWORD PTR nbCompares$1$[rsp]
	test	ebx, ebx
	je	SHORT $LN2413@ZSTD_compr
	mov	r9, QWORD PTR dictBase$1$[rsp]
	jmp	$LL1881@ZSTD_compr
$LN2369@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	ebx, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$1[rbp-256]
	jmp	SHORT $LN1882@ZSTD_compr
$LN2370@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	ebx, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$1[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	SHORT $LN2732@ZSTD_compr
$LN2413@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	ebx
$LN2732@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN1882@ZSTD_compr:
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	xor	r12d, r12d

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	DWORD PTR [rcx], r12d
	mov	DWORD PTR [rax], r12d
	jne	$LN2371@ZSTD_compr
	test	ebx, ebx
	je	$LN2371@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	lea	r8d, QWORD PTR [r12+6]
	mov	rcx, rdi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	mov	esi, r12d
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	mov	ecx, r12d
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
	npad	8
$LL1883@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	ebx
	mov	DWORD PTR nbCompares$1$[rsp], ebx
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2689@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, rsi

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rsi
	mov	r12d, r15d
	cmovb	rbx, rcx
	add	r14, r12
	lea	r13, QWORD PTR [rdx+rax*4]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	lea	rcx, QWORD PTR [rbx+rdi]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16680[rsp]
	lea	rcx, QWORD PTR [rbx+r12]
	cmp	rcx, rax
	jb	SHORT $LN2738@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16444[rsp]
	mov	r14d, eax
	add	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1913@ZSTD_compr
$LN2738@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16444[rsp]
$LN1913@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1916@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+r15]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2482@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2482@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r12d, r12d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx
	add	eax, 2
	mov	DWORD PTR [rcx+r8*8+4], ebx
	lea	rcx, QWORD PTR [rcx+r8*8]
	inc	r8d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+rdi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r12d
	mov	eax, r12d
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	sete	cl
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2689@ZSTD_compr
$LN1916@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR dmsBtLow$1$[rsp]
	jbe	SHORT $LN2689@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1918@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [r13+4]
	mov	rcx, rbx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx

; 728  :             } else {

	jmp	SHORT $LN1919@ZSTD_compr
$LN1918@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	rsi, rbx
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1919@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	ebx, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	ebx, ebx
	jne	$LL1883@ZSTD_compr
$LN2689@ZSTD_compr:
	mov	esi, DWORD PTR seqPos$1$[rsp]
$LN2371@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 763  :     case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);

	jmp	$LN2791@ZSTD_compr
$LN1201@ZSTD_compr:

; 521  :     const BYTE* const base = ms->window.base;

	mov	r13, QWORD PTR [r12+8]
	cmp	eax, ecx

; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;

	mov	rbx, QWORD PTR [r12+48]
	mov	r14d, edi
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r13
	mov	eax, DWORD PTR [r12+192]
	sub	r14d, r13d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	mov	rcx, rdi
	mov	DWORD PTR current$1$[rsp], r14d
	mov	edx, eax
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r15d, DWORD PTR [rbx+rax*4]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	ecx, DWORD PTR [r12+188]
	dec	ecx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	mov	QWORD PTR tv16570[rbp-256], rax
	mov	ebx, 1
	mov	rax, QWORD PTR [r12+64]
	shl	ebx, cl

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rcx, QWORD PTR [r12+16]
	dec	ebx

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r12d, DWORD PTR [r12+24]
	mov	QWORD PTR bt$1$[rbp-256], rax

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	eax, r12d
	mov	QWORD PTR tv16569[rbp-256], rax

; 535  :     const BYTE* const prefixStart = base + dictLimit;

	add	rax, r13
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, r12
	mov	QWORD PTR prefixStart$1$[rbp-256], rax

; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	eax, r14d
	sub	eax, ebx
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	DWORD PTR dictLimit$1$[rbp-256], r12d
	mov	edx, r14d
	cmovb	ecx, eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR tv16443[rbp-256], ecx
	mov	rcx, rax
	mov	r8d, DWORD PTR [rax+184]
	call	ZSTD_getLowestMatchIndex
	mov	r13d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r13d, r13d
	mov	eax, 1
	cmovne	eax, r13d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	mov	rax, QWORD PTR bt$1$[rbp-256]

; 543  :     U32 mnum = 0;

	xor	edx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], edx
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r14+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r14d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	shl	r14d, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	jne	$LN1431@ZSTD_compr
	mov	r8, QWORD PTR [rax+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	edx, r13d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	ebx, 1
	mov	QWORD PTR dms$1$[rsp], r8
	mov	r10, QWORD PTR [r8]
	mov	r11, QWORD PTR [r8+8]
	mov	eax, r10d
	mov	r9d, DWORD PTR [r8+28]
	sub	eax, r11d
	mov	ecx, DWORD PTR [r8+188]
	sub	edx, eax
	mov	DWORD PTR tv16779[rsp], eax
	dec	ecx
	mov	eax, DWORD PTR [r8+192]
	shl	ebx, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	ecx, DWORD PTR tv16779[rsp]
	dec	ebx
	mov	DWORD PTR dmsHashLog$1$[rsp], eax
	mov	eax, ecx
	sub	eax, r9d
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	mov	QWORD PTR dmsEnd$2$[rbp-256], r10
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16442[rsp], edx
	mov	DWORD PTR dmsBtMask$1$[rsp], ebx
	cmp	ebx, eax
	jae	SHORT $LN1447@ZSTD_compr
	mov	r8d, ecx
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	sub	r8d, ebx
	mov	QWORD PTR dmsEnd$2$[rbp-256], r10
	mov	DWORD PTR dmsBtLow$1$[rbp-256], r8d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16442[rsp], edx
	jmp	SHORT $LN1448@ZSTD_compr
$LN1431@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16779[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, edx
	mov	QWORD PTR dms$1$[rsp], rdx
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	mov	QWORD PTR dmsBase$2$[rbp-256], rdx
	mov	QWORD PTR dmsEnd$2$[rbp-256], rdx
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	DWORD PTR tv16442[rsp], edx
$LN1447@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rbp-256], r9d
$LN1448@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv16639[rbp-256]
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	mov	edx, DWORD PTR current$1$[rsp]
	sub	edx, r12d
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv16567[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	r12, QWORD PTR [rcx+rax*4]
$LL1382@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN1449@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1450@ZSTD_compr
$LN1449@ZSTD_compr:
	mov	ecx, DWORD PTR [r12]
$LN1450@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r8d, eax
	xor	r9d, r9d
	sub	r8d, ecx
	cmp	r11d, edx
	jae	$LN1387@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	r11d, r11d
	mov	edx, ecx
	mov	ecx, r11d
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rdi]
	mov	eax, r11d
	sete	cl
	cmp	r8d, r13d
	setae	al
	test	ecx, eax
	je	SHORT $LN1391@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rdi+4]
	add	rdx, 4
	add	rdx, rdi
	call	ZSTD_count
	lea	r9d, DWORD PTR [rax+4]
$LN2719@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	r11d, r11d
$LN2723@ZSTD_compr:
	mov	r10d, DWORD PTR lastR$1$[rsp]
$LN1391@ZSTD_compr:
	mov	edx, r9d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN2760@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r9+rdi]
	mov	DWORD PTR [rcx+4], r9d
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rax, r8
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	eax, r11d
	sete	cl
	cmp	r9d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN1209@ZSTD_compr

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	$LN1380@ZSTD_compr
$LN1387@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	ecx, r8d
	jne	SHORT $LN1451@ZSTD_compr
	mov	edx, DWORD PTR tv16442[rsp]
	mov	r10, QWORD PTR dmsBase$2$[rbp-256]

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	sub	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	sub	r10, rdx
	add	r10, rcx
	xor	edx, edx
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r8d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	$LN2723@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	$LN2723@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
$LN2806@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r9d, DWORD PTR [rax+4]
	jmp	$LN2719@ZSTD_compr
$LN1451@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	add	r10, rcx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	$LN2719@ZSTD_compr
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	sub	eax, r13d
	xor	edx, edx
	cmp	r11d, eax
	setb	dl
	sub	ecx, r8d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	$LN2723@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	$LN2723@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	jmp	SHORT $LN2806@ZSTD_compr
$LN2760@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r8, QWORD PTR iend$1$[rsp]
$LN1380@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv16567[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	add	r12, 4
	cmp	ebx, r10d
	jb	$LL1382@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv16570[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r14d, r14d
	je	$LN2416@ZSTD_compr
	npad	14
$LL1383@ZSTD_compr:
	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	mov	DWORD PTR tv17927[rbp-256], r14d
	cmp	r15d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN2729@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r15d
	add	eax, eax
	lea	r13, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN1403@ZSTD_compr
	mov	r12d, r15d
	lea	rax, QWORD PTR [rbx+r12]
	cmp	rax, QWORD PTR tv16569[rbp-256]
	jae	SHORT $LN1403@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+rdi]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r14, r12
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rbx+r12]
	cmp	rax, QWORD PTR tv16569[rbp-256]
	jb	SHORT $LN1405@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1405@ZSTD_compr
$LN1403@ZSTD_compr:

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14d, r15d

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+rdi]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax
$LN1405@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2759@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r15d
	cmp	rbx, rax
	jbe	SHORT $LN1407@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r15+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1407@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r15d
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	inc	r8d
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+rdi]
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rax, r8
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	mov	eax, r11d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1408@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r14d, r11d
	cmovne	r14d, DWORD PTR tv17927[rbp-256]
	jmp	SHORT $LN2729@ZSTD_compr
$LN2759@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r8, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
$LN1408@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1410@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r15d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16443[rbp-256]
	jbe	$LN2375@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r15d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1411@ZSTD_compr
$LN1410@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r15d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16443[rbp-256]
	jbe	$LN2376@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN1411@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	test	r14d, r14d
	jne	$LL1383@ZSTD_compr
$LN2416@ZSTD_compr:
	dec	r14d
$LN2729@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN1384@ZSTD_compr:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d
	jne	$LN2377@ZSTD_compr
	test	r14d, r14d
	je	$LN2377@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rsp]
	mov	r8d, 4
	mov	rcx, rdi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rsp]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	esi, esi
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
$LL1385@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2690@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, rsi

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rsi
	mov	r12d, r15d
	cmovb	rbx, rcx
	add	r14, r12
	lea	r13, QWORD PTR [rdx+rax*4]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	lea	rcx, QWORD PTR [rbx+rdi]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16779[rsp]
	lea	rcx, QWORD PTR [rbx+r12]
	cmp	rcx, rax
	jb	SHORT $LN2734@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16442[rsp]
	lea	r14, QWORD PTR [r12+rax]
	add	r14, QWORD PTR base$1$[rbp-256]
	jmp	SHORT $LN1415@ZSTD_compr
$LN2375@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$3[rbp-256]
	jmp	$LN1384@ZSTD_compr
$LN2376@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$3[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN2729@ZSTD_compr
$LN2734@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16442[rsp]
$LN1415@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1418@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+r15]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2484@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2484@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	lea	rax, QWORD PTR [rbx+rdi]
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	xor	r8d, r8d
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2690@ZSTD_compr
$LN1418@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR dmsBtLow$1$[rbp-256]
	jbe	SHORT $LN2690@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1420@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [r13+4]
	mov	rcx, rbx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx

; 728  :             } else {

	jmp	SHORT $LN1421@ZSTD_compr
$LN1420@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	rsi, rbx
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1421@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r14d, r14d
	jne	$LL1385@ZSTD_compr
$LN2690@ZSTD_compr:
	mov	esi, DWORD PTR seqPos$1$[rsp]
$LN2377@ZSTD_compr:

; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]

; 760  :     case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);

	jmp	$LN2791@ZSTD_compr
$LN1202@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r14d, edi
	mov	r13, QWORD PTR [r12+8]
	cmp	eax, ecx

; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;

	mov	rbx, QWORD PTR [r12+48]

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	mov	QWORD PTR base$1$[rbp-256], r13
	mov	eax, DWORD PTR [r12+192]
	sub	r14d, r13d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	edx, eax
	mov	rcx, rdi
	mov	DWORD PTR current$1$[rsp], r14d
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];

	mov	r15d, DWORD PTR [rbx+rax*4]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	ecx, DWORD PTR [r12+188]
	dec	ecx
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx
	mov	QWORD PTR tv16558[rbp-256], rax
	mov	ebx, 1
	mov	rax, QWORD PTR [r12+64]
	shl	ebx, cl

; 532  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rcx, QWORD PTR [r12+16]
	dec	ebx

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r12d, DWORD PTR [r12+24]
	mov	QWORD PTR bt$1$[rbp-256], rax

; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;

	mov	eax, r12d
	mov	QWORD PTR tv16557[rbp-256], rax

; 535  :     const BYTE* const prefixStart = base + dictLimit;

	add	rax, r13
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, r12
	mov	QWORD PTR prefixStart$1$[rbp-256], rax

; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	eax, r14d
	sub	eax, ebx
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	cmp	ebx, r14d
	mov	DWORD PTR dictLimit$1$[rbp-256], r12d
	mov	edx, r14d
	cmovb	ecx, eax
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR tv16441[rbp-256], ecx
	mov	rcx, rax
	mov	r8d, DWORD PTR [rax+184]
	call	ZSTD_getLowestMatchIndex
	mov	r13d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r13d, r13d
	mov	eax, 1
	cmovne	eax, r13d
	and	ecx, r14d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	mov	rax, QWORD PTR bt$1$[rbp-256]

; 543  :     U32 mnum = 0;

	xor	edx, edx
	mov	DWORD PTR nbMatches$1$[rbp-256], edx
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r14+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r14d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	shl	r14d, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	jne	$LN1680@ZSTD_compr
	mov	r8, QWORD PTR [rax+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	edx, r13d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	ebx, 1
	mov	QWORD PTR dms$1$[rsp], r8
	mov	r10, QWORD PTR [r8]
	mov	r11, QWORD PTR [r8+8]
	mov	eax, r10d
	mov	r9d, DWORD PTR [r8+28]
	sub	eax, r11d
	mov	ecx, DWORD PTR [r8+188]
	sub	edx, eax
	mov	DWORD PTR tv16746[rsp], eax
	dec	ecx
	mov	eax, DWORD PTR [r8+192]
	shl	ebx, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	ecx, DWORD PTR tv16746[rsp]
	dec	ebx
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	mov	eax, ecx
	sub	eax, r9d
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	mov	QWORD PTR dmsEnd$2$[rbp-256], r10
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16440[rsp], edx
	mov	DWORD PTR dmsBtMask$1$[rsp], ebx
	cmp	ebx, eax
	jae	SHORT $LN1696@ZSTD_compr
	mov	r8d, ecx
	mov	QWORD PTR dmsBase$2$[rbp-256], r11
	sub	r8d, ebx
	mov	QWORD PTR dmsEnd$2$[rbp-256], r10
	mov	DWORD PTR dmsBtLow$1$[rsp], r8d
	mov	DWORD PTR dmsLowLimit$1$[rsp], r9d
	mov	DWORD PTR tv16440[rsp], edx
	jmp	SHORT $LN1697@ZSTD_compr
$LN1680@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16746[rsp], edx

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, edx
	mov	QWORD PTR dms$1$[rsp], rdx
	mov	DWORD PTR dmsBtMask$1$[rsp], edx
	mov	QWORD PTR dmsBase$2$[rbp-256], rdx
	mov	QWORD PTR dmsEnd$2$[rbp-256], rdx
	mov	DWORD PTR dmsLowLimit$1$[rsp], edx
	mov	DWORD PTR tv16440[rsp], edx
$LN1696@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rsp], r9d
$LN1697@ZSTD_compr:

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	rax, QWORD PTR tv16639[rbp-256]
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	mov	edx, DWORD PTR current$1$[rsp]
	sub	edx, r12d
	mov	QWORD PTR bestLength$1$[rbp-256], rax

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, eax
	mov	DWORD PTR tv16555[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	r12, QWORD PTR [rcx+rax*4]
$LL1631@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN1698@ZSTD_compr
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1699@ZSTD_compr
$LN1698@ZSTD_compr:
	mov	ecx, DWORD PTR [r12]
$LN1699@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	eax, DWORD PTR current$1$[rsp]

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rcx-1]
	mov	r8d, eax
	xor	r9d, r9d
	sub	r8d, ecx
	cmp	r11d, edx
	jae	$LN1636@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	r11d, r11d
	mov	edx, ecx
	mov	ecx, r11d
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rdi]
	mov	eax, r11d
	sete	cl
	cmp	r8d, r13d
	setae	al
	test	ecx, eax
	je	SHORT $LN1640@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rdi+4]
	add	rdx, 4
	add	rdx, rdi
	call	ZSTD_count
	lea	r9d, DWORD PTR [rax+4]
$LN2724@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	r11d, r11d
$LN2728@ZSTD_compr:
	mov	r10d, DWORD PTR lastR$1$[rsp]
$LN1640@ZSTD_compr:
	mov	edx, r9d
	cmp	rdx, QWORD PTR bestLength$1$[rbp-256]
	jbe	$LN2762@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r9+rdi]
	mov	DWORD PTR [rcx+4], r9d
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rax, r8
	mov	QWORD PTR bestLength$1$[rbp-256], rdx
	mov	eax, r11d
	sete	cl
	cmp	r9d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN1209@ZSTD_compr

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	$LN1629@ZSTD_compr
$LN1636@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	ecx, r8d
	jne	SHORT $LN1700@ZSTD_compr

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	mov	edx, DWORD PTR tv16440[rsp]
	mov	r10, QWORD PTR dmsBase$2$[rbp-256]
	sub	eax, edx
	sub	r10, rdx
	xor	edx, edx
	add	r10, rcx
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r8d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	$LN2728@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	$LN2728@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
$LN2807@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+4]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r10+4]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r9d, DWORD PTR [rax+4]
	jmp	$LN2724@ZSTD_compr
$LN1700@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r10, QWORD PTR dictBase$1$[rbp-256]
	add	r10, rcx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	$LN2724@ZSTD_compr
	mov	ecx, DWORD PTR dictLimit$1$[rbp-256]
	sub	eax, r13d
	xor	edx, edx
	cmp	r11d, eax
	setb	dl
	sub	ecx, r8d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	$LN2728@ZSTD_compr

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rdi]

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	eax, DWORD PTR [r10]
	jne	$LN2728@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	jmp	SHORT $LN2807@ZSTD_compr
$LN2762@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r8, QWORD PTR iend$1$[rsp]
$LN1629@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv16555[rbp-256]
	inc	ebx
	mov	rcx, QWORD PTR rep$1$[rbp-256]
	add	r12, 4
	cmp	ebx, r10d
	jb	$LL1631@ZSTD_compr

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv16558[rbp-256]
	mov	ecx, DWORD PTR current$1$[rsp]
	mov	DWORD PTR [rax], ecx

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r14d, r14d
	je	$LN2419@ZSTD_compr
	npad	5
$LL1632@ZSTD_compr:
	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	mov	DWORD PTR tv17982[rbp-256], r14d
	cmp	r15d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN2730@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r15d
	add	eax, eax
	lea	r13, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN1652@ZSTD_compr
	mov	r12d, r15d
	lea	rax, QWORD PTR [rbx+r12]
	cmp	rax, QWORD PTR tv16557[rbp-256]
	jae	SHORT $LN1652@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rbx+rdi]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r14, r12
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [rbx+r12]
	cmp	rax, QWORD PTR tv16557[rbp-256]
	jb	SHORT $LN1654@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1654@ZSTD_compr
$LN1652@ZSTD_compr:

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14d, r15d

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rbx+rdi]
	add	r14, QWORD PTR base$1$[rbp-256]
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax
$LN1654@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN2761@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r15d
	cmp	rbx, rax
	jbe	SHORT $LN1656@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r15+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1656@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r15d
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	inc	r8d
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+rdi]
	mov	ecx, r11d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rax, r8
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	mov	eax, r11d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1657@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r14d, r11d
	cmovne	r14d, DWORD PTR tv17982[rbp-256]
	jmp	SHORT $LN2730@ZSTD_compr
$LN2761@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r8, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
$LN1657@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1659@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r15d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16441[rbp-256]
	jbe	$LN2381@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r15d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1660@ZSTD_compr
$LN1659@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r15d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16441[rbp-256]
	jbe	$LN2382@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN1660@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	test	r14d, r14d
	jne	$LL1632@ZSTD_compr
$LN2419@ZSTD_compr:
	dec	r14d
$LN2730@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN1633@ZSTD_compr:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d
	jne	$LN2383@ZSTD_compr
	test	r14d, r14d
	je	$LN2383@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 5
	mov	rcx, rdi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rsp]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	esi, esi
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
$LL1634@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r14d
	mov	DWORD PTR nbCompares$1$[rsp], r14d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2691@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, rsi

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rsi
	mov	r12d, r15d
	cmovb	rbx, rcx
	add	r14, r12
	lea	r13, QWORD PTR [rdx+rax*4]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	lea	rcx, QWORD PTR [rbx+rdi]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16746[rsp]
	lea	rcx, QWORD PTR [rbx+r12]
	cmp	rcx, rax
	jb	SHORT $LN2735@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16440[rsp]
	mov	r14d, eax
	add	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1664@ZSTD_compr
$LN2381@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$2[rbp-256]
	jmp	$LN1633@ZSTD_compr
$LN2382@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$2[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	$LN2730@ZSTD_compr
$LN2735@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16440[rsp]
$LN1664@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rbp-256]
	jbe	SHORT $LN1667@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [r15+rax]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2486@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2486@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2

; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx+4], ebx
	mov	DWORD PTR [rcx], eax

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	lea	rax, QWORD PTR [rbx+rdi]
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	xor	r8d, r8d
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	mov	QWORD PTR bestLength$1$[rbp-256], rbx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2691@ZSTD_compr
$LN1667@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR dmsBtLow$1$[rsp]
	jbe	SHORT $LN2691@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rdi]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1669@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [r13+4]
	mov	rcx, rbx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx

; 728  :             } else {

	jmp	SHORT $LN1670@ZSTD_compr
$LN1669@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	rsi, rbx
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1670@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r14d, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r14d, r14d
	jne	$LL1634@ZSTD_compr
$LN2691@ZSTD_compr:
	mov	esi, DWORD PTR seqPos$1$[rsp]

; 761  :     case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);

	jmp	$LN2383@ZSTD_compr
$LN1200@ZSTD_compr:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 522  :     U32 const current = (U32)(ip-base);

	mov	r13d, edi
	mov	r12, QWORD PTR [r12+8]
	cmp	eax, ecx

; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	mov	QWORD PTR base$1$[rbp-256], r12
	cmovb	ecx, eax
	sub	r13d, r12d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR current$1$[rsp], r13d
	mov	eax, DWORD PTR [rcx+192]
	mov	edx, eax
	mov	rbx, QWORD PTR [rcx+48]
	mov	rcx, rdi
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	call	ZSTD_hashPtr

; 528  :     U32* const bt   = ms->chainTable;

	mov	r9, QWORD PTR ms$[rbp-256]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;

	xor	edx, edx
	mov	r15d, DWORD PTR [rbx+rax*4]
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdx
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdx

; 533  :     U32 const dictLimit = ms->window.dictLimit;

	mov	r14d, DWORD PTR [r9+24]
	mov	ebx, 1
	mov	ecx, DWORD PTR [r9+188]

; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	r8d, DWORD PTR [r9+184]
	dec	ecx
	shl	ebx, cl
	mov	rcx, QWORD PTR [r9+16]
	dec	ebx
	mov	QWORD PTR tv16546[rbp-256], rax
	mov	rax, QWORD PTR [r9+64]
	mov	QWORD PTR bt$1$[rbp-256], rax
	mov	eax, r14d
	mov	QWORD PTR dictBase$1$[rbp-256], rcx
	add	rcx, r14
	mov	QWORD PTR tv16545[rbp-256], rax
	add	rax, r12
	mov	QWORD PTR dictEnd$1$[rbp-256], rcx
	mov	ecx, edx
	mov	QWORD PTR prefixStart$1$[rbp-256], rax
	mov	edx, r13d
	mov	eax, r13d
	mov	DWORD PTR btMask$1$[rbp-256], ebx
	sub	eax, ebx
	mov	DWORD PTR dictLimit$1$[rsp], r14d
	cmp	ebx, r13d
	cmovb	ecx, eax
	mov	DWORD PTR tv16439[rbp-256], ecx
	mov	rcx, r9
	call	ZSTD_getLowestMatchIndex
	mov	r12d, eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, ebx
	test	r12d, r12d
	mov	eax, 1
	mov	edx, r13d
	cmovne	eax, r12d
	and	ecx, r13d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	mov	rax, QWORD PTR bt$1$[rbp-256]

; 543  :     U32 mnum = 0;

	xor	r8d, r8d
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r13+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r13d, 1
	mov	rax, QWORD PTR ms$[rbp-256]
	mov	ecx, DWORD PTR [rax+196]
	shl	r13d, cl

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;

	cmp	DWORD PTR dictMode$[rbp-256], 2
	jne	$LN1261@ZSTD_compr
	mov	r9, QWORD PTR [rax+176]

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	r8d, r12d
	mov	QWORD PTR dms$1$[rbp-256], r9
	mov	r11, QWORD PTR [r9]
	mov	rbx, QWORD PTR [r9+8]
	mov	eax, r11d
	mov	r10d, DWORD PTR [r9+28]
	sub	eax, ebx

; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;

	mov	ecx, DWORD PTR [r9+188]
	sub	r8d, eax
	mov	DWORD PTR tv16778[rsp], eax
	dec	ecx
	mov	eax, DWORD PTR [r9+192]

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r9d, 1
	shl	r9d, cl

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	ecx, DWORD PTR tv16778[rsp]
	dec	r9d
	mov	DWORD PTR dmsHashLog$1$[rbp-256], eax
	mov	eax, ecx
	sub	eax, r10d
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16438[rsp], r8d
	mov	DWORD PTR dmsBtMask$1$[rsp], r9d
	cmp	r9d, eax
	jae	SHORT $LN1277@ZSTD_compr
	mov	r9d, ecx
	mov	QWORD PTR dmsBase$2$[rbp-256], rbx
	sub	r9d, DWORD PTR dmsBtMask$1$[rsp]
	mov	DWORD PTR dmsBtLow$1$[rbp-256], r9d
	mov	QWORD PTR dmsEnd$2$[rbp-256], r11
	mov	DWORD PTR dmsLowLimit$1$[rsp], r10d
	mov	DWORD PTR tv16438[rsp], r8d
	jmp	SHORT $LN1278@ZSTD_compr
$LN1261@ZSTD_compr:

; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;

	mov	DWORD PTR tv16778[rsp], r8d

; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;

	mov	r10d, r8d
	mov	QWORD PTR dms$1$[rbp-256], r8
	mov	DWORD PTR dmsBtMask$1$[rsp], r8d
	mov	QWORD PTR dmsBase$2$[rbp-256], r8
	mov	QWORD PTR dmsEnd$2$[rbp-256], r8
	mov	DWORD PTR dmsLowLimit$1$[rsp], r8d
	mov	DWORD PTR tv16438[rsp], r8d
$LN1277@ZSTD_compr:

; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;

	mov	DWORD PTR dmsBtLow$1$[rbp-256], r10d
$LN1278@ZSTD_compr:

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	ecx, DWORD PTR ll0$1$[rsp]
	mov	rax, QWORD PTR tv16639[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	ebx, ecx
	mov	r9, QWORD PTR rep$1$[rbp-256]
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	eax, ecx
	mov	ecx, edx
	sub	ecx, r14d
	mov	DWORD PTR tv16543[rbp-256], ecx

; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	lea	r14, QWORD PTR [r9+rax*4]
$LL1212@ZSTD_compr:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	ebx, 3
	jne	SHORT $LN1279@ZSTD_compr
	mov	eax, DWORD PTR [r9]
	dec	eax
	jmp	SHORT $LN1280@ZSTD_compr
$LN1279@ZSTD_compr:
	mov	eax, DWORD PTR [r14]
$LN1280@ZSTD_compr:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, edx

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	r11d, DWORD PTR [rax-1]
	sub	r9d, eax
	xor	r10d, r10d
	cmp	r11d, ecx
	jae	SHORT $LN1217@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	r8d, DWORD PTR [rdi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, eax
	xor	eax, eax
	neg	r11

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	r8d, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	ecx, eax
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	edx, DWORD PTR [r11+rdi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	edx, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	r9d, r12d
	setae	cl
	cmp	r8d, edx
	sete	al
	test	ecx, eax
	je	$LN2784@ZSTD_compr

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r11+3]
	add	rdx, rdi
	lea	rcx, QWORD PTR [rdi+3]
	call	ZSTD_count
	lea	r10d, DWORD PTR [rax+3]

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */

	jmp	$LN2784@ZSTD_compr
$LN1217@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	ecx, r9d
	jne	SHORT $LN1281@ZSTD_compr
	mov	eax, r8d
	mov	r8, QWORD PTR dmsBase$2$[rbp-256]
	sub	r8, rax

; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	mov	eax, edx
	sub	eax, DWORD PTR dmsLowLimit$1$[rsp]
	add	r8, rcx
	sub	eax, DWORD PTR tv16438[rsp]
	xor	edx, edx
	mov	ecx, DWORD PTR dictLimit$1$[rsp]
	cmp	r11d, eax
	setb	dl
	sub	ecx, r9d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	$LN1221@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [rdi]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN1221@ZSTD_compr

; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	jmp	SHORT $LN2808@ZSTD_compr
$LN1281@ZSTD_compr:

; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?

	mov	r8, QWORD PTR dictBase$1$[rbp-256]
	add	r8, rcx

; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	DWORD PTR dictMode$[rbp-256], 1
	jne	SHORT $LN2784@ZSTD_compr
	mov	ecx, DWORD PTR dictLimit$1$[rsp]
	mov	eax, edx
	sub	eax, r12d
	xor	edx, edx
	cmp	r11d, eax
	setb	dl
	sub	ecx, r9d
	xor	r11d, r11d
	dec	ecx
	cmp	ecx, 3
	mov	eax, r11d
	setae	al
	test	edx, eax
	je	SHORT $LN1221@ZSTD_compr

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	ecx, DWORD PTR [rdi]
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r8]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	ecx, 8
	shl	eax, 8

; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {

	cmp	ecx, eax
	jne	SHORT $LN1221@ZSTD_compr

; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
$LN2808@ZSTD_compr:

; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rdx, QWORD PTR [r8+3]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rdi+3]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	lea	r10d, DWORD PTR [rax+3]
$LN2784@ZSTD_compr:
	xor	r11d, r11d
$LN1221@ZSTD_compr:
	mov	r9, QWORD PTR bestLength$1$[rsp]
	mov	edx, r10d
	cmp	rdx, r9
	jbe	SHORT $LN1210@ZSTD_compr

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	eax, ebx
	sub	eax, DWORD PTR ll0$1$[rsp]
	mov	r9d, edx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r8*8]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;

	inc	r8d
	mov	DWORD PTR [rcx], eax

; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	lea	rax, QWORD PTR [r10+rdi]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	eax, r11d
	mov	DWORD PTR [rcx+4], r10d
	mov	ecx, r11d
	sete	cl
	mov	QWORD PTR bestLength$1$[rsp], rdx
	cmp	r10d, DWORD PTR sufficient_len$1$[rbp-256]
	mov	DWORD PTR nbMatches$1$[rbp-256], r8d
	seta	al
	or	ecx, eax
	jne	$LN1209@ZSTD_compr
$LN1210@ZSTD_compr:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	eax, DWORD PTR ll0$1$[rsp]
	inc	ebx
	add	eax, 3
	add	r14, 4
	cmp	ebx, eax
	jae	SHORT $LN2652@ZSTD_compr
	mov	ecx, DWORD PTR tv16543[rbp-256]
	mov	edx, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR tv16438[rsp]
	mov	r9, QWORD PTR rep$1$[rbp-256]
	jmp	$LL1212@ZSTD_compr
$LN2652@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r9, 3
	jae	$LN2733@ZSTD_compr

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$[rbp-256]
	lea	rdx, QWORD PTR nextToUpdate3$[rbp-256]
	mov	r8, rdi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r14d, DWORD PTR current$1$[rsp]
	xor	r11d, r11d
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, r11d
	mov	ecx, r11d
	mov	ebx, r14d
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN2748@ZSTD_compr

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN1228@ZSTD_compr
	cmp	eax, DWORD PTR dictLimit$1$[rsp]
	jae	SHORT $LN1228@ZSTD_compr

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);

	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	mov	rcx, rdi
	mov	r8, QWORD PTR iend$1$[rsp]
	mov	edx, eax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	add	rdx, QWORD PTR dictBase$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_count_2segments
	jmp	SHORT $LN2794@ZSTD_compr
$LN1228@ZSTD_compr:

; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rdi
	mov	edx, eax
	add	rdx, QWORD PTR base$1$[rbp-256]
	call	ZSTD_count
$LN2794@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	xor	r11d, r11d
	mov	r8, rax
	cmp	rax, 3
	jb	$LN2744@ZSTD_compr

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	edx, r11d
	mov	QWORD PTR bestLength$1$[rsp], rax
	mov	r12d, 1
	lea	eax, DWORD PTR [rbx+2]
	mov	DWORD PTR nbMatches$1$[rbp-256], r12d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+r8]
	cmp	rax, r10
	mov	DWORD PTR [rcx+4], r8d
	mov	eax, DWORD PTR sufficient_len$1$[rbp-256]
	mov	ecx, r11d
	sete	dl
	cmp	r8, rax
	seta	cl
	or	edx, ecx
	je	$LN2745@ZSTD_compr

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r14+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rbp-256], r12d
	jmp	$LN2795@ZSTD_compr
$LN2733@ZSTD_compr:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r14d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
$LN2748@ZSTD_compr:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r10, QWORD PTR iend$1$[rsp]
$LN2796@ZSTD_compr:
	mov	r12d, DWORD PTR nbMatches$1$[rbp-256]
$LN1230@ZSTD_compr:
	mov	rax, QWORD PTR tv16546[rbp-256]
	mov	DWORD PTR [rax], r14d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r13d, r13d
	je	$LN2422@ZSTD_compr
	npad	7
$LL1213@ZSTD_compr:
	dec	r13d
	mov	DWORD PTR nbCompares$1$[rsp], r13d
	mov	DWORD PTR tv18051[rbp-256], r13d
	cmp	r15d, r8d
	jb	$LN2731@ZSTD_compr

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rbp-256]
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r15d
	add	eax, eax
	lea	r13, QWORD PTR [rcx+rax*4]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]

; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {

	test	DWORD PTR dictMode$[rbp-256], -3	; fffffffdH
	je	SHORT $LN1233@ZSTD_compr
	mov	r12d, r15d
	lea	rax, QWORD PTR [r12+rbx]
	cmp	rax, QWORD PTR tv16545[rbp-256]
	jae	SHORT $LN1233@ZSTD_compr

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);

	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	lea	rcx, QWORD PTR [rdi+rbx]
	mov	r14, QWORD PTR dictBase$1$[rbp-256]
	mov	r8, r10
	mov	r9, QWORD PTR dictEnd$1$[rbp-256]
	add	r14, r12
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 657  :             if (matchIndex+matchLength >= dictLimit)

	lea	rax, QWORD PTR [r12+rbx]
	cmp	rax, QWORD PTR tv16545[rbp-256]
	jb	SHORT $LN1235@ZSTD_compr

; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */

	mov	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1235@ZSTD_compr
$LN2744@ZSTD_compr:

; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LN2796@ZSTD_compr
$LN2745@ZSTD_compr:

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;
; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LN1230@ZSTD_compr
$LN1233@ZSTD_compr:

; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;

	mov	r14d, r15d

; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	lea	rcx, QWORD PTR [rdi+rbx]
	add	r14, QWORD PTR base$1$[rbp-256]
	mov	r8, r10
	lea	rdx, QWORD PTR [r14+rbx]
	call	ZSTD_count
	add	rbx, rax
$LN1235@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2747@ZSTD_compr

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, r15d
	cmp	rbx, rax
	jbe	SHORT $LN1237@ZSTD_compr

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r15+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1237@ZSTD_compr:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r12d, DWORD PTR nbMatches$1$[rbp-256]

; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r11d, r11d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r15d
	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r12*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	inc	r12d
	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR bestLength$1$[rsp], rbx
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rbp-256], r12d
	mov	ecx, r11d
	mov	eax, r11d
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN1238@ZSTD_compr

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	r13d, r11d
	cmovne	r13d, DWORD PTR tv18051[rbp-256]
	jmp	$LN2731@ZSTD_compr
$LN2747@ZSTD_compr:

; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	mov	r12d, DWORD PTR nbMatches$1$[rbp-256]
	xor	r11d, r11d
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1238@ZSTD_compr:

; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rbx]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1240@ZSTD_compr

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx
	mov	DWORD PTR [rax], r15d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16439[rbp-256]
	jbe	SHORT $LN2387@ZSTD_compr

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r15d, DWORD PTR [r13+4]
	lea	rax, QWORD PTR [r13+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1241@ZSTD_compr
$LN1240@ZSTD_compr:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rcx], r15d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR tv16439[rbp-256]
	jbe	SHORT $LN2388@ZSTD_compr

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	QWORD PTR largerPtr$1$[rbp-256], r13
$LN1241@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r13d, DWORD PTR nbCompares$1$[rsp]
	test	r13d, r13d
	je	SHORT $LN2422@ZSTD_compr
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL1213@ZSTD_compr
$LN2387@ZSTD_compr:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r13d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$4[rbp-256]
	jmp	SHORT $LN1214@ZSTD_compr
$LN2388@ZSTD_compr:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	mov	r13d, DWORD PTR nbCompares$1$[rsp]
	lea	rax, QWORD PTR dummy32$4[rbp-256]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	jmp	SHORT $LN2731@ZSTD_compr
$LN2422@ZSTD_compr:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	dec	r13d
$LN2731@ZSTD_compr:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN1214@ZSTD_compr:

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {

	cmp	DWORD PTR dictMode$[rbp-256], 2
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], r11d
	mov	DWORD PTR [rax], r11d
	jne	$LN2389@ZSTD_compr
	test	r13d, r13d
	je	$LN2389@ZSTD_compr

; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);

	mov	edx, DWORD PTR dmsHashLog$1$[rbp-256]
	mov	r8d, 3
	mov	rcx, rdi
	call	ZSTD_hashPtr

; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];

	mov	rdx, QWORD PTR dms$1$[rbp-256]

; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;

	xor	esi, esi
	mov	rcx, QWORD PTR [rdx+48]
	mov	rdx, QWORD PTR [rdx+64]
	mov	QWORD PTR dmsBt$1$[rbp-256], rdx
	mov	r15d, DWORD PTR [rcx+rax*4]
	xor	ecx, ecx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rcx
	npad	3
$LL1215@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	dec	r13d
	mov	DWORD PTR nbCompares$1$[rsp], r13d
	cmp	r15d, DWORD PTR dmsLowLimit$1$[rsp]
	jbe	$LN2692@ZSTD_compr

; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;

	mov	r14, QWORD PTR dmsBase$2$[rbp-256]
	mov	eax, r15d
	and	eax, DWORD PTR dmsBtMask$1$[rsp]
	mov	rbx, rsi

; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);

	mov	r9, QWORD PTR dmsEnd$2$[rbp-256]
	add	eax, eax
	mov	r8, QWORD PTR iend$1$[rsp]
	cmp	rcx, rsi
	mov	r12d, r15d
	cmovb	rbx, rcx
	add	r14, r12
	lea	r13, QWORD PTR [rdx+rax*4]
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [r14+rbx]
	lea	rcx, QWORD PTR [rdi+rbx]
	call	ZSTD_count_2segments
	add	rbx, rax

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16778[rsp]
	lea	rcx, QWORD PTR [r12+rbx]
	cmp	rcx, rax
	jb	SHORT $LN2737@ZSTD_compr

; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	eax, DWORD PTR tv16438[rsp]
	mov	r14d, eax
	add	r14, QWORD PTR base$1$[rbp-256]
	add	r14, r12
	jmp	SHORT $LN1245@ZSTD_compr
$LN2737@ZSTD_compr:

; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)

	mov	eax, DWORD PTR tv16438[rsp]
$LN1245@ZSTD_compr:

; 707  : 
; 708  :             if (matchLength > bestLength) {

	cmp	rbx, QWORD PTR bestLength$1$[rsp]
	jbe	SHORT $LN2746@ZSTD_compr

; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;

	lea	edx, DWORD PTR [rax+r15]

; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edx
	cmp	rbx, rax
	jbe	SHORT $LN2488@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdx+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN2488@ZSTD_compr:

; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r12d, DWORD PTR nbMatches$1$[rbp-256]

; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	xor	r8d, r8d
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edx
	add	eax, 2
	mov	DWORD PTR [rcx+r12*8+4], ebx
	lea	rcx, QWORD PTR [rcx+r12*8]
	inc	r12d
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rdi+rbx]
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, r8d
	mov	eax, r8d
	mov	QWORD PTR bestLength$1$[rsp], rbx
	sete	cl
	mov	DWORD PTR nbMatches$1$[rbp-256], r12d
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN2692@ZSTD_compr

; 707  : 
; 708  :             if (matchLength > bestLength) {

	jmp	SHORT $LN1248@ZSTD_compr
$LN2746@ZSTD_compr:
	mov	r12d, DWORD PTR nbMatches$1$[rbp-256]
$LN1248@ZSTD_compr:

; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */

	cmp	r15d, DWORD PTR dmsBtLow$1$[rbp-256]
	jbe	SHORT $LN2692@ZSTD_compr

; 725  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rbx]
	cmp	BYTE PTR [r14+rbx], al
	jae	SHORT $LN1250@ZSTD_compr

; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	r15d, DWORD PTR [r13+4]
	mov	rcx, rbx
	mov	QWORD PTR commonLengthSmaller$2$[rbp-256], rbx

; 728  :             } else {

	jmp	SHORT $LN1251@ZSTD_compr
$LN1250@ZSTD_compr:

; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];

	mov	r15d, DWORD PTR [r13]
	mov	rsi, rbx
	mov	rcx, QWORD PTR commonLengthSmaller$2$[rbp-256]
$LN1251@ZSTD_compr:

; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {

	mov	r13d, DWORD PTR nbCompares$1$[rsp]
	mov	rdx, QWORD PTR dmsBt$1$[rbp-256]
	test	r13d, r13d
	jne	$LL1215@ZSTD_compr
$LN2692@ZSTD_compr:
	mov	esi, DWORD PTR seqPos$1$[rsp]
$LN2389@ZSTD_compr:

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rbp-256], r12d
$LN2383@ZSTD_compr:

; 949  :                 U32 matchNb;
; 950  :                 if (!nbMatches) {

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
$LN2791@ZSTD_compr:
	add	eax, -8					; fffffff8H
$LN2795@ZSTD_compr:
	mov	rcx, QWORD PTR ms$[rbp-256]
	mov	DWORD PTR [rcx+36], eax
$LN1209@ZSTD_compr:
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	ebx, DWORD PTR cur$1$[rsp]
	test	r8d, r8d
	je	$LN2763@ZSTD_compr

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r12, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]
	mov	edx, eax
	mov	ecx, DWORD PTR [r12+rax*8+4]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN2393@ZSTD_compr
	lea	eax, DWORD PTR [rcx+rbx]
	cmp	eax, 4096				; 00001000H
	jae	$LN2393@ZSTD_compr

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r9d, r9d
	mov	ecx, r9d
	mov	DWORD PTR matchNb$1$[rsp], ecx
	test	r8d, r8d
	je	$LN2763@ZSTD_compr

; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;

	mov	rdx, r12
	mov	QWORD PTR tv16455[rbp-256], rdx
	npad	8
$LL21@ZSTD_compr:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	eax, DWORD PTR [rdx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR offset$1$[rbp-256], eax

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	ecx, ecx
	je	SHORT $LN61@ZSTD_compr
	lea	eax, DWORD PTR [rcx-1]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r14d, DWORD PTR [r12+rax*8+4]
	mov	eax, DWORD PTR offset$1$[rbp-256]
	inc	r14d
	jmp	SHORT $LN2797@ZSTD_compr
$LN61@ZSTD_compr:
	mov	r14d, DWORD PTR minMatch$1$[rbp-256]
$LN2797@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	mov	DWORD PTR startML$1$[rbp-256], r14d
	cmp	edx, r14d
	jb	$LN19@ZSTD_compr
	mov	r8, QWORD PTR optStatePtr$1$[rbp-256]
	lea	edi, DWORD PTR [rdx+rbx]
	inc	eax
	mov	r12d, ebx
	mov	DWORD PTR tv16532[rbp-256], eax
	neg	r12d
	npad	13
$LL24@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	ebx, r9d
	mov	DWORD PTR r$12[rbp-256], r9d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 264  :     U32 const mlBase = matchLength - MINMATCH;

	lea	r13d, DWORD PTR [r12+rdi]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	ebx, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [r8+80], 1
	jne	SHORT $LN2138@ZSTD_compr

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	cmp	DWORD PTR optLevel$[rbp-256], 0
	je	SHORT $LN2141@ZSTD_compr
	lea	ecx, DWORD PTR [r13-3]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR optStatePtr$1$[rbp-256]
	add	ebx, 16
	mov	r15d, DWORD PTR optLevel$[rbp-256]
	shl	ebx, 8
	add	ebx, eax
	add	ebx, DWORD PTR tv16587[rbp-256]
	jmp	$LN2137@ZSTD_compr
$LN2141@ZSTD_compr:
	mov	r15d, DWORD PTR optLevel$[rbp-256]

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	lea	eax, DWORD PTR [r13-2]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r9d
	mov	DWORD PTR r$11[rbp-256], r9d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	ebx, 16
	shl	ebx, 8

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	eax, 8

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	add	ebx, eax
	add	ebx, DWORD PTR tv16587[rbp-256]
	jmp	$LN2137@ZSTD_compr
$LN2138@ZSTD_compr:

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	cmp	DWORD PTR optLevel$[rbp-256], 0
	mov	rax, QWORD PTR [r8+24]
	mov	eax, DWORD PTR [rax+rbx*4]
	je	SHORT $LN2143@ZSTD_compr
	mov	ecx, eax
	call	ZSTD_fracWeight
	mov	rdx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	ecx, eax
	mov	eax, ebx
	shl	eax, 8
	add	eax, DWORD PTR [rdx+76]
	sub	eax, ecx

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	DWORD PTR optLevel$[rbp-256], 2
	mov	r14d, eax
	jge	SHORT $LN2139@ZSTD_compr
	jmp	SHORT $LN2630@ZSTD_compr
$LN2143@ZSTD_compr:

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$9[rbp-256], r9d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	edx, r9d
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	eax, ebx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	sub	eax, edx
	shl	eax, 8
	add	eax, DWORD PTR [r8+76]
	mov	r14d, eax
$LN2630@ZSTD_compr:

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)

	cmp	ebx, 20
	jb	SHORT $LN2139@ZSTD_compr

; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */

	shl	ebx, 9
	lea	r14d, DWORD PTR [rax-9728]
	add	r14d, ebx
$LN2139@ZSTD_compr:

; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r13-3]
	call	ZSTD_MLcode
	mov	r8, QWORD PTR optStatePtr$1$[rbp-256]

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	r15d, DWORD PTR optLevel$[rbp-256]
	mov	eax, eax
	lea	rbx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [r8+16]
	mov	eax, DWORD PTR [rbx+rax]
	test	r15d, r15d
	je	SHORT $LN2145@ZSTD_compr
	mov	ecx, eax
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR optStatePtr$1$[rbp-256]
	mov	edx, eax
	jmp	SHORT $LN2146@ZSTD_compr
$LN2145@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edx, edx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$10[rbp-256], edx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 43   :     return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);

	shl	edx, 8
$LN2146@ZSTD_compr:

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	lea	rax, OFFSET FLAT:ML_bits
	mov	eax, DWORD PTR [rbx+rax]

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */
; 281  : 
; 282  :     DEBUGLOG(8, "ZSTD_getMatchPrice(ml:%u) = %u", matchLength, price);
; 283  :     return price;

	mov	ebx, DWORD PTR tv16587[rbp-256]
	shl	eax, 8
	add	ebx, 51					; 00000033H
	add	eax, DWORD PTR [r8+72]
	sub	eax, edx
	add	eax, r14d
	mov	r14d, DWORD PTR startML$1$[rbp-256]
	add	ebx, eax
$LN2137@ZSTD_compr:

; 981  :                         U32 const pos = cur + mlen;
; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);
; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	mov	rdx, QWORD PTR opt$1$[rbp-256]
	cmp	edi, esi
	ja	SHORT $LL25@ZSTD_compr
	mov	eax, edi
	imul	rcx, rax, 28
	cmp	ebx, DWORD PTR [rcx+rdx]
	jl	SHORT $LN26@ZSTD_compr

; 992  :                         } else {
; 993  :                             DEBUGLOG(7, "rPos:%u (ml=%2u) => new price is worse (%.2f>=%.2f)",
; 994  :                                         pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));
; 995  :                             if (optLevel==0) break;  /* early update abort; gets ~+10% speed for about -0.01 ratio loss */

	test	r15d, r15d
	je	SHORT $LN2693@ZSTD_compr
	jmp	SHORT $LN22@ZSTD_compr
	npad	7
$LL25@ZSTD_compr:

; 985  :                             DEBUGLOG(7, "rPos:%u (ml=%2u) => new better price (%.2f<%.2f)",
; 986  :                                         pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));
; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	esi
	mov	eax, esi
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+rdx], 1073741824		; 40000000H
	cmp	esi, edi
	jb	SHORT $LL25@ZSTD_compr
	mov	DWORD PTR seqPos$1$[rsp], esi
$LN26@ZSTD_compr:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, edi
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;

	mov	eax, DWORD PTR offset$1$[rbp-256]
	mov	DWORD PTR [rcx+rdx+4], eax

; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+rdx+12], eax
	mov	DWORD PTR [rcx+rdx+8], r13d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rdx], ebx
$LN22@ZSTD_compr:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	dec	edi
	mov	r9d, 0
	lea	eax, DWORD PTR [r12+rdi]
	cmp	eax, r14d
	mov	eax, DWORD PTR tv16532[rbp-256]
	jae	$LL24@ZSTD_compr
$LN2693@ZSTD_compr:
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	xor	r9d, r9d
	mov	r8d, DWORD PTR nbMatches$1$[rbp-256]
	mov	ebx, DWORD PTR cur$1$[rsp]
	mov	r12, QWORD PTR matches$1$[rbp-256]
$LN19@ZSTD_compr:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	mov	rdx, QWORD PTR tv16455[rbp-256]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR matchNb$1$[rsp], ecx
	mov	QWORD PTR tv16455[rbp-256], rdx
	cmp	ecx, r8d
	jb	$LL21@ZSTD_compr
$LN2763@ZSTD_compr:

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	r13, QWORD PTR opt$1$[rbp-256]
	jmp	SHORT $LN16@ZSTD_compr
$LN2766@ZSTD_compr:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR cur$1$[rsp]
$LN16@ZSTD_compr:

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	inc	ebx
	mov	DWORD PTR cur$1$[rsp], ebx
	cmp	ebx, esi
	ja	SHORT $LN2654@ZSTD_compr
	mov	r14, QWORD PTR optStatePtr$1$[rbp-256]
	jmp	$LL18@ZSTD_compr
$LN2393@ZSTD_compr:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r12+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r14d, r14d
	mov	r13, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$[rbp-244], eax
	mov	eax, ebx
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$[rbp-248], ecx
	cmp	DWORD PTR [rax+r13+8], r14d
	jne	SHORT $LN59@ZSTD_compr
	mov	eax, DWORD PTR [rax+r13+12]
	jmp	SHORT $LN60@ZSTD_compr
$LN59@ZSTD_compr:
	mov	eax, r14d
$LN60@ZSTD_compr:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$[rbp-256]
	mov	r15, QWORD PTR rep$[rbp-256]
	sub	ebx, eax
	cmp	ebx, 4096				; 00001000H
	mov	esi, r14d
	cmovbe	esi, ebx
	mov	ebx, DWORD PTR lastSequence$5$[rbp-256]
	jmp	$_shortestPath$2810
$LN2654@ZSTD_compr:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	mov	r15, QWORD PTR rep$[rbp-256]
	mov	eax, esi
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+r13]
	mov	ebx, DWORD PTR [rdx+r13+24]
	movsd	xmm0, QWORD PTR [rdx+r13+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 996  :                         }
; 997  :             }   }   }
; 998  :         }  /* for (cur = 1; cur <= last_pos; cur++) */
; 999  : 
; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 996  :                         }
; 997  :             }   }   }
; 998  :         }  /* for (cur = 1; cur <= last_pos; cur++) */
; 999  : 
; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], ebx

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	esi, ecx
	jbe	$LN2790@ZSTD_compr
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	esi, eax
	movd	eax, xmm1
	sub	esi, eax
	xor	r14d, r14d
	jmp	$_shortestPath$2810
$LN49@ZSTD_compr:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [r15], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r15+8], eax
$LN50@ZSTD_compr:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	movups	xmm0, XMMWORD PTR lastSequence$[rbp-256]
	lea	r12d, DWORD PTR [rsi+1]
	mov	eax, r12d
	mov	edi, r12d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r13], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r13+16], xmm0
	mov	DWORD PTR [rcx+r13+24], ebx

; 1028 :             while (seqPos > 0) {

	test	esi, esi
	je	SHORT $LN28@ZSTD_compr
	npad	10
$LL27@ZSTD_compr:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, esi

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r13
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1031 :                 DEBUGLOG(6, "sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1032 :                             seqPos, storeStart, opt[seqPos].litlen, opt[seqPos].mlen, opt[seqPos].off);
; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1031 :                 DEBUGLOG(6, "sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1032 :                             seqPos, storeStart, opt[seqPos].litlen, opt[seqPos].mlen, opt[seqPos].off);
; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r13], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r13+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r13+24], eax
	mov	eax, esi
	sub	esi, edx
	cmp	eax, edx
	cmovbe	esi, r14d
	test	esi, esi
	jne	SHORT $LL27@ZSTD_compr
$LN28@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r12d
	ja	$LN30@ZSTD_compr
	mov	r8, QWORD PTR src$[rbp-256]
	npad	1
$LL31@ZSTD_compr:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r13+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r13+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r13+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	jne	SHORT $LN51@ZSTD_compr

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */

	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR ip$1$[rsp], rax

; 1051 :                         continue;   /* will finish */

	jmp	$LN29@ZSTD_compr
$LN51@ZSTD_compr:

; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], esi
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rdx, QWORD PTR src$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+rdx]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN2218@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN2219@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [rdx+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
	npad	13
$LL2232@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL2232@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN2798@ZSTD_compr
$LN2218@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$[rbp-256]
$LN2798@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	mov	rdx, QWORD PTR src$[rbp-256]
$LN2219@ZSTD_compr:
	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN2491@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN2491@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN2629@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN2629@ZSTD_compr:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	eax, r15d
	add	rdx, rax
	mov	QWORD PTR src$[rbp-256], rdx
	mov	r8, rdx
	mov	QWORD PTR ip$1$[rsp], rdx
$LN29@ZSTD_compr:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	inc	edi
	cmp	edi, r12d
	jbe	$LL31@ZSTD_compr
$LN30@ZSTD_compr:

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	edx, DWORD PTR optLevel$[rbp-256]
	mov	rcx, QWORD PTR optStatePtr$1$[rbp-256]
	call	ZSTD_setBasePrices
	mov	r9, QWORD PTR ip$1$[rsp]
	jmp	SHORT $LN2430@ZSTD_compr
$LN2772@ZSTD_compr:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r9, QWORD PTR ip$1$[rsp]
$LN2535@ZSTD_compr:
	inc	r9
	mov	QWORD PTR ip$1$[rsp], r9
$LN2430@ZSTD_compr:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r12d, 0
	mov	r13, QWORD PTR iend$1$[rsp]
	mov	r15, QWORD PTR ms$[rbp-256]
	mov	rdi, QWORD PTR src$[rbp-256]
	cmp	r9, QWORD PTR ilimit$1$[rbp-256]
	jb	$LL2@ZSTD_compr
	mov	r14, QWORD PTR [rsp+488]
$LN3@ZSTD_compr:

; 1061 :         }
; 1062 :     }   /* while (ip < ilimit) */
; 1063 : 
; 1064 :     /* Return the last literals size */
; 1065 :     return (size_t)(iend - anchor);

	sub	r13, rdi
	mov	rax, r13

; 1066 : }

	add	rsp, 496				; 000001f0H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressBlock_opt_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
table$ = 8
lastEltIndex$ = 16
bonus$dead$ = 24
ZSTD_upscaleStat PROC

; 1081 :     U32 s, sum=0;

	xor	r8d, r8d

; 1082 :     assert(ZSTD_FREQ_DIV+bonus >= 0);
; 1083 :     for (s=0; s<lastEltIndex+1; s++) {

	lea	r9d, DWORD PTR [rdx+1]
	mov	edx, r8d
	test	r9d, r9d
	je	$LN17@ZSTD_upsca
	cmp	r9d, 8
	jb	$LN15@ZSTD_upsca

; 1081 :     U32 s, sum=0;

	movdqa	xmm4, XMMWORD PTR __xmm@00000001000000010000000100000001
	mov	eax, 4
	mov	r8d, r9d
	xorps	xmm2, xmm2
	and	r8d, -8					; fffffff8H
	xorps	xmm1, xmm1
	movd	xmm3, eax
	npad	5
$LL4@ZSTD_upsca:

; 1084 :         table[s] <<= ZSTD_FREQ_DIV+bonus;

	mov	eax, edx
	movdqu	xmm0, XMMWORD PTR [rcx+rax*4]
	pslld	xmm0, xmm3

; 1085 :         table[s]--;

	psubd	xmm0, xmm4
	movdqu	XMMWORD PTR [rcx+rax*4], xmm0
	lea	eax, DWORD PTR [rdx+4]
	add	edx, 8

; 1086 :         sum += table[s];

	paddd	xmm0, xmm2
	movdqa	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rcx+rax*4]
	pslld	xmm0, xmm3
	psubd	xmm0, xmm4
	movdqu	XMMWORD PTR [rcx+rax*4], xmm0
	paddd	xmm0, xmm1
	movdqa	xmm1, xmm0
	cmp	edx, r8d
	jb	SHORT $LL4@ZSTD_upsca

; 1081 :     U32 s, sum=0;

	paddd	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	r8d, xmm1

; 1082 :     assert(ZSTD_FREQ_DIV+bonus >= 0);
; 1083 :     for (s=0; s<lastEltIndex+1; s++) {

	cmp	edx, r9d
	jae	SHORT $LN17@ZSTD_upsca
$LN15@ZSTD_upsca:

; 1084 :         table[s] <<= ZSTD_FREQ_DIV+bonus;

	mov	eax, edx
	sub	r9d, edx
	mov	edx, r9d
	lea	rax, QWORD PTR [rcx+rax*4]
	npad	11
$LL8@ZSTD_upsca:
	mov	ecx, DWORD PTR [rax]
	lea	rax, QWORD PTR [rax+4]
	shl	ecx, 4

; 1085 :         table[s]--;

	dec	ecx

; 1086 :         sum += table[s];

	add	r8d, ecx
	mov	DWORD PTR [rax-4], ecx
	sub	rdx, 1
	jne	SHORT $LL8@ZSTD_upsca
$LN17@ZSTD_upsca:

; 1087 :     }
; 1088 :     return sum;
; 1089 : }

	mov	eax, r8d
	ret	0
ZSTD_upscaleStat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
optPtr$ = 48
ZSTD_upscaleStats PROC

; 1093 : {

	sub	rsp, 40					; 00000028H

; 69   :     return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;

	cmp	DWORD PTR [rcx+96], 2

; 1093 : {

	mov	r10, rcx

; 1094 :     if (ZSTD_compressedLiterals(optPtr))

	je	SHORT $LN2@ZSTD_upsca

; 1095 :         optPtr->litSum = ZSTD_upscaleStat(optPtr->litFreq, MaxLit, 0);

	mov	rcx, QWORD PTR [rcx]
	mov	edx, 255				; 000000ffH
	call	ZSTD_upscaleStat
	mov	DWORD PTR [r10+48], eax
$LN2@ZSTD_upsca:

; 1096 :     optPtr->litLengthSum = ZSTD_upscaleStat(optPtr->litLengthFreq, MaxLL, 0);

	mov	rcx, QWORD PTR [r10+8]
	mov	edx, 35					; 00000023H
	call	ZSTD_upscaleStat

; 1097 :     optPtr->matchLengthSum = ZSTD_upscaleStat(optPtr->matchLengthFreq, MaxML, 0);

	mov	rcx, QWORD PTR [r10+16]
	mov	edx, 52					; 00000034H
	mov	DWORD PTR [r10+52], eax
	call	ZSTD_upscaleStat

; 1098 :     optPtr->offCodeSum = ZSTD_upscaleStat(optPtr->offCodeFreq, MaxOff, 0);

	mov	rcx, QWORD PTR [r10+24]
	mov	edx, 31
	mov	DWORD PTR [r10+56], eax
	call	ZSTD_upscaleStat
	mov	DWORD PTR [r10+60], eax

; 1099 : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_upscaleStats ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
_TEXT	SEGMENT
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchLow$1$ = 48
current$1$ = 48
current$1$ = 48
current$1$ = 48
matchEndIdx$1$ = 48
nbMatches$1$ = 52
ll0$1$ = 52
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
current$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
matchEndIdx$1$ = 56
sufficient_len$1$ = 56
nbCompares$1$ = 60
windowLow$1$ = 60
sufficient_len$1$ = 60
btMask$1$ = 60
btMask$1$ = 60
lastR$1$ = 60
nbCompares$1$ = 60
lastR$1$ = 60
nbCompares$1$ = 60
nbCompares$1$ = 60
windowLow$1$ = 60
tv11281 = 60
dummy32$1 = 60
dummy32$2 = 60
btMask$1$ = 64
btMask$1$ = 64
matchEndIdx$1$ = 64
windowLow$1$ = 64
windowLow$1$ = 64
windowLow$1$ = 64
lastR$1$ = 64
matchNb$1$ = 64
tv11295 = 64
iend$1$ = 72
btMask$1$ = 80
nbCompares$1$ = 80
windowLow$1$ = 80
lastR$1$ = 80
nbCompares$1$ = 80
nbCompares$1$ = 80
windowLow$1$ = 80
tv11268 = 80
dummy32$3 = 80
dummy32$4 = 80
current$1$ = 84
cur$1$ = 84
tv11204 = 84
tv11203 = 84
tv11202 = 84
matchLow$1$ = 88
btMask$1$ = 88
btMask$1$ = 88
matchLow$1$ = 88
ll0$1$ = 88
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
largerPtr$1$ = 96
rep$1$ = 96
matchLow$1$ = 104
sufficient_len$1$ = 104
matchLow$1$ = 104
matchLow$1$ = 104
tv11328 = 104
tv11201 = 104
tv11199 = 104
tv11197 = 104
sufficient_len$1$ = 108
matchLow$1$ = 108
sufficient_len$1$ = 108
btMask$1$ = 108
offset$1$ = 108
tv11321 = 108
tv11314 = 108
tv11288 = 108
tv11196 = 108
ip$1$ = 112
ms$GSCopy$1$ = 120
largerPtr$1$ = 128
largerPtr$1$ = 128
largerPtr$1$ = 128
largerPtr$1$ = 128
commonLengthSmaller$1$ = 128
commonLengthSmaller$1$ = 128
commonLengthSmaller$1$ = 128
commonLengthSmaller$1$ = 128
tv11215 = 128
smallerPtr$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
smallerPtr$1$ = 136
lastR$1$ = 144
lastR$1$ = 144
lastR$1$ = 144
litlen$1$ = 144
tv11198 = 144
lastR$1$ = 148
nbCompares$1$ = 148
sufficient_len$1$ = 148
sufficient_len$1$ = 148
seqPos$1$ = 148
tv11307 = 148
commonLengthLarger$1$ = 152
commonLengthSmaller$1$ = 152
commonLengthSmaller$1$ = 152
commonLengthSmaller$1$ = 152
inr$1$ = 152
tv11333 = 152
tv11323 = 152
tv11316 = 152
tv11309 = 152
tv11206 = 152
$T5 = 160
commonLengthLarger$1$ = 160
commonLengthLarger$1$ = 160
commonLengthLarger$1$ = 160
commonLengthLarger$1$ = 160
tv11348 = 160
matches$1$ = 168
commonLengthSmaller$1$ = 176
commonLengthLarger$1$ = 176
commonLengthLarger$1$ = 176
commonLengthLarger$1$ = 176
bt$1$ = 176
bt$1$ = 176
bt$1$ = 176
bt$1$ = 176
matchLow$1$ = 184
sufficient_len$1$ = 184
windowLow$1$ = 184
tv11274 = 184
r$6 = 184
tmpRep$2$ = 188
litlen$1$ = 188
opt$1$ = 192
minMatch$1$ = 200
$T7 = 208
basePrice$1$ = 208
r$8 = 208
tv11330 = 216
lastSequence$5$ = 224
bt$1$ = 232
bt$1$ = 232
bt$1$ = 232
tv11297 = 232
bt$1$ = 240
tv11290 = 240
tv11283 = 240
tv11276 = 240
nextToUpdate3$9 = 248
sufficient_len$1$ = 252
anchor$1$ = 256
ilimit$1$ = 264
seqStore$GSCopy$1$ = 272
lastSequence$10 = 280
lastSequence$4$ = 312
srcSize$GSCopy$1$ = 320
$T11 = 368
$T12 = 384
tmpRep$ = 400
__$ArrayPad$ = 416
ms$ = 512
seqStore$ = 520
rep$ = 528
src$ = 536
srcSize$ = 544
ZSTD_initStats_ultra PROC

; 1111 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-184]
	sub	rsp, 440				; 000001b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1112 :     U32 tmpRep[ZSTD_REP_NUM];  /* updated rep codes will sink here */
; 1113 :     memcpy(tmpRep, rep, sizeof(tmpRep));

	mov	eax, DWORD PTR [r8+8]
	mov	r12, rcx
	mov	r10, QWORD PTR srcSize$[rbp-256]
	mov	rdi, rdx
	movsd	xmm0, QWORD PTR [r8]
	mov	rsi, r9
	mov	DWORD PTR tmpRep$2$[rbp-256], eax

; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	r8, r10
	mov	ebx, DWORD PTR [r12+24]
	add	rbx, QWORD PTR [r12+8]
	lea	r14, QWORD PTR [r9+r10]

; 1112 :     U32 tmpRep[ZSTD_REP_NUM];  /* updated rep codes will sink here */
; 1113 :     memcpy(tmpRep, rep, sizeof(tmpRep));

	mov	DWORD PTR tmpRep$[rbp-248], eax

; 808  :     const BYTE* const ilimit = iend - 8;

	lea	r13, QWORD PTR [r14-8]

; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 1111 : {

	mov	QWORD PTR seqStore$GSCopy$1$[rbp-256], rdx

; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	edx, 4095				; 00000fffH

; 1111 : {

	mov	QWORD PTR ms$GSCopy$1$[rsp], rcx

; 803  :     optState_t* const optStatePtr = &ms->opt;

	add	rcx, 72					; 00000048H

; 809  :     const BYTE* const base = ms->window.base;
; 810  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 811  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 812  : 
; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, edx

; 1111 : {

	mov	QWORD PTR anchor$1$[rbp-256], r9

; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	r9d, 2

; 1111 : {

	mov	QWORD PTR srcSize$GSCopy$1$[rbp-256], r10

; 813  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmovb	edx, eax

; 1112 :     U32 tmpRep[ZSTD_REP_NUM];  /* updated rep codes will sink here */
; 1113 :     memcpy(tmpRep, rep, sizeof(tmpRep));

	movsd	QWORD PTR tmpRep$[rbp-256], xmm0

; 814  :     U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;

	xor	eax, eax
	mov	DWORD PTR sufficient_len$1$[rbp-256], edx
	cmp	DWORD PTR [r12+200], 3

; 815  :     U32 nextToUpdate3 = ms->nextToUpdate;
; 816  : 
; 817  :     ZSTD_optimal_t* const opt = optStatePtr->priceTable;
; 818  :     ZSTD_match_t* const matches = optStatePtr->matchTable;
; 819  :     ZSTD_optimal_t lastSequence;
; 820  : 
; 821  :     /* init */
; 822  :     DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
; 823  :                 (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
; 824  :     assert(optLevel <= 2);
; 825  :     ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);

	mov	rdx, rsi
	mov	QWORD PTR iend$1$[rsp], r14
	setne	al
	mov	QWORD PTR ilimit$1$[rbp-256], r13
	add	eax, 3
	mov	DWORD PTR minMatch$1$[rbp-256], eax
	mov	eax, DWORD PTR [r12+36]
	mov	DWORD PTR nextToUpdate3$9[rbp-256], eax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR opt$1$[rbp-256], rax
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR matches$1$[rbp-256], rax
	call	ZSTD_rescaleFreqs

; 826  :     ip += (ip==prefixStart);

	xor	ecx, ecx
	cmp	rsi, rbx
	mov	eax, ecx
	sete	al
	lea	r15, QWORD PTR [rax+rsi]
	mov	QWORD PTR ip$1$[rsp], r15
	cmp	r15, r13

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_initS
	movsd	xmm0, QWORD PTR lastSequence$10[rbp-240]
	mov	eax, DWORD PTR lastSequence$10[rbp-232]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0
	mov	DWORD PTR lastSequence$5$[rbp-256], eax
	npad	11
$LL4@ZSTD_initS:

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	r8, QWORD PTR [r12+8]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	eax, r15d

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	ebx, DWORD PTR [r12+36]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	sub	eax, esi

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	esi, DWORD PTR [r12+200]

; 833  :         {   U32 const litlen = (U32)(ip - anchor);

	mov	DWORD PTR litlen$1$[rbp-256], eax

; 834  :             U32 const ll0 = !litlen;

	mov	eax, ecx
	sete	al

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	QWORD PTR $T7[rbp-256], r8

; 834  :             U32 const ll0 = !litlen;

	mov	DWORD PTR ll0$1$[rsp], eax

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	lea	rax, QWORD PTR [r8+rbx]
	cmp	r15, rax
	jb	$LN1815@ZSTD_initS

; 489  :     U32 const target = (U32)(ip - base);

	mov	edi, r15d

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	xor	r13d, r13d
	sub	edi, r8d
	cmp	ebx, edi
	jae	SHORT $LN80@ZSTD_initS
	npad	15
$LL79@ZSTD_initS:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, esi
	add	rdx, r8
	mov	DWORD PTR [rsp+32], r13d
	mov	r8, r14
	mov	rcx, r12
	call	ZSTD_insertBt1
	mov	r8, QWORD PTR $T7[rbp-256]

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, edi
	jb	SHORT $LL79@ZSTD_initS
	mov	r8, QWORD PTR [r12+8]
	mov	QWORD PTR $T7[rbp-256], r8
$LN80@ZSTD_initS:

; 756  :     switch(matchLengthSearch)

	mov	rbx, QWORD PTR [r12+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], edi

; 756  :     switch(matchLengthSearch)

	mov	edx, DWORD PTR [r12+192]
	cmp	esi, 3
	je	$LN73@ZSTD_initS
	cmp	esi, 5
	je	$LN75@ZSTD_initS
	lea	eax, DWORD PTR [rsi-6]
	mov	esi, r15d
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN74@ZSTD_initS

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx
	cmovb	ecx, eax

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	sub	esi, r8d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	mov	rcx, r15
	mov	DWORD PTR current$1$[rsp], esi
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r14d, 1
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r12+64]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	r8d, DWORD PTR [r12+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r12+24]
	shl	r14d, cl
	mov	ecx, r13d
	mov	QWORD PTR tv11333[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r13
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r13
	cmovb	ecx, eax
	mov	DWORD PTR tv11204[rsp], ecx
	mov	rcx, r12
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	r11d, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	mov	eax, 1
	cmovne	eax, r11d
	mov	edx, r8d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r14d, r14d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r12+196]
	lea	rax, QWORD PTR [r13+4]
	mov	r15d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11330[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11328[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	lea	rbx, QWORD PTR tmpRep$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r10d
	lea	rbx, QWORD PTR [rbx+rax*4]
$LL595@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN662@ZSTD_initS
	mov	ecx, DWORD PTR tmpRep$[rbp-256]
	dec	ecx
	jmp	SHORT $LN663@ZSTD_initS
$LN662@ZSTD_initS:
	mov	ecx, DWORD PTR [rbx]
$LN663@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN602@ZSTD_initS

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rsp]
	setae	al
	test	ecx, eax
	je	SHORT $LN602@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN602@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN593@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	lea	rdx, QWORD PTR [rdx+r14*8]
	inc	r14d
	mov	DWORD PTR [rdx+4], r8d
	mov	ecx, esi
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN82@ZSTD_initS
$LN593@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11328[rsp]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	cmp	esi, r10d
	jb	$LL595@ZSTD_initS

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11333[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1869@ZSTD_initS
	npad	5
$LL596@ZSTD_initS:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rbp-256], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1869@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	rsi, QWORD PTR $T7[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1914@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN620@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN620@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r12, rbx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r14*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	inc	r14d
	add	rax, rbx
	mov	ecx, edx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	SHORT $LN621@ZSTD_initS
$LN1869@ZSTD_initS:

; 836  :             if (!nbMatches) { ip++; continue; }

	mov	rax, QWORD PTR largerPtr$1$[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN1937@ZSTD_initS
$LN1914@ZSTD_initS:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
$LN621@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN623@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11204[rsp]
	jbe	SHORT $LN1666@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN624@ZSTD_initS
$LN623@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11204[rsp]
	jbe	SHORT $LN1667@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN624@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rbp-256]
	test	r15d, r15d
	jne	$LL596@ZSTD_initS
	jmp	SHORT $LN1869@ZSTD_initS
$LN1666@ZSTD_initS:

; 836  :             if (!nbMatches) { ip++; continue; }

	lea	r13, QWORD PTR dummy32$1[rsp]
	jmp	SHORT $LN1869@ZSTD_initS
$LN1667@ZSTD_initS:
	lea	rax, QWORD PTR dummy32$1[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], ecx
	jmp	$LN1937@ZSTD_initS
$LN74@ZSTD_initS:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx
	cmovb	ecx, eax

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	sub	esi, r8d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	mov	rcx, r15
	mov	DWORD PTR current$1$[rsp], esi
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r14d, 1
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r12+64]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	r8d, DWORD PTR [r12+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r12+24]
	shl	r14d, cl
	mov	ecx, r13d
	mov	QWORD PTR tv11323[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r13
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r13
	cmovb	ecx, eax
	mov	DWORD PTR tv11203[rsp], ecx
	mov	rcx, r12
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	r11d, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	mov	eax, 1
	cmovne	eax, r11d
	mov	edx, r8d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r14d, r14d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r12+196]
	lea	rax, QWORD PTR [r13+4]
	mov	r15d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11330[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11321[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	lea	rbx, QWORD PTR tmpRep$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rbx+rax*4]
$LL255@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN322@ZSTD_initS
	mov	ecx, DWORD PTR tmpRep$[rbp-256]
	dec	ecx
	jmp	SHORT $LN323@ZSTD_initS
$LN322@ZSTD_initS:
	mov	ecx, DWORD PTR [rbx]
$LN323@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN262@ZSTD_initS

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rsp]
	setae	al
	test	ecx, eax
	je	SHORT $LN262@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN262@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN253@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	lea	rdx, QWORD PTR [rdx+r14*8]
	inc	r14d
	mov	DWORD PTR [rdx+4], r8d
	mov	ecx, esi
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN82@ZSTD_initS
$LN253@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11321[rsp]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	cmp	esi, r10d
	jb	$LL255@ZSTD_initS

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11323[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1869@ZSTD_initS
$LL256@ZSTD_initS:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1869@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	rsi, QWORD PTR $T7[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1916@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN280@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN280@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r12, rbx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r14*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	inc	r14d
	add	rax, rbx
	mov	ecx, edx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1869@ZSTD_initS

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN281@ZSTD_initS
$LN1916@ZSTD_initS:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN281@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN283@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11203[rsp]
	jbe	$LN1666@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN284@ZSTD_initS
$LN283@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11203[rsp]
	jbe	$LN1667@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN284@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
	test	r15d, r15d
	jne	$LL256@ZSTD_initS
	jmp	$LN1869@ZSTD_initS
$LN75@ZSTD_initS:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r15d
	cmp	eax, ecx
	cmovb	ecx, eax
	sub	esi, r8d
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	mov	rcx, r15
	mov	DWORD PTR current$1$[rsp], esi
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r14d, 1
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r12+64]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	r8d, DWORD PTR [r12+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r12+24]
	shl	r14d, cl
	mov	ecx, r13d
	mov	QWORD PTR tv11316[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r13
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r13
	cmovb	ecx, eax
	mov	DWORD PTR tv11202[rsp], ecx
	mov	rcx, r12
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	r11d, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	mov	eax, 1
	cmovne	eax, r11d
	mov	edx, r8d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r14d, r14d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r12+196]
	lea	rax, QWORD PTR [r13+4]
	mov	r15d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11330[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11314[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	lea	rbx, QWORD PTR tmpRep$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rbx, QWORD PTR [rbx+rax*4]
$LL425@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN492@ZSTD_initS
	mov	ecx, DWORD PTR tmpRep$[rbp-256]
	dec	ecx
	jmp	SHORT $LN493@ZSTD_initS
$LN492@ZSTD_initS:
	mov	ecx, DWORD PTR [rbx]
$LN493@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN432@ZSTD_initS

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11, QWORD PTR ip$1$[rsp]
	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rax]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	eax, DWORD PTR [rdx+r11]
	sete	cl
	xor	eax, eax
	cmp	r9d, DWORD PTR windowLow$1$[rsp]
	setae	al
	test	ecx, eax
	je	SHORT $LN432@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rax, r11
	add	rdx, 4
	add	rdx, rax
	lea	rcx, QWORD PTR [rax+4]
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN432@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN423@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, QWORD PTR ip$1$[rsp]
	lea	rdx, QWORD PTR [rdx+r14*8]
	inc	r14d
	mov	DWORD PTR [rdx+4], r8d
	mov	ecx, esi
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN82@ZSTD_initS
$LN423@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11314[rsp]
	inc	esi
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rbx, 4
	cmp	esi, r10d
	jb	$LL425@ZSTD_initS

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rcx, QWORD PTR tv11316[rbp-256]
	mov	DWORD PTR [rcx], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1869@ZSTD_initS
	npad	5
$LL426@ZSTD_initS:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	edi, DWORD PTR matchLow$1$[rsp]
	jb	$LN1869@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	mov	rcx, QWORD PTR ip$1$[rsp]
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	rsi, QWORD PTR $T7[rbp-256]
	add	rcx, rbx
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	SHORT $LN1918@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN450@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN450@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r12, rbx
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, edi

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r14*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	mov	rax, QWORD PTR ip$1$[rsp]
	inc	r14d
	add	rax, rbx
	mov	ecx, edx
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1869@ZSTD_initS

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN451@ZSTD_initS
$LN1918@ZSTD_initS:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN451@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	mov	rax, QWORD PTR ip$1$[rsp]
	movzx	eax, BYTE PTR [rbx+rax]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN453@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11202[rsp]
	jbe	$LN1666@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN454@ZSTD_initS
$LN453@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11202[rsp]
	jbe	$LN1667@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN454@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
	test	r15d, r15d
	jne	$LL426@ZSTD_initS
	jmp	$LN1869@ZSTD_initS
$LN73@ZSTD_initS:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	esi, r15d
	cmp	eax, ecx
	cmovb	ecx, eax
	sub	esi, r8d
	mov	DWORD PTR sufficient_len$1$[rsp], ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	mov	rcx, r15
	mov	DWORD PTR current$1$[rsp], esi
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 530  :     U32 const btMask= (1U << btLog) - 1;

	mov	r14d, 1
	mov	edi, DWORD PTR [rbx+rax*4]
	dec	ecx
	mov	r15, QWORD PTR [r12+64]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, esi
	mov	r8d, DWORD PTR [r12+184]
	lea	rax, QWORD PTR [rbx+rax*4]
	mov	ebx, DWORD PTR [r12+24]
	shl	r14d, cl
	mov	ecx, r13d
	mov	QWORD PTR tv11309[rbp-256], rax
	dec	r14d
	mov	eax, esi
	mov	QWORD PTR bt$1$[rbp-256], r15
	sub	eax, r14d
	mov	DWORD PTR btMask$1$[rsp], r14d
	cmp	r14d, esi
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], r13
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], r13
	cmovb	ecx, eax
	mov	DWORD PTR tv11201[rsp], ecx
	mov	rcx, r12
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	test	r11d, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r14d
	mov	eax, 1
	cmovne	eax, r11d
	mov	edx, r8d
	and	ecx, esi
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	r14d, r14d
	lea	r13, QWORD PTR [r15+rcx*4]

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r12+196]
	lea	rax, QWORD PTR [r13+4]
	mov	r15d, 1
	mov	QWORD PTR largerPtr$1$[rsp], rax
	lea	eax, DWORD PTR [rsi+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	eax, DWORD PTR minMatch$1$[rbp-256]
	shl	r15d, cl
	dec	eax
	sub	edx, ebx
	mov	QWORD PTR tv11330[rbp-256], rax
	mov	r12d, eax
	mov	DWORD PTR tv11307[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	lea	rbx, QWORD PTR tmpRep$[rbp-256]

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	esi, eax
	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r9d
	lea	rbx, QWORD PTR [rbx+rax*4]
$LL85@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	esi, 3
	jne	SHORT $LN152@ZSTD_initS
	mov	ecx, DWORD PTR tmpRep$[rbp-256]
	dec	ecx
	jmp	SHORT $LN153@ZSTD_initS
$LN152@ZSTD_initS:
	mov	ecx, DWORD PTR [rbx]
$LN153@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1933@ZSTD_initS

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	rax, QWORD PTR ip$1$[rsp]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rax]
	shl	edx, 8
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rax]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, r11d
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	$LN1865@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	rax, QWORD PTR ip$1$[rsp]
	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [rax+3]
	add	rdx, r9
	lea	rcx, QWORD PTR [rax+3]
	call	ZSTD_count
	mov	r9d, DWORD PTR lastR$1$[rsp]

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, DWORD PTR windowLow$1$[rsp]

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r8d, DWORD PTR [rax+3]
$LN1933@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	edx, edx
$LN92@ZSTD_initS:
	mov	r10, QWORD PTR ip$1$[rsp]
	mov	eax, r8d
	cmp	rax, r12
	jbe	SHORT $LN83@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	mov	r12d, eax

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, r10
	mov	DWORD PTR [rdx+r14*8+4], r8d
	lea	rdx, QWORD PTR [rdx+r14*8]
	mov	ecx, esi
	sub	ecx, DWORD PTR ll0$1$[rsp]
	inc	r14d
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN82@ZSTD_initS
$LN83@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	esi
	add	rbx, 4
	cmp	esi, r9d
	jae	SHORT $LN1841@ZSTD_initS
	mov	edx, DWORD PTR tv11307[rbp-256]
	mov	r8d, DWORD PTR current$1$[rsp]
	jmp	$LL85@ZSTD_initS
$LN1865@ZSTD_initS:

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, DWORD PTR lastR$1$[rsp]
	jmp	SHORT $LN92@ZSTD_initS
$LN1841@ZSTD_initS:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r12, 3
	jae	$LN1890@ZSTD_initS

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	lea	rdx, QWORD PTR nextToUpdate3$9[rbp-256]
	mov	r8, r10
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	esi, DWORD PTR current$1$[rsp]
	xor	ecx, ecx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, ecx
	mov	ebx, esi
	sub	ebx, eax
	cmp	eax, r8d
	setae	dl
	cmp	ebx, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	SHORT $LN1921@ZSTD_initS

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR ip$1$[rsp]
	mov	edx, eax
	add	rdx, QWORD PTR $T7[rbp-256]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1899@ZSTD_initS

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rbx+2]

; 632  :                 if ( (mlen > sufficient_len) |

	xor	r8d, r8d
	mov	r12, rax
	mov	r14d, 1
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rax+r10]
	cmp	rcx, r9
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	xor	edx, edx
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1899@ZSTD_initS

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [rsi+1]

; 635  :                     return 1;

	jmp	$LN1940@ZSTD_initS
$LN1890@ZSTD_initS:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	esi, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1941@ZSTD_initS
$LN1899@ZSTD_initS:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN103@ZSTD_initS
$LN1921@ZSTD_initS:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10, QWORD PTR ip$1$[rsp]
	xor	edx, edx
$LN1941@ZSTD_initS:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN103@ZSTD_initS:
	mov	rax, QWORD PTR tv11309[rbp-256]
	mov	DWORD PTR [rax], esi

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r15d, r15d
	je	$LN1894@ZSTD_initS
$LL86@ZSTD_initS:
	dec	r15d
	mov	DWORD PTR nbCompares$1$[rsp], r15d
	cmp	edi, r8d
	jb	$LN1894@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, edi
	add	eax, eax
	mov	esi, edi
	lea	r15, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rbx, rcx
	cmovb	rbx, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	rsi, QWORD PTR $T7[rbp-256]
	lea	rcx, QWORD PTR [rbx+r10]
	lea	rdx, QWORD PTR [rsi+rbx]
	call	ZSTD_count
	add	rbx, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rbx, r12
	jbe	$LN1920@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, ebx
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN110@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN110@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR matches$1$[rbp-256]
	mov	r12, rbx

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR ip$1$[rsp]
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	eax, r14d
	inc	r14d
	lea	rcx, QWORD PTR [rcx+rax*8]
	mov	eax, DWORD PTR current$1$[rsp]
	sub	eax, edi
	mov	DWORD PTR [rcx+4], edx
	add	eax, 2
	xor	edx, edx
	mov	DWORD PTR [rcx], eax
	lea	rax, QWORD PTR [rbx+r10]
	cmp	rax, r9
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rbx, 4096				; 00001000H
	seta	al
	or	ecx, eax
	je	$LN111@ZSTD_initS
$LN1894@ZSTD_initS:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR largerPtr$1$[rsp]
$LN1706@ZSTD_initS:
	mov	DWORD PTR [rax], edx

; 694  : 
; 695  :     if (dictMode == ZSTD_dictMatchState && nbCompares) {
; 696  :         size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
; 697  :         U32 dictMatchIndex = dms->hashTable[dmsH];
; 698  :         const U32* const dmsBt = dms->chainTable;
; 699  :         commonLengthSmaller = commonLengthLarger = 0;
; 700  :         while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {
; 701  :             const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
; 702  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 703  :             const BYTE* match = dmsBase + dictMatchIndex;
; 704  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
; 705  :             if (dictMatchIndex+matchLength >= dmsHighLimit)
; 706  :                 match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
; 707  : 
; 708  :             if (matchLength > bestLength) {
; 709  :                 matchIndex = dictMatchIndex + dmsIndexDelta;
; 710  :                 DEBUGLOG(8, "found dms match of length %u at distance %u (offCode=%u)",
; 711  :                         (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 712  :                 if (matchLength > matchEndIdx - matchIndex)
; 713  :                     matchEndIdx = matchIndex + (U32)matchLength;
; 714  :                 bestLength = matchLength;
; 715  :                 matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;
; 716  :                 matches[mnum].len = (U32)matchLength;
; 717  :                 mnum++;
; 718  :                 if ( (matchLength > ZSTD_OPT_NUM)
; 719  :                    | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
; 720  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 721  :                 }
; 722  :             }
; 723  : 
; 724  :             if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
; 725  :             if (match[matchLength] < ip[matchLength]) {
; 726  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 727  :                 dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
; 728  :             } else {
; 729  :                 /* match is larger than current */
; 730  :                 commonLengthLarger = matchLength;
; 731  :                 dictMatchIndex = nextPtr[0];
; 732  :             }
; 733  :         }
; 734  :     }
; 735  : 
; 736  :     assert(matchEndIdx > current+8);
; 737  :     ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	DWORD PTR [r13], edx
$LN1937@ZSTD_initS:

; 836  :             if (!nbMatches) { ip++; continue; }

	add	eax, -8					; fffffff8H
$LN1940@ZSTD_initS:
	mov	r8, QWORD PTR ms$GSCopy$1$[rsp]
	mov	DWORD PTR [r8+36], eax
$LN82@ZSTD_initS:
	test	r14d, r14d
	je	$LN1930@ZSTD_initS

; 837  : 
; 838  :             /* initialize opt[0] */
; 839  :             { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 840  :             opt[0].mlen = 0;  /* means is_a_literal */

	xor	r12d, r12d
	mov	eax, DWORD PTR tmpRep$[rbp-256]

; 841  :             opt[0].litlen = litlen;

	mov	ebx, DWORD PTR litlen$1$[rbp-256]

; 842  :             /* We don't need to include the actual price of the literals because
; 843  :              * it is static for the duration of the forward pass, and is included
; 844  :              * in every price. We include the literal length to avoid negative
; 845  :              * prices when we subtract the previous literal length.
; 846  :              */
; 847  :             opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);

	mov	ecx, ebx
	mov	rsi, QWORD PTR ms$GSCopy$1$[rsp]
	mov	DWORD PTR [rdi+16], eax
	lea	r8d, QWORD PTR [r12+2]
	mov	eax, DWORD PTR tmpRep$[rbp-252]
	mov	DWORD PTR [rdi+20], eax
	mov	eax, DWORD PTR tmpRep$2$[rbp-256]
	lea	rdx, QWORD PTR [rsi+72]
	mov	DWORD PTR [rdi+24], eax
	mov	DWORD PTR [rdi+8], r12d
	mov	DWORD PTR [rdi+12], ebx
	call	ZSTD_litLengthPrice

; 848  : 
; 849  :             /* large match -> immediate encoding */
; 850  :             {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	DWORD PTR [rdi], eax
	lea	eax, DWORD PTR [r14-1]
	mov	ecx, eax
	mov	eax, DWORD PTR [r15+rax*8+4]

; 851  :                 U32 const maxOffset = matches[nbMatches-1].off;
; 852  :                 DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series",
; 853  :                             nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));
; 854  : 
; 855  :                 if (maxML > sufficient_len) {

	cmp	eax, DWORD PTR sufficient_len$1$[rbp-256]
	jbe	$LN35@ZSTD_initS

; 856  :                     lastSequence.litlen = litlen;
; 857  :                     lastSequence.mlen = maxML;
; 858  :                     lastSequence.off = maxOffset;
; 859  :                     DEBUGLOG(6, "large match (%u>%u), immediate encoding",
; 860  :                                 maxML, sufficient_len);
; 861  :                     cur = 0;
; 862  :                     last_pos = ZSTD_totalLen(lastSequence);
; 863  :                     goto _shortestPath;

	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	mov	DWORD PTR lastSequence$10[rbp-248], eax
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR lastSequence$10[rbp-252], eax
	mov	DWORD PTR lastSequence$10[rbp-244], ebx
	movups	xmm2, XMMWORD PTR lastSequence$10[rbp-256]
	jmp	$LN1943@ZSTD_initS
$LN1920@ZSTD_initS:

; 661  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR iend$1$[rsp]
	xor	edx, edx
	mov	r10, QWORD PTR ip$1$[rsp]
$LN111@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+r10]
	cmp	BYTE PTR [rsi+rbx], al
	jae	SHORT $LN113@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [r13], edi

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rbx

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11201[rsp]
	jbe	SHORT $LN1678@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	edi, DWORD PTR [r15+4]
	lea	r13, QWORD PTR [r15+4]

; 685  :         } else {

	jmp	SHORT $LN114@ZSTD_initS
$LN113@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rbx
	mov	DWORD PTR [rax], edi

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv11201[rsp]
	jbe	SHORT $LN1679@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r15]
	mov	QWORD PTR largerPtr$1$[rsp], r15
$LN114@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r15d, DWORD PTR nbCompares$1$[rsp]
	test	r15d, r15d
	je	$LN1894@ZSTD_initS
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL86@ZSTD_initS
$LN1678@ZSTD_initS:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	r13, QWORD PTR dummy32$2[rsp]
	jmp	$LN1894@ZSTD_initS
$LN1679@ZSTD_initS:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$2[rsp]
	jmp	$LN1706@ZSTD_initS
$LN35@ZSTD_initS:

; 867  :             {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	lea	rdx, QWORD PTR [rsi+72]
	xor	ecx, ecx
	call	ZSTD_litLengthPrice
	mov	r13d, eax
	lea	rcx, QWORD PTR [rdi+28]
	mov	rax, QWORD PTR tv11330[rbp-256]
	add	r13d, DWORD PTR [rdi]
	mov	rdx, rax
	lea	esi, DWORD PTR [rax+1]
	npad	13
$LL11@ZSTD_initS:

; 868  :                 U32 pos;
; 869  :                 U32 matchNb;
; 870  :                 for (pos = 1; pos < minMatch; pos++) {
; 871  :                     opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */

	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	lea	rcx, QWORD PTR [rcx+28]
	sub	rdx, 1
	jne	SHORT $LL11@ZSTD_initS

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	test	r14d, r14d
	je	$LN13@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rax, r15
	mov	ecx, r14d
	mov	QWORD PTR tv11215[rbp-256], rax
	mov	QWORD PTR tv11348[rbp-256], rcx
	npad	9
$LL14@ZSTD_initS:

; 875  :                     U32 const end = matches[matchNb].len;

	mov	r15d, DWORD PTR [rax+4]
	mov	r14d, DWORD PTR [rax]

; 876  :                     for ( ; pos <= end ; pos++ ) {

	cmp	esi, r15d
	ja	$LN12@ZSTD_initS
	lea	r12d, DWORD PTR [r14+1]
	npad	12
$LL17@ZSTD_initS:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ecx, ecx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	mov	edi, ecx
	mov	DWORD PTR r$8[rbp-256], ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edi, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rcx+152], 1
	jne	SHORT $LN807@ZSTD_initS

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [rsi-3]
	call	ZSTD_fracWeight
	lea	edx, DWORD PTR [rdi+16]
	shl	edx, 8
	add	edx, eax
	jmp	SHORT $LN806@ZSTD_initS
$LN807@ZSTD_initS:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rax+rdi*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	shl	edi, 8
	add	edi, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [rsi-3]
	sub	edi, eax
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	mov	eax, eax
	lea	rbx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax+rbx]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR ms$GSCopy$1$[rsp]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	edx, DWORD PTR [rbx+rcx]
	shl	edx, 8
	add	edx, DWORD PTR [r8+144]
	sub	edx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	add	edx, 51					; 00000033H
	add	edx, edi
$LN806@ZSTD_initS:

; 881  :                         opt[pos].mlen = pos;

	mov	rdi, QWORD PTR opt$1$[rbp-256]

; 882  :                         opt[pos].off = offset;
; 883  :                         opt[pos].litlen = litlen;

	mov	ebx, DWORD PTR litlen$1$[rbp-256]
	mov	eax, esi
	imul	rcx, rax, 28
	lea	eax, DWORD PTR [rdx+r13]
	mov	DWORD PTR [rcx+rdi+8], esi
	inc	esi
	mov	DWORD PTR [rcx+rdi+4], r14d
	mov	DWORD PTR [rcx+rdi+12], ebx

; 884  :                         opt[pos].price = sequencePrice;

	mov	DWORD PTR [rcx+rdi], eax
	cmp	esi, r15d
	jbe	$LL17@ZSTD_initS
	mov	rax, QWORD PTR tv11215[rbp-256]
	mov	rcx, QWORD PTR tv11348[rbp-256]
$LN12@ZSTD_initS:

; 872  :                 }
; 873  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	add	rax, 8
	sub	rcx, 1
	mov	QWORD PTR tv11215[rbp-256], rax
	mov	QWORD PTR tv11348[rbp-256], rcx
	jne	$LL14@ZSTD_initS
$LN13@ZSTD_initS:

; 885  :                 }   }
; 886  :                 last_pos = pos-1;

	lea	ebx, DWORD PTR [rsi-1]

; 887  :             }
; 888  :         }
; 889  : 
; 890  :         /* check further positions */
; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	eax, 1
	mov	DWORD PTR seqPos$1$[rbp-256], ebx
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	ebx, eax
	jb	$LN1848@ZSTD_initS
	npad	2
$LL20@ZSTD_initS:

; 892  :             const BYTE* const inr = ip + cur;

	mov	rsi, QWORD PTR ip$1$[rsp]

; 893  :             assert(cur < ZSTD_OPT_NUM);
; 894  :             DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
; 895  : 
; 896  :             /* Fix current position with one literal if cheaper */
; 897  :             {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;

	lea	r12d, DWORD PTR [rax-1]
	mov	r14d, eax
	imul	rax, r12, 28
	add	rsi, r14
	add	rdi, rax
	mov	QWORD PTR inr$1$[rbp-256], rsi
	cmp	DWORD PTR [rdi+8], 0
	jne	SHORT $LN57@ZSTD_initS
	mov	r15d, DWORD PTR [rdi+12]
	inc	r15d
	jmp	SHORT $LN58@ZSTD_initS
$LN57@ZSTD_initS:
	mov	r15d, 1
$LN58@ZSTD_initS:

; 898  :                 int const price = opt[cur-1].price

	mov	r13, QWORD PTR ms$GSCopy$1$[rsp]
	lea	ecx, DWORD PTR [r15-1]
	add	r13, 72					; 00000048H
	mov	r8d, 2
	mov	rdx, r13
	call	ZSTD_litLengthPrice
	mov	edi, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rsi-1]
	mov	r9d, 2
	mov	r8, r13
	sub	edi, eax
	lea	edx, QWORD PTR [r9-1]
	call	ZSTD_rawLiteralsCost
	mov	r8d, 2
	mov	rdx, r13
	mov	ecx, r15d
	add	edi, eax
	call	ZSTD_litLengthPrice

; 899  :                                 + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
; 900  :                                 + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
; 901  :                                 - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
; 902  :                 assert(price < 1000000000); /* overflow check */
; 903  :                 if (price <= opt[cur].price) {

	imul	r14, r14, 28
	add	eax, edi
	xor	edx, edx
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	r14, rdi
	cmp	eax, DWORD PTR [r14]
	jg	SHORT $LN1830@ZSTD_initS

; 904  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
; 905  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
; 906  :                                 opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
; 907  :                     opt[cur].mlen = 0;
; 908  :                     opt[cur].off = 0;

	mov	QWORD PTR [r14+4], rdx

; 909  :                     opt[cur].litlen = litlen;

	mov	DWORD PTR [r14+12], r15d

; 910  :                     opt[cur].price = price;

	mov	DWORD PTR [r14], eax
$LN1830@ZSTD_initS:

; 911  :                 } else {
; 912  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
; 913  :                                 inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
; 914  :                                 opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
; 915  :                 }
; 916  :             }
; 917  : 
; 918  :             /* Set the repcodes of the current position. We must do it here
; 919  :              * because we rely on the repcodes of the 2nd to last sequence being
; 920  :              * correct to set the next chunks repcodes during the backward
; 921  :              * traversal.
; 922  :              */
; 923  :             ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
; 924  :             assert(cur >= opt[cur].mlen);
; 925  :             if (opt[cur].mlen != 0) {

	mov	ecx, DWORD PTR [r14+8]
	mov	r15d, DWORD PTR cur$1$[rsp]
	test	ecx, ecx
	je	SHORT $LN38@ZSTD_initS

; 926  :                 U32 const prev = cur - opt[cur].mlen;
; 927  :                 repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);

	cmp	DWORD PTR [r14+12], 0
	mov	r9d, edx
	mov	r8d, DWORD PTR [r14+4]
	lea	rdx, QWORD PTR [rdi+16]
	sete	r9b
	mov	eax, r15d
	sub	eax, ecx
	imul	rcx, rax, 28
	add	rdx, rcx
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	ZSTD_updateRep

; 928  :                 memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));

	movsd	xmm0, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+8]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], ecx

; 929  :             } else {

	jmp	SHORT $LN39@ZSTD_initS
$LN38@ZSTD_initS:

; 930  :                 memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));

	imul	rax, r12, 28
	movsd	xmm0, QWORD PTR [rax+rdi+16]
	mov	eax, DWORD PTR [rax+rdi+24]
	movsd	QWORD PTR [r14+16], xmm0
	mov	DWORD PTR [r14+24], eax
$LN39@ZSTD_initS:

; 931  :             }
; 932  : 
; 933  :             /* last match must start at a minimum distance of 8 from oend */
; 934  :             if (inr > ilimit) continue;

	cmp	rsi, QWORD PTR ilimit$1$[rbp-256]
	ja	$LN18@ZSTD_initS

; 935  : 
; 936  :             if (cur == last_pos) break;

	cmp	r15d, ebx
	je	$LN1848@ZSTD_initS

; 937  : 
; 938  :             if ( (optLevel==0) /*static_test*/
; 939  :               && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {
; 940  :                 DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
; 941  :                 continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
; 942  :             }
; 943  : 
; 944  :             {   U32 const ll0 = (opt[cur].mlen != 0);

	mov	eax, DWORD PTR [r14+8]
	xor	edx, edx
	test	eax, eax
	mov	ecx, edx
	setne	cl
	mov	DWORD PTR ll0$1$[rsp], ecx

; 945  :                 U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;

	test	eax, eax
	jne	SHORT $LN59@ZSTD_initS
	mov	r12d, DWORD PTR [r14+12]
	mov	DWORD PTR litlen$1$[rbp-256], r12d
	jmp	SHORT $LN60@ZSTD_initS
$LN59@ZSTD_initS:
	mov	DWORD PTR litlen$1$[rbp-256], edx
$LN60@ZSTD_initS:

; 946  :                 U32 const previousPrice = opt[cur].price;

	mov	edi, DWORD PTR [r14]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	mov	r8d, 2
	mov	rdx, r13
	xor	ecx, ecx
	call	ZSTD_litLengthPrice

; 752  :     U32 const matchLengthSearch = cParams->minMatch;

	mov	r12, QWORD PTR ms$GSCopy$1$[rsp]

; 947  :                 U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);

	add	eax, edi

; 948  :                 U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);

	add	r14, 16
	mov	DWORD PTR basePrice$1$[rbp-256], eax
	mov	QWORD PTR rep$1$[rsp], r14

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	rdx, QWORD PTR [r12+8]
	mov	edi, DWORD PTR [r12+36]
	mov	r15d, DWORD PTR [r12+200]
	mov	QWORD PTR $T5[rbp-256], rdx
	lea	rcx, QWORD PTR [rdx+rdi]
	cmp	rsi, rcx
	jb	$LN1906@ZSTD_initS

; 489  :     U32 const target = (U32)(ip - base);

	mov	r14d, esi
	sub	r14d, edx

; 490  :     U32 idx = ms->nextToUpdate;
; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	edi, r14d
	jae	SHORT $LN863@ZSTD_initS
	mov	rbx, QWORD PTR iend$1$[rsp]
	mov	rsi, rdx
	npad	8
$LL862@ZSTD_initS:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, edi
	mov	r9d, r15d
	add	rdx, rsi
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rbx
	mov	rcx, r12
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	edi, eax
	cmp	edi, r14d
	jb	SHORT $LL862@ZSTD_initS

; 910  :                     opt[cur].price = price;

	mov	rdx, QWORD PTR [r12+8]
	mov	ebx, DWORD PTR seqPos$1$[rbp-256]
	mov	rsi, QWORD PTR inr$1$[rbp-256]
	mov	QWORD PTR $T5[rbp-256], rdx
$LN863@ZSTD_initS:

; 756  :     switch(matchLengthSearch)

	mov	rdi, QWORD PTR [r12+48]
	mov	ecx, 4095				; 00000fffH

; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r12+36], r14d

; 756  :     switch(matchLengthSearch)

	cmp	r15d, 3
	je	$LN856@ZSTD_initS
	cmp	r15d, 5
	je	$LN858@ZSTD_initS
	lea	eax, DWORD PTR [r15-6]
	mov	r15d, esi
	cmp	eax, 1
	mov	eax, DWORD PTR [r12+204]
	ja	$LN857@ZSTD_initS

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 6
	cmovb	ecx, eax
	sub	r15d, edx
	mov	edx, DWORD PTR [r12+192]
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$GSCopy$1$[rsp]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11297[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11199[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rbp-256], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rsp], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11330[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$GSCopy$1$[rsp]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11295[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	6
$LL1378@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1445@ZSTD_initS
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1446@ZSTD_initS
$LN1445@ZSTD_initS:
	mov	ecx, DWORD PTR [rdi]
$LN1446@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1385@ZSTD_initS

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN1901@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1901@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN1385@ZSTD_initS:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1923@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rsp], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN865@ZSTD_initS

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1376@ZSTD_initS
$LN1923@ZSTD_initS:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1376@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11295[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL1378@ZSTD_initS

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11297[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1881@ZSTD_initS
$LL1379@ZSTD_initS:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rbp-256]
	jb	$LN1881@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR $T5[rbp-256]
	lea	rcx, QWORD PTR [rsi+rdi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1922@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1403@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1403@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rsp]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rsi+rdi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rsp], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1881@ZSTD_initS

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1404@ZSTD_initS
$LN1922@ZSTD_initS:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1404@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1406@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11199[rsp]
	jbe	SHORT $LN1682@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1407@ZSTD_initS
$LN1406@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11199[rsp]
	jbe	SHORT $LN1683@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rbp-256], r12
$LN1407@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1379@ZSTD_initS
	jmp	SHORT $LN1881@ZSTD_initS
$LN1682@ZSTD_initS:

; 950  :                 if (!nbMatches) {

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	lea	rax, QWORD PTR dummy32$3[rsp]
	xor	edx, edx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1944@ZSTD_initS
$LN1683@ZSTD_initS:
	lea	rax, QWORD PTR dummy32$3[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
$LN1881@ZSTD_initS:
	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
	xor	edx, edx
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	jmp	$LN1944@ZSTD_initS
$LN857@ZSTD_initS:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 4
	cmovb	ecx, eax
	sub	r15d, edx
	mov	edx, DWORD PTR [r12+192]
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$GSCopy$1$[rsp]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11290[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11198[rbp-256], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rbp-256], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rsp], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11330[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$GSCopy$1$[rsp]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11288[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r10d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rsp], r10d
	lea	rdi, QWORD PTR [rcx+rax*4]
	npad	5
$LL1038@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1105@ZSTD_initS
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1106@ZSTD_initS
$LN1105@ZSTD_initS:
	mov	ecx, DWORD PTR [rdi]
$LN1106@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r9d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r9d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1045@ZSTD_initS

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	edx, ecx
	xor	ecx, ecx
	neg	rdx
	cmp	eax, DWORD PTR [rdx+rsi]
	sete	cl
	xor	eax, eax
	cmp	r9d, r11d
	setae	al
	test	ecx, eax
	je	SHORT $LN1045@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	add	rdx, rsi
	call	ZSTD_count
	mov	r10d, DWORD PTR lastR$1$[rsp]
	mov	r11d, DWORD PTR windowLow$1$[rbp-256]
	lea	r8d, DWORD PTR [rax+4]
$LN1045@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1927@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r9d, DWORD PTR nbMatches$1$[rsp]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r9*8]
	inc	r9d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rsp], r9d
	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, r9
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN865@ZSTD_initS

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1036@ZSTD_initS
$LN1927@ZSTD_initS:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1036@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11288[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r10d
	jb	$LL1038@ZSTD_initS

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11290[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1881@ZSTD_initS
$LL1039@ZSTD_initS:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1881@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR $T5[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1926@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1063@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rdi+r14]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1063@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rsp]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rsp], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1881@ZSTD_initS

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1064@ZSTD_initS
$LN1926@ZSTD_initS:
	mov	r9, QWORD PTR iend$1$[rsp]
$LN1064@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1066@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11198[rbp-256]
	jbe	$LN1682@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1067@ZSTD_initS
$LN1066@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11198[rbp-256]
	jbe	$LN1683@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rbp-256], r12
$LN1067@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1039@ZSTD_initS
	jmp	$LN1881@ZSTD_initS
$LN858@ZSTD_initS:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 5
	cmovb	ecx, eax
	sub	r15d, edx
	mov	edx, DWORD PTR [r12+192]
	mov	DWORD PTR sufficient_len$1$[rbp-256], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$GSCopy$1$[rsp]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11283[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11197[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rsp], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11330[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$GSCopy$1$[rsp]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11281[rsp], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL1208@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN1275@ZSTD_initS
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN1276@ZSTD_initS
$LN1275@ZSTD_initS:
	mov	ecx, DWORD PTR [rdi]
$LN1276@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1215@ZSTD_initS

; 330  :     case 4 : return MEM_read32(memPtr);

	mov	edx, DWORD PTR [rsi]

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	xor	eax, eax
	mov	r9d, ecx
	mov	ecx, eax
	neg	r9
	cmp	r10d, r11d
	setae	cl
	cmp	edx, DWORD PTR [r9+rsi]
	sete	al
	test	ecx, eax
	je	SHORT $LN1902@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+4]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+4]
	call	ZSTD_count
	mov	r11d, DWORD PTR windowLow$1$[rsp]
	lea	r8d, DWORD PTR [rax+4]
$LN1902@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
$LN1215@ZSTD_initS:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1925@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	mov	ecx, edx
	mov	DWORD PTR nbMatches$1$[rsp], r10d
	mov	r10, QWORD PTR iend$1$[rsp]
	cmp	rax, r10
	mov	eax, edx
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rbp-256]
	seta	al
	or	ecx, eax
	jne	$LN865@ZSTD_initS

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN1206@ZSTD_initS
$LN1925@ZSTD_initS:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1206@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	edx, DWORD PTR tv11281[rsp]
	inc	r15d
	mov	r8d, DWORD PTR current$1$[rsp]
	add	rdi, 4
	mov	rcx, QWORD PTR rep$1$[rsp]
	cmp	r15d, r9d
	jb	$LL1208@ZSTD_initS

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	rax, QWORD PTR tv11283[rbp-256]
	mov	DWORD PTR [rax], r8d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1881@ZSTD_initS
	npad	8
$LL1209@ZSTD_initS:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, DWORD PTR matchLow$1$[rsp]
	jb	$LN1881@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r10
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR $T5[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1924@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN1233@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN1233@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r8d, DWORD PTR nbMatches$1$[rsp]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r10, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r8*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r8d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r10
	mov	DWORD PTR nbMatches$1$[rsp], r8d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	$LN1881@ZSTD_initS

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN1234@ZSTD_initS
$LN1924@ZSTD_initS:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN1234@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN1236@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11197[rsp]
	jbe	$LN1682@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN1237@ZSTD_initS
$LN1236@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11197[rsp]
	jbe	$LN1683@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rbp-256], r12
$LN1237@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	jne	$LL1209@ZSTD_initS
	jmp	$LN1881@ZSTD_initS
$LN856@ZSTD_initS:

; 520  :     U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);

	mov	eax, DWORD PTR [r12+204]

; 521  :     const BYTE* const base = ms->window.base;
; 522  :     U32 const current = (U32)(ip-base);

	mov	r15d, esi
	cmp	eax, ecx

; 523  :     U32 const hashLog = cParams->hashLog;
; 524  :     U32 const minMatch = (mls==3) ? 3 : 4;
; 525  :     U32* const hashTable = ms->hashTable;
; 526  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, 3
	cmovb	ecx, eax
	sub	r15d, edx
	mov	edx, DWORD PTR [r12+192]
	mov	DWORD PTR sufficient_len$1$[rsp], ecx
	mov	rcx, rsi
	mov	DWORD PTR current$1$[rsp], r15d
	call	ZSTD_hashPtr

; 527  :     U32 matchIndex  = hashTable[h];
; 528  :     U32* const bt   = ms->chainTable;
; 529  :     U32 const btLog = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r12+188]

; 531  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 532  :     const BYTE* const dictBase = ms->window.dictBase;
; 533  :     U32 const dictLimit = ms->window.dictLimit;
; 534  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 535  :     const BYTE* const prefixStart = base + dictLimit;
; 536  :     U32 const btLow = (btMask >= current) ? 0 : current - btMask;
; 537  :     U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);

	mov	edx, r15d
	mov	r13, QWORD PTR [r12+64]
	dec	ecx
	mov	r9, QWORD PTR ms$GSCopy$1$[rsp]
	mov	r12d, 1
	mov	r14d, DWORD PTR [rdi+rax*4]
	lea	rax, QWORD PTR [rdi+rax*4]
	shl	r12d, cl
	xor	ecx, ecx
	mov	QWORD PTR tv11276[rbp-256], rax
	dec	r12d
	mov	r8d, DWORD PTR [r9+184]
	mov	eax, r15d
	mov	edi, DWORD PTR [r9+24]
	sub	eax, r12d
	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	cmp	r12d, r15d
	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rcx
	cmovb	ecx, eax
	mov	QWORD PTR bt$1$[rbp-256], r13
	mov	DWORD PTR tv11196[rsp], ecx
	mov	rcx, r9
	mov	DWORD PTR btMask$1$[rsp], r12d
	call	ZSTD_getLowestMatchIndex
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	r11d, eax
	mov	DWORD PTR windowLow$1$[rsp], eax

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	mov	ecx, r12d
	test	r11d, r11d
	mov	eax, 1

; 544  :     U32 nbCompares = 1U << cParams->searchLog;

	mov	r12d, 1
	mov	edx, r8d

; 538  :     U32 const matchLow = windowLow ? windowLow : 1;

	cmovne	eax, r11d

; 539  :     U32* smallerPtr = bt + 2*(current&btMask);

	and	ecx, r15d
	mov	DWORD PTR matchLow$1$[rsp], eax
	add	ecx, ecx
	lea	rax, QWORD PTR [rcx*4]

; 540  :     U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 541  :     U32 matchEndIdx = current+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
; 542  :     U32 dummy32;   /* to be nullified at the end */
; 543  :     U32 mnum = 0;

	xor	ecx, ecx
	add	rax, r13
	mov	DWORD PTR nbMatches$1$[rsp], ecx

; 545  : 
; 546  :     const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
; 547  :     const ZSTD_compressionParameters* const dmsCParams =
; 548  :                                       dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
; 549  :     const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
; 550  :     const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
; 551  :     U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
; 552  :     U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
; 553  :     U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
; 554  :     U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
; 555  :     U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
; 556  :     U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
; 557  :     U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
; 558  : 
; 559  :     size_t bestLength = lengthToBeat-1;

	mov	r13, QWORD PTR tv11330[rbp-256]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax
	add	rax, 4
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
	lea	eax, DWORD PTR [r15+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
	mov	rax, QWORD PTR ms$GSCopy$1$[rsp]
	mov	ecx, DWORD PTR [rax+196]

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	mov	eax, DWORD PTR ll0$1$[rsp]
	shl	r12d, cl

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	mov	r15d, eax
	mov	rcx, QWORD PTR rep$1$[rsp]
	sub	edx, edi
	mov	DWORD PTR tv11274[rbp-256], edx

; 560  :     DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", current);
; 561  : 
; 562  :     /* check repCode */
; 563  :     assert(ll0 <= 1);   /* necessarily 1 or 0 */
; 564  :     {   U32 const lastR = ZSTD_REP_NUM + ll0;

	lea	r9d, DWORD PTR [rax+3]
	mov	DWORD PTR lastR$1$[rbp-256], r9d
	lea	rdi, QWORD PTR [rcx+rax*4]
$LL868@ZSTD_initS:

; 567  :             U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];

	cmp	r15d, 3
	jne	SHORT $LN935@ZSTD_initS
	mov	ecx, DWORD PTR [rcx]
	dec	ecx
	jmp	SHORT $LN936@ZSTD_initS
$LN935@ZSTD_initS:
	mov	ecx, DWORD PTR [rdi]
$LN936@ZSTD_initS:

; 568  :             U32 const repIndex = current - repOffset;

	mov	r10d, r8d

; 569  :             U32 repLen = 0;
; 570  :             assert(current >= dictLimit);
; 571  :             if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < current-dictLimit) {  /* equivalent to `current > repIndex >= dictLimit` */

	lea	eax, DWORD PTR [rcx-1]
	sub	r10d, ecx
	xor	r8d, r8d
	cmp	eax, edx
	jae	SHORT $LN1935@ZSTD_initS

; 332  :                 return MEM_read32(memPtr)<<8;

	mov	edx, DWORD PTR [rsi]
	shl	edx, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, ecx
	xor	ecx, ecx
	neg	r9
; File E:\dev\pyzstd\lib\common\mem.h

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */

	mov	eax, DWORD PTR [r9+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 332  :                 return MEM_read32(memPtr)<<8;

	shl	eax, 8

; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	cmp	edx, eax
	sete	cl
	xor	edx, edx
	cmp	r10d, r11d
	mov	eax, edx
	setae	al
	test	ecx, eax
	je	SHORT $LN1903@ZSTD_initS

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rdx, QWORD PTR [r9+3]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rsi+3]
	call	ZSTD_count
	mov	r9d, DWORD PTR lastR$1$[rbp-256]

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r11d, DWORD PTR windowLow$1$[rsp]

; 576  :                     repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;

	lea	r8d, DWORD PTR [rax+3]
$LN1935@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	xor	edx, edx
$LN875@ZSTD_initS:
	mov	eax, r8d
	cmp	rax, r13
	jbe	SHORT $LN1913@ZSTD_initS

; 597  :                 DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
; 598  :                             repCode, ll0, repOffset, repLen);
; 599  :                 bestLength = repLen;
; 600  :                 matches[mnum].off = repCode - ll0;

	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	mov	r13d, eax
	mov	rdx, QWORD PTR matches$1$[rbp-256]

; 601  :                 matches[mnum].len = (U32)repLen;
; 602  :                 mnum++;
; 603  :                 if ( (repLen > sufficient_len)
; 604  :                    | (ip+repLen == iLimit) ) {  /* best possible */

	add	rax, rsi
	lea	rdx, QWORD PTR [rdx+r10*8]
	inc	r10d
	mov	ecx, r15d
	mov	DWORD PTR [rdx+4], r8d
	sub	ecx, DWORD PTR ll0$1$[rsp]
	mov	DWORD PTR [rdx], ecx
	xor	edx, edx
	cmp	rax, QWORD PTR iend$1$[rsp]
	mov	ecx, edx
	mov	eax, edx
	mov	DWORD PTR nbMatches$1$[rsp], r10d
	sete	cl
	cmp	r8d, DWORD PTR sufficient_len$1$[rsp]
	seta	al
	or	ecx, eax
	jne	$LN865@ZSTD_initS

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	jmp	SHORT $LN866@ZSTD_initS
$LN1903@ZSTD_initS:

; 572  :                 /* We must validate the repcode offset because when we're using a dictionary the
; 573  :                  * valid offset range shrinks when the dictionary goes out of bounds.
; 574  :                  */
; 575  :                 if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {

	mov	r9d, DWORD PTR lastR$1$[rbp-256]
	jmp	SHORT $LN875@ZSTD_initS
$LN1913@ZSTD_initS:

; 577  :                 }
; 578  :             } else {  /* repIndex < dictLimit || repIndex >= current */
; 579  :                 const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
; 580  :                                              dmsBase + repIndex - dmsIndexDelta :
; 581  :                                              dictBase + repIndex;
; 582  :                 assert(current >= windowLow);
; 583  :                 if ( dictMode == ZSTD_extDict
; 584  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - windowLow)  /* equivalent to `current > repIndex >= windowLow` */
; 585  :                      & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
; 586  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 587  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
; 588  :                 }
; 589  :                 if (dictMode == ZSTD_dictMatchState
; 590  :                   && ( ((repOffset-1) /*intentional overflow*/ < current - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `current > repIndex >= dmsLowLimit` */
; 591  :                      & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
; 592  :                   && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
; 593  :                     repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
; 594  :             }   }
; 595  :             /* save longer solution */
; 596  :             if (repLen > bestLength) {

	mov	r10d, DWORD PTR nbMatches$1$[rsp]
$LN866@ZSTD_initS:

; 565  :         U32 repCode;
; 566  :         for (repCode = ll0; repCode < lastR; repCode++) {

	inc	r15d
	add	rdi, 4
	cmp	r15d, r9d
	jae	SHORT $LN1846@ZSTD_initS
	mov	edx, DWORD PTR tv11274[rbp-256]
	mov	r8d, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR rep$1$[rsp]
	jmp	$LL868@ZSTD_initS
$LN1846@ZSTD_initS:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	cmp	r13, 3
	jae	$LN1908@ZSTD_initS

; 610  :         U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	lea	rdx, QWORD PTR nextToUpdate3$9[rbp-256]
	mov	r8, rsi
	call	ZSTD_insertAndFindFirstIndexHash3

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r15d, DWORD PTR current$1$[rsp]
	xor	ecx, ecx
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	mov	edx, ecx
	mov	edi, r15d
	sub	edi, eax
	cmp	eax, r8d
	setae	dl
	cmp	edi, 262144				; 00040000H
	setb	cl
	test	edx, ecx
	je	$LN1912@ZSTD_initS

; 613  :             size_t mlen;
; 614  :             if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
; 615  :                 const BYTE* const match = base + matchIndex3;
; 616  :                 mlen = ZSTD_count(ip, match, iLimit);

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rcx, rsi
	mov	edx, eax
	add	rdx, QWORD PTR $T5[rbp-256]
	call	ZSTD_count

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rax, 3
	jb	SHORT $LN1909@ZSTD_initS

; 624  :                 DEBUGLOG(8, "found small match with hlog3, of length %u",
; 625  :                             (U32)mlen);
; 626  :                 bestLength = mlen;
; 627  :                 assert(current > matchIndex3);
; 628  :                 assert(mnum==0);  /* no prior solution */
; 629  :                 matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR matches$1$[rbp-256]
	lea	ecx, DWORD PTR [rdi+2]

; 630  :                 matches[0].len = (U32)mlen;
; 631  :                 mnum = 1;

	mov	r10d, 1
	mov	r13, rax
	mov	DWORD PTR nbMatches$1$[rsp], r10d
	mov	DWORD PTR [rdx], ecx

; 632  :                 if ( (mlen > sufficient_len) |

	lea	rcx, QWORD PTR [rax+rsi]
	mov	DWORD PTR [rdx+4], eax
	xor	edx, edx
	cmp	rcx, r9
	mov	r8d, edx
	mov	ecx, DWORD PTR sufficient_len$1$[rsp]
	sete	r8b
	cmp	rax, rcx
	seta	dl
	or	r8d, edx
	je	SHORT $LN1910@ZSTD_initS

; 633  :                      (ip+mlen == iLimit) ) {  /* best possible length */
; 634  :                     ms->nextToUpdate = current+1;  /* skip insertion */

	lea	eax, DWORD PTR [r15+1]

; 635  :                     return 1;

	mov	DWORD PTR nbMatches$1$[rsp], r10d
	jmp	$LN1945@ZSTD_initS
$LN1908@ZSTD_initS:

; 605  :                     return mnum;
; 606  :     }   }   }   }
; 607  : 
; 608  :     /* HC3 match finder */
; 609  :     if ((mls == 3) /*static*/ && (bestLength < mls)) {

	mov	r15d, DWORD PTR current$1$[rsp]
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	SHORT $LN1946@ZSTD_initS
$LN1909@ZSTD_initS:

; 617  :             } else {
; 618  :                 const BYTE* const match = dictBase + matchIndex3;
; 619  :                 mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
; 620  :             }
; 621  : 
; 622  :             /* save best solution */
; 623  :             if (mlen >= mls /* == 3 > bestLength */) {

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	jmp	SHORT $LN886@ZSTD_initS
$LN1910@ZSTD_initS:

; 632  :                 if ( (mlen > sufficient_len) |

	mov	r8d, DWORD PTR matchLow$1$[rsp]
	xor	edx, edx
	jmp	SHORT $LN886@ZSTD_initS
$LN1912@ZSTD_initS:

; 611  :         if ((matchIndex3 >= matchLow)
; 612  :           & (current - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {

	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	xor	edx, edx
$LN1946@ZSTD_initS:

; 636  :         }   }   }
; 637  :         /* no dictMatchState lookup: dicts don't have a populated HC3 table */
; 638  :     }
; 639  : 
; 640  :     hashTable[h] = current;   /* Update Hash Table */

	mov	r9, QWORD PTR iend$1$[rsp]
$LN886@ZSTD_initS:
	mov	rax, QWORD PTR tv11276[rbp-256]
	mov	DWORD PTR [rax], r15d

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	test	r12d, r12d
	je	$LN1898@ZSTD_initS
$LL869@ZSTD_initS:
	dec	r12d
	mov	DWORD PTR nbCompares$1$[rsp], r12d
	cmp	r14d, r8d
	jb	$LN1898@ZSTD_initS

; 643  :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, DWORD PTR btMask$1$[rsp]

; 644  :         const BYTE* match;
; 645  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
; 646  :         assert(current > matchIndex);
; 647  : 
; 648  :         if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
; 649  :             assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
; 650  :             match = base + matchIndex;
; 651  :             if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 652  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);

	mov	r8, r9
	mov	rcx, QWORD PTR bt$1$[rbp-256]
	and	eax, r14d
	add	eax, eax
	mov	r15d, r14d
	lea	r12, QWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR commonLengthLarger$1$[rbp-256]
	cmp	QWORD PTR commonLengthSmaller$1$[rbp-256], rcx
	mov	rdi, rcx
	cmovb	rdi, QWORD PTR commonLengthSmaller$1$[rbp-256]
	add	r15, QWORD PTR $T5[rbp-256]
	lea	rcx, QWORD PTR [rdi+rsi]
	lea	rdx, QWORD PTR [r15+rdi]
	call	ZSTD_count
	add	rdi, rax

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	cmp	rdi, r13
	jbe	SHORT $LN1911@ZSTD_initS

; 662  :             DEBUGLOG(8, "found match of length %u at distance %u (offCode=%u)",
; 663  :                     (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);
; 664  :             assert(matchEndIdx > matchIndex);
; 665  :             if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	mov	edx, edi
	sub	eax, r14d
	cmp	rdi, rax
	jbe	SHORT $LN893@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [r14+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN893@ZSTD_initS:

; 667  :             bestLength = matchLength;
; 668  :             matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;

	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	mov	r13, rdi
	mov	eax, DWORD PTR current$1$[rsp]
	mov	rcx, QWORD PTR matches$1$[rbp-256]
	sub	eax, r14d

; 669  :             matches[mnum].len = (U32)matchLength;
; 670  :             mnum++;
; 671  :             if ( (matchLength > ZSTD_OPT_NUM)
; 672  :                | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {

	mov	r9, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rcx+r10*8]
	add	eax, 2
	mov	DWORD PTR [rcx+4], edx
	mov	DWORD PTR [rcx], eax
	xor	edx, edx
	inc	r10d
	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, r9
	mov	DWORD PTR nbMatches$1$[rsp], r10d
	mov	ecx, edx
	mov	eax, edx
	sete	cl
	cmp	rdi, 4096				; 00001000H
	seta	al
	or	ecx, eax
	jne	SHORT $LN1898@ZSTD_initS

; 653  :         } else {
; 654  :             match = dictBase + matchIndex;
; 655  :             assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
; 656  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
; 657  :             if (matchIndex+matchLength >= dictLimit)
; 658  :                 match = base + matchIndex;   /* prepare for match[matchLength] read */
; 659  :         }
; 660  : 
; 661  :         if (matchLength > bestLength) {

	jmp	SHORT $LN894@ZSTD_initS
$LN1911@ZSTD_initS:
	mov	r10d, DWORD PTR nbMatches$1$[rsp]
	xor	edx, edx
	mov	r9, QWORD PTR iend$1$[rsp]
$LN894@ZSTD_initS:

; 673  :                 if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
; 674  :                 break; /* drop, to preserve bt consistency (miss a little bit of compression) */
; 675  :             }
; 676  :         }
; 677  : 
; 678  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	BYTE PTR [r15+rdi], al
	jae	SHORT $LN896@ZSTD_initS

; 679  :             /* match smaller than current */
; 680  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]

; 681  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	QWORD PTR commonLengthSmaller$1$[rbp-256], rdi
	mov	DWORD PTR [rax], r14d

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11196[rsp]
	jbe	SHORT $LN1694@ZSTD_initS

; 683  :             smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
; 684  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */

	mov	r14d, DWORD PTR [r12+4]
	lea	rax, QWORD PTR [r12+4]
	mov	QWORD PTR smallerPtr$1$[rbp-256], rax

; 685  :         } else {

	jmp	SHORT $LN897@ZSTD_initS
$LN896@ZSTD_initS:

; 686  :             *largerPtr = matchIndex;

	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 687  :             commonLengthLarger = matchLength;

	mov	QWORD PTR commonLengthLarger$1$[rbp-256], rdi
	mov	DWORD PTR [rcx], r14d

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	r14d, DWORD PTR tv11196[rsp]
	jbe	SHORT $LN1695@ZSTD_initS

; 689  :             largerPtr = nextPtr;
; 690  :             matchIndex = nextPtr[0];

	mov	r14d, DWORD PTR [r12]
	mov	QWORD PTR largerPtr$1$[rbp-256], r12
$LN897@ZSTD_initS:

; 641  : 
; 642  :     while (nbCompares-- && (matchIndex >= matchLow)) {

	mov	r12d, DWORD PTR nbCompares$1$[rsp]
	test	r12d, r12d
	je	SHORT $LN1898@ZSTD_initS
	mov	r8d, DWORD PTR matchLow$1$[rsp]
	jmp	$LL869@ZSTD_initS
$LN1694@ZSTD_initS:

; 682  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$4[rsp]
	jmp	SHORT $LN1719@ZSTD_initS
$LN1695@ZSTD_initS:

; 688  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rax, QWORD PTR dummy32$4[rsp]
	mov	QWORD PTR largerPtr$1$[rbp-256], rax
$LN1898@ZSTD_initS:

; 691  :     }   }
; 692  : 
; 693  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR smallerPtr$1$[rbp-256]
$LN1719@ZSTD_initS:
	mov	rcx, QWORD PTR largerPtr$1$[rbp-256]

; 738  :     return mnum;

	mov	DWORD PTR nbMatches$1$[rsp], r10d
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rax], edx
	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
$LN1944@ZSTD_initS:

; 950  :                 if (!nbMatches) {

	add	eax, -8					; fffffff8H
$LN1945@ZSTD_initS:
	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	mov	DWORD PTR [rcx+36], eax
$LN865@ZSTD_initS:
	mov	r8d, DWORD PTR nbMatches$1$[rsp]
	test	r8d, r8d
	je	$LN1906@ZSTD_initS

; 951  :                     DEBUGLOG(7, "rPos:%u : no match found", cur);
; 952  :                     continue;
; 953  :                 }
; 954  : 
; 955  :                 {   U32 const maxML = matches[nbMatches-1].len;

	mov	r15, QWORD PTR matches$1$[rbp-256]
	lea	eax, DWORD PTR [r8-1]

; 956  :                     DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
; 957  :                                 inr-istart, cur, nbMatches, maxML);
; 958  : 
; 959  :                     if ( (maxML > sufficient_len)
; 960  :                       || (cur + maxML >= ZSTD_OPT_NUM) ) {

	mov	r9d, DWORD PTR cur$1$[rsp]
	mov	edx, eax
	mov	ecx, DWORD PTR [r15+rax*8+4]
	cmp	ecx, DWORD PTR sufficient_len$1$[rbp-256]
	ja	$LN1697@ZSTD_initS
	lea	eax, DWORD PTR [rcx+r9]
	cmp	eax, 4096				; 00001000H
	jae	$LN1697@ZSTD_initS

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	xor	r10d, r10d
	mov	ecx, r10d
	mov	DWORD PTR matchNb$1$[rsp], ecx
	test	r8d, r8d
	je	$LN1906@ZSTD_initS

; 666  :                 matchEndIdx = matchIndex + (U32)matchLength;

	mov	rdx, r15
	mov	QWORD PTR tv11206[rbp-256], rdx
	npad	1
$LL23@ZSTD_initS:

; 972  :                     U32 const offset = matches[matchNb].off;

	mov	eax, DWORD PTR [rdx]

; 973  :                     U32 const lastML = matches[matchNb].len;

	mov	edx, DWORD PTR [rdx+4]
	mov	DWORD PTR offset$1$[rsp], eax

; 974  :                     U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;

	test	ecx, ecx
	je	SHORT $LN63@ZSTD_initS
	lea	eax, DWORD PTR [rcx-1]
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r13d, DWORD PTR [r15+rax*8+4]
	mov	eax, DWORD PTR offset$1$[rsp]
	inc	r13d
	jmp	SHORT $LN64@ZSTD_initS
$LN63@ZSTD_initS:
	mov	r13d, DWORD PTR minMatch$1$[rbp-256]
$LN64@ZSTD_initS:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	cmp	edx, r13d
	jb	$LN1907@ZSTD_initS
	inc	eax
	lea	esi, DWORD PTR [rdx+r9]
	mov	r12d, r9d
	mov	DWORD PTR tv11268[rsp], eax
	neg	r12d
	npad	1
$LL26@ZSTD_initS:

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	lea	r15d, DWORD PTR [r12+rsi]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	r14d, r10d
	mov	DWORD PTR r$6[rbp-256], r10d
	cmovne	r14d, eax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 267  :     if (optPtr->priceType == zop_predef)  /* fixed scheme, do not use statistics */

	cmp	DWORD PTR [rcx+152], 1
	jne	SHORT $LN1548@ZSTD_initS

; 268  :         return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);

	lea	ecx, DWORD PTR [r15-3]
	call	ZSTD_fracWeight
	lea	ecx, DWORD PTR [r14+16]
	shl	ecx, 8
	add	eax, ecx
	jmp	SHORT $LN1547@ZSTD_initS
$LN1548@ZSTD_initS:

; 269  : 
; 270  :     /* dynamic statistics */
; 271  :     price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));

	mov	rax, QWORD PTR [rcx+96]
	mov	ecx, DWORD PTR [rax+r14*4]
	call	ZSTD_fracWeight
	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	shl	r14d, 8
	add	r14d, DWORD PTR [rcx+148]

; 272  :     if ((optLevel<2) /*static*/ && offCode >= 20)
; 273  :         price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
; 274  : 
; 275  :     /* match Length */
; 276  :     {   U32 const mlCode = ZSTD_MLcode(mlBase);

	lea	ecx, DWORD PTR [r15-3]
	sub	r14d, eax
	call	ZSTD_MLcode

; 277  :         price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	mov	eax, eax
	lea	rdi, QWORD PTR [rax*4]
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax+rdi]
	call	ZSTD_fracWeight
	mov	r8, QWORD PTR ms$GSCopy$1$[rsp]
	lea	rcx, OFFSET FLAT:ML_bits
	mov	ecx, DWORD PTR [rdi+rcx]
	shl	ecx, 8
	add	ecx, DWORD PTR [r8+144]
	sub	ecx, eax

; 278  :     }
; 279  : 
; 280  :     price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */

	lea	eax, DWORD PTR [rcx+51]
	add	eax, r14d
$LN1547@ZSTD_initS:

; 982  :                         int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);

	mov	edx, DWORD PTR basePrice$1$[rbp-256]

; 983  : 
; 984  :                         if ((pos > last_pos) || (price < opt[pos].price)) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
	add	edx, eax
	cmp	esi, ebx
	ja	SHORT $LL27@ZSTD_initS
	mov	eax, esi
	imul	rcx, rax, 28
	cmp	edx, DWORD PTR [rcx+rdi]
	jge	SHORT $LN24@ZSTD_initS

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	jmp	SHORT $LN28@ZSTD_initS
	npad	13
$LL27@ZSTD_initS:

; 985  :                             DEBUGLOG(7, "rPos:%u (ml=%2u) => new better price (%.2f<%.2f)",
; 986  :                                         pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));
; 987  :                             while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */

	inc	ebx
	mov	eax, ebx
	imul	rcx, rax, 28
	mov	DWORD PTR [rcx+rdi], 1073741824		; 40000000H
	cmp	ebx, esi
	jb	SHORT $LL27@ZSTD_initS
	mov	DWORD PTR seqPos$1$[rbp-256], ebx
$LN28@ZSTD_initS:

; 988  :                             opt[pos].mlen = mlen;

	mov	eax, esi
	imul	rcx, rax, 28

; 989  :                             opt[pos].off = offset;

	mov	eax, DWORD PTR offset$1$[rsp]
	mov	DWORD PTR [rcx+rdi+4], eax

; 990  :                             opt[pos].litlen = litlen;

	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR [rcx+rdi+12], eax
	mov	DWORD PTR [rcx+rdi+8], r15d

; 991  :                             opt[pos].price = price;

	mov	DWORD PTR [rcx+rdi], edx
$LN24@ZSTD_initS:

; 975  :                     U32 mlen;
; 976  : 
; 977  :                     DEBUGLOG(7, "testing match %u => offCode=%4u, mlen=%2u, llen=%2u",
; 978  :                                 matchNb, matches[matchNb].off, lastML, litlen);
; 979  : 
; 980  :                     for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */

	dec	esi
	mov	r10d, 0
	lea	eax, DWORD PTR [r12+rsi]
	cmp	eax, r13d
	mov	eax, DWORD PTR tv11268[rsp]
	jae	$LL26@ZSTD_initS
	mov	ecx, DWORD PTR matchNb$1$[rsp]
	mov	r8d, DWORD PTR nbMatches$1$[rsp]
	mov	r15, QWORD PTR matches$1$[rbp-256]
	mov	r9d, DWORD PTR cur$1$[rsp]
	jmp	SHORT $LN21@ZSTD_initS
$LN1907@ZSTD_initS:
	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN21@ZSTD_initS:

; 968  :                 }   }
; 969  : 
; 970  :                 /* set prices using matches found at position == cur */
; 971  :                 for (matchNb = 0; matchNb < nbMatches; matchNb++) {

	mov	rdx, QWORD PTR tv11206[rbp-256]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR matchNb$1$[rsp], ecx
	mov	QWORD PTR tv11206[rbp-256], rdx
	cmp	ecx, r8d
	jb	$LL23@ZSTD_initS

; 754  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	jmp	SHORT $LN18@ZSTD_initS
$LN1906@ZSTD_initS:

; 891  :         for (cur = 1; cur <= last_pos; cur++) {

	mov	rdi, QWORD PTR opt$1$[rbp-256]
$LN18@ZSTD_initS:
	mov	eax, DWORD PTR cur$1$[rsp]
	inc	eax
	mov	DWORD PTR cur$1$[rsp], eax
	cmp	eax, ebx
	jbe	$LL20@ZSTD_initS
$LN1848@ZSTD_initS:

; 992  :                         } else {
; 993  :                             DEBUGLOG(7, "rPos:%u (ml=%2u) => new price is worse (%.2f>=%.2f)",
; 994  :                                         pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));
; 995  :                             if (optLevel==0) break;  /* early update abort; gets ~+10% speed for about -0.01 ratio loss */
; 996  :                         }
; 997  :             }   }   }
; 998  :         }  /* for (cur = 1; cur <= last_pos; cur++) */
; 999  : 
; 1000 :         lastSequence = opt[last_pos];

	mov	eax, ebx
	imul	rdx, rax, 28
	movups	xmm2, XMMWORD PTR [rdx+rdi]
	mov	esi, DWORD PTR [rdx+rdi+24]
	movsd	xmm0, QWORD PTR [rdx+rdi+16]
	movsd	QWORD PTR lastSequence$4$[rbp-256], xmm0

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	movups	xmm1, xmm2

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm2
	psrldq	xmm1, 8
	psrldq	xmm0, 8
	movq	rcx, xmm0
	movd	eax, xmm1
	shr	rcx, 32					; 00000020H

; 1000 :         lastSequence = opt[last_pos];

	movups	XMMWORD PTR lastSequence$10[rbp-256], xmm2

; 775  :     return sol.litlen + sol.mlen;

	add	ecx, eax

; 1000 :         lastSequence = opt[last_pos];

	mov	DWORD PTR lastSequence$5$[rbp-256], esi

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	cmp	ebx, ecx
	jbe	SHORT $LN65@ZSTD_initS
	movdqa	xmm0, xmm2
	movups	xmm1, xmm2
	psrldq	xmm0, 8
	movq	rax, xmm0
	psrldq	xmm1, 8
	shr	rax, 32					; 00000020H
	sub	ebx, eax
	movd	eax, xmm1
	sub	ebx, eax
	xor	r12d, r12d
	jmp	SHORT $_shortestPath$1950
$LN1697@ZSTD_initS:

; 961  :                         lastSequence.mlen = maxML;
; 962  :                         lastSequence.off = matches[nbMatches-1].off;

	mov	eax, DWORD PTR [r15+rdx*8]

; 963  :                         lastSequence.litlen = litlen;
; 964  :                         cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */

	xor	r12d, r12d
	mov	rdi, QWORD PTR opt$1$[rbp-256]
	mov	DWORD PTR lastSequence$10[rbp-252], eax
	mov	eax, DWORD PTR litlen$1$[rbp-256]
	mov	DWORD PTR lastSequence$10[rbp-244], eax
	mov	eax, r9d
	imul	rax, rax, 28
	mov	DWORD PTR lastSequence$10[rbp-248], ecx
	cmp	DWORD PTR [rax+rdi+8], r12d
	jne	SHORT $LN61@ZSTD_initS
	mov	eax, DWORD PTR [rax+rdi+12]
	jmp	SHORT $LN62@ZSTD_initS
$LN61@ZSTD_initS:
	mov	eax, r12d
$LN62@ZSTD_initS:

; 965  :                         last_pos = cur + ZSTD_totalLen(lastSequence);
; 966  :                         if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
; 967  :                         goto _shortestPath;

	movups	xmm2, XMMWORD PTR lastSequence$10[rbp-256]
	mov	esi, DWORD PTR lastSequence$5$[rbp-256]
	sub	r9d, eax
	cmp	r9d, 4096				; 00001000H
	mov	ebx, r12d
	cmovbe	ebx, r9d
	jmp	SHORT $_shortestPath$1950
$LN65@ZSTD_initS:

; 1001 :         cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */

	xor	r12d, r12d
$LN1943@ZSTD_initS:

; 1002 :         assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
; 1003 : 
; 1004 : _shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
; 1005 :         assert(opt[0].mlen == 0);
; 1006 : 
; 1007 :         /* Set the next chunk's repcodes based on the repcodes of the beginning
; 1008 :          * of the last match, and the last sequence. This avoids us having to
; 1009 :          * update them while traversing the sequences.
; 1010 :          */
; 1011 :         if (lastSequence.mlen != 0) {

	mov	ebx, r12d
$_shortestPath$1950:
	mov	eax, ebx
	lea	rdx, QWORD PTR [rdi+16]
	imul	rcx, rax, 28
	add	rdx, rcx
	cmp	DWORD PTR lastSequence$10[rbp-248], 0
	je	SHORT $LN51@ZSTD_initS

; 1012 :             repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);

	movdqa	xmm0, xmm2
	lea	rcx, QWORD PTR $T12[rbp-256]
	psrldq	xmm0, 8
	mov	r9d, r12d
	movq	rax, xmm0
	movq	r8, xmm2
	shr	rax, 32					; 00000020H
	test	eax, eax
	sete	r9b
	shr	r8, 32					; 00000020H
	call	ZSTD_updateRep

; 1013 :             memcpy(rep, &reps, sizeof(reps));

	mov	edx, DWORD PTR [rax+8]
	movsd	xmm0, QWORD PTR [rax]
	mov	DWORD PTR tmpRep$2$[rbp-256], edx
	mov	DWORD PTR tmpRep$[rbp-248], edx

; 1014 :         } else {

	jmp	SHORT $LN1948@ZSTD_initS
$LN51@ZSTD_initS:

; 1015 :             memcpy(rep, opt[cur].rep, sizeof(repcodes_t));

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	mov	DWORD PTR tmpRep$2$[rbp-256], eax
	mov	DWORD PTR tmpRep$[rbp-248], eax
$LN1948@ZSTD_initS:

; 1016 :         }
; 1017 : 
; 1018 :         {   U32 const storeEnd = cur + 1;
; 1019 :             U32 storeStart = storeEnd;
; 1020 :             U32 seqPos = cur;
; 1021 : 
; 1022 :             DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
; 1023 :                         last_pos, cur); (void)last_pos;
; 1024 :             assert(storeEnd < ZSTD_OPT_NUM);
; 1025 :             DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
; 1026 :                         storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
; 1027 :             opt[storeEnd] = lastSequence;

	mov	r9, QWORD PTR opt$1$[rbp-256]
	lea	r13d, DWORD PTR [rbx+1]
	movsd	QWORD PTR tmpRep$[rbp-256], xmm0
	mov	edi, r13d
	movups	xmm0, XMMWORD PTR lastSequence$10[rbp-256]
	mov	eax, r13d
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm0, QWORD PTR lastSequence$4$[rbp-256]
	movsd	QWORD PTR [rcx+r9+16], xmm0
	mov	DWORD PTR [rcx+r9+24], esi

; 1028 :             while (seqPos > 0) {

	test	ebx, ebx
	je	SHORT $LN30@ZSTD_initS
	npad	3
$LL29@ZSTD_initS:

; 1029 :                 U32 const backDist = ZSTD_totalLen(opt[seqPos]);

	mov	eax, ebx

; 1030 :                 storeStart--;

	dec	edi
	imul	r8, rax, 28
	add	r8, r9
	movups	xmm1, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	movdqa	xmm0, xmm1
	psrldq	xmm1, 8
	movd	eax, xmm1
	psrldq	xmm0, 8
	movq	rdx, xmm0

; 1033 :                 opt[storeStart] = opt[seqPos];

	movups	xmm0, XMMWORD PTR [r8]

; 775  :     return sol.litlen + sol.mlen;

	shr	rdx, 32					; 00000020H
	add	edx, eax

; 1033 :                 opt[storeStart] = opt[seqPos];

	mov	eax, edi
	imul	rcx, rax, 28
	movups	XMMWORD PTR [rcx+r9], xmm0
	movsd	xmm1, QWORD PTR [r8+16]
	movsd	QWORD PTR [rcx+r9+16], xmm1
	mov	eax, DWORD PTR [r8+24]
	mov	DWORD PTR [rcx+r9+24], eax
	mov	eax, ebx
	sub	ebx, edx
	cmp	eax, edx
	cmovbe	ebx, r12d
	test	ebx, ebx
	jne	SHORT $LL29@ZSTD_initS
$LN30@ZSTD_initS:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	cmp	edi, r13d
	ja	$LN1931@ZSTD_initS
	mov	r11, QWORD PTR anchor$1$[rbp-256]
	npad	4
$LL33@ZSTD_initS:

; 1041 :                     U32 const llen = opt[storePos].litlen;

	mov	eax, edi
	mov	r12, r11
	imul	rcx, rax, 28
	mov	edx, DWORD PTR [rcx+r9+12]

; 1042 :                     U32 const mlen = opt[storePos].mlen;

	mov	esi, DWORD PTR [rcx+r9+8]

; 1043 :                     U32 const offCode = opt[storePos].off;
; 1044 :                     U32 const advance = llen + mlen;

	mov	ebx, edx
	mov	r14d, DWORD PTR [rcx+r9+4]
	lea	r15d, DWORD PTR [rsi+rdx]

; 1045 :                     DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
; 1046 :                                 anchor - istart, (unsigned)llen, (unsigned)mlen);
; 1047 : 
; 1048 :                     if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */

	test	esi, esi
	je	$LN31@ZSTD_initS

; 1049 :                         assert(storePos == storeEnd);   /* must be last sequence */
; 1050 :                         ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
; 1051 :                         continue;   /* will finish */
; 1052 :                     }
; 1053 : 
; 1054 :                     assert(anchor + llen <= iend);
; 1055 :                     ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);

	mov	rcx, QWORD PTR ms$GSCopy$1$[rsp]
	mov	r9d, r14d
	add	rcx, 72					; 00000048H
	mov	DWORD PTR [rsp+32], esi
	mov	r8, r11
	call	ZSTD_updateStats
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR anchor$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1056 :                     ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);

	add	esi, -3					; fffffffdH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r10, QWORD PTR seqStore$GSCopy$1$[rbp-256]
	add	r9, -32					; ffffffffffffffe0H
	lea	r8, QWORD PTR [rbx+r11]
	mov	rcx, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1584@ZSTD_initS
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r11]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN1585@ZSTD_initS

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r11+16]
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rax-16]
	add	rdx, rbx
	npad	1
$LL1598@ZSTD_initS:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL1598@ZSTD_initS
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1585@ZSTD_initS
$LN1584@ZSTD_initS:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r11
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR seqStore$GSCopy$1$[rbp-256]
	mov	r11, QWORD PTR anchor$1$[rbp-256]
$LN1585@ZSTD_initS:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], rbx
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1779@ZSTD_initS

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN1779@ZSTD_initS:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r10+8]
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	esi, 65535				; 0000ffffH
	jbe	SHORT $LN1833@ZSTD_initS

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [r10+8]
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
	mov	DWORD PTR [r10+72], 2
$LN1833@ZSTD_initS:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [r10+8]
	mov	r9, QWORD PTR opt$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	mov	ebx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r10+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1057 :                     anchor += advance;

	add	r11, rbx
	mov	QWORD PTR anchor$1$[rbp-256], r11
$LN31@ZSTD_initS:

; 1034 :                 seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
; 1035 :             }
; 1036 : 
; 1037 :             /* save sequences */
; 1038 :             DEBUGLOG(6, "sending selected sequences into seqStore")
; 1039 :             {   U32 storePos;
; 1040 :                 for (storePos=storeStart; storePos <= storeEnd; storePos++) {

	inc	edi
	lea	r15, QWORD PTR [r12+rbx]
	mov	QWORD PTR ip$1$[rsp], r15
	cmp	edi, r13d
	jbe	$LL33@ZSTD_initS
	jmp	SHORT $LN32@ZSTD_initS
$LN1931@ZSTD_initS:
	mov	r15, QWORD PTR ip$1$[rsp]
$LN32@ZSTD_initS:

; 1058 :                     ip = anchor;
; 1059 :             }   }
; 1060 :             ZSTD_setBasePrices(optStatePtr, optLevel);

	mov	r12, QWORD PTR ms$GSCopy$1$[rsp]
	mov	edx, 2
	lea	rcx, QWORD PTR [r12+72]
	call	ZSTD_setBasePrices
	mov	r13, QWORD PTR ilimit$1$[rbp-256]
	jmp	SHORT $LN1726@ZSTD_initS
$LN1930@ZSTD_initS:

; 835  :             U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);
; 836  :             if (!nbMatches) { ip++; continue; }

	mov	r15, QWORD PTR ip$1$[rsp]
	mov	r12, QWORD PTR ms$GSCopy$1$[rsp]
	mov	r13, QWORD PTR ilimit$1$[rbp-256]
$LN1815@ZSTD_initS:
	inc	r15
	mov	QWORD PTR ip$1$[rsp], r15
$LN1726@ZSTD_initS:

; 827  : 
; 828  :     /* Match Loop */
; 829  :     while (ip < ilimit) {

	mov	r14, QWORD PTR iend$1$[rsp]
	mov	ecx, 0
	mov	rsi, QWORD PTR anchor$1$[rbp-256]
	cmp	r15, r13
	jb	$LL4@ZSTD_initS
	mov	rdi, QWORD PTR seqStore$GSCopy$1$[rbp-256]
$LN5@ZSTD_initS:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2235 :     ssPtr->lit = ssPtr->litStart;

	mov	rax, QWORD PTR [rdi+16]

; 2237 :     ssPtr->longLengthID = 0;

	mov	DWORD PTR [rdi+72], ecx
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1125 :     ms->window.base -= srcSize;

	mov	rcx, QWORD PTR srcSize$GSCopy$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2235 :     ssPtr->lit = ssPtr->litStart;

	mov	QWORD PTR [rdi+24], rax

; 2236 :     ssPtr->sequences = ssPtr->sequencesStart;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rdi+8], rax
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 1126 :     ms->window.dictLimit += (U32)srcSize;

	mov	edx, DWORD PTR [r12+24]
	sub	QWORD PTR [r12+8], rcx
	add	edx, ecx

; 1127 :     ms->window.lowLimit = ms->window.dictLimit;
; 1128 :     ms->nextToUpdate = ms->window.dictLimit;
; 1129 : 
; 1130 :     /* re-inforce weight of collected statistics */
; 1131 :     ZSTD_upscaleStats(&ms->opt);

	lea	rcx, QWORD PTR [r12+72]
	mov	DWORD PTR [r12+24], edx
	mov	DWORD PTR [r12+28], edx
	mov	DWORD PTR [r12+36], edx
	call	ZSTD_upscaleStats

; 1132 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 440				; 000001b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_initStats_ultra ENDP
_TEXT	ENDS
END
