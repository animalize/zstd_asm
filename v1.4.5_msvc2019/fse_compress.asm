; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

BIT_mask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	DD	01ffffH
	DD	03ffffH
	DD	07ffffH
	DD	0fffffH
	DD	01fffffH
	DD	03fffffH
	DD	07fffffH
	DD	0ffffffH
	DD	01ffffffH
	DD	03ffffffH
	DD	07ffffffH
	DD	0fffffffH
	DD	01fffffffH
	DD	03fffffffH
	DD	07fffffffH
?rtbTable@?2??FSE_normalizeCount@@9@9 DD 00H		; `FSE_normalizeCount'::`3'::rtbTable
	DD	07386bH
	DD	07b20dH
	DD	07f29cH
	DD	086470H
	DD	0aae60H
	DD	0b71b0H
	DD	0caa30H
PUBLIC	FSE_compress_usingCTable
PUBLIC	FSE_optimalTableLog_internal
PUBLIC	FSE_NCountWriteBound
PUBLIC	FSE_normalizeCount
PUBLIC	FSE_writeNCount
PUBLIC	FSE_optimalTableLog
PUBLIC	FSE_buildCTable_rle
PUBLIC	FSE_buildCTable_wksp
pdata	SEGMENT
$pdata$FSE_compress_usingCTable DD imagerel $LN7
	DD	imagerel $LN7+74
	DD	imagerel $unwind$FSE_compress_usingCTable
$pdata$FSE_compress_usingCTable_generic DD imagerel FSE_compress_usingCTable_generic
	DD	imagerel FSE_compress_usingCTable_generic+88
	DD	imagerel $unwind$FSE_compress_usingCTable_generic
$pdata$1$FSE_compress_usingCTable_generic DD imagerel FSE_compress_usingCTable_generic+88
	DD	imagerel FSE_compress_usingCTable_generic+1527
	DD	imagerel $chain$1$FSE_compress_usingCTable_generic
$pdata$2$FSE_compress_usingCTable_generic DD imagerel FSE_compress_usingCTable_generic+1527
	DD	imagerel FSE_compress_usingCTable_generic+1587
	DD	imagerel $chain$2$FSE_compress_usingCTable_generic
$pdata$FSE_normalizeM2 DD imagerel FSE_normalizeM2
	DD	imagerel FSE_normalizeM2+531
	DD	imagerel $unwind$FSE_normalizeM2
$pdata$FSE_optimalTableLog_internal DD imagerel $LN17
	DD	imagerel $LN17+122
	DD	imagerel $unwind$FSE_optimalTableLog_internal
$pdata$FSE_writeNCount_generic DD imagerel FSE_writeNCount_generic
	DD	imagerel FSE_writeNCount_generic+591
	DD	imagerel $unwind$FSE_writeNCount_generic
$pdata$FSE_encodeSymbol DD imagerel FSE_encodeSymbol
	DD	imagerel FSE_encodeSymbol+102
	DD	imagerel $unwind$FSE_encodeSymbol
$pdata$FSE_normalizeCount DD imagerel $LN39
	DD	imagerel $LN39+117
	DD	imagerel $unwind$FSE_normalizeCount
$pdata$4$FSE_normalizeCount DD imagerel $LN39+117
	DD	imagerel $LN39+477
	DD	imagerel $chain$4$FSE_normalizeCount
$pdata$6$FSE_normalizeCount DD imagerel $LN39+477
	DD	imagerel $LN39+493
	DD	imagerel $chain$6$FSE_normalizeCount
$pdata$7$FSE_normalizeCount DD imagerel $LN39+493
	DD	imagerel $LN39+509
	DD	imagerel $chain$7$FSE_normalizeCount
$pdata$FSE_writeNCount DD imagerel $LN10
	DD	imagerel $LN10+127
	DD	imagerel $unwind$FSE_writeNCount
$pdata$FSE_buildCTable_wksp DD imagerel $LN57
	DD	imagerel $LN57+144
	DD	imagerel $unwind$FSE_buildCTable_wksp
$pdata$0$FSE_buildCTable_wksp DD imagerel $LN57+144
	DD	imagerel $LN57+510
	DD	imagerel $chain$0$FSE_buildCTable_wksp
$pdata$1$FSE_buildCTable_wksp DD imagerel $LN57+510
	DD	imagerel $LN57+545
	DD	imagerel $chain$1$FSE_buildCTable_wksp
xdata	SEGMENT
$unwind$FSE_compress_usingCTable DD 010401H
	DD	06204H
$unwind$FSE_compress_usingCTable_generic DD 071801H
	DD	0f014a218H
	DD	0d010e012H
	DD	0700cc00eH
	DD	0500bH
$chain$1$FSE_compress_usingCTable_generic DD 041c21H
	DD	0a641cH
	DD	0133408H
	DD	imagerel FSE_compress_usingCTable_generic
	DD	imagerel FSE_compress_usingCTable_generic+88
	DD	imagerel $unwind$FSE_compress_usingCTable_generic
$chain$2$FSE_compress_usingCTable_generic DD 021H
	DD	imagerel FSE_compress_usingCTable_generic
	DD	imagerel FSE_compress_usingCTable_generic+88
	DD	imagerel $unwind$FSE_compress_usingCTable_generic
$unwind$FSE_normalizeM2 DD 0b1c01H
	DD	09641cH
	DD	08541cH
	DD	06341cH
	DD	0e01af01cH
	DD	0c016d018H
	DD	07014H
$unwind$FSE_optimalTableLog_internal DD 040a01H
	DD	03740aH
	DD	023405H
$unwind$FSE_writeNCount_generic DD 0a1e01H
	DD	0a541eH
	DD	08341eH
	DD	0e01cf01eH
	DD	0c018d01aH
	DD	060157016H
$unwind$FSE_encodeSymbol DD 020501H
	DD	013405H
$unwind$FSE_normalizeCount DD 041201H
	DD	0e00eb212H
	DD	0300b500cH
$chain$4$FSE_normalizeCount DD 0a3f21H
	DD	08f43fH
	DD	09d426H
	DD	0ac41fH
	DD	0b7417H
	DD	0136408H
	DD	imagerel $LN39
	DD	imagerel $LN39+117
	DD	imagerel $unwind$FSE_normalizeCount
$chain$6$FSE_normalizeCount DD 0a0021H
	DD	08f400H
	DD	09d400H
	DD	0ac400H
	DD	0b7400H
	DD	0136400H
	DD	imagerel $LN39
	DD	imagerel $LN39+117
	DD	imagerel $unwind$FSE_normalizeCount
$chain$7$FSE_normalizeCount DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+117
	DD	imagerel $unwind$FSE_normalizeCount
$unwind$FSE_writeNCount DD 010401H
	DD	06204H
$unwind$FSE_buildCTable_wksp DD 092519H
	DD	0880113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	050037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0420H
$chain$0$FSE_buildCTable_wksp DD 020821H
	DD	0876408H
	DD	imagerel $LN57
	DD	imagerel $LN57+144
	DD	imagerel $unwind$FSE_buildCTable_wksp
$chain$1$FSE_buildCTable_wksp DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+144
	DD	imagerel $unwind$FSE_buildCTable_wksp
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
cumul$ = 16
__$ArrayPad$ = 1056
ct$ = 1152
normalizedCounter$ = 1160
maxSymbolValue$ = 1168
tableLog$ = 1176
workSpace$ = 1184
wkspSize$ = 1192
FSE_buildCTable_wksp PROC

; 69   : {

$LN57:
	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 1088				; 00000440H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, QWORD PTR workSpace$[rsp]
	mov	r10, rcx

; 70   :     U32 const tableSize = 1 << tableLog;

	mov	ecx, r9d
	mov	r14d, r9d
	mov	r11d, 1
	mov	r15d, r8d

; 71   :     U32 const tableMask = tableSize - 1;
; 72   :     void* const ptr = ct;
; 73   :     U16* const tableU16 = ( (U16*) ptr) + 2;
; 74   :     void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableLog ? tableSize>>1 : 1) ;

	mov	eax, r11d
	mov	ebp, r11d
	shl	ebp, cl
	lea	r12, QWORD PTR [r10+4]
	mov	ecx, ebp
	mov	rdi, rdx
	shr	ecx, 1
	test	r9d, r9d

; 75   :     FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);
; 76   :     U32 const step = FSE_TABLESTEP(tableSize);

	mov	r9d, ebp
	lea	r8d, DWORD PTR [rbp-1]
	cmovne	eax, ecx

; 77   :     U32 cumul[FSE_MAX_SYMBOL_VALUE+2];
; 78   : 
; 79   :     FSE_FUNCTION_TYPE* const tableSymbol = (FSE_FUNCTION_TYPE*)workSpace;
; 80   :     U32 highThreshold = tableSize-1;

	mov	edx, r8d
	shr	r9d, 1
	mov	ecx, ebp
	shr	ecx, 3
	add	ecx, 3
	add	r9d, ecx
	lea	r13, QWORD PTR [r10+rax*4]

; 81   : 
; 82   :     /* CTable header */
; 83   :     if (((size_t)1 << tableLog) * sizeof(FSE_FUNCTION_TYPE) > wkspSize) return ERROR(tableLog_tooLarge);

	mov	ecx, r14d
	mov	eax, r11d
	shl	rax, cl
	cmp	rax, QWORD PTR wkspSize$[rsp]
	jbe	SHORT $LN21@FSE_buildC
	lea	rax, QWORD PTR [r11-45]
	jmp	$LN1@FSE_buildC
$LN21@FSE_buildC:
	mov	QWORD PTR [rsp+1080], rsi

; 84   :     tableU16[-2] = (U16) tableLog;
; 85   :     tableU16[-1] = (U16) maxSymbolValue;
; 86   :     assert(tableLog < 16);   /* required for threshold strategy to work */
; 87   : 
; 88   :     /* For explanations on how to distribute symbol values over the table :
; 89   :      * http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html */
; 90   : 
; 91   :      #ifdef __clang_analyzer__
; 92   :      memset(tableSymbol, 0, sizeof(*tableSymbol) * tableSize);   /* useless initialization, just to keep scan-build happy */
; 93   :      #endif
; 94   : 
; 95   :     /* symbol start positions */
; 96   :     {   U32 u;
; 97   :         cumul[0] = 0;
; 98   :         for (u=1; u <= maxSymbolValue+1; u++) {

	lea	esi, DWORD PTR [r15+1]
	mov	WORD PTR [r12-4], r14w
	mov	WORD PTR [r12-2], r15w
	mov	DWORD PTR cumul$[rsp], 0
	cmp	esi, r11d
	jb	SHORT $LN3@FSE_buildC
	npad	11
$LL4@FSE_buildC:

; 99   :             if (normalizedCounter[u-1]==-1) {  /* Low proba symbol */

	lea	eax, DWORD PTR [r11-1]
	mov	ecx, eax
	lea	r10, QWORD PTR cumul$[rsp]
	movsx	eax, WORD PTR [rdi+rax*2]
	lea	r10, QWORD PTR [r10+rcx*4]
	cmp	ax, -1
	jne	SHORT $LN22@FSE_buildC

; 100  :                 cumul[u] = cumul[u-1] + 1;
; 101  :                 tableSymbol[highThreshold--] = (FSE_FUNCTION_TYPE)(u-1);

	mov	eax, edx
	lea	ecx, DWORD PTR [r11-1]
	dec	edx
	mov	BYTE PTR [rax+rbx], cl
	mov	ecx, DWORD PTR [r10]
	inc	ecx

; 102  :             } else {

	jmp	SHORT $LN2@FSE_buildC
$LN22@FSE_buildC:

; 103  :                 cumul[u] = cumul[u-1] + normalizedCounter[u-1];

	mov	ecx, eax
	add	ecx, DWORD PTR [r10]
$LN2@FSE_buildC:

; 84   :     tableU16[-2] = (U16) tableLog;
; 85   :     tableU16[-1] = (U16) maxSymbolValue;
; 86   :     assert(tableLog < 16);   /* required for threshold strategy to work */
; 87   : 
; 88   :     /* For explanations on how to distribute symbol values over the table :
; 89   :      * http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html */
; 90   : 
; 91   :      #ifdef __clang_analyzer__
; 92   :      memset(tableSymbol, 0, sizeof(*tableSymbol) * tableSize);   /* useless initialization, just to keep scan-build happy */
; 93   :      #endif
; 94   : 
; 95   :     /* symbol start positions */
; 96   :     {   U32 u;
; 97   :         cumul[0] = 0;
; 98   :         for (u=1; u <= maxSymbolValue+1; u++) {

	mov	eax, r11d
	inc	r11d
	mov	DWORD PTR cumul$[rsp+rax*4], ecx
	cmp	r11d, esi
	jbe	SHORT $LL4@FSE_buildC
$LN3@FSE_buildC:

; 104  :         }   }
; 105  :         cumul[maxSymbolValue+1] = tableSize+1;

	lea	eax, DWORD PTR [rbp+1]
	mov	DWORD PTR cumul$[rsp+rsi*4], eax

; 106  :     }
; 107  : 
; 108  :     /* Spread symbols */
; 109  :     {   U32 position = 0;

	xor	eax, eax

; 110  :         U32 symbol;
; 111  :         for (symbol=0; symbol<=maxSymbolValue; symbol++) {

	xor	r11d, r11d
	npad	5
$LL7@FSE_buildC:

; 112  :             int nbOccurrences;
; 113  :             int const freq = normalizedCounter[symbol];

	movsx	r10d, WORD PTR [rdi+r11*2]

; 114  :             for (nbOccurrences=0; nbOccurrences<freq; nbOccurrences++) {

	test	r10d, r10d
	jle	SHORT $LN5@FSE_buildC
	npad	6
$LL10@FSE_buildC:

; 115  :                 tableSymbol[position] = (FSE_FUNCTION_TYPE)symbol;

	mov	BYTE PTR [rax+rbx], r11b

; 116  :                 position = (position + step) & tableMask;

	add	eax, r9d
	and	eax, r8d

; 117  :                 while (position > highThreshold)

	cmp	eax, edx
	jbe	SHORT $LN8@FSE_buildC
	npad	2
$LL11@FSE_buildC:

; 118  :                     position = (position + step) & tableMask;   /* Low proba area */

	add	eax, r9d
	and	eax, r8d
	cmp	eax, edx
	ja	SHORT $LL11@FSE_buildC
$LN8@FSE_buildC:

; 114  :             for (nbOccurrences=0; nbOccurrences<freq; nbOccurrences++) {

	sub	r10, 1
	jne	SHORT $LL10@FSE_buildC
$LN5@FSE_buildC:

; 110  :         U32 symbol;
; 111  :         for (symbol=0; symbol<=maxSymbolValue; symbol++) {

	inc	r11d
	cmp	r11d, r15d
	jbe	SHORT $LL7@FSE_buildC

; 119  :         }   }
; 120  : 
; 121  :         assert(position==0);  /* Must have initialized all positions */
; 122  :     }
; 123  : 
; 124  :     /* Build table */
; 125  :     {   U32 u; for (u=0; u<tableSize; u++) {

	xor	r10d, r10d
	mov	r8d, r10d
	test	ebp, ebp
	je	SHORT $LN14@FSE_buildC
$LL15@FSE_buildC:

; 126  :         FSE_FUNCTION_TYPE s = tableSymbol[u];   /* note : static analyzer may not understand tableSymbol is properly initialized */
; 127  :         tableU16[cumul[s]++] = (U16) (tableSize+u);   /* TableU16 : sorted by symbol order; gives next state value */

	movzx	edx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [r8+rbp]
	inc	r8d
	lea	rbx, QWORD PTR [rbx+1]
	mov	ecx, DWORD PTR cumul$[rsp+rdx*4]
	mov	WORD PTR [r12+rcx*2], ax
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR cumul$[rsp+rdx*4], eax
	cmp	r8d, ebp
	jb	SHORT $LL15@FSE_buildC
$LN14@FSE_buildC:

; 128  :     }   }
; 129  : 
; 130  :     /* Build Symbol Transformation Table */
; 131  :     {   unsigned total = 0;

	mov	r9d, r10d
	lea	rdx, QWORD PTR [r13+8]
	npad	4
$LL18@FSE_buildC:

; 134  :             switch (normalizedCounter[s])

	movsx	r8d, WORD PTR [rdi]
	cmp	r8d, -1
	je	SHORT $LN25@FSE_buildC
	test	r8d, r8d
	je	SHORT $LN24@FSE_buildC
	cmp	r8d, 1
	je	SHORT $LN25@FSE_buildC

; 149  :                     U32 const maxBitsOut = tableLog - BIT_highbit32 (normalizedCounter[s]-1);

	lea	eax, DWORD PTR [r8-1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 149  :                     U32 const maxBitsOut = tableLog - BIT_highbit32 (normalizedCounter[s]-1);

	mov	ecx, r14d
	sub	ecx, eax

; 150  :                     U32 const minStatePlus = normalizedCounter[s] << maxBitsOut;

	shl	r8d, cl

; 151  :                     symbolTT[s].deltaNbBits = (maxBitsOut << 16) - minStatePlus;

	shl	ecx, 16
	sub	ecx, r8d
	mov	DWORD PTR [rdx], ecx

; 152  :                     symbolTT[s].deltaFindState = total - normalizedCounter[s];

	mov	ecx, r9d
	movsx	eax, WORD PTR [rdi]
	sub	ecx, eax
	mov	DWORD PTR [rdx-4], ecx

; 153  :                     total +=  normalizedCounter[s];

	movsx	eax, WORD PTR [rdi]
	add	r9d, eax
	jmp	SHORT $LN16@FSE_buildC
$LN24@FSE_buildC:

; 135  :             {
; 136  :             case  0:
; 137  :                 /* filling nonetheless, for compatibility with FSE_getMaxNbBits() */
; 138  :                 symbolTT[s].deltaNbBits = ((tableLog+1) << 16) - (1<<tableLog);

	lea	eax, DWORD PTR [r14+1]
	shl	eax, 16
	sub	eax, ebp
	mov	DWORD PTR [rdx], eax

; 139  :                 break;

	jmp	SHORT $LN16@FSE_buildC
$LN25@FSE_buildC:

; 140  : 
; 141  :             case -1:
; 142  :             case  1:
; 143  :                 symbolTT[s].deltaNbBits = (tableLog << 16) - (1<<tableLog);

	mov	eax, r14d
	shl	eax, 16
	sub	eax, ebp
	mov	DWORD PTR [rdx], eax

; 144  :                 symbolTT[s].deltaFindState = total - 1;

	lea	eax, DWORD PTR [r9-1]
	mov	DWORD PTR [rdx-4], eax

; 145  :                 total ++;

	inc	r9d
$LN16@FSE_buildC:

; 132  :         unsigned s;
; 133  :         for (s=0; s<=maxSymbolValue; s++) {

	add	rdi, 2
	add	rdx, 8
	sub	rsi, 1
	jne	SHORT $LL18@FSE_buildC

; 154  :     }   }   }   }
; 155  : 
; 156  : #if 0  /* debug : symbol costs */
; 157  :     DEBUGLOG(5, "\n --- table statistics : ");
; 158  :     {   U32 symbol;
; 159  :         for (symbol=0; symbol<=maxSymbolValue; symbol++) {
; 160  :             DEBUGLOG(5, "%3u: w=%3i,   maxBits=%u, fracBits=%.2f",
; 161  :                 symbol, normalizedCounter[symbol],
; 162  :                 FSE_getMaxNbBits(symbolTT, symbol),
; 163  :                 (double)FSE_bitCost(symbolTT, tableLog, symbol, 8) / 256);
; 164  :         }
; 165  :     }
; 166  : #endif
; 167  : 
; 168  :     return 0;

	mov	rsi, QWORD PTR [rsp+1080]
	xor	eax, eax
$LN1@FSE_buildC:

; 169  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1088				; 00000440H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
FSE_buildCTable_wksp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
ct$ = 8
symbolValue$ = 16
FSE_buildCTable_rle PROC

; 533  :     void* ptr = ct;
; 534  :     U16* tableU16 = ( (U16*) ptr) + 2;
; 535  :     void* FSCTptr = (U32*)ptr + 2;
; 536  :     FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) FSCTptr;
; 537  : 
; 538  :     /* header */
; 539  :     tableU16[-2] = (U16) 0;

	xor	r8d, r8d

; 540  :     tableU16[-1] = (U16) symbolValue;

	movzx	eax, dl
	mov	WORD PTR [rcx+2], ax

; 541  : 
; 542  :     /* Build table */
; 543  :     tableU16[0] = 0;
; 544  :     tableU16[1] = 0;   /* just in case */
; 545  : 
; 546  :     /* Build Symbol Transformation Table */
; 547  :     symbolTT[symbolValue].deltaNbBits = 0;

	movzx	eax, dl
	mov	WORD PTR [rcx], r8w
	mov	DWORD PTR [rcx+4], r8d

; 548  :     symbolTT[symbolValue].deltaFindState = 0;

	mov	QWORD PTR [rcx+rax*8+8], r8

; 549  : 
; 550  :     return 0;

	xor	eax, eax

; 551  : }

	ret	0
FSE_buildCTable_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
maxTableLog$ = 8
srcSize$ = 16
maxSymbolValue$ = 24
FSE_optimalTableLog PROC
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	xor	r11d, r11d
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 327  :     U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;

	lea	eax, DWORD PTR [rdx-1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	r9d, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 340  : {

	mov	r10d, ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	eax, r11d
	mov	ecx, r11d
	cmovne	eax, r9d
	lea	r9d, DWORD PTR [rax-2]
	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 318  :     U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;

	inc	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	cmovne	r11d, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	mov	eax, 11

; 319  :     U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;

	add	r11d, 2

; 320  :     U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;

	cmp	ecx, r11d
	cmovb	r11d, ecx

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	test	r10d, r10d
	cmovne	eax, r10d

; 333  :     if (minBits > tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */

	cmp	r9d, eax
	cmovae	r9d, eax
	cmp	r11d, r9d
	cmova	r9d, r11d

; 334  :     if (tableLog < FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;

	cmp	r9d, 5
	jae	SHORT $LN7@FSE_optima

; 341  :     return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 2);

	mov	eax, 5

; 342  : }

	ret	0
$LN7@FSE_optima:

; 335  :     if (tableLog > FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;

	mov	eax, 12
	cmp	r9d, eax
	cmova	r9d, eax

; 341  :     return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 2);

	mov	eax, r9d

; 342  : }

	ret	0
FSE_optimalTableLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
buffer$ = 64
bufferSize$ = 72
normalizedCounter$ = 80
maxSymbolValue$ = 88
tableLog$ = 96
FSE_writeNCount PROC

; 290  : {

$LN10:
	sub	rsp, 56					; 00000038H

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	mov	r10d, DWORD PTR tableLog$[rsp]
	mov	r11, rcx
	cmp	r10d, 12
	jbe	SHORT $LN2@FSE_writeN
	mov	rax, -44				; ffffffffffffffd4H

; 298  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@FSE_writeN:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	r10d, 5
	jae	SHORT $LN3@FSE_writeN
	mov	rax, -1

; 298  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN3@FSE_writeN:

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	lea	eax, DWORD PTR [r9+1]

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	mov	ecx, 512				; 00000200H
	imul	eax, r10d
	shr	eax, 3
	add	eax, 3
	test	r9d, r9d
	cmovne	ecx, eax

; 293  : 
; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	cmp	rdx, rcx
	mov	rcx, r11
	jae	SHORT $LN4@FSE_writeN

; 295  :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);

	mov	DWORD PTR [rsp+40], 0

; 298  : }

	mov	DWORD PTR [rsp+32], r10d
	call	FSE_writeNCount_generic
	add	rsp, 56					; 00000038H
	ret	0
$LN4@FSE_writeN:

; 296  : 
; 297  :     return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 1 /* write in buffer is safe */);

	mov	DWORD PTR [rsp+40], 1

; 298  : }

	mov	DWORD PTR [rsp+32], r10d
	call	FSE_writeNCount_generic
	add	rsp, 56					; 00000038H
	ret	0
FSE_writeNCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
step$1$ = 48
tv596 = 56
normalizedCounter$ = 128
tableLog$ = 136
count$ = 144
total$ = 152
maxSymbolValue$ = 160
FSE_normalizeCount PROC

; 438  : {

$LN39:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	r14
	sub	rsp, 96					; 00000060H

; 439  :     /* Sanity checks */
; 440  :     if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;
; 441  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported size */

	test	edx, edx
	mov	ebx, 11
	mov	rbp, r9
	mov	r9, r8
	cmovne	ebx, edx
	mov	r8, rcx
	cmp	ebx, 5
	jb	$LN32@FSE_normal

; 442  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported size */

	cmp	ebx, 12
	jbe	SHORT $LN7@FSE_normal
	mov	rax, -44				; ffffffffffffffd4H

; 494  : }

	add	rsp, 96					; 00000060H
	pop	r14
	pop	rbp
	pop	rbx
	ret	0
$LN7@FSE_normal:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	r14d, DWORD PTR maxSymbolValue$[rsp]

; 144  :         unsigned long r=0;

	xor	r11d, r11d

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, ebp
	mov	edx, r11d
	mov	ecx, r11d
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 318  :     U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;

	inc	edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r14d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 319  :     U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;

	add	ecx, 2

; 320  :     U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;

	cmp	edx, ecx
	cmovb	ecx, edx

; 443  :     if (tableLog < FSE_minTableLog(total, maxSymbolValue)) return ERROR(GENERIC);   /* Too small tableLog, compression potentially impossible */

	cmp	ebx, ecx
	jb	$LN32@FSE_normal

; 444  : 
; 445  :     {   static U32 const rtbTable[] = {     0, 473195, 504333, 520860, 550000, 700000, 750000, 830000 };
; 446  :         U64 const scale = 62 - tableLog;
; 447  :         U64 const step = ((U64)1<<62) / total;   /* <== here, one division ! */

	xor	edx, edx
	mov	QWORD PTR [rsp+152], rsi
	mov	rax, 4611686018427387904		; 4000000000000000H
	mov	QWORD PTR [rsp+88], rdi
	div	rbp
	mov	QWORD PTR [rsp+80], r12

; 448  :         U64 const vStep = 1ULL<<(scale-20);
; 449  :         int stillToDistribute = 1<<tableLog;

	mov	ecx, ebx
	mov	QWORD PTR [rsp+72], r13
	mov	rdx, rax
	mov	QWORD PTR step$1$[rsp], rax
	mov	r13d, 62				; 0000003eH
	mov	r10d, 1
	mov	QWORD PTR [rsp+64], r15

; 450  :         unsigned s;
; 451  :         unsigned largest=0;
; 452  :         short largestP=0;
; 453  :         U32 lowThreshold = (U32)(total >> tableLog);

	mov	rax, rbp
	shl	r10d, cl
	sub	r13d, ebx
	mov	r12d, r11d
	shr	rax, cl
	movzx	r15d, r11w
	mov	QWORD PTR tv596[rsp], rax
	mov	rsi, r8
	mov	rdi, r9
$LL4@FSE_normal:

; 456  :             if (count[s] == total) return 0;   /* rle special case */

	mov	r8d, DWORD PTR [rdi]
	cmp	r8, rbp
	je	$LN28@FSE_normal

; 457  :             if (count[s] == 0) { normalizedCounter[s]=0; continue; }

	test	r8d, r8d
	jne	SHORT $LN10@FSE_normal
	xor	ecx, ecx
	jmp	SHORT $LN2@FSE_normal
$LN10@FSE_normal:

; 458  :             if (count[s] <= lowThreshold) {

	cmp	r8d, eax
	ja	SHORT $LN11@FSE_normal

; 459  :                 normalizedCounter[s] = -1;
; 460  :                 stillToDistribute--;

	dec	r10d
	mov	ecx, -1

; 461  :             } else {

	jmp	SHORT $LN2@FSE_normal
$LN11@FSE_normal:

; 462  :                 short proba = (short)((count[s]*step) >> scale);

	imul	r8, rdx
	mov	rcx, r13
	mov	r9, r8
	shr	r9, cl

; 463  :                 if (proba<8) {

	cmp	r9w, 8
	jge	SHORT $LN13@FSE_normal

; 464  :                     U64 restToBeat = vStep * rtbTable[proba];
; 465  :                     proba += (count[s]*step) - ((U64)proba<<scale) > restToBeat;

	movsx	rdx, r9w
	mov	rax, rdx
	shl	rax, cl
	lea	rcx, QWORD PTR [r13-20]
	sub	r8, rax
	lea	rax, OFFSET FLAT:?rtbTable@?2??FSE_normalizeCount@@9@9
	mov	edx, DWORD PTR [rax+rdx*4]
	xor	eax, eax
	shl	rdx, cl
	cmp	r8, rdx
	mov	rdx, QWORD PTR step$1$[rsp]
	seta	al
	add	r9w, ax
$LN13@FSE_normal:

; 466  :                 }
; 467  :                 if (proba > largestP) { largestP=proba; largest=s; }
; 468  :                 normalizedCounter[s] = proba;
; 469  :                 stillToDistribute -= proba;

	movsx	eax, r9w
	movzx	ecx, r9w
	sub	r10d, eax
	mov	eax, r11d
	cmp	r9w, r15w
	cmovle	eax, r12d
	cmovle	r9w, r15w
	mov	r12d, eax
	movzx	r15d, r9w
	mov	rax, QWORD PTR tv596[rsp]
$LN2@FSE_normal:

; 454  : 
; 455  :         for (s=0; s<=maxSymbolValue; s++) {

	mov	WORD PTR [rsi], cx
	inc	r11d
	add	rsi, 2
	add	rdi, 4
	cmp	r11d, r14d
	jbe	$LL4@FSE_normal

; 470  :         }   }
; 471  :         if (-stillToDistribute >= (normalizedCounter[largest] >> 1)) {

	mov	r11, QWORD PTR normalizedCounter$[rsp]
	mov	eax, r12d
	movsx	edx, WORD PTR [r11+rax*2]
	lea	r8, QWORD PTR [r11+rax*2]
	mov	ecx, edx
	mov	eax, r10d
	sar	ecx, 1
	neg	eax
	cmp	eax, ecx
	jl	SHORT $LN15@FSE_normal

; 472  :             /* corner case, need another normalization method */
; 473  :             size_t const errorCode = FSE_normalizeM2(normalizedCounter, tableLog, count, total, maxSymbolValue);

	mov	r8, QWORD PTR count$[rsp]
	mov	r9, rbp
	mov	edx, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, r11
	call	FSE_normalizeM2
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 474  :             if (FSE_isError(errorCode)) return errorCode;

	jbe	SHORT $LN16@FSE_normal
$LN37@FSE_normal:
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+152]
	mov	r15, QWORD PTR [rsp+64]

; 494  : }

	add	rsp, 96					; 00000060H
	pop	r14
	pop	rbp
	pop	rbx
	ret	0
$LN15@FSE_normal:

; 475  :         }
; 476  :         else normalizedCounter[largest] += (short)stillToDistribute;

	add	dx, r10w
	mov	WORD PTR [r8], dx
$LN16@FSE_normal:

; 477  :     }
; 478  : 
; 479  : #if 0
; 480  :     {   /* Print Table (debug) */
; 481  :         U32 s;
; 482  :         U32 nTotal = 0;
; 483  :         for (s=0; s<=maxSymbolValue; s++)
; 484  :             RAWLOG(2, "%3i: %4i \n", s, normalizedCounter[s]);
; 485  :         for (s=0; s<=maxSymbolValue; s++)
; 486  :             nTotal += abs(normalizedCounter[s]);
; 487  :         if (nTotal != (1U<<tableLog))
; 488  :             RAWLOG(2, "Warning !!! Total == %u != %u !!!", nTotal, 1U<<tableLog);
; 489  :         getchar();
; 490  :     }
; 491  : #endif
; 492  : 
; 493  :     return tableLog;

	mov	eax, ebx
	jmp	SHORT $LN37@FSE_normal
$LN28@FSE_normal:

; 456  :             if (count[s] == total) return 0;   /* rle special case */

	xor	eax, eax
	jmp	SHORT $LN37@FSE_normal
$LN32@FSE_normal:

; 443  :     if (tableLog < FSE_minTableLog(total, maxSymbolValue)) return ERROR(GENERIC);   /* Too small tableLog, compression potentially impossible */

	mov	rax, -1

; 494  : }

	add	rsp, 96					; 00000060H
	pop	r14
	pop	rbp
	pop	rbx
	ret	0
FSE_normalizeCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write64 PROC

; 269  :     memcpy(memPtr, &value, sizeof(value));

	mov	QWORD PTR [rcx], rdx

; 270  : }

	ret	0
MEM_write64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val64$ = 16
MEM_writeLE64 PROC

; 376  :     if (MEM_isLittleEndian())
; 377  :         MEM_write64(memPtr, val64);

	mov	QWORD PTR [rcx], rdx

; 378  :     else
; 379  :         MEM_write64(memPtr, MEM_swap64(val64));
; 380  : }

	ret	0
MEM_writeLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLEST PROC

; 392  :     if (MEM_32bits())
; 393  :         MEM_writeLE32(memPtr, (U32)val);
; 394  :     else
; 395  :         MEM_writeLE64(memPtr, (U64)val);

	mov	QWORD PTR [rcx], rdx

; 396  : }

	ret	0
MEM_writeLEST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
val$ = 8
BIT_highbit32 PROC

; 141  :     assert(val != 0);
; 142  :     {
; 143  : #   if defined(_MSC_VER)   /* Visual */
; 144  :         unsigned long r=0;

	xor	eax, eax

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 146  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* Use GCC Intrinsic */
; 147  :         return __builtin_clz (val) ^ 31;
; 148  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 149  :         return 31 - __CLZ(val);
; 150  : #   else   /* Software version */
; 151  :         static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,
; 152  :                                                  11, 14, 16, 18, 22, 25,  3, 30,
; 153  :                                                   8, 12, 20, 28, 15, 17, 24,  7,
; 154  :                                                  19, 27, 23,  6, 26,  5,  4, 31 };
; 155  :         U32 v = val;
; 156  :         v |= v >> 1;
; 157  :         v |= v >> 2;
; 158  :         v |= v >> 4;
; 159  :         v |= v >> 8;
; 160  :         v |= v >> 16;
; 161  :         return DeBruijnClz[ (U32) (v * 0x07C4ACDDU) >> 27];
; 162  : #   endif
; 163  :     }
; 164  : }

	ret	0
BIT_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
startPtr$ = 16
dstCapacity$ = 24
BIT_initCStream PROC

; 186  :     bitC->bitContainer = 0;

	xor	eax, eax

; 187  :     bitC->bitPos = 0;
; 188  :     bitC->startPtr = (char*)startPtr;

	mov	QWORD PTR [rcx+16], rdx

; 189  :     bitC->ptr = bitC->startPtr;

	mov	QWORD PTR [rcx+24], rdx

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	add	rdx, -8
	add	rdx, r8
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	r8, 8
	mov	QWORD PTR [rcx+32], rdx
	mov	rcx, -70				; ffffffffffffffbaH
	cmovbe	rax, rcx

; 192  :     return 0;
; 193  : }

	ret	0
BIT_initCStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
value$ = 16
nbBits$ = 24
BIT_addBits PROC

; 200  : {

	mov	r10, rcx

; 201  :     MEM_STATIC_ASSERT(BIT_MASK_SIZE == 32);
; 202  :     assert(nbBits < BIT_MASK_SIZE);
; 203  :     assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, r8d
	mov	ecx, DWORD PTR [rcx+8]
	lea	r9, OFFSET FLAT:BIT_mask
	mov	r9d, DWORD PTR [r9+rax*4]
	and	r9, rdx

; 205  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rcx+r8]
	shl	r9, cl
	or	QWORD PTR [r10], r9
	mov	DWORD PTR [r10+8], eax

; 206  : }

	ret	0
BIT_addBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
value$dead$ = 16
nbBits$dead$ = 24
BIT_addBitsFast PROC

; 214  :     assert((value>>nbBits) == 0);
; 215  :     assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	edx, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	bts	rax, rdx
	mov	QWORD PTR [rcx], rax

; 217  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR [rcx+8], eax

; 218  : }

	ret	0
BIT_addBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_flushBitsFast PROC

; 225  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	edx, DWORD PTR [rcx+8]
	mov	r10, rcx

; 226  :     assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 227  :     assert(bitC->ptr <= bitC->endPtr);
; 228  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rcx+24]
	mov	r8d, edx
	mov	r9, QWORD PTR [rcx]

; 229  :     bitC->ptr += nbBytes;
; 230  :     bitC->bitPos &= 7;

	and	edx, 7
	shr	r8, 3
	mov	DWORD PTR [rcx+8], edx
	mov	QWORD PTR [rax], r9
	add	rax, r8
	mov	QWORD PTR [rcx+24], rax

; 231  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, r8b
	shl	cl, 3
	shr	r9, cl
	mov	QWORD PTR [r10], r9

; 232  : }

	ret	0
BIT_flushBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_flushBits PROC

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	r8d, DWORD PTR [rcx+8]
	mov	r11, rcx

; 242  :     assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 243  :     assert(bitC->ptr <= bitC->endPtr);
; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rcx+24]
	mov	r9d, r8d
	mov	r10, QWORD PTR [rcx]
	shr	r9, 3
	mov	QWORD PTR [rax], r10

; 245  :     bitC->ptr += nbBytes;

	lea	rdx, QWORD PTR [rax+r9]

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	cmp	rdx, QWORD PTR [rcx+32]
	cmova	rdx, QWORD PTR [rcx+32]

; 247  :     bitC->bitPos &= 7;

	and	r8d, 7
	mov	DWORD PTR [rcx+8], r8d
	mov	QWORD PTR [rcx+24], rdx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, r9b
	shl	cl, 3
	shr	r10, cl
	mov	QWORD PTR [r11], r10

; 249  : }

	ret	0
BIT_flushBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_closeCStream PROC

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	eax, DWORD PTR [rcx+8]

; 255  : {

	mov	rdx, rcx

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	r9, QWORD PTR [rcx]
	bts	r9, rax

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	mov	r11, QWORD PTR [rdx+32]

; 217  :     bitC->bitPos += nbBits;

	lea	r8d, DWORD PTR [rax+1]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rdx+24]
	mov	ecx, r8d

; 245  :     bitC->ptr += nbBytes;
; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	and	r8d, 7
	shr	rcx, 3
	mov	DWORD PTR [rdx+8], r8d
	mov	QWORD PTR [rax], r9
	lea	r10, QWORD PTR [rax+rcx]
	shl	cl, 3
	shr	r9, cl
	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx], r9
	cmp	r10, r11
	jbe	SHORT $LN11@BIT_closeC
	mov	QWORD PTR [rdx+24], r11

; 256  :     BIT_addBitsFast(bitC, 1, 1);   /* endMark */
; 257  :     BIT_flushBits(bitC);
; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	xor	eax, eax

; 260  : }

	ret	0
$LN11@BIT_closeC:

; 256  :     BIT_addBitsFast(bitC, 1, 1);   /* endMark */
; 257  :     BIT_flushBits(bitC);
; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	jb	SHORT $LN2@BIT_closeC
	xor	eax, eax

; 260  : }

	ret	0
$LN2@BIT_closeC:

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	xor	eax, eax
	test	r8d, r8d
	setne	al
	sub	rax, QWORD PTR [rdx+16]
	add	rax, r10

; 260  : }

	ret	0
BIT_closeCStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
statePtr$ = 8
ct$ = 16
FSE_initCState PROC

; 490  :     const void* ptr = ct;
; 491  :     const U16* u16ptr = (const U16*) ptr;
; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	r10d, WORD PTR [rdx]
	mov	r9, rcx

; 493  :     statePtr->value = (ptrdiff_t)1<<tableLog;

	mov	r8d, 1
	mov	ecx, r10d
	mov	eax, r8d
	shl	rax, cl
	mov	QWORD PTR [r9], rax

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rax, QWORD PTR [rdx+4]
	mov	QWORD PTR [r9+8], rax

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	r10d, r10d
	je	SHORT $LN3@FSE_initCS
	lea	ecx, DWORD PTR [r10-1]
	shl	r8d, cl
$LN3@FSE_initCS:
	movsxd	rcx, r8d
	inc	rcx

; 496  :     statePtr->stateLog = tableLog;

	mov	DWORD PTR [r9+24], r10d
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	QWORD PTR [r9+16], rcx

; 497  : }

	ret	0
FSE_initCState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
statePtr$ = 8
ct$ = 16
symbol$ = 24
FSE_initCState2 PROC

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	r9d, WORD PTR [rdx]

; 493  :     statePtr->value = (ptrdiff_t)1<<tableLog;
; 494  :     statePtr->stateTable = u16ptr+2;

	lea	r11, QWORD PTR [rdx+4]
	mov	QWORD PTR [rcx+8], r11

; 504  : {

	mov	r10, rcx

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	eax, 1
	test	r9d, r9d
	je	SHORT $LN6@FSE_initCS
	lea	ecx, DWORD PTR [r9-1]
	shl	eax, cl
$LN6@FSE_initCS:
	cdqe
	add	rdx, 4

; 496  :     statePtr->stateLog = tableLog;

	mov	DWORD PTR [r10+24], r9d
	lea	rcx, QWORD PTR [rdx+rax*4]

; 505  :     FSE_initCState(statePtr, ct);
; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	eax, r8d

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR [r10+16], rcx

; 505  :     FSE_initCState(statePtr, ct);
; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+rax*8]

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	mov	rcx, r8
	mov	rdx, r8
	shr	rdx, 32					; 00000020H
	shr	rcx, 32					; 00000020H
	add	ecx, 32768				; 00008000H
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rax, r8d
	sar	rdx, cl
	add	rdx, rax
	movzx	eax, WORD PTR [r11+rdx*2]
	mov	QWORD PTR [r10], rax

; 511  :     }
; 512  : }

	ret	0
FSE_initCState2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
bitC$ = 8
statePtr$ = 16
symbol$ = 24
FSE_encodeSymbol PROC

; 515  : {

	mov	QWORD PTR [rsp+8], rbx

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	mov	r11, QWORD PTR [rdx]
	mov	rbx, rdx
	mov	rax, QWORD PTR [rdx+16]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8d, r8d
	mov	r10, QWORD PTR [rax+r8*8]
	mov	r8, r10
	shr	r8, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r8, r11
	sar	r8, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, r8d
	mov	edx, DWORD PTR [rdx+rax*4]

; 205  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rcx+r8]
	and	rdx, r11
	mov	DWORD PTR [r9+8], eax
	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	QWORD PTR [r9], rdx
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r11, cl
	movsxd	rax, r10d
	add	r11, rax
	mov	rax, QWORD PTR [rbx+8]
	movzx	ecx, WORD PTR [rax+r11*2]
	mov	QWORD PTR [rbx], rcx

; 521  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
FSE_encodeSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
bitC$ = 8
statePtr$ = 16
FSE_flushCState PROC

; 525  :     BIT_addBits(bitC, statePtr->value, statePtr->stateLog);

	mov	r8d, DWORD PTR [rdx+24]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r9, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 524  : {

	mov	r11, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [rcx+8]
	mov	r10d, DWORD PTR [r9+r8*4]
	and	r10, QWORD PTR [rdx]

; 205  :     bitC->bitPos += nbBits;

	lea	r9d, DWORD PTR [rcx+r8]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [r11+24]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	shl	r10, cl
	or	r10, QWORD PTR [r11]

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	edx, r9d
	shr	rdx, 3

; 242  :     assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 243  :     assert(bitC->ptr <= bitC->endPtr);
; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [rax], r10

; 245  :     bitC->ptr += nbBytes;

	lea	rcx, QWORD PTR [rax+rdx]

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	cmp	rcx, QWORD PTR [r11+32]
	cmova	rcx, QWORD PTR [r11+32]

; 247  :     bitC->bitPos &= 7;

	and	r9d, 7
	mov	QWORD PTR [r11+24], rcx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
	shl	cl, 3
	shr	r10, cl
	mov	QWORD PTR [r11], r10
	mov	DWORD PTR [r11+8], r9d
; File E:\dev\pyzstd\lib\common\fse.h

; 527  : }

	ret	0
FSE_flushCState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
maxSymbolValue$ = 8
tableLog$ = 16
FSE_NCountWriteBound PROC

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	lea	eax, DWORD PTR [rcx+1]
	imul	edx, eax

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	mov	eax, 512				; 00000200H
	shr	edx, 3
	add	edx, 3
	test	ecx, ecx
	cmovne	eax, edx

; 190  : }

	ret	0
FSE_NCountWriteBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
header$ = 56
headerBufferSize$ = 64
normalizedCounter$ = 72
maxSymbolValue$ = 80
tableLog$ = 88
writeIsSafe$ = 96
FSE_writeNCount_generic PROC

; 196  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 197  :     BYTE* const ostart = (BYTE*) header;
; 198  :     BYTE* out = ostart;
; 199  :     BYTE* const oend = ostart + headerBufferSize;
; 200  :     int nbBits;
; 201  :     const int tableSize = 1 << tableLog;
; 202  :     int remaining;
; 203  :     int threshold;
; 204  :     U32 bitStream = 0;
; 205  :     int bitCount = 0;
; 206  :     unsigned symbol = 0;
; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */
; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	mov	r12d, DWORD PTR writeIsSafe$[rsp]
	lea	r13, QWORD PTR [rcx+rdx]
	xor	ebx, ebx
	lea	r15d, DWORD PTR [r9+1]
	mov	r11, rcx
	mov	esi, 1
	mov	ecx, DWORD PTR tableLog$[rsp]
	xor	edx, edx
	shl	esi, cl
	mov	r10, r8
	lea	edi, QWORD PTR [rbx+4]
	lea	r8d, DWORD PTR [rcx-5]
	lea	r14d, DWORD PTR [rsi+1]
	lea	ebp, DWORD PTR [rcx+1]
	test	r15d, r15d
	je	$LN3@FSE_writeN
	npad	9
$LL2@FSE_writeN:
	cmp	r14d, 1
	jle	$LN53@FSE_writeN

; 220  :         if (previousIs0) {

	test	edx, edx
	je	$LN15@FSE_writeN

; 221  :             unsigned start = symbol;

	mov	edx, ebx

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	ebx, r15d
	jae	SHORT $LN54@FSE_writeN
	lea	rcx, QWORD PTR [r10+rbx*2]
	npad	3
$LL4@FSE_writeN:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN51@FSE_writeN
	inc	ebx
	add	rcx, 2
	cmp	ebx, r15d
	jb	SHORT $LL4@FSE_writeN
$LN54@FSE_writeN:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN50@FSE_writeN
$LN51@FSE_writeN:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	ebx, r9d
	jb	SHORT $LN27@FSE_writeN
	mov	ecx, edi
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
	npad	5
$LL6@FSE_writeN:

; 225  :                 start+=24;

	add	edx, 24
	add	r9d, 24

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r8d, r10d

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	test	r12d, r12d
	jne	SHORT $LN49@FSE_writeN
	lea	rax, QWORD PTR [r13-2]
	cmp	r11, rax
	ja	$LN52@FSE_writeN
$LN49@FSE_writeN:

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [r11], r8b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 231  :                 out+=2;

	add	r11, 2

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	cmp	ebx, r9d
	jae	SHORT $LL6@FSE_writeN
	mov	r10, QWORD PTR normalizedCounter$[rsp]
$LN27@FSE_writeN:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	ebx, r9d
	jb	SHORT $LN9@FSE_writeN
	npad	12
$LL8@FSE_writeN:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, edi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	edi, 2
	cmp	r9d, ebx
	jbe	SHORT $LL8@FSE_writeN
$LN9@FSE_writeN:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, edi
	mov	eax, ebx
	sub	eax, edx

; 240  :             bitCount += 2;

	add	edi, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	edi, 16
	jle	SHORT $LN15@FSE_writeN

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	test	r12d, r12d
	jne	SHORT $LN16@FSE_writeN
	lea	rax, QWORD PTR [r13-2]
	cmp	r11, rax
	ja	$LN52@FSE_writeN
$LN16@FSE_writeN:

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [r11], r8b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 246  :                 out += 2;

	add	r11, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	edi, 16
$LN15@FSE_writeN:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR [r10+rbx*2]
	inc	ebx

; 251  :             int const max = (2*threshold-1) - remaining;
; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	lea	r10d, DWORD PTR [rsi+rsi]
	cdq
	sub	r10d, r14d
	xor	eax, edx
	sub	eax, edx
	sub	r14d, eax
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	lea	r9d, DWORD PTR [r10-1]
	mov	eax, 1
	cmovl	r10d, eax
	add	r10d, ecx
	mov	ecx, edi
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl

; 259  :             previousIs0  = (count==1);

	xor	edx, edx
	sub	eax, ecx
	add	edi, eax
	cmp	r10d, 1
	sete	dl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r14d, 1
	jl	SHORT $LN50@FSE_writeN

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r14d, esi
	jge	SHORT $LN11@FSE_writeN
$LL10@FSE_writeN:
	dec	ebp
	sar	esi, 1
	cmp	r14d, esi
	jl	SHORT $LL10@FSE_writeN
$LN11@FSE_writeN:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	edi, 16
	jle	SHORT $LN19@FSE_writeN

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	test	r12d, r12d
	jne	SHORT $LN20@FSE_writeN
	lea	rax, QWORD PTR [r13-2]
	cmp	r11, rax
	ja	SHORT $LN52@FSE_writeN
$LN20@FSE_writeN:

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [r11], r8b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 268  :             out += 2;

	add	r11, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	edi, 16
$LN19@FSE_writeN:

; 197  :     BYTE* const ostart = (BYTE*) header;
; 198  :     BYTE* out = ostart;
; 199  :     BYTE* const oend = ostart + headerBufferSize;
; 200  :     int nbBits;
; 201  :     const int tableSize = 1 << tableLog;
; 202  :     int remaining;
; 203  :     int threshold;
; 204  :     U32 bitStream = 0;
; 205  :     int bitCount = 0;
; 206  :     unsigned symbol = 0;
; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */
; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	mov	r10, QWORD PTR normalizedCounter$[rsp]
	cmp	ebx, r15d
	jb	$LL2@FSE_writeN
$LN3@FSE_writeN:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r14d, 1
$LN53@FSE_writeN:
	je	SHORT $LN21@FSE_writeN
$LN50@FSE_writeN:

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rax, -1
	jmp	SHORT $LN1@FSE_writeN
$LN21@FSE_writeN:

; 275  :     assert(symbol <= alphabetSize);
; 276  : 
; 277  :     /* flush remaining bitStream */
; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	test	r12d, r12d
	jne	SHORT $LN22@FSE_writeN
	lea	rax, QWORD PTR [r13-2]
	cmp	r11, rax
	jbe	SHORT $LN22@FSE_writeN
$LN52@FSE_writeN:

; 279  :         return ERROR(dstSize_tooSmall);   /* Buffer overflow */

	mov	rax, -70				; ffffffffffffffbaH
	jmp	SHORT $LN1@FSE_writeN
$LN22@FSE_writeN:

; 280  :     out[0] = (BYTE)bitStream;
; 281  :     out[1] = (BYTE)(bitStream>>8);
; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [rdi+7]
	mov	BYTE PTR [r11], r8b
	cdq
	shr	r8d, 8
	and	edx, 7
	mov	BYTE PTR [r11+1], r8b
	add	eax, edx
	sar	eax, 3
	cdqe

; 283  : 
; 284  :     return (out-ostart);

	sub	rax, QWORD PTR header$[rsp]
	add	rax, r11
$LN1@FSE_writeN:

; 285  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
FSE_writeNCount_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
srcSize$ = 8
maxSymbolValue$ = 16
FSE_minTableLog PROC
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	xor	r9d, r9d

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, ecx
	mov	r8d, r9d
	cmovne	r8d, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 318  :     U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;

	inc	r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, edx
	cmovne	r9d, ecx
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 319  :     U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;

	add	r9d, 2

; 320  :     U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;

	cmp	r8d, r9d
	cmovb	r9d, r8d

; 321  :     assert(srcSize > 1); /* Not supported, RLE should be used instead */
; 322  :     return minBits;

	mov	eax, r9d

; 323  : }

	ret	0
FSE_minTableLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
maxTableLog$ = 8
srcSize$ = 16
maxSymbolValue$ = 24
minus$ = 32
FSE_optimalTableLog_internal PROC

; 326  : {

$LN17:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	xor	ebx, ebx
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 327  :     U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;

	lea	eax, DWORD PTR [rdx-1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	r10d, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 326  : {

	mov	r11d, ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edi, ebx
	mov	ecx, ebx
	cmovne	edi, r10d
	sub	edi, r9d
	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 318  :     U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;

	inc	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	cmovne	ebx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	mov	eax, 11

; 319  :     U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;

	add	ebx, 2

; 320  :     U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;

	cmp	ecx, ebx
	cmovb	ebx, ecx

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	test	r11d, r11d
	cmovne	eax, r11d

; 333  :     if (minBits > tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */

	cmp	edi, eax
	cmovae	edi, eax
	cmp	ebx, edi
	cmova	edi, ebx

; 334  :     if (tableLog < FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;

	cmp	edi, 5
	jae	SHORT $LN5@FSE_optima

; 335  :     if (tableLog > FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;
; 336  :     return tableLog;

	mov	eax, 5

; 337  : }

	mov	rbx, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
$LN5@FSE_optima:
	mov	rbx, QWORD PTR [rsp+16]
	mov	eax, 12
	cmp	edi, eax
	cmova	edi, eax
	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
FSE_optimalTableLog_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
norm$ = 48
tableLog$ = 56
count$ = 64
total$ = 72
maxSymbolValue$ = 80
FSE_normalizeM2 PROC

; 349  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	DWORD PTR [rsp+16], edx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 350  :     short const NOT_YET_ASSIGNED = -2;
; 351  :     U32 s;
; 352  :     U32 distributed = 0;
; 353  :     U32 ToDistribute;
; 354  : 
; 355  :     /* Init */
; 356  :     U32 const lowThreshold = (U32)(total >> tableLog);

	mov	r12d, DWORD PTR maxSymbolValue$[rsp]

; 357  :     U32 lowOne = (U32)((total * 3) >> (tableLog + 1));

	lea	rbp, QWORD PTR [r9+r9*2]
	xor	r10d, r10d
	mov	r11, rcx
	mov	ecx, edx
	mov	r14, r9
	shr	r14, cl
	mov	rbx, r8
	lea	ecx, DWORD PTR [rdx+1]
	mov	rdi, r9
	shr	rbp, cl
	lea	r9d, QWORD PTR [r10+1]
	inc	r12d
	lea	r13d, QWORD PTR [r10-2]
	mov	rdx, r8
	mov	r15d, r12d
	mov	r8d, r12d
	mov	esi, r10d
	lea	r12, QWORD PTR [r10-1]
	mov	rcx, r11
	npad	3
$LL41@FSE_normal:

; 360  :         if (count[s] == 0) {

	mov	eax, DWORD PTR [rdx]
	test	eax, eax
	jne	SHORT $LN42@FSE_normal

; 361  :             norm[s]=0;

	mov	WORD PTR [rcx], r10w

; 362  :             continue;

	jmp	SHORT $LN45@FSE_normal
$LN42@FSE_normal:

; 363  :         }
; 364  :         if (count[s] <= lowThreshold) {

	cmp	eax, r14d
	ja	SHORT $LN43@FSE_normal

; 365  :             norm[s] = -1;
; 366  :             distributed++;

	inc	esi
	mov	WORD PTR [rcx], r12w

; 367  :             total -= count[s];

	sub	rdi, rax

; 368  :             continue;

	jmp	SHORT $LN45@FSE_normal
$LN43@FSE_normal:

; 369  :         }
; 370  :         if (count[s] <= lowOne) {

	cmp	eax, ebp
	ja	SHORT $LN44@FSE_normal

; 371  :             norm[s] = 1;
; 372  :             distributed++;

	inc	esi
	mov	WORD PTR [rcx], r9w

; 373  :             total -= count[s];

	sub	rdi, rax

; 374  :             continue;

	jmp	SHORT $LN45@FSE_normal
$LN44@FSE_normal:

; 375  :         }
; 376  : 
; 377  :         norm[s]=NOT_YET_ASSIGNED;

	mov	WORD PTR [rcx], r13w
$LN45@FSE_normal:

; 358  : 
; 359  :     for (s=0; s<=maxSymbolValue; s++) {

	add	rdx, 4
	add	rcx, 2
	sub	r8, r9
	jne	SHORT $LL41@FSE_normal

; 378  :     }
; 379  :     ToDistribute = (1 << tableLog) - distributed;

	mov	ecx, DWORD PTR tableLog$[rsp]
	mov	r14d, r9d

; 380  : 
; 381  :     if (ToDistribute == 0)

	mov	r13d, DWORD PTR maxSymbolValue$[rsp]
	shl	r14d, cl
	mov	r8d, r14d
	lea	r12d, DWORD PTR [r13+1]
	sub	r8d, esi
	je	$LN70@FSE_normal

; 382  :         return 0;
; 383  : 
; 384  :     if ((total / ToDistribute) > lowOne) {

	mov	ecx, r8d
	xor	edx, edx
	mov	rax, rdi
	div	rcx
	mov	rcx, rax
	mov	eax, ebp
	cmp	rcx, rax
	jbe	SHORT $LN21@FSE_normal

; 385  :         /* risk of rounding to zero */
; 386  :         lowOne = (U32)((total * 3) / (ToDistribute * 2));

	lea	ecx, DWORD PTR [r8+r8]
	xor	edx, edx
	lea	rax, QWORD PTR [rdi+rdi*2]
	div	rcx
	mov	rdx, rbx
	mov	rcx, r11
$LL49@FSE_normal:

; 388  :             if ((norm[s] == NOT_YET_ASSIGNED) && (count[s] <= lowOne)) {

	cmp	WORD PTR [rcx], -2
	jne	SHORT $LN50@FSE_normal
	mov	r8d, DWORD PTR [rdx]
	cmp	r8d, eax
	ja	SHORT $LN50@FSE_normal

; 389  :                 norm[s] = 1;
; 390  :                 distributed++;

	inc	esi
	mov	WORD PTR [rcx], r9w

; 391  :                 total -= count[s];

	sub	rdi, r8
$LN50@FSE_normal:

; 387  :         for (s=0; s<=maxSymbolValue; s++) {

	add	rdx, 4
	add	rcx, 2
	sub	r15, r9
	jne	SHORT $LL49@FSE_normal

; 392  :                 continue;
; 393  :         }   }
; 394  :         ToDistribute = (1 << tableLog) - distributed;

	mov	r8d, r14d
	sub	r8d, esi
$LN21@FSE_normal:

; 395  :     }
; 396  : 
; 397  :     if (distributed == maxSymbolValue+1) {

	cmp	esi, r12d
	jne	SHORT $LN23@FSE_normal

; 398  :         /* all values are pretty poor;
; 399  :            probably incompressible data (should have already been detected);
; 400  :            find max, then give all remaining points to max */
; 401  :         U32 maxV = 0, maxC = 0;

	mov	edx, r10d
	mov	r9d, r10d
	npad	8
$LL53@FSE_normal:

; 402  :         for (s=0; s<=maxSymbolValue; s++)
; 403  :             if (count[s] > maxC) { maxV=s; maxC=count[s]; }

	mov	ecx, DWORD PTR [rbx]
	lea	rbx, QWORD PTR [rbx+4]
	cmp	ecx, edx
	mov	eax, r9d
	cmovbe	eax, r10d
	inc	r9d
	cmp	ecx, edx
	mov	r10d, eax
	cmovbe	ecx, edx
	mov	edx, ecx
	cmp	r9d, r13d
	jbe	SHORT $LL53@FSE_normal

; 404  :         norm[maxV] += (short)ToDistribute;

	add	WORD PTR [r11+rax*2], r8w
$LN70@FSE_normal:

; 429  :     }   }   }
; 430  : 
; 431  :     return 0;
; 432  : }

	xor	eax, eax
$LN1@FSE_normal:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN23@FSE_normal:

; 405  :         return 0;
; 406  :     }
; 407  : 
; 408  :     if (total == 0) {

	test	rdi, rdi
	jne	SHORT $LN25@FSE_normal

; 409  :         /* all of the symbols were low enough for the lowOne or lowThreshold */
; 410  :         for (s=0; ToDistribute > 0; s = (s+1)%(maxSymbolValue+1))

	test	r8d, r8d
	je	SHORT $LN70@FSE_normal
	npad	5
$LL13@FSE_normal:

; 411  :             if (norm[s] > 0) { ToDistribute--; norm[s]++; }

	mov	eax, r10d
	lea	rcx, QWORD PTR [r11+rax*2]
	movzx	eax, WORD PTR [r11+rax*2]
	test	ax, ax
	jle	SHORT $LN11@FSE_normal
	dec	r8d
	inc	ax
	mov	WORD PTR [rcx], ax
$LN11@FSE_normal:

; 409  :         /* all of the symbols were low enough for the lowOne or lowThreshold */
; 410  :         for (s=0; ToDistribute > 0; s = (s+1)%(maxSymbolValue+1))

	lea	eax, DWORD PTR [r10+1]
	xor	edx, edx
	div	r12d
	mov	r10d, edx
	test	r8d, r8d
	jne	SHORT $LL13@FSE_normal

; 428  :                 tmpTotal = end;

	jmp	SHORT $LN70@FSE_normal
$LN25@FSE_normal:

; 412  :         return 0;
; 413  :     }
; 414  : 
; 415  :     {   U64 const vStepLog = 62 - tableLog;

	mov	eax, 62					; 0000003eH

; 416  :         U64 const mid = (1ULL << (vStepLog-1)) - 1;
; 417  :         U64 const rStep = ((((U64)1<<vStepLog) * ToDistribute) + mid) / total;   /* scale on remaining */

	xor	edx, edx
	sub	eax, DWORD PTR tableLog$[rsp]
	mov	esi, eax
	lea	ecx, DWORD PTR [rax+255]
	mov	eax, r8d
	shl	r9, cl
	mov	ecx, esi
	shl	rax, cl
	dec	r9
	add	rax, r9
	div	rdi
	mov	r8, rax
$LL16@FSE_normal:

; 420  :             if (norm[s]==NOT_YET_ASSIGNED) {

	cmp	WORD PTR [r11], -2
	jne	SHORT $LN14@FSE_normal

; 421  :                 U64 const end = tmpTotal + (count[s] * rStep);

	mov	edx, DWORD PTR [rbx]

; 422  :                 U32 const sStart = (U32)(tmpTotal >> vStepLog);
; 423  :                 U32 const sEnd = (U32)(end >> vStepLog);

	mov	rcx, rsi
	imul	rdx, r8
	add	rdx, r9
	shr	r9, cl
	mov	rax, rdx
	shr	rax, cl

; 424  :                 U32 const weight = sEnd - sStart;

	sub	eax, r9d

; 425  :                 if (weight < 1)

	cmp	eax, 1
	jb	SHORT $LN35@FSE_normal

; 427  :                 norm[s] = (short)weight;

	mov	WORD PTR [r11], ax

; 428  :                 tmpTotal = end;

	mov	r9, rdx
$LN14@FSE_normal:

; 418  :         U64 tmpTotal = mid;
; 419  :         for (s=0; s<=maxSymbolValue; s++) {

	inc	r10d
	add	rbx, 4
	add	r11, 2
	cmp	r10d, r13d
	jbe	SHORT $LL16@FSE_normal
	jmp	$LN70@FSE_normal
$LN35@FSE_normal:

; 426  :                     return ERROR(GENERIC);

	mov	rax, -1
	jmp	$LN1@FSE_normal
FSE_normalizeM2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
bitC$$sroa$1475$1$ = 0
tv2423 = 8
tableLog$1$ = 16
CState1$$sroa$1470$3$ = 24
CState1$$sroa$1468$1$ = 32
ip$1$ = 40
bitC$$sroa$1224$3$ = 48
CState2$$sroa$1473$1$ = 56
CState1$$sroa$1466$2$ = 64
bitC$$sroa$1273$1$ = 72
dst$ = 144
dstSize$ = 152
src$ = 160
$T1 = 168
tv2453 = 168
srcSize$ = 168
ct$ = 176
fast$ = 184
FSE_compress_usingCTable_generic PROC

; 557  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 88					; 00000058H
	mov	rdi, QWORD PTR ct$[rsp]
	mov	r12, r9

; 558  :     const BYTE* const istart = (const BYTE*) src;
; 559  :     const BYTE* const iend = istart + srcSize;

	lea	r11, QWORD PTR [r9+r8]
	mov	r15, rcx

; 560  :     const BYTE* ip=iend;
; 561  : 
; 562  :     BIT_CStream_t bitC;
; 563  :     FSE_CState_t CState1, CState2;
; 564  : 
; 565  :     /* init */
; 566  :     if (srcSize <= 2) return 0;

	cmp	r9, 2
	jbe	$LN122@FSE_compre
; File E:\dev\pyzstd\lib\common\bitstream.h

; 186  :     bitC->bitContainer = 0;

	xor	r13d, r13d

; 187  :     bitC->bitPos = 0;
; 188  :     bitC->startPtr = (char*)startPtr;
; 189  :     bitC->ptr = bitC->startPtr;
; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	lea	r14, QWORD PTR [rdx-8]
	add	r14, rcx
	mov	ebp, r13d
	mov	QWORD PTR tv2423[rsp], rbp
	mov	eax, r13d
	mov	QWORD PTR bitC$$sroa$1273$1$[rsp], r14

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	rdx, 8
	jbe	$LN122@FSE_compre
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 572  :     if (srcSize & 1) {

	mov	QWORD PTR [rsp+152], rbx
	lea	r10d, QWORD PTR [r13+1]
	movzx	ebx, WORD PTR [rdi]
	lea	r9, QWORD PTR [rdi+4]
	mov	DWORD PTR tableLog$1$[rsp], ebx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR CState1$$sroa$1466$2$[rsp], r9
	test	r12b, r10b
	je	$LN6@FSE_compre
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	eax, r10d
	test	ebx, ebx
	je	SHORT $LN30@FSE_compre
	lea	ecx, DWORD PTR [rbx-1]
	shl	eax, cl
$LN30@FSE_compre:
	cdqe
	inc	rax
	lea	rcx, QWORD PTR [rdi+rax*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	eax, BYTE PTR [r11-1]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR CState1$$sroa$1468$1$[rsp], rcx

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+rax*8]
	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
	add	rdx, rax
	movzx	esi, WORD PTR [r9+rdx*2]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	ebx, ebx
	je	SHORT $LN35@FSE_compre
	lea	ecx, DWORD PTR [rbx-1]
	shl	r10d, cl
$LN35@FSE_compre:
	movsxd	rax, r10d

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r10, QWORD PTR CState1$$sroa$1468$1$[rsp]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	lea	rdi, QWORD PTR [rdi+rax*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	eax, BYTE PTR [r11-2]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 575  :         FSE_encodeSymbol(&bitC, &CState1, *--ip);

	sub	r11, 3
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR CState2$$sroa$1473$1$[rsp], rdi

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rdi+rax*8]
	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	rcx, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rax, r8d
	add	rdx, rax
	movzx	eax, WORD PTR [r9+rdx*2]
	mov	WORD PTR $T1[rsp], ax

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	eax, BYTE PTR [r11]
	mov	rdx, QWORD PTR [r10+rax*8]
	mov	rbp, rdx
	shr	rbp, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	rbp, rsi
	shr	rbp, 16
	mov	ebp, ebp
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, DWORD PTR [rcx+rbp*4]

; 205  :     bitC->bitPos += nbBits;

	mov	ecx, ebp
	and	rax, rsi
	sar	rsi, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rcx, edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rsi, rcx
	mov	ecx, ebp
	shr	rcx, 3
	movzx	r8d, WORD PTR [r9+rsi*2]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 576  :         FSE_FLUSHBITS(&bitC);

	cmp	DWORD PTR fast$[rsp], r13d
	je	SHORT $LN12@FSE_compre
; File E:\dev\pyzstd\lib\common\bitstream.h

; 229  :     bitC->ptr += nbBytes;

	lea	rsi, QWORD PTR [rcx+r15]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 577  :     } else {

	mov	QWORD PTR [r15], rbx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 231  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 577  :     } else {

	and	ebp, 7
	mov	QWORD PTR bitC$$sroa$1475$1$[rsp], rsi
	mov	QWORD PTR tv2423[rsp], rbp
	jmp	$LN52@FSE_compre
$LN12@FSE_compre:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	lea	rdx, QWORD PTR [rcx+r15]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 577  :     } else {

	mov	QWORD PTR [r15], rbx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	mov	rsi, r14
	shr	rax, cl
	cmp	rdx, r14
	cmovbe	rsi, rdx
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 577  :     } else {

	and	ebp, 7
	mov	QWORD PTR tv2423[rsp], rbp
	mov	QWORD PTR bitC$$sroa$1475$1$[rsp], rsi
	jmp	$LN52@FSE_compre
$LN6@FSE_compre:
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	edx, r10d
	test	ebx, ebx
	je	SHORT $LN51@FSE_compre
	lea	ecx, DWORD PTR [rbx-1]
	shl	edx, cl
$LN51@FSE_compre:
	movsxd	rcx, edx
	inc	rcx
	lea	r9, QWORD PTR [rdi+rcx*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11-1]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR CState2$$sroa$1473$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 579  :         FSE_initCState2(&CState1, ct, *--ip);

	sub	r11, 2
; File E:\dev\pyzstd\lib\common\fse.h

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r9, QWORD PTR [r9+rcx*8]
	mov	r8, r9
	shr	r8, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [r8+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	edx, ecx
	shl	edx, 16
	sub	edx, r8d
	mov	r8d, edx

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r8, cl
	movsxd	rcx, r9d
	add	r8, rcx
	movzx	ecx, WORD PTR [rdi+r8*2+4]
	mov	WORD PTR $T1[rsp], cx

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	ebx, ebx
	je	SHORT $LN56@FSE_compre
	lea	ecx, DWORD PTR [rbx-1]
	shl	r10d, cl
$LN56@FSE_compre:
	movsxd	rcx, r10d

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	rsi, r15

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	inc	rcx

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR bitC$$sroa$1475$1$[rsp], r15

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	lea	r10, QWORD PTR [rdi+rcx*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR CState1$$sroa$1468$1$[rsp], r10

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r9, QWORD PTR [r10+rcx*8]
	mov	r8, r9
	shr	r8, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [r8+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	edx, ecx
	shl	edx, 16
	sub	edx, r8d
	mov	r8d, edx

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r8, cl
	movsxd	rcx, r9d
	lea	r9, QWORD PTR [rdi+4]
	mov	rdi, QWORD PTR CState2$$sroa$1473$1$[rsp]
	add	r8, rcx
	movzx	r8d, WORD PTR [r9+r8*2]
$LN52@FSE_compre:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 583  :     srcSize -= 2;

	movzx	edx, WORD PTR $T1[rsp]
	add	r12b, 254				; 000000feH
	movzx	ebx, r8w

; 584  :     if ((sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 ) && (srcSize & 2)) {  /* test bit 2 */

	mov	r15d, edx
	mov	QWORD PTR CState1$$sroa$1470$3$[rsp], rbx
	mov	QWORD PTR bitC$$sroa$1224$3$[rsp], rdx
	test	r12b, 2
	je	$LN123@FSE_compre
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11-1]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 586  :         FSE_encodeSymbol(&bitC, &CState1, *--ip);

	sub	r11, 2
	mov	QWORD PTR ip$1$[rsp], r11
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rdi+rcx*8]
	mov	rbx, r8
	shr	rbx, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	rbx, rdx
	shr	rbx, 16

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, ebx
	sar	rdx, cl
	movsxd	rcx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r8, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rdx, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 205  :     bitC->bitPos += nbBits;

	lea	edi, DWORD PTR [rbx+rbp]
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	r15d, WORD PTR [r9+rdx*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r11, QWORD PTR [r10+rcx*8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, edi
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r10, r11

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR bitC$$sroa$1224$3$[rsp], r15

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	shr	r10, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r10, QWORD PTR CState1$$sroa$1470$3$[rsp]
	shr	r10, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, r10d
	mov	r9d, DWORD PTR [r8+rdx*4]
	and	r9, QWORD PTR CState1$$sroa$1470$3$[rsp]
	shl	r9, cl
	mov	ecx, ebp
	mov	edx, ebx
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	rbx, QWORD PTR CState1$$sroa$1470$3$[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	r8d, DWORD PTR [r8+rdx*4]
	movzx	edx, WORD PTR $T1[rsp]
	and	r8, rdx
	shl	r8, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, r10d
	sar	rbx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	r9, r8
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rcx, r11d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r8d, DWORD PTR [rdi+r10]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 587  :         FSE_FLUSHBITS(&bitC);

	mov	r11, QWORD PTR ip$1$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rbx, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	rax, r9
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, r8d
	mov	r9, QWORD PTR CState1$$sroa$1466$2$[rsp]
	and	r8d, 7
	shr	rcx, 3
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 587  :         FSE_FLUSHBITS(&bitC);

	mov	r10d, r8d
	mov	QWORD PTR tv2423[rsp], r10
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	ebx, WORD PTR [r9+rbx*2]
	mov	QWORD PTR CState1$$sroa$1470$3$[rsp], rbx
	mov	QWORD PTR [rsi], rax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 587  :         FSE_FLUSHBITS(&bitC);

	cmp	DWORD PTR fast$[rsp], r13d
	je	SHORT $LN14@FSE_compre
; File E:\dev\pyzstd\lib\common\bitstream.h

; 229  :     bitC->ptr += nbBytes;

	add	rsi, rcx

; 231  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
	mov	QWORD PTR bitC$$sroa$1475$1$[rsp], rsi
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 587  :         FSE_FLUSHBITS(&bitC);

	jmp	SHORT $LN119@FSE_compre
$LN14@FSE_compre:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	lea	rdx, QWORD PTR [rsi+rcx]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
	mov	rsi, r14
	cmp	rdx, r14
	cmovbe	rsi, rdx
	mov	QWORD PTR bitC$$sroa$1475$1$[rsp], rsi
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 584  :     if ((sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 ) && (srcSize & 2)) {  /* test bit 2 */

	jmp	SHORT $LN119@FSE_compre
$LN123@FSE_compre:
	mov	r10, QWORD PTR tv2423[rsp]
$LN119@FSE_compre:

; 591  :     while ( ip>istart ) {

	cmp	r11, QWORD PTR src$[rsp]
	jbe	$LN3@FSE_compre
	jmp	SHORT $LN2@FSE_compre
	npad	3
$LL124@FSE_compre:
	mov	r15, QWORD PTR bitC$$sroa$1224$3$[rsp]
	mov	r9, QWORD PTR CState1$$sroa$1466$2$[rsp]
$LN2@FSE_compre:
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11-1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	rdi, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 593  :         FSE_encodeSymbol(&bitC, &CState2, *--ip);

	mov	QWORD PTR tv2453[rsp], rsi
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rsi, QWORD PTR CState2$$sroa$1473$1$[rsp]
	mov	r8, QWORD PTR [rsi+rcx*8]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	rcx, r15
	sar	rcx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, ecx

; 205  :     bitC->bitPos += nbBits;

	lea	r12d, DWORD PTR [r10+rcx]
	mov	r13d, DWORD PTR [rdi+rdx*4]
	and	r13, r15
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r15, cl
	movsxd	rcx, r8d

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR CState1$$sroa$1468$1$[rsp]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	r15, rcx

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11-2]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	r14d, WORD PTR [r9+r15*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [r8+rcx*8]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	rcx, rbx
	sar	rcx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, ecx
	mov	ebp, DWORD PTR [rdi+rdx*4]
	lea	edi, DWORD PTR [r12+rcx]
	and	rbp, rbx

; 205  :     bitC->bitPos += nbBits;

	mov	edx, r14d
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rbx, cl
	movsxd	rcx, r8d
	add	rbx, rcx

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11-3]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 602  :             FSE_encodeSymbol(&bitC, &CState1, *--ip);

	sub	r11, 4
	mov	QWORD PTR ip$1$[rsp], r11
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rsi+rcx*8]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	r15d, WORD PTR [r9+rbx*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r10, r8
	shr	r10, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r10, r14
	shr	r10, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 205  :     bitC->bitPos += nbBits;

	mov	ecx, r10d
	sar	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rcx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r8, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rdx, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	esi, DWORD PTR [rdi+r10]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	ecx, WORD PTR [r9+rdx*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, QWORD PTR CState1$$sroa$1468$1$[rsp]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR bitC$$sroa$1224$3$[rsp], rcx

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	ecx, BYTE PTR [r11]
	mov	rbx, QWORD PTR [rdx+rcx*8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, esi
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r11, rbx
	shr	r11, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r11, r15
	shr	r11, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, r11d
	mov	r9d, DWORD PTR [r8+rdx*4]
	and	r9, r15
	mov	edx, r10d
	shl	r9, cl
	mov	ecx, edi
	mov	r8d, DWORD PTR [r8+rdx*4]
	and	r8, r14
	shl	r8, cl
	mov	ecx, r12d
	shl	rbp, cl
	or	r9, r8
	mov	rcx, QWORD PTR tv2423[rsp]
	or	r9, rbp
	shl	r13, cl

; 205  :     bitC->bitPos += nbBits;

	mov	ecx, r11d
	or	r9, r13
	sar	r15, cl
	or	r9, rax
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rcx, ebx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	rax, r9
	mov	r10, r9
	lea	r9d, DWORD PTR [rsi+r11]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	r15, rcx
	mov	rcx, QWORD PTR CState1$$sroa$1466$2$[rsp]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 605  :         FSE_FLUSHBITS(&bitC);

	mov	r14, QWORD PTR bitC$$sroa$1273$1$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	r8d, r9d
	shr	r8, 3
	movzx	ebx, WORD PTR [rcx+r15*2]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 605  :         FSE_FLUSHBITS(&bitC);

	movzx	ecx, r8b
	shl	cl, 3
	cmp	DWORD PTR fast$[rsp], 0
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR CState1$$sroa$1470$3$[rsp], rbx
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 605  :         FSE_FLUSHBITS(&bitC);

	je	SHORT $LN18@FSE_compre
; File E:\dev\pyzstd\lib\common\bitstream.h

; 229  :     bitC->ptr += nbBytes;

	mov	rsi, QWORD PTR bitC$$sroa$1475$1$[rsp]
	add	rsi, r8

; 231  :     bitC->bitContainer >>= nbBytes*8;

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 605  :         FSE_FLUSHBITS(&bitC);

	jmp	SHORT $LN126@FSE_compre
$LN18@FSE_compre:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rdx, QWORD PTR bitC$$sroa$1475$1$[rsp]

; 245  :     bitC->ptr += nbBytes;
; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;
; 247  :     bitC->bitPos &= 7;

	mov	rsi, r14
	add	rdx, r8

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shr	rax, cl
	cmp	rdx, r14
	cmovbe	rsi, rdx
$LN126@FSE_compre:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 591  :     while ( ip>istart ) {

	mov	rcx, QWORD PTR tv2453[rsp]
	and	r9d, 7
	mov	r11, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR bitC$$sroa$1475$1$[rsp], rsi
	mov	QWORD PTR [rcx], r10
	mov	r10d, r9d
	mov	QWORD PTR tv2423[rsp], r10
	cmp	r11, QWORD PTR src$[rsp]
	ja	$LL124@FSE_compre
	xor	r13d, r13d
$LN3@FSE_compre:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ebx, DWORD PTR tableLog$1$[rsp]
	lea	rdx, OFFSET FLAT:BIT_mask
	mov	r11, QWORD PTR bitC$$sroa$1224$3$[rsp]
	mov	ecx, r10d
	mov	r12, QWORD PTR CState1$$sroa$1470$3$[rsp]

; 247  :     bitC->bitPos &= 7;

	mov	r8, r14

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	r9d, DWORD PTR [rdx+rbx*4]

; 205  :     bitC->bitPos += nbBits;

	lea	edx, DWORD PTR [rbx+r10]
	and	r11, r9
	shl	r11, cl
	or	r11, rax

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, edx
	shr	rcx, 3

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [rsi], r11
	lea	rax, QWORD PTR [rsi+rcx]

; 247  :     bitC->bitPos &= 7;

	mov	rsi, QWORD PTR [rsp+80]
	cmp	rax, r14
	cmovbe	r8, rax

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	r11, cl
	and	edx, 7

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	and	r12, r9
	mov	ecx, edx
	shl	r12, cl
	add	edx, ebx

; 247  :     bitC->bitPos &= 7;

	mov	rbx, QWORD PTR [rsp+152]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	r11, r12

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	mov	ecx, edx
	shr	rcx, 3
	lea	rax, QWORD PTR [r8+rcx]

; 245  :     bitC->ptr += nbBytes;
; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;
; 247  :     bitC->bitPos &= 7;

	mov	r8, r14
	cmp	rax, r14
	cmovbe	r8, rax

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	r11, cl
	and	edx, 7

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	bts	r11, rdx

; 247  :     bitC->bitPos &= 7;

	mov	rax, r14
	mov	QWORD PTR [r8], r11

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	lea	r9d, DWORD PTR [rdx+1]

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r9d
	shr	rcx, 3
	add	rcx, r8

; 245  :     bitC->ptr += nbBytes;
; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;
; 247  :     bitC->bitPos &= 7;

	cmp	rcx, r14
	cmovbe	rax, rcx

; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	cmp	rax, r14
	jae	SHORT $LN111@FSE_compre

; 247  :     bitC->bitPos &= 7;

	test	r9b, 7

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	mov	r13d, 0
	seta	r13b
	sub	r13, QWORD PTR dst$[rsp]
	add	r13, rax
$LN111@FSE_compre:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 610  :     return BIT_closeCStream(&bitC);

	mov	rax, r13

; 611  : }

	add	rsp, 88					; 00000058H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN122@FSE_compre:

; 567  :     { size_t const initError = BIT_initCStream(&bitC, dst, dstSize);
; 568  :       if (FSE_isError(initError)) return 0; /* not enough space available to write a bitstream */ }

	xor	eax, eax

; 611  : }

	add	rsp, 88					; 00000058H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
FSE_compress_usingCTable_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\fse_compress.c
_TEXT	SEGMENT
dst$ = 64
dstSize$ = 72
src$ = 80
srcSize$ = 88
ct$ = 96
FSE_compress_usingCTable PROC

; 616  : {

$LN7:
	sub	rsp, 56					; 00000038H

; 617  :     unsigned const fast = (dstSize >= FSE_BLOCKBOUND(srcSize));

	mov	rax, r9
	shr	rax, 7
	add	rax, 12
	add	rax, r9
	cmp	rdx, rax

; 618  : 
; 619  :     if (fast)

	mov	rax, QWORD PTR ct$[rsp]
	jb	SHORT $LN2@FSE_compre

; 620  :         return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 1);

	mov	DWORD PTR [rsp+40], 1

; 623  : }

	mov	QWORD PTR [rsp+32], rax
	call	FSE_compress_usingCTable_generic
	add	rsp, 56					; 00000038H
	ret	0
$LN2@FSE_compre:

; 621  :     else
; 622  :         return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 0);

	mov	DWORD PTR [rsp+40], 0

; 623  : }

	mov	QWORD PTR [rsp+32], rax
	call	FSE_compress_usingCTable_generic
	add	rsp, 56					; 00000038H
	ret	0
FSE_compress_usingCTable ENDP
_TEXT	ENDS
END
