; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+4
LL_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
BIT_mask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	DD	01ffffH
	DD	03ffffH
	DD	07ffffH
	DD	0fffffH
	DD	01fffffH
	DD	03fffffH
	DD	07fffffH
	DD	0ffffffH
	DD	01ffffffH
	DD	03ffffffH
	DD	07ffffffH
	DD	0fffffffH
	DD	01fffffffH
	DD	03fffffffH
	DD	07fffffffH
ML_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	ORG $+4
kInverseProbabilityLog256 DD 00H
	DD	0800H
	DD	0700H
	DD	066aH
	DD	0600H
	DD	05adH
	DD	056aH
	DD	0531H
	DD	0500H
	DD	04d4H
	DD	04adH
	DD	048aH
	DD	046aH
	DD	044cH
	DD	0431H
	DD	0417H
	DD	0400H
	DD	03e9H
	DD	03d4H
	DD	03c0H
	DD	03adH
	DD	039bH
	DD	038aH
	DD	0379H
	DD	036aH
	DD	035bH
	DD	034cH
	DD	033eH
	DD	0331H
	DD	0324H
	DD	0317H
	DD	030bH
	DD	0300H
	DD	02f4H
	DD	02e9H
	DD	02deH
	DD	02d4H
	DD	02caH
	DD	02c0H
	DD	02b6H
	DD	02adH
	DD	02a4H
	DD	029bH
	DD	0292H
	DD	028aH
	DD	0282H
	DD	0279H
	DD	0272H
	DD	026aH
	DD	0262H
	DD	025bH
	DD	0253H
	DD	024cH
	DD	0245H
	DD	023eH
	DD	0237H
	DD	0231H
	DD	022aH
	DD	0224H
	DD	021eH
	DD	0217H
	DD	0211H
	DD	020bH
	DD	0205H
	DD	0200H
	DD	01faH
	DD	01f4H
	DD	01efH
	DD	01e9H
	DD	01e4H
	DD	01deH
	DD	01d9H
	DD	01d4H
	DD	01cfH
	DD	01caH
	DD	01c5H
	DD	01c0H
	DD	01bbH
	DD	01b6H
	DD	01b2H
	DD	01adH
	DD	01a8H
	DD	01a4H
	DD	019fH
	DD	019bH
	DD	0197H
	DD	0192H
	DD	018eH
	DD	018aH
	DD	0186H
	DD	0182H
	DD	017eH
	DD	0179H
	DD	0175H
	DD	0172H
	DD	016eH
	DD	016aH
	DD	0166H
	DD	0162H
	DD	015eH
	DD	015bH
	DD	0157H
	DD	0153H
	DD	0150H
	DD	014cH
	DD	0149H
	DD	0145H
	DD	0142H
	DD	013eH
	DD	013bH
	DD	0137H
	DD	0134H
	DD	0131H
	DD	012eH
	DD	012aH
	DD	0127H
	DD	0124H
	DD	0121H
	DD	011eH
	DD	011aH
	DD	0117H
	DD	0114H
	DD	0111H
	DD	010eH
	DD	010bH
	DD	0108H
	DD	0105H
	DD	0102H
	DD	0100H
	DD	0fdH
	DD	0faH
	DD	0f7H
	DD	0f4H
	DD	0f1H
	DD	0efH
	DD	0ecH
	DD	0e9H
	DD	0e6H
	DD	0e4H
	DD	0e1H
	DD	0deH
	DD	0dcH
	DD	0d9H
	DD	0d7H
	DD	0d4H
	DD	0d1H
	DD	0cfH
	DD	0ccH
	DD	0caH
	DD	0c7H
	DD	0c5H
	DD	0c2H
	DD	0c0H
	DD	0beH
	DD	0bbH
	DD	0b9H
	DD	0b6H
	DD	0b4H
	DD	0b2H
	DD	0afH
	DD	0adH
	DD	0abH
	DD	0a8H
	DD	0a6H
	DD	0a4H
	DD	0a2H
	DD	09fH
	DD	09dH
	DD	09bH
	DD	099H
	DD	097H
	DD	095H
	DD	092H
	DD	090H
	DD	08eH
	DD	08cH
	DD	08aH
	DD	088H
	DD	086H
	DD	084H
	DD	082H
	DD	080H
	DD	07eH
	DD	07bH
	DD	079H
	DD	077H
	DD	075H
	DD	073H
	DD	072H
	DD	070H
	DD	06eH
	DD	06cH
	DD	06aH
	DD	068H
	DD	066H
	DD	064H
	DD	062H
	DD	060H
	DD	05eH
	DD	05dH
	DD	05bH
	DD	059H
	DD	057H
	DD	055H
	DD	053H
	DD	052H
	DD	050H
	DD	04eH
	DD	04cH
	DD	04aH
	DD	049H
	DD	047H
	DD	045H
	DD	043H
	DD	042H
	DD	040H
	DD	03eH
	DD	03dH
	DD	03bH
	DD	039H
	DD	037H
	DD	036H
	DD	034H
	DD	032H
	DD	031H
	DD	02fH
	DD	02eH
	DD	02cH
	DD	02aH
	DD	029H
	DD	027H
	DD	025H
	DD	024H
	DD	022H
	DD	021H
	DD	01fH
	DD	01eH
	DD	01cH
	DD	01aH
	DD	019H
	DD	017H
	DD	016H
	DD	014H
	DD	013H
	DD	011H
	DD	010H
	DD	0eH
	DD	0dH
	DD	0bH
	DD	0aH
	DD	08H
	DD	07H
	DD	05H
	DD	04H
	DD	02H
	DD	01H
PUBLIC	ZSTD_crossEntropyCost
PUBLIC	ZSTD_fseBitCost
PUBLIC	ZSTD_selectEncodingType
PUBLIC	ZSTD_encodeSequences
PUBLIC	ZSTD_buildCTable
pdata	SEGMENT
$pdata$ZSTD_encodeSequences_default DD imagerel ZSTD_encodeSequences_default
	DD	imagerel ZSTD_encodeSequences_default+60
	DD	imagerel $unwind$ZSTD_encodeSequences_default
$pdata$4$ZSTD_encodeSequences_default DD imagerel ZSTD_encodeSequences_default+60
	DD	imagerel ZSTD_encodeSequences_default+1719
	DD	imagerel $chain$4$ZSTD_encodeSequences_default
$pdata$5$ZSTD_encodeSequences_default DD imagerel ZSTD_encodeSequences_default+1719
	DD	imagerel ZSTD_encodeSequences_default+1764
	DD	imagerel $chain$5$ZSTD_encodeSequences_default
$pdata$ZSTD_encodeSequences_body DD imagerel ZSTD_encodeSequences_body
	DD	imagerel ZSTD_encodeSequences_body+60
	DD	imagerel $unwind$ZSTD_encodeSequences_body
$pdata$4$ZSTD_encodeSequences_body DD imagerel ZSTD_encodeSequences_body+60
	DD	imagerel ZSTD_encodeSequences_body+1719
	DD	imagerel $chain$4$ZSTD_encodeSequences_body
$pdata$5$ZSTD_encodeSequences_body DD imagerel ZSTD_encodeSequences_body+1719
	DD	imagerel ZSTD_encodeSequences_body+1764
	DD	imagerel $chain$5$ZSTD_encodeSequences_body
$pdata$ZSTD_crossEntropyCost DD imagerel $LN13
	DD	imagerel $LN13+94
	DD	imagerel $unwind$ZSTD_crossEntropyCost
$pdata$ZSTD_fseBitCost DD imagerel $LN24
	DD	imagerel $LN24+207
	DD	imagerel $unwind$ZSTD_fseBitCost
$pdata$ZSTD_entropyCost DD imagerel ZSTD_entropyCost
	DD	imagerel ZSTD_entropyCost+116
	DD	imagerel $unwind$ZSTD_entropyCost
$pdata$ZSTD_NCountCost DD imagerel ZSTD_NCountCost
	DD	imagerel ZSTD_NCountCost+218
	DD	imagerel $unwind$ZSTD_NCountCost
$pdata$4$ZSTD_NCountCost DD imagerel ZSTD_NCountCost+218
	DD	imagerel ZSTD_NCountCost+1196
	DD	imagerel $chain$4$ZSTD_NCountCost
$pdata$5$ZSTD_NCountCost DD imagerel ZSTD_NCountCost+1196
	DD	imagerel ZSTD_NCountCost+1222
	DD	imagerel $chain$5$ZSTD_NCountCost
$pdata$FSE_encodeSymbol DD imagerel FSE_encodeSymbol
	DD	imagerel FSE_encodeSymbol+102
	DD	imagerel $unwind$FSE_encodeSymbol
$pdata$ZSTD_selectEncodingType DD imagerel $LN33
	DD	imagerel $LN33+86
	DD	imagerel $unwind$ZSTD_selectEncodingType
$pdata$1$ZSTD_selectEncodingType DD imagerel $LN33+86
	DD	imagerel $LN33+201
	DD	imagerel $chain$1$ZSTD_selectEncodingType
$pdata$2$ZSTD_selectEncodingType DD imagerel $LN33+201
	DD	imagerel $LN33+221
	DD	imagerel $chain$2$ZSTD_selectEncodingType
$pdata$3$ZSTD_selectEncodingType DD imagerel $LN33+221
	DD	imagerel $LN33+436
	DD	imagerel $chain$3$ZSTD_selectEncodingType
$pdata$ZSTD_buildCTable DD imagerel $LN167
	DD	imagerel $LN167+202
	DD	imagerel $unwind$ZSTD_buildCTable
$pdata$0$ZSTD_buildCTable DD imagerel $LN167+202
	DD	imagerel $LN167+1390
	DD	imagerel $chain$0$ZSTD_buildCTable
$pdata$1$ZSTD_buildCTable DD imagerel $LN167+1390
	DD	imagerel $LN167+1542
	DD	imagerel $chain$1$ZSTD_buildCTable
xdata	SEGMENT
$unwind$ZSTD_encodeSequences_default DD 041701H
	DD	0f010f217H
	DD	0700cc00eH
$chain$4$ZSTD_encodeSequences_default DD 0a1821H
	DD	0ce418H
	DD	0dd414H
	DD	0e6410H
	DD	0f540cH
	DD	0163404H
	DD	imagerel ZSTD_encodeSequences_default
	DD	imagerel ZSTD_encodeSequences_default+60
	DD	imagerel $unwind$ZSTD_encodeSequences_default
$chain$5$ZSTD_encodeSequences_default DD 021H
	DD	imagerel ZSTD_encodeSequences_default
	DD	imagerel ZSTD_encodeSequences_default+60
	DD	imagerel $unwind$ZSTD_encodeSequences_default
$unwind$ZSTD_encodeSequences_body DD 041701H
	DD	0f010f217H
	DD	0700cc00eH
$chain$4$ZSTD_encodeSequences_body DD 0a1821H
	DD	0ce418H
	DD	0dd414H
	DD	0e6410H
	DD	0f540cH
	DD	0163404H
	DD	imagerel ZSTD_encodeSequences_body
	DD	imagerel ZSTD_encodeSequences_body+60
	DD	imagerel $unwind$ZSTD_encodeSequences_body
$chain$5$ZSTD_encodeSequences_body DD 021H
	DD	imagerel ZSTD_encodeSequences_body
	DD	imagerel ZSTD_encodeSequences_body+60
	DD	imagerel $unwind$ZSTD_encodeSequences_body
$unwind$ZSTD_crossEntropyCost DD 040a01H
	DD	02740aH
	DD	013405H
$unwind$ZSTD_fseBitCost DD 072e01H
	DD	02542eH
	DD	04640bH
	DD	03340bH
	DD	0700bH
$unwind$ZSTD_entropyCost DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
$unwind$ZSTD_NCountCost DD 041c19H
	DD	05d010aH
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$chain$4$ZSTD_NCountCost DD 0a3d21H
	DD	058f43dH
	DD	059e42bH
	DD	05ad41eH
	DD	05b7414H
	DD	05c6408H
	DD	imagerel ZSTD_NCountCost
	DD	imagerel ZSTD_NCountCost+218
	DD	imagerel $unwind$ZSTD_NCountCost
$chain$5$ZSTD_NCountCost DD 021H
	DD	imagerel ZSTD_NCountCost
	DD	imagerel ZSTD_NCountCost+218
	DD	imagerel $unwind$ZSTD_NCountCost
$unwind$FSE_encodeSymbol DD 020501H
	DD	013405H
$unwind$ZSTD_selectEncodingType DD 081301H
	DD	0b6413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0700be00dH
$chain$1$ZSTD_selectEncodingType DD 040a21H
	DD	09c40aH
	DD	085405H
	DD	imagerel $LN33
	DD	imagerel $LN33+86
	DD	imagerel $unwind$ZSTD_selectEncodingType
$chain$2$ZSTD_selectEncodingType DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+86
	DD	imagerel $unwind$ZSTD_selectEncodingType
$chain$3$ZSTD_selectEncodingType DD 040021H
	DD	09c400H
	DD	085400H
	DD	imagerel $LN33
	DD	imagerel $LN33+86
	DD	imagerel $unwind$ZSTD_selectEncodingType
$unwind$ZSTD_buildCTable DD 092519H
	DD	01a0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$chain$0$ZSTD_buildCTable DD 020821H
	DD	0235408H
	DD	imagerel $LN167
	DD	imagerel $LN167+202
	DD	imagerel $unwind$ZSTD_buildCTable
$chain$1$ZSTD_buildCTable DD 021H
	DD	imagerel $LN167
	DD	imagerel $LN167+202
	DD	imagerel $unwind$ZSTD_buildCTable
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
tableLog$1$ = 48
dst$GSCopy$1$ = 56
entropyWorkspace$GSCopy$1$ = 64
nextCTable$GSCopy$1$ = 72
norm$1 = 80
__$ArrayPad$ = 192
dst$ = 272
dstCapacity$ = 280
nextCTable$ = 288
FSELog$ = 296
type$ = 304
count$ = 312
max$ = 320
codeTable$ = 328
nbSeq$ = 336
defaultNorm$ = 344
defaultNormLog$ = 352
defaultMax$ = 360
prevCTable$ = 368
prevCTableSize$ = 376
entropyWorkspace$ = 384
entropyWorkspaceSize$ = 392
ZSTD_buildCTable PROC

; 230  : {

$LN167:
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 208				; 000000d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, QWORD PTR count$[rsp]
	mov	rbx, rdx
	mov	rdi, QWORD PTR codeTable$[rsp]
	mov	r14, r8
	mov	rdx, QWORD PTR nbSeq$[rsp]
	mov	r15, rcx
	mov	r10, QWORD PTR defaultNorm$[rsp]
	mov	r11d, r9d
	mov	r9, QWORD PTR prevCTable$[rsp]

; 231  :     BYTE* op = (BYTE*)dst;
; 232  :     const BYTE* const oend = op + dstCapacity;

	lea	r13, QWORD PTR [rcx+rbx]
	mov	QWORD PTR nextCTable$GSCopy$1$[rsp], r8
	mov	r8, QWORD PTR entropyWorkspace$[rsp]
	mov	QWORD PTR dst$GSCopy$1$[rsp], rcx

; 233  :     DEBUGLOG(6, "ZSTD_buildCTable (dstCapacity=%u)", (unsigned)dstCapacity);
; 234  : 
; 235  :     switch (type) {

	mov	ecx, DWORD PTR type$[rsp]
	mov	QWORD PTR entropyWorkspace$GSCopy$1$[rsp], r8
	test	ecx, ecx
	je	$LN9@ZSTD_build
	sub	ecx, 1
	je	$LN6@ZSTD_build
	sub	ecx, 1
	je	SHORT $LN31@ZSTD_build
	cmp	ecx, 1
	je	SHORT $LN27@ZSTD_build

; 260  :             return NCountSize;
; 261  :         }
; 262  :     }
; 263  :     default: assert(0); RETURN_ERROR(GENERIC, "impossible to reach");

	mov	rax, -1
	jmp	$LN20@ZSTD_build
$LN27@ZSTD_build:

; 241  :     case set_repeat:
; 242  :         memcpy(nextCTable, prevCTable, prevCTableSize);

	mov	r8, QWORD PTR prevCTableSize$[rsp]
	mov	rdx, r9
	mov	rcx, r14
	call	memcpy

; 243  :         return 0;

	xor	eax, eax
	jmp	$LN20@ZSTD_build
$LN31@ZSTD_build:

; 246  :         return 0;
; 247  :     case set_compressed: {
; 248  :         S16 norm[MaxSeq + 1];
; 249  :         size_t nbSeq_1 = nbSeq;
; 250  :         const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);

	mov	r12d, DWORD PTR max$[rsp]
	mov	ecx, r11d
	mov	r8d, r12d
	mov	QWORD PTR [rsp+280], rbp
	call	FSE_optimalTableLog

; 251  :         if (count[codeTable[nbSeq-1]] > 1) {

	movzx	ecx, BYTE PTR [rdx+rdi-1]
	mov	ebp, eax
	mov	DWORD PTR tableLog$1$[rsp], eax
	lea	r9, QWORD PTR [rsi+rcx*4]
	mov	ecx, DWORD PTR [rsi+rcx*4]
	cmp	ecx, 1
	jbe	SHORT $LN12@ZSTD_build

; 252  :             count[codeTable[nbSeq-1]]--;

	dec	ecx
	mov	DWORD PTR [r9], ecx

; 253  :             nbSeq_1--;

	dec	rdx
$LN12@ZSTD_build:

; 256  :         FORWARD_IF_ERROR(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max), "");

	mov	r9, rdx
	mov	DWORD PTR [rsp+32], r12d
	mov	edx, ebp
	lea	rcx, QWORD PTR norm$1[rsp]
	mov	r8, rsi
	call	FSE_normalizeCount
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 256  :         FORWARD_IF_ERROR(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max), "");

	ja	$LN161@ZSTD_build
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	cmp	ebp, 12
	jbe	SHORT $LN51@ZSTD_build
	mov	rbx, -44				; ffffffffffffffd4H
	jmp	$LN154@ZSTD_build
$LN51@ZSTD_build:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	ebp, 5
	jae	SHORT $LN52@ZSTD_build
	mov	rbx, -1
	jmp	$LN154@ZSTD_build
$LN52@ZSTD_build:

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	mov	ecx, ebp
	lea	r14d, DWORD PTR [r12+1]
	mov	edx, r14d
	lea	r8d, DWORD PTR [rbp-5]
	imul	edx, ebp
	mov	esi, 1
	shl	esi, cl
	mov	eax, 512				; 00000200H
	shr	edx, 3
	add	edx, 3
	inc	ebp
	test	r12d, r12d
	cmovne	eax, edx

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	xor	r12d, r12d
	mov	ecx, r12d
	lea	r11d, QWORD PTR [r12+4]
	cmp	rbx, rax
	jae	$LN53@ZSTD_build

; 198  :     BYTE* out = ostart;

	mov	rbx, r15

; 199  :     BYTE* const oend = ostart + headerBufferSize;
; 200  :     int nbBits;
; 201  :     const int tableSize = 1 << tableLog;
; 202  :     int remaining;
; 203  :     int threshold;
; 204  :     U32 bitStream = 0;
; 205  :     int bitCount = 0;
; 206  :     unsigned symbol = 0;
; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */

	lea	r15d, DWORD PTR [rsi+1]
	mov	edi, r12d

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	test	r14d, r14d
	je	$LN59@ZSTD_build
	npad	5
$LL58@ZSTD_build:
	cmp	r15d, 1
	jle	$LN162@ZSTD_build

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN71@ZSTD_build

; 221  :             unsigned start = symbol;

	mov	edx, edi

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	edi, r14d
	jae	SHORT $LN163@ZSTD_build
	mov	eax, edi
	lea	rcx, QWORD PTR norm$1[rsp]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LL60@ZSTD_build:
	cmp	WORD PTR [rcx], r12w
	jne	SHORT $LN159@ZSTD_build
	inc	edi
	add	rcx, 2
	cmp	edi, r14d
	jb	SHORT $LL60@ZSTD_build
$LN163@ZSTD_build:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN123@ZSTD_build
$LN159@ZSTD_build:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	edi, r9d
	jb	SHORT $LN142@ZSTD_build
	mov	ecx, r11d
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
	lea	rcx, QWORD PTR [r13-2]
	npad	12
$LL62@ZSTD_build:

; 225  :                 start+=24;

	add	edx, 24
	add	r9d, 24

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r8d, r10d

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	cmp	rbx, rcx
	ja	$LN117@ZSTD_build

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rbx], r8b
	shr	eax, 8
	mov	BYTE PTR [rbx+1], al

; 231  :                 out+=2;

	add	rbx, 2

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	cmp	edi, r9d
	jae	SHORT $LL62@ZSTD_build
$LN142@ZSTD_build:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	edi, r9d
	jb	SHORT $LN65@ZSTD_build
	npad	11
$LL64@ZSTD_build:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, r11d
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	r11d, 2
	cmp	r9d, edi
	jbe	SHORT $LL64@ZSTD_build
$LN65@ZSTD_build:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, r11d
	mov	eax, edi
	sub	eax, edx

; 240  :             bitCount += 2;

	add	r11d, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN71@ZSTD_build

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	cmp	rbx, rax
	ja	$LN117@ZSTD_build

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rbx], r8b
	shr	eax, 8
	mov	BYTE PTR [rbx+1], al

; 246  :                 out += 2;

	add	rbx, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	r11d, 16
$LN71@ZSTD_build:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	mov	eax, edi

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r10d, DWORD PTR [rsi+rsi]
	sub	r10d, r15d
	inc	edi
	movsx	ecx, WORD PTR norm$1[rsp+rax*2]

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	lea	r9d, DWORD PTR [r10-1]
	cdq
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	mov	eax, 1
	cmovl	r10d, eax
	add	r10d, ecx
	mov	ecx, r11d
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	mov	ecx, r12d
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	mov	ecx, r12d
	add	r11d, eax
	cmp	r10d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	$LN123@ZSTD_build

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, esi
	jge	SHORT $LN67@ZSTD_build
	npad	5
$LL66@ZSTD_build:
	dec	ebp
	sar	esi, 1
	cmp	r15d, esi
	jl	SHORT $LL66@ZSTD_build
$LN67@ZSTD_build:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN155@ZSTD_build

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	cmp	rbx, rax
	ja	SHORT $LN117@ZSTD_build

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rbx], r8b
	shr	eax, 8
	mov	BYTE PTR [rbx+1], al

; 268  :             out += 2;

	add	rbx, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	r11d, 16
$LN155@ZSTD_build:

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	edi, r14d
	jb	$LL58@ZSTD_build
$LN59@ZSTD_build:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN162@ZSTD_build:
	je	SHORT $LN77@ZSTD_build

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rbx, -1
	jmp	$LN15@ZSTD_build
$LN77@ZSTD_build:

; 275  :     assert(symbol <= alphabetSize);
; 276  : 
; 277  :     /* flush remaining bitStream */
; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	cmp	rbx, rax
	jbe	SHORT $LN78@ZSTD_build
$LN117@ZSTD_build:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rbx, -70				; ffffffffffffffbaH
	jmp	$LN15@ZSTD_build
$LN78@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 280  :     out[0] = (BYTE)bitStream;

	mov	BYTE PTR [rbx], r8b

; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [r11+7]
	cdq
	shr	r8d, 8
	and	edx, 7
	mov	BYTE PTR [rbx+1], r8b
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	movsxd	rcx, eax
	sub	rcx, QWORD PTR dst$GSCopy$1$[rsp]
	add	rbx, rcx

; 295  :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);

	jmp	$LN15@ZSTD_build
$LN53@ZSTD_build:

; 198  :     BYTE* out = ostart;

	mov	rdi, r15

; 199  :     BYTE* const oend = ostart + headerBufferSize;
; 200  :     int nbBits;
; 201  :     const int tableSize = 1 << tableLog;
; 202  :     int remaining;
; 203  :     int threshold;
; 204  :     U32 bitStream = 0;
; 205  :     int bitCount = 0;
; 206  :     unsigned symbol = 0;
; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */

	lea	r15d, DWORD PTR [rsi+1]
	mov	ebx, r12d

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	test	r14d, r14d
	je	$LN82@ZSTD_build
	npad	5
$LL81@ZSTD_build:
	cmp	r15d, 1
	jle	$LN164@ZSTD_build

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN94@ZSTD_build

; 221  :             unsigned start = symbol;

	mov	edx, ebx

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	ebx, r14d
	jae	SHORT $LN165@ZSTD_build
	mov	eax, ebx
	lea	rcx, QWORD PTR norm$1[rsp]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LL83@ZSTD_build:
	cmp	WORD PTR [rcx], r12w
	jne	SHORT $LN157@ZSTD_build
	inc	ebx
	add	rcx, 2
	cmp	ebx, r14d
	jb	SHORT $LL83@ZSTD_build
$LN165@ZSTD_build:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN123@ZSTD_build
$LN157@ZSTD_build:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	ebx, r9d
	jb	SHORT $LN115@ZSTD_build
	mov	ecx, r11d
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
$LL85@ZSTD_build:

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r8d, r10d
	add	edx, 24

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rdi], r8b
	shr	eax, 8
	add	r9d, 24
	mov	BYTE PTR [rdi+1], al

; 231  :                 out+=2;

	add	rdi, 2

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	cmp	r9d, ebx
	jbe	SHORT $LL85@ZSTD_build
$LN115@ZSTD_build:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	ebx, r9d
	jb	SHORT $LN88@ZSTD_build
	npad	4
$LL87@ZSTD_build:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, r11d
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	r11d, 2
	cmp	r9d, ebx
	jbe	SHORT $LL87@ZSTD_build
$LN88@ZSTD_build:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, r11d
	mov	eax, ebx
	sub	eax, edx

; 240  :             bitCount += 2;

	add	r11d, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN94@ZSTD_build

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rdi], r8b
	shr	eax, 8
	mov	BYTE PTR [rdi+1], al

; 246  :                 out += 2;

	add	rdi, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	r11d, 16
$LN94@ZSTD_build:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	mov	eax, ebx

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r10d, DWORD PTR [rsi+rsi]
	sub	r10d, r15d
	inc	ebx
	movsx	ecx, WORD PTR norm$1[rsp+rax*2]

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	lea	r9d, DWORD PTR [r10-1]
	cdq
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	mov	eax, 1
	cmovl	r10d, eax
	add	r10d, ecx
	mov	ecx, r11d
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	mov	ecx, r12d
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	mov	ecx, r12d
	add	r11d, eax
	cmp	r10d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	SHORT $LN123@ZSTD_build

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, esi
	jge	SHORT $LN90@ZSTD_build
	npad	6
$LL89@ZSTD_build:
	dec	ebp
	sar	esi, 1
	cmp	r15d, esi
	jl	SHORT $LL89@ZSTD_build
$LN90@ZSTD_build:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN98@ZSTD_build

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rdi], r8b
	shr	eax, 8
	mov	BYTE PTR [rdi+1], al

; 268  :             out += 2;

	add	rdi, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	r11d, 16
$LN98@ZSTD_build:

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	ebx, r14d
	jb	$LL81@ZSTD_build
$LN82@ZSTD_build:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN164@ZSTD_build:
	je	SHORT $LN100@ZSTD_build
$LN123@ZSTD_build:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rbx, -1
	jmp	SHORT $LN15@ZSTD_build
$LN100@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [r11+7]
	mov	BYTE PTR [rdi], r8b
	cdq
	shr	r8d, 8
	and	edx, 7
	mov	BYTE PTR [rdi+1], r8b
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	movsxd	rbx, eax
	sub	rbx, QWORD PTR dst$GSCopy$1$[rsp]
	add	rbx, rdi
$LN15@ZSTD_build:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 258  :             FORWARD_IF_ERROR(NCountSize, "FSE_writeNCount failed");

	ja	SHORT $LN154@ZSTD_build

; 259  :             FORWARD_IF_ERROR(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, entropyWorkspace, entropyWorkspaceSize), "");

	mov	rax, QWORD PTR entropyWorkspaceSize$[rsp]
	lea	rdx, QWORD PTR norm$1[rsp]
	mov	r9d, DWORD PTR tableLog$1$[rsp]
	mov	r8d, DWORD PTR max$[rsp]
	mov	rcx, QWORD PTR nextCTable$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR entropyWorkspace$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	FSE_buildCTable_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 259  :             FORWARD_IF_ERROR(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, entropyWorkspace, entropyWorkspaceSize), "");

	cmova	rbx, rax
$LN154@ZSTD_build:
	mov	rax, rbx
$LN161@ZSTD_build:
	mov	rbp, QWORD PTR [rsp+280]
$LN20@ZSTD_build:

; 264  :     }
; 265  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 540  :     tableU16[-1] = (U16) symbolValue;

	movzx	eax, BYTE PTR max$[rsp]
	xor	r12d, r12d
	mov	WORD PTR [r14], r12w
	mov	WORD PTR [r14+2], ax

; 541  : 
; 542  :     /* Build table */
; 543  :     tableU16[0] = 0;

	mov	DWORD PTR [r14+4], r12d

; 544  :     tableU16[1] = 0;   /* just in case */
; 545  : 
; 546  :     /* Build Symbol Transformation Table */
; 547  :     symbolTT[symbolValue].deltaNbBits = 0;
; 548  :     symbolTT[symbolValue].deltaFindState = 0;

	mov	QWORD PTR [r14+rax*8+8], r12
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 238  :         RETURN_ERROR_IF(dstCapacity==0, dstSize_tooSmall, "not enough space");

	test	rbx, rbx
	jne	SHORT $LN25@ZSTD_build
	lea	rax, QWORD PTR [rbx-70]
	jmp	SHORT $LN20@ZSTD_build
$LN25@ZSTD_build:

; 239  :         *op = codeTable[0];

	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [r15], al

; 240  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN20@ZSTD_build
$LN9@ZSTD_build:

; 245  :         FORWARD_IF_ERROR(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, entropyWorkspace, entropyWorkspaceSize), "");  /* note : could be pre-calculated */

	mov	rax, QWORD PTR entropyWorkspaceSize$[rsp]
	mov	rdx, r10
	mov	r9d, DWORD PTR defaultNormLog$[rsp]
	mov	rcx, r14
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r8
	mov	r8d, DWORD PTR defaultMax$[rsp]
	call	FSE_buildCTable_wksp
	xor	r12d, r12d
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 245  :         FORWARD_IF_ERROR(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, entropyWorkspace, entropyWorkspaceSize), "");  /* note : could be pre-calculated */

	cmova	r12, rax
	mov	rax, r12
	jmp	$LN20@ZSTD_build
ZSTD_buildCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
dst$ = 8
dstCapacity$ = 16
CTable_MatchLength$ = 24
mlCodeTable$ = 32
CTable_OffsetBits$ = 40
ofCodeTable$ = 48
CTable_LitLength$ = 56
llCodeTable$ = 64
sequences$ = 72
nbSeq$ = 80
longOffsets$ = 88
bmi2$dead$ = 96
ZSTD_encodeSequences PROC

; 403  :     DEBUGLOG(5, "ZSTD_encodeSequences: dstCapacity = %u", (unsigned)dstCapacity);
; 404  : #if DYNAMIC_BMI2
; 405  :     if (bmi2) {
; 406  :         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
; 407  :                                          CTable_MatchLength, mlCodeTable,
; 408  :                                          CTable_OffsetBits, ofCodeTable,
; 409  :                                          CTable_LitLength, llCodeTable,
; 410  :                                          sequences, nbSeq, longOffsets);
; 411  :     }
; 412  : #endif
; 413  :     (void)bmi2;
; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	jmp	ZSTD_encodeSequences_default
ZSTD_encodeSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
repeatMode$ = 64
count$ = 72
max$ = 80
mostFrequent$ = 88
nbSeq$ = 96
FSELog$ = 104
prevCTable$ = 112
defaultNorm$ = 120
defaultNormLog$ = 128
isDefaultAllowed$ = 136
strategy$ = 144
ZSTD_selectEncodingType PROC

; 149  : {

$LN33:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 150  :     ZSTD_STATIC_ASSERT(ZSTD_defaultDisallowed == 0 && ZSTD_defaultAllowed != 0);
; 151  :     if (mostFrequent == nbSeq) {

	mov	rbx, QWORD PTR nbSeq$[rsp]
	mov	r15d, r8d
	mov	rdi, rdx
	mov	r14, rcx
	cmp	r9, rbx
	jne	SHORT $LN2@ZSTD_selec

; 152  :         *repeatMode = FSE_repeat_none;
; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	cmp	DWORD PTR isDefaultAllowed$[rsp], 0
	mov	DWORD PTR [rcx], 0
	je	SHORT $LN3@ZSTD_selec
	cmp	rbx, 2
	ja	SHORT $LN3@ZSTD_selec

; 154  :             /* Prefer set_basic over set_rle when there are 2 or less symbols,
; 155  :              * since RLE uses 1 byte, but set_basic uses 5-6 bits per symbol.
; 156  :              * If basic encoding isn't possible, always choose RLE.
; 157  :              */
; 158  :             DEBUGLOG(5, "Selected set_basic");
; 159  :             return set_basic;

	xor	eax, eax
	jmp	$LN1@ZSTD_selec
$LN3@ZSTD_selec:

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	mov	eax, 1
	jmp	SHORT $LN1@ZSTD_selec
$LN2@ZSTD_selec:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	ecx, DWORD PTR strategy$[rsp]
	mov	esi, 1
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], r12
	cmp	ecx, 4
	jge	SHORT $LN4@ZSTD_selec

; 165  :         if (isDefaultAllowed) {

	cmp	DWORD PTR isDefaultAllowed$[rsp], 0
	je	SHORT $LN12@ZSTD_selec

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	mov	eax, 10
	sub	eax, ecx

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	mov	ecx, DWORD PTR defaultNormLog$[rsp]
	movsxd	rdx, eax
	mov	eax, esi
	shl	rax, cl
	imul	rdx, rax
	shr	rdx, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	DWORD PTR [r14], 2
	jne	SHORT $LN7@ZSTD_selec
	cmp	rbx, 1000				; 000003e8H
	jb	$LN29@ZSTD_selec
$LN7@ZSTD_selec:

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;
; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rbx, rdx
	jb	$LN28@ZSTD_selec
	dec	ecx
	shr	rbx, cl
	cmp	r9, rbx
	jb	$LN28@ZSTD_selec
$LN12@ZSTD_selec:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	DWORD PTR [r14], esi

; 219  :     return set_compressed;

	mov	eax, 2
$LN31@ZSTD_selec:
	mov	rbp, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+72]
$LN1@ZSTD_selec:

; 220  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN4@ZSTD_selec:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;
; 187  :                 return set_basic;
; 188  :             }
; 189  :         }
; 190  :     } else {
; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	cmp	DWORD PTR isDefaultAllowed$[rsp], 0
	mov	rbp, -1
	je	SHORT $LN14@ZSTD_selec
	mov	rcx, QWORD PTR defaultNorm$[rsp]
	mov	r9d, r15d
	mov	edx, DWORD PTR defaultNormLog$[rsp]
	mov	r8, rdi
	call	ZSTD_crossEntropyCost
	mov	r12, rax
	jmp	SHORT $LN15@ZSTD_selec
$LN14@ZSTD_selec:
	mov	r12, rbp
$LN15@ZSTD_selec:

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	cmp	DWORD PTR [r14], 0
	je	SHORT $LN16@ZSTD_selec
	mov	rcx, QWORD PTR prevCTable$[rsp]
	mov	r8d, r15d
	mov	rdx, rdi
	call	ZSTD_fseBitCost
	mov	rbp, rax
$LN16@ZSTD_selec:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r9d, DWORD PTR FSELog$[rsp]
	mov	r8, rbx
	mov	edx, r15d
	mov	rcx, rdi
	call	ZSTD_NCountCost
	lea	r10d, DWORD PTR [r15+1]
	mov	r11, rax
	lea	r15, OFFSET FLAT:kInverseProbabilityLog256

; 73   :     unsigned cost = 0;

	xor	r9d, r9d
	npad	6
$LL21@ZSTD_selec:

; 74   :     unsigned s;
; 75   :     for (s = 0; s <= max; ++s) {
; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [rdi]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rbx

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN22@ZSTD_selec
	test	eax, eax
	cmove	eax, esi
$LN22@ZSTD_selec:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	rdi, 4
	mov	ecx, DWORD PTR [r15+rax*4]
	imul	ecx, r8d
	add	r9d, ecx
	sub	r10, rsi
	jne	SHORT $LL21@ZSTD_selec

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	mov	eax, r9d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r11*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	cmp	r12, rbp
	ja	SHORT $LN11@ZSTD_selec
	cmp	r12, rcx
	ja	SHORT $LN11@ZSTD_selec
$LN28@ZSTD_selec:

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r14], 0

; 208  :             return set_basic;

	xor	eax, eax
	jmp	$LN31@ZSTD_selec
$LN11@ZSTD_selec:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	cmp	rbp, rcx
	ja	$LN12@ZSTD_selec
$LN29@ZSTD_selec:

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	mov	eax, 3
	jmp	$LN31@ZSTD_selec
ZSTD_selectEncodingType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write64 PROC

; 269  :     memcpy(memPtr, &value, sizeof(value));

	mov	QWORD PTR [rcx], rdx

; 270  : }

	ret	0
MEM_write64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val64$ = 16
MEM_writeLE64 PROC

; 376  :     if (MEM_isLittleEndian())
; 377  :         MEM_write64(memPtr, val64);

	mov	QWORD PTR [rcx], rdx

; 378  :     else
; 379  :         MEM_write64(memPtr, MEM_swap64(val64));
; 380  : }

	ret	0
MEM_writeLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLEST PROC

; 392  :     if (MEM_32bits())
; 393  :         MEM_writeLE32(memPtr, (U32)val);
; 394  :     else
; 395  :         MEM_writeLE64(memPtr, (U64)val);

	mov	QWORD PTR [rcx], rdx

; 396  : }

	ret	0
MEM_writeLEST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
startPtr$ = 16
dstCapacity$ = 24
BIT_initCStream PROC

; 186  :     bitC->bitContainer = 0;

	xor	eax, eax

; 187  :     bitC->bitPos = 0;
; 188  :     bitC->startPtr = (char*)startPtr;

	mov	QWORD PTR [rcx+16], rdx

; 189  :     bitC->ptr = bitC->startPtr;

	mov	QWORD PTR [rcx+24], rdx

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	add	rdx, -8
	add	rdx, r8
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	r8, 8
	mov	QWORD PTR [rcx+32], rdx
	mov	rcx, -70				; ffffffffffffffbaH
	cmovbe	rax, rcx

; 192  :     return 0;
; 193  : }

	ret	0
BIT_initCStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
value$ = 16
nbBits$ = 24
BIT_addBits PROC

; 200  : {

	mov	r10, rcx

; 201  :     MEM_STATIC_ASSERT(BIT_MASK_SIZE == 32);
; 202  :     assert(nbBits < BIT_MASK_SIZE);
; 203  :     assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, r8d
	mov	ecx, DWORD PTR [rcx+8]
	lea	r9, OFFSET FLAT:BIT_mask
	mov	r9d, DWORD PTR [r9+rax*4]
	and	r9, rdx

; 205  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rcx+r8]
	shl	r9, cl
	or	QWORD PTR [r10], r9
	mov	DWORD PTR [r10+8], eax

; 206  : }

	ret	0
BIT_addBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
value$dead$ = 16
nbBits$dead$ = 24
BIT_addBitsFast PROC

; 214  :     assert((value>>nbBits) == 0);
; 215  :     assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	edx, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	bts	rax, rdx
	mov	QWORD PTR [rcx], rax

; 217  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR [rcx+8], eax

; 218  : }

	ret	0
BIT_addBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_flushBits PROC

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	r8d, DWORD PTR [rcx+8]
	mov	r11, rcx

; 242  :     assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 243  :     assert(bitC->ptr <= bitC->endPtr);
; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rcx+24]
	mov	r9d, r8d
	mov	r10, QWORD PTR [rcx]
	shr	r9, 3
	mov	QWORD PTR [rax], r10

; 245  :     bitC->ptr += nbBytes;

	lea	rdx, QWORD PTR [rax+r9]

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	cmp	rdx, QWORD PTR [rcx+32]
	cmova	rdx, QWORD PTR [rcx+32]

; 247  :     bitC->bitPos &= 7;

	and	r8d, 7
	mov	DWORD PTR [rcx+8], r8d
	mov	QWORD PTR [rcx+24], rdx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, r9b
	shl	cl, 3
	shr	r10, cl
	mov	QWORD PTR [r11], r10

; 249  : }

	ret	0
BIT_flushBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_closeCStream PROC

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	eax, DWORD PTR [rcx+8]

; 255  : {

	mov	rdx, rcx

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	r9, QWORD PTR [rcx]
	bts	r9, rax

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	mov	r11, QWORD PTR [rdx+32]

; 217  :     bitC->bitPos += nbBits;

	lea	r8d, DWORD PTR [rax+1]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rdx+24]
	mov	ecx, r8d

; 245  :     bitC->ptr += nbBytes;
; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	and	r8d, 7
	shr	rcx, 3
	mov	DWORD PTR [rdx+8], r8d
	mov	QWORD PTR [rax], r9
	lea	r10, QWORD PTR [rax+rcx]
	shl	cl, 3
	shr	r9, cl
	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx], r9
	cmp	r10, r11
	jbe	SHORT $LN11@BIT_closeC
	mov	QWORD PTR [rdx+24], r11

; 256  :     BIT_addBitsFast(bitC, 1, 1);   /* endMark */
; 257  :     BIT_flushBits(bitC);
; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	xor	eax, eax

; 260  : }

	ret	0
$LN11@BIT_closeC:

; 256  :     BIT_addBitsFast(bitC, 1, 1);   /* endMark */
; 257  :     BIT_flushBits(bitC);
; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	jb	SHORT $LN2@BIT_closeC
	xor	eax, eax

; 260  : }

	ret	0
$LN2@BIT_closeC:

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	xor	eax, eax
	test	r8d, r8d
	setne	al
	sub	rax, QWORD PTR [rdx+16]
	add	rax, r10

; 260  : }

	ret	0
BIT_closeCStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
statePtr$ = 8
ct$ = 16
FSE_initCState PROC

; 490  :     const void* ptr = ct;
; 491  :     const U16* u16ptr = (const U16*) ptr;
; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	r10d, WORD PTR [rdx]
	mov	r9, rcx

; 493  :     statePtr->value = (ptrdiff_t)1<<tableLog;

	mov	r8d, 1
	mov	ecx, r10d
	mov	eax, r8d
	shl	rax, cl
	mov	QWORD PTR [r9], rax

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rax, QWORD PTR [rdx+4]
	mov	QWORD PTR [r9+8], rax

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	r10d, r10d
	je	SHORT $LN3@FSE_initCS
	lea	ecx, DWORD PTR [r10-1]
	shl	r8d, cl
$LN3@FSE_initCS:
	movsxd	rcx, r8d
	inc	rcx

; 496  :     statePtr->stateLog = tableLog;

	mov	DWORD PTR [r9+24], r10d
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	QWORD PTR [r9+16], rcx

; 497  : }

	ret	0
FSE_initCState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
statePtr$ = 8
ct$ = 16
symbol$ = 24
FSE_initCState2 PROC

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	r9d, WORD PTR [rdx]

; 493  :     statePtr->value = (ptrdiff_t)1<<tableLog;
; 494  :     statePtr->stateTable = u16ptr+2;

	lea	r11, QWORD PTR [rdx+4]
	mov	QWORD PTR [rcx+8], r11

; 504  : {

	mov	r10, rcx

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	eax, 1
	test	r9d, r9d
	je	SHORT $LN6@FSE_initCS
	lea	ecx, DWORD PTR [r9-1]
	shl	eax, cl
$LN6@FSE_initCS:
	cdqe
	add	rdx, 4

; 496  :     statePtr->stateLog = tableLog;

	mov	DWORD PTR [r10+24], r9d
	lea	rcx, QWORD PTR [rdx+rax*4]

; 505  :     FSE_initCState(statePtr, ct);
; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	eax, r8d

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR [r10+16], rcx

; 505  :     FSE_initCState(statePtr, ct);
; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+rax*8]

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	mov	rcx, r8
	mov	rdx, r8
	shr	rdx, 32					; 00000020H
	shr	rcx, 32					; 00000020H
	add	ecx, 32768				; 00008000H
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movsxd	rax, r8d
	sar	rdx, cl
	add	rdx, rax
	movzx	eax, WORD PTR [r11+rdx*2]
	mov	QWORD PTR [r10], rax

; 511  :     }
; 512  : }

	ret	0
FSE_initCState2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
bitC$ = 8
statePtr$ = 16
symbol$ = 24
FSE_encodeSymbol PROC

; 515  : {

	mov	QWORD PTR [rsp+8], rbx

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	mov	r11, QWORD PTR [rdx]
	mov	rbx, rdx
	mov	rax, QWORD PTR [rdx+16]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8d, r8d
	mov	r10, QWORD PTR [rax+r8*8]
	mov	r8, r10
	shr	r8, 32					; 00000020H

; 517  :     const U16* const stateTable = (const U16*)(statePtr->stateTable);
; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r8, r11
	sar	r8, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, r8d
	mov	edx, DWORD PTR [rdx+rax*4]

; 205  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rcx+r8]
	and	rdx, r11
	mov	DWORD PTR [r9+8], eax
	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	QWORD PTR [r9], rdx
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r11, cl
	movsxd	rax, r10d
	add	r11, rax
	mov	rax, QWORD PTR [rbx+8]
	movzx	ecx, WORD PTR [rax+r11*2]
	mov	QWORD PTR [rbx], rcx

; 521  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
FSE_encodeSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
bitC$ = 8
statePtr$ = 16
FSE_flushCState PROC

; 525  :     BIT_addBits(bitC, statePtr->value, statePtr->stateLog);

	mov	r8d, DWORD PTR [rdx+24]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r9, OFFSET FLAT:BIT_mask
; File E:\dev\pyzstd\lib\common\fse.h

; 524  : {

	mov	r11, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [rcx+8]
	mov	r10d, DWORD PTR [r9+r8*4]
	and	r10, QWORD PTR [rdx]

; 205  :     bitC->bitPos += nbBits;

	lea	r9d, DWORD PTR [rcx+r8]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [r11+24]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	shl	r10, cl
	or	r10, QWORD PTR [r11]

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	edx, r9d
	shr	rdx, 3

; 242  :     assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 243  :     assert(bitC->ptr <= bitC->endPtr);
; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [rax], r10

; 245  :     bitC->ptr += nbBytes;

	lea	rcx, QWORD PTR [rax+rdx]

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	cmp	rcx, QWORD PTR [r11+32]
	cmova	rcx, QWORD PTR [r11+32]

; 247  :     bitC->bitPos &= 7;

	and	r9d, 7
	mov	QWORD PTR [r11+24], rcx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
	shl	cl, 3
	shr	r10, cl
	mov	QWORD PTR [r11], r10
	mov	DWORD PTR [r11+8], r9d
; File E:\dev\pyzstd\lib\common\fse.h

; 527  : }

	ret	0
FSE_flushCState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\fse.h
_TEXT	SEGMENT
symbolTTPtr$ = 8
tableLog$ = 16
symbolValue$ = 24
accuracyLog$dead$ = 32
FSE_bitCost PROC

; 547  :     const FSE_symbolCompressionTransform* symbolTT = (const FSE_symbolCompressionTransform*) symbolTTPtr;
; 548  :     U32 const minNbBits = symbolTT[symbolValue].deltaNbBits >> 16;

	mov	eax, r8d
	mov	r8d, DWORD PTR [rcx+rax*8+4]

; 549  :     U32 const threshold = (minNbBits+1) << 16;
; 550  :     assert(tableLog < 16);
; 551  :     assert(accuracyLog < 31-tableLog);  /* ensure enough room for renormalization double shift */
; 552  :     {   U32 const tableSize = 1 << tableLog;

	mov	ecx, edx
	mov	r9d, r8d
	mov	eax, 1
	shl	eax, cl
	shr	r9d, 16

; 553  :         U32 const deltaFromThreshold = threshold - (symbolTT[symbolValue].deltaNbBits + tableSize);
; 554  :         U32 const normalizedDeltaFromThreshold = (deltaFromThreshold << accuracyLog) >> tableLog;   /* linear interpolation (very approximate) */

	lea	r10d, DWORD PTR [r9+1]
	shl	r10d, 16

; 555  :         U32 const bitMultiplier = 1 << accuracyLog;
; 556  :         assert(symbolTT[symbolValue].deltaNbBits + tableSize <= threshold);
; 557  :         assert(normalizedDeltaFromThreshold <= bitMultiplier);
; 558  :         return (minNbBits+1)*bitMultiplier - normalizedDeltaFromThreshold;

	sub	r10d, eax
	lea	eax, DWORD PTR [r9+1]
	sub	r10d, r8d
	shl	eax, 8
	shl	r10d, 8
	shr	r10d, cl
	sub	eax, r10d

; 559  :     }
; 560  : }

	ret	0
FSE_bitCost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
ctable$ = 8
ZSTD_getFSEMaxSymbolValue PROC

; 47   :   void const* ptr = ctable;
; 48   :   U16 const* u16ptr = (U16 const*)ptr;
; 49   :   U32 const maxSymbolValue = MEM_read16(u16ptr + 1);

	movzx	eax, WORD PTR [rcx+2]

; 50   :   return maxSymbolValue;
; 51   : }

	ret	0
ZSTD_getFSEMaxSymbolValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
r$1 = 48
r$2 = 48
r$3 = 48
norm$ = 64
wksp$ = 176
__$ArrayPad$ = 688
count$ = 768
max$ = 776
nbSeq$ = 784
FSELog$ = 792
ZSTD_NCountCost PROC

; 59   : {

	push	rbx
	push	rbp
	sub	rsp, 744				; 000002e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	mov	DWORD PTR r$3[rsp], 0
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 59   : {

	mov	ebx, edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	mov	DWORD PTR r$2[rsp], 0
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 327  :     U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;

	lea	eax, DWORD PTR [r8-1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	mov	DWORD PTR r$1[rsp], 0

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	ebp, 0
	cmovne	ebp, ecx
	mov	ecx, 0
	add	ebp, -2					; fffffffeH
	bsr	eax, r8d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 318  :     U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;

	inc	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, edx
	mov	edx, 0
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	mov	eax, 11

; 319  :     U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;

	add	edx, 2

; 320  :     U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;

	cmp	ecx, edx
	cmovb	edx, ecx

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	test	r9d, r9d
	cmovne	eax, r9d

; 333  :     if (minBits > tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */

	cmp	ebp, eax
	cmovae	ebp, eax
	cmp	edx, ebp
	cmova	ebp, edx

; 334  :     if (tableLog < FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;

	cmp	ebp, 5
	jae	SHORT $LN14@ZSTD_NCoun
	mov	ebp, 5

; 335  :     if (tableLog > FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;

	jmp	SHORT $LN15@ZSTD_NCoun
$LN14@ZSTD_NCoun:
	mov	eax, 12
	cmp	ebp, eax
	cmova	ebp, eax
$LN15@ZSTD_NCoun:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 63   :     FORWARD_IF_ERROR(FSE_normalizeCount(norm, tableLog, count, nbSeq, max), "");

	mov	r9, r8
	mov	DWORD PTR [rsp+32], ebx
	mov	r8, r10
	lea	rcx, QWORD PTR norm$[rsp]
	mov	edx, ebp
	call	FSE_normalizeCount
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 63   :     FORWARD_IF_ERROR(FSE_normalizeCount(norm, tableLog, count, nbSeq, max), "");

	ja	$LN57@ZSTD_NCoun
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	cmp	ebp, 12
	jbe	SHORT $LN28@ZSTD_NCoun
	mov	rax, -44				; ffffffffffffffd4H
	jmp	$LN57@ZSTD_NCoun
$LN28@ZSTD_NCoun:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	ebp, 5
	jae	SHORT $LN29@ZSTD_NCoun
	mov	rax, -1
	jmp	$LN57@ZSTD_NCoun
$LN29@ZSTD_NCoun:
	mov	QWORD PTR [rsp+736], rsi

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	lea	r8d, DWORD PTR [rbp-5]
	mov	QWORD PTR [rsp+728], rdi
	mov	ecx, ebp
	mov	QWORD PTR [rsp+720], r13
	mov	eax, 512				; 00000200H
	mov	QWORD PTR [rsp+712], r14
	mov	r13d, 1
	lea	r14d, DWORD PTR [rbx+1]
	mov	QWORD PTR [rsp+704], r15

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	mov	edx, r14d

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	mov	esi, r13d
	imul	edx, ebp
	shl	esi, cl

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	lea	r11d, QWORD PTR [r13+3]

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	shr	edx, 3

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	lea	r15d, DWORD PTR [rsi+1]

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	add	edx, 3

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	inc	ebp
	test	ebx, ebx
	cmovne	eax, edx

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	xor	ecx, ecx
	cmp	rax, 512				; 00000200H
	jbe	$LN30@ZSTD_NCoun

; 206  :     unsigned symbol = 0;

	xor	edi, edi
	lea	rbx, QWORD PTR wksp$[rsp]

; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */
; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	test	r14d, r14d
	je	$LN36@ZSTD_NCoun
	npad	8
$LL35@ZSTD_NCoun:
	cmp	r15d, r13d
	jle	$LN137@ZSTD_NCoun

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN48@ZSTD_NCoun

; 221  :             unsigned start = symbol;

	mov	edx, edi

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	edi, r14d
	jae	SHORT $LN138@ZSTD_NCoun
	lea	rcx, QWORD PTR norm$[rsp]
	lea	rcx, QWORD PTR [rcx+rdi*2]
$LL37@ZSTD_NCoun:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN130@ZSTD_NCoun
	inc	edi
	add	rcx, 2
	cmp	edi, r14d
	jb	SHORT $LL37@ZSTD_NCoun
$LN138@ZSTD_NCoun:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN127@ZSTD_NCoun
$LN130@ZSTD_NCoun:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	edi, r9d
	jb	SHORT $LN115@ZSTD_NCoun
	mov	ecx, r11d
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
	npad	3
$LL39@ZSTD_NCoun:

; 225  :                 start+=24;

	add	edx, 24

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	lea	rax, QWORD PTR wksp$[rsp+510]
	add	r9d, 24
	add	r8d, r10d
	cmp	rbx, rax
	ja	$LN90@ZSTD_NCoun

; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);
; 231  :                 out+=2;

	add	rbx, 2

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	cmp	edi, r9d
	jae	SHORT $LL39@ZSTD_NCoun
$LN115@ZSTD_NCoun:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	edi, r9d
	jb	SHORT $LN42@ZSTD_NCoun
	npad	15
$LL41@ZSTD_NCoun:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, r11d
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	r11d, 2
	cmp	r9d, edi
	jbe	SHORT $LL41@ZSTD_NCoun
$LN42@ZSTD_NCoun:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, r11d
	mov	eax, edi
	sub	eax, edx

; 240  :             bitCount += 2;

	add	r11d, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN48@ZSTD_NCoun

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR wksp$[rsp+510]
	cmp	rbx, rax
	ja	$LN90@ZSTD_NCoun

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);
; 246  :                 out += 2;

	add	rbx, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	r11d, 16
$LN48@ZSTD_NCoun:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR norm$[rsp+rdi*2]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r10d, DWORD PTR [rsi+rsi]
	sub	r10d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	edi
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	r9d, DWORD PTR [r10-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	cmovl	r10d, r13d
	add	r10d, ecx
	mov	ecx, r11d
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	r11d, eax
	cmp	r10d, r13d
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, r13d
	jl	$LN127@ZSTD_NCoun

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, esi
	jge	SHORT $LN44@ZSTD_NCoun
	npad	8
$LL43@ZSTD_NCoun:
	dec	ebp
	sar	esi, 1
	cmp	r15d, esi
	jl	SHORT $LL43@ZSTD_NCoun
$LN44@ZSTD_NCoun:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN116@ZSTD_NCoun

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR wksp$[rsp+510]
	cmp	rbx, rax
	ja	SHORT $LN90@ZSTD_NCoun

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);
; 268  :             out += 2;

	add	rbx, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	r11d, 16
$LN116@ZSTD_NCoun:

; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */
; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	edi, r14d
	jb	$LL35@ZSTD_NCoun
$LN36@ZSTD_NCoun:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, r13d
$LN137@ZSTD_NCoun:
	jne	$LN127@ZSTD_NCoun

; 275  :     assert(symbol <= alphabetSize);
; 276  : 
; 277  :     /* flush remaining bitStream */
; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR wksp$[rsp+510]
	cmp	rbx, rax
	ja	SHORT $LN90@ZSTD_NCoun

; 279  :         return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 280  :     out[0] = (BYTE)bitStream;
; 281  :     out[1] = (BYTE)(bitStream>>8);
; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [r11+7]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	movsxd	rcx, eax
	lea	rax, QWORD PTR wksp$[rsp]
	sub	rcx, rax
	lea	rax, QWORD PTR [rcx+rbx]

; 295  :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);

	jmp	$LN136@ZSTD_NCoun
$LN90@ZSTD_NCoun:

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN136@ZSTD_NCoun
$LN30@ZSTD_NCoun:

; 206  :     unsigned symbol = 0;

	xor	ebx, ebx
	lea	rdi, QWORD PTR wksp$[rsp]

; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */
; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	test	r14d, r14d
	je	$LN59@ZSTD_NCoun
	npad	6
$LL58@ZSTD_NCoun:
	cmp	r15d, r13d
	jle	$LN139@ZSTD_NCoun

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN71@ZSTD_NCoun

; 221  :             unsigned start = symbol;

	mov	edx, ebx

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	ebx, r14d
	jae	SHORT $LN140@ZSTD_NCoun
	lea	rcx, QWORD PTR norm$[rsp]
	lea	rcx, QWORD PTR [rcx+rbx*2]
$LL60@ZSTD_NCoun:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN128@ZSTD_NCoun
	inc	ebx
	add	rcx, 2
	cmp	ebx, r14d
	jb	SHORT $LL60@ZSTD_NCoun
$LN140@ZSTD_NCoun:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN127@ZSTD_NCoun
$LN128@ZSTD_NCoun:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	ebx, r9d
	jb	SHORT $LN88@ZSTD_NCoun
	mov	ecx, r11d
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
	npad	3
$LL62@ZSTD_NCoun:

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r8d, r10d
	add	edx, 24

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	add	r9d, 24
	add	rdi, 2
	cmp	r9d, ebx
	jbe	SHORT $LL62@ZSTD_NCoun
$LN88@ZSTD_NCoun:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	ebx, r9d
	jb	SHORT $LN65@ZSTD_NCoun
$LL64@ZSTD_NCoun:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, r11d
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	r11d, 2
	cmp	r9d, ebx
	jbe	SHORT $LL64@ZSTD_NCoun
$LN65@ZSTD_NCoun:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, r11d
	mov	eax, ebx
	sub	eax, edx

; 240  :             bitCount += 2;

	add	r11d, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN71@ZSTD_NCoun

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);
; 246  :                 out += 2;

	add	rdi, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	r11d, 16
$LN71@ZSTD_NCoun:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR norm$[rsp+rbx*2]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r10d, DWORD PTR [rsi+rsi]
	sub	r10d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	ebx
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	r9d, DWORD PTR [r10-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	cmovl	r10d, r13d
	add	r10d, ecx
	mov	ecx, r11d
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	r11d, eax
	cmp	r10d, r13d
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, r13d
	jl	SHORT $LN127@ZSTD_NCoun

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, esi
	jge	SHORT $LN67@ZSTD_NCoun
$LL66@ZSTD_NCoun:
	dec	ebp
	sar	esi, 1
	cmp	r15d, esi
	jl	SHORT $LL66@ZSTD_NCoun
$LN67@ZSTD_NCoun:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN75@ZSTD_NCoun

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);
; 268  :             out += 2;

	add	rdi, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	r11d, 16
$LN75@ZSTD_NCoun:

; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */
; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	ebx, r14d
	jb	$LL58@ZSTD_NCoun
$LN59@ZSTD_NCoun:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, r13d
$LN139@ZSTD_NCoun:
	je	SHORT $LN77@ZSTD_NCoun
$LN127@ZSTD_NCoun:

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rax, -1
	jmp	SHORT $LN136@ZSTD_NCoun
$LN77@ZSTD_NCoun:

; 279  :         return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 280  :     out[0] = (BYTE)bitStream;
; 281  :     out[1] = (BYTE)(bitStream>>8);
; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [r11+7]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	movsxd	rcx, eax
	lea	rax, QWORD PTR wksp$[rsp]
	sub	rcx, rax
	lea	rax, QWORD PTR [rcx+rdi]
$LN136@ZSTD_NCoun:
	mov	r14, QWORD PTR [rsp+712]
	mov	r13, QWORD PTR [rsp+720]
	mov	rdi, QWORD PTR [rsp+728]
	mov	rsi, QWORD PTR [rsp+736]
	mov	r15, QWORD PTR [rsp+704]
$LN57@ZSTD_NCoun:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 65   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 744				; 000002e8H
	pop	rbp
	pop	rbx
	ret	0
ZSTD_NCountCost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
count$ = 8
max$ = 16
total$ = 24
ZSTD_entropyCost PROC

; 72   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 73   :     unsigned cost = 0;

	xor	r11d, r11d
	lea	ebx, DWORD PTR [rdx+1]
	mov	r10, rcx
	lea	rsi, OFFSET FLAT:kInverseProbabilityLog256
	lea	edi, QWORD PTR [r11+1]
	npad	13
$LL4@ZSTD_entro:

; 74   :     unsigned s;
; 75   :     for (s = 0; s <= max; ++s) {
; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r9d, DWORD PTR [r10]
	xor	edx, edx
	mov	eax, r9d
	shl	eax, 8
	div	r8

; 77   :         if (count[s] != 0 && norm == 0)

	test	r9d, r9d
	je	SHORT $LN5@ZSTD_entro
	test	eax, eax
	cmove	eax, edi
$LN5@ZSTD_entro:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	ecx, eax
	add	r10, 4
	mov	eax, DWORD PTR [rsi+rcx*4]
	imul	eax, r9d
	add	r11d, eax
	sub	rbx, rdi
	jne	SHORT $LL4@ZSTD_entro

; 81   :     }
; 82   :     return cost >> 8;
; 83   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	mov	eax, r11d
	shr	rax, 8
	ret	0
ZSTD_entropyCost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
ctable$ = 16
count$ = 24
max$ = 32
ZSTD_fseBitCost PROC

; 93   : {

$LN24:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
; File E:\dev\pyzstd\lib\common\fse.h

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	edi, WORD PTR [rcx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 95   :     size_t cost = 0;

	xor	r10d, r10d
	mov	rbx, rdx
	mov	esi, r8d
	mov	rdx, rcx
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	lea	eax, QWORD PTR [r10+1]
	test	edi, edi
	je	SHORT $LN12@ZSTD_fseBi
	lea	ecx, DWORD PTR [rdi-1]
	shl	eax, cl
$LN12@ZSTD_fseBi:
	cdqe
	mov	QWORD PTR [rsp+16], rbp
	lea	r11, QWORD PTR [rdx+rax*4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 49   :   U32 const maxSymbolValue = MEM_read16(u16ptr + 1);

	movzx	eax, WORD PTR [rdx+2]

; 96   :     unsigned s;
; 97   :     FSE_CState_t cstate;
; 98   :     FSE_initCState(&cstate, ctable);
; 99   :     if (ZSTD_getFSEMaxSymbolValue(ctable) < max) {

	cmp	eax, esi
	jb	SHORT $LN18@ZSTD_fseBi

; 100  :         DEBUGLOG(5, "Repeat FSE_CTable has maxSymbolValue %u < %u",
; 101  :                     ZSTD_getFSEMaxSymbolValue(ctable), max);
; 102  :         return ERROR(GENERIC);
; 103  :     }
; 104  :     for (s = 0; s <= max; ++s) {

	mov	ecx, edi
	mov	ebp, -1
	shl	ebp, cl
	mov	edx, r10d
	add	r11, 8
	npad	6
$LL4@ZSTD_fseBi:
; File E:\dev\pyzstd\lib\common\fse.h

; 548  :     U32 const minNbBits = symbolTT[symbolValue].deltaNbBits >> 16;

	mov	r8d, DWORD PTR [r11]

; 549  :     U32 const threshold = (minNbBits+1) << 16;
; 550  :     assert(tableLog < 16);
; 551  :     assert(accuracyLog < 31-tableLog);  /* ensure enough room for renormalization double shift */
; 552  :     {   U32 const tableSize = 1 << tableLog;
; 553  :         U32 const deltaFromThreshold = threshold - (symbolTT[symbolValue].deltaNbBits + tableSize);
; 554  :         U32 const normalizedDeltaFromThreshold = (deltaFromThreshold << accuracyLog) >> tableLog;   /* linear interpolation (very approximate) */

	mov	ecx, edi
	shr	r8d, 16
	lea	r9d, DWORD PTR [r8+1]
	shl	r9d, 16

; 558  :         return (minNbBits+1)*bitMultiplier - normalizedDeltaFromThreshold;

	sub	r9d, DWORD PTR [r11]
	add	r9d, ebp
	shl	r9d, 8
	shr	r9d, cl
	lea	ecx, DWORD PTR [r8+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 108  :         if (count[s] == 0)

	mov	r8d, DWORD PTR [rbx]
; File E:\dev\pyzstd\lib\common\fse.h

; 558  :         return (minNbBits+1)*bitMultiplier - normalizedDeltaFromThreshold;

	shl	ecx, 8
	sub	ecx, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 108  :         if (count[s] == 0)

	test	r8d, r8d
	je	SHORT $LN2@ZSTD_fseBi

; 105  :         unsigned const tableLog = cstate.stateLog;
; 106  :         unsigned const badCost = (tableLog + 1) << kAccuracyLog;

	lea	eax, DWORD PTR [rdi+1]
	shl	eax, 8

; 109  :             continue;
; 110  :         if (bitCost >= badCost) {

	cmp	ecx, eax
	jae	SHORT $LN18@ZSTD_fseBi

; 113  :         }
; 114  :         cost += (size_t)count[s] * bitCost;

	imul	r8, rcx
	add	r10, r8
$LN2@ZSTD_fseBi:

; 100  :         DEBUGLOG(5, "Repeat FSE_CTable has maxSymbolValue %u < %u",
; 101  :                     ZSTD_getFSEMaxSymbolValue(ctable), max);
; 102  :         return ERROR(GENERIC);
; 103  :     }
; 104  :     for (s = 0; s <= max; ++s) {

	inc	edx
	add	r11, 8
	add	rbx, 4
	cmp	edx, esi
	jbe	SHORT $LL4@ZSTD_fseBi

; 115  :     }
; 116  :     return cost >> kAccuracyLog;

	shr	r10, 8
	mov	rax, r10
	mov	rbp, QWORD PTR [rsp+16]

; 117  : }

	mov	rbx, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+32]
	pop	rdi
	ret	0
$LN18@ZSTD_fseBi:
	mov	rbp, QWORD PTR [rsp+16]

; 111  :             DEBUGLOG(5, "Repeat FSE_CTable has Prob[%u] == 0", s);
; 112  :             return ERROR(GENERIC);

	mov	rax, -1

; 117  : }

	mov	rbx, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+32]
	pop	rdi
	ret	0
ZSTD_fseBitCost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
norm$ = 8
accuracyLog$ = 16
count$ = 24
max$ = 32
ZSTD_crossEntropyCost PROC

; 126  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 127  :     unsigned const shift = 8 - accuracyLog;

	mov	ebx, 8
	lea	rdi, OFFSET FLAT:kInverseProbabilityLog256
	sub	ebx, edx

; 128  :     size_t cost = 0;

	xor	r10d, r10d
	inc	r9d
	mov	r11, rcx
$LL4@ZSTD_cross:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [r11]
	cmp	ax, -1
	jne	SHORT $LN7@ZSTD_cross
	mov	eax, 1
$LN7@ZSTD_cross:

; 133  :         unsigned const norm256 = normAcc << shift;

	mov	ecx, ebx
	add	r11, 2
	shl	eax, cl

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	ecx, DWORD PTR [rdi+rax*4]
	imul	ecx, DWORD PTR [r8]
	add	r8, 4
	add	r10, rcx
	sub	r9, 1
	jne	SHORT $LL4@ZSTD_cross

; 137  :     }
; 138  :     return cost >> 8;
; 139  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	shr	r10, 8
	mov	rax, r10
	ret	0
ZSTD_crossEntropyCost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
stateLitLength$$sroa$1660$1$ = 0
llBits$1$ = 8
tableLog$1$ = 12
tableLog$1$ = 16
tableLog$1$ = 20
stateMatchLength$$sroa$1652$1$ = 24
stateOffsetBits$$sroa$1656$1$ = 32
tv2952 = 40
stateOffsetBits$$sroa$1654$1$ = 48
stateOffsetBits$$sroa$1653$1$ = 56
stateMatchLength$$sroa$1648$1$ = 64
stateMatchLength$$sroa$1647$1$ = 72
stateLitLength$$sroa$1658$1$ = 80
stateLitLength$$sroa$1657$1$ = 88
dst$ = 160
mlBits$1$ = 168
dstCapacity$ = 168
CTable_MatchLength$ = 176
mlCodeTable$ = 184
CTable_OffsetBits$ = 192
ofCodeTable$ = 200
CTable_LitLength$ = 208
llCodeTable$ = 216
sequences$ = 224
nbSeq$ = 232
longOffsets$ = 240
ZSTD_encodeSequences_body PROC

; 274  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], r9
	mov	QWORD PTR [rax+8], rcx
	push	rdi
	push	r12
	push	r15
	sub	rsp, 128				; 00000080H
; File E:\dev\pyzstd\lib\common\bitstream.h

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	lea	r12, QWORD PTR [rdx-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 274  : {

	mov	rdi, r9
; File E:\dev\pyzstd\lib\common\bitstream.h

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	add	r12, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 274  : {

	mov	r15, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	rdx, 8
	jbe	$LN147@ZSTD_encod
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 288  :     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);

	mov	r11, QWORD PTR nbSeq$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	r9d, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 288  :     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);

	mov	QWORD PTR [rax+24], rbx
; File E:\dev\pyzstd\lib\common\fse.h

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rbx, QWORD PTR [r8+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 288  :     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);

	mov	QWORD PTR [rax-32], rbp
	mov	QWORD PTR [rax-40], rsi
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
; File E:\dev\pyzstd\lib\common\fse.h

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR tableLog$1$[rsp], eax

; 494  :     statePtr->stateTable = u16ptr+2;

	mov	QWORD PTR stateMatchLength$$sroa$1647$1$[rsp], rbx

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	eax, eax
	je	SHORT $LN37@ZSTD_encod
	lea	ecx, DWORD PTR [rax-1]
	mov	eax, r9d
	shl	eax, cl
	jmp	SHORT $LN38@ZSTD_encod
$LN37@ZSTD_encod:
	mov	eax, r9d
$LN38@ZSTD_encod:

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	r10d, BYTE PTR [rdi+r11-1]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	add	r8, 4
	cdqe
	lea	rax, QWORD PTR [r8+rax*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rax+r10*8]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR stateMatchLength$$sroa$1648$1$[rsp], rax

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
	add	rdx, rax
	movzx	eax, WORD PTR [rbx+rdx*2]

; 492  :     const U32 tableLog = MEM_read16(ptr);

	mov	rdx, QWORD PTR CTable_OffsetBits$[rsp]

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateMatchLength$$sroa$1652$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 289  :     FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);

	mov	rax, QWORD PTR ofCodeTable$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rsi, QWORD PTR [rdx+4]
	mov	QWORD PTR stateOffsetBits$$sroa$1653$1$[rsp], rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 289  :     FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);

	movzx	ebx, BYTE PTR [rax+r11-1]
; File E:\dev\pyzstd\lib\common\fse.h

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	eax, WORD PTR [rdx]
	mov	DWORD PTR tableLog$1$[rsp], eax

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	eax, eax
	je	SHORT $LN43@ZSTD_encod
	lea	ecx, DWORD PTR [rax-1]
	mov	eax, r9d
	shl	eax, cl
	jmp	SHORT $LN44@ZSTD_encod
$LN43@ZSTD_encod:
	mov	eax, r9d
$LN44@ZSTD_encod:
	add	rdx, 4
	movsxd	rcx, eax
	lea	rcx, QWORD PTR [rdx+rcx*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+rbx*8]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR stateOffsetBits$$sroa$1654$1$[rsp], rcx

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
	add	rdx, rax
	movzx	eax, WORD PTR [rsi+rdx*2]

; 492  :     const U32 tableLog = MEM_read16(ptr);

	mov	rdx, QWORD PTR CTable_LitLength$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 290  :     FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);

	mov	rsi, QWORD PTR llCodeTable$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateOffsetBits$$sroa$1656$1$[rsp], rax

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	eax, WORD PTR [rdx]

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rbp, QWORD PTR [rdx+4]
	mov	DWORD PTR tableLog$1$[rsp], eax
	mov	QWORD PTR stateLitLength$$sroa$1657$1$[rsp], rbp

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	eax, eax
	je	SHORT $LN49@ZSTD_encod
	lea	ecx, DWORD PTR [rax-1]
	shl	r9d, cl
$LN49@ZSTD_encod:
	add	rdx, 4
	movsxd	rax, r9d

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	r9d, BYTE PTR [rsi+r11-1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 291  :     BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);

	lea	r14, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	lea	rax, QWORD PTR [rdx+rax*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rax+r9*8]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR stateLitLength$$sroa$1658$1$[rsp], rax

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 291  :     BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);

	mov	r8d, DWORD PTR LL_bits[r14+r9*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rdx, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	eax, WORD PTR [rbp+rdx*2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 293  :     BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);

	mov	edx, DWORD PTR ML_bits[r14+r10*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateLitLength$$sroa$1660$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	rax, QWORD PTR sequences$[rsp]
	mov	r9d, DWORD PTR BIT_mask[r14+rdx*4]
	lea	r10d, DWORD PTR [r8+rdx]
	lea	rbp, QWORD PTR [rax+r11*8]
	movzx	eax, WORD PTR [rax+r11*8-2]
	and	r9, rax
	movzx	eax, WORD PTR [rbp-4]
	shl	r9, cl
	mov	ecx, DWORD PTR BIT_mask[r14+r8*4]
	mov	r8, rbx
	and	rcx, rax
	or	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 295  :     if (longOffsets) {

	cmp	DWORD PTR longOffsets$[rsp], 0
	je	SHORT $LN9@ZSTD_encod

; 296  :         U32 const ofBits = ofCodeTable[nbSeq-1];
; 297  :         unsigned const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);

	mov	edi, 56					; 00000038H
	mov	rbx, r15
	cmp	r8d, edi
	cmovb	edi, r8d
	sub	r8d, edi

; 298  :         if (extraBits) {

	je	SHORT $LN63@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, DWORD PTR [rbp-8]
	mov	ecx, r10d
	mov	edx, DWORD PTR BIT_mask[r14+r8*4]
	add	r10d, r8d
	and	rdx, rax

; 247  :     bitC->bitPos &= 7;

	mov	rbx, r12

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	shl	rdx, cl
	or	r9, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	eax, r10d
	shr	rax, 3

; 247  :     bitC->bitPos &= 7;

	and	r10d, 7
	mov	QWORD PTR [r15], r9
	lea	rdx, QWORD PTR [rax+r15]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	al, 3
	movzx	ecx, al
	shr	r9, cl
	cmp	rdx, r12
	cmovbe	rbx, rdx
$LN63@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 302  :         BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,

	mov	eax, DWORD PTR [rbp-8]
	mov	ecx, r8d
	shr	rax, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR BIT_mask[r14+rdi*4]
	lea	r14d, DWORD PTR [r10+rdi]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 304  :     } else {

	mov	rdi, QWORD PTR mlCodeTable$[rsp]
	jmp	SHORT $LN149@ZSTD_encod
$LN9@ZSTD_encod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, DWORD PTR BIT_mask[r14+rbx*4]
	lea	r14d, DWORD PTR [r10+rbx]
	mov	ecx, DWORD PTR [rbp-8]

; 205  :     bitC->bitPos += nbBits;

	mov	rbx, r15
$LN149@ZSTD_encod:

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	and	rax, rcx
	mov	edx, r14d
	shr	rdx, 3
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	lea	r13, QWORD PTR [r11-2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r10d

; 247  :     bitC->bitPos &= 7;

	mov	r15, r12
	shl	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	lea	r10, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\common\bitstream.h

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	or	rax, r9

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	lea	rcx, QWORD PTR [rbx+rdx]
	mov	QWORD PTR [rbx], rax

; 247  :     bitC->bitPos &= 7;

	cmp	rcx, r12
	cmovbe	r15, rcx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
	shl	cl, 3
	and	r14d, 7
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	cmp	r13, r11
	jae	$LN3@ZSTD_encod
	mov	rcx, QWORD PTR ofCodeTable$[rsp]
	lea	rdx, QWORD PTR [rsi+r13]
	sub	rcx, rsi
	mov	QWORD PTR tv2952[rsp], rdx
	sub	rdi, rsi
	mov	QWORD PTR ofCodeTable$[rsp], rcx
	mov	QWORD PTR mlCodeTable$[rsp], rdi
	npad	8
$LL4@ZSTD_encod:

; 311  :             BYTE const llCode = llCodeTable[n];
; 312  :             BYTE const ofCode = ofCodeTable[n];

	movzx	ecx, BYTE PTR [rcx+rdx]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r11, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 316  :             U32  const mlBits = ML_bits[mlCode];

	movzx	r9d, BYTE PTR [rdi+rdx]
	mov	ebp, ecx
	movzx	esi, BYTE PTR [rdx]
	mov	edx, DWORD PTR ML_bits[r10+r9*4]
	mov	r8d, DWORD PTR LL_bits[r10+rsi*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	mov	r10, QWORD PTR stateOffsetBits$$sroa$1656$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 316  :             U32  const mlBits = ML_bits[mlCode];

	mov	DWORD PTR mlBits$1$[rsp], edx
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, QWORD PTR stateOffsetBits$$sroa$1654$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 314  :             U32  const llBits = LL_bits[llCode];

	mov	DWORD PTR llBits$1$[rsp], r8d
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rdx+rcx*8]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	rcx, r10
	shr	rcx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, ecx

; 205  :     bitC->bitPos += nbBits;

	lea	ebx, DWORD PTR [r14+rcx]
	mov	edi, DWORD PTR BIT_mask[r11+rdx*4]
	and	rdi, r10
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r10, cl
	movsxd	rcx, r8d
	add	r10, rcx
	mov	rcx, QWORD PTR stateOffsetBits$$sroa$1653$1$[rsp]
	movzx	r10d, WORD PTR [rcx+r10*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rcx, QWORD PTR stateMatchLength$$sroa$1648$1$[rsp]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateOffsetBits$$sroa$1656$1$[rsp], r10

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+r9*8]

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	mov	r9, QWORD PTR stateMatchLength$$sroa$1652$1$[rsp]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, r9
	sar	rcx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, ecx
	mov	r10d, DWORD PTR BIT_mask[r11+rdx*4]
	lea	r11d, DWORD PTR [rbx+rcx]
	and	r10, r9
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r9, cl
	movsxd	rcx, r8d
	add	r9, rcx
	mov	rcx, QWORD PTR stateMatchLength$$sroa$1647$1$[rsp]
	movzx	r9d, WORD PTR [rcx+r9*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rcx, QWORD PTR stateLitLength$$sroa$1658$1$[rsp]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateMatchLength$$sroa$1652$1$[rsp], r9

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r9, QWORD PTR [rcx+rsi*8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	rcx, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, r9
	shr	r8, 32					; 00000020H

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r8, QWORD PTR stateLitLength$$sroa$1660$1$[rsp]
	shr	r8, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, r8d
	mov	esi, DWORD PTR BIT_mask[rcx+rdx*4]
	mov	ecx, r11d
	mov	rdx, QWORD PTR stateLitLength$$sroa$1660$1$[rsp]
	and	rsi, rdx
	shl	rsi, cl
	mov	ecx, r14d
	shl	rdi, cl
	mov	ecx, ebx
	shl	r10, cl
	or	rsi, rdi
	or	rsi, r10
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	rsi, rax
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r10d, DWORD PTR [r11+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	mov	r11d, DWORD PTR mlBits$1$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rdx, rax
	mov	rax, QWORD PTR stateLitLength$$sroa$1657$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	mov	r9d, DWORD PTR llBits$1$[rsp]
	lea	ebx, DWORD PTR [r11+rbp]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	edx, WORD PTR [rax+rdx*2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	add	ebx, r9d
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateLitLength$$sroa$1660$1$[rsp], rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	ebx, 31
	jb	SHORT $LN88@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], rsi
	mov	eax, r10d

; 247  :     bitC->bitPos &= 7;

	and	r10d, 7
	shr	rax, 3
	lea	rdx, QWORD PTR [r15+rax]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	al, 3
	movzx	ecx, al
	mov	r15, r12
	shr	rsi, cl
	cmp	rdx, r12
	cmovbe	r15, rdx
$LN88@ZSTD_encod:

; 205  :     bitC->bitPos += nbBits;

	lea	r8d, DWORD PTR [r10+r9]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR BIT_mask[rcx+r9*4]
	lea	r14d, DWORD PTR [r11+r8]
	mov	r9, QWORD PTR sequences$[rsp]
	mov	ecx, r10d
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	edx, WORD PTR [r9+r13*8+4]
	and	rax, rdx
	mov	edx, DWORD PTR BIT_mask[r10+r11*4]
	shl	rax, cl
	movzx	ecx, WORD PTR [r9+r13*8+6]
	and	rdx, rcx
	mov	ecx, r8d
	shl	rdx, cl
	or	rax, rdx
	or	rax, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 332  :             if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);

	cmp	ebx, 56					; 00000038H
	jbe	SHORT $LN98@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], rax
	mov	ecx, r14d

; 247  :     bitC->bitPos &= 7;

	and	r14d, 7
	shr	rcx, 3
	lea	rdx, QWORD PTR [r15+rcx]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
	mov	r15, r12
	cmp	rdx, r12
	cmovbe	r15, rdx
$LN98@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 333  :             if (longOffsets) {

	cmp	DWORD PTR longOffsets$[rsp], 0
	je	SHORT $LN18@ZSTD_encod

; 334  :                 unsigned const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);

	mov	r8d, 56					; 00000038H
	cmp	ebp, r8d
	cmovb	r8d, ebp
	sub	ebp, r8d

; 335  :                 if (extraBits) {

	je	SHORT $LN103@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [r9+r13*8]
	mov	edx, DWORD PTR BIT_mask[r10+rbp*4]
	and	rdx, rcx
	mov	ecx, r14d
	shl	rdx, cl

; 205  :     bitC->bitPos += nbBits;

	add	r14d, ebp
	or	rax, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r14d
	shr	rcx, 3

; 247  :     bitC->bitPos &= 7;

	and	r14d, 7
	mov	QWORD PTR [r15], rax
	lea	rdx, QWORD PTR [r15+rcx]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
	mov	r15, r12
	cmp	rdx, r12
	cmovbe	r15, rdx
$LN103@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 339  :                 BIT_addBits(&blockStream, sequences[n].offset >> extraBits,

	mov	edx, DWORD PTR [r9+r13*8]
	mov	ecx, ebp
	shr	rdx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR BIT_mask[r10+r8*4]
	and	rdx, rcx
	mov	ecx, r14d
	shl	rdx, cl
	or	rax, rdx

; 205  :     bitC->bitPos += nbBits;

	add	r14d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 341  :             } else {

	jmp	SHORT $LN108@ZSTD_encod
$LN18@ZSTD_encod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [r9+r13*8]
	mov	edx, DWORD PTR BIT_mask[r10+rbp*4]
	and	rdx, rcx
	mov	ecx, r14d
	shl	rdx, cl
	or	rax, rdx

; 205  :     bitC->bitPos += nbBits;

	add	r14d, ebp
$LN108@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	mov	rdi, QWORD PTR mlCodeTable$[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], rax
	mov	edx, r14d
	shr	rdx, 3
	lea	rcx, QWORD PTR [r15+rdx]

; 247  :     bitC->bitPos &= 7;

	mov	r15, r12
	cmp	rcx, r12
	cmovbe	r15, rcx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	mov	rdx, QWORD PTR tv2952[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 247  :     bitC->bitPos &= 7;

	and	r14d, 7

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	dec	rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	dec	r13
	mov	rcx, QWORD PTR ofCodeTable$[rsp]
	mov	QWORD PTR tv2952[rsp], rdx
	cmp	r13, QWORD PTR nbSeq$[rsp]
	jb	$LL4@ZSTD_encod
$LN3@ZSTD_encod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, DWORD PTR tableLog$1$[rsp]
	lea	rbx, OFFSET FLAT:__ImageBase

; 247  :     bitC->bitPos &= 7;

	mov	r13, QWORD PTR [rsp+104]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, r14d

; 247  :     bitC->bitPos &= 7;

	mov	rsi, QWORD PTR [rsp+112]
	mov	r8, r12
	mov	rbp, QWORD PTR [rsp+120]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	r11d, DWORD PTR BIT_mask[r10+rdx*4]

; 205  :     bitC->bitPos += nbBits;

	lea	r9d, DWORD PTR [r14+rdx]
	and	r11, QWORD PTR stateMatchLength$$sroa$1652$1$[rsp]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	r10d, DWORD PTR tableLog$1$[rsp]

; 247  :     bitC->bitPos &= 7;

	mov	r14, QWORD PTR [rsp+96]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	shl	r11, cl
	or	r11, rax

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r9d

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, DWORD PTR BIT_mask[rbx+r10*4]

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	shr	rcx, 3

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], r11
	lea	rax, QWORD PTR [r15+rcx]

; 247  :     bitC->bitPos &= 7;

	cmp	rax, r12
	cmovbe	r8, rax

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	and	rdx, QWORD PTR stateOffsetBits$$sroa$1656$1$[rsp]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	and	r9d, 7
	shr	r11, cl

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	add	r10d, r9d
	mov	ecx, r9d
	mov	r9d, DWORD PTR tableLog$1$[rsp]
	shl	rdx, cl
	or	r11, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r10d
	shr	rcx, 3

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, DWORD PTR BIT_mask[rbx+r9*4]

; 247  :     bitC->bitPos &= 7;

	mov	rbx, QWORD PTR [rsp+176]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	lea	rax, QWORD PTR [r8+rcx]

; 247  :     bitC->bitPos &= 7;

	mov	r8, r12
	cmp	rax, r12
	cmovbe	r8, rax

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	and	rdx, QWORD PTR stateLitLength$$sroa$1660$1$[rsp]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	and	r10d, 7
	shr	r11, cl

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, r10d
	shl	rdx, cl
	or	r11, rdx
	lea	edx, DWORD PTR [r9+r10]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	mov	ecx, edx
	shr	rcx, 3
	lea	rax, QWORD PTR [r8+rcx]

; 247  :     bitC->bitPos &= 7;

	mov	r8, r12
	cmp	rax, r12
	cmovbe	r8, rax
	and	edx, 7

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	r11, cl

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	bts	r11, rdx
	lea	r9d, DWORD PTR [rdx+1]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	mov	ecx, r9d

; 247  :     bitC->bitPos &= 7;

	mov	rdx, r12
	shr	rcx, 3
	add	rcx, r8
	cmp	rcx, r12
	cmovbe	rdx, rcx

; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	cmp	rdx, r12
	jae	SHORT $LN147@ZSTD_encod

; 247  :     bitC->bitPos &= 7;

	test	r9b, 7

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	mov	eax, 0
	seta	al
	sub	rax, QWORD PTR dst$[rsp]
	add	rax, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 356  :         RETURN_ERROR_IF(streamSize==0, dstSize_tooSmall, "not enough space");

	jne	SHORT $LN1@ZSTD_encod
$LN147@ZSTD_encod:
	mov	rax, -70				; ffffffffffffffbaH
$LN1@ZSTD_encod:

; 357  :         return streamSize;
; 358  :     }
; 359  : }

	add	rsp, 128				; 00000080H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
ZSTD_encodeSequences_body ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\fse.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
_TEXT	SEGMENT
stateLitLength$4$sroa$1660$1$ = 0
llBits$1$ = 8
tableLog$1$ = 12
tableLog$1$ = 16
tableLog$1$ = 20
stateMatchLength$2$sroa$1652$1$ = 24
stateOffsetBits$3$sroa$1656$1$ = 32
tv2955 = 40
stateOffsetBits$3$sroa$1654$1$ = 48
stateOffsetBits$3$sroa$1653$1$ = 56
stateMatchLength$2$sroa$1648$1$ = 64
stateMatchLength$2$sroa$1647$1$ = 72
stateLitLength$4$sroa$1658$1$ = 80
stateLitLength$4$sroa$1657$1$ = 88
dst$ = 160
mlBits$1$ = 168
dstCapacity$ = 168
CTable_MatchLength$ = 176
mlCodeTable$ = 184
CTable_OffsetBits$ = 192
ofCodeTable$ = 200
CTable_LitLength$ = 208
llCodeTable$ = 216
sequences$ = 224
nbSeq$ = 232
longOffsets$ = 240
ZSTD_encodeSequences_default PROC

; 368  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], r9
	mov	QWORD PTR [rax+8], rcx
	push	rdi
	push	r12
	push	r15
	sub	rsp, 128				; 00000080H
; File E:\dev\pyzstd\lib\common\bitstream.h

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	lea	r12, QWORD PTR [rdx-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 368  : {

	mov	rdi, r9
; File E:\dev\pyzstd\lib\common\bitstream.h

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	add	r12, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 368  : {

	mov	r15, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	rdx, 8
	jbe	$LN149@ZSTD_encod
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 288  :     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);

	mov	r11, QWORD PTR nbSeq$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	r9d, 1
	mov	QWORD PTR [rax+24], rbx

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rbx, QWORD PTR [r8+4]
	mov	QWORD PTR [rax-32], rbp
	mov	QWORD PTR [rax-40], rsi
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR tableLog$1$[rsp], eax

; 494  :     statePtr->stateTable = u16ptr+2;

	mov	QWORD PTR stateMatchLength$2$sroa$1647$1$[rsp], rbx

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	eax, eax
	je	SHORT $LN39@ZSTD_encod
	lea	ecx, DWORD PTR [rax-1]
	mov	eax, r9d
	shl	eax, cl
	jmp	SHORT $LN40@ZSTD_encod
$LN39@ZSTD_encod:
	mov	eax, r9d
$LN40@ZSTD_encod:

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	r10d, BYTE PTR [rdi+r11-1]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	add	r8, 4
	cdqe
	lea	rax, QWORD PTR [r8+rax*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rax+r10*8]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR stateMatchLength$2$sroa$1648$1$[rsp], rax

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
	add	rdx, rax
	movzx	eax, WORD PTR [rbx+rdx*2]

; 492  :     const U32 tableLog = MEM_read16(ptr);

	mov	rdx, QWORD PTR CTable_OffsetBits$[rsp]

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateMatchLength$2$sroa$1652$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 289  :     FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);

	mov	rax, QWORD PTR ofCodeTable$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rsi, QWORD PTR [rdx+4]
	mov	QWORD PTR stateOffsetBits$3$sroa$1653$1$[rsp], rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 289  :     FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);

	movzx	ebx, BYTE PTR [rax+r11-1]
; File E:\dev\pyzstd\lib\common\fse.h

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	eax, WORD PTR [rdx]
	mov	DWORD PTR tableLog$1$[rsp], eax

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	eax, eax
	je	SHORT $LN45@ZSTD_encod
	lea	ecx, DWORD PTR [rax-1]
	mov	eax, r9d
	shl	eax, cl
	jmp	SHORT $LN46@ZSTD_encod
$LN45@ZSTD_encod:
	mov	eax, r9d
$LN46@ZSTD_encod:
	add	rdx, 4
	movsxd	rcx, eax
	lea	rcx, QWORD PTR [rdx+rcx*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+rbx*8]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR stateOffsetBits$3$sroa$1654$1$[rsp], rcx

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
	add	rdx, rax
	movzx	eax, WORD PTR [rsi+rdx*2]

; 492  :     const U32 tableLog = MEM_read16(ptr);

	mov	rdx, QWORD PTR CTable_LitLength$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 290  :     FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);

	mov	rsi, QWORD PTR llCodeTable$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateOffsetBits$3$sroa$1656$1$[rsp], rax

; 492  :     const U32 tableLog = MEM_read16(ptr);

	movzx	eax, WORD PTR [rdx]

; 494  :     statePtr->stateTable = u16ptr+2;

	lea	rbp, QWORD PTR [rdx+4]
	mov	DWORD PTR tableLog$1$[rsp], eax
	mov	QWORD PTR stateLitLength$4$sroa$1657$1$[rsp], rbp

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	test	eax, eax
	je	SHORT $LN51@ZSTD_encod
	lea	ecx, DWORD PTR [rax-1]
	shl	r9d, cl
$LN51@ZSTD_encod:
	add	rdx, 4
	movsxd	rax, r9d

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	movzx	r9d, BYTE PTR [rsi+r11-1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 291  :     BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);

	lea	r14, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\common\fse.h

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	lea	rax, QWORD PTR [rdx+rax*4]

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rax+r9*8]

; 495  :     statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);

	mov	QWORD PTR stateLitLength$4$sroa$1658$1$[rsp], rax

; 506  :     {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, r8
	shr	rdx, 32					; 00000020H

; 507  :         const U16* stateTable = (const U16*)(statePtr->stateTable);
; 508  :         U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);

	lea	ecx, DWORD PTR [rdx+32768]
	shr	ecx, 16

; 509  :         statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;

	mov	eax, ecx
	shl	eax, 16
	sub	eax, edx
	mov	edx, eax

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 291  :     BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);

	mov	r8d, DWORD PTR LL_bits[r14+r9*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rdx, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	eax, WORD PTR [rbp+rdx*2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 293  :     BIT_addBits(&blockStream, sequences[nbSeq-1].matchLength, ML_bits[mlCodeTable[nbSeq-1]]);

	mov	edx, DWORD PTR ML_bits[r14+r10*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 510  :         statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateLitLength$4$sroa$1660$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	rax, QWORD PTR sequences$[rsp]
	mov	r9d, DWORD PTR BIT_mask[r14+rdx*4]
	lea	r10d, DWORD PTR [r8+rdx]
	lea	rbp, QWORD PTR [rax+r11*8]
	movzx	eax, WORD PTR [rax+r11*8-2]
	and	r9, rax
	movzx	eax, WORD PTR [rbp-4]
	shl	r9, cl
	mov	ecx, DWORD PTR BIT_mask[r14+r8*4]
	mov	r8, rbx
	and	rcx, rax
	or	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 295  :     if (longOffsets) {

	cmp	DWORD PTR longOffsets$[rsp], 0
	je	SHORT $LN11@ZSTD_encod

; 296  :         U32 const ofBits = ofCodeTable[nbSeq-1];
; 297  :         unsigned const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);

	mov	edi, 56					; 00000038H
	mov	rbx, r15
	cmp	r8d, edi
	cmovb	edi, r8d
	sub	r8d, edi

; 298  :         if (extraBits) {

	je	SHORT $LN65@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, DWORD PTR [rbp-8]
	mov	ecx, r10d
	mov	edx, DWORD PTR BIT_mask[r14+r8*4]
	add	r10d, r8d
	and	rdx, rax

; 247  :     bitC->bitPos &= 7;

	mov	rbx, r12

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	shl	rdx, cl
	or	r9, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	eax, r10d
	shr	rax, 3

; 247  :     bitC->bitPos &= 7;

	and	r10d, 7
	mov	QWORD PTR [r15], r9
	lea	rdx, QWORD PTR [rax+r15]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	al, 3
	movzx	ecx, al
	shr	r9, cl
	cmp	rdx, r12
	cmovbe	rbx, rdx
$LN65@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 302  :         BIT_addBits(&blockStream, sequences[nbSeq-1].offset >> extraBits,

	mov	eax, DWORD PTR [rbp-8]
	mov	ecx, r8d
	shr	rax, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR BIT_mask[r14+rdi*4]
	lea	r14d, DWORD PTR [r10+rdi]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 304  :     } else {

	mov	rdi, QWORD PTR mlCodeTable$[rsp]
	jmp	SHORT $LN151@ZSTD_encod
$LN11@ZSTD_encod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	eax, DWORD PTR BIT_mask[r14+rbx*4]
	lea	r14d, DWORD PTR [r10+rbx]
	mov	ecx, DWORD PTR [rbp-8]

; 205  :     bitC->bitPos += nbBits;

	mov	rbx, r15
$LN151@ZSTD_encod:

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	and	rax, rcx
	mov	edx, r14d
	shr	rdx, 3
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	lea	r13, QWORD PTR [r11-2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r10d

; 247  :     bitC->bitPos &= 7;

	mov	r15, r12
	shl	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	lea	r10, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\common\bitstream.h

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	or	rax, r9

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	lea	rcx, QWORD PTR [rbx+rdx]
	mov	QWORD PTR [rbx], rax

; 247  :     bitC->bitPos &= 7;

	cmp	rcx, r12
	cmovbe	r15, rcx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
	shl	cl, 3
	and	r14d, 7
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	cmp	r13, r11
	jae	$LN5@ZSTD_encod
	mov	rcx, QWORD PTR ofCodeTable$[rsp]
	lea	rdx, QWORD PTR [rsi+r13]
	sub	rcx, rsi
	mov	QWORD PTR tv2955[rsp], rdx
	sub	rdi, rsi
	mov	QWORD PTR ofCodeTable$[rsp], rcx
	mov	QWORD PTR mlCodeTable$[rsp], rdi
	npad	8
$LL6@ZSTD_encod:

; 311  :             BYTE const llCode = llCodeTable[n];
; 312  :             BYTE const ofCode = ofCodeTable[n];

	movzx	ecx, BYTE PTR [rcx+rdx]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r11, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 316  :             U32  const mlBits = ML_bits[mlCode];

	movzx	r9d, BYTE PTR [rdi+rdx]
	mov	ebp, ecx
	movzx	esi, BYTE PTR [rdx]
	mov	edx, DWORD PTR ML_bits[r10+r9*4]
	mov	r8d, DWORD PTR LL_bits[r10+rsi*4]
; File E:\dev\pyzstd\lib\common\fse.h

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	mov	r10, QWORD PTR stateOffsetBits$3$sroa$1656$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 316  :             U32  const mlBits = ML_bits[mlCode];

	mov	DWORD PTR mlBits$1$[rsp], edx
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rdx, QWORD PTR stateOffsetBits$3$sroa$1654$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 314  :             U32  const llBits = LL_bits[llCode];

	mov	DWORD PTR llBits$1$[rsp], r8d
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rdx+rcx*8]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	rcx, r10
	shr	rcx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, ecx

; 205  :     bitC->bitPos += nbBits;

	lea	ebx, DWORD PTR [r14+rcx]
	mov	edi, DWORD PTR BIT_mask[r11+rdx*4]
	and	rdi, r10
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r10, cl
	movsxd	rcx, r8d
	add	r10, rcx
	mov	rcx, QWORD PTR stateOffsetBits$3$sroa$1653$1$[rsp]
	movzx	r10d, WORD PTR [rcx+r10*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rcx, QWORD PTR stateMatchLength$2$sroa$1648$1$[rsp]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateOffsetBits$3$sroa$1656$1$[rsp], r10

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, QWORD PTR [rcx+r9*8]

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	mov	r9, QWORD PTR stateMatchLength$2$sroa$1652$1$[rsp]
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, r9
	sar	rcx, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, ecx
	mov	r10d, DWORD PTR BIT_mask[r11+rdx*4]
	lea	r11d, DWORD PTR [rbx+rcx]
	and	r10, r9
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	r9, cl
	movsxd	rcx, r8d
	add	r9, rcx
	mov	rcx, QWORD PTR stateMatchLength$2$sroa$1647$1$[rsp]
	movzx	r9d, WORD PTR [rcx+r9*2]

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	rcx, QWORD PTR stateLitLength$4$sroa$1658$1$[rsp]

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateMatchLength$2$sroa$1652$1$[rsp], r9

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r9, QWORD PTR [rcx+rsi*8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	rcx, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\common\fse.h

; 516  :     FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];

	mov	r8, r9
	shr	r8, 32					; 00000020H

; 518  :     U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);

	add	r8, QWORD PTR stateLitLength$4$sroa$1660$1$[rsp]
	shr	r8, 16
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, r8d
	mov	esi, DWORD PTR BIT_mask[rcx+rdx*4]
	mov	ecx, r11d
	mov	rdx, QWORD PTR stateLitLength$4$sroa$1660$1$[rsp]
	and	rsi, rdx
	shl	rsi, cl
	mov	ecx, r14d
	shl	rdi, cl
	mov	ecx, ebx
	shl	r10, cl
	or	rsi, rdi
	or	rsi, r10
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	or	rsi, rax
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	sar	rdx, cl
	movsxd	rax, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	r10d, DWORD PTR [r11+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	mov	r11d, DWORD PTR mlBits$1$[rsp]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	add	rdx, rax
	mov	rax, QWORD PTR stateLitLength$4$sroa$1657$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	mov	r9d, DWORD PTR llBits$1$[rsp]
	lea	ebx, DWORD PTR [r11+rbp]
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	movzx	edx, WORD PTR [rax+rdx*2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	add	ebx, r9d
; File E:\dev\pyzstd\lib\common\fse.h

; 520  :     statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];

	mov	QWORD PTR stateLitLength$4$sroa$1660$1$[rsp], rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 327  :             if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	ebx, 31
	jb	SHORT $LN90@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], rsi
	mov	eax, r10d

; 247  :     bitC->bitPos &= 7;

	and	r10d, 7
	shr	rax, 3
	lea	rdx, QWORD PTR [r15+rax]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	al, 3
	movzx	ecx, al
	mov	r15, r12
	shr	rsi, cl
	cmp	rdx, r12
	cmovbe	r15, rdx
$LN90@ZSTD_encod:

; 205  :     bitC->bitPos += nbBits;

	lea	r8d, DWORD PTR [r10+r9]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR BIT_mask[rcx+r9*4]
	lea	r14d, DWORD PTR [r11+r8]
	mov	r9, QWORD PTR sequences$[rsp]
	mov	ecx, r10d
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	edx, WORD PTR [r9+r13*8+4]
	and	rax, rdx
	mov	edx, DWORD PTR BIT_mask[r10+r11*4]
	shl	rax, cl
	movzx	ecx, WORD PTR [r9+r13*8+6]
	and	rdx, rcx
	mov	ecx, r8d
	shl	rdx, cl
	or	rax, rdx
	or	rax, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 332  :             if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);

	cmp	ebx, 56					; 00000038H
	jbe	SHORT $LN100@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], rax
	mov	ecx, r14d

; 247  :     bitC->bitPos &= 7;

	and	r14d, 7
	shr	rcx, 3
	lea	rdx, QWORD PTR [r15+rcx]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
	mov	r15, r12
	cmp	rdx, r12
	cmovbe	r15, rdx
$LN100@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 333  :             if (longOffsets) {

	cmp	DWORD PTR longOffsets$[rsp], 0
	je	SHORT $LN20@ZSTD_encod

; 334  :                 unsigned const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);

	mov	r8d, 56					; 00000038H
	cmp	ebp, r8d
	cmovb	r8d, ebp
	sub	ebp, r8d

; 335  :                 if (extraBits) {

	je	SHORT $LN105@ZSTD_encod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [r9+r13*8]
	mov	edx, DWORD PTR BIT_mask[r10+rbp*4]
	and	rdx, rcx
	mov	ecx, r14d
	shl	rdx, cl

; 205  :     bitC->bitPos += nbBits;

	add	r14d, ebp
	or	rax, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r14d
	shr	rcx, 3

; 247  :     bitC->bitPos &= 7;

	and	r14d, 7
	mov	QWORD PTR [r15], rax
	lea	rdx, QWORD PTR [r15+rcx]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	rax, cl
	mov	r15, r12
	cmp	rdx, r12
	cmovbe	r15, rdx
$LN105@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 339  :                 BIT_addBits(&blockStream, sequences[n].offset >> extraBits,

	mov	edx, DWORD PTR [r9+r13*8]
	mov	ecx, ebp
	shr	rdx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR BIT_mask[r10+r8*4]
	and	rdx, rcx
	mov	ecx, r14d
	shl	rdx, cl
	or	rax, rdx

; 205  :     bitC->bitPos += nbBits;

	add	r14d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 341  :             } else {

	jmp	SHORT $LN110@ZSTD_encod
$LN20@ZSTD_encod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, DWORD PTR [r9+r13*8]
	mov	edx, DWORD PTR BIT_mask[r10+rbp*4]
	and	rdx, rcx
	mov	ecx, r14d
	shl	rdx, cl
	or	rax, rdx

; 205  :     bitC->bitPos += nbBits;

	add	r14d, ebp
$LN110@ZSTD_encod:
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	mov	rdi, QWORD PTR mlCodeTable$[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], rax
	mov	edx, r14d
	shr	rdx, 3
	lea	rcx, QWORD PTR [r15+rdx]

; 247  :     bitC->bitPos &= 7;

	mov	r15, r12
	cmp	rcx, r12
	cmovbe	r15, rcx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	mov	rdx, QWORD PTR tv2955[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 247  :     bitC->bitPos &= 7;

	and	r14d, 7

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	dec	rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 310  :         for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */

	dec	r13
	mov	rcx, QWORD PTR ofCodeTable$[rsp]
	mov	QWORD PTR tv2955[rsp], rdx
	cmp	r13, QWORD PTR nbSeq$[rsp]
	jb	$LL6@ZSTD_encod
$LN5@ZSTD_encod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, DWORD PTR tableLog$1$[rsp]
	lea	rbx, OFFSET FLAT:__ImageBase

; 247  :     bitC->bitPos &= 7;

	mov	r13, QWORD PTR [rsp+104]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, r14d

; 247  :     bitC->bitPos &= 7;

	mov	rsi, QWORD PTR [rsp+112]
	mov	r8, r12
	mov	rbp, QWORD PTR [rsp+120]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	r11d, DWORD PTR BIT_mask[r10+rdx*4]

; 205  :     bitC->bitPos += nbBits;

	lea	r9d, DWORD PTR [r14+rdx]
	and	r11, QWORD PTR stateMatchLength$2$sroa$1652$1$[rsp]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	r10d, DWORD PTR tableLog$1$[rsp]

; 247  :     bitC->bitPos &= 7;

	mov	r14, QWORD PTR [rsp+96]

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	shl	r11, cl
	or	r11, rax

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r9d

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, DWORD PTR BIT_mask[rbx+r10*4]

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	shr	rcx, 3

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], r11
	lea	rax, QWORD PTR [r15+rcx]

; 247  :     bitC->bitPos &= 7;

	cmp	rax, r12
	cmovbe	r8, rax

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	and	rdx, QWORD PTR stateOffsetBits$3$sroa$1656$1$[rsp]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	and	r9d, 7
	shr	r11, cl

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	add	r10d, r9d
	mov	ecx, r9d
	mov	r9d, DWORD PTR tableLog$1$[rsp]
	shl	rdx, cl
	or	r11, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, r10d
	shr	rcx, 3

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	edx, DWORD PTR BIT_mask[rbx+r9*4]

; 247  :     bitC->bitPos &= 7;

	mov	rbx, QWORD PTR [rsp+176]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	lea	rax, QWORD PTR [r8+rcx]

; 247  :     bitC->bitPos &= 7;

	mov	r8, r12
	cmp	rax, r12
	cmovbe	r8, rax

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	and	rdx, QWORD PTR stateLitLength$4$sroa$1660$1$[rsp]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	and	r10d, 7
	shr	r11, cl

; 204  :     bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;

	mov	ecx, r10d
	shl	rdx, cl
	or	r11, rdx
	lea	edx, DWORD PTR [r9+r10]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	mov	ecx, edx
	shr	rcx, 3
	lea	rax, QWORD PTR [r8+rcx]

; 247  :     bitC->bitPos &= 7;

	mov	r8, r12
	cmp	rax, r12
	cmovbe	r8, rax
	and	edx, 7

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	r11, cl

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	bts	r11, rdx
	lea	r9d, DWORD PTR [rdx+1]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r8], r11
	mov	ecx, r9d

; 247  :     bitC->bitPos &= 7;

	mov	rdx, r12
	shr	rcx, 3
	add	rcx, r8
	cmp	rcx, r12
	cmovbe	rdx, rcx

; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	cmp	rdx, r12
	jae	SHORT $LN149@ZSTD_encod

; 247  :     bitC->bitPos &= 7;

	test	r9b, 7

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	mov	eax, 0
	seta	al
	sub	rax, QWORD PTR dst$[rsp]
	add	rax, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 356  :         RETURN_ERROR_IF(streamSize==0, dstSize_tooSmall, "not enough space");

	jne	SHORT $LN3@ZSTD_encod
$LN149@ZSTD_encod:

; 369  :     return ZSTD_encodeSequences_body(dst, dstCapacity,
; 370  :                                     CTable_MatchLength, mlCodeTable,
; 371  :                                     CTable_OffsetBits, ofCodeTable,
; 372  :                                     CTable_LitLength, llCodeTable,
; 373  :                                     sequences, nbSeq, longOffsets);
; 374  : }

	mov	rax, -70				; ffffffffffffffbaH
$LN3@ZSTD_encod:
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
ZSTD_encodeSequences_default ENDP
_TEXT	ENDS
END
