; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_clock:PROC
g_compressionLevel_default DD 03H
ZSTD_defaultCMem DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
repStartValue DD 01H
	DD	04H
	DD	08H
PUBLIC	ZDICT_trainFromBuffer
PUBLIC	ZDICT_finalizeDictionary
PUBLIC	ZDICT_getDictID
PUBLIC	ZDICT_getErrorName
PUBLIC	ZDICT_isError
PUBLIC	fprintf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
	ALIGN	4

$SG4294963403 DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$ZDICT_trainFromBuffer DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$ZDICT_trainFromBuffer
$pdata$ZDICT_finalizeDictionary DD imagerel $LN470
	DD	imagerel $LN470+481
	DD	imagerel $unwind$ZDICT_finalizeDictionary
$pdata$ZDICT_analyzeEntropy DD imagerel ZDICT_analyzeEntropy
	DD	imagerel ZDICT_analyzeEntropy+197
	DD	imagerel $unwind$ZDICT_analyzeEntropy
$pdata$1$ZDICT_analyzeEntropy DD imagerel ZDICT_analyzeEntropy+197
	DD	imagerel ZDICT_analyzeEntropy+5966
	DD	imagerel $chain$1$ZDICT_analyzeEntropy
$pdata$2$ZDICT_analyzeEntropy DD imagerel ZDICT_analyzeEntropy+5966
	DD	imagerel ZDICT_analyzeEntropy+6656
	DD	imagerel $chain$2$ZDICT_analyzeEntropy
$pdata$ZDICT_totalSampleSize DD imagerel ZDICT_totalSampleSize
	DD	imagerel ZDICT_totalSampleSize+119
	DD	imagerel $unwind$ZDICT_totalSampleSize
$pdata$0$ZDICT_totalSampleSize DD imagerel ZDICT_totalSampleSize+119
	DD	imagerel ZDICT_totalSampleSize+172
	DD	imagerel $chain$0$ZDICT_totalSampleSize
$pdata$1$ZDICT_totalSampleSize DD imagerel ZDICT_totalSampleSize+172
	DD	imagerel ZDICT_totalSampleSize+190
	DD	imagerel $chain$1$ZDICT_totalSampleSize
$pdata$ZDICT_countEStats DD imagerel ZDICT_countEStats
	DD	imagerel ZDICT_countEStats+1084
	DD	imagerel $unwind$ZDICT_countEStats
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
xdata	SEGMENT
$unwind$ZDICT_trainFromBuffer DD 010401H
	DD	0e204H
$unwind$ZDICT_finalizeDictionary DD 0a2619H
	DD	02f0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$ZDICT_analyzeEntropy DD 0b3619H
	DD	059f3425H
	DD	05960125H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	02c80H
$chain$1$ZDICT_analyzeEntropy DD 041721H
	DD	02c97817H
	DD	02ca6808H
	DD	imagerel ZDICT_analyzeEntropy
	DD	imagerel ZDICT_analyzeEntropy+197
	DD	imagerel $unwind$ZDICT_analyzeEntropy
$chain$2$ZDICT_analyzeEntropy DD 021H
	DD	imagerel ZDICT_analyzeEntropy
	DD	imagerel ZDICT_analyzeEntropy+197
	DD	imagerel $unwind$ZDICT_analyzeEntropy
$unwind$ZDICT_totalSampleSize DD 010201H
	DD	07002H
$chain$0$ZDICT_totalSampleSize DD 020521H
	DD	023405H
	DD	imagerel ZDICT_totalSampleSize
	DD	imagerel ZDICT_totalSampleSize+119
	DD	imagerel $unwind$ZDICT_totalSampleSize
$chain$1$ZDICT_totalSampleSize DD 021H
	DD	imagerel ZDICT_totalSampleSize
	DD	imagerel ZDICT_totalSampleSize+119
	DD	imagerel $unwind$ZDICT_totalSampleSize
$unwind$ZDICT_countEStats DD 0104101H
	DD	01e8841H
	DD	01f783cH
	DD	0206835H
	DD	043011dH
	DD	0e00df00fH
	DD	0c009d00bH
	DD	060067007H
	DD	050043005H
	ORG $+3
$SG4294963402 DB 0dH, '%70s', 0dH, 00H
	ORG $+6
$SG4294963401 DB 'statistics ... ', 0aH, 00H
	ORG $+5
$SG4294963404 DB 'not enough space to write RepOffsets ', 0aH, 00H
	ORG $+1
$SG4294963405 DB 'FSE_writeNCount error with litlengthNCount ', 0aH, 00H
	ORG $+3
$SG4294963406 DB 'FSE_writeNCount error with matchLengthNCount ', 0aH, 00H
	ORG $+1
$SG4294963407 DB 'FSE_writeNCount error with offcodeNCount ', 0aH, 00H
	ORG $+5
$SG4294963408 DB 'HUF_writeCTable error ', 0aH, 00H
$SG4294963409 DB 'FSE_normalizeCount error with litLengthCount ', 0aH, 00H
	ORG $+1
$SG4294963410 DB 'FSE_normalizeCount error with matchLengthCount ', 0aH, 00H
	ORG $+5
$SG4294963411 DB 'FSE_normalizeCount error with offcodeCount ', 0aH, 00H
	ORG $+3
$SG4294963414 DB 'Not enough memory ', 0aH, 00H
	ORG $+4
$SG4294963412 DB 'warning : pathological dataset : literals are not compr'
	DB	'essible : samples are noisy or too regular ', 0aH, 00H
	ORG $+4
$SG4294963413 DB ' HUF_buildCTable error ', 0aH, 00H
	ORG $+6
$SG4294963415 DB 'warning : could not compress sample size %u ', 0aH, 00H
	ORG $+2
$SG4294963416 DB 'warning : ZSTD_compressBegin_usingCDict failed ', 0aH, 00H
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 644  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Stream$ = 80
_Format$ = 88
fprintf	PROC						; COMDAT

; 835  :     {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rbx, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_getErrorCode PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rcx, -120				; ffffffffffffff88H

; 58   : ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }

	ja	SHORT $LN2@ERR_getErr
	xor	eax, eax
	ret	0
$LN2@ERR_getErr:
	neg	ecx
	mov	eax, ecx
	ret	0
ERR_getErrorCode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_getErrorName PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rcx, -120				; ffffffffffffff88H

; 58   : ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }

	ja	SHORT $LN4@ERR_getErr
	xor	ecx, ecx

; 73   :     return ERR_getErrorString(ERR_getErrorCode(code));

	jmp	ERR_getErrorString
$LN4@ERR_getErr:

; 58   : ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }

	neg	ecx

; 73   :     return ERR_getErrorString(ERR_getErrorCode(code));

	jmp	ERR_getErrorString
ERR_getErrorName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
val$ = 8
ZSTD_highbit32 PROC

; 394  :     assert(val != 0);
; 395  :     {
; 396  : #   if defined(_MSC_VER)   /* Visual */
; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 399  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
; 400  :         return __builtin_clz (val) ^ 31;
; 401  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 402  :         return 31 - __CLZ(val);
; 403  : #   else   /* Software version */
; 404  :         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
; 405  :         U32 v = val;
; 406  :         v |= v >> 1;
; 407  :         v |= v >> 2;
; 408  :         v |= v >> 4;
; 409  :         v |= v >> 8;
; 410  :         v |= v >> 16;
; 411  :         return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];
; 412  : #   endif
; 413  :     }
; 414  : }

	ret	0
ZSTD_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
errorCode$ = 8
ZDICT_isError PROC
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 92   : unsigned ZDICT_isError(size_t errorCode) { return ERR_isError(errorCode); }

	ret	0
ZDICT_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
errorCode$ = 8
ZDICT_getErrorName PROC
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rcx, -120				; ffffffffffffff88H

; 58   : ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }

	ja	SHORT $LN6@ZDICT_getE
	xor	ecx, ecx

; 73   :     return ERR_getErrorString(ERR_getErrorCode(code));

	jmp	ERR_getErrorString
$LN6@ZDICT_getE:

; 58   : ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }

	neg	ecx

; 73   :     return ERR_getErrorString(ERR_getErrorCode(code));

	jmp	ERR_getErrorString
ZDICT_getErrorName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
dictBuffer$ = 8
dictSize$ = 16
ZDICT_getDictID PROC

; 98   :     if (dictSize < 8) return 0;

	cmp	rdx, 8
	jb	SHORT $LN5@ZDICT_getD

; 99   :     if (MEM_readLE32(dictBuffer) != ZSTD_MAGIC_DICTIONARY) return 0;

	cmp	DWORD PTR [rcx], -332356553		; ec30a437H
	jne	SHORT $LN5@ZDICT_getD

; 100  :     return MEM_readLE32((const char*)dictBuffer + 4);

	mov	eax, DWORD PTR [rcx+4]

; 101  : }

	ret	0
$LN5@ZDICT_getD:

; 99   :     if (MEM_readLE32(dictBuffer) != ZSTD_MAGIC_DICTIONARY) return 0;

	xor	eax, eax

; 101  : }

	ret	0
ZDICT_getDictID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
params$1$ = 80
$T1 = 88
$T2 = 88
src$GSCopy$1$ = 120
esr$GSCopy$1$ = 128
repOffsets$GSCopy$1$ = 136
fParams$3 = 144
params$4 = 160
$T5 = 304
$T6 = 448
esr$ = 608
params$ = 616
countLit$ = 624
offsetcodeCount$ = 632
matchlengthCount$ = 640
litlengthCount$ = 648
repOffsets$ = 656
src$ = 664
srcSize$ = 672
notificationLevel$ = 680
ZDICT_countEStats PROC

; 619  : {

	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-344]
	sub	rsp, 536				; 00000218H
	mov	r12, QWORD PTR matchlengthCount$[rbp-256]
	mov	r14, r8
	mov	r13, QWORD PTR litlengthCount$[rbp-256]
	mov	r8, rcx
	movaps	XMMWORD PTR [rax-88], xmm6
	mov	r15, r9
	movaps	XMMWORD PTR [rax-104], xmm7
	movaps	XMMWORD PTR [rax-120], xmm8
	mov	rax, QWORD PTR repOffsets$[rbp-256]

; 624  :     {   size_t const errorCode = ZSTD_compressBegin_usingCDict(esr.zc, esr.dict);

	mov	rdi, QWORD PTR [r8]
	mov	rbx, QWORD PTR [r8+8]
	mov	QWORD PTR repOffsets$GSCopy$1$[rbp-256], rax
	mov	rax, QWORD PTR src$[rbp-256]
	mov	QWORD PTR src$GSCopy$1$[rsp], rax
	mov	eax, 1
	mov	QWORD PTR esr$GSCopy$1$[rbp-256], rcx
	mov	ecx, DWORD PTR [rdx]
	shl	eax, cl
	mov	ecx, 131072				; 00020000H
	cmp	eax, ecx
	cmovg	eax, ecx
	mov	rcx, QWORD PTR srcSize$[rbp-256]
	cdqe
	cmp	rcx, rax
	cmova	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3577 :     ZSTD_frameParameters const fParams = { 0 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };

	xor	esi, esi
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 623  :     if (srcSize > blockSizeMax) srcSize = blockSizeMax;   /* protection vs large samples */

	mov	QWORD PTR srcSize$[rbp-256], rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3577 :     ZSTD_frameParameters const fParams = { 0 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };

	mov	QWORD PTR fParams$3[rbp-256], rsi

; 3543 :     RETURN_ERROR_IF(cdict==NULL, dictionary_wrong, "NULL pointer!");

	test	rdi, rdi
	je	$LN241@ZDICT_coun

; 3544 :     {   ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm0, XMMWORD PTR [rbx+16]
	movups	xmm3, XMMWORD PTR [rbx+80]
	movups	xmm1, XMMWORD PTR [rbx+32]
	movups	xmm4, XMMWORD PTR [rbx+64]
	movups	xmm5, XMMWORD PTR [rbx+96]
	movups	xmm6, XMMWORD PTR [rbx+112]
	movups	xmm7, XMMWORD PTR [rbx+128]
	movups	xmm8, XMMWORD PTR [rbx+144]
	movaps	XMMWORD PTR params$4[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rbx+48]
	movaps	XMMWORD PTR params$4[rbp-240], xmm1
	movaps	XMMWORD PTR params$4[rbp-224], xmm0

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	movdqa	xmm0, xmm3
	psrldq	xmm0, 4
	movd	ecx, xmm0
	movaps	XMMWORD PTR params$4[rbp-208], xmm4
	movaps	XMMWORD PTR params$4[rbp-192], xmm3
	movaps	XMMWORD PTR params$4[rbp-176], xmm5
	movaps	XMMWORD PTR params$4[rbp-160], xmm6
	movaps	XMMWORD PTR params$4[rbp-144], xmm7
	movaps	XMMWORD PTR params$4[rbp-128], xmm8
	mov	DWORD PTR params$1$[rsp], ecx
	cmp	ecx, 3
	je	SHORT $LN34@ZDICT_coun

; 3533 :     return cdict->matchState.cParams;

	movups	xmm0, XMMWORD PTR [rdi+272]
	mov	eax, DWORD PTR [rdi+296]
	movsd	xmm1, QWORD PTR [rdi+288]
	movups	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	jmp	SHORT $LN245@ZDICT_coun
$LN34@ZDICT_coun:

; 4254 :     return ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize);

	mov	r9, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR $T6[rbp-256]
	mov	edx, DWORD PTR [rdi+4924]
	mov	r8, -1
	call	ZSTD_getCParams_internal
	mov	ecx, DWORD PTR params$1$[rsp]
	movups	xmm2, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR $T1[rsp], xmm2
	movsd	QWORD PTR $T1[rsp+16], xmm0
$LN245@ZDICT_coun:

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	mov	DWORD PTR $T1[rsp+24], eax
	lea	rax, QWORD PTR $T1[rsp]
	movups	xmm0, XMMWORD PTR [rax]

; 3546 :                         || pledgedSrcSize < cdict->dictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER
; 3547 :                         || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
; 3548 :                         || cdict->compressionLevel == 0 )
; 3549 :                       && (params.attachDictPref != ZSTD_dictForceLoad) ?
; 3550 :                 ZSTD_getCParamsFromCDict(cdict)
; 3551 :               : ZSTD_getCParams(cdict->compressionLevel,
; 3552 :                                 pledgedSrcSize,
; 3553 :                                 cdict->dictContentSize);
; 3554 :         /* Increase window log to fit the entire dictionary and source if the
; 3555 :          * source size is known. Limit the increase to 19, which is the
; 3556 :          * window log for compression level 1 with the largest source size.
; 3557 :          */
; 3558 :         if (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN) {
; 3559 :             U32 const limitedSrcSize = (U32)MIN(pledgedSrcSize, 1U << 19);
; 3560 :             U32 const limitedSrcLog = limitedSrcSize > 1 ? ZSTD_highbit32(limitedSrcSize - 1) + 1 : 1;
; 3561 :             params.cParams.windowLog = MAX(params.cParams.windowLog, limitedSrcLog);
; 3562 :         }
; 3563 :         params.fParams = fParams;

	mov	DWORD PTR params$4[rbp-216], esi
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR params$4[rbp-252], xmm0
	mov	DWORD PTR params$4[rbp-228], eax
	movsd	xmm0, QWORD PTR fParams$3[rbp-256]
	movsd	QWORD PTR params$4[rbp-224], xmm0
	movsd	QWORD PTR params$4[rbp-236], xmm1

; 3099 :       && (params->attachDictPref != ZSTD_dictForceLoad) ) {

	cmp	QWORD PTR [rdi+8], rsi
	jbe	$LN48@ZDICT_coun
	cmp	ecx, 3
	je	$LN48@ZDICT_coun

; 3100 :         return ZSTD_resetCCtx_usingCDict(cctx, cdict, params, pledgedSrcSize, zbuff);

	mov	r9, -1
	mov	DWORD PTR [rsp+32], esi
	lea	r8, QWORD PTR params$4[rbp-256]
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_resetCCtx_usingCDict
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 625  :         if (ZSTD_isError(errorCode)) { DISPLAYLEVEL(1, "warning : ZSTD_compressBegin_usingCDict failed \n"); return; }

	jbe	$LN15@ZDICT_coun
$LN241@ZDICT_coun:
	cmp	DWORD PTR notificationLevel$[rbp-256], 1
	jb	SHORT $LN20@ZDICT_coun
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294963416
	call	fprintf
$LN246@ZDICT_coun:

; 667  :     }   }   }
; 668  : }

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN20@ZDICT_coun:
	lea	r11, QWORD PTR [rsp+536]
	movaps	xmm6, XMMWORD PTR [r11-24]
	movaps	xmm7, XMMWORD PTR [r11-40]
	movaps	xmm8, XMMWORD PTR [r11-56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN48@ZDICT_coun:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	movaps	xmm0, XMMWORD PTR params$4[rbp-256]
	lea	rdx, QWORD PTR $T5[rbp-256]
	movaps	xmm1, XMMWORD PTR params$4[rbp-240]
	xor	r9d, r9d
	movaps	XMMWORD PTR $T5[rbp-256], xmm0
	mov	rcx, rbx
	movaps	xmm0, XMMWORD PTR params$4[rbp-224]
	movaps	XMMWORD PTR $T5[rbp-240], xmm1
	lea	r8, QWORD PTR [r9-1]
	movaps	XMMWORD PTR $T5[rbp-224], xmm0
	movaps	XMMWORD PTR $T5[rbp-208], xmm4
	movaps	XMMWORD PTR $T5[rbp-192], xmm3
	movaps	XMMWORD PTR $T5[rbp-176], xmm5
	movaps	XMMWORD PTR $T5[rbp-160], xmm6
	movaps	XMMWORD PTR $T5[rbp-144], xmm7
	movaps	XMMWORD PTR $T5[rbp-128], xmm8
	mov	DWORD PTR [rsp+32], esi
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	ja	$LN241@ZDICT_coun

; 3104 :                                      ZSTDcrp_makeClean, zbuff) , "");
; 3105 :     {   size_t const dictID = cdict ?

	mov	rax, QWORD PTR [rbx+992]
	lea	rcx, QWORD PTR [rbx+160]
	mov	QWORD PTR [rsp+72], rax
	lea	r9, QWORD PTR [rbx+312]
	mov	rax, QWORD PTR [rdi+8]
	lea	r8, QWORD PTR [rbx+648]
	mov	DWORD PTR [rsp+64], esi
	lea	rdx, QWORD PTR [rbx+776]
	mov	DWORD PTR [rsp+56], esi
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR [rbx+760]
	call	ZSTD_compress_insertDictionary
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3115 :         FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");

	ja	$LN241@ZDICT_coun

; 3116 :         assert(dictID <= UINT_MAX);
; 3117 :         cctx->dictID = (U32)dictID;

	mov	DWORD PTR [rbx+304], eax
$LN15@ZDICT_coun:

; 2805 :     return MIN (ZSTD_BLOCKSIZE_MAX, (U32)1 << cParams.windowLog);

	mov	ecx, DWORD PTR [rbx+164]
	mov	eax, 1

; 2812 :       RETURN_ERROR_IF(srcSize > blockSizeMax, srcSize_wrong, "input is larger than a block"); }

	mov	rdi, QWORD PTR srcSize$[rbp-256]

; 2805 :     return MIN (ZSTD_BLOCKSIZE_MAX, (U32)1 << cParams.windowLog);

	mov	r8d, 131072				; 00020000H
	shl	eax, cl
	cmp	eax, r8d
	cmova	eax, r8d

; 2812 :       RETURN_ERROR_IF(srcSize > blockSizeMax, srcSize_wrong, "input is larger than a block"); }

	cmp	rdi, rax
	ja	$LN242@ZDICT_coun

; 2813 : 
; 2814 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 0 /* frame mode */, 0 /* last chunk */);

	mov	rdx, QWORD PTR esr$GSCopy$1$[rbp-256]
	mov	rcx, rbx
	mov	r9, QWORD PTR src$GSCopy$1$[rsp]
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+40], esi
	mov	rdx, QWORD PTR [rdx+16]
	mov	QWORD PTR [rsp+32], rdi
	call	ZSTD_compressContinue_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 629  :     if (ZSTD_isError(cSize)) { DISPLAYLEVEL(3, "warning : could not compress sample size %u \n", (unsigned)srcSize); return; }

	ja	$LN242@ZDICT_coun

; 630  : 
; 631  :     if (cSize) {  /* if == 0; block is not compressible */

	test	rax, rax
	je	$LN20@ZDICT_coun

; 632  :         const seqStore_t* const seqStorePtr = ZSTD_getSeqStore(esr.zc);

	add	rbx, 568				; 00000238H

; 633  : 
; 634  :         /* literals stats */
; 635  :         {   const BYTE* bytePtr;
; 636  :             for(bytePtr = seqStorePtr->litStart; bytePtr < seqStorePtr->lit; bytePtr++)

	mov	rcx, QWORD PTR [rbx+16]
	cmp	rcx, QWORD PTR [rbx+24]
	jae	SHORT $LN3@ZDICT_coun
	npad	3
$LL4@ZDICT_coun:

; 637  :                 countLit[*bytePtr]++;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	inc	DWORD PTR [r14+rax*4]
	cmp	rcx, QWORD PTR [rbx+24]
	jb	SHORT $LL4@ZDICT_coun
$LN3@ZDICT_coun:

; 638  :         }
; 639  : 
; 640  :         /* seqStats */
; 641  :         {   U32 const nbSeq = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rdi, QWORD PTR [rbx+8]

; 642  :             ZSTD_seqToCodes(seqStorePtr);

	mov	rcx, rbx
	sub	rdi, QWORD PTR [rbx]
	sar	rdi, 3
	call	ZSTD_seqToCodes

; 643  : 
; 644  :             {   const BYTE* codePtr = seqStorePtr->ofCode;

	mov	rcx, QWORD PTR [rbx+48]

; 645  :                 U32 u;
; 646  :                 for (u=0; u<nbSeq; u++) offsetcodeCount[codePtr[u]]++;

	test	edi, edi
	je	$LN20@ZDICT_coun
	mov	edx, edi
$LL7@ZDICT_coun:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	inc	DWORD PTR [r15+rax*4]
	sub	rdx, 1
	jne	SHORT $LL7@ZDICT_coun
	mov	rcx, QWORD PTR [rbx+40]
	mov	edx, edi
	npad	8
$LL10@ZDICT_coun:

; 647  :             }
; 648  : 
; 649  :             {   const BYTE* codePtr = seqStorePtr->mlCode;
; 650  :                 U32 u;
; 651  :                 for (u=0; u<nbSeq; u++) matchlengthCount[codePtr[u]]++;

	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	inc	DWORD PTR [r12+rax*4]
	sub	rdx, 1
	jne	SHORT $LL10@ZDICT_coun
	mov	rcx, QWORD PTR [rbx+32]
	mov	edx, edi
	npad	9
$LL13@ZDICT_coun:

; 652  :             }
; 653  : 
; 654  :             {   const BYTE* codePtr = seqStorePtr->llCode;
; 655  :                 U32 u;
; 656  :                 for (u=0; u<nbSeq; u++) litlengthCount[codePtr[u]]++;

	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	inc	DWORD PTR [r13+rax*4]
	sub	rdx, 1
	jne	SHORT $LL13@ZDICT_coun

; 657  :             }
; 658  : 
; 659  :             if (nbSeq >= 2) { /* rep offsets */

	cmp	edi, 2
	jb	$LN20@ZDICT_coun

; 660  :                 const seqDef* const seq = seqStorePtr->sequencesStart;

	mov	rcx, QWORD PTR [rbx]

; 661  :                 U32 offset1 = seq[0].offset - 3;
; 662  :                 U32 offset2 = seq[1].offset - 3;
; 663  :                 if (offset1 >= MAXREPOFFSET) offset1 = 0;
; 664  :                 if (offset2 >= MAXREPOFFSET) offset2 = 0;

	mov	eax, esi
	mov	edx, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rcx+8]
	add	edx, -3					; fffffffdH
	add	ecx, -3					; fffffffdH
	cmp	edx, 1024				; 00000400H
	cmovb	eax, edx

; 665  :                 repOffsets[offset1] += 3;

	mov	rdx, QWORD PTR repOffsets$GSCopy$1$[rbp-256]
	add	DWORD PTR [rdx+rax*4], 3
	cmp	ecx, 1024				; 00000400H
	cmovb	esi, ecx

; 666  :                 repOffsets[offset2] += 1;

	inc	DWORD PTR [rdx+rsi*4]
	jmp	$LN20@ZDICT_coun
$LN242@ZDICT_coun:

; 629  :     if (ZSTD_isError(cSize)) { DISPLAYLEVEL(3, "warning : could not compress sample size %u \n", (unsigned)srcSize); return; }

	cmp	DWORD PTR notificationLevel$[rbp-256], 3
	jb	$LN20@ZDICT_coun
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294963415
	mov	rcx, rax
	call	fprintf
	jmp	$LN246@ZDICT_coun
ZDICT_countEStats ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
fileSizes$ = 16
nbFiles$ = 24
ZDICT_totalSampleSize PROC

; 671  : {

	push	rdi

; 672  :     size_t total=0;

	xor	r8d, r8d
	mov	edi, edx
	mov	r9, rcx
	mov	r11d, r8d
	mov	r10d, r8d

; 673  :     unsigned u;
; 674  :     for (u=0; u<nbFiles; u++) total += fileSizes[u];

	cmp	edx, 4
	jb	SHORT $LN9@ZDICT_tota

; 672  :     size_t total=0;

	and	edx, -4					; fffffffcH
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	npad	2
$LL4@ZDICT_tota:

; 673  :     unsigned u;
; 674  :     for (u=0; u<nbFiles; u++) total += fileSizes[u];

	mov	eax, r10d
	movdqu	xmm0, XMMWORD PTR [rcx+rax*8]
	lea	eax, DWORD PTR [r10+2]
	add	r10d, 4
	paddq	xmm0, xmm2
	movdqa	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rcx+rax*8]
	paddq	xmm0, xmm1
	movdqa	xmm1, xmm0
	cmp	r10d, edx
	jb	SHORT $LL4@ZDICT_tota

; 672  :     size_t total=0;

	paddq	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddq	xmm1, xmm0
	movq	r11, xmm1
$LN9@ZDICT_tota:

; 673  :     unsigned u;
; 674  :     for (u=0; u<nbFiles; u++) total += fileSizes[u];

	mov	rdx, r8
	cmp	r10d, edi
	jae	SHORT $LN20@ZDICT_tota
	mov	ecx, edi
	mov	eax, r10d
	sub	ecx, r10d
	cmp	ecx, 2
	jb	SHORT $LC14@ZDICT_tota
	mov	ecx, edi
	mov	QWORD PTR [rsp+16], rbx
	sub	ecx, r10d
	sub	ecx, 2
	shr	ecx, 1
	inc	ecx
	mov	ebx, ecx
	lea	ecx, DWORD PTR [r10+rcx*2]
	npad	4
$LL16@ZDICT_tota:
	add	r8, QWORD PTR [r9+rax*8]
	add	rdx, QWORD PTR [r9+rax*8+8]
	add	rax, 2
	sub	rbx, 1
	jne	SHORT $LL16@ZDICT_tota
	mov	rbx, QWORD PTR [rsp+16]
	cmp	ecx, edi
	jae	SHORT $LN15@ZDICT_tota
$LC14@ZDICT_tota:
	add	r11, QWORD PTR [r9+rax*8]
$LN15@ZDICT_tota:
	lea	rax, QWORD PTR [rdx+r8]
	add	rax, r11

; 676  : }

	pop	rdi
	ret	0
$LN20@ZDICT_tota:

; 675  :     return total;

	mov	rax, r11

; 676  : }

	pop	rdi
	ret	0
ZDICT_totalSampleSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
table$ = 8
val$ = 16
count$ = 24
ZDICT_insertSortCount PROC

; 682  :     U32 u;
; 683  :     table[ZSTD_REP_NUM].offset = val;

	lea	r9, QWORD PTR [rcx+24]

; 684  :     table[ZSTD_REP_NUM].count = count;

	mov	DWORD PTR [rcx+28], r8d
	mov	DWORD PTR [r9], edx
	mov	r10, rcx

; 685  :     for (u=ZSTD_REP_NUM; u>0; u--) {

	mov	r8d, 3
	npad	12
$LL4@ZDICT_inse:

; 686  :         offsetCount_t tmp;
; 687  :         if (table[u-1].count >= table[u].count) break;

	mov	eax, DWORD PTR [r9+4]
	lea	edx, DWORD PTR [r8-1]
	cmp	DWORD PTR [r10+rdx*8+4], eax
	jae	SHORT $LN8@ZDICT_inse

; 688  :         tmp = table[u-1];
; 689  :         table[u-1] = table[u];

	mov	rcx, QWORD PTR [r9]
	mov	rax, QWORD PTR [r10+rdx*8]

; 690  :         table[u] = tmp;

	mov	QWORD PTR [r9], rax
	sub	r9, 8
	mov	QWORD PTR [r10+rdx*8], rcx
	add	r8d, -1					; ffffffffH
	jne	SHORT $LL4@ZDICT_inse
$LN8@ZDICT_inse:

; 691  :     }
; 692  : }

	ret	0
ZDICT_insertSortCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
countLit$ = 8
ZDICT_flatLit PROC

; 700  :     int u;
; 701  :     for (u=1; u<256; u++) countLit[u] = 2;

	lea	rax, QWORD PTR [rcx+4]
	mov	edx, 15
	mov	r8, 8589934594				; 0000000200000002H
	npad	13
$LL10@ZDICT_flat:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	sub	rdx, 1
	jne	SHORT $LL10@ZDICT_flat
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+32], r8
	mov	QWORD PTR [rax+40], r8
	mov	QWORD PTR [rax+48], r8
	mov	DWORD PTR [rax+56], r8d

; 702  :     countLit[0]   = 4;

	mov	DWORD PTR [rcx], 4

; 703  :     countLit[253] = 1;

	mov	DWORD PTR [rcx+1012], 1

; 704  :     countLit[254] = 1;

	mov	DWORD PTR [rcx+1016], 1

; 705  : }

	ret	0
ZDICT_flatLit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
eSize$1$ = 80
r$1 = 80
maxDstSize$GSCopy$1$ = 88
tv5734 = 88
r$2 = 88
offcodeMax$1$ = 96
dstPtr$1$ = 96
$T3 = 112
$T4 = 112
$T5 = 112
$T6 = 112
$T7 = 112
$T8 = 112
cMem$9 = 112
$T10 = 112
$T11 = 112
dictBuffer$GSCopy$1$ = 144
$T12 = 144
cMem$13 = 160
$T14 = 160
esr$ = 160
esr$1$ = 192
srcBuffer$GSCopy$1$ = 200
dstBuffer$GSCopy$1$ = 208
workspace$15 = 224
workspace$16 = 224
bestRepOffset$ = 4576
matchLengthNCount$ = 4608
offcodeCount$ = 4608
litLengthCount$ = 4736
matchLengthCount$ = 4880
countLit$ = 5104
hufTablehb$ = 6128
repOffset$ = 7152
cp$17 = 11248
$T18 = 11248
$T19 = 11248
litLengthNCount$ = 11248
offcodeNCount$ = 11328
params$ = 11328
__$ArrayPad$ = 11392
dstBuffer$ = 11504
maxDstSize$dead$ = 11512
compressionLevel$ = 11520
srcBuffer$ = 11528
fileSizes$ = 11536
nbFiles$ = 11544
dictBuffer$ = 11552
dictBufferSize$ = 11560
notificationLevel$ = 11568
ZDICT_analyzeEntropy PROC

; 713  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-11184]
	mov	eax, 11440				; 00002cb0H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rax, QWORD PTR dictBuffer$[rbp-256]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ebx, ebx
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 713  : {

	mov	r15, QWORD PTR dictBufferSize$[rbp-256]
	xorps	xmm0, xmm0
	mov	rsi, QWORD PTR fileSizes$[rbp-256]
	mov	r12d, r8d

; 726  :     ZSTD_parameters params;
; 727  :     U32 u, huffLog = 11, Offlog = OffFSELog, mlLog = MLFSELog, llLog = LLFSELog, total;
; 728  :     size_t pos = 0, errorCode;
; 729  :     size_t eSize = 0;
; 730  :     size_t const totalSrcSize = ZDICT_totalSampleSize(fileSizes, nbFiles);

	mov	r13d, DWORD PTR nbFiles$[rbp-256]
	mov	r14d, ebx
	mov	QWORD PTR dictBuffer$GSCopy$1$[rbp-256], rax
	mov	edx, r13d
	lea	eax, DWORD PTR [r15+131072]
	mov	QWORD PTR dstBuffer$GSCopy$1$[rbp-256], rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, ebx
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 713  : {

	mov	QWORD PTR srcBuffer$GSCopy$1$[rbp-256], r9
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$2[rsp], ebx

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 725  :     EStats_ress_t esr = { NULL, NULL, NULL };

	mov	QWORD PTR esr$1$[rbp-256], rbx

; 726  :     ZSTD_parameters params;
; 727  :     U32 u, huffLog = 11, Offlog = OffFSELog, mlLog = MLFSELog, llLog = LLFSELog, total;
; 728  :     size_t pos = 0, errorCode;
; 729  :     size_t eSize = 0;
; 730  :     size_t const totalSrcSize = ZDICT_totalSampleSize(fileSizes, nbFiles);

	mov	rcx, rsi
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	DWORD PTR offcodeMax$1$[rsp], eax
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 725  :     EStats_ress_t esr = { NULL, NULL, NULL };

	movdqu	XMMWORD PTR esr$[rbp-256], xmm0

; 726  :     ZSTD_parameters params;
; 727  :     U32 u, huffLog = 11, Offlog = OffFSELog, mlLog = MLFSELog, llLog = LLFSELog, total;
; 728  :     size_t pos = 0, errorCode;
; 729  :     size_t eSize = 0;
; 730  :     size_t const totalSrcSize = ZDICT_totalSampleSize(fileSizes, nbFiles);

	call	ZDICT_totalSampleSize
	mov	rdi, rax

; 731  :     size_t const averageSampleSize = totalSrcSize / (nbFiles + !nbFiles);

	test	r13d, r13d
	mov	eax, ebx
	sete	al
	xor	edx, edx
	lea	ecx, DWORD PTR [rax+r13]
	mov	rax, rdi
	div	rcx

; 732  :     BYTE* dstPtr = (BYTE*)dstBuffer;
; 733  : 
; 734  :     /* init */
; 735  :     DEBUGLOG(4, "ZDICT_analyzeEntropy");
; 736  :     if (offcodeMax>OFFCODE_MAX) { eSize = ERROR(dictionaryCreation_failed); goto _cleanup; }   /* too large dictionary */

	mov	edx, DWORD PTR offcodeMax$1$[rsp]
	mov	rbx, rax
	cmp	edx, 30
	jbe	SHORT $LN29@ZDICT_anal
	mov	QWORD PTR eSize$1$[rsp], -34		; ffffffffffffffdeH
	jmp	$LN354@ZDICT_anal
$LN29@ZDICT_anal:
	movaps	XMMWORD PTR [rsp+11424], xmm6

; 737  :     for (u=0; u<256; u++) countLit[u] = 1;   /* any character must be described */

	lea	rax, QWORD PTR countLit$[rbp-256]
	movaps	XMMWORD PTR [rsp+11408], xmm7
	mov	r8, 4294967297				; 0000000100000001H
	mov	ecx, 16
	npad	5
$LL599@ZDICT_anal:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	sub	rcx, 1
	jne	SHORT $LL599@ZDICT_anal
	inc	edx

; 738  :     for (u=0; u<=offcodeMax; u++) offcodeCount[u] = 1;

	lea	rdi, QWORD PTR offcodeCount$[rbp-256]
	mov	eax, 1
	mov	ecx, edx
	rep stosd

; 739  :     for (u=0; u<=MaxML; u++) matchLengthCount[u] = 1;

	mov	ecx, 3
	mov	DWORD PTR tv5734[rsp], edx
	lea	rax, QWORD PTR matchLengthCount$[rbp-256]
	npad	5
$LL598@ZDICT_anal:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	sub	rcx, 1
	jne	SHORT $LL598@ZDICT_anal
	mov	QWORD PTR [rax], r8

; 740  :     for (u=0; u<=MaxLL; u++) litLengthCount[u] = 1;

	mov	ecx, 2
	mov	QWORD PTR [rax+8], r8
	mov	DWORD PTR [rax+16], r8d
	lea	rax, QWORD PTR litLengthCount$[rbp-256]
$LL597@ZDICT_anal:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	sub	rcx, 1
	jne	SHORT $LL597@ZDICT_anal
	mov	QWORD PTR [rax], r8

; 741  :     memset(repOffset, 0, sizeof(repOffset));

	lea	rcx, QWORD PTR repOffset$[rbp-256]
	mov	QWORD PTR [rax+8], r8
	xor	edx, edx
	mov	r8d, 4096				; 00001000H
	call	memset

; 742  :     repOffset[1] = repOffset[4] = repOffset[8] = 1;
; 743  :     memset(bestRepOffset, 0, sizeof(bestRepOffset));

	xor	r11d, r11d
	mov	r10d, 1

; 745  :     params = ZSTD_getParams(compressionLevel, averageSampleSize, dictBufferSize);

	test	r12d, r12d
	mov	DWORD PTR repOffset$[rbp-224], r10d
	mov	edx, 3
	mov	DWORD PTR repOffset$[rbp-240], r10d
	cmovne	edx, r12d
	mov	DWORD PTR repOffset$[rbp-252], r10d
	mov	QWORD PTR bestRepOffset$[rbp-256], r11
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR bestRepOffset$[rbp-248], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4276 :     if (srcSizeHint == 0) srcSizeHint = ZSTD_CONTENTSIZE_UNKNOWN;

	test	rbx, rbx
	jne	SHORT $LN58@ZDICT_anal
	lea	rbx, QWORD PTR [r10-2]

; 4233 :     size_t const addedSize = unknown && dictSize > 0 ? 500 : 0;

	jmp	SHORT $LN572@ZDICT_anal
$LN58@ZDICT_anal:
	cmp	rbx, -1
	jne	SHORT $LN68@ZDICT_anal
$LN572@ZDICT_anal:
	test	r15, r15
	je	SHORT $LN68@ZDICT_anal
	mov	eax, 500				; 000001f4H
$LN70@ZDICT_anal:

; 4234 :     U64 const rSize = unknown && dictSize == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : srcSizeHint+dictSize+addedSize;

	lea	r8, QWORD PTR [r15+rax]
	add	r8, rbx
$LN71@ZDICT_anal:

; 4235 :     U32 const tableID = (rSize <= 256 KB) + (rSize <= 128 KB) + (rSize <= 16 KB);
; 4236 :     int row = compressionLevel;
; 4237 :     DEBUGLOG(5, "ZSTD_getCParams_internal (cLevel=%i)", compressionLevel);
; 4238 :     if (compressionLevel == 0) row = ZSTD_CLEVEL_DEFAULT;   /* 0 == default */

	test	edx, edx
	jne	SHORT $LN63@ZDICT_anal
	lea	edi, QWORD PTR [rdx+3]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 270  :             bitCount -= 16;

	jmp	SHORT $LN65@ZDICT_anal
$LN68@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4233 :     size_t const addedSize = unknown && dictSize > 0 ? 500 : 0;

	mov	rax, r11

; 4234 :     U64 const rSize = unknown && dictSize == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : srcSizeHint+dictSize+addedSize;

	cmp	rbx, -1
	jne	SHORT $LN70@ZDICT_anal
	test	r15, r15
	jne	SHORT $LN70@ZDICT_anal
	mov	r8, rbx
	jmp	SHORT $LN71@ZDICT_anal
$LN63@ZDICT_anal:

; 4239 :     if (compressionLevel < 0) row = 0;   /* entry 0 is baseline for fast mode */
; 4240 :     if (compressionLevel > ZSTD_MAX_CLEVEL) row = ZSTD_MAX_CLEVEL;

	test	edx, edx
	mov	eax, 22
	mov	edi, r11d
	cmovns	edi, edx
	cmp	edx, eax
	cmovg	edi, eax
$LN65@ZDICT_anal:

; 4241 :     {   ZSTD_compressionParameters cp = ZSTD_defaultCParameters[tableID][row];

	cmp	r8, 16384				; 00004000H
	mov	r9d, 23
	mov	rcx, r11
	mov	rax, r11
	cmovbe	rcx, r9
	cmp	r8, 262144				; 00040000H
	cmovbe	rax, r9
	add	rcx, rax
	mov	rax, r11
	cmp	r8, 131072				; 00020000H
	cmovbe	rax, r9
	add	rcx, rax
	movsxd	rax, edi
	add	rcx, rax
	imul	rax, rcx, 28
	lea	rcx, OFFSET FLAT:ZSTD_defaultCParameters
	movsd	xmm0, QWORD PTR [rax+rcx+16]
	mov	r8d, DWORD PTR [rax+rcx+24]
	movsd	QWORD PTR cp$17[rbp-240], xmm0
	movups	xmm1, XMMWORD PTR [rax+rcx]
	movups	XMMWORD PTR cp$17[rbp-256], xmm1

; 4242 :         if (compressionLevel < 0) cp.targetLength = (unsigned)(-compressionLevel);   /* acceleration factor */

	test	edx, edx
	jns	SHORT $LN66@ZDICT_anal
	neg	edx
	mov	DWORD PTR cp$17[rbp-236], edx
	movsd	xmm0, QWORD PTR cp$17[rbp-240]
$LN66@ZDICT_anal:

; 4243 :         /* refine parameters based on srcSize & dictSize */
; 4244 :         return ZSTD_adjustCParams_internal(cp, srcSizeHint, dictSize);

	movaps	XMMWORD PTR $T7[rsp], xmm1
	movaps	xmm3, xmm0

; 1040 :     if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)

	mov	r12d, 6
	test	r15, r15
	je	SHORT $LN73@ZDICT_anal
	cmp	rbx, -1
	jne	SHORT $LN73@ZDICT_anal

; 1041 :         srcSize = minSrcSize;

	mov	ebx, 513				; 00000201H

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	jmp	SHORT $LN574@ZDICT_anal
$LN73@ZDICT_anal:
	cmp	rbx, 1073741824				; 40000000H
	jae	SHORT $LN600@ZDICT_anal
$LN574@ZDICT_anal:
	cmp	r15, 1073741824				; 40000000H
	jae	SHORT $LN600@ZDICT_anal

; 1046 :         U32 const tSize = (U32)(srcSize + dictSize);

	lea	eax, DWORD PTR [r15+rbx]

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	cmp	eax, 64					; 00000040H
	jae	SHORT $LN80@ZDICT_anal

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	mov	edx, DWORD PTR $T7[rsp]
	mov	eax, r12d
	cmp	DWORD PTR cp$17[rbp-256], eax
	cmova	edx, eax
	jmp	SHORT $LN75@ZDICT_anal
$LN80@ZDICT_anal:
	mov	edx, DWORD PTR $T7[rsp]
	dec	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
	mov	DWORD PTR r$1[rsp], r11d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	inc	eax

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	cmp	DWORD PTR cp$17[rbp-256], eax
	cmova	edx, eax
	jmp	SHORT $LN75@ZDICT_anal
$LN600@ZDICT_anal:

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	mov	edx, DWORD PTR $T7[rsp]
$LN75@ZDICT_anal:

; 1051 :     }
; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	eax, DWORD PTR $T7[rsp+8]
	lea	ecx, DWORD PTR [rdx+1]
	cmp	eax, ecx
	cmova	eax, ecx

; 1022 :     return hashLog - btScale;

	mov	ecx, DWORD PTR $T7[rsp+4]

; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	DWORD PTR $T7[rsp+8], eax

; 1021 :     U32 const btScale = ((U32)strat >= (U32)ZSTD_btlazy2);

	cmp	r8d, r12d
	mov	eax, r11d

; 1022 :     return hashLog - btScale;

	mov	edi, ecx
	setae	al
	sub	edi, eax

; 1054 :         if (cycleLog > cPar.windowLog)

	cmp	edi, edx
	jbe	SHORT $LN77@ZDICT_anal

; 1055 :             cPar.chainLog -= (cycleLog - cPar.windowLog);

	mov	eax, edx
	sub	eax, edi
	add	ecx, eax
	mov	DWORD PTR $T7[rsp+4], ecx
$LN77@ZDICT_anal:
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 747  :     esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);

	movups	xmm1, XMMWORD PTR ZSTD_defaultCMem
	mov	rcx, QWORD PTR dictBuffer$GSCopy$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	eax, 10
	cmp	edx, eax

; 4266 :     params.cParams = cParams;

	mov	DWORD PTR $T18[rbp-232], r8d

; 4267 :     params.fParams.contentSizeFlag = 1;

	mov	DWORD PTR $T18[rbp-228], r10d
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 747  :     esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);

	mov	r9d, r10d
	movups	xmm0, XMMWORD PTR $T18[rbp-240]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmovb	edx, eax

; 4265 :     memset(&params, 0, sizeof(params));

	mov	QWORD PTR $T18[rbp-224], r11

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	DWORD PTR $T7[rsp], edx
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 747  :     esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);

	lea	rax, QWORD PTR $T11[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4266 :     params.cParams = cParams;

	movaps	xmm2, XMMWORD PTR $T7[rsp]
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 745  :     params = ZSTD_getParams(compressionLevel, averageSampleSize, dictBufferSize);

	movsd	xmm0, xmm3
	movups	XMMWORD PTR $T18[rbp-240], xmm0

; 747  :     esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);

	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T19[rbp-256]
	movups	XMMWORD PTR params$[rbp-240], xmm0
	mov	rdx, r15
	mov	DWORD PTR $T19[rbp-232], r8d
	movsd	xmm0, QWORD PTR $T18[rbp-224]
	mov	r8d, r10d
	movsd	QWORD PTR params$[rbp-224], xmm0
	movsd	xmm0, QWORD PTR ZSTD_defaultCMem+16
	movsd	QWORD PTR $T11[rbp-240], xmm0
	movups	XMMWORD PTR params$[rbp-256], xmm2
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T11[rsp], xmm1
	movaps	XMMWORD PTR $T19[rbp-256], xmm2
	movsd	QWORD PTR $T19[rbp-240], xmm3
	call	ZSTD_createCDict_advanced
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	movups	xmm6, XMMWORD PTR ZSTD_defaultCMem
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	mov	ecx, 1160				; 00000488H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 747  :     esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);

	mov	rbx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	movsd	xmm7, QWORD PTR ZSTD_defaultCMem+16
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 747  :     esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);

	mov	QWORD PTR esr$[rbp-256], rax
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	QWORD PTR $T12[rbp-256], rax
	mov	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 87   :         if (!cctx) return NULL;

	test	rax, rax
	jne	SHORT $LN90@ZDICT_anal
	mov	QWORD PTR $T12[rbp-256], rax
	jmp	SHORT $LN88@ZDICT_anal
$LN90@ZDICT_anal:

; 88   :         ZSTD_initCCtx(cctx, customMem);

	lea	rdx, QWORD PTR $T8[rsp]
	movaps	XMMWORD PTR $T8[rsp], xmm6
	mov	rcx, rax
	movsd	QWORD PTR $T8[rbp-240], xmm7
	call	ZSTD_initCCtx
$LN88@ZDICT_anal:
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 749  :     esr.workPlace = malloc(ZSTD_BLOCKSIZE_MAX);

	mov	ecx, 131072				; 00020000H
	mov	QWORD PTR esr$[rbp-248], rdi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR esr$1$[rbp-256], rax
	mov	QWORD PTR esr$[rbp-240], rax

; 750  :     if (!esr.dict || !esr.zc || !esr.workPlace) {

	test	rbx, rbx
	je	$LN32@ZDICT_anal
	test	rdi, rdi
	je	$LN32@ZDICT_anal
	test	rax, rax
	je	$LN32@ZDICT_anal

; 753  :         goto _cleanup;
; 754  :     }
; 755  : 
; 756  :     /* collect stats on all samples */
; 757  :     for (u=0; u<nbFiles; u++) {

	mov	r15d, DWORD PTR notificationLevel$[rbp-256]
	test	r13d, r13d
	je	$LN15@ZDICT_anal
	movsd	xmm6, QWORD PTR esr$[rbp-240]
	mov	rdi, r13
	movdqu	xmm7, XMMWORD PTR esr$[rbp-256]
	mov	rbx, QWORD PTR srcBuffer$GSCopy$1$[rbp-256]
	npad	10
$LL16@ZDICT_anal:

; 758  :         ZDICT_countEStats(esr, &params,

	mov	rax, QWORD PTR [rsi]
	lea	rcx, QWORD PTR [rbx+r14]
	mov	DWORD PTR [rsp+72], r15d
	lea	r9, QWORD PTR offcodeCount$[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	lea	r8, QWORD PTR countLit$[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	lea	rax, QWORD PTR repOffset$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	lea	rdx, QWORD PTR params$[rbp-256]
	lea	rax, QWORD PTR litLengthCount$[rbp-256]
	movaps	XMMWORD PTR $T10[rsp], xmm7
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR $T10[rsp]
	lea	rax, QWORD PTR matchLengthCount$[rbp-256]
	movsd	QWORD PTR $T10[rbp-240], xmm6
	mov	QWORD PTR [rsp+32], rax
	call	ZDICT_countEStats

; 759  :                           countLit, offcodeCount, matchLengthCount, litLengthCount, repOffset,
; 760  :                          (const char*)srcBuffer + pos, fileSizes[u],
; 761  :                           notificationLevel);
; 762  :         pos += fileSizes[u];

	add	r14, QWORD PTR [rsi]
	lea	rsi, QWORD PTR [rsi+8]
	sub	rdi, 1
	jne	SHORT $LL16@ZDICT_anal
$LN15@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	lea	rax, QWORD PTR workspace$16[rbp-256]
	mov	QWORD PTR [rsp+40], 4352		; 00001100H
	mov	r9d, 11
	mov	QWORD PTR [rsp+32], rax
	mov	r8d, 255				; 000000ffH
	lea	rdx, QWORD PTR countLit$[rbp-256]
	lea	rcx, QWORD PTR hufTablehb$[rbp-256]
	call	HUF_buildCTable_wksp
	mov	QWORD PTR eSize$1$[rsp], rax
	mov	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 767  :         if (HUF_isError(maxNbBits)) {

	jbe	SHORT $LN34@ZDICT_anal

; 768  :             eSize = maxNbBits;
; 769  :             DISPLAYLEVEL(1, " HUF_buildCTable error \n");

	cmp	r15d, 1
	jb	$LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963413
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3468 :     if (cdict==NULL) return 0;   /* support free on NULL */

	jmp	$LN629@ZDICT_anal
$LN34@ZDICT_anal:
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 772  :         if (maxNbBits==8) {  /* not compressible : will fail on HUF_writeCTable() */

	mov	r14d, DWORD PTR notificationLevel$[rbp-256]
	cmp	rax, 8
	jne	$LN611@ZDICT_anal

; 773  :             DISPLAYLEVEL(2, "warning : pathological dataset : literals are not compressible : samples are noisy or too regular \n");

	cmp	r14d, 2
	jb	SHORT $LN37@ZDICT_anal
	lea	ecx, QWORD PTR [rax-6]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294963412
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN37@ZDICT_anal:

; 701  :     for (u=1; u<256; u++) countLit[u] = 2;

	mov	rdx, 8589934594				; 0000000200000002H
	lea	rax, QWORD PTR countLit$[rbp-252]
	mov	ecx, 15
	npad	7
$LL596@ZDICT_anal:
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], rdx
	mov	QWORD PTR [rax-32], rdx
	mov	QWORD PTR [rax-24], rdx
	mov	QWORD PTR [rax-16], rdx
	mov	QWORD PTR [rax-8], rdx
	sub	rcx, 1
	jne	SHORT $LL596@ZDICT_anal
	mov	QWORD PTR [rax], rdx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	lea	r9d, QWORD PTR [rcx+11]
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 701  :     for (u=1; u<256; u++) countLit[u] = 2;

	mov	QWORD PTR [rax+8], rdx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	lea	rcx, QWORD PTR hufTablehb$[rbp-256]
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 701  :     for (u=1; u<256; u++) countLit[u] = 2;

	mov	QWORD PTR [rax+16], rdx

; 703  :     countLit[253] = 1;

	mov	r15d, 1
	mov	QWORD PTR [rax+24], rdx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	mov	r8d, 255				; 000000ffH
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 701  :     for (u=1; u<256; u++) countLit[u] = 2;

	mov	QWORD PTR [rax+32], rdx
	mov	QWORD PTR [rax+40], rdx
	mov	QWORD PTR [rax+48], rdx
	mov	DWORD PTR [rax+56], edx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	lea	rax, QWORD PTR workspace$15[rbp-256]
	mov	QWORD PTR [rsp+40], 4352		; 00001100H
	lea	rdx, QWORD PTR countLit$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 702  :     countLit[0]   = 4;

	mov	DWORD PTR countLit$[rbp-256], 4

; 703  :     countLit[253] = 1;

	mov	DWORD PTR countLit$[rbp+756], r15d

; 704  :     countLit[254] = 1;

	mov	DWORD PTR countLit$[rbp+760], r15d
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	call	HUF_buildCTable_wksp
	mov	rcx, rax
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 772  :         if (maxNbBits==8) {  /* not compressible : will fail on HUF_writeCTable() */

	jmp	SHORT $LN36@ZDICT_anal
$LN611@ZDICT_anal:
	mov	r15d, 1
$LN36@ZDICT_anal:

; 774  :             ZDICT_flatLit(countLit);  /* replace distribution by a fake "mostly flat but still compressible" distribution, that HUF_writeCTable() can encode */
; 775  :             maxNbBits = HUF_buildCTable (hufTable, countLit, 255, huffLog);
; 776  :             assert(maxNbBits==9);
; 777  :         }
; 778  :         huffLog = (U32)maxNbBits;

	mov	ebx, ecx
	lea	r10, QWORD PTR repOffset$[rbp-252]
	mov	r9d, r15d
	npad	5
$LL19@ZDICT_anal:

; 684  :     table[ZSTD_REP_NUM].count = count;

	mov	eax, DWORD PTR [r10]
	lea	rdx, QWORD PTR bestRepOffset$[rbp-232]
	mov	DWORD PTR bestRepOffset$[rbp-228], eax

; 685  :     for (u=ZSTD_REP_NUM; u>0; u--) {

	mov	edi, 3
	mov	DWORD PTR bestRepOffset$[rbp-232], r9d
	npad	4
$LL109@ZDICT_anal:

; 686  :         offsetCount_t tmp;
; 687  :         if (table[u-1].count >= table[u].count) break;

	lea	eax, DWORD PTR [rdi-1]
	lea	r8, QWORD PTR [rax*8]
	mov	eax, DWORD PTR [rdx+4]
	cmp	DWORD PTR bestRepOffset$[rbp+r8-252], eax
	jae	SHORT $LN17@ZDICT_anal

; 688  :         tmp = table[u-1];
; 689  :         table[u-1] = table[u];

	mov	rcx, QWORD PTR [rdx]
	mov	rax, QWORD PTR bestRepOffset$[rbp+r8-256]

; 690  :         table[u] = tmp;

	mov	QWORD PTR [rdx], rax
	sub	rdx, 8
	mov	QWORD PTR bestRepOffset$[rbp+r8-256], rcx
	add	edi, -1					; ffffffffH
	jne	SHORT $LL109@ZDICT_anal
$LN17@ZDICT_anal:

; 779  :     }
; 780  : 
; 781  :     /* looking for most common first offsets */
; 782  :     {   U32 offset;
; 783  :         for (offset=1; offset<MAXREPOFFSET; offset++)

	inc	r9d
	add	r10, 4
	cmp	r9d, 1024				; 00000400H
	jb	SHORT $LL19@ZDICT_anal

; 784  :             ZDICT_insertSortCount(bestRepOffset, offset, repOffset[offset]);
; 785  :     }
; 786  :     /* note : the result of this phase should be used to better appreciate the impact on statistics */
; 787  : 
; 788  :     total=0; for (u=0; u<=offcodeMax; u++) total+=offcodeCount[u];

	mov	eax, DWORD PTR tv5734[rsp]
	xor	r9d, r9d
	mov	r11d, DWORD PTR offcodeMax$1$[rsp]
	xor	edx, edx
	cmp	eax, 8
	jb	SHORT $LN455@ZDICT_anal
	and	eax, 7
	mov	edi, r11d
	sub	edi, eax
	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	npad	8
$LL22@ZDICT_anal:
	movdqu	xmm0, XMMWORD PTR offcodeCount$[rbp+rdx*4-256]
	lea	eax, DWORD PTR [rdx+4]
	add	edx, 8
	paddd	xmm0, xmm1
	movdqa	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR offcodeCount$[rbp+rax*4-256]
	paddd	xmm0, xmm2
	movdqa	xmm2, xmm0
	cmp	edx, edi
	jbe	SHORT $LL22@ZDICT_anal
	paddd	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	r9d, xmm1
$LN455@ZDICT_anal:
	xor	edi, edi
	xor	r8d, r8d
	cmp	edx, r11d
	ja	SHORT $LN507@ZDICT_anal
	mov	eax, r11d
	sub	eax, edx
	inc	eax
	cmp	eax, 2
	jb	SHORT $LN592@ZDICT_anal
	lea	r10d, DWORD PTR [r11-1]
	npad	7
$LL510@ZDICT_anal:
	add	edi, DWORD PTR offcodeCount$[rbp+rdx*4-256]
	lea	eax, DWORD PTR [rdx+1]
	add	r8d, DWORD PTR offcodeCount$[rbp+rax*4-256]
	add	edx, 2
	cmp	edx, r10d
	jbe	SHORT $LL510@ZDICT_anal
	cmp	edx, r11d
	ja	SHORT $LN509@ZDICT_anal
$LN592@ZDICT_anal:
	add	r9d, DWORD PTR offcodeCount$[rbp+rdx*4-256]
$LN509@ZDICT_anal:
	lea	eax, DWORD PTR [rdi+r8]
	add	r9d, eax
$LN507@ZDICT_anal:

; 789  :     errorCode = FSE_normalizeCount(offcodeNCount, Offlog, offcodeCount, total, offcodeMax);

	lea	r8, QWORD PTR offcodeCount$[rbp-256]
	mov	DWORD PTR [rsp+32], r11d
	mov	edx, 8
	lea	rcx, QWORD PTR offcodeNCount$[rbp-256]
	call	FSE_normalizeCount
	mov	QWORD PTR eSize$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 790  :     if (FSE_isError(errorCode)) {

	jbe	SHORT $LN38@ZDICT_anal

; 791  :         eSize = errorCode;
; 792  :         DISPLAYLEVEL(1, "FSE_normalizeCount error with offcodeCount \n");

	cmp	r14d, 1
	jb	$_cleanup$632
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963411
$LN630@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3468 :     if (cdict==NULL) return 0;   /* support free on NULL */

	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
	jmp	$_cleanup$632
$LN38@ZDICT_anal:
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 795  :     Offlog = (U32)errorCode;

	mov	esi, eax
	xorps	xmm6, xmm6
	lea	rax, QWORD PTR matchLengthCount$[rbp-256]
	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	npad	11
$LL25@ZDICT_anal:

; 796  : 
; 797  :     total=0; for (u=0; u<=MaxML; u++) total+=matchLengthCount[u];

	movdqu	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+32]
	paddd	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-16]
	paddd	xmm0, xmm2
	movdqa	xmm2, xmm0
	sub	r12, 1
	jne	SHORT $LL25@ZDICT_anal
	paddd	xmm1, xmm0
	lea	rax, QWORD PTR matchLengthCount$[rbp-64]
	movdqa	xmm0, xmm1
	xor	ecx, ecx
	psrldq	xmm0, 8
	xor	edx, edx
	paddd	xmm1, xmm0
	mov	edi, 2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	r8d, xmm1
	npad	14
$LL514@ZDICT_anal:
	add	ecx, DWORD PTR [rax]
	add	edx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR [rax+8]
	sub	rdi, 1
	jne	SHORT $LL514@ZDICT_anal
	add	r8d, DWORD PTR matchLengthCount$[rbp-48]
	lea	r9d, DWORD PTR [rcx+rdx]
	add	r9d, r8d

; 798  :     errorCode = FSE_normalizeCount(matchLengthNCount, mlLog, matchLengthCount, total, MaxML);

	mov	DWORD PTR [rsp+32], 52			; 00000034H
	lea	r8, QWORD PTR matchLengthCount$[rbp-256]
	lea	edx, QWORD PTR [rdi+9]
	lea	rcx, QWORD PTR matchLengthNCount$[rbp-256]
	call	FSE_normalizeCount
	mov	QWORD PTR eSize$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 799  :     if (FSE_isError(errorCode)) {

	jbe	SHORT $LN40@ZDICT_anal

; 800  :         eSize = errorCode;
; 801  :         DISPLAYLEVEL(1, "FSE_normalizeCount error with matchLengthCount \n");

	cmp	r14d, 1
	jb	$_cleanup$632
	lea	ecx, QWORD PTR [rdi+2]
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963410

; 802  :         goto _cleanup;

	jmp	$LN630@ZDICT_anal
$LN40@ZDICT_anal:

; 803  :     }
; 804  :     mlLog = (U32)errorCode;

	mov	r13d, eax
	movdqa	xmm1, xmm6
	lea	rax, QWORD PTR litLengthCount$[rbp-256]
	mov	ecx, 4
	npad	8
$LL28@ZDICT_anal:

; 805  : 
; 806  :     total=0; for (u=0; u<=MaxLL; u++) total+=litLengthCount[u];

	movdqu	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+32]
	paddd	xmm6, xmm0
	movdqu	xmm0, XMMWORD PTR [rax-16]
	paddd	xmm0, xmm1
	movdqa	xmm1, xmm0
	sub	rcx, 1
	jne	SHORT $LL28@ZDICT_anal
	paddd	xmm6, xmm0
	lea	rax, QWORD PTR litLengthCount$[rbp-128]
	movdqa	xmm0, xmm6
	xor	edi, edi
	psrldq	xmm0, 8
	mov	r8d, 2
	paddd	xmm6, xmm0
	movdqa	xmm0, xmm6
	psrldq	xmm0, 4
	paddd	xmm6, xmm0
	movd	r9d, xmm6
$LL518@ZDICT_anal:
	add	ecx, DWORD PTR [rax]
	add	edi, DWORD PTR [rax+4]
	lea	rax, QWORD PTR [rax+8]
	sub	r8, 1
	jne	SHORT $LL518@ZDICT_anal

; 807  :     errorCode = FSE_normalizeCount(litLengthNCount, llLog, litLengthCount, total, MaxLL);

	lea	eax, DWORD PTR [rcx+rdi]
	mov	DWORD PTR [rsp+32], 35			; 00000023H
	add	r9d, eax
	lea	r8, QWORD PTR litLengthCount$[rbp-256]
	mov	edx, 9
	lea	rcx, QWORD PTR litLengthNCount$[rbp-256]
	call	FSE_normalizeCount
	mov	QWORD PTR eSize$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 808  :     if (FSE_isError(errorCode)) {

	jbe	SHORT $LN42@ZDICT_anal

; 809  :         eSize = errorCode;
; 810  :         DISPLAYLEVEL(1, "FSE_normalizeCount error with litLengthCount \n");

	cmp	r14d, 1
	jb	$_cleanup$632
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963409

; 811  :         goto _cleanup;

	jmp	$LN630@ZDICT_anal
$LN42@ZDICT_anal:

; 812  :     }
; 813  :     llLog = (U32)errorCode;
; 814  : 
; 815  :     /* write result to buffer */
; 816  :     {   size_t const hhSize = HUF_writeCTable(dstPtr, maxDstSize, hufTable, 255, huffLog);

	mov	rdi, QWORD PTR dstBuffer$GSCopy$1$[rbp-256]
	lea	r8, QWORD PTR hufTablehb$[rbp-256]
	mov	r15d, 248				; 000000f8H
	mov	DWORD PTR [rsp+32], ebx
	mov	edx, r15d
	mov	rcx, rdi
	mov	r9d, 255				; 000000ffH
	mov	r12d, eax
	call	HUF_writeCTable
	mov	QWORD PTR eSize$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 817  :         if (HUF_isError(hhSize)) {

	jbe	SHORT $LN44@ZDICT_anal

; 818  :             eSize = hhSize;
; 819  :             DISPLAYLEVEL(1, "HUF_writeCTable error \n");

	cmp	r14d, 1
	jb	$LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963408

; 820  :             goto _cleanup;

	jmp	$LN629@ZDICT_anal
$LN44@ZDICT_anal:

; 821  :         }
; 822  :         dstPtr += hhSize;
; 823  :         maxDstSize -= hhSize;

	sub	r15, rax
	lea	r8, QWORD PTR [rdi+rax]
	mov	QWORD PTR dstPtr$1$[rsp], r8
	mov	QWORD PTR maxDstSize$GSCopy$1$[rsp], r15
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	cmp	esi, 12
	jbe	SHORT $LN121@ZDICT_anal
	mov	rax, -44				; ffffffffffffffd4H
	jmp	$LN569@ZDICT_anal
$LN121@ZDICT_anal:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	esi, 5
	jae	SHORT $LN122@ZDICT_anal
	mov	rax, -1
	jmp	$LN569@ZDICT_anal
$LN122@ZDICT_anal:

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	imul	eax, esi, 31
	lea	r9d, DWORD PTR [rsi-5]
	mov	ecx, esi
	lea	r14d, DWORD PTR [rsi+1]

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	xor	r10d, r10d

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	mov	ebx, 1
	shl	ebx, cl

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	mov	r11, r8
	xor	ecx, ecx

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	shr	eax, 3
	add	eax, 3

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	lea	esi, QWORD PTR [r10+4]
	cmp	r15, rax
	lea	r15d, DWORD PTR [rbx+1]
	jae	$LL151@ZDICT_anal
	npad	3
$LL128@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r15d, 1
	jle	$LN613@ZDICT_anal

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN141@ZDICT_anal

; 221  :             unsigned start = symbol;

	mov	edx, r10d

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	r10d, 31
	jae	SHORT $LN614@ZDICT_anal
	lea	rcx, QWORD PTR offcodeNCount$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*2]
$LL130@ZDICT_anal:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN591@ZDICT_anal
	inc	r10d
	add	rcx, 2
	cmp	r10d, 31
	jb	SHORT $LL130@ZDICT_anal
$LN614@ZDICT_anal:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN404@ZDICT_anal
$LN591@ZDICT_anal:

; 224  :             while (symbol >= start+24) {

	lea	edi, DWORD PTR [rdx+24]
	cmp	r10d, edi
	jb	SHORT $LN519@ZDICT_anal
	mov	ecx, esi
	mov	r8d, 65535				; 0000ffffH
	shl	r8d, cl
	mov	rcx, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	add	rcx, -2
	add	rcx, QWORD PTR dstPtr$1$[rsp]
$LL132@ZDICT_anal:

; 225  :                 start+=24;

	add	edx, 24
	add	edi, 24

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r9d, r8d

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	cmp	r11, rcx
	ja	$LN398@ZDICT_anal

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 231  :                 out+=2;

	add	r11, 2

; 232  :                 bitStream>>=16;

	shr	r9d, 16
	cmp	r10d, edi
	jae	SHORT $LL132@ZDICT_anal
	mov	r8, QWORD PTR dstPtr$1$[rsp]
$LN519@ZDICT_anal:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	edi, DWORD PTR [rdx+3]
	cmp	r10d, edi
	jb	SHORT $LN135@ZDICT_anal
	npad	7
$LL134@ZDICT_anal:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, esi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r9d, eax
	add	edi, 3

; 237  :                 bitCount += 2;

	add	esi, 2
	cmp	edi, r10d
	jbe	SHORT $LL134@ZDICT_anal
$LN135@ZDICT_anal:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, esi
	mov	eax, r10d
	sub	eax, edx

; 240  :             bitCount += 2;

	add	esi, 2
	shl	eax, cl
	add	r9d, eax

; 241  :             if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN141@ZDICT_anal

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	mov	rax, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	add	rax, -2
	add	rax, r8
	cmp	r11, rax
	ja	$LN398@ZDICT_anal

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 246  :                 out += 2;

	add	r11, 2

; 247  :                 bitStream >>= 16;

	shr	r9d, 16

; 248  :                 bitCount -= 16;

	sub	esi, 16
$LN141@ZDICT_anal:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR offcodeNCount$[rbp+r10*2-256]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r8d, DWORD PTR [rbx+rbx]
	sub	r8d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	r10d
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	edi, DWORD PTR [r8-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, ebx
	mov	eax, 1
	cmovl	r8d, eax
	add	r8d, ecx
	mov	ecx, esi
	mov	eax, r8d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r9d, eax
	mov	eax, r14d
	cmp	r8d, edi
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	esi, eax
	cmp	r8d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	$LN404@ZDICT_anal

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, ebx
	jge	SHORT $LN137@ZDICT_anal
	npad	2
$LL136@ZDICT_anal:
	dec	r14d
	sar	ebx, 1
	cmp	r15d, ebx
	jl	SHORT $LL136@ZDICT_anal
$LN137@ZDICT_anal:

; 262  :         }
; 263  :         if (bitCount>16) {

	mov	r8, QWORD PTR dstPtr$1$[rsp]
	cmp	esi, 16
	jle	SHORT $LN577@ZDICT_anal

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	mov	rax, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	add	rax, -2
	add	rax, r8
	cmp	r11, rax
	ja	SHORT $LN398@ZDICT_anal

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 268  :             out += 2;

	add	r11, 2

; 269  :             bitStream >>= 16;

	shr	r9d, 16

; 270  :             bitCount -= 16;

	sub	esi, 16
$LN577@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r10d, 31
	jb	$LL128@ZDICT_anal

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN613@ZDICT_anal:
	je	SHORT $LN147@ZDICT_anal

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rax, -1
	jmp	$LN150@ZDICT_anal
$LN147@ZDICT_anal:

; 275  :     assert(symbol <= alphabetSize);
; 276  : 
; 277  :     /* flush remaining bitStream */
; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	mov	rax, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	add	rax, -2
	add	rax, r8
	cmp	r11, rax
	jbe	SHORT $LN148@ZDICT_anal
$LN398@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN150@ZDICT_anal
$LN148@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [rsi+7]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	cdqe
	sub	rax, r8

; 295  :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);

	jmp	$LN615@ZDICT_anal
	npad	4
$LL151@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r15d, 1
	jle	$LN616@ZDICT_anal

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN164@ZDICT_anal

; 221  :             unsigned start = symbol;

	mov	edx, r10d

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	r10d, 31
	jae	SHORT $LN617@ZDICT_anal
	lea	rcx, QWORD PTR offcodeNCount$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*2]
$LL153@ZDICT_anal:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN589@ZDICT_anal
	inc	r10d
	add	rcx, 2
	cmp	r10d, 31
	jb	SHORT $LL153@ZDICT_anal
$LN617@ZDICT_anal:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN404@ZDICT_anal
$LN589@ZDICT_anal:

; 224  :             while (symbol >= start+24) {

	lea	edi, DWORD PTR [rdx+24]
	cmp	r10d, edi
	jb	SHORT $LN375@ZDICT_anal
	mov	ecx, esi
	mov	r8d, 65535				; 0000ffffH
	shl	r8d, cl
	npad	14
$LL155@ZDICT_anal:

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r9d, r8d
	add	edx, 24

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	add	edi, 24
	mov	BYTE PTR [r11+1], al

; 231  :                 out+=2;

	add	r11, 2

; 232  :                 bitStream>>=16;

	shr	r9d, 16
	cmp	edi, r10d
	jbe	SHORT $LL155@ZDICT_anal
$LN375@ZDICT_anal:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	edi, DWORD PTR [rdx+3]
	cmp	r10d, edi
	jb	SHORT $LN158@ZDICT_anal
	npad	5
$LL157@ZDICT_anal:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, esi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r9d, eax
	add	edi, 3

; 237  :                 bitCount += 2;

	add	esi, 2
	cmp	edi, r10d
	jbe	SHORT $LL157@ZDICT_anal
$LN158@ZDICT_anal:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, esi
	mov	eax, r10d
	sub	eax, edx

; 240  :             bitCount += 2;

	add	esi, 2
	shl	eax, cl
	add	r9d, eax

; 241  :             if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN164@ZDICT_anal

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 246  :                 out += 2;

	add	r11, 2

; 247  :                 bitStream >>= 16;

	shr	r9d, 16

; 248  :                 bitCount -= 16;

	sub	esi, 16
$LN164@ZDICT_anal:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR offcodeNCount$[rbp+r10*2-256]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r8d, DWORD PTR [rbx+rbx]
	sub	r8d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	r10d
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	edi, DWORD PTR [r8-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, ebx
	mov	eax, 1
	cmovl	r8d, eax
	add	r8d, ecx
	mov	ecx, esi
	mov	eax, r8d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r9d, eax
	mov	eax, r14d
	cmp	r8d, edi
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	esi, eax
	cmp	r8d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	SHORT $LN404@ZDICT_anal

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, ebx
	jge	SHORT $LN160@ZDICT_anal
$LL159@ZDICT_anal:
	dec	r14d
	sar	ebx, 1
	cmp	r15d, ebx
	jl	SHORT $LL159@ZDICT_anal
$LN160@ZDICT_anal:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN168@ZDICT_anal

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 268  :             out += 2;

	add	r11, 2

; 269  :             bitStream >>= 16;

	shr	r9d, 16

; 270  :             bitCount -= 16;

	sub	esi, 16
$LN168@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r10d, 31
	jb	$LL151@ZDICT_anal

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN616@ZDICT_anal:
	je	SHORT $LN170@ZDICT_anal
$LN404@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rax, -1
	jmp	SHORT $LN150@ZDICT_anal
$LN170@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [rsi+7]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	cdqe
	sub	rax, QWORD PTR dstPtr$1$[rsp]
$LN615@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	BYTE PTR [r11], r9b
	shr	r9d, 8
	add	rax, r11
	mov	BYTE PTR [r11+1], r9b
$LN150@ZDICT_anal:
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 828  :         if (FSE_isError(ohSize)) {

	jbe	SHORT $LN46@ZDICT_anal
$LN569@ZDICT_anal:

; 829  :             eSize = ohSize;
; 830  :             DISPLAYLEVEL(1, "FSE_writeNCount error with offcodeNCount \n");

	cmp	DWORD PTR notificationLevel$[rbp-256], 1
	mov	QWORD PTR eSize$1$[rsp], rax
	jb	$LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963407

; 831  :             goto _cleanup;

	jmp	$LN629@ZDICT_anal
$LN46@ZDICT_anal:

; 832  :         }
; 833  :         dstPtr += ohSize;
; 834  :         maxDstSize -= ohSize;

	mov	r8, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	add	QWORD PTR dstPtr$1$[rsp], rax
	sub	r8, rax

; 835  :         eSize += ohSize;

	add	QWORD PTR eSize$1$[rsp], rax
	mov	QWORD PTR maxDstSize$GSCopy$1$[rsp], r8
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	cmp	r13d, 12
	jbe	SHORT $LN176@ZDICT_anal
	mov	rax, -44				; ffffffffffffffd4H
	jmp	$LN570@ZDICT_anal
$LN176@ZDICT_anal:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	r13d, 5
	jae	SHORT $LN177@ZDICT_anal
	mov	rax, -1
	jmp	$LN570@ZDICT_anal
$LN177@ZDICT_anal:

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	imul	eax, r13d, 53				; 00000035H
	lea	r9d, DWORD PTR [r13-5]
	mov	ecx, r13d
	lea	r14d, DWORD PTR [r13+1]

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	mov	r13, QWORD PTR dstPtr$1$[rsp]
	xor	r10d, r10d

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	mov	ebx, 1

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	mov	r11, r13

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	shl	ebx, cl

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	xor	ecx, ecx

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	shr	eax, 3
	add	eax, 3

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	lea	esi, QWORD PTR [r10+4]
	lea	r15d, DWORD PTR [rbx+1]
	cmp	r8, rax
	jae	$LL206@ZDICT_anal
	npad	6
$LL183@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r15d, 1
	jle	$LN618@ZDICT_anal

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN196@ZDICT_anal

; 221  :             unsigned start = symbol;

	mov	edx, r10d

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	r10d, 53				; 00000035H
	jae	SHORT $LN619@ZDICT_anal
	lea	rcx, QWORD PTR matchLengthNCount$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*2]
$LL185@ZDICT_anal:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN587@ZDICT_anal
	inc	r10d
	add	rcx, 2
	cmp	r10d, 53				; 00000035H
	jb	SHORT $LL185@ZDICT_anal
$LN619@ZDICT_anal:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN411@ZDICT_anal
$LN587@ZDICT_anal:

; 224  :             while (symbol >= start+24) {

	lea	edi, DWORD PTR [rdx+24]
	cmp	r10d, edi
	jb	SHORT $LN521@ZDICT_anal
	mov	ecx, esi
	mov	r8d, 65535				; 0000ffffH
	shl	r8d, cl
	lea	rcx, QWORD PTR [r13-2]
	add	rcx, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	npad	5
$LL187@ZDICT_anal:

; 225  :                 start+=24;

	add	edx, 24
	add	edi, 24

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r9d, r8d

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	cmp	r11, rcx
	ja	$LN405@ZDICT_anal

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 231  :                 out+=2;

	add	r11, 2

; 232  :                 bitStream>>=16;

	shr	r9d, 16
	cmp	r10d, edi
	jae	SHORT $LL187@ZDICT_anal
	mov	r8, QWORD PTR maxDstSize$GSCopy$1$[rsp]
$LN521@ZDICT_anal:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	edi, DWORD PTR [rdx+3]
	cmp	r10d, edi
	jb	SHORT $LN190@ZDICT_anal
	npad	7
$LL189@ZDICT_anal:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, esi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r9d, eax
	add	edi, 3

; 237  :                 bitCount += 2;

	add	esi, 2
	cmp	edi, r10d
	jbe	SHORT $LL189@ZDICT_anal
$LN190@ZDICT_anal:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, esi
	mov	eax, r10d
	sub	eax, edx

; 240  :             bitCount += 2;

	add	esi, 2
	shl	eax, cl
	add	r9d, eax

; 241  :             if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN196@ZDICT_anal

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	add	rax, r8
	cmp	r11, rax
	ja	$LN405@ZDICT_anal

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 246  :                 out += 2;

	add	r11, 2

; 247  :                 bitStream >>= 16;

	shr	r9d, 16

; 248  :                 bitCount -= 16;

	sub	esi, 16
$LN196@ZDICT_anal:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR matchLengthNCount$[rbp+r10*2-256]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r8d, DWORD PTR [rbx+rbx]
	sub	r8d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	r10d
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	edi, DWORD PTR [r8-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, ebx
	mov	eax, 1
	cmovl	r8d, eax
	add	r8d, ecx
	mov	ecx, esi
	mov	eax, r8d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r9d, eax
	mov	eax, r14d
	cmp	r8d, edi
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	esi, eax
	cmp	r8d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	$LN411@ZDICT_anal

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, ebx
	jge	SHORT $LN192@ZDICT_anal
	npad	7
$LL191@ZDICT_anal:
	dec	r14d
	sar	ebx, 1
	cmp	r15d, ebx
	jl	SHORT $LL191@ZDICT_anal
$LN192@ZDICT_anal:

; 262  :         }
; 263  :         if (bitCount>16) {

	mov	r8, QWORD PTR maxDstSize$GSCopy$1$[rsp]
	cmp	esi, 16
	jle	SHORT $LN578@ZDICT_anal

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	add	rax, r8
	cmp	r11, rax
	ja	SHORT $LN405@ZDICT_anal

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 268  :             out += 2;

	add	r11, 2

; 269  :             bitStream >>= 16;

	shr	r9d, 16

; 270  :             bitCount -= 16;

	sub	esi, 16
$LN578@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r10d, 53				; 00000035H
	jb	$LL183@ZDICT_anal

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN618@ZDICT_anal:
	je	SHORT $LN202@ZDICT_anal

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rax, -1
	jmp	$LN205@ZDICT_anal
$LN202@ZDICT_anal:

; 275  :     assert(symbol <= alphabetSize);
; 276  : 
; 277  :     /* flush remaining bitStream */
; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	add	rax, r8
	cmp	r11, rax
	jbe	$LN225@ZDICT_anal
$LN405@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN205@ZDICT_anal
$LL206@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r15d, 1
	jle	$LN621@ZDICT_anal

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN219@ZDICT_anal

; 221  :             unsigned start = symbol;

	mov	edx, r10d

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	r10d, 53				; 00000035H
	jae	SHORT $LN622@ZDICT_anal
	lea	rcx, QWORD PTR matchLengthNCount$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*2]
$LL208@ZDICT_anal:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN585@ZDICT_anal
	inc	r10d
	add	rcx, 2
	cmp	r10d, 53				; 00000035H
	jb	SHORT $LL208@ZDICT_anal
$LN622@ZDICT_anal:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN411@ZDICT_anal
$LN585@ZDICT_anal:

; 224  :             while (symbol >= start+24) {

	lea	edi, DWORD PTR [rdx+24]
	cmp	r10d, edi
	jb	SHORT $LN385@ZDICT_anal
	mov	ecx, esi
	mov	r8d, 65535				; 0000ffffH
	shl	r8d, cl
	npad	14
$LL210@ZDICT_anal:

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r9d, r8d
	add	edx, 24

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	add	edi, 24
	mov	BYTE PTR [r11+1], al

; 231  :                 out+=2;

	add	r11, 2

; 232  :                 bitStream>>=16;

	shr	r9d, 16
	cmp	edi, r10d
	jbe	SHORT $LL210@ZDICT_anal
$LN385@ZDICT_anal:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	edi, DWORD PTR [rdx+3]
	cmp	r10d, edi
	jb	SHORT $LN213@ZDICT_anal
	npad	5
$LL212@ZDICT_anal:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, esi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r9d, eax
	add	edi, 3

; 237  :                 bitCount += 2;

	add	esi, 2
	cmp	edi, r10d
	jbe	SHORT $LL212@ZDICT_anal
$LN213@ZDICT_anal:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, esi
	mov	eax, r10d
	sub	eax, edx

; 240  :             bitCount += 2;

	add	esi, 2
	shl	eax, cl
	add	r9d, eax

; 241  :             if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN219@ZDICT_anal

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 246  :                 out += 2;

	add	r11, 2

; 247  :                 bitStream >>= 16;

	shr	r9d, 16

; 248  :                 bitCount -= 16;

	sub	esi, 16
$LN219@ZDICT_anal:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR matchLengthNCount$[rbp+r10*2-256]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r8d, DWORD PTR [rbx+rbx]
	sub	r8d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	r10d
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	edi, DWORD PTR [r8-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, ebx
	mov	eax, 1
	cmovl	r8d, eax
	add	r8d, ecx
	mov	ecx, esi
	mov	eax, r8d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	r9d, eax
	mov	eax, r14d
	cmp	r8d, edi
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	esi, eax
	cmp	r8d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	SHORT $LN411@ZDICT_anal

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, ebx
	jge	SHORT $LN215@ZDICT_anal
$LL214@ZDICT_anal:
	dec	r14d
	sar	ebx, 1
	cmp	r15d, ebx
	jl	SHORT $LL214@ZDICT_anal
$LN215@ZDICT_anal:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN223@ZDICT_anal

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r9d
	mov	BYTE PTR [r11], r9b
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 268  :             out += 2;

	add	r11, 2

; 269  :             bitStream >>= 16;

	shr	r9d, 16

; 270  :             bitCount -= 16;

	sub	esi, 16
$LN223@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r10d, 53				; 00000035H
	jb	$LL206@ZDICT_anal

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN621@ZDICT_anal:
	je	SHORT $LN225@ZDICT_anal
$LN411@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rax, -1
	jmp	SHORT $LN205@ZDICT_anal
$LN225@ZDICT_anal:
	lea	eax, DWORD PTR [rsi+7]
	mov	BYTE PTR [r11], r9b
	cdq
	shr	r9d, 8
	and	edx, 7
	mov	BYTE PTR [r11+1], r9b
	add	eax, edx
	sar	eax, 3
	cdqe
	sub	rax, r13
	add	rax, r11
$LN205@ZDICT_anal:
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 839  :         if (FSE_isError(mhSize)) {

	jbe	SHORT $LN48@ZDICT_anal
$LN570@ZDICT_anal:

; 840  :             eSize = mhSize;
; 841  :             DISPLAYLEVEL(1, "FSE_writeNCount error with matchLengthNCount \n");

	cmp	DWORD PTR notificationLevel$[rbp-256], 1
	mov	QWORD PTR eSize$1$[rsp], rax
	jb	$LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963406

; 842  :             goto _cleanup;

	jmp	$LN629@ZDICT_anal
$LN48@ZDICT_anal:

; 843  :         }
; 844  :         dstPtr += mhSize;
; 845  :         maxDstSize -= mhSize;

	sub	QWORD PTR maxDstSize$GSCopy$1$[rsp], rax
	add	r13, rax

; 846  :         eSize += mhSize;

	add	QWORD PTR eSize$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	cmp	r12d, 12
	jbe	SHORT $LN231@ZDICT_anal
	mov	rax, -44				; ffffffffffffffd4H
	jmp	$LN571@ZDICT_anal
$LN231@ZDICT_anal:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	r12d, 5
	jae	SHORT $LN232@ZDICT_anal
	mov	rax, -1
	jmp	$LN571@ZDICT_anal
$LN232@ZDICT_anal:

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	lea	eax, DWORD PTR [r12+r12*8]
	mov	ecx, r12d
	shl	eax, 2
	lea	edi, DWORD PTR [r12-5]
	shr	eax, 3
	lea	r14d, DWORD PTR [r12+1]

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	mov	r12, QWORD PTR maxDstSize$GSCopy$1$[rsp]

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	mov	ebx, 1
	shl	ebx, cl
	add	eax, 3

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	mov	esi, 4
	lea	r15d, DWORD PTR [rbx+1]
	cmp	r12, rax
	jae	$LN233@ZDICT_anal

; 206  :     unsigned symbol = 0;

	xor	r11d, r11d
	mov	r10, r13

; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;

	xor	ecx, ecx
$LL238@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r15d, 1
	jle	$LN623@ZDICT_anal

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN251@ZDICT_anal

; 221  :             unsigned start = symbol;

	mov	edx, r11d

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	r11d, 36				; 00000024H
	jae	SHORT $LN624@ZDICT_anal
	lea	rcx, QWORD PTR litLengthNCount$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r11*2]
	npad	6
$LL240@ZDICT_anal:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN583@ZDICT_anal
	inc	r11d
	add	rcx, 2
	cmp	r11d, 36				; 00000024H
	jb	SHORT $LL240@ZDICT_anal
$LN624@ZDICT_anal:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN418@ZDICT_anal
$LN583@ZDICT_anal:

; 224  :             while (symbol >= start+24) {

	lea	r8d, DWORD PTR [rdx+24]
	cmp	r11d, r8d
	jb	SHORT $LN523@ZDICT_anal
	mov	ecx, esi
	mov	r9d, 65535				; 0000ffffH
	shl	r9d, cl
	lea	rcx, QWORD PTR [r12-2]
	add	rcx, r13
	npad	11
$LL242@ZDICT_anal:

; 225  :                 start+=24;

	add	edx, 24
	add	r8d, 24

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	edi, r9d

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	cmp	r10, rcx
	ja	$LN412@ZDICT_anal

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, edi
	mov	BYTE PTR [r10], dil
	shr	eax, 8
	mov	BYTE PTR [r10+1], al

; 231  :                 out+=2;

	add	r10, 2

; 232  :                 bitStream>>=16;

	shr	edi, 16
	cmp	r11d, r8d
	jae	SHORT $LL242@ZDICT_anal
$LN523@ZDICT_anal:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r8d, DWORD PTR [rdx+3]
	cmp	r11d, r8d
	jb	SHORT $LN245@ZDICT_anal
	npad	12
$LL244@ZDICT_anal:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, esi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	edi, eax
	add	r8d, 3

; 237  :                 bitCount += 2;

	add	esi, 2
	cmp	r8d, r11d
	jbe	SHORT $LL244@ZDICT_anal
$LN245@ZDICT_anal:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, esi
	mov	eax, r11d
	sub	eax, edx

; 240  :             bitCount += 2;

	add	esi, 2
	shl	eax, cl
	add	edi, eax

; 241  :             if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN251@ZDICT_anal

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r12-2]
	add	rax, r13
	cmp	r10, rax
	ja	$LN412@ZDICT_anal

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, edi
	mov	BYTE PTR [r10], dil
	shr	eax, 8
	mov	BYTE PTR [r10+1], al

; 246  :                 out += 2;

	add	r10, 2

; 247  :                 bitStream >>= 16;

	shr	edi, 16

; 248  :                 bitCount -= 16;

	sub	esi, 16
$LN251@ZDICT_anal:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR litLengthNCount$[rbp+r11*2-256]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r9d, DWORD PTR [rbx+rbx]
	sub	r9d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	r11d
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	r8d, DWORD PTR [r9-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, ebx
	mov	eax, 1
	cmovl	r9d, eax
	add	r9d, ecx
	mov	ecx, esi
	mov	eax, r9d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	edi, eax
	mov	eax, r14d
	cmp	r9d, r8d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	esi, eax
	cmp	r9d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	$LN418@ZDICT_anal

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, ebx
	jge	SHORT $LN247@ZDICT_anal
$LL246@ZDICT_anal:
	dec	r14d
	sar	ebx, 1
	cmp	r15d, ebx
	jl	SHORT $LL246@ZDICT_anal
$LN247@ZDICT_anal:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN579@ZDICT_anal

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r12-2]
	add	rax, r13
	cmp	r10, rax
	ja	SHORT $LN412@ZDICT_anal

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, edi
	mov	BYTE PTR [r10], dil
	shr	eax, 8
	mov	BYTE PTR [r10+1], al

; 268  :             out += 2;

	add	r10, 2

; 269  :             bitStream >>= 16;

	shr	edi, 16

; 270  :             bitCount -= 16;

	sub	esi, 16
$LN579@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r11d, 36				; 00000024H
	jb	$LL238@ZDICT_anal

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN623@ZDICT_anal:
	je	SHORT $LN257@ZDICT_anal

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rax, -1
	jmp	$LN260@ZDICT_anal
$LN257@ZDICT_anal:

; 275  :     assert(symbol <= alphabetSize);
; 276  : 
; 277  :     /* flush remaining bitStream */
; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r12-2]
	add	rax, r13
	cmp	r10, rax
	jbe	SHORT $LN258@ZDICT_anal
$LN412@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN260@ZDICT_anal
$LN258@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [rsi+7]
	mov	BYTE PTR [r10], dil
	cdq
	shr	edi, 8
	and	edx, 7
	mov	BYTE PTR [r10+1], dil
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	cdqe
	sub	rax, r13
	add	rax, r10

; 295  :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);

	jmp	$LN260@ZDICT_anal
$LN233@ZDICT_anal:

; 206  :     unsigned symbol = 0;

	xor	r10d, r10d
	mov	r11, r13

; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;

	xor	ecx, ecx
	npad	8
$LL261@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r15d, 1
	jle	$LN625@ZDICT_anal

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN274@ZDICT_anal

; 221  :             unsigned start = symbol;

	mov	edx, r10d

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	r10d, 36				; 00000024H
	jae	SHORT $LN626@ZDICT_anal
	lea	rcx, QWORD PTR litLengthNCount$[rbp-256]
	lea	rcx, QWORD PTR [rcx+r10*2]
$LL263@ZDICT_anal:
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN581@ZDICT_anal
	inc	r10d
	add	rcx, 2
	cmp	r10d, 36				; 00000024H
	jb	SHORT $LL263@ZDICT_anal
$LN626@ZDICT_anal:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN418@ZDICT_anal
$LN581@ZDICT_anal:

; 224  :             while (symbol >= start+24) {

	lea	r8d, DWORD PTR [rdx+24]
	cmp	r10d, r8d
	jb	SHORT $LN395@ZDICT_anal
	mov	ecx, esi
	mov	r9d, 65535				; 0000ffffH
	shl	r9d, cl
	npad	13
$LL265@ZDICT_anal:

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	edi, r9d
	add	edx, 24

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, edi
	mov	BYTE PTR [r11], dil
	shr	eax, 8
	add	r8d, 24
	mov	BYTE PTR [r11+1], al

; 231  :                 out+=2;

	add	r11, 2

; 232  :                 bitStream>>=16;

	shr	edi, 16
	cmp	r8d, r10d
	jbe	SHORT $LL265@ZDICT_anal
$LN395@ZDICT_anal:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r8d, DWORD PTR [rdx+3]
	cmp	r10d, r8d
	jb	SHORT $LN268@ZDICT_anal
	npad	5
$LL267@ZDICT_anal:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, esi
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	edi, eax
	add	r8d, 3

; 237  :                 bitCount += 2;

	add	esi, 2
	cmp	r8d, r10d
	jbe	SHORT $LL267@ZDICT_anal
$LN268@ZDICT_anal:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, esi
	mov	eax, r10d
	sub	eax, edx

; 240  :             bitCount += 2;

	add	esi, 2
	shl	eax, cl
	add	edi, eax

; 241  :             if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN274@ZDICT_anal

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, edi
	mov	BYTE PTR [r11], dil
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 246  :                 out += 2;

	add	r11, 2

; 247  :                 bitStream >>= 16;

	shr	edi, 16

; 248  :                 bitCount -= 16;

	sub	esi, 16
$LN274@ZDICT_anal:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	movsx	ecx, WORD PTR litLengthNCount$[rbp+r10*2-256]

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r9d, DWORD PTR [rbx+rbx]
	sub	r9d, r15d

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	cdq
	inc	r10d
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	r8d, DWORD PTR [r9-1]
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, ebx
	mov	eax, 1
	cmovl	r9d, eax
	add	r9d, ecx
	mov	ecx, esi
	mov	eax, r9d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	xor	ecx, ecx
	add	edi, eax
	mov	eax, r14d
	cmp	r9d, r8d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	xor	ecx, ecx
	add	esi, eax
	cmp	r9d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	SHORT $LN418@ZDICT_anal

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, ebx
	jge	SHORT $LN270@ZDICT_anal
$LL269@ZDICT_anal:
	dec	r14d
	sar	ebx, 1
	cmp	r15d, ebx
	jl	SHORT $LL269@ZDICT_anal
$LN270@ZDICT_anal:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	esi, 16
	jle	SHORT $LN278@ZDICT_anal

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, edi
	mov	BYTE PTR [r11], dil
	shr	eax, 8
	mov	BYTE PTR [r11+1], al

; 268  :             out += 2;

	add	r11, 2

; 269  :             bitStream >>= 16;

	shr	edi, 16

; 270  :             bitCount -= 16;

	sub	esi, 16
$LN278@ZDICT_anal:

; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	r10d, 36				; 00000024H
	jb	$LL261@ZDICT_anal

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN625@ZDICT_anal:
	je	SHORT $LN280@ZDICT_anal
$LN418@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rax, -1
	jmp	SHORT $LN260@ZDICT_anal
$LN280@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [rsi+7]
	mov	BYTE PTR [r11], dil
	cdq
	shr	edi, 8
	and	edx, 7
	mov	BYTE PTR [r11+1], dil
	add	eax, edx
	sar	eax, 3

; 283  : 
; 284  :     return (out-ostart);

	cdqe
	sub	rax, r13
	add	rax, r11
$LN260@ZDICT_anal:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 850  :         if (FSE_isError(lhSize)) {

	jbe	SHORT $LN50@ZDICT_anal
$LN571@ZDICT_anal:

; 851  :             eSize = lhSize;
; 852  :             DISPLAYLEVEL(1, "FSE_writeNCount error with litlengthNCount \n");

	cmp	DWORD PTR notificationLevel$[rbp-256], 1
	mov	QWORD PTR eSize$1$[rsp], rax
	jb	$LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963405

; 853  :             goto _cleanup;

	jmp	$LN629@ZDICT_anal
$LN50@ZDICT_anal:

; 854  :         }
; 855  :         dstPtr += lhSize;
; 856  :         maxDstSize -= lhSize;
; 857  :         eSize += lhSize;

	mov	rcx, QWORD PTR eSize$1$[rsp]
	sub	r12, rax
	add	rcx, 12

; 858  :     }
; 859  : 
; 860  :     if (maxDstSize<12) {

	cmp	r12, 12
	jae	SHORT $LN52@ZDICT_anal

; 861  :         eSize = ERROR(dstSize_tooSmall);
; 862  :         DISPLAYLEVEL(1, "not enough space to write RepOffsets \n");

	cmp	DWORD PTR notificationLevel$[rbp-256], 1
	mov	QWORD PTR eSize$1$[rsp], -70		; ffffffffffffffbaH
	jb	SHORT $LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963404

; 863  :         goto _cleanup;

	jmp	SHORT $LN629@ZDICT_anal
$LN52@ZDICT_anal:

; 864  :     }
; 865  : # if 0
; 866  :     MEM_writeLE32(dstPtr+0, bestRepOffset[0].offset);
; 867  :     MEM_writeLE32(dstPtr+4, bestRepOffset[1].offset);
; 868  :     MEM_writeLE32(dstPtr+8, bestRepOffset[2].offset);
; 869  : #else
; 870  :     /* at this stage, we don't use the result of "most common first offset",
; 871  :        as the impact of statistics is not properly evaluated */
; 872  :     MEM_writeLE32(dstPtr+0, repStartValue[0]);

	mov	r15d, 1

; 873  :     MEM_writeLE32(dstPtr+4, repStartValue[1]);

	mov	DWORD PTR [r13+rax+4], 4

; 874  :     MEM_writeLE32(dstPtr+8, repStartValue[2]);
; 875  : #endif
; 876  :     eSize += 12;

	add	rcx, rax
	mov	DWORD PTR [r13+rax], r15d
	mov	QWORD PTR eSize$1$[rsp], rcx
	mov	DWORD PTR [r13+rax+8], 8
	jmp	SHORT $_cleanup$632
$LN32@ZDICT_anal:

; 751  :         eSize = ERROR(memory_allocation);
; 752  :         DISPLAYLEVEL(1, "Not enough memory \n");

	cmp	DWORD PTR notificationLevel$[rbp-256], 1
	mov	QWORD PTR eSize$1$[rsp], -64		; ffffffffffffffc0H
	jb	SHORT $LN610@ZDICT_anal
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294963414
$LN629@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3468 :     if (cdict==NULL) return 0;   /* support free on NULL */

	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN610@ZDICT_anal:
	mov	r15d, 1
$_cleanup$632:
	mov	rbx, QWORD PTR esr$[rbp-256]
	movaps	xmm7, XMMWORD PTR [rsp+11408]
	movaps	xmm6, XMMWORD PTR [rsp+11424]
	test	rbx, rbx
	je	$LN303@ZDICT_anal

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movups	xmm0, XMMWORD PTR [rbx+4896]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movsd	xmm1, QWORD PTR [rbx+4912]
	movsd	QWORD PTR cMem$9[rbp-240], xmm1
	movups	XMMWORD PTR cMem$9[rsp], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	rcx, rbx
	ja	SHORT $LN291@ZDICT_anal
	cmp	rbx, QWORD PTR [rbx+32]
	ja	SHORT $LN291@ZDICT_anal
	mov	edi, r15d
	jmp	SHORT $LN292@ZDICT_anal
$LN291@ZDICT_anal:
	xor	edi, edi
$LN292@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3471 :         ZSTD_cwksp_free(&cdict->workspace, cMem);

	movaps	XMMWORD PTR $T14[rbp-256], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR $T14[rbp-240], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rbx+24], xmm0
	movups	XMMWORD PTR [rbx+40], xmm0
	movups	XMMWORD PTR [rbx+56], xmm0
	movups	XMMWORD PTR [rbx+72], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN298@ZDICT_anal

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T14[rbp-248]
	test	rax, rax
	je	SHORT $LN297@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T14[rbp-240]
	call	rax
	jmp	SHORT $LN298@ZDICT_anal
$LN297@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN298@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3472 :         if (!cdictInWorkspace) {

	test	edi, edi
	jne	SHORT $LN303@ZDICT_anal
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR cMem$9[rsp+8]
	test	rax, rax
	je	SHORT $LN302@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$9[rbp-240]
	mov	rdx, rbx
	call	rax
	jmp	SHORT $LN303@ZDICT_anal
$LN302@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN303@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 149  :     if (cctx==NULL) return 0;   /* support free on NULL */

	mov	rsi, QWORD PTR $T12[rbp-256]
	test	rsi, rsi
	je	$LN354@ZDICT_anal

; 150  :     RETURN_ERROR_IF(cctx->staticSize, memory_allocation,

	cmp	QWORD PTR [rsi+520], 0
	jne	$LN354@ZDICT_anal
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	QWORD PTR [rsi+312], rsi
	ja	SHORT $LN313@ZDICT_anal
	cmp	rsi, QWORD PTR [rsi+320]
	ja	SHORT $LN313@ZDICT_anal
	mov	ebx, r15d
	jmp	SHORT $LN314@ZDICT_anal
$LN313@ZDICT_anal:
	xor	ebx, ebx
$LN314@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 122  :     ZSTD_free(cctx->localDict.dictBuffer, cctx->customMem);

	movups	xmm0, XMMWORD PTR [rsi+496]
	mov	rcx, QWORD PTR [rsi+1080]
	movsd	xmm1, QWORD PTR [rsi+512]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movsd	QWORD PTR $T4[rbp-240], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN322@ZDICT_anal

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T4[rsp+8]
	test	rax, rax
	je	SHORT $LN321@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T4[rbp-240]
	call	rax
	jmp	SHORT $LN322@ZDICT_anal
$LN321@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN322@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 123  :     ZSTD_freeCDict(cctx->localDict.cdict);

	mov	rdi, QWORD PTR [rsi+1112]

; 3468 :     if (cdict==NULL) return 0;   /* support free on NULL */

	test	rdi, rdi
	je	$LN342@ZDICT_anal

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movups	xmm0, XMMWORD PTR [rdi+4896]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	mov	rcx, QWORD PTR [rdi+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movsd	xmm1, QWORD PTR [rdi+4912]
	movsd	QWORD PTR cMem$13[rbp-240], xmm1
	movups	XMMWORD PTR cMem$13[rbp-256], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	rcx, rdi
	ja	SHORT $LN330@ZDICT_anal
	cmp	rdi, QWORD PTR [rdi+32]
	jbe	SHORT $LN331@ZDICT_anal
$LN330@ZDICT_anal:
	xor	r15d, r15d
$LN331@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3471 :         ZSTD_cwksp_free(&cdict->workspace, cMem);

	movaps	XMMWORD PTR $T3[rsp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR $T3[rbp-240], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rdi+24], xmm0
	movups	XMMWORD PTR [rdi+40], xmm0
	movups	XMMWORD PTR [rdi+56], xmm0
	movups	XMMWORD PTR [rdi+72], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN337@ZDICT_anal

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T3[rsp+8]
	test	rax, rax
	je	SHORT $LN336@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T3[rbp-240]
	call	rax
	jmp	SHORT $LN337@ZDICT_anal
$LN336@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN337@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3472 :         if (!cdictInWorkspace) {

	test	r15d, r15d
	jne	SHORT $LN342@ZDICT_anal
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR cMem$13[rbp-248]
	test	rax, rax
	je	SHORT $LN341@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$13[rbp-240]
	mov	rdx, rdi
	call	rax
	jmp	SHORT $LN342@ZDICT_anal
$LN341@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN342@ZDICT_anal:
	xorps	xmm0, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 124  :     memset(&cctx->localDict, 0, sizeof(cctx->localDict));

	xor	eax, eax
	movups	XMMWORD PTR [rsi+1080], xmm0
	movups	XMMWORD PTR [rsi+1096], xmm0
	mov	QWORD PTR [rsi+1112], rax

; 125  :     memset(&cctx->prefixDict, 0, sizeof(cctx->prefixDict));

	movups	XMMWORD PTR [rsi+1128], xmm0
	mov	QWORD PTR [rsi+1144], rax

; 142  :     ZSTDMT_freeCCtx(cctx->mtctx); cctx->mtctx = NULL;

	mov	rcx, QWORD PTR [rsi+1152]

; 126  :     cctx->cdict = NULL;

	mov	QWORD PTR [rsi+1120], rax

; 142  :     ZSTDMT_freeCCtx(cctx->mtctx); cctx->mtctx = NULL;

	call	ZSTDMT_freeCCtx

; 144  :     ZSTD_cwksp_free(&cctx->workspace, cctx->customMem);

	movups	xmm0, XMMWORD PTR [rsi+496]
	mov	QWORD PTR [rsi+1152], 0
	movsd	xmm1, QWORD PTR [rsi+512]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 467  :     void *ptr = ws->workspace;

	mov	rcx, QWORD PTR [rsi+312]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 144  :     ZSTD_cwksp_free(&cctx->workspace, cctx->customMem);

	movaps	XMMWORD PTR $T5[rsp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR $T5[rbp-240], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rsi+312], xmm0
	movups	XMMWORD PTR [rsi+328], xmm0
	movups	XMMWORD PTR [rsi+344], xmm0
	movups	XMMWORD PTR [rsi+360], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN349@ZDICT_anal

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T5[rsp+8]
	test	rax, rax
	je	SHORT $LN348@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T5[rbp-240]
	call	rax
	jmp	SHORT $LN349@ZDICT_anal
$LN348@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN349@ZDICT_anal:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 155  :         if (!cctxInWorkspace) {

	test	ebx, ebx
	jne	SHORT $LN354@ZDICT_anal

; 156  :             ZSTD_free(cctx, cctx->customMem);

	movups	xmm1, XMMWORD PTR [rsi+496]
	movsd	xmm0, QWORD PTR [rsi+512]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 156  :             ZSTD_free(cctx, cctx->customMem);

	movsd	QWORD PTR $T6[rbp-240], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN353@ZDICT_anal

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T6[rbp-240]
	mov	rdx, rsi
	call	rax
	jmp	SHORT $LN354@ZDICT_anal
$LN353@ZDICT_anal:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN354@ZDICT_anal:
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 881  :     free(esr.workPlace);

	mov	rcx, QWORD PTR esr$1$[rbp-256]
	call	QWORD PTR __imp_free

; 882  : 
; 883  :     return eSize;

	mov	rax, QWORD PTR eSize$1$[rsp]

; 884  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+11512]
	add	rsp, 11440				; 00002cb0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZDICT_analyzeEntropy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
samplesSizes$GSCopy$1$ = 80
header$ = 96
__$ArrayPad$ = 352
dictBuffer$ = 448
dictBufferCapacity$ = 456
customDictContent$ = 464
dictContentSize$ = 472
samplesBuffer$ = 480
samplesSizes$ = 488
nbSamples$ = 496
params$ = 504
ZDICT_finalizeDictionary PROC

; 892  : {

$LN470:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 376				; 00000178H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, QWORD PTR params$[rsp]
	mov	rdi, r9
	mov	rax, QWORD PTR samplesSizes$[rsp]
	mov	rbp, r8
	mov	r13, QWORD PTR samplesBuffer$[rsp]
	mov	rbx, rdx
	mov	QWORD PTR samplesSizes$GSCopy$1$[rsp], rax
	mov	r12, rcx

; 893  :     size_t hSize;
; 894  : #define HBUFFSIZE 256   /* should prove large enough for all entropy headers */
; 895  :     BYTE header[HBUFFSIZE];
; 896  :     int const compressionLevel = (params.compressionLevel == 0) ? g_compressionLevel_default : params.compressionLevel;

	mov	r14d, DWORD PTR [rsi]
	mov	eax, 3

; 897  :     U32 const notificationLevel = params.notificationLevel;

	mov	r15d, DWORD PTR [rsi+4]
	test	r14d, r14d
	cmove	r14d, eax

; 898  : 
; 899  :     /* check conditions */
; 900  :     DEBUGLOG(4, "ZDICT_finalizeDictionary");
; 901  :     if (dictBufferCapacity < dictContentSize) return ERROR(dstSize_tooSmall);

	cmp	rdx, r9
	jb	$LN468@ZDICT_fina

; 902  :     if (dictContentSize < ZDICT_CONTENTSIZE_MIN) return ERROR(srcSize_wrong);

	cmp	r9, 128					; 00000080H
	jae	SHORT $LN3@ZDICT_fina
	mov	rax, -72				; ffffffffffffffb8H
	jmp	$LN1@ZDICT_fina
$LN3@ZDICT_fina:

; 903  :     if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) return ERROR(dstSize_tooSmall);

	cmp	rbx, 256				; 00000100H
	jb	$LN468@ZDICT_fina

; 904  : 
; 905  :     /* dictionary header */
; 906  :     MEM_writeLE32(header, ZSTD_MAGIC_DICTIONARY);
; 907  :     {   U64 const randomID = XXH64(customDictContent, dictContentSize, 0);

	xor	r8d, r8d
	mov	DWORD PTR header$[rsp], -332356553	; ec30a437H
	mov	rdx, rdi
	mov	rcx, rbp
	call	XXH64

; 909  :         U32 const dictID = params.dictID ? params.dictID : compliantID;

	mov	ecx, DWORD PTR [rsi+8]
	mov	r8, rax
	test	ecx, ecx
	jne	SHORT $LN13@ZDICT_fina

; 908  :         U32 const compliantID = (randomID % ((1U<<31)-32768)) + 32768;

	mov	rax, -9223231297218904063		; 8000800080008001H
	mov	ecx, r8d
	mul	r8
	shr	rdx, 30
	imul	eax, edx, 2147450880			; 7fff8000H
	sub	ecx, eax
	add	ecx, 32768				; 00008000H
$LN13@ZDICT_fina:

; 910  :         MEM_writeLE32(header+4, dictID);

	mov	DWORD PTR header$[rsp+4], ecx

; 911  :     }
; 912  :     hSize = 8;
; 913  : 
; 914  :     /* entropy tables */
; 915  :     DISPLAYLEVEL(2, "\r%70s\r", "");   /* clean display line */

	cmp	r15d, 2
	jb	SHORT $LN6@ZDICT_fina
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r8, OFFSET FLAT:$SG4294963403
	lea	rdx, OFFSET FLAT:$SG4294963402
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 916  :     DISPLAYLEVEL(2, "statistics ... \n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294963401
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN6@ZDICT_fina:

; 917  :     {   size_t const eSize = ZDICT_analyzeEntropy(header+hSize, HBUFFSIZE-hSize,

	mov	eax, DWORD PTR nbSamples$[rsp]
	lea	rcx, QWORD PTR header$[rsp+8]
	mov	DWORD PTR [rsp+64], r15d
	mov	r9, r13
	mov	QWORD PTR [rsp+56], rdi
	mov	r8d, r14d
	mov	QWORD PTR [rsp+48], rbp
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR samplesSizes$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZDICT_analyzeEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c

; 922  :         if (ZDICT_isError(eSize)) return eSize;

	ja	SHORT $LN1@ZDICT_fina

; 923  :         hSize += eSize;

	lea	rsi, QWORD PTR [rax+8]

; 924  :     }
; 925  : 
; 926  :     /* copy elements in final buffer ; note : src and dst buffer can overlap */
; 927  :     if (hSize + dictContentSize > dictBufferCapacity) dictContentSize = dictBufferCapacity - hSize;

	lea	rax, QWORD PTR [rdi+rsi]
	cmp	rax, rbx
	jbe	SHORT $LN8@ZDICT_fina
	mov	rdi, rbx
	sub	rdi, rsi
$LN8@ZDICT_fina:

; 928  :     {   size_t const dictSize = hSize + dictContentSize;
; 929  :         char* dictEnd = (char*)dictBuffer + dictSize;
; 930  :         memmove(dictEnd - dictContentSize, customDictContent, dictContentSize);

	mov	rcx, r12
	lea	rbx, QWORD PTR [rdi+rsi]
	sub	rcx, rdi
	mov	r8, rdi
	add	rcx, rbx
	mov	rdx, rbp
	call	memmove

; 931  :         memcpy(dictBuffer, header, hSize);

	mov	r8, rsi
	lea	rdx, QWORD PTR header$[rsp]
	mov	rcx, r12
	call	memcpy

; 932  :         return dictSize;

	mov	rax, rbx
	jmp	SHORT $LN1@ZDICT_fina
$LN468@ZDICT_fina:

; 903  :     if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) return ERROR(dstSize_tooSmall);

	mov	rax, -70				; ffffffffffffffbaH
$LN1@ZDICT_fina:

; 933  :     }
; 934  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZDICT_finalizeDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\zdict.c
_TEXT	SEGMENT
params$ = 48
dictBuffer$ = 128
dictBufferCapacity$ = 136
samplesBuffer$ = 144
samplesSizes$ = 152
nbSamples$ = 160
ZDICT_trainFromBuffer PROC

; 1111 : {

$LN4:
	sub	rsp, 120				; 00000078H

; 1112 :     ZDICT_fastCover_params_t params;
; 1113 :     DEBUGLOG(3, "ZDICT_trainFromBuffer");
; 1114 :     memset(&params, 0, sizeof(params));

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR params$[rsp+48], rax

; 1115 :     params.d = 8;
; 1116 :     params.steps = 4;
; 1117 :     /* Default to level 6 since no compression level information is available */
; 1118 :     params.zParams.compressionLevel = 3;
; 1119 : #if defined(DEBUGLEVEL) && (DEBUGLEVEL>=1)
; 1120 :     params.zParams.notificationLevel = DEBUGLEVEL;
; 1121 : #endif
; 1122 :     return ZDICT_optimizeTrainFromBuffer_fastCover(dictBuffer, dictBufferCapacity,

	lea	rax, QWORD PTR params$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR nbSamples$[rsp]
	movups	XMMWORD PTR params$[rsp], xmm0
	mov	DWORD PTR [rsp+32], eax
	movups	XMMWORD PTR params$[rsp+32], xmm0
	mov	DWORD PTR params$[rsp+4], 8
	movups	XMMWORD PTR params$[rsp+16], xmm0
	mov	DWORD PTR params$[rsp+12], 4
	mov	DWORD PTR params$[rsp+44], 3
	call	ZDICT_optimizeTrainFromBuffer_fastCover

; 1123 :                                                samplesBuffer, samplesSizes, nbSamples,
; 1124 :                                                &params);
; 1125 : }

	add	rsp, 120				; 00000078H
	ret	0
ZDICT_trainFromBuffer ENDP
_TEXT	ENDS
END
