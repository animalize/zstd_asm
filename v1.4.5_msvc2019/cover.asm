; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_qsort:PROC
g_ctx	DQ	01H DUP (?)
_BSS	ENDS
g_displayLevel DD 02H
refreshRate DD	096H
prime4bytes DD	09e3779b1H
PUBLIC	COVER_checkTotalCompressedSize
PUBLIC	COVER_best_wait
PUBLIC	COVER_sum
PUBLIC	COVER_computeEpochs
PUBLIC	COVER_dictSelectionFree
PUBLIC	COVER_dictSelectionError
PUBLIC	COVER_warnOnSmallCorpus
PUBLIC	COVER_best_destroy
PUBLIC	COVER_best_init
PUBLIC	COVER_dictSelectionIsError
PUBLIC	COVER_best_finish
PUBLIC	COVER_best_start
PUBLIC	COVER_selectDict
	ALIGN	4

g_time	DD	01H DUP (?)
$SG4294962266 DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$COVER_tryParameters DD imagerel COVER_tryParameters
	DD	imagerel COVER_tryParameters+889
	DD	imagerel $unwind$COVER_tryParameters
$pdata$COVER_checkTotalCompressedSize DD imagerel $LN94
	DD	imagerel $LN94+817
	DD	imagerel $unwind$COVER_checkTotalCompressedSize
$pdata$COVER_buildDictionary DD imagerel COVER_buildDictionary
	DD	imagerel COVER_buildDictionary+688
	DD	imagerel $unwind$COVER_buildDictionary
$pdata$COVER_selectSegment DD imagerel COVER_selectSegment
	DD	imagerel COVER_selectSegment+768
	DD	imagerel $unwind$COVER_selectSegment
$pdata$COVER_group DD imagerel COVER_group
	DD	imagerel COVER_group+227
	DD	imagerel $unwind$COVER_group
$pdata$COVER_strict_cmp8 DD imagerel COVER_strict_cmp8
	DD	imagerel COVER_strict_cmp8+134
	DD	imagerel $unwind$COVER_strict_cmp8
$pdata$COVER_strict_cmp DD imagerel COVER_strict_cmp
	DD	imagerel COVER_strict_cmp+73
	DD	imagerel $unwind$COVER_strict_cmp
$pdata$COVER_map_destroy DD imagerel COVER_map_destroy
	DD	imagerel COVER_map_destroy+37
	DD	imagerel $unwind$COVER_map_destroy
$pdata$COVER_map_remove DD imagerel COVER_map_remove
	DD	imagerel COVER_map_remove+92
	DD	imagerel $unwind$COVER_map_remove
$pdata$0$COVER_map_remove DD imagerel COVER_map_remove+92
	DD	imagerel COVER_map_remove+207
	DD	imagerel $chain$0$COVER_map_remove
$pdata$1$COVER_map_remove DD imagerel COVER_map_remove+207
	DD	imagerel COVER_map_remove+214
	DD	imagerel $chain$1$COVER_map_remove
$pdata$COVER_map_init DD imagerel COVER_map_init
	DD	imagerel COVER_map_init+111
	DD	imagerel $unwind$COVER_map_init
$pdata$COVER_best_wait DD imagerel $LN12
	DD	imagerel $LN12+26
	DD	imagerel $unwind$COVER_best_wait
$pdata$0$COVER_best_wait DD imagerel $LN12+26
	DD	imagerel $LN12+63
	DD	imagerel $chain$0$COVER_best_wait
$pdata$1$COVER_best_wait DD imagerel $LN12+63
	DD	imagerel $LN12+78
	DD	imagerel $chain$1$COVER_best_wait
$pdata$COVER_sum DD imagerel $LN22
	DD	imagerel $LN22+119
	DD	imagerel $unwind$COVER_sum
$pdata$0$COVER_sum DD imagerel $LN22+119
	DD	imagerel $LN22+172
	DD	imagerel $chain$0$COVER_sum
$pdata$1$COVER_sum DD imagerel $LN22+172
	DD	imagerel $LN22+190
	DD	imagerel $chain$1$COVER_sum
$pdata$COVER_computeEpochs DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$COVER_computeEpochs
$pdata$COVER_dictSelectionFree DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$COVER_dictSelectionFree
$pdata$COVER_warnOnSmallCorpus DD imagerel $LN10
	DD	imagerel $LN10+193
	DD	imagerel $unwind$COVER_warnOnSmallCorpus
$pdata$COVER_best_destroy DD imagerel $LN16
	DD	imagerel $LN16+26
	DD	imagerel $unwind$COVER_best_destroy
$pdata$0$COVER_best_destroy DD imagerel $LN16+26
	DD	imagerel $LN16+63
	DD	imagerel $chain$0$COVER_best_destroy
$pdata$1$COVER_best_destroy DD imagerel $LN16+63
	DD	imagerel $LN16+102
	DD	imagerel $chain$1$COVER_best_destroy
$pdata$COVER_best_init DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$COVER_best_init
$pdata$COVER_best_finish DD imagerel $LN14
	DD	imagerel $LN14+45
	DD	imagerel $unwind$COVER_best_finish
$pdata$0$COVER_best_finish DD imagerel $LN14+45
	DD	imagerel $LN14+237
	DD	imagerel $chain$0$COVER_best_finish
$pdata$1$COVER_best_finish DD imagerel $LN14+237
	DD	imagerel $LN14+238
	DD	imagerel $chain$1$COVER_best_finish
$pdata$COVER_best_start DD imagerel $LN6
	DD	imagerel $LN6+38
	DD	imagerel $unwind$COVER_best_start
$pdata$COVER_selectDict DD imagerel $LN51
	DD	imagerel $LN51+135
	DD	imagerel $unwind$COVER_selectDict
$pdata$0$COVER_selectDict DD imagerel $LN51+135
	DD	imagerel $LN51+417
	DD	imagerel $chain$0$COVER_selectDict
$pdata$1$COVER_selectDict DD imagerel $LN51+417
	DD	imagerel $LN51+446
	DD	imagerel $chain$1$COVER_selectDict
$pdata$2$COVER_selectDict DD imagerel $LN51+446
	DD	imagerel $LN51+931
	DD	imagerel $chain$2$COVER_selectDict
$pdata$3$COVER_selectDict DD imagerel $LN51+931
	DD	imagerel $LN51+967
	DD	imagerel $chain$3$COVER_selectDict
xdata	SEGMENT
$unwind$COVER_tryParameters DD 0d2401H
	DD	02d7424H
	DD	02c6424H
	DD	02b3424H
	DD	0240124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
$unwind$COVER_checkTotalCompressedSize DD 0113f01H
	DD	07883fH
	DD	087837H
	DD	096830H
	DD	01d3421H
	DD	0140121H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
$unwind$COVER_buildDictionary DD 0b2601H
	DD	01a3426H
	DD	0120126H
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	05015H
$unwind$COVER_selectSegment DD 0a1e01H
	DD	010341eH
	DD	0f01a521eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$COVER_group DD 091601H
	DD	057416H
	DD	046416H
	DD	035416H
	DD	023416H
	DD	0e016H
$unwind$COVER_strict_cmp8 DD 040a01H
	DD	02740aH
	DD	013405H
$unwind$COVER_strict_cmp DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$COVER_map_destroy DD 020601H
	DD	030023206H
$unwind$COVER_map_remove DD 030601H
	DD	033406H
	DD	06006H
$chain$0$COVER_map_remove DD 020521H
	DD	027405H
	DD	imagerel COVER_map_remove
	DD	imagerel COVER_map_remove+92
	DD	imagerel $unwind$COVER_map_remove
$chain$1$COVER_map_remove DD 021H
	DD	imagerel COVER_map_remove
	DD	imagerel COVER_map_remove+92
	DD	imagerel $unwind$COVER_map_remove
$unwind$COVER_map_init DD 020601H
	DD	030023206H
$unwind$COVER_best_wait DD 020a01H
	DD	03006320aH
$chain$0$COVER_best_wait DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+26
	DD	imagerel $unwind$COVER_best_wait
$chain$1$COVER_best_wait DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+26
	DD	imagerel $unwind$COVER_best_wait
$unwind$COVER_sum DD 010201H
	DD	07002H
$chain$0$COVER_sum DD 020521H
	DD	023405H
	DD	imagerel $LN22
	DD	imagerel $LN22+119
	DD	imagerel $unwind$COVER_sum
$chain$1$COVER_sum DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+119
	DD	imagerel $unwind$COVER_sum
$unwind$COVER_computeEpochs DD 010401H
	DD	02204H
$unwind$COVER_dictSelectionFree DD 010401H
	DD	04204H
$unwind$COVER_warnOnSmallCorpus DD 060f01H
	DD	03680fH
	DD	0a340aH
	DD	07006720aH
$unwind$COVER_best_destroy DD 020a01H
	DD	03006320aH
$chain$0$COVER_best_destroy DD 020521H
	DD	067405H
	DD	imagerel $LN16
	DD	imagerel $LN16+26
	DD	imagerel $unwind$COVER_best_destroy
$chain$1$COVER_best_destroy DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+26
	DD	imagerel $unwind$COVER_best_destroy
$unwind$COVER_best_init DD 020a01H
	DD	03006320aH
$unwind$COVER_best_finish DD 081c01H
	DD	0a641cH
	DD	09341cH
	DD	0f018321cH
	DD	07014e016H
$chain$0$COVER_best_finish DD 020521H
	DD	085405H
	DD	imagerel $LN14
	DD	imagerel $LN14+45
	DD	imagerel $unwind$COVER_best_finish
$chain$1$COVER_best_finish DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+45
	DD	imagerel $unwind$COVER_best_finish
$unwind$COVER_best_start DD 020a01H
	DD	03006320aH
$unwind$COVER_selectDict DD 0b2101H
	DD	086821H
	DD	0120116H
	DD	0e00df00fH
	DD	07009d00bH
	DD	050076008H
	DD	03006H
$chain$0$COVER_selectDict DD 020821H
	DD	01bc408H
	DD	imagerel $LN51
	DD	imagerel $LN51+135
	DD	imagerel $unwind$COVER_selectDict
$chain$1$COVER_selectDict DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+135
	DD	imagerel $unwind$COVER_selectDict
$chain$2$COVER_selectDict DD 020021H
	DD	01bc400H
	DD	imagerel $LN51
	DD	imagerel $LN51+135
	DD	imagerel $unwind$COVER_selectDict
$chain$3$COVER_selectDict DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+135
	DD	imagerel $unwind$COVER_selectDict
	ORG $+3
$SG4294962265 DB 0dH, '%79s', 0dH, 00H
$SG4294962256 DB 'Failed to select dictionary', 0aH, 00H
	ORG $+3
$SG4294962257 DB 'Failed to allocate buffers: out of memory', 0aH, 00H
	ORG $+5
$SG4294962258 DB 'Failed to allocate dmer map: out of memory', 0aH, 00H
	ORG $+4
$SG4294962267 DB 0dH, '%u%%       ', 00H
	ORG $+3
$SG4294962268 DB 'Breaking content into %u epochs of size %u', 0aH, 00H
	ORG $+4
$SG4294962269 DB 'WARNING: The maximum dictionary size %u is too large co'
	DB	'mpared to the source size %u! size(source)/size(dictionary) ='
	DB	' %f, but it should be >= 10! This may lead to a subpar dictio'
	DB	'nary! We recommend training on sources at least 10x, and pref'
	DB	'erably 100x the size of the dictionary! ', 0aH, 00H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 80
$T4 = 80
tv386 = 208
$T5 = 208
customDictContent$ = 216
dictContentSize$ = 224
samplesBuffer$ = 232
samplesSizes$ = 240
nbFinalizeSamples$ = 248
nbCheckSamples$ = 256
nbSamples$ = 264
params$ = 272
offsets$ = 280
totalCompressedSize$dead$ = 288
COVER_selectDict PROC

; 951  :         size_t nbCheckSamples, size_t nbSamples, ZDICT_cover_params_t params, size_t* offsets, size_t totalCompressedSize) {

$LN51:
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+128], xmm6

; 952  : 
; 953  :   size_t largestDict = 0;
; 954  :   size_t largestCompressed = 0;
; 955  :   BYTE* customDictContentEnd = customDictContent + dictContentSize;

	lea	rax, QWORD PTR [rdx+r8]

; 956  : 
; 957  :   BYTE * largestDictbuffer = (BYTE *)malloc(dictContentSize);

	mov	rcx, r8
	mov	QWORD PTR tv386[rsp], rax
	mov	r13, r9
	mov	rdi, r8
	mov	rsi, rdx
	call	QWORD PTR __imp_malloc

; 958  :   BYTE * candidateDictBuffer = (BYTE *)malloc(dictContentSize);

	mov	rcx, rdi
	mov	r14, rax
	call	QWORD PTR __imp_malloc

; 959  :   double regressionTolerance = ((double)params.shrinkDictMaxRegression / 100.0) + 1.00;

	mov	r15, QWORD PTR params$[rsp]
	xorps	xmm6, xmm6
	mov	rbp, rax
	mov	r10d, DWORD PTR [r15+28]
	cvtsi2sd xmm6, r10
	divsd	xmm6, QWORD PTR __real@4059000000000000
	addsd	xmm6, QWORD PTR __real@3ff0000000000000

; 960  : 
; 961  :   if (!largestDictbuffer || !candidateDictBuffer) {

	test	r14, r14
	je	$LN5@COVER_sele
	test	rax, rax
	je	$LN5@COVER_sele

; 965  :   }
; 966  : 
; 967  :   /* Initial dictionary size and compressed size */
; 968  :   memcpy(largestDictbuffer, customDictContent, dictContentSize);

	mov	r8, rdi
	mov	QWORD PTR [rsp+216], r12
	mov	rdx, rsi
	mov	rcx, r14
	call	memcpy

; 969  :   dictContentSize = ZDICT_finalizeDictionary(

	mov	eax, DWORD PTR [r15+40]
	mov	r9, rdi
	movsd	xmm0, QWORD PTR [r15+32]
	mov	r8, rsi
	mov	DWORD PTR $T2[rsp+8], eax
	mov	rdx, rdi
	lea	rax, QWORD PTR $T2[rsp]
	movsd	QWORD PTR $T2[rsp], xmm0
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, r14
	mov	eax, DWORD PTR nbFinalizeSamples$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR samplesSizes$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r13
	call	ZDICT_finalizeDictionary
	mov	r12, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 973  :   if (ZDICT_isError(dictContentSize)) {

	jbe	SHORT $LN6@COVER_sele

; 974  :     free(largestDictbuffer);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 975  :     free(candidateDictBuffer);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 976  :     return COVER_dictSelectionError(dictContentSize);

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], r12
	jmp	$LN47@COVER_sele
$LN6@COVER_sele:

; 977  :   }
; 978  : 
; 979  :   totalCompressedSize = COVER_checkTotalCompressedSize(params, samplesSizes,

	movaps	xmm0, XMMWORD PTR [r15]
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rax, QWORD PTR nbSamples$[rsp]
	mov	r8, r13
	movaps	xmm1, XMMWORD PTR [r15+16]
	mov	r9, QWORD PTR offsets$[rsp]
	mov	rdx, QWORD PTR samplesSizes$[rsp]
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR nbCheckSamples$[rsp]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [r15+32]
	movaps	XMMWORD PTR $T4[rsp+32], xmm0
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T4[rsp+16], xmm1
	call	COVER_checkTotalCompressedSize
	mov	rsi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 984  :   if (ZSTD_isError(totalCompressedSize)) {

	jbe	SHORT $LN7@COVER_sele

; 985  :     free(largestDictbuffer);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 986  :     free(candidateDictBuffer);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 987  :     return COVER_dictSelectionError(totalCompressedSize);

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
$LN48@COVER_sele:

; 1028 :       return selection;

	mov	QWORD PTR [rbx+16], rsi
$LN47@COVER_sele:
	mov	r12, QWORD PTR [rsp+216]
$LN49@COVER_sele:

; 1038 :   }
; 1039 : }

	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	rax, rbx
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN7@COVER_sele:

; 988  :   }
; 989  : 
; 990  :   if (params.shrinkDict == 0) {

	cmp	DWORD PTR [r15+24], 0
	je	$LN3@COVER_sele

; 991  :     COVER_dictSelection_t selection = { largestDictbuffer, dictContentSize, totalCompressedSize };
; 992  :     free(candidateDictBuffer);
; 993  :     return selection;
; 994  :   }
; 995  : 
; 996  :   largestDict = dictContentSize;
; 997  :   largestCompressed = totalCompressedSize;
; 998  :   dictContentSize = ZDICT_DICTSIZE_MIN;

	mov	edi, 256				; 00000100H

; 999  : 
; 1000 :   /* Largest dict is initially at least ZDICT_DICTSIZE_MIN */
; 1001 :   while (dictContentSize < largestDict) {

	cmp	rdi, r12
	jae	$LN3@COVER_sele
	npad	9
$LL2@COVER_sele:

; 1002 :     memcpy(candidateDictBuffer, largestDictbuffer, largestDict);

	mov	r8, r12
	mov	rdx, r14
	mov	rcx, rbp
	call	memcpy

; 1003 :     dictContentSize = ZDICT_finalizeDictionary(

	mov	eax, DWORD PTR [r15+40]
	mov	r9, rdi
	movsd	xmm0, QWORD PTR [r15+32]
	mov	rdx, rdi
	mov	r8, QWORD PTR tv386[rsp]
	mov	rcx, rbp
	mov	DWORD PTR $T1[rsp+8], eax
	sub	r8, rdi
	lea	rax, QWORD PTR $T1[rsp]
	movsd	QWORD PTR $T1[rsp], xmm0
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR nbFinalizeSamples$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR samplesSizes$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r13
	call	ZDICT_finalizeDictionary
	mov	r13, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 1007 :     if (ZDICT_isError(dictContentSize)) {

	ja	$LN36@COVER_sele

; 1011 : 
; 1012 :     }
; 1013 : 
; 1014 :     totalCompressedSize = COVER_checkTotalCompressedSize(params, samplesSizes,

	movaps	xmm0, XMMWORD PTR [r15]
	lea	rcx, QWORD PTR $T3[rsp]
	movaps	xmm1, XMMWORD PTR [r15+16]
	mov	r9, QWORD PTR offsets$[rsp]
	mov	r8, QWORD PTR samplesBuffer$[rsp]
	mov	rdx, QWORD PTR samplesSizes$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR nbSamples$[rsp]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR nbCheckSamples$[rsp]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [r15+32]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T3[rsp+16], xmm1
	movaps	XMMWORD PTR $T3[rsp+32], xmm0
	call	COVER_checkTotalCompressedSize
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 1019 :     if (ZSTD_isError(totalCompressedSize)) {

	ja	$LN37@COVER_sele

; 1023 :     }
; 1024 : 
; 1025 :     if (totalCompressedSize <= largestCompressed * regressionTolerance) {

	xorps	xmm1, xmm1
	test	rax, rax
	js	SHORT $LN44@COVER_sele
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN45@COVER_sele
$LN44@COVER_sele:
	mov	rcx, rdi
	and	eax, 1
	shr	rcx, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
$LN45@COVER_sele:
	xorps	xmm0, xmm0
	test	rsi, rsi
	js	SHORT $LN42@COVER_sele
	cvtsi2sd xmm0, rsi
	jmp	SHORT $LN43@COVER_sele
$LN42@COVER_sele:
	mov	rax, rsi
	mov	rcx, rsi
	shr	rcx, 1
	and	eax, 1
	or	rcx, rax
	cvtsi2sd xmm0, rcx
	addsd	xmm0, xmm0
$LN43@COVER_sele:
	mulsd	xmm0, xmm6
	comisd	xmm0, xmm1
	jae	SHORT $LN38@COVER_sele

; 1029 :     }
; 1030 :     dictContentSize *= 2;

	lea	rdi, QWORD PTR [r13*2]
	mov	r13, QWORD PTR samplesBuffer$[rsp]
	cmp	rdi, r12
	jb	$LL2@COVER_sele
$LN3@COVER_sele:

; 1031 :   }
; 1032 :   dictContentSize = largestDict;
; 1033 :   totalCompressedSize = largestCompressed;
; 1034 :   {
; 1035 :     COVER_dictSelection_t selection = { largestDictbuffer, dictContentSize, totalCompressedSize };
; 1036 :     free(candidateDictBuffer);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 1037 :     return selection;

	mov	QWORD PTR [rbx], r14
	mov	QWORD PTR [rbx+8], r12
	jmp	$LN48@COVER_sele
$LN38@COVER_sele:

; 1026 :       COVER_dictSelection_t selection = { candidateDictBuffer, dictContentSize, totalCompressedSize };
; 1027 :       free(largestDictbuffer);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 1028 :       return selection;

	mov	QWORD PTR [rbx], rbp
	mov	QWORD PTR [rbx+8], r13
	mov	QWORD PTR [rbx+16], rdi
	jmp	$LN47@COVER_sele
$LN37@COVER_sele:

; 1020 :       free(largestDictbuffer);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 1021 :       free(candidateDictBuffer);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 1022 :       return COVER_dictSelectionError(totalCompressedSize);

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rdi
	jmp	$LN47@COVER_sele
$LN36@COVER_sele:

; 1008 :       free(largestDictbuffer);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 1009 :       free(candidateDictBuffer);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 1010 :       return COVER_dictSelectionError(dictContentSize);

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], r13
	jmp	$LN47@COVER_sele
$LN5@COVER_sele:

; 962  :     free(largestDictbuffer);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 963  :     free(candidateDictBuffer);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 964  :     return COVER_dictSelectionError(dictContentSize);

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rdi
	jmp	$LN49@COVER_sele
COVER_selectDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
best$ = 48
COVER_best_start PROC

; 878  : void COVER_best_start(COVER_best_t *best) {

$LN6:

; 879  :   if (!best) {

	test	rcx, rcx
	je	SHORT $LN4@COVER_best
	push	rbx
	sub	rsp, 32					; 00000020H

; 878  : void COVER_best_start(COVER_best_t *best) {

	mov	rbx, rcx

; 880  :     return;
; 881  :   }
; 882  :   ZSTD_pthread_mutex_lock(&best->mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 883  :   ++best->liveJobs;

	inc	QWORD PTR [rbx+48]

; 884  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 885  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN4@COVER_best:
	ret	0
COVER_best_start ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
best$ = 64
parameters$ = 72
selection$ = 80
COVER_best_finish PROC

; 893  :                               COVER_dictSelection_t selection) {

$LN14:

; 897  :   if (!best) {

	test	rcx, rcx
	je	$LN12@COVER_best
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 894  :   void* dict = selection.dictContent;

	mov	rsi, QWORD PTR [r8]
	mov	r15, rdx

; 895  :   size_t compressedSize = selection.totalCompressedSize;

	mov	r14, QWORD PTR [r8+16]
	mov	rbx, rcx

; 896  :   size_t dictSize = selection.dictSize;

	mov	rdi, QWORD PTR [r8+8]

; 898  :     return;
; 899  :   }
; 900  :   {
; 901  :     size_t liveJobs;
; 902  :     ZSTD_pthread_mutex_lock(&best->mutex);

	mov	QWORD PTR [rsp+64], rbp
	call	QWORD PTR __imp_EnterCriticalSection

; 903  :     --best->liveJobs;

	dec	QWORD PTR [rbx+48]
	mov	rbp, QWORD PTR [rbx+48]

; 904  :     liveJobs = best->liveJobs;
; 905  :     /* If the new dictionary is better */
; 906  :     if (compressedSize < best->compressedSize) {

	cmp	r14, QWORD PTR [rbx+120]
	jae	SHORT $LN8@COVER_best

; 907  :       /* Allocate space if necessary */
; 908  :       if (!best->dict || best->dictSize < dictSize) {

	mov	rax, QWORD PTR [rbx+56]
	test	rax, rax
	je	SHORT $LN6@COVER_best
	cmp	QWORD PTR [rbx+64], rdi
	jae	SHORT $LN7@COVER_best

; 909  :         if (best->dict) {
; 910  :           free(best->dict);

	mov	rcx, rax
	call	QWORD PTR __imp_free
$LN6@COVER_best:

; 911  :         }
; 912  :         best->dict = malloc(dictSize);

	mov	rcx, rdi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+56], rax

; 913  :         if (!best->dict) {

	test	rax, rax
	jne	SHORT $LN7@COVER_best

; 914  :           best->compressedSize = ERROR(GENERIC);
; 915  :           best->dictSize = 0;
; 916  :           ZSTD_pthread_cond_signal(&best->cond);

	lea	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+120], -1
	mov	QWORD PTR [rbx+64], rax
	call	QWORD PTR __imp_WakeConditionVariable

; 917  :           ZSTD_pthread_mutex_unlock(&best->mutex);
; 918  :           return;

	jmp	SHORT $LN9@COVER_best
$LN7@COVER_best:

; 919  :         }
; 920  :       }
; 921  :       /* Save the dictionary, parameters, and size */
; 922  :       if (dict) {

	test	rsi, rsi
	je	SHORT $LN8@COVER_best

; 923  :         memcpy(best->dict, dict, dictSize);

	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy

; 924  :         best->dictSize = dictSize;
; 925  :         best->parameters = parameters;

	movaps	xmm0, XMMWORD PTR [r15]
	movaps	xmm1, XMMWORD PTR [r15+16]
	movups	XMMWORD PTR [rbx+72], xmm0
	mov	QWORD PTR [rbx+64], rdi
	movaps	xmm0, XMMWORD PTR [r15+32]
	movups	XMMWORD PTR [rbx+88], xmm1

; 926  :         best->compressedSize = compressedSize;

	mov	QWORD PTR [rbx+120], r14
	movups	XMMWORD PTR [rbx+104], xmm0
$LN8@COVER_best:

; 927  :       }
; 928  :     }
; 929  :     if (liveJobs == 0) {

	test	rbp, rbp
	jne	SHORT $LN9@COVER_best

; 930  :       ZSTD_pthread_cond_broadcast(&best->cond);

	lea	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_WakeAllConditionVariable
$LN9@COVER_best:

; 931  :     }
; 932  :     ZSTD_pthread_mutex_unlock(&best->mutex);
; 933  :   }
; 934  : }

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbp, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
$LN12@COVER_best:
	ret	0
COVER_best_finish ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
selection$ = 8
COVER_dictSelectionIsError PROC
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	QWORD PTR [rcx+16], -120		; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 942  :   return (ZSTD_isError(selection.totalCompressedSize) || !selection.dictContent);

	ja	SHORT $LN3@COVER_dict
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN3@COVER_dict
	xor	eax, eax

; 943  : }

	ret	0
$LN3@COVER_dict:

; 942  :   return (ZSTD_isError(selection.totalCompressedSize) || !selection.dictContent);

	mov	eax, 1

; 943  : }

	ret	0
COVER_dictSelectionIsError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
best$ = 48
COVER_best_init PROC

; 834  : void COVER_best_init(COVER_best_t *best) {

$LN6:

; 835  :   if (best==NULL) return; /* compatible with init on NULL */

	test	rcx, rcx
	je	SHORT $LN4@COVER_best
	push	rbx
	sub	rsp, 32					; 00000020H

; 834  : void COVER_best_init(COVER_best_t *best) {

	mov	rbx, rcx

; 836  :   (void)ZSTD_pthread_mutex_init(&best->mutex, NULL);

	call	QWORD PTR __imp_InitializeCriticalSection

; 837  :   (void)ZSTD_pthread_cond_init(&best->cond, NULL);

	lea	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_InitializeConditionVariable

; 838  :   best->liveJobs = 0;

	xor	eax, eax

; 839  :   best->dict = NULL;
; 840  :   best->dictSize = 0;
; 841  :   best->compressedSize = (size_t)-1;

	mov	QWORD PTR [rbx+120], -1
	xorps	xmm0, xmm0
	mov	QWORD PTR [rbx+48], rax
	mov	QWORD PTR [rbx+56], rax
	mov	QWORD PTR [rbx+64], rax

; 842  :   memset(&best->parameters, 0, sizeof(best->parameters));

	movups	XMMWORD PTR [rbx+72], xmm0
	movups	XMMWORD PTR [rbx+88], xmm0
	movups	XMMWORD PTR [rbx+104], xmm0

; 843  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN4@COVER_best:
	ret	0
COVER_best_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
best$ = 48
COVER_best_destroy PROC

; 862  : void COVER_best_destroy(COVER_best_t *best) {

$LN16:

; 863  :   if (!best) {

	test	rcx, rcx
	je	SHORT $LN14@COVER_best
	push	rbx
	sub	rsp, 32					; 00000020H

; 862  : void COVER_best_destroy(COVER_best_t *best) {

	mov	rbx, rcx

; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR [rbx+48], 0
	je	SHORT $LN7@COVER_best
	mov	QWORD PTR [rsp+48], rdi
	npad	1
$LL6@COVER_best:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rbx
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR [rbx+48], 0
	jne	SHORT $LL6@COVER_best

; 853  :   while (best->liveJobs != 0) {

	mov	rdi, QWORD PTR [rsp+48]
$LN7@COVER_best:

; 855  :   }
; 856  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 864  :     return;
; 865  :   }
; 866  :   COVER_best_wait(best);
; 867  :   if (best->dict) {

	mov	rcx, QWORD PTR [rbx+56]
	test	rcx, rcx
	je	SHORT $LN3@COVER_best

; 868  :     free(best->dict);

	call	QWORD PTR __imp_free
$LN3@COVER_best:

; 869  :   }
; 870  :   ZSTD_pthread_mutex_destroy(&best->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_DeleteCriticalSection

; 871  :   ZSTD_pthread_cond_destroy(&best->cond);
; 872  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN14@COVER_best:
	ret	0
COVER_best_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
maxDictSize$ = 80
nbDmers$ = 88
displayLevel$ = 96
COVER_warnOnSmallCorpus PROC

; 631  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rsp+48], xmm6

; 632  :   const double ratio = (double)nbDmers / maxDictSize;

	xorps	xmm6, xmm6
	mov	rdi, rdx
	mov	rbx, rcx
	test	rdx, rdx
	js	SHORT $LN7@COVER_warn
	cvtsi2sd xmm6, rdx
	jmp	SHORT $LN8@COVER_warn
$LN7@COVER_warn:
	mov	rax, rdi
	mov	rcx, rdi
	shr	rcx, 1
	and	eax, 1
	or	rcx, rax
	cvtsi2sd xmm6, rcx
	addsd	xmm6, xmm6
$LN8@COVER_warn:
	xorps	xmm0, xmm0
	test	rbx, rbx
	js	SHORT $LN5@COVER_warn
	cvtsi2sd xmm0, rbx
	jmp	SHORT $LN6@COVER_warn
$LN5@COVER_warn:
	mov	rax, rbx
	mov	rcx, rbx
	shr	rcx, 1
	and	eax, 1
	or	rcx, rax
	cvtsi2sd xmm0, rcx
	addsd	xmm0, xmm0
$LN6@COVER_warn:
	divsd	xmm6, xmm0

; 633  :   if (ratio >= 10) {

	comisd	xmm6, QWORD PTR __real@4024000000000000
	jae	SHORT $LN3@COVER_warn

; 634  :       return;
; 635  :   }
; 636  :   LOCALDISPLAYLEVEL(displayLevel, 1,

	cmp	r8d, 1
	jl	SHORT $LN3@COVER_warn
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, edi
	movsd	QWORD PTR [rsp+32], xmm6
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962269
	mov	r8d, ebx
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN3@COVER_warn:

; 637  :                     "WARNING: The maximum dictionary size %u is too large "
; 638  :                     "compared to the source size %u! "
; 639  :                     "size(source)/size(dictionary) = %f, but it should be >= "
; 640  :                     "10! This may lead to a subpar dictionary! We recommend "
; 641  :                     "training on sources at least 10x, and preferably 100x "
; 642  :                     "the size of the dictionary! \n", (U32)maxDictSize,
; 643  :                     (U32)nbDmers, ratio);
; 644  : }

	mov	rbx, QWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
COVER_warnOnSmallCorpus ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
$T1 = 8
error$ = 16
COVER_dictSelectionError PROC

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 938  :     return selection;

	mov	rax, rcx

; 939  : }

	ret	0
COVER_dictSelectionError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
selection$ = 48
COVER_dictSelectionFree PROC

; 945  : void COVER_dictSelectionFree(COVER_dictSelection_t selection){

$LN4:
	sub	rsp, 40					; 00000028H

; 946  :   free(selection.dictContent);

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_free

; 947  : }

	add	rsp, 40					; 00000028H
	ret	0
COVER_dictSelectionFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
epochs$ = 0
maxDictSize$ = 32
nbDmers$ = 40
k$ = 48
passes$ = 56
COVER_computeEpochs PROC

; 648  : {

$LN7:
	sub	rsp, 24
	mov	r10d, edx

; 649  :   const U32 minEpochSize = k * 10;

	lea	r11d, DWORD PTR [r8+r8*4]

; 650  :   COVER_epoch_info_t epochs;
; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	xor	edx, edx
	mov	eax, ecx
	div	r8d
	xor	edx, edx
	add	r11d, r11d
	div	r9d
	mov	ecx, eax
	mov	eax, 1
	cmp	ecx, eax
	cmovb	ecx, eax

; 652  :   epochs.size = nbDmers / epochs.num;

	xor	edx, edx
	mov	eax, r10d
	mov	DWORD PTR epochs$[rsp], ecx
	div	ecx
	mov	DWORD PTR epochs$[rsp+4], eax
	cmp	eax, r11d

; 653  :   if (epochs.size >= minEpochSize) {

	jb	SHORT $LN2@COVER_comp

; 654  :       assert(epochs.size * epochs.num <= nbDmers);
; 655  :       return epochs;

	mov	rax, QWORD PTR epochs$[rsp]

; 659  :   assert(epochs.size * epochs.num <= nbDmers);
; 660  :   return epochs;
; 661  : }

	add	rsp, 24
	ret	0
$LN2@COVER_comp:

; 656  :   }
; 657  :   epochs.size = MIN(minEpochSize, nbDmers);

	cmp	r11d, r10d
	mov	ecx, r10d
	mov	eax, r10d
	cmovb	ecx, r11d
	xor	edx, edx
	div	ecx

; 658  :   epochs.num = nbDmers / epochs.size;

	shl	rcx, 32					; 00000020H
	or	rax, rcx

; 659  :   assert(epochs.size * epochs.num <= nbDmers);
; 660  :   return epochs;
; 661  : }

	add	rsp, 24
	ret	0
COVER_computeEpochs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
samplesSizes$ = 16
nbSamples$ = 24
COVER_sum PROC

; 227  : size_t COVER_sum(const size_t *samplesSizes, unsigned nbSamples) {

$LN22:
	push	rdi

; 228  :   size_t sum = 0;

	xor	r8d, r8d
	mov	edi, edx
	mov	r9, rcx
	mov	r11d, r8d
	mov	r10d, r8d

; 229  :   unsigned i;
; 230  :   for (i = 0; i < nbSamples; ++i) {

	cmp	edx, 4
	jb	SHORT $LN9@COVER_sum

; 228  :   size_t sum = 0;

	and	edx, -4					; fffffffcH
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	npad	2
$LL4@COVER_sum:

; 231  :     sum += samplesSizes[i];

	mov	eax, r10d
	movdqu	xmm0, XMMWORD PTR [rcx+rax*8]
	lea	eax, DWORD PTR [r10+2]
	add	r10d, 4
	paddq	xmm0, xmm2
	movdqa	xmm2, xmm0
	movdqu	xmm0, XMMWORD PTR [rcx+rax*8]
	paddq	xmm0, xmm1
	movdqa	xmm1, xmm0
	cmp	r10d, edx
	jb	SHORT $LL4@COVER_sum

; 228  :   size_t sum = 0;

	paddq	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddq	xmm1, xmm0
	movq	r11, xmm1
$LN9@COVER_sum:

; 229  :   unsigned i;
; 230  :   for (i = 0; i < nbSamples; ++i) {

	mov	rdx, r8
	cmp	r10d, edi
	jae	SHORT $LN20@COVER_sum
	mov	ecx, edi
	mov	eax, r10d
	sub	ecx, r10d
	cmp	ecx, 2
	jb	SHORT $LC14@COVER_sum
	mov	ecx, edi
	mov	QWORD PTR [rsp+16], rbx
	sub	ecx, r10d
	sub	ecx, 2
	shr	ecx, 1
	inc	ecx
	mov	ebx, ecx
	lea	ecx, DWORD PTR [r10+rcx*2]
	npad	4
$LL16@COVER_sum:

; 231  :     sum += samplesSizes[i];

	add	r8, QWORD PTR [r9+rax*8]
	add	rdx, QWORD PTR [r9+rax*8+8]
	add	rax, 2
	sub	rbx, 1
	jne	SHORT $LL16@COVER_sum

; 229  :   unsigned i;
; 230  :   for (i = 0; i < nbSamples; ++i) {

	mov	rbx, QWORD PTR [rsp+16]
	cmp	ecx, edi
	jae	SHORT $LN15@COVER_sum
$LC14@COVER_sum:

; 231  :     sum += samplesSizes[i];

	add	r11, QWORD PTR [r9+rax*8]
$LN15@COVER_sum:
	lea	rax, QWORD PTR [rdx+r8]
	add	rax, r11

; 234  : }

	pop	rdi
	ret	0
$LN20@COVER_sum:

; 232  :   }
; 233  :   return sum;

	mov	rax, r11

; 234  : }

	pop	rdi
	ret	0
COVER_sum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
best$ = 48
COVER_best_wait PROC

; 848  : void COVER_best_wait(COVER_best_t *best) {

$LN12:

; 849  :   if (!best) {

	test	rcx, rcx
	je	SHORT $LN10@COVER_best
	push	rbx
	sub	rsp, 32					; 00000020H

; 848  : void COVER_best_wait(COVER_best_t *best) {

	mov	rbx, rcx

; 850  :     return;
; 851  :   }
; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR [rbx+48], 0
	je	SHORT $LN3@COVER_best
	mov	QWORD PTR [rsp+48], rdi
	npad	1
$LL2@COVER_best:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rbx
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR [rbx+48], 0
	jne	SHORT $LL2@COVER_best

; 853  :   while (best->liveJobs != 0) {

	mov	rdi, QWORD PTR [rsp+48]
$LN3@COVER_best:

; 855  :   }
; 856  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 857  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN10@COVER_best:
	ret	0
COVER_best_wait ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
val$ = 8
ZSTD_highbit32 PROC

; 394  :     assert(val != 0);
; 395  :     {
; 396  : #   if defined(_MSC_VER)   /* Visual */
; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 399  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
; 400  :         return __builtin_clz (val) ^ 31;
; 401  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 402  :         return 31 - __CLZ(val);
; 403  : #   else   /* Software version */
; 404  :         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
; 405  :         U32 v = val;
; 406  :         v |= v >> 1;
; 407  :         v |= v >> 2;
; 408  :         v |= v >> 4;
; 409  :         v |= v >> 8;
; 410  :         v |= v >> 16;
; 411  :         return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];
; 412  : #   endif
; 413  :     }
; 414  : }

	ret	0
ZSTD_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
map$ = 8
COVER_map_clear PROC

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	mov	r8d, DWORD PTR [rcx+12]
	mov	edx, -1
	mov	rcx, QWORD PTR [rcx]
	shl	r8, 3
	jmp	memset
COVER_map_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
r$1 = 48
map$ = 48
size$ = 56
COVER_map_init PROC

; 106  : static int COVER_map_init(COVER_map_t *map, U32 size) {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$1[rsp], 0

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, edx
	mov	ecx, 0
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 108  :   map->size = (U32)1 << map->sizeLog;

	mov	eax, 1
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 107  :   map->sizeLog = ZSTD_highbit32(size) + 2;

	add	ecx, 2

; 108  :   map->size = (U32)1 << map->sizeLog;

	shl	eax, cl
	mov	DWORD PTR [rbx+8], ecx
	mov	ecx, eax

; 109  :   map->sizeMask = map->size - 1;

	dec	eax
	mov	DWORD PTR [rbx+12], ecx

; 110  :   map->data = (COVER_map_pair_t *)malloc(map->size * sizeof(COVER_map_pair_t));

	shl	rcx, 3
	mov	DWORD PTR [rbx+16], eax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx], rax

; 111  :   if (!map->data) {

	test	rax, rax
	jne	SHORT $LN2@COVER_map_

; 112  :     map->sizeLog = 0;

	mov	QWORD PTR [rbx+8], rax

; 118  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@COVER_map_:

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	mov	r8d, DWORD PTR [rbx+12]
	mov	edx, -1
	shl	r8, 3
	mov	rcx, rax
	call	memset

; 113  :     map->size = 0;
; 114  :     return 0;
; 115  :   }
; 116  :   COVER_map_clear(map);
; 117  :   return 1;

	mov	eax, 1

; 118  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
COVER_map_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
map$ = 8
key$ = 16
COVER_map_hash PROC

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	r8d, 32					; 00000020H
	imul	eax, edx, -1640531535			; 9e3779b1H
	sub	r8d, DWORD PTR [rcx+8]
	movzx	ecx, r8b
	shr	eax, cl

; 126  : }

	ret	0
COVER_map_hash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
map$ = 8
key$ = 16
COVER_map_index PROC

; 131  : static U32 COVER_map_index(COVER_map_t *map, U32 key) {

	mov	r10, rcx

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	imul	eax, edx, -1640531535			; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR [r10+8]

; 135  :     COVER_map_pair_t *pos = &map->data[i];

	mov	r11, QWORD PTR [r10]

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	shr	eax, cl

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [r11+rax*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [r11+rax*8]
	je	SHORT $LN12@COVER_map_
$LL4@COVER_map_:

; 137  :       return i;
; 138  :     }
; 139  :     if (pos->key == key) {

	cmp	DWORD PTR [r9], edx
	je	SHORT $LN12@COVER_map_

; 132  :   const U32 hash = COVER_map_hash(map, key);
; 133  :   U32 i;
; 134  :   for (i = hash;; i = (i + 1) & map->sizeMask) {

	inc	eax
	and	eax, DWORD PTR [r10+16]

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [r11+rax*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [r11+rax*8]
	jne	SHORT $LL4@COVER_map_
$LN12@COVER_map_:

; 140  :       return i;
; 141  :     }
; 142  :   }
; 143  : }

	ret	0
COVER_map_index ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
map$ = 8
key$ = 16
COVER_map_at PROC

; 150  : static U32 *COVER_map_at(COVER_map_t *map, U32 key) {

	mov	r11, rcx

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	imul	eax, edx, -1640531535			; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR [r11+8]

; 135  :     COVER_map_pair_t *pos = &map->data[i];

	mov	r10, QWORD PTR [r11]

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	shr	eax, cl

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [r10+rax*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [r10+rax*8]
	je	SHORT $LN16@COVER_map_
$LL7@COVER_map_:

; 137  :       return i;
; 138  :     }
; 139  :     if (pos->key == key) {

	cmp	DWORD PTR [r9], edx
	je	SHORT $LN16@COVER_map_

; 126  : }
; 127  : 
; 128  : /**
; 129  :  * Helper function that returns the index that a key should be placed into.
; 130  :  */
; 131  : static U32 COVER_map_index(COVER_map_t *map, U32 key) {
; 132  :   const U32 hash = COVER_map_hash(map, key);
; 133  :   U32 i;
; 134  :   for (i = hash;; i = (i + 1) & map->sizeMask) {

	inc	eax
	and	eax, DWORD PTR [r11+16]

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [r10+rax*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [r10+rax*8]
	jne	SHORT $LL7@COVER_map_
$LN16@COVER_map_:

; 151  :   COVER_map_pair_t *pos = &map->data[COVER_map_index(map, key)];

	mov	ecx, eax

; 152  :   if (pos->value == MAP_EMPTY_VALUE) {

	lea	rax, QWORD PTR [r10+4]
	cmp	DWORD PTR [rax+rcx*8], -1		; ffffffffH
	lea	rax, QWORD PTR [rax+rcx*8]
	jne	SHORT $LN20@COVER_map_

; 153  :     pos->key = key;

	mov	DWORD PTR [r10+rcx*8], edx

; 154  :     pos->value = 0;

	mov	DWORD PTR [rax], 0
$LN20@COVER_map_:

; 155  :   }
; 156  :   return &pos->value;
; 157  : }

	ret	0
COVER_map_at ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
map$ = 16
key$ = 24
COVER_map_remove PROC

; 162  : static void COVER_map_remove(COVER_map_t *map, U32 key) {

	mov	QWORD PTR [rsp+16], rbx
	push	rsi

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	imul	r8d, edx, -1640531535			; 9e3779b1H

; 162  : static void COVER_map_remove(COVER_map_t *map, U32 key) {

	mov	r11, rcx

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	esi, 32					; 00000020H
	sub	esi, DWORD PTR [rcx+8]
	mov	ecx, esi

; 135  :     COVER_map_pair_t *pos = &map->data[i];

	mov	rbx, QWORD PTR [r11]

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	shr	r8d, cl

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+r8*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [rbx+r8*8]
	je	SHORT $LN35@COVER_map_
	npad	4
$LL13@COVER_map_:

; 137  :       return i;
; 138  :     }
; 139  :     if (pos->key == key) {

	cmp	DWORD PTR [r9], edx
	je	SHORT $LN35@COVER_map_

; 126  : }
; 127  : 
; 128  : /**
; 129  :  * Helper function that returns the index that a key should be placed into.
; 130  :  */
; 131  : static U32 COVER_map_index(COVER_map_t *map, U32 key) {
; 132  :   const U32 hash = COVER_map_hash(map, key);
; 133  :   U32 i;
; 134  :   for (i = hash;; i = (i + 1) & map->sizeMask) {

	inc	r8d
	and	r8d, DWORD PTR [r11+16]

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+r8*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [rbx+r8*8]
	jne	SHORT $LL13@COVER_map_
$LN35@COVER_map_:

; 163  :   U32 i = COVER_map_index(map, key);
; 164  :   COVER_map_pair_t *del = &map->data[i];
; 165  :   U32 shift = 1;
; 166  :   if (del->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+r8*8+4], -1		; ffffffffH
	lea	r10, QWORD PTR [rbx+r8*8]
	mov	edx, 1
	je	SHORT $LN3@COVER_map_

; 167  :     return;
; 168  :   }
; 169  :   for (i = (i + 1) & map->sizeMask;; i = (i + 1) & map->sizeMask) {

	inc	r8d
	mov	QWORD PTR [rsp+16], rdi
	mov	edi, DWORD PTR [r11+16]
	and	r8d, edi

; 170  :     COVER_map_pair_t *const pos = &map->data[i];
; 171  :     /* If the position is empty we are done */
; 172  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+r8*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [rbx+r8*8]
	je	SHORT $LN26@COVER_map_
	npad	12
$LL4@COVER_map_:

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	r11d, DWORD PTR [r9]
	mov	ecx, esi
	imul	eax, r11d, -1640531535			; 9e3779b1H
	shr	eax, cl

; 174  :       return;
; 175  :     }
; 176  :     /* If pos can be moved to del do so */
; 177  :     if (((i - COVER_map_hash(map, pos->key)) & map->sizeMask) >= shift) {

	mov	ecx, r8d
	sub	ecx, eax
	and	ecx, edi
	cmp	ecx, edx
	jb	SHORT $LN7@COVER_map_

; 178  :       del->key = pos->key;

	mov	DWORD PTR [r10], r11d

; 179  :       del->value = pos->value;
; 180  :       del = pos;
; 181  :       shift = 1;

	mov	edx, 1
	mov	eax, DWORD PTR [r9+4]
	mov	DWORD PTR [r10+4], eax
	mov	r10, r9

; 182  :     } else {

	jmp	SHORT $LN2@COVER_map_
$LN7@COVER_map_:

; 183  :       ++shift;

	inc	edx
$LN2@COVER_map_:

; 167  :     return;
; 168  :   }
; 169  :   for (i = (i + 1) & map->sizeMask;; i = (i + 1) & map->sizeMask) {

	inc	r8d
	and	r8d, edi

; 170  :     COVER_map_pair_t *const pos = &map->data[i];
; 171  :     /* If the position is empty we are done */
; 172  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+r8*8+4], -1		; ffffffffH
	lea	r9, QWORD PTR [rbx+r8*8]
	jne	SHORT $LL4@COVER_map_
$LN26@COVER_map_:

; 173  :       del->value = MAP_EMPTY_VALUE;

	mov	rdi, QWORD PTR [rsp+16]
	mov	DWORD PTR [r10+4], -1			; ffffffffH
$LN3@COVER_map_:

; 184  :     }
; 185  :   }
; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
COVER_map_remove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
map$ = 48
COVER_map_destroy PROC

; 191  : static void COVER_map_destroy(COVER_map_t *map) {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 192  :   if (map->data) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@COVER_map_

; 193  :     free(map->data);

	call	QWORD PTR __imp_free
$LN4@COVER_map_:

; 194  :   }
; 195  :   map->data = NULL;
; 196  :   map->size = 0;
; 197  : }

	xor	eax, eax
	mov	DWORD PTR [rbx+12], eax
	mov	QWORD PTR [rbx], rax
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
COVER_map_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
ctx$ = 8
lp$ = 16
rp$ = 24
COVER_cmp PROC

; 242  :   U32 const lhs = *(U32 const *)lp;
; 243  :   U32 const rhs = *(U32 const *)rp;
; 244  :   return memcmp(ctx->samples + lhs, ctx->samples + rhs, ctx->d);

	mov	rax, QWORD PTR [rcx]
	mov	r10, rdx
	mov	r9, r8
	mov	r8d, DWORD PTR [rcx+80]
	mov	ecx, DWORD PTR [r10]
	mov	edx, DWORD PTR [r9]
	add	rcx, rax
	add	rdx, rax
	jmp	memcmp
COVER_cmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
ctx$ = 8
lp$ = 16
rp$ = 24
COVER_cmp8 PROC

; 249  : static int COVER_cmp8(COVER_ctx_t *ctx, const void *lp, const void *rp) {

	mov	r9, r8
	mov	r8, rdx
	mov	rdx, rcx

; 250  :   U64 const mask = (ctx->d == 8) ? (U64)-1 : (((U64)1 << (8 * ctx->d)) - 1);

	mov	ecx, DWORD PTR [rcx+80]
	cmp	ecx, 8
	jne	SHORT $LN4@COVER_cmp8
	mov	rax, -1
	jmp	SHORT $LN5@COVER_cmp8
$LN4@COVER_cmp8:
	lea	ecx, DWORD PTR [rcx*8]
	mov	eax, 1
	shl	rax, cl
	dec	rax
$LN5@COVER_cmp8:

; 251  :   U64 const lhs = MEM_readLE64(ctx->samples + *(U32 const *)lp) & mask;

	mov	ecx, DWORD PTR [r8]
	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+rdx]

; 252  :   U64 const rhs = MEM_readLE64(ctx->samples + *(U32 const *)rp) & mask;

	mov	ecx, DWORD PTR [r9]
	and	r8, rax
	mov	r9, QWORD PTR [rcx+rdx]
	and	r9, rax

; 253  :   if (lhs < rhs) {

	cmp	r8, r9
	jae	SHORT $LN2@COVER_cmp8

; 254  :     return -1;

	mov	eax, -1

; 257  : }

	ret	0
$LN2@COVER_cmp8:

; 255  :   }
; 256  :   return (lhs > rhs);

	xor	eax, eax
	cmp	r8, r9
	seta	al

; 257  : }

	ret	0
COVER_cmp8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
lp$ = 48
rp$ = 56
COVER_strict_cmp PROC

; 264  : static int COVER_strict_cmp(const void *lp, const void *rp) {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 244  :   return memcmp(ctx->samples + lhs, ctx->samples + rhs, ctx->d);

	mov	rax, QWORD PTR g_ctx

; 264  : static int COVER_strict_cmp(const void *lp, const void *rp) {

	mov	rbx, rdx

; 244  :   return memcmp(ctx->samples + lhs, ctx->samples + rhs, ctx->d);

	mov	edx, DWORD PTR [rdx]

; 264  : static int COVER_strict_cmp(const void *lp, const void *rp) {

	mov	rdi, rcx

; 244  :   return memcmp(ctx->samples + lhs, ctx->samples + rhs, ctx->d);

	mov	ecx, DWORD PTR [rcx]
	mov	r8d, DWORD PTR [rax+80]
	add	rdx, QWORD PTR [rax]
	add	rcx, QWORD PTR [rax]
	call	memcmp

; 265  :   int result = COVER_cmp(g_ctx, lp, rp);
; 266  :   if (result == 0) {

	test	eax, eax
	jne	SHORT $LN6@COVER_stri

; 267  :     result = lp < rp ? -1 : 1;

	cmp	rdi, rbx
	mov	eax, 1
	mov	ecx, -1
	cmovb	eax, ecx
$LN6@COVER_stri:

; 268  :   }
; 269  :   return result;
; 270  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
COVER_strict_cmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
lp$ = 8
rp$ = 16
COVER_strict_cmp8 PROC

; 274  : static int COVER_strict_cmp8(const void *lp, const void *rp) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 250  :   U64 const mask = (ctx->d == 8) ? (U64)-1 : (((U64)1 << (8 * ctx->d)) - 1);

	mov	rax, QWORD PTR g_ctx
	mov	rdi, -1

; 274  : static int COVER_strict_cmp8(const void *lp, const void *rp) {

	mov	rbx, rcx
	mov	r11, rdx

; 250  :   U64 const mask = (ctx->d == 8) ? (U64)-1 : (((U64)1 << (8 * ctx->d)) - 1);

	mov	ecx, DWORD PTR [rax+80]
	lea	r9d, QWORD PTR [rdi+2]
	cmp	ecx, 8
	jne	SHORT $LN7@COVER_stri
	mov	r8, rdi
	jmp	SHORT $LN8@COVER_stri
$LN7@COVER_stri:
	lea	ecx, DWORD PTR [rcx*8]
	mov	r8, r9
	shl	r8, cl
	dec	r8
$LN8@COVER_stri:

; 251  :   U64 const lhs = MEM_readLE64(ctx->samples + *(U32 const *)lp) & mask;

	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rbx]
	mov	rdx, QWORD PTR [rax+rcx]

; 252  :   U64 const rhs = MEM_readLE64(ctx->samples + *(U32 const *)rp) & mask;

	mov	eax, DWORD PTR [r11]
	and	rdx, r8
	mov	r10, QWORD PTR [rax+rcx]
	and	r10, r8

; 253  :   if (lhs < rhs) {

	cmp	rdx, r10
	jae	SHORT $LN5@COVER_stri

; 278  :   }
; 279  :   return result;

	mov	eax, edi

; 280  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN5@COVER_stri:

; 256  :   return (lhs > rhs);

	xor	eax, eax
	cmp	rdx, r10
	seta	al

; 275  :   int result = COVER_cmp8(g_ctx, lp, rp);
; 276  :   if (result == 0) {

	ja	SHORT $LN9@COVER_stri

; 277  :     result = lp < rp ? -1 : 1;

	cmp	rbx, r11
	cmovb	r9d, edi

; 278  :   }
; 279  :   return result;

	mov	eax, r9d
$LN9@COVER_stri:

; 280  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
COVER_strict_cmp8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
first$ = 8
last$ = 16
value$ = 24
COVER_lower_bound PROC

; 288  :   size_t count = last - first;

	sub	rdx, rcx
	mov	r9, r8
	sar	rdx, 3

; 289  :   while (count != 0) {

	test	rdx, rdx
	je	SHORT $LN10@COVER_lowe
	npad	1
$LL2@COVER_lowe:

; 290  :     size_t step = count / 2;

	mov	r8, rdx
	shr	r8, 1

; 291  :     const size_t *ptr = first;
; 292  :     ptr += step;
; 293  :     if (*ptr < value) {

	cmp	QWORD PTR [rcx+r8*8], r9
	lea	rax, QWORD PTR [rcx+r8*8]
	jae	SHORT $LN4@COVER_lowe

; 294  :       first = ++ptr;

	lea	rcx, QWORD PTR [rax+8]

; 295  :       count -= step + 1;

	mov	rax, -1
	sub	rax, r8
	add	rdx, rax

; 296  :     } else {

	jmp	SHORT $LN5@COVER_lowe
$LN4@COVER_lowe:

; 297  :       count = step;

	mov	rdx, r8
$LN5@COVER_lowe:

; 289  :   while (count != 0) {

	test	rdx, rdx
	jne	SHORT $LL2@COVER_lowe
$LN10@COVER_lowe:

; 298  :     }
; 299  :   }
; 300  :   return first;
; 301  : }

	mov	rax, rcx
	ret	0
COVER_lower_bound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
ctx$ = 16
group$ = 24
groupEnd$ = 32
COVER_group PROC

; 336  :                         const void *groupEnd) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14

; 337  :   /* The group consists of all the positions with the same first d bytes. */
; 338  :   const U32 *grpPtr = (const U32 *)group;
; 339  :   const U32 *grpEnd = (const U32 *)groupEnd;
; 340  :   /* The dmerId is how we will reference this dmer.
; 341  :    * This allows us to map the whole dmer space to a much smaller space, the
; 342  :    * size of the suffix array.
; 343  :    */
; 344  :   const U32 dmerId = (U32)(grpPtr - ctx->suffix);
; 345  :   /* Count the number of samples this dmer shows up in */
; 346  :   U32 freq = 0;
; 347  :   /* Details */
; 348  :   const size_t *curOffsetPtr = ctx->offsets;

	mov	r9, QWORD PTR [rcx+8]
	mov	rsi, rdx
	mov	r11, QWORD PTR [rcx+48]
	mov	r10, rdx

; 349  :   const size_t *offsetsEnd = ctx->offsets + ctx->nbSamples;

	mov	rax, QWORD PTR [rcx+24]
	sub	rsi, r11
	sar	rsi, 2
	xor	ebx, ebx

; 350  :   /* Once *grpPtr >= curSampleEnd this occurrence of the dmer is in a
; 351  :    * different sample than the last.
; 352  :    */
; 353  :   size_t curSampleEnd = ctx->offsets[0];

	mov	rdx, QWORD PTR [r9]
	mov	rdi, r8
	mov	rbp, rcx
	lea	r14, QWORD PTR [r9+rax*8]

; 354  :   for (; grpPtr != grpEnd; ++grpPtr) {

	cmp	r10, r8
	je	$LN21@COVER_grou
	npad	9
$LL4@COVER_grou:

; 355  :     /* Save the dmerId for this position so we can get back to it. */
; 356  :     ctx->dmerAt[*grpPtr] = dmerId;

	mov	ecx, DWORD PTR [r10]
	mov	rax, QWORD PTR [rbp+72]
	mov	DWORD PTR [rax+rcx*4], esi

; 357  :     /* Dictionaries only help for the first reference to the dmer.
; 358  :      * After that zstd can reference the match from the previous reference.
; 359  :      * So only count each dmer once for each sample it is in.
; 360  :      */
; 361  :     if (*grpPtr < curSampleEnd) {

	mov	r8d, DWORD PTR [r10]
	cmp	r8, rdx
	jb	SHORT $LN2@COVER_grou

; 362  :       continue;
; 363  :     }
; 364  :     freq += 1;

	inc	ebx

; 365  :     /* Binary search to find the end of the sample *grpPtr is in.
; 366  :      * In the common case that grpPtr + 1 == grpEnd we can skip the binary
; 367  :      * search because the loop is over.
; 368  :      */
; 369  :     if (grpPtr + 1 != grpEnd) {

	lea	rax, QWORD PTR [r10+4]
	cmp	rax, rdi
	je	SHORT $LN2@COVER_grou

; 288  :   size_t count = last - first;

	mov	rax, r14
	sub	rax, r9
	sar	rax, 3

; 289  :   while (count != 0) {

	test	rax, rax
	je	SHORT $LN10@COVER_grou
	npad	4
$LL9@COVER_grou:

; 290  :     size_t step = count / 2;

	mov	rdx, rax
	shr	rdx, 1

; 291  :     const size_t *ptr = first;
; 292  :     ptr += step;
; 293  :     if (*ptr < value) {

	cmp	QWORD PTR [r9+rdx*8], r8
	lea	rcx, QWORD PTR [r9+rdx*8]
	jae	SHORT $LN11@COVER_grou

; 294  :       first = ++ptr;

	lea	r9, QWORD PTR [rcx+8]

; 295  :       count -= step + 1;

	mov	rcx, -1
	sub	rcx, rdx
	add	rax, rcx

; 296  :     } else {

	jmp	SHORT $LN12@COVER_grou
$LN11@COVER_grou:

; 297  :       count = step;

	mov	rax, rdx
$LN12@COVER_grou:

; 289  :   while (count != 0) {

	test	rax, rax
	jne	SHORT $LL9@COVER_grou
$LN10@COVER_grou:

; 370  :       const size_t *sampleEndPtr =
; 371  :           COVER_lower_bound(curOffsetPtr, offsetsEnd, *grpPtr);
; 372  :       curSampleEnd = *sampleEndPtr;

	mov	rdx, QWORD PTR [r9]

; 373  :       curOffsetPtr = sampleEndPtr + 1;

	add	r9, 8
$LN2@COVER_grou:

; 354  :   for (; grpPtr != grpEnd; ++grpPtr) {

	add	r10, 4
	cmp	r10, rdi
	jne	SHORT $LL4@COVER_grou

; 374  :     }
; 375  :   }
; 376  :   /* At this point we are never going to look at this segment of the suffix
; 377  :    * array again.  We take advantage of this fact to save memory.
; 378  :    * We store the frequency of the dmer in the first position of the group,
; 379  :    * which is dmerId.
; 380  :    */
; 381  :   ctx->suffix[dmerId] = freq;

	mov	rax, QWORD PTR [rbp+48]
	mov	ecx, esi
	mov	DWORD PTR [rax+rcx*4], ebx
	jmp	SHORT $LN3@COVER_grou
$LN21@COVER_grou:
	mov	ecx, esi
	mov	DWORD PTR [r11+rcx*4], ebx
$LN3@COVER_grou:

; 382  : }

	mov	rbx, QWORD PTR [rsp+16]
	mov	rbp, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+40]
	pop	r14
	ret	0
COVER_group ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
activeSegment$ = 32
$T1 = 112
ctx$ = 120
freqs$ = 128
activeSegment$2$ = 136
activeDmers$ = 136
$T2 = 144
begin$ = 144
end$ = 152
tv952 = 160
parameters$ = 160
COVER_selectSegment PROC

; 399  :                                            ZDICT_cover_params_t parameters) {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 400  :   /* Constants */
; 401  :   const U32 k = parameters.k;
; 402  :   const U32 d = parameters.d;

	mov	rax, QWORD PTR parameters$[rsp]

; 403  :   const U32 dmersInK = k - d + 1;
; 404  :   /* Try each segment (activeSegment) and save the best (bestSegment) */
; 405  :   COVER_segment_t bestSegment = {0, 0, 0};

	xor	r15d, r15d

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	mov	rbx, QWORD PTR [r9]

; 399  :                                            ZDICT_cover_params_t parameters) {

	mov	r13, r8

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	mov	r8d, DWORD PTR [r9+12]

; 399  :                                            ZDICT_cover_params_t parameters) {

	mov	rsi, rdx
	mov	r12, rcx

; 403  :   const U32 dmersInK = k - d + 1;
; 404  :   /* Try each segment (activeSegment) and save the best (bestSegment) */
; 405  :   COVER_segment_t bestSegment = {0, 0, 0};

	mov	QWORD PTR [rcx], r15
	mov	edi, DWORD PTR [rax]

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	lea	edx, QWORD PTR [r15-1]

; 400  :   /* Constants */
; 401  :   const U32 k = parameters.k;
; 402  :   const U32 d = parameters.d;

	sub	edi, DWORD PTR [rax+4]
	mov	r14, r9

; 403  :   const U32 dmersInK = k - d + 1;
; 404  :   /* Try each segment (activeSegment) and save the best (bestSegment) */
; 405  :   COVER_segment_t bestSegment = {0, 0, 0};

	mov	DWORD PTR [rcx+8], r15d

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	mov	rcx, rbx
	shl	r8, 3
	call	memset

; 406  :   COVER_segment_t activeSegment;
; 407  :   /* Reset the activeDmers in the segment */
; 408  :   COVER_map_clear(activeDmers);
; 409  :   /* The activeSegment starts at the beginning of the epoch. */
; 410  :   activeSegment.begin = begin;

	mov	ebp, DWORD PTR begin$[rsp]

; 411  :   activeSegment.end = begin;
; 412  :   activeSegment.score = 0;

	xor	edx, edx
	xor	r9d, r9d
	mov	DWORD PTR activeSegment$[rsp], ebp
	xor	r10d, r10d
	mov	r11d, ebp
	cmp	ebp, DWORD PTR end$[rsp]

; 413  :   /* Slide the activeSegment through the whole epoch.
; 414  :    * Save the best segment in bestSegment.
; 415  :    */
; 416  :   while (activeSegment.end < end) {

	jae	$LN3@COVER_sele

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	r9d, 32					; 00000020H
	lea	r10d, DWORD PTR [rdi+2]
	sub	r9d, DWORD PTR [r14+8]
	mov	DWORD PTR $T2[rsp], r9d
	mov	DWORD PTR tv952[rsp], r10d
	npad	7
$LL2@COVER_sele:

; 417  :     /* The dmerId for the dmer at the next position */
; 418  :     U32 newDmer = ctx->dmerAt[activeSegment.end];

	mov	rax, QWORD PTR [rsi+72]
	mov	ecx, r11d
	mov	r8d, DWORD PTR [rax+rcx*4]

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	ecx, r9d
	imul	eax, r8d, -1640531535			; 9e3779b1H
	shr	eax, cl

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rax*8+4], -1		; ffffffffH
	lea	rdx, QWORD PTR [rbx+rax*8]
	je	SHORT $LN105@COVER_sele
$LL24@COVER_sele:

; 137  :       return i;
; 138  :     }
; 139  :     if (pos->key == key) {

	cmp	DWORD PTR [rdx], r8d
	je	SHORT $LN105@COVER_sele

; 126  : }
; 127  : 
; 128  : /**
; 129  :  * Helper function that returns the index that a key should be placed into.
; 130  :  */
; 131  : static U32 COVER_map_index(COVER_map_t *map, U32 key) {
; 132  :   const U32 hash = COVER_map_hash(map, key);
; 133  :   U32 i;
; 134  :   for (i = hash;; i = (i + 1) & map->sizeMask) {

	inc	eax
	and	eax, DWORD PTR [r14+16]

; 135  :     COVER_map_pair_t *pos = &map->data[i];
; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rax*8+4], -1		; ffffffffH
	lea	rdx, QWORD PTR [rbx+rax*8]
	jne	SHORT $LL24@COVER_sele
$LN105@COVER_sele:

; 151  :   COVER_map_pair_t *pos = &map->data[COVER_map_index(map, key)];

	lea	rax, QWORD PTR [rbx+rax*8]

; 152  :   if (pos->value == MAP_EMPTY_VALUE) {

	mov	edx, DWORD PTR [rax+4]
	lea	rcx, QWORD PTR [rax+4]
	cmp	edx, -1					; ffffffffH
	jne	SHORT $LN19@COVER_sele

; 153  :     pos->key = key;

	mov	DWORD PTR [rax], r8d

; 154  :     pos->value = 0;

	xor	edx, edx
	mov	DWORD PTR [rcx], 0

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	jmp	SHORT $LN103@COVER_sele
$LN19@COVER_sele:

; 419  :     /* The entry in activeDmers for this dmerId */
; 420  :     U32 *newDmerOcc = COVER_map_at(activeDmers, newDmer);
; 421  :     /* If the dmer isn't already present in the segment add its score. */
; 422  :     if (*newDmerOcc == 0) {

	test	edx, edx
	jne	SHORT $LN10@COVER_sele
$LN103@COVER_sele:

; 423  :       /* The paper suggest using the L-0.5 norm, but experiments show that it
; 424  :        * doesn't help.
; 425  :        */
; 426  :       activeSegment.score += freqs[newDmer];

	add	r15d, DWORD PTR [r13+r8*4]
$LN10@COVER_sele:

; 427  :     }
; 428  :     /* Add the dmer to the segment */
; 429  :     activeSegment.end += 1;

	inc	r11d

; 430  :     *newDmerOcc += 1;

	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR [rcx], eax
	mov	eax, r11d
	sub	eax, ebp
	mov	DWORD PTR activeSegment$2$[rsp], r11d
	mov	DWORD PTR activeSegment$[rsp+4], r11d

; 431  : 
; 432  :     /* If the window is now too large, drop the first position */
; 433  :     if (activeSegment.end - activeSegment.begin == dmersInK + 1) {

	cmp	eax, r10d
	jne	$LN12@COVER_sele

; 434  :       U32 delDmer = ctx->dmerAt[activeSegment.begin];

	mov	rax, QWORD PTR [rsi+72]
	mov	ecx, ebp
	mov	esi, DWORD PTR [rax+rcx*4]

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	ecx, r9d
	imul	edx, esi, -1640531535			; 9e3779b1H
	shr	edx, cl

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rdx*8+4], -1		; ffffffffH
	mov	ecx, edx
	lea	r8, QWORD PTR [rbx+rdx*8]
	mov	rax, r8
	je	SHORT $LN106@COVER_sele
$LL36@COVER_sele:

; 137  :       return i;
; 138  :     }
; 139  :     if (pos->key == key) {

	cmp	DWORD PTR [rax], esi
	je	SHORT $LN106@COVER_sele

; 126  : }
; 127  : 
; 128  : /**
; 129  :  * Helper function that returns the index that a key should be placed into.
; 130  :  */
; 131  : static U32 COVER_map_index(COVER_map_t *map, U32 key) {
; 132  :   const U32 hash = COVER_map_hash(map, key);
; 133  :   U32 i;
; 134  :   for (i = hash;; i = (i + 1) & map->sizeMask) {

	inc	ecx
	and	ecx, DWORD PTR [r14+16]

; 135  :     COVER_map_pair_t *pos = &map->data[i];
; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rcx*8+4], -1		; ffffffffH
	lea	rax, QWORD PTR [rbx+rcx*8]
	jne	SHORT $LL36@COVER_sele
$LN106@COVER_sele:

; 152  :   if (pos->value == MAP_EMPTY_VALUE) {

	mov	eax, DWORD PTR [rbx+rcx*8+4]
	lea	rcx, QWORD PTR [rbx+rcx*8]
	cmp	eax, -1					; ffffffffH
	jne	SHORT $LN31@COVER_sele

; 154  :     pos->value = 0;

	inc	ebp
	mov	DWORD PTR [rcx], esi
	mov	DWORD PTR activeSegment$[rsp], ebp
	mov	DWORD PTR [rcx+4], eax

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	jmp	$LN108@COVER_sele
$LN31@COVER_sele:

; 435  :       U32 *delDmerOcc = COVER_map_at(activeDmers, delDmer);
; 436  :       activeSegment.begin += 1;

	inc	ebp

; 437  :       *delDmerOcc -= 1;

	sub	eax, 1
	mov	DWORD PTR activeSegment$[rsp], ebp
	mov	DWORD PTR [rcx+4], eax

; 438  :       /* If this is the last occurrence of the dmer, subtract its score */
; 439  :       if (*delDmerOcc == 0) {

	jne	$LN108@COVER_sele

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [r8+4], -1			; ffffffffH
	je	SHORT $LN107@COVER_sele
$LL54@COVER_sele:

; 137  :       return i;
; 138  :     }
; 139  :     if (pos->key == key) {

	cmp	DWORD PTR [r8], esi
	je	SHORT $LN107@COVER_sele

; 126  : }
; 127  : 
; 128  : /**
; 129  :  * Helper function that returns the index that a key should be placed into.
; 130  :  */
; 131  : static U32 COVER_map_index(COVER_map_t *map, U32 key) {
; 132  :   const U32 hash = COVER_map_hash(map, key);
; 133  :   U32 i;
; 134  :   for (i = hash;; i = (i + 1) & map->sizeMask) {

	inc	edx
	and	edx, DWORD PTR [r14+16]

; 135  :     COVER_map_pair_t *pos = &map->data[i];
; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rdx*8+4], -1		; ffffffffH
	lea	r8, QWORD PTR [rbx+rdx*8]
	jne	SHORT $LL54@COVER_sele
$LN107@COVER_sele:

; 166  :   if (del->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rdx*8+4], -1		; ffffffffH
	lea	r11, QWORD PTR [rbx+rdx*8]
	mov	r9d, 1
	je	$LN44@COVER_sele

; 167  :     return;
; 168  :   }
; 169  :   for (i = (i + 1) & map->sizeMask;; i = (i + 1) & map->sizeMask) {

	mov	edi, DWORD PTR [r14+16]
	inc	edx
	and	edx, edi

; 170  :     COVER_map_pair_t *const pos = &map->data[i];
; 171  :     /* If the position is empty we are done */
; 172  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rdx*8+4], -1		; ffffffffH
	lea	r8, QWORD PTR [rbx+rdx*8]
	je	SHORT $LN76@COVER_sele
	mov	r12d, DWORD PTR $T2[rsp]
	npad	10
$LL45@COVER_sele:

; 125  :   return (key * prime4bytes) >> (32 - map->sizeLog);

	mov	r10d, DWORD PTR [r8]
	mov	ecx, r12d
	imul	eax, r10d, -1640531535			; 9e3779b1H
	shr	eax, cl

; 177  :     if (((i - COVER_map_hash(map, pos->key)) & map->sizeMask) >= shift) {

	mov	ecx, edx
	sub	ecx, eax
	and	ecx, edi
	cmp	ecx, r9d
	jb	SHORT $LN48@COVER_sele

; 178  :       del->key = pos->key;

	mov	DWORD PTR [r11], r10d

; 179  :       del->value = pos->value;
; 180  :       del = pos;
; 181  :       shift = 1;

	mov	r9d, 1
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [r11+4], eax
	mov	r11, r8

; 182  :     } else {

	jmp	SHORT $LN43@COVER_sele
$LN48@COVER_sele:

; 183  :       ++shift;

	inc	r9d
$LN43@COVER_sele:

; 167  :     return;
; 168  :   }
; 169  :   for (i = (i + 1) & map->sizeMask;; i = (i + 1) & map->sizeMask) {

	inc	edx
	and	edx, edi

; 170  :     COVER_map_pair_t *const pos = &map->data[i];
; 171  :     /* If the position is empty we are done */
; 172  :     if (pos->value == MAP_EMPTY_VALUE) {

	cmp	DWORD PTR [rbx+rdx*8+4], -1		; ffffffffH
	lea	r8, QWORD PTR [rbx+rdx*8]
	jne	SHORT $LL45@COVER_sele
	mov	r12, QWORD PTR $T1[rsp]
	mov	r10d, DWORD PTR tv952[rsp]
$LN76@COVER_sele:

; 173  :       del->value = MAP_EMPTY_VALUE;

	mov	DWORD PTR [r11+4], -1			; ffffffffH
$LN44@COVER_sele:

; 440  :         COVER_map_remove(activeDmers, delDmer);
; 441  :         activeSegment.score -= freqs[delDmer];

	sub	r15d, DWORD PTR [r13+rsi*4]
	mov	r11d, DWORD PTR activeSegment$2$[rsp]
	mov	r9d, DWORD PTR $T2[rsp]
$LN108@COVER_sele:

; 442  :       }
; 443  :     }
; 444  : 
; 445  :     /* If this segment is the best so far save it */
; 446  :     if (activeSegment.score > bestSegment.score) {

	mov	rsi, QWORD PTR ctx$[rsp]
$LN12@COVER_sele:
	cmp	r15d, DWORD PTR [r12+8]
	jbe	SHORT $LN13@COVER_sele

; 447  :       bestSegment = activeSegment;

	movsd	xmm0, QWORD PTR activeSegment$[rsp]
	movsd	QWORD PTR [r12], xmm0
	mov	DWORD PTR [r12+8], r15d
$LN13@COVER_sele:

; 413  :   /* Slide the activeSegment through the whole epoch.
; 414  :    * Save the best segment in bestSegment.
; 415  :    */
; 416  :   while (activeSegment.end < end) {

	cmp	r11d, DWORD PTR end$[rsp]
	jb	$LL2@COVER_sele

; 136  :     if (pos->value == MAP_EMPTY_VALUE) {

	mov	edx, DWORD PTR [r12+4]
	mov	r10d, edx
	mov	r9d, DWORD PTR [r12]
$LN3@COVER_sele:

; 448  :     }
; 449  :   }
; 450  :   {
; 451  :     /* Trim off the zero frequency head and tail from the segment. */
; 452  :     U32 newBegin = bestSegment.end;
; 453  :     U32 newEnd = bestSegment.begin;
; 454  :     U32 pos;
; 455  :     for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {

	mov	r8d, r9d
	cmp	r9d, edx
	je	SHORT $LN5@COVER_sele

; 456  :       U32 freq = freqs[ctx->dmerAt[pos]];

	mov	r11, QWORD PTR [rsi+72]
	npad	1
$LL6@COVER_sele:
	mov	eax, r8d
	mov	ecx, DWORD PTR [r11+rax*4]

; 457  :       if (freq != 0) {

	cmp	DWORD PTR [r13+rcx*4], 0
	je	SHORT $LN4@COVER_sele

; 458  :         newBegin = MIN(newBegin, pos);

	cmp	edx, r8d

; 459  :         newEnd = pos + 1;

	lea	r9d, DWORD PTR [r8+1]
	mov	eax, r8d
	cmovb	eax, edx
	mov	edx, eax
$LN4@COVER_sele:

; 448  :     }
; 449  :   }
; 450  :   {
; 451  :     /* Trim off the zero frequency head and tail from the segment. */
; 452  :     U32 newBegin = bestSegment.end;
; 453  :     U32 newEnd = bestSegment.begin;
; 454  :     U32 pos;
; 455  :     for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {

	inc	r8d
	cmp	r8d, r10d
	jne	SHORT $LL6@COVER_sele
$LN5@COVER_sele:

; 460  :       }
; 461  :     }
; 462  :     bestSegment.begin = newBegin;

	mov	DWORD PTR [r12], edx

; 463  :     bestSegment.end = newEnd;

	mov	DWORD PTR [r12+4], r9d

; 464  :   }
; 465  :   {
; 466  :     /* Zero out the frequency of each dmer covered by the chosen segment. */
; 467  :     U32 pos;
; 468  :     for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {

	cmp	edx, r9d
	je	SHORT $LN104@COVER_sele
	xor	r8d, r8d
	npad	9
$LL9@COVER_sele:

; 469  :       freqs[ctx->dmerAt[pos]] = 0;

	mov	rax, QWORD PTR [rsi+72]
	mov	ecx, edx
	inc	edx
	mov	ecx, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR [r13+rcx*4], r8d
	cmp	edx, r9d
	jne	SHORT $LL9@COVER_sele
$LN104@COVER_sele:

; 470  :     }
; 471  :   }
; 472  :   return bestSegment;
; 473  : }

	mov	rbx, QWORD PTR [rsp+128]
	mov	rax, r12
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
COVER_selectSegment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
segment$1 = 64
$T2 = 80
$T3 = 96
ctx$ = 208
freqs$ = 216
activeDmers$ = 224
dictBuffer$ = 232
epochs$4 = 240
dictBufferCapacity$ = 240
$T5 = 240
maxZeroScoreRun$1$ = 248
parameters$ = 248
COVER_buildDictionary PROC

; 669  :                                     ZDICT_cover_params_t parameters) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H

; 670  :   BYTE *const dict = (BYTE *)dictBuffer;
; 671  :   size_t tail = dictBufferCapacity;

	mov	r12, QWORD PTR dictBufferCapacity$[rsp]

; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	xor	edx, edx

; 672  :   /* Divide the data into epochs. We will select one segment from each epoch. */
; 673  :   const COVER_epoch_info_t epochs = COVER_computeEpochs(

	mov	r15, QWORD PTR parameters$[rsp]

; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	mov	eax, r12d

; 672  :   /* Divide the data into epochs. We will select one segment from each epoch. */
; 673  :   const COVER_epoch_info_t epochs = COVER_computeEpochs(

	mov	ebx, DWORD PTR [rcx+56]
	mov	r13, rcx
	mov	rsi, r12
	mov	r10d, DWORD PTR [r15]

; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	div	r10d
	lea	r11d, DWORD PTR [r10+r10*4]
	mov	r8d, eax
	add	r11d, r11d
	shr	r8d, 2
	mov	eax, 1
	cmp	r8d, eax
	cmovb	r8d, eax

; 652  :   epochs.size = nbDmers / epochs.num;

	xor	edx, edx
	mov	eax, ebx
	mov	DWORD PTR epochs$4[rsp], r8d
	div	r8d
	mov	DWORD PTR epochs$4[rsp+4], eax
	cmp	eax, r11d

; 653  :   if (epochs.size >= minEpochSize) {

	jb	SHORT $LN23@COVER_buil

; 654  :       assert(epochs.size * epochs.num <= nbDmers);
; 655  :       return epochs;

	mov	rbx, QWORD PTR epochs$4[rsp]
	jmp	SHORT $LN35@COVER_buil
$LN23@COVER_buil:

; 656  :   }
; 657  :   epochs.size = MIN(minEpochSize, nbDmers);

	mov	ecx, ebx
	cmp	r11d, ebx
	mov	eax, ebx
	cmovb	ecx, r11d
	xor	edx, edx
	div	ecx

; 658  :   epochs.num = nbDmers / epochs.size;

	shl	rcx, 32					; 00000020H
	mov	ebx, eax
	or	rbx, rcx
$LN35@COVER_buil:

; 672  :   /* Divide the data into epochs. We will select one segment from each epoch. */
; 673  :   const COVER_epoch_info_t epochs = COVER_computeEpochs(

	mov	eax, ebx
	mov	QWORD PTR $T5[rsp], rbx
	shr	eax, 3

; 674  :       (U32)dictBufferCapacity, (U32)ctx->suffixSize, parameters.k, 4);
; 675  :   const size_t maxZeroScoreRun = MAX(10, MIN(100, epochs.num >> 3));

	cmp	eax, 100				; 00000064H
	jbe	SHORT $LN14@COVER_buil
	mov	eax, 100				; 00000064H
	jmp	SHORT $LN16@COVER_buil
$LN14@COVER_buil:
	mov	ecx, 10
	cmp	eax, ecx
	cmovb	eax, ecx
$LN16@COVER_buil:

; 676  :   size_t zeroScoreRun = 0;

	xor	ebp, ebp
	mov	QWORD PTR maxZeroScoreRun$1$[rsp], rax

; 677  :   size_t epoch;
; 678  :   DISPLAYLEVEL(2, "Breaking content into %u epochs of size %u\n",

	mov	rdi, rbx
	shr	rdi, 32					; 00000020H
	lea	ecx, QWORD PTR [rbp+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, edi
	lea	rdx, OFFSET FLAT:$SG4294962268
	mov	rcx, rax
	mov	r8d, ebx
	call	fprintf
	lea	ecx, QWORD PTR [rbp+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 679  :                 (U32)epochs.num, (U32)epochs.size);
; 680  :   /* Loop through the epochs until there are no more segments or the dictionary
; 681  :    * is full.
; 682  :    */
; 683  :   for (epoch = 0; tail > 0; epoch = (epoch + 1) % epochs.num) {

	xor	r14d, r14d
	test	r12, r12
	je	$LN34@COVER_buil
	npad	15
$LL4@COVER_buil:

; 684  :     const U32 epochBegin = (U32)(epoch * epochs.size);

	mov	eax, DWORD PTR $T5[rsp+4]

; 685  :     const U32 epochEnd = epochBegin + epochs.size;
; 686  :     size_t segmentSize;
; 687  :     /* Select a segment */
; 688  :     COVER_segment_t segment = COVER_selectSegment(

	lea	rdx, QWORD PTR $T3[rsp]
	movaps	xmm0, XMMWORD PTR [r15]
	mov	ecx, r14d
	movaps	xmm1, XMMWORD PTR [r15+16]
	mov	r9, QWORD PTR activeDmers$[rsp]
	mov	r8, QWORD PTR freqs$[rsp]
	imul	ecx, eax
	mov	QWORD PTR [rsp+48], rdx
	mov	rdx, r13
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [r15+32]
	movaps	XMMWORD PTR $T3[rsp+16], xmm1
	add	eax, ecx
	movaps	XMMWORD PTR $T3[rsp+32], xmm0
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	lea	rcx, QWORD PTR $T2[rsp]
	call	COVER_selectSegment

; 689  :         ctx, freqs, activeDmers, epochBegin, epochEnd, parameters);
; 690  :     /* If the segment covers no dmers, then we are out of content.
; 691  :      * There may be new content in other epochs, for continue for some time.
; 692  :      */
; 693  :     if (segment.score == 0) {

	cmp	DWORD PTR [rax+8], 0
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR segment$1[rsp], xmm0
	jne	SHORT $LN6@COVER_buil

; 694  :       if (++zeroScoreRun >= maxZeroScoreRun) {

	inc	rbp
	cmp	rbp, QWORD PTR maxZeroScoreRun$1$[rsp]
	jae	$LN34@COVER_buil

; 695  :           break;
; 696  :       }
; 697  :       continue;

	jmp	$LN2@COVER_buil
$LN6@COVER_buil:

; 698  :     }
; 699  :     zeroScoreRun = 0;
; 700  :     /* Trim the segment if necessary and if it is too small then we are done */
; 701  :     segmentSize = MIN(segment.end - segment.begin + parameters.d - 1, tail);

	mov	ecx, DWORD PTR [r15+4]
	xor	ebp, ebp
	mov	rax, QWORD PTR segment$1[rsp]
	mov	edx, DWORD PTR segment$1[rsp]
	shr	rax, 32					; 00000020H
	lea	r8d, DWORD PTR [rcx-1]
	sub	eax, edx
	add	r8d, eax

; 702  :     if (segmentSize < parameters.d) {

	cmp	r8, rsi
	cmovae	r8, rsi
	cmp	r8, rcx
	jb	$LN34@COVER_buil

; 703  :       break;
; 704  :     }
; 705  :     /* We fill the dictionary from the back to allow the best segments to be
; 706  :      * referenced with the smallest offsets.
; 707  :      */
; 708  :     tail -= segmentSize;
; 709  :     memcpy(dict + tail, ctx->samples + segment.begin, segmentSize);

	mov	rcx, QWORD PTR dictBuffer$[rsp]
	sub	rsi, r8
	add	rdx, QWORD PTR [r13]
	add	rcx, rsi
	call	memcpy

; 710  :     DISPLAYUPDATE(

	call	QWORD PTR __imp_clock
	sub	eax, DWORD PTR g_time
	cmp	eax, 150				; 00000096H
	jle	SHORT $LN2@COVER_buil
	call	QWORD PTR __imp_clock
	mov	DWORD PTR g_time, eax
	xor	edx, edx
	mov	rax, r12
	lea	ecx, QWORD PTR [rbp+2]
	sub	rax, rsi
	imul	rax, rax, 100				; 00000064H
	div	r12
	mov	rdi, rax
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294962267
	mov	rcx, rax
	call	fprintf
	lea	ecx, QWORD PTR [rbp+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN2@COVER_buil:

; 679  :                 (U32)epochs.num, (U32)epochs.size);
; 680  :   /* Loop through the epochs until there are no more segments or the dictionary
; 681  :    * is full.
; 682  :    */
; 683  :   for (epoch = 0; tail > 0; epoch = (epoch + 1) % epochs.num) {

	lea	rax, QWORD PTR [r14+1]
	mov	r8d, ebx
	xor	edx, edx
	div	r8
	mov	r14, rdx
	test	rsi, rsi
	jne	$LL4@COVER_buil
$LN34@COVER_buil:

; 711  :         2, "\r%u%%       ",
; 712  :         (unsigned)(((dictBufferCapacity - tail) * 100) / dictBufferCapacity));
; 713  :   }
; 714  :   DISPLAYLEVEL(2, "\r%79s\r", "");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r8, OFFSET FLAT:$SG4294962266
	lea	rdx, OFFSET FLAT:$SG4294962265
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 715  :   return tail;
; 716  : }

	mov	rbx, QWORD PTR [rsp+208]
	mov	rax, rsi
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
COVER_buildDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
cMem$3 = 80
$T4 = 80
$T5 = 80
dstCapacity$1$ = 224
parameters$ = 224
samplesSizes$ = 232
samples$ = 240
offsets$ = 248
src$1$ = 256
nbTrainSamples$ = 256
dst$1$ = 264
nbSamples$ = 264
dict$ = 272
dictBufferCapacity$ = 280
COVER_checkTotalCompressedSize PROC

; 782  :                                     BYTE *const dict, size_t dictBufferCapacity) {

$LN94:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+32], r9
	mov	QWORD PTR [rax+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H

; 783  :   size_t totalCompressedSize = ERROR(GENERIC);
; 784  :   /* Pointers */
; 785  :   ZSTD_CCtx *cctx;
; 786  :   ZSTD_CDict *cdict;
; 787  :   void *dst;
; 788  :   /* Local variables */
; 789  :   size_t dstCapacity;
; 790  :   size_t i;
; 791  :   /* Allocate dst with enough space to compress the maximum sized sample */
; 792  :   {
; 793  :     size_t maxSampleSize = 0;
; 794  :     i = parameters.splitPoint < 1.0 ? nbTrainSamples : 0;
; 795  :     for (; i < nbSamples; ++i) {

	mov	r12, QWORD PTR nbSamples$[rsp]
	xor	r10d, r10d
	movaps	XMMWORD PTR [rax-72], xmm6
	xor	r11d, r11d
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	r15, rcx
	movaps	XMMWORD PTR [rax-104], xmm8
	mov	r13, rdx
	movsd	xmm8, QWORD PTR __real@3ff0000000000000
	mov	rsi, -1
	comisd	xmm8, QWORD PTR [rcx+16]
	mov	ecx, 131072				; 00020000H
	cmova	r10, QWORD PTR nbTrainSamples$[rsp]
	cmp	r10, r12
	jae	SHORT $LN85@COVER_chec
	npad	5
$LL4@COVER_chec:

; 796  :       maxSampleSize = MAX(samplesSizes[i], maxSampleSize);

	mov	rax, QWORD PTR [rdx+r10*8]
	cmp	rax, r11
	cmovbe	rax, r11
	inc	r10
	mov	r11, rax
	cmp	r10, r12
	jb	SHORT $LL4@COVER_chec
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	cmp	rax, rcx
	jb	SHORT $LN85@COVER_chec
	xor	ecx, ecx
	jmp	SHORT $LN18@COVER_chec
$LN85@COVER_chec:
	sub	rcx, r11
	shr	rcx, 11
$LN18@COVER_chec:
	mov	rax, r11
	shr	rax, 8
	add	rax, rcx
	add	rax, r11
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 799  :     dst = malloc(dstCapacity);

	mov	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	QWORD PTR dstCapacity$1$[rsp], rax
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 799  :     dst = malloc(dstCapacity);

	call	QWORD PTR __imp_malloc
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	movups	xmm6, XMMWORD PTR ZSTD_defaultCMem
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	mov	ecx, 1160				; 00000488H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 799  :     dst = malloc(dstCapacity);

	mov	rbp, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	movsd	xmm7, QWORD PTR ZSTD_defaultCMem+16
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 799  :     dst = malloc(dstCapacity);

	mov	QWORD PTR dst$1$[rsp], rax
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 87   :         if (!cctx) return NULL;

	test	rax, rax
	je	SHORT $LN21@COVER_chec
$LN23@COVER_chec:

; 88   :         ZSTD_initCCtx(cctx, customMem);

	lea	rdx, QWORD PTR $T5[rsp]
	movaps	XMMWORD PTR $T5[rsp], xmm6
	mov	rcx, rax
	movsd	QWORD PTR $T5[rsp+16], xmm7
	call	ZSTD_initCCtx
$LN21@COVER_chec:
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 803  :   cdict = ZSTD_createCDict(dict, dictBufferCapacity,

	mov	r14, QWORD PTR dictBufferCapacity$[rsp]
	mov	r8d, DWORD PTR [r15+32]
	mov	rdx, r14
	mov	rcx, QWORD PTR dict$[rsp]
	call	ZSTD_createCDict
	mov	rdi, rax

; 804  :                            parameters.zParams.compressionLevel);
; 805  :   if (!dst || !cctx || !cdict) {

	test	rbp, rbp
	je	$_compressCleanup$95
	test	rbx, rbx
	je	$LN54@COVER_chec
	test	rax, rax
	je	$LN87@COVER_chec

; 806  :     goto _compressCleanup;
; 807  :   }
; 808  :   /* Compress each sample and sum their sizes (or error) */
; 809  :   totalCompressedSize = dictBufferCapacity;
; 810  :   i = parameters.splitPoint < 1.0 ? nbTrainSamples : 0;

	xor	r8d, r8d
	mov	rsi, r14
	comisd	xmm8, QWORD PTR [r15+16]
	mov	ebp, r8d
	cmova	rbp, QWORD PTR nbTrainSamples$[rsp]

; 811  :   for (; i < nbSamples; ++i) {

	cmp	rbp, r12
	jae	$LN92@COVER_chec

; 806  :     goto _compressCleanup;
; 807  :   }
; 808  :   /* Compress each sample and sum their sizes (or error) */
; 809  :   totalCompressedSize = dictBufferCapacity;
; 810  :   i = parameters.splitPoint < 1.0 ? nbTrainSamples : 0;

	mov	rax, QWORD PTR offsets$[rsp]
	sub	r13, rax
	lea	r14, QWORD PTR [rax+rbp*8]
$LL7@COVER_chec:

; 812  :     const size_t size = ZSTD_compress_usingCDict(

	mov	rax, QWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	rdx, rdi
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 812  :     const size_t size = ZSTD_compress_usingCDict(

	mov	r15, QWORD PTR [r14+r13]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 812  :     const size_t size = ZSTD_compress_usingCDict(

	add	rax, QWORD PTR samples$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	r9, r15
	mov	DWORD PTR $T1[rsp+8], r8d
	lea	r8, QWORD PTR $T1[rsp]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 812  :     const size_t size = ZSTD_compress_usingCDict(

	mov	QWORD PTR src$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	QWORD PTR $T1[rsp], 1
	call	ZSTD_compressBegin_usingCDict_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	ja	SHORT $LN88@COVER_chec

; 3588 :     return ZSTD_compressEnd(cctx, dst, dstCapacity, src, srcSize);

	mov	r9, QWORD PTR src$1$[rsp]
	mov	rcx, rbx
	mov	r8, QWORD PTR dstCapacity$1$[rsp]
	mov	rdx, QWORD PTR dst$1$[rsp]
	mov	QWORD PTR [rsp+32], r15
	call	ZSTD_compressEnd
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 815  :     if (ZSTD_isError(size)) {

	ja	SHORT $LN88@COVER_chec

; 817  :       goto _compressCleanup;
; 818  :     }
; 819  :     totalCompressedSize += size;

	add	rsi, rax
	inc	rbp
	add	r14, 8
	cmp	rbp, r12
	jae	SHORT $LN92@COVER_chec

; 811  :   for (; i < nbSamples; ++i) {

	xor	r8d, r8d
	jmp	SHORT $LL7@COVER_chec
$LN88@COVER_chec:

; 816  :       totalCompressedSize = size;

	mov	rsi, rax
$LN92@COVER_chec:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 150  :     RETURN_ERROR_IF(cctx->staticSize, memory_allocation,

	mov	rbp, QWORD PTR dst$1$[rsp]
$LN87@COVER_chec:
	cmp	QWORD PTR [rbx+520], 0
	jne	SHORT $LN54@COVER_chec
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	QWORD PTR [rbx+312], rbx
	ja	SHORT $LN49@COVER_chec
	cmp	rbx, QWORD PTR [rbx+320]
	ja	SHORT $LN49@COVER_chec
	mov	rcx, rbx
	call	ZSTD_freeCCtxContent
	jmp	SHORT $LN54@COVER_chec
$_compressCleanup$95:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 149  :     if (cctx==NULL) return 0;   /* support free on NULL */

	test	rbx, rbx
	je	SHORT $LN54@COVER_chec
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 811  :   for (; i < nbSamples; ++i) {

	jmp	SHORT $LN87@COVER_chec
$LN49@COVER_chec:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	mov	rcx, rbx
	call	ZSTD_freeCCtxContent
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 156  :             ZSTD_free(cctx, cctx->customMem);

	movups	xmm1, XMMWORD PTR [rbx+496]
	movsd	xmm0, QWORD PTR [rbx+512]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 156  :             ZSTD_free(cctx, cctx->customMem);

	movsd	QWORD PTR $T4[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN53@COVER_chec

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T4[rsp+16]
	mov	rdx, rbx
	call	rax
	jmp	SHORT $LN54@COVER_chec
$LN53@COVER_chec:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN54@COVER_chec:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3468 :     if (cdict==NULL) return 0;   /* support free on NULL */

	test	rdi, rdi
	je	$LN74@COVER_chec

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movups	xmm0, XMMWORD PTR [rdi+4896]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	mov	rcx, QWORD PTR [rdi+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movsd	xmm1, QWORD PTR [rdi+4912]
	movsd	QWORD PTR cMem$3[rsp+16], xmm1
	movups	XMMWORD PTR cMem$3[rsp], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	rcx, rdi
	ja	SHORT $LN62@COVER_chec
	cmp	rdi, QWORD PTR [rdi+32]
	ja	SHORT $LN62@COVER_chec
	mov	ebx, 1
	jmp	SHORT $LN63@COVER_chec
$LN62@COVER_chec:
	xor	ebx, ebx
$LN63@COVER_chec:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3471 :         ZSTD_cwksp_free(&cdict->workspace, cMem);

	movaps	XMMWORD PTR $T2[rsp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rdi+24], xmm0
	movups	XMMWORD PTR [rdi+40], xmm0
	movups	XMMWORD PTR [rdi+56], xmm0
	movups	XMMWORD PTR [rdi+72], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN69@COVER_chec

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T2[rsp+8]
	test	rax, rax
	je	SHORT $LN68@COVER_chec

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax
	jmp	SHORT $LN69@COVER_chec
$LN68@COVER_chec:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN69@COVER_chec:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3472 :         if (!cdictInWorkspace) {

	test	ebx, ebx
	jne	SHORT $LN74@COVER_chec
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR cMem$3[rsp+8]
	test	rax, rax
	je	SHORT $LN73@COVER_chec

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$3[rsp+16]
	mov	rdx, rdi
	call	rax
	jmp	SHORT $LN74@COVER_chec
$LN73@COVER_chec:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN74@COVER_chec:
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 824  :   if (dst) {

	test	rbp, rbp
	je	SHORT $LN90@COVER_chec

; 825  :     free(dst);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN90@COVER_chec:

; 826  :   }
; 827  :   return totalCompressedSize;
; 828  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rax, rsi
	mov	rbx, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
COVER_checkTotalCompressedSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
_TEXT	SEGMENT
activeDmers$ = 96
$T1 = 96
parameters$3$ = 120
selection$ = 136
parameters$4$ = 160
parameters$5$ = 176
$T2 = 192
$T3 = 192
$T4 = 240
$T5 = 240
liveJobs$1$ = 336
r$6 = 336
opaque$ = 336
COVER_tryParameters PROC

; 1056 : static void COVER_tryParameters(void *opaque) {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H

; 1057 :   /* Save parameters as local variables */
; 1058 :   COVER_tryParameters_data_t *const data = (COVER_tryParameters_data_t *)opaque;
; 1059 :   const COVER_ctx_t *const ctx = data->ctx;
; 1060 :   const ZDICT_cover_params_t parameters = data->parameters;

	movups	xmm0, XMMWORD PTR [rcx+24]

; 1061 :   size_t dictBufferCapacity = data->dictBufferCapacity;

	mov	r13, QWORD PTR [rcx+16]
	mov	r12, rcx
	mov	r14, QWORD PTR [rcx]
	movups	XMMWORD PTR parameters$3$[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rcx+40]
	movups	XMMWORD PTR parameters$4$[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rcx+56]

; 1062 :   size_t totalCompressedSize = ERROR(GENERIC);
; 1063 :   /* Allocate space for hash table, dict, and freqs */
; 1064 :   COVER_map_t activeDmers;
; 1065 :   BYTE *const dict = (BYTE * const)malloc(dictBufferCapacity);

	mov	rcx, r13
	movups	XMMWORD PTR parameters$5$[rbp-256], xmm0
	call	QWORD PTR __imp_malloc

; 1067 :   U32 *freqs = (U32 *)malloc(ctx->suffixSize * sizeof(U32));

	mov	rcx, QWORD PTR [r14+56]

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	xor	edi, edi
	mov	QWORD PTR $T1[rsp], rdi

; 1062 :   size_t totalCompressedSize = ERROR(GENERIC);
; 1063 :   /* Allocate space for hash table, dict, and freqs */
; 1064 :   COVER_map_t activeDmers;
; 1065 :   BYTE *const dict = (BYTE * const)malloc(dictBufferCapacity);

	mov	rbx, rax

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	mov	QWORD PTR $T1[rsp+8], rdi

; 1066 :   COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));

	movups	xmm0, XMMWORD PTR $T1[rsp]

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	mov	QWORD PTR $T1[rsp+16], -1

; 1066 :   COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));

	movsd	xmm1, QWORD PTR $T1[rsp+16]

; 1067 :   U32 *freqs = (U32 *)malloc(ctx->suffixSize * sizeof(U32));

	shl	rcx, 2
	movups	XMMWORD PTR selection$[rbp-256], xmm0
	movsd	QWORD PTR selection$[rbp-240], xmm1
	call	QWORD PTR __imp_malloc
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	movups	xmm0, XMMWORD PTR parameters$3$[rsp]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 1067 :   U32 *freqs = (U32 *)malloc(ctx->suffixSize * sizeof(U32));

	mov	r15, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$6[rbp-256], edi
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 107  :   map->sizeLog = ZSTD_highbit32(size) + 2;

	mov	eax, 1
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	movd	edx, xmm0
	psrldq	xmm0, 4
	movd	ecx, xmm0
	sub	edx, ecx
	mov	ecx, edi
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 1068 :   if (!COVER_map_init(&activeDmers, parameters.k - parameters.d + 1)) {

	inc	edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, edx
	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 107  :   map->sizeLog = ZSTD_highbit32(size) + 2;

	add	ecx, 2
	shl	eax, cl
	mov	esi, eax

; 108  :   map->size = (U32)1 << map->sizeLog;

	dec	eax
	mov	DWORD PTR activeDmers$[rsp+8], ecx
	mov	DWORD PTR activeDmers$[rsp+12], esi

; 109  :   map->sizeMask = map->size - 1;
; 110  :   map->data = (COVER_map_pair_t *)malloc(map->size * sizeof(COVER_map_pair_t));

	shl	rsi, 3
	mov	rcx, rsi
	mov	DWORD PTR activeDmers$[rsp+16], eax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR activeDmers$[rsp], rax
	mov	rdi, rax

; 111  :   if (!map->data) {

	test	rax, rax
	je	$LN42@COVER_tryP

; 97   :   memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));

	mov	r8, rsi
	mov	edx, -1
	mov	rcx, rax
	call	memset

; 1070 :     goto _cleanup;
; 1071 :   }
; 1072 :   if (!dict || !freqs) {

	test	rbx, rbx
	je	$LN5@COVER_tryP
	test	r15, r15
	je	$LN5@COVER_tryP

; 1074 :     goto _cleanup;
; 1075 :   }
; 1076 :   /* Copy the frequencies because we need to modify them */
; 1077 :   memcpy(freqs, ctx->freqs, ctx->suffixSize * sizeof(U32));

	mov	r8, QWORD PTR [r14+56]
	mov	rcx, r15
	mov	rdx, QWORD PTR [r14+64]
	shl	r8, 2
	call	memcpy

; 1078 :   /* Build the dictionary */
; 1079 :   {
; 1080 :     const size_t tail = COVER_buildDictionary(ctx, freqs, &activeDmers, dict,

	movups	xmm0, XMMWORD PTR parameters$3$[rsp]
	lea	rax, QWORD PTR $T4[rbp-256]
	mov	r9, rbx
	movups	xmm1, XMMWORD PTR parameters$4$[rbp-256]
	lea	r8, QWORD PTR activeDmers$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movaps	XMMWORD PTR $T4[rbp-256], xmm0
	mov	rdx, r15
	movups	xmm0, XMMWORD PTR parameters$5$[rbp-256]
	mov	rcx, r14
	mov	QWORD PTR [rsp+32], r13
	movaps	XMMWORD PTR $T4[rbp-240], xmm1
	movaps	XMMWORD PTR $T4[rbp-224], xmm0
	call	COVER_buildDictionary

; 1082 :     selection = COVER_selectDict(dict + tail, dictBufferCapacity - tail,

	mov	rcx, QWORD PTR [r14+32]
	sub	r13, rax
	movups	xmm0, XMMWORD PTR parameters$3$[rsp]
	mov	r9, QWORD PTR [r14]
	mov	r8, r13
	lea	rdx, QWORD PTR [rax+rbx]
	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR [rsp+72], rax
	lea	rax, QWORD PTR $T3[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR [r14+24]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR [r14+16]
	mov	QWORD PTR [rsp+48], rcx
	movaps	XMMWORD PTR $T3[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR parameters$4$[rbp-256]
	mov	DWORD PTR [rsp+40], ecx
	lea	rcx, QWORD PTR $T5[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T3[rbp-240], xmm0
	movups	xmm0, XMMWORD PTR parameters$5$[rbp-256]
	movaps	XMMWORD PTR $T3[rbp-224], xmm0
	call	COVER_selectDict
	movups	xmm0, XMMWORD PTR [rax]
	movsd	xmm1, QWORD PTR [rax+16]

; 1083 :         ctx->samples, ctx->samplesSizes, (unsigned)ctx->nbTrainSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,
; 1084 :         totalCompressedSize);
; 1085 : 
; 1086 :     if (COVER_dictSelectionIsError(selection)) {

	movsd	QWORD PTR $T2[rbp-240], xmm1
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	QWORD PTR $T2[rbp-240], -120		; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 1082 :     selection = COVER_selectDict(dict + tail, dictBufferCapacity - tail,

	movups	XMMWORD PTR selection$[rbp-256], xmm0

; 1083 :         ctx->samples, ctx->samplesSizes, (unsigned)ctx->nbTrainSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,
; 1084 :         totalCompressedSize);
; 1085 : 
; 1086 :     if (COVER_dictSelectionIsError(selection)) {

	movaps	XMMWORD PTR $T2[rbp-256], xmm0
	movsd	QWORD PTR selection$[rbp-240], xmm1

; 942  :   return (ZSTD_isError(selection.totalCompressedSize) || !selection.dictContent);

	ja	SHORT $LN22@COVER_tryP
	cmp	QWORD PTR $T2[rbp-256], 0
	je	SHORT $LN22@COVER_tryP
	mov	rdi, QWORD PTR activeDmers$[rsp]
	jmp	SHORT $_cleanup$46
$LN22@COVER_tryP:

; 1087 :       DISPLAYLEVEL(1, "Failed to select dictionary\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962256
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 1088 :       goto _cleanup;

	mov	rdi, QWORD PTR activeDmers$[rsp]
	jmp	SHORT $_cleanup$46
$LN5@COVER_tryP:

; 1073 :     DISPLAYLEVEL(1, "Failed to allocate buffers: out of memory\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962257
	jmp	SHORT $LN44@COVER_tryP
$LN42@COVER_tryP:

; 1069 :     DISPLAYLEVEL(1, "Failed to allocate dmer map: out of memory\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962258
$LN44@COVER_tryP:

; 1089 :     }
; 1090 :   }
; 1091 : _cleanup:
; 1092 :   free(dict);

	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$_cleanup$46:
	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 1093 :   COVER_best_finish(data->best, parameters, selection);

	mov	rbx, QWORD PTR [r12+8]

; 897  :   if (!best) {

	mov	r14, QWORD PTR selection$[rbp-256]
	test	rbx, rbx
	je	$LN26@COVER_tryP

; 898  :     return;
; 899  :   }
; 900  :   {
; 901  :     size_t liveJobs;
; 902  :     ZSTD_pthread_mutex_lock(&best->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 903  :     --best->liveJobs;

	dec	QWORD PTR [rbx+48]

; 904  :     liveJobs = best->liveJobs;
; 905  :     /* If the new dictionary is better */
; 906  :     if (compressedSize < best->compressedSize) {

	mov	r13, QWORD PTR selection$[rbp-240]
	mov	rcx, QWORD PTR [rbx+48]
	mov	QWORD PTR liveJobs$1$[rbp-256], rcx
	cmp	r13, QWORD PTR [rbx+120]
	jae	SHORT $LN33@COVER_tryP

; 907  :       /* Allocate space if necessary */
; 908  :       if (!best->dict || best->dictSize < dictSize) {

	mov	rax, QWORD PTR [rbx+56]
	mov	rsi, QWORD PTR selection$[rbp-248]
	test	rax, rax
	je	SHORT $LN31@COVER_tryP
	cmp	QWORD PTR [rbx+64], rsi
	jae	SHORT $LN32@COVER_tryP

; 909  :         if (best->dict) {
; 910  :           free(best->dict);

	mov	rcx, rax
	call	QWORD PTR __imp_free
$LN31@COVER_tryP:

; 911  :         }
; 912  :         best->dict = malloc(dictSize);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+56], rax

; 913  :         if (!best->dict) {

	test	rax, rax
	jne	SHORT $LN32@COVER_tryP

; 914  :           best->compressedSize = ERROR(GENERIC);
; 915  :           best->dictSize = 0;
; 916  :           ZSTD_pthread_cond_signal(&best->cond);

	lea	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+120], -1
	mov	QWORD PTR [rbx+64], rax
	call	QWORD PTR __imp_WakeConditionVariable

; 917  :           ZSTD_pthread_mutex_unlock(&best->mutex);
; 918  :           return;

	jmp	SHORT $LN34@COVER_tryP
$LN32@COVER_tryP:

; 919  :         }
; 920  :       }
; 921  :       /* Save the dictionary, parameters, and size */
; 922  :       if (dict) {

	test	r14, r14
	je	SHORT $LN33@COVER_tryP

; 923  :         memcpy(best->dict, dict, dictSize);

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rax
	call	memcpy

; 924  :         best->dictSize = dictSize;
; 925  :         best->parameters = parameters;

	movups	xmm0, XMMWORD PTR parameters$3$[rsp]
	mov	QWORD PTR [rbx+64], rsi

; 926  :         best->compressedSize = compressedSize;

	mov	QWORD PTR [rbx+120], r13
	movups	XMMWORD PTR [rbx+72], xmm0
	movups	xmm0, XMMWORD PTR parameters$4$[rbp-256]
	movups	XMMWORD PTR [rbx+88], xmm0
	movups	xmm0, XMMWORD PTR parameters$5$[rbp-256]
	movups	XMMWORD PTR [rbx+104], xmm0
$LN33@COVER_tryP:

; 927  :       }
; 928  :     }
; 929  :     if (liveJobs == 0) {

	cmp	QWORD PTR liveJobs$1$[rbp-256], 0
	jne	SHORT $LN34@COVER_tryP

; 930  :       ZSTD_pthread_cond_broadcast(&best->cond);

	lea	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_WakeAllConditionVariable
$LN34@COVER_tryP:

; 1094 :   free(data);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN26@COVER_tryP:
	mov	rcx, r12
	call	QWORD PTR __imp_free

; 192  :   if (map->data) {

	test	rdi, rdi
	je	SHORT $LN37@COVER_tryP

; 193  :     free(map->data);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN37@COVER_tryP:

; 946  :   free(selection.dictContent);

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 1095 :   COVER_map_destroy(&activeDmers);
; 1096 :   COVER_dictSelectionFree(selection);
; 1097 :   if (freqs) {

	test	r15, r15
	je	SHORT $LN9@COVER_tryP

; 1098 :     free(freqs);

	mov	rcx, r15
	call	QWORD PTR __imp_free
$LN9@COVER_tryP:

; 1099 :   }
; 1100 : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
COVER_tryParameters ENDP
_TEXT	ENDS
END
