; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

?maxWindowResize@?1??ZSTD_adjustCParams_internal@@9@9 DQ 0000000040000000H ; `ZSTD_adjustCParams_internal'::`2'::maxWindowResize
LL_defaultNormLog DD 06H
OF_defaultNormLog DD 05H
prime8bytes DQ	cf1bbcdcb7a56463H
ML_defaultNormLog DD 06H
?ML_deltaCode@?1??ZSTD_MLcode@@9@9 DD 024H		; `ZSTD_MLcode'::`2'::ML_deltaCode
OF_defaultNorm DW 01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	ORG $+6
?minSrcSize@?1??ZSTD_adjustCParams_internal@@9@9 DQ 0000000000000201H ; `ZSTD_adjustCParams_internal'::`2'::minSrcSize
ZSTD_defaultCMem DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
ZSTD_defaultCParameters DD 013H
	DD	0cH
	DD	0dH
	DD	01H
	DD	06H
	DD	01H
	DD	01H
	DD	013H
	DD	0dH
	DD	0eH
	DD	01H
	DD	07H
	DD	00H
	DD	01H
	DD	014H
	DD	0fH
	DD	010H
	DD	01H
	DD	06H
	DD	00H
	DD	01H
	DD	015H
	DD	010H
	DD	011H
	DD	01H
	DD	05H
	DD	00H
	DD	02H
	DD	015H
	DD	012H
	DD	012H
	DD	01H
	DD	05H
	DD	00H
	DD	02H
	DD	015H
	DD	012H
	DD	013H
	DD	02H
	DD	05H
	DD	02H
	DD	03H
	DD	015H
	DD	013H
	DD	013H
	DD	03H
	DD	05H
	DD	04H
	DD	03H
	DD	015H
	DD	013H
	DD	013H
	DD	03H
	DD	05H
	DD	08H
	DD	04H
	DD	015H
	DD	013H
	DD	013H
	DD	03H
	DD	05H
	DD	010H
	DD	05H
	DD	015H
	DD	013H
	DD	014H
	DD	04H
	DD	05H
	DD	010H
	DD	05H
	DD	016H
	DD	014H
	DD	015H
	DD	04H
	DD	05H
	DD	010H
	DD	05H
	DD	016H
	DD	015H
	DD	016H
	DD	04H
	DD	05H
	DD	010H
	DD	05H
	DD	016H
	DD	015H
	DD	016H
	DD	05H
	DD	05H
	DD	010H
	DD	05H
	DD	016H
	DD	015H
	DD	016H
	DD	05H
	DD	05H
	DD	020H
	DD	06H
	DD	016H
	DD	016H
	DD	017H
	DD	05H
	DD	05H
	DD	020H
	DD	06H
	DD	016H
	DD	017H
	DD	017H
	DD	06H
	DD	05H
	DD	020H
	DD	06H
	DD	016H
	DD	016H
	DD	016H
	DD	05H
	DD	05H
	DD	030H
	DD	07H
	DD	017H
	DD	017H
	DD	016H
	DD	05H
	DD	04H
	DD	040H
	DD	07H
	DD	017H
	DD	017H
	DD	016H
	DD	06H
	DD	03H
	DD	040H
	DD	08H
	DD	017H
	DD	018H
	DD	016H
	DD	07H
	DD	03H
	DD	0100H
	DD	09H
	DD	019H
	DD	019H
	DD	017H
	DD	07H
	DD	03H
	DD	0100H
	DD	09H
	DD	01aH
	DD	01aH
	DD	018H
	DD	07H
	DD	03H
	DD	0200H
	DD	09H
	DD	01bH
	DD	01bH
	DD	019H
	DD	09H
	DD	03H
	DD	03e7H
	DD	09H
	DD	012H
	DD	0cH
	DD	0dH
	DD	01H
	DD	05H
	DD	01H
	DD	01H
	DD	012H
	DD	0dH
	DD	0eH
	DD	01H
	DD	06H
	DD	00H
	DD	01H
	DD	012H
	DD	0eH
	DD	0eH
	DD	01H
	DD	05H
	DD	00H
	DD	02H
	DD	012H
	DD	010H
	DD	010H
	DD	01H
	DD	04H
	DD	00H
	DD	02H
	DD	012H
	DD	010H
	DD	011H
	DD	02H
	DD	05H
	DD	02H
	DD	03H
	DD	012H
	DD	012H
	DD	012H
	DD	03H
	DD	05H
	DD	02H
	DD	03H
	DD	012H
	DD	012H
	DD	013H
	DD	03H
	DD	05H
	DD	04H
	DD	04H
	DD	012H
	DD	012H
	DD	013H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	012H
	DD	012H
	DD	013H
	DD	04H
	DD	04H
	DD	08H
	DD	05H
	DD	012H
	DD	012H
	DD	013H
	DD	05H
	DD	04H
	DD	08H
	DD	05H
	DD	012H
	DD	012H
	DD	013H
	DD	06H
	DD	04H
	DD	08H
	DD	05H
	DD	012H
	DD	012H
	DD	013H
	DD	05H
	DD	04H
	DD	0cH
	DD	06H
	DD	012H
	DD	013H
	DD	013H
	DD	07H
	DD	04H
	DD	0cH
	DD	06H
	DD	012H
	DD	012H
	DD	013H
	DD	04H
	DD	04H
	DD	010H
	DD	07H
	DD	012H
	DD	012H
	DD	013H
	DD	04H
	DD	03H
	DD	020H
	DD	07H
	DD	012H
	DD	012H
	DD	013H
	DD	06H
	DD	03H
	DD	080H
	DD	07H
	DD	012H
	DD	013H
	DD	013H
	DD	06H
	DD	03H
	DD	080H
	DD	08H
	DD	012H
	DD	013H
	DD	013H
	DD	08H
	DD	03H
	DD	0100H
	DD	08H
	DD	012H
	DD	013H
	DD	013H
	DD	06H
	DD	03H
	DD	080H
	DD	09H
	DD	012H
	DD	013H
	DD	013H
	DD	08H
	DD	03H
	DD	0100H
	DD	09H
	DD	012H
	DD	013H
	DD	013H
	DD	0aH
	DD	03H
	DD	0200H
	DD	09H
	DD	012H
	DD	013H
	DD	013H
	DD	0cH
	DD	03H
	DD	0200H
	DD	09H
	DD	012H
	DD	013H
	DD	013H
	DD	0dH
	DD	03H
	DD	03e7H
	DD	09H
	DD	011H
	DD	0cH
	DD	0cH
	DD	01H
	DD	05H
	DD	01H
	DD	01H
	DD	011H
	DD	0cH
	DD	0dH
	DD	01H
	DD	06H
	DD	00H
	DD	01H
	DD	011H
	DD	0dH
	DD	0fH
	DD	01H
	DD	05H
	DD	00H
	DD	01H
	DD	011H
	DD	0fH
	DD	010H
	DD	02H
	DD	05H
	DD	00H
	DD	02H
	DD	011H
	DD	011H
	DD	011H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	011H
	DD	010H
	DD	011H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	011H
	DD	011H
	DD	011H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	011H
	DD	011H
	DD	011H
	DD	03H
	DD	04H
	DD	08H
	DD	05H
	DD	011H
	DD	011H
	DD	011H
	DD	04H
	DD	04H
	DD	08H
	DD	05H
	DD	011H
	DD	011H
	DD	011H
	DD	05H
	DD	04H
	DD	08H
	DD	05H
	DD	011H
	DD	011H
	DD	011H
	DD	06H
	DD	04H
	DD	08H
	DD	05H
	DD	011H
	DD	011H
	DD	011H
	DD	05H
	DD	04H
	DD	08H
	DD	06H
	DD	011H
	DD	012H
	DD	011H
	DD	07H
	DD	04H
	DD	0cH
	DD	06H
	DD	011H
	DD	012H
	DD	011H
	DD	03H
	DD	04H
	DD	0cH
	DD	07H
	DD	011H
	DD	012H
	DD	011H
	DD	04H
	DD	03H
	DD	020H
	DD	07H
	DD	011H
	DD	012H
	DD	011H
	DD	06H
	DD	03H
	DD	0100H
	DD	07H
	DD	011H
	DD	012H
	DD	011H
	DD	06H
	DD	03H
	DD	080H
	DD	08H
	DD	011H
	DD	012H
	DD	011H
	DD	08H
	DD	03H
	DD	0100H
	DD	08H
	DD	011H
	DD	012H
	DD	011H
	DD	0aH
	DD	03H
	DD	0200H
	DD	08H
	DD	011H
	DD	012H
	DD	011H
	DD	05H
	DD	03H
	DD	0100H
	DD	09H
	DD	011H
	DD	012H
	DD	011H
	DD	07H
	DD	03H
	DD	0200H
	DD	09H
	DD	011H
	DD	012H
	DD	011H
	DD	09H
	DD	03H
	DD	0200H
	DD	09H
	DD	011H
	DD	012H
	DD	011H
	DD	0bH
	DD	03H
	DD	03e7H
	DD	09H
	DD	0eH
	DD	0cH
	DD	0dH
	DD	01H
	DD	05H
	DD	01H
	DD	01H
	DD	0eH
	DD	0eH
	DD	0fH
	DD	01H
	DD	05H
	DD	00H
	DD	01H
	DD	0eH
	DD	0eH
	DD	0fH
	DD	01H
	DD	04H
	DD	00H
	DD	01H
	DD	0eH
	DD	0eH
	DD	0fH
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	0eH
	DD	0eH
	DD	0eH
	DD	04H
	DD	04H
	DD	02H
	DD	03H
	DD	0eH
	DD	0eH
	DD	0eH
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	0eH
	DD	0eH
	DD	0eH
	DD	04H
	DD	04H
	DD	08H
	DD	05H
	DD	0eH
	DD	0eH
	DD	0eH
	DD	06H
	DD	04H
	DD	08H
	DD	05H
	DD	0eH
	DD	0eH
	DD	0eH
	DD	08H
	DD	04H
	DD	08H
	DD	05H
	DD	0eH
	DD	0fH
	DD	0eH
	DD	05H
	DD	04H
	DD	08H
	DD	06H
	DD	0eH
	DD	0fH
	DD	0eH
	DD	09H
	DD	04H
	DD	08H
	DD	06H
	DD	0eH
	DD	0fH
	DD	0eH
	DD	03H
	DD	04H
	DD	0cH
	DD	07H
	DD	0eH
	DD	0fH
	DD	0eH
	DD	04H
	DD	03H
	DD	018H
	DD	07H
	DD	0eH
	DD	0fH
	DD	0eH
	DD	05H
	DD	03H
	DD	020H
	DD	08H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	06H
	DD	03H
	DD	040H
	DD	08H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	07H
	DD	03H
	DD	0100H
	DD	08H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	05H
	DD	03H
	DD	030H
	DD	09H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	06H
	DD	03H
	DD	080H
	DD	09H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	07H
	DD	03H
	DD	0100H
	DD	09H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	08H
	DD	03H
	DD	0100H
	DD	09H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	08H
	DD	03H
	DD	0200H
	DD	09H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	09H
	DD	03H
	DD	0200H
	DD	09H
	DD	0eH
	DD	0fH
	DD	0fH
	DD	0aH
	DD	03H
	DD	03e7H
	DD	09H
?ML_Code@?1??ZSTD_MLcode@@9@9 DB 00H			; `ZSTD_MLcode'::`2'::ML_Code
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	020H
	DB	021H
	DB	021H
	DB	022H
	DB	022H
	DB	023H
	DB	023H
	DB	024H
	DB	024H
	DB	024H
	DB	024H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	026H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	027H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	028H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	029H
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
	DB	02aH
?LL_Code@?1??ZSTD_LLcode@@9@9 DB 00H			; `ZSTD_LLcode'::`2'::LL_Code
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
ML_defaultNorm DW 01H
	DW	04H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	ORG $+6
attachDictSizeCutoffs DQ 0000000000002000H
	DQ	0000000000002000H
	DQ	0000000000004000H
	DQ	0000000000008000H
	DQ	0000000000008000H
	DQ	0000000000008000H
	DQ	0000000000008000H
	DQ	0000000000008000H
	DQ	0000000000002000H
	DQ	0000000000002000H
?hashSizeMin@?2??ZSTD_adjustCParams_internal@@9@9 DD 040H ; `ZSTD_adjustCParams_internal'::`3'::hashSizeMin
?LL_deltaCode@?1??ZSTD_LLcode@@9@9 DD 013H		; `ZSTD_LLcode'::`2'::LL_deltaCode
ZSTD_blockHeaderSize DQ 0000000000000003H
?blockCompressor@?1??ZSTD_selectBlockCompressor@@9@9 DQ FLAT:ZSTD_compressBlock_fast ; `ZSTD_selectBlockCompressor'::`2'::blockCompressor
	DQ	FLAT:ZSTD_compressBlock_fast
	DQ	FLAT:ZSTD_compressBlock_doubleFast
	DQ	FLAT:ZSTD_compressBlock_greedy
	DQ	FLAT:ZSTD_compressBlock_lazy
	DQ	FLAT:ZSTD_compressBlock_lazy2
	DQ	FLAT:ZSTD_compressBlock_btlazy2
	DQ	FLAT:ZSTD_compressBlock_btopt
	DQ	FLAT:ZSTD_compressBlock_btultra
	DQ	FLAT:ZSTD_compressBlock_btultra2
	DQ	FLAT:ZSTD_compressBlock_fast_extDict
	DQ	FLAT:ZSTD_compressBlock_fast_extDict
	DQ	FLAT:ZSTD_compressBlock_doubleFast_extDict
	DQ	FLAT:ZSTD_compressBlock_greedy_extDict
	DQ	FLAT:ZSTD_compressBlock_lazy_extDict
	DQ	FLAT:ZSTD_compressBlock_lazy2_extDict
	DQ	FLAT:ZSTD_compressBlock_btlazy2_extDict
	DQ	FLAT:ZSTD_compressBlock_btopt_extDict
	DQ	FLAT:ZSTD_compressBlock_btultra_extDict
	DQ	FLAT:ZSTD_compressBlock_btultra_extDict
	DQ	FLAT:ZSTD_compressBlock_fast_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_fast_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_doubleFast_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_greedy_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_lazy_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_lazy2_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_btlazy2_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_btopt_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_btultra_dictMatchState
	DQ	FLAT:ZSTD_compressBlock_btultra_dictMatchState
repStartValue DD 01H
	DD	04H
	DD	08H
	ORG $+4
LL_defaultNorm DW 04H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
PUBLIC	ZSTD_getParams
PUBLIC	ZSTD_getCParams
PUBLIC	ZSTD_minCLevel
PUBLIC	ZSTD_maxCLevel
PUBLIC	ZSTD_compressStream2
PUBLIC	ZSTD_initCStream_internal
PUBLIC	ZSTD_compress_usingCDict
PUBLIC	ZSTD_compress_usingCDict_advanced
PUBLIC	ZSTD_compressBegin_usingCDict
PUBLIC	ZSTD_compressBegin_usingCDict_advanced
PUBLIC	ZSTD_getCParamsFromCDict
PUBLIC	ZSTD_freeCDict
PUBLIC	ZSTD_createCDict
PUBLIC	ZSTD_createCDict_advanced
PUBLIC	ZSTD_compress_advanced_internal
PUBLIC	ZSTD_compressEnd
PUBLIC	ZSTD_compressBegin_advanced_internal
PUBLIC	ZSTD_loadCEntropy
PUBLIC	ZSTD_compressBlock
PUBLIC	ZSTD_getBlockSize
PUBLIC	ZSTD_compressContinue
PUBLIC	ZSTD_referenceExternalSequences
PUBLIC	ZSTD_writeLastEmptyBlock
PUBLIC	ZSTD_resetSeqStore
PUBLIC	ZSTD_selectBlockCompressor
PUBLIC	ZSTD_seqToCodes
PUBLIC	ZSTD_invalidateRepCodes
PUBLIC	ZSTD_reset_compressedBlockState
PUBLIC	ZSTD_getCParamsFromCCtxParams
PUBLIC	ZSTD_cycleLog
PUBLIC	ZSTD_checkCParams
PUBLIC	ZSTD_CCtx_reset
PUBLIC	ZSTD_CCtx_refCDict
PUBLIC	ZSTD_CCtx_loadDictionary
PUBLIC	ZSTD_CCtx_loadDictionary_advanced
PUBLIC	ZSTD_CCtx_setPledgedSrcSize
PUBLIC	ZSTD_CCtxParams_setParameter
PUBLIC	ZSTD_CCtx_setParameter
PUBLIC	ZSTD_cParam_getBounds
PUBLIC	ZSTD_CCtxParams_init
PUBLIC	ZSTD_CCtxParams_reset
PUBLIC	ZSTD_getSeqStore
PUBLIC	ZSTD_freeCCtx
PUBLIC	ZSTD_createCCtx_advanced
PUBLIC	ZSTD_createCCtx
PUBLIC	ZSTD_compressBound
$SG4294966449 DB 01H DUP (?)
	ALIGN	4

$SG4294966450 DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$ZSTD_getParams DD imagerel $LN7
	DD	imagerel $LN7+104
	DD	imagerel $unwind$ZSTD_getParams
$pdata$ZSTD_getParams_internal DD imagerel ZSTD_getParams_internal
	DD	imagerel ZSTD_getParams_internal+65
	DD	imagerel $unwind$ZSTD_getParams_internal
$pdata$ZSTD_getCParams DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$ZSTD_getCParams
$pdata$ZSTD_getCParams_internal DD imagerel ZSTD_getCParams_internal
	DD	imagerel ZSTD_getCParams_internal+418
	DD	imagerel $unwind$ZSTD_getCParams_internal
$pdata$ZSTD_compressStream2 DD imagerel $LN119
	DD	imagerel $LN119+65
	DD	imagerel $unwind$ZSTD_compressStream2
$pdata$7$ZSTD_compressStream2 DD imagerel $LN119+65
	DD	imagerel $LN119+1110
	DD	imagerel $chain$7$ZSTD_compressStream2
$pdata$9$ZSTD_compressStream2 DD imagerel $LN119+1110
	DD	imagerel $LN119+1427
	DD	imagerel $chain$9$ZSTD_compressStream2
$pdata$10$ZSTD_compressStream2 DD imagerel $LN119+1427
	DD	imagerel $LN119+1450
	DD	imagerel $chain$10$ZSTD_compressStream2
$pdata$ZSTD_compressStream_generic DD imagerel ZSTD_compressStream_generic
	DD	imagerel ZSTD_compressStream_generic+1006
	DD	imagerel $unwind$ZSTD_compressStream_generic
$pdata$ZSTD_initCStream_internal DD imagerel $LN75
	DD	imagerel $LN75+317
	DD	imagerel $unwind$ZSTD_initCStream_internal
$pdata$ZSTD_resetCStream_internal DD imagerel ZSTD_resetCStream_internal
	DD	imagerel ZSTD_resetCStream_internal+222
	DD	imagerel $unwind$ZSTD_resetCStream_internal
$pdata$ZSTD_compress_usingCDict DD imagerel $LN13
	DD	imagerel $LN13+131
	DD	imagerel $unwind$ZSTD_compress_usingCDict
$pdata$ZSTD_compress_usingCDict_advanced DD imagerel $LN11
	DD	imagerel $LN11+141
	DD	imagerel $unwind$ZSTD_compress_usingCDict_advanced
$pdata$ZSTD_compressBegin_usingCDict DD imagerel $LN190
	DD	imagerel $LN190+56
	DD	imagerel $unwind$ZSTD_compressBegin_usingCDict
$pdata$3$ZSTD_compressBegin_usingCDict DD imagerel $LN190+56
	DD	imagerel $LN190+575
	DD	imagerel $chain$3$ZSTD_compressBegin_usingCDict
$pdata$4$ZSTD_compressBegin_usingCDict DD imagerel $LN190+575
	DD	imagerel $LN190+595
	DD	imagerel $chain$4$ZSTD_compressBegin_usingCDict
$pdata$ZSTD_compressBegin_usingCDict_advanced DD imagerel $LN22
	DD	imagerel $LN22+436
	DD	imagerel $unwind$ZSTD_compressBegin_usingCDict_advanced
$pdata$ZSTD_freeCDict DD imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$ZSTD_freeCDict
$pdata$0$ZSTD_freeCDict DD imagerel $LN24+25
	DD	imagerel $LN24+145
	DD	imagerel $chain$0$ZSTD_freeCDict
$pdata$1$ZSTD_freeCDict DD imagerel $LN24+145
	DD	imagerel $LN24+190
	DD	imagerel $chain$1$ZSTD_freeCDict
$pdata$ZSTD_createCDict DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$ZSTD_createCDict
$pdata$ZSTD_createCDict_advanced DD imagerel $LN48
	DD	imagerel $LN48+478
	DD	imagerel $unwind$ZSTD_createCDict_advanced
$pdata$ZSTD_initCDict_internal DD imagerel ZSTD_initCDict_internal
	DD	imagerel ZSTD_initCDict_internal+166
	DD	imagerel $unwind$ZSTD_initCDict_internal
$pdata$1$ZSTD_initCDict_internal DD imagerel ZSTD_initCDict_internal+166
	DD	imagerel ZSTD_initCDict_internal+530
	DD	imagerel $chain$1$ZSTD_initCDict_internal
$pdata$2$ZSTD_initCDict_internal DD imagerel ZSTD_initCDict_internal+530
	DD	imagerel ZSTD_initCDict_internal+551
	DD	imagerel $chain$2$ZSTD_initCDict_internal
$pdata$ZSTD_compress_advanced_internal DD imagerel $LN108
	DD	imagerel $LN108+203
	DD	imagerel $unwind$ZSTD_compress_advanced_internal
$pdata$ZSTD_compressEnd DD imagerel $LN71
	DD	imagerel $LN71+77
	DD	imagerel $unwind$ZSTD_compressEnd
$pdata$0$ZSTD_compressEnd DD imagerel $LN71+77
	DD	imagerel $LN71+369
	DD	imagerel $chain$0$ZSTD_compressEnd
$pdata$1$ZSTD_compressEnd DD imagerel $LN71+369
	DD	imagerel $LN71+391
	DD	imagerel $chain$1$ZSTD_compressEnd
$pdata$ZSTD_writeEpilogue DD imagerel ZSTD_writeEpilogue
	DD	imagerel ZSTD_writeEpilogue+289
	DD	imagerel $unwind$ZSTD_writeEpilogue
$pdata$ZSTD_compressBegin_advanced_internal DD imagerel $LN11
	DD	imagerel $LN11+164
	DD	imagerel $unwind$ZSTD_compressBegin_advanced_internal
$pdata$ZSTD_compressBegin_internal DD imagerel ZSTD_compressBegin_internal
	DD	imagerel ZSTD_compressBegin_internal+424
	DD	imagerel $unwind$ZSTD_compressBegin_internal
$pdata$ZSTD_compress_insertDictionary DD imagerel ZSTD_compress_insertDictionary
	DD	imagerel ZSTD_compress_insertDictionary+241
	DD	imagerel $unwind$ZSTD_compress_insertDictionary
$pdata$0$ZSTD_compress_insertDictionary DD imagerel ZSTD_compress_insertDictionary+241
	DD	imagerel ZSTD_compress_insertDictionary+507
	DD	imagerel $chain$0$ZSTD_compress_insertDictionary
$pdata$2$ZSTD_compress_insertDictionary DD imagerel ZSTD_compress_insertDictionary+507
	DD	imagerel ZSTD_compress_insertDictionary+527
	DD	imagerel $chain$2$ZSTD_compress_insertDictionary
$pdata$3$ZSTD_compress_insertDictionary DD imagerel ZSTD_compress_insertDictionary+527
	DD	imagerel ZSTD_compress_insertDictionary+583
	DD	imagerel $chain$3$ZSTD_compress_insertDictionary
$pdata$ZSTD_loadZstdDictionary DD imagerel ZSTD_loadZstdDictionary
	DD	imagerel ZSTD_loadZstdDictionary+371
	DD	imagerel $unwind$ZSTD_loadZstdDictionary
$pdata$ZSTD_loadCEntropy DD imagerel $LN88
	DD	imagerel $LN88+651
	DD	imagerel $unwind$ZSTD_loadCEntropy
$pdata$ZSTD_loadDictionaryContent DD imagerel ZSTD_loadDictionaryContent
	DD	imagerel ZSTD_loadDictionaryContent+544
	DD	imagerel $unwind$ZSTD_loadDictionaryContent
$pdata$ZSTD_compressBlock DD imagerel $LN10
	DD	imagerel $LN10+86
	DD	imagerel $unwind$ZSTD_compressBlock
$pdata$ZSTD_getBlockSize DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$ZSTD_getBlockSize
$pdata$ZSTD_compressContinue DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$ZSTD_compressContinue
$pdata$ZSTD_compressContinue_internal DD imagerel ZSTD_compressContinue_internal
	DD	imagerel ZSTD_compressContinue_internal+128
	DD	imagerel $unwind$ZSTD_compressContinue_internal
$pdata$0$ZSTD_compressContinue_internal DD imagerel ZSTD_compressContinue_internal+128
	DD	imagerel ZSTD_compressContinue_internal+395
	DD	imagerel $chain$0$ZSTD_compressContinue_internal
$pdata$1$ZSTD_compressContinue_internal DD imagerel ZSTD_compressContinue_internal+395
	DD	imagerel ZSTD_compressContinue_internal+421
	DD	imagerel $chain$1$ZSTD_compressContinue_internal
$pdata$ZSTD_writeFrameHeader DD imagerel ZSTD_writeFrameHeader
	DD	imagerel ZSTD_writeFrameHeader+411
	DD	imagerel $unwind$ZSTD_writeFrameHeader
$pdata$ZSTD_compress_frameChunk DD imagerel ZSTD_compress_frameChunk
	DD	imagerel ZSTD_compress_frameChunk+667
	DD	imagerel $unwind$ZSTD_compress_frameChunk
$pdata$ZSTD_overflowCorrectIfNeeded DD imagerel ZSTD_overflowCorrectIfNeeded
	DD	imagerel ZSTD_overflowCorrectIfNeeded+84
	DD	imagerel $unwind$ZSTD_overflowCorrectIfNeeded
$pdata$0$ZSTD_overflowCorrectIfNeeded DD imagerel ZSTD_overflowCorrectIfNeeded+84
	DD	imagerel ZSTD_overflowCorrectIfNeeded+273
	DD	imagerel $chain$0$ZSTD_overflowCorrectIfNeeded
$pdata$1$ZSTD_overflowCorrectIfNeeded DD imagerel ZSTD_overflowCorrectIfNeeded+273
	DD	imagerel ZSTD_overflowCorrectIfNeeded+333
	DD	imagerel $chain$1$ZSTD_overflowCorrectIfNeeded
$pdata$ZSTD_compressBlock_targetCBlockSize DD imagerel ZSTD_compressBlock_targetCBlockSize
	DD	imagerel ZSTD_compressBlock_targetCBlockSize+157
	DD	imagerel $unwind$ZSTD_compressBlock_targetCBlockSize
$pdata$ZSTD_compressBlock_targetCBlockSize_body DD imagerel ZSTD_compressBlock_targetCBlockSize_body
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body+242
	DD	imagerel $unwind$ZSTD_compressBlock_targetCBlockSize_body
$pdata$2$ZSTD_compressBlock_targetCBlockSize_body DD imagerel ZSTD_compressBlock_targetCBlockSize_body+242
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body+571
	DD	imagerel $chain$2$ZSTD_compressBlock_targetCBlockSize_body
$pdata$3$ZSTD_compressBlock_targetCBlockSize_body DD imagerel ZSTD_compressBlock_targetCBlockSize_body+571
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body+747
	DD	imagerel $chain$3$ZSTD_compressBlock_targetCBlockSize_body
$pdata$ZSTD_compressBlock_internal DD imagerel ZSTD_compressBlock_internal
	DD	imagerel ZSTD_compressBlock_internal+147
	DD	imagerel $unwind$ZSTD_compressBlock_internal
$pdata$0$ZSTD_compressBlock_internal DD imagerel ZSTD_compressBlock_internal+147
	DD	imagerel ZSTD_compressBlock_internal+257
	DD	imagerel $chain$0$ZSTD_compressBlock_internal
$pdata$1$ZSTD_compressBlock_internal DD imagerel ZSTD_compressBlock_internal+257
	DD	imagerel ZSTD_compressBlock_internal+406
	DD	imagerel $chain$1$ZSTD_compressBlock_internal
$pdata$ZSTD_copyBlockSequences DD imagerel ZSTD_copyBlockSequences
	DD	imagerel ZSTD_copyBlockSequences+71
	DD	imagerel $unwind$ZSTD_copyBlockSequences
$pdata$2$ZSTD_copyBlockSequences DD imagerel ZSTD_copyBlockSequences+71
	DD	imagerel ZSTD_copyBlockSequences+339
	DD	imagerel $chain$2$ZSTD_copyBlockSequences
$pdata$3$ZSTD_copyBlockSequences DD imagerel ZSTD_copyBlockSequences+339
	DD	imagerel ZSTD_copyBlockSequences+360
	DD	imagerel $chain$3$ZSTD_copyBlockSequences
$pdata$ZSTD_buildSeqStore DD imagerel ZSTD_buildSeqStore
	DD	imagerel ZSTD_buildSeqStore+77
	DD	imagerel $unwind$ZSTD_buildSeqStore
$pdata$0$ZSTD_buildSeqStore DD imagerel ZSTD_buildSeqStore+77
	DD	imagerel ZSTD_buildSeqStore+582
	DD	imagerel $chain$0$ZSTD_buildSeqStore
$pdata$1$ZSTD_buildSeqStore DD imagerel ZSTD_buildSeqStore+582
	DD	imagerel ZSTD_buildSeqStore+603
	DD	imagerel $chain$1$ZSTD_buildSeqStore
$pdata$ZSTD_storeLastLiterals DD imagerel ZSTD_storeLastLiterals
	DD	imagerel ZSTD_storeLastLiterals+40
	DD	imagerel $unwind$ZSTD_storeLastLiterals
$pdata$ZSTD_compressSequences DD imagerel ZSTD_compressSequences
	DD	imagerel ZSTD_compressSequences+161
	DD	imagerel $unwind$ZSTD_compressSequences
$pdata$ZSTD_compressSequences_internal DD imagerel ZSTD_compressSequences_internal
	DD	imagerel ZSTD_compressSequences_internal+2839
	DD	imagerel $unwind$ZSTD_compressSequences_internal
$pdata$ZSTD_seqToCodes DD imagerel $LN27
	DD	imagerel $LN27+31
	DD	imagerel $unwind$ZSTD_seqToCodes
$pdata$0$ZSTD_seqToCodes DD imagerel $LN27+31
	DD	imagerel $LN27+48
	DD	imagerel $chain$0$ZSTD_seqToCodes
$pdata$4$ZSTD_seqToCodes DD imagerel $LN27+48
	DD	imagerel $LN27+218
	DD	imagerel $chain$4$ZSTD_seqToCodes
$pdata$5$ZSTD_seqToCodes DD imagerel $LN27+218
	DD	imagerel $LN27+249
	DD	imagerel $chain$5$ZSTD_seqToCodes
$pdata$6$ZSTD_seqToCodes DD imagerel $LN27+249
	DD	imagerel $LN27+263
	DD	imagerel $chain$6$ZSTD_seqToCodes
$pdata$ZSTD_reduceIndex DD imagerel ZSTD_reduceIndex
	DD	imagerel ZSTD_reduceIndex+113
	DD	imagerel $unwind$ZSTD_reduceIndex
$pdata$ZSTD_reduceTable_internal DD imagerel ZSTD_reduceTable_internal
	DD	imagerel ZSTD_reduceTable_internal+29
	DD	imagerel $unwind$ZSTD_reduceTable_internal
$pdata$0$ZSTD_reduceTable_internal DD imagerel ZSTD_reduceTable_internal+29
	DD	imagerel ZSTD_reduceTable_internal+771
	DD	imagerel $chain$0$ZSTD_reduceTable_internal
$pdata$1$ZSTD_reduceTable_internal DD imagerel ZSTD_reduceTable_internal+771
	DD	imagerel ZSTD_reduceTable_internal+776
	DD	imagerel $chain$1$ZSTD_reduceTable_internal
$pdata$ZSTD_resetCCtx_usingCDict DD imagerel ZSTD_resetCCtx_usingCDict
	DD	imagerel ZSTD_resetCCtx_usingCDict+670
	DD	imagerel $unwind$ZSTD_resetCCtx_usingCDict
$pdata$0$ZSTD_resetCCtx_usingCDict DD imagerel ZSTD_resetCCtx_usingCDict+670
	DD	imagerel ZSTD_resetCCtx_usingCDict+765
	DD	imagerel $chain$0$ZSTD_resetCCtx_usingCDict
$pdata$1$ZSTD_resetCCtx_usingCDict DD imagerel ZSTD_resetCCtx_usingCDict+765
	DD	imagerel ZSTD_resetCCtx_usingCDict+921
	DD	imagerel $chain$1$ZSTD_resetCCtx_usingCDict
$pdata$2$ZSTD_resetCCtx_usingCDict DD imagerel ZSTD_resetCCtx_usingCDict+921
	DD	imagerel ZSTD_resetCCtx_usingCDict+1013
	DD	imagerel $chain$2$ZSTD_resetCCtx_usingCDict
$pdata$3$ZSTD_resetCCtx_usingCDict DD imagerel ZSTD_resetCCtx_usingCDict+1013
	DD	imagerel ZSTD_resetCCtx_usingCDict+1050
	DD	imagerel $chain$3$ZSTD_resetCCtx_usingCDict
$pdata$ZSTD_resetCCtx_byCopyingCDict DD imagerel ZSTD_resetCCtx_byCopyingCDict
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict+224
	DD	imagerel $unwind$ZSTD_resetCCtx_byCopyingCDict
$pdata$1$ZSTD_resetCCtx_byCopyingCDict DD imagerel ZSTD_resetCCtx_byCopyingCDict+224
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict+405
	DD	imagerel $chain$1$ZSTD_resetCCtx_byCopyingCDict
$pdata$2$ZSTD_resetCCtx_byCopyingCDict DD imagerel ZSTD_resetCCtx_byCopyingCDict+405
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict+512
	DD	imagerel $chain$2$ZSTD_resetCCtx_byCopyingCDict
$pdata$ZSTD_resetCCtx_byAttachingCDict DD imagerel ZSTD_resetCCtx_byAttachingCDict
	DD	imagerel ZSTD_resetCCtx_byAttachingCDict+497
	DD	imagerel $unwind$ZSTD_resetCCtx_byAttachingCDict
$pdata$ZSTD_resetCCtx_internal DD imagerel ZSTD_resetCCtx_internal
	DD	imagerel ZSTD_resetCCtx_internal+2969
	DD	imagerel $unwind$ZSTD_resetCCtx_internal
$pdata$ZSTD_reset_matchState DD imagerel ZSTD_reset_matchState
	DD	imagerel ZSTD_reset_matchState+1194
	DD	imagerel $unwind$ZSTD_reset_matchState
$pdata$ZSTD_sizeof_matchState DD imagerel ZSTD_sizeof_matchState
	DD	imagerel ZSTD_sizeof_matchState+142
	DD	imagerel $unwind$ZSTD_sizeof_matchState
$pdata$ZSTD_getCParamsFromCCtxParams DD imagerel $LN29
	DD	imagerel $LN29+406
	DD	imagerel $unwind$ZSTD_getCParamsFromCCtxParams
$pdata$ZSTD_checkCParams DD imagerel $LN74
	DD	imagerel $LN74+480
	DD	imagerel $unwind$ZSTD_checkCParams
$pdata$ZSTD_CCtx_reset DD imagerel $LN17
	DD	imagerel $LN17+152
	DD	imagerel $unwind$ZSTD_CCtx_reset
$pdata$ZSTD_CCtx_refCDict DD imagerel $LN6
	DD	imagerel $LN6+68
	DD	imagerel $unwind$ZSTD_CCtx_refCDict
$pdata$ZSTD_CCtx_loadDictionary DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$ZSTD_CCtx_loadDictionary
$pdata$ZSTD_CCtx_loadDictionary_advanced DD imagerel $LN20
	DD	imagerel $LN20+218
	DD	imagerel $unwind$ZSTD_CCtx_loadDictionary_advanced
$pdata$ZSTD_initLocalDict DD imagerel ZSTD_initLocalDict
	DD	imagerel ZSTD_initLocalDict+213
	DD	imagerel $unwind$ZSTD_initLocalDict
$pdata$ZSTD_CCtxParams_setParameter DD imagerel $LN469
	DD	imagerel $LN469+1913
	DD	imagerel $unwind$ZSTD_CCtxParams_setParameter
$pdata$ZSTD_cParam_clampBounds DD imagerel ZSTD_cParam_clampBounds
	DD	imagerel ZSTD_cParam_clampBounds+73
	DD	imagerel $unwind$ZSTD_cParam_clampBounds
$pdata$ZSTD_freeCCtx DD imagerel $LN18
	DD	imagerel $LN18+144
	DD	imagerel $unwind$ZSTD_freeCCtx
$pdata$ZSTD_freeCCtxContent DD imagerel ZSTD_freeCCtxContent
	DD	imagerel ZSTD_freeCCtxContent+150
	DD	imagerel $unwind$ZSTD_freeCCtxContent
$pdata$ZSTD_clearAllDicts DD imagerel ZSTD_clearAllDicts
	DD	imagerel ZSTD_clearAllDicts+140
	DD	imagerel $unwind$ZSTD_clearAllDicts
$pdata$ZSTD_createCCtx_advanced DD imagerel $LN11
	DD	imagerel $LN11+145
	DD	imagerel $unwind$ZSTD_createCCtx_advanced
$pdata$ZSTD_initCCtx DD imagerel ZSTD_initCCtx
	DD	imagerel ZSTD_initCCtx+229
	DD	imagerel $unwind$ZSTD_initCCtx
$pdata$ZSTD_createCCtx DD imagerel $LN11
	DD	imagerel $LN11+101
	DD	imagerel $unwind$ZSTD_createCCtx
$pdata$ZSTD_window_update DD imagerel ZSTD_window_update
	DD	imagerel ZSTD_window_update+29
	DD	imagerel $unwind$ZSTD_window_update
$pdata$0$ZSTD_window_update DD imagerel ZSTD_window_update+29
	DD	imagerel ZSTD_window_update+34
	DD	imagerel $chain$0$ZSTD_window_update
$pdata$1$ZSTD_window_update DD imagerel ZSTD_window_update+34
	DD	imagerel ZSTD_window_update+154
	DD	imagerel $chain$1$ZSTD_window_update
$pdata$2$ZSTD_window_update DD imagerel ZSTD_window_update+154
	DD	imagerel ZSTD_window_update+176
	DD	imagerel $chain$2$ZSTD_window_update
$pdata$3$ZSTD_window_update DD imagerel ZSTD_window_update+176
	DD	imagerel ZSTD_window_update+181
	DD	imagerel $chain$3$ZSTD_window_update
$pdata$ZSTD_matchState_dictMode DD imagerel ZSTD_matchState_dictMode
	DD	imagerel ZSTD_matchState_dictMode+59
	DD	imagerel $unwind$ZSTD_matchState_dictMode
$pdata$ZSTD_noCompressBlock DD imagerel ZSTD_noCompressBlock
	DD	imagerel ZSTD_noCompressBlock+76
	DD	imagerel $unwind$ZSTD_noCompressBlock
$pdata$ZSTD_cParam_withinBounds DD imagerel ZSTD_cParam_withinBounds
	DD	imagerel ZSTD_cParam_withinBounds+74
	DD	imagerel $unwind$ZSTD_cParam_withinBounds
$pdata$ZSTD_cwksp_free DD imagerel ZSTD_cwksp_free
	DD	imagerel ZSTD_cwksp_free+88
	DD	imagerel $unwind$ZSTD_cwksp_free
$pdata$ZSTD_cwksp_create DD imagerel ZSTD_cwksp_create
	DD	imagerel ZSTD_cwksp_create+126
	DD	imagerel $unwind$ZSTD_cwksp_create
$pdata$ZSTD_cwksp_clean_tables DD imagerel ZSTD_cwksp_clean_tables
	DD	imagerel ZSTD_cwksp_clean_tables+58
	DD	imagerel $unwind$ZSTD_cwksp_clean_tables
$pdata$ZSTD_limitCopy DD imagerel ZSTD_limitCopy
	DD	imagerel ZSTD_limitCopy+44
	DD	imagerel $unwind$ZSTD_limitCopy
$pdata$ZSTD_cpuid DD imagerel ZSTD_cpuid
	DD	imagerel ZSTD_cpuid+111
	DD	imagerel $unwind$ZSTD_cpuid
xdata	SEGMENT
$unwind$ZSTD_getParams DD 020601H
	DD	03002d206H
$unwind$ZSTD_getParams_internal DD 020601H
	DD	030027206H
$unwind$ZSTD_getCParams DD 020601H
	DD	030027206H
$unwind$ZSTD_getCParams_internal DD 060f01H
	DD	0c640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$ZSTD_compressStream2 DD 071901H
	DD	0560119H
	DD	0e009f00bH
	DD	03005d007H
	DD	05004H
$chain$7$ZSTD_compressStream2 DD 0102721H
	DD	026a827H
	DD	0279822H
	DD	028881dH
	DD	0297818H
	DD	02a6813H
	DD	05ec40eH
	DD	05d740aH
	DD	05c6404H
	DD	imagerel $LN119
	DD	imagerel $LN119+65
	DD	imagerel $unwind$ZSTD_compressStream2
$chain$9$ZSTD_compressStream2 DD 0100021H
	DD	026a800H
	DD	0279800H
	DD	0288800H
	DD	0297800H
	DD	02a6800H
	DD	05ec400H
	DD	05d7400H
	DD	05c6400H
	DD	imagerel $LN119
	DD	imagerel $LN119+65
	DD	imagerel $unwind$ZSTD_compressStream2
$chain$10$ZSTD_compressStream2 DD 021H
	DD	imagerel $LN119
	DD	imagerel $LN119+65
	DD	imagerel $unwind$ZSTD_compressStream2
$unwind$ZSTD_compressStream_generic DD 0b5c01H
	DD	0ce45cH
	DD	0146426H
	DD	0f014c218H
	DD	0c010d012H
	DD	0500d700eH
	DD	0300cH
$unwind$ZSTD_initCStream_internal DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$ZSTD_resetCStream_internal DD 080f01H
	DD	0f00bd20fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
$unwind$ZSTD_compress_usingCDict DD 0a1a01H
	DD	0d741aH
	DD	0c641aH
	DD	0b541aH
	DD	0a341aH
	DD	0e016721aH
$unwind$ZSTD_compress_usingCDict_advanced DD 0a1a01H
	DD	0d741aH
	DD	0c641aH
	DD	0b541aH
	DD	0a341aH
	DD	0e016721aH
$unwind$ZSTD_compressBegin_usingCDict DD 071801H
	DD	0453418H
	DD	03e0118H
	DD	07007e009H
	DD	05006H
$chain$3$ZSTD_compressBegin_usingCDict DD 085521H
	DD	01c8855H
	DD	01d783cH
	DD	01e6828H
	DD	0446408H
	DD	imagerel $LN190
	DD	imagerel $LN190+56
	DD	imagerel $unwind$ZSTD_compressBegin_usingCDict
$chain$4$ZSTD_compressBegin_usingCDict DD 021H
	DD	imagerel $LN190
	DD	imagerel $LN190+56
	DD	imagerel $unwind$ZSTD_compressBegin_usingCDict
$unwind$ZSTD_compressBegin_usingCDict_advanced DD 091a01H
	DD	02a641aH
	DD	028341aH
	DD	024011aH
	DD	0700ce00eH
	DD	0500bH
$unwind$ZSTD_freeCDict DD 020601H
	DD	03002b206H
$chain$0$ZSTD_freeCDict DD 020521H
	DD	0e7405H
	DD	imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$ZSTD_freeCDict
$chain$1$ZSTD_freeCDict DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$ZSTD_freeCDict
$unwind$ZSTD_createCDict DD 071201H
	DD	0156412H
	DD	0143412H
	DD	0120112H
	DD	0700bH
$unwind$ZSTD_createCDict_advanced DD 0d1f01H
	DD	01a641fH
	DD	019541fH
	DD	018341fH
	DD	012011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
$unwind$ZSTD_initCDict_internal DD 071201H
	DD	0216412H
	DD	0203412H
	DD	01c0112H
	DD	0700bH
$chain$1$ZSTD_initCDict_internal DD 041021H
	DD	01fe410H
	DD	01e5408H
	DD	imagerel ZSTD_initCDict_internal
	DD	imagerel ZSTD_initCDict_internal+166
	DD	imagerel $unwind$ZSTD_initCDict_internal
$chain$2$ZSTD_initCDict_internal DD 021H
	DD	imagerel ZSTD_initCDict_internal
	DD	imagerel ZSTD_initCDict_internal+166
	DD	imagerel $unwind$ZSTD_initCDict_internal
$unwind$ZSTD_compress_advanced_internal DD 071001H
	DD	0180110H
	DD	07007e009H
	DD	050056006H
	DD	03004H
$unwind$ZSTD_compressEnd DD 081501H
	DD	0d7415H
	DD	0c6415H
	DD	0b3415H
	DD	0e0117215H
$chain$0$ZSTD_compressEnd DD 020521H
	DD	0af405H
	DD	imagerel $LN71
	DD	imagerel $LN71+77
	DD	imagerel $unwind$ZSTD_compressEnd
$chain$1$ZSTD_compressEnd DD 021H
	DD	imagerel $LN71
	DD	imagerel $LN71+77
	DD	imagerel $unwind$ZSTD_compressEnd
$unwind$ZSTD_writeEpilogue DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$ZSTD_compressBegin_advanced_internal DD 081401H
	DD	0126414H
	DD	0115414H
	DD	0103414H
	DD	07010d214H
$unwind$ZSTD_compressBegin_internal DD 0b1d01H
	DD	021741dH
	DD	020641dH
	DD	01f541dH
	DD	01e341dH
	DD	01c011dH
	DD	0e016H
$unwind$ZSTD_compress_insertDictionary DD 092519H
	DD	0180113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$chain$0$ZSTD_compress_insertDictionary DD 020821H
	DD	0175408H
	DD	imagerel ZSTD_compress_insertDictionary
	DD	imagerel ZSTD_compress_insertDictionary+241
	DD	imagerel $unwind$ZSTD_compress_insertDictionary
$chain$2$ZSTD_compress_insertDictionary DD 020021H
	DD	0175400H
	DD	imagerel ZSTD_compress_insertDictionary
	DD	imagerel ZSTD_compress_insertDictionary+241
	DD	imagerel $unwind$ZSTD_compress_insertDictionary
$chain$3$ZSTD_compress_insertDictionary DD 021H
	DD	imagerel ZSTD_compress_insertDictionary
	DD	imagerel ZSTD_compress_insertDictionary+241
	DD	imagerel $unwind$ZSTD_compress_insertDictionary
$unwind$ZSTD_loadZstdDictionary DD 0a2619H
	DD	0150114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$ZSTD_loadCEntropy DD 0a2719H
	DD	0190119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$ZSTD_loadDictionaryContent DD 0a1e01H
	DD	0e341eH
	DD	0f01a521eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_compressBlock DD 010401H
	DD	0c204H
$unwind$ZSTD_getBlockSize DD 010401H
	DD	04204H
$unwind$ZSTD_compressContinue DD 010401H
	DD	08204H
$unwind$ZSTD_compressContinue_internal DD 0a1901H
	DD	0d7419H
	DD	0c5419H
	DD	0b3419H
	DD	0f0155219H
	DD	0d011e013H
$chain$0$ZSTD_compressContinue_internal DD 020521H
	DD	0a6405H
	DD	imagerel ZSTD_compressContinue_internal
	DD	imagerel ZSTD_compressContinue_internal+128
	DD	imagerel $unwind$ZSTD_compressContinue_internal
$chain$1$ZSTD_compressContinue_internal DD 021H
	DD	imagerel ZSTD_compressContinue_internal
	DD	imagerel ZSTD_compressContinue_internal+128
	DD	imagerel $unwind$ZSTD_compressContinue_internal
$unwind$ZSTD_writeFrameHeader DD 0b1a01H
	DD	07741aH
	DD	06641aH
	DD	05541aH
	DD	04341aH
	DD	0e018f01aH
	DD	0c016H
$unwind$ZSTD_compress_frameChunk DD 0a1901H
	DD	0123419H
	DD	0f0157219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$ZSTD_overflowCorrectIfNeeded DD 081501H
	DD	0d7415H
	DD	0c6415H
	DD	0b3415H
	DD	0e0117215H
$chain$0$ZSTD_overflowCorrectIfNeeded DD 020521H
	DD	0a5405H
	DD	imagerel ZSTD_overflowCorrectIfNeeded
	DD	imagerel ZSTD_overflowCorrectIfNeeded+84
	DD	imagerel $unwind$ZSTD_overflowCorrectIfNeeded
$chain$1$ZSTD_overflowCorrectIfNeeded DD 021H
	DD	imagerel ZSTD_overflowCorrectIfNeeded
	DD	imagerel ZSTD_overflowCorrectIfNeeded+84
	DD	imagerel $unwind$ZSTD_overflowCorrectIfNeeded
$unwind$ZSTD_compressBlock_targetCBlockSize DD 0a1a01H
	DD	0d741aH
	DD	0c641aH
	DD	0b541aH
	DD	0a341aH
	DD	0e016721aH
$unwind$ZSTD_compressBlock_targetCBlockSize_body DD 072119H
	DD	098010fH
	DD	0c006e008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0490H
$chain$2$ZSTD_compressBlock_targetCBlockSize_body DD 062921H
	DD	095f429H
	DD	096d41aH
	DD	0975408H
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body+242
	DD	imagerel $unwind$ZSTD_compressBlock_targetCBlockSize_body
$chain$3$ZSTD_compressBlock_targetCBlockSize_body DD 021H
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body
	DD	imagerel ZSTD_compressBlock_targetCBlockSize_body+242
	DD	imagerel $unwind$ZSTD_compressBlock_targetCBlockSize_body
$unwind$ZSTD_compressBlock_internal DD 081201H
	DD	0105412H
	DD	0f3412H
	DD	0f00e9212H
	DD	0600b700cH
$chain$0$ZSTD_compressBlock_internal DD 020521H
	DD	0ee405H
	DD	imagerel ZSTD_compressBlock_internal
	DD	imagerel ZSTD_compressBlock_internal+147
	DD	imagerel $unwind$ZSTD_compressBlock_internal
$chain$1$ZSTD_compressBlock_internal DD 021H
	DD	imagerel ZSTD_compressBlock_internal
	DD	imagerel ZSTD_compressBlock_internal+147
	DD	imagerel $unwind$ZSTD_compressBlock_internal
$unwind$ZSTD_copyBlockSequences DD 050a01H
	DD	07540aH
	DD	0e008f00aH
	DD	06006H
$chain$2$ZSTD_copyBlockSequences DD 061721H
	DD	06c417H
	DD	05740eH
	DD	043405H
	DD	imagerel ZSTD_copyBlockSequences
	DD	imagerel ZSTD_copyBlockSequences+71
	DD	imagerel $unwind$ZSTD_copyBlockSequences
$chain$3$ZSTD_copyBlockSequences DD 021H
	DD	imagerel ZSTD_copyBlockSequences
	DD	imagerel ZSTD_copyBlockSequences+71
	DD	imagerel $unwind$ZSTD_copyBlockSequences
$unwind$ZSTD_buildSeqStore DD 081401H
	DD	0f6414H
	DD	0e5414H
	DD	0d3414H
	DD	070109214H
$chain$0$ZSTD_buildSeqStore DD 020521H
	DD	0ce405H
	DD	imagerel ZSTD_buildSeqStore
	DD	imagerel ZSTD_buildSeqStore+77
	DD	imagerel $unwind$ZSTD_buildSeqStore
$chain$1$ZSTD_buildSeqStore DD 021H
	DD	imagerel ZSTD_buildSeqStore
	DD	imagerel ZSTD_buildSeqStore+77
	DD	imagerel $unwind$ZSTD_buildSeqStore
$unwind$ZSTD_storeLastLiterals DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTD_compressSequences DD 040a01H
	DD	0c340aH
	DD	07006920aH
$unwind$ZSTD_compressSequences_internal DD 0a2d19H
	DD	043011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$ZSTD_seqToCodes DD 020601H
	DD	060021206H
$chain$0$ZSTD_seqToCodes DD 020521H
	DD	065405H
	DD	imagerel $LN27
	DD	imagerel $LN27+31
	DD	imagerel $unwind$ZSTD_seqToCodes
$chain$4$ZSTD_seqToCodes DD 082021H
	DD	0f420H
	DD	01e416H
	DD	07740eH
	DD	053405H
	DD	imagerel $LN27+31
	DD	imagerel $LN27+48
	DD	imagerel $chain$0$ZSTD_seqToCodes
$chain$5$ZSTD_seqToCodes DD 021H
	DD	imagerel $LN27+31
	DD	imagerel $LN27+48
	DD	imagerel $chain$0$ZSTD_seqToCodes
$chain$6$ZSTD_seqToCodes DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+31
	DD	imagerel $unwind$ZSTD_seqToCodes
$unwind$ZSTD_reduceIndex DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$ZSTD_reduceTable_internal DD 010401H
	DD	0204H
$chain$0$ZSTD_reduceTable_internal DD 020421H
	DD	03404H
	DD	imagerel ZSTD_reduceTable_internal
	DD	imagerel ZSTD_reduceTable_internal+29
	DD	imagerel $unwind$ZSTD_reduceTable_internal
$chain$1$ZSTD_reduceTable_internal DD 021H
	DD	imagerel ZSTD_reduceTable_internal
	DD	imagerel ZSTD_reduceTable_internal+29
	DD	imagerel $unwind$ZSTD_reduceTable_internal
$unwind$ZSTD_resetCCtx_usingCDict DD 0d2f01H
	DD	017882fH
	DD	0187823H
	DD	019681cH
	DD	03b3418H
	DD	0340118H
	DD	06009700aH
	DD	05008H
$chain$0$ZSTD_resetCCtx_usingCDict DD 020821H
	DD	038e408H
	DD	imagerel ZSTD_resetCCtx_usingCDict
	DD	imagerel ZSTD_resetCCtx_usingCDict+670
	DD	imagerel $unwind$ZSTD_resetCCtx_usingCDict
$chain$1$ZSTD_resetCCtx_usingCDict DD 020821H
	DD	03af408H
	DD	imagerel ZSTD_resetCCtx_usingCDict+670
	DD	imagerel ZSTD_resetCCtx_usingCDict+765
	DD	imagerel $chain$0$ZSTD_resetCCtx_usingCDict
$chain$2$ZSTD_resetCCtx_usingCDict DD 021H
	DD	imagerel ZSTD_resetCCtx_usingCDict+670
	DD	imagerel ZSTD_resetCCtx_usingCDict+765
	DD	imagerel $chain$0$ZSTD_resetCCtx_usingCDict
$chain$3$ZSTD_resetCCtx_usingCDict DD 021H
	DD	imagerel ZSTD_resetCCtx_usingCDict
	DD	imagerel ZSTD_resetCCtx_usingCDict+670
	DD	imagerel $unwind$ZSTD_resetCCtx_usingCDict
$unwind$ZSTD_resetCCtx_byCopyingCDict DD 071201H
	DD	01d5412H
	DD	01c3412H
	DD	0180112H
	DD	0700bH
$chain$1$ZSTD_resetCCtx_byCopyingCDict DD 041021H
	DD	01be410H
	DD	01a6408H
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict+224
	DD	imagerel $unwind$ZSTD_resetCCtx_byCopyingCDict
$chain$2$ZSTD_resetCCtx_byCopyingCDict DD 021H
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict
	DD	imagerel ZSTD_resetCCtx_byCopyingCDict+224
	DD	imagerel $unwind$ZSTD_resetCCtx_byCopyingCDict
$unwind$ZSTD_resetCCtx_byAttachingCDict DD 091701H
	DD	0216417H
	DD	0205417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
$unwind$ZSTD_resetCCtx_internal DD 0a1801H
	DD	0190118H
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	030065007H
$unwind$ZSTD_reset_matchState DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
$unwind$ZSTD_sizeof_matchState DD 020501H
	DD	013405H
$unwind$ZSTD_getCParamsFromCCtxParams DD 081501H
	DD	0126415H
	DD	0113415H
	DD	0e00eb215H
	DD	0500b700cH
$unwind$ZSTD_checkCParams DD 010401H
	DD	06204H
$unwind$ZSTD_CCtx_reset DD 020601H
	DD	030023206H
$unwind$ZSTD_CCtx_refCDict DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTD_CCtx_loadDictionary DD 010401H
	DD	06204H
$unwind$ZSTD_CCtx_loadDictionary_advanced DD 084501H
	DD	0a7445H
	DD	0c540fH
	DD	0b340fH
	DD	0600b720fH
$unwind$ZSTD_initLocalDict DD 030901H
	DD	0120109H
	DD	03002H
$unwind$ZSTD_CCtxParams_setParameter DD 020901H
	DD	050025209H
$unwind$ZSTD_cParam_clampBounds DD 010401H
	DD	06204H
$unwind$ZSTD_freeCCtx DD 020601H
	DD	030027206H
$unwind$ZSTD_freeCCtxContent DD 020601H
	DD	030027206H
$unwind$ZSTD_clearAllDicts DD 020601H
	DD	030027206H
$unwind$ZSTD_createCCtx_advanced DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$ZSTD_initCCtx DD 040a01H
	DD	08340aH
	DD	07006520aH
$unwind$ZSTD_createCCtx DD 020601H
	DD	030027206H
$unwind$ZSTD_window_update DD 010201H
	DD	06002H
$chain$0$ZSTD_window_update DD 020521H
	DD	023405H
	DD	imagerel ZSTD_window_update
	DD	imagerel ZSTD_window_update+29
	DD	imagerel $unwind$ZSTD_window_update
$chain$1$ZSTD_window_update DD 020521H
	DD	037405H
	DD	imagerel ZSTD_window_update+29
	DD	imagerel ZSTD_window_update+34
	DD	imagerel $chain$0$ZSTD_window_update
$chain$2$ZSTD_window_update DD 021H
	DD	imagerel ZSTD_window_update+29
	DD	imagerel ZSTD_window_update+34
	DD	imagerel $chain$0$ZSTD_window_update
$chain$3$ZSTD_window_update DD 021H
	DD	imagerel ZSTD_window_update
	DD	imagerel ZSTD_window_update+29
	DD	imagerel $unwind$ZSTD_window_update
$unwind$ZSTD_matchState_dictMode DD 010401H
	DD	04204H
$unwind$ZSTD_noCompressBlock DD 020601H
	DD	030023206H
$unwind$ZSTD_cParam_withinBounds DD 010401H
	DD	06204H
$unwind$ZSTD_cwksp_free DD 010401H
	DD	08204H
$unwind$ZSTD_cwksp_create DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$ZSTD_cwksp_clean_tables DD 020601H
	DD	030023206H
$unwind$ZSTD_limitCopy DD 020601H
	DD	030023206H
$unwind$ZSTD_cpuid DD 060f01H
	DD	05640fH
	DD	04340fH
	DD	0700b120fH
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write16 PROC

; 259  :     memcpy(memPtr, &value, sizeof(value));

	mov	WORD PTR [rcx], dx

; 260  : }

	ret	0
MEM_write16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write64 PROC

; 269  :     memcpy(memPtr, &value, sizeof(value));

	mov	QWORD PTR [rcx], rdx

; 270  : }

	ret	0
MEM_write64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE16 PROC

; 330  :     if (MEM_isLittleEndian()) {
; 331  :         MEM_write16(memPtr, val);

	mov	WORD PTR [rcx], dx

; 332  :     } else {
; 333  :         BYTE* p = (BYTE*)memPtr;
; 334  :         p[0] = (BYTE)val;
; 335  :         p[1] = (BYTE)(val>>8);
; 336  :     }
; 337  : }

	ret	0
MEM_writeLE16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE24 PROC

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rcx], dx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	edx, 16
	mov	BYTE PTR [rcx+2], dl

; 348  : }

	ret	0
MEM_writeLE24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val64$ = 16
MEM_writeLE64 PROC

; 376  :     if (MEM_isLittleEndian())
; 377  :         MEM_write64(memPtr, val64);

	mov	QWORD PTR [rcx], rdx

; 378  :     else
; 379  :         MEM_write64(memPtr, MEM_swap64(val64));
; 380  : }

	ret	0
MEM_writeLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\cpu.h
_TEXT	SEGMENT
$T1 = 32
ZSTD_cpuid PROC

; 34   : MEM_STATIC ZSTD_cpuid_t ZSTD_cpuid(void) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 16

; 35   :     U32 f1c = 0;

	xor	r9d, r9d
	mov	r8, rcx

; 36   :     U32 f1d = 0;
; 37   :     U32 f7b = 0;
; 38   :     U32 f7c = 0;
; 39   : #if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
; 40   :     int reg[4];
; 41   :     __cpuid((int*)reg, 0);

	xor	ecx, ecx
	xor	eax, eax
	cpuid
	mov	edi, r9d
	mov	r10d, r9d
	mov	r11d, r9d
	mov	esi, eax

; 42   :     {
; 43   :         int const n = reg[0];

	cmp	eax, 1

; 44   :         if (n >= 1) {

	jl	SHORT $LN2@ZSTD_cpuid

; 45   :             __cpuid((int*)reg, 1);

	mov	eax, 1
	xor	ecx, ecx
	cpuid
	mov	edi, edx
	mov	r9d, ecx
$LN2@ZSTD_cpuid:

; 46   :             f1c = (U32)reg[2];
; 47   :             f1d = (U32)reg[3];
; 48   :         }
; 49   :         if (n >= 7) {

	cmp	esi, 7
	jl	SHORT $LN3@ZSTD_cpuid

; 50   :             __cpuidex((int*)reg, 7, 0);

	mov	eax, 7
	xor	ecx, ecx
	cpuid
	mov	r11d, ecx
	mov	r10d, ebx
$LN3@ZSTD_cpuid:

; 51   :             f7b = (U32)reg[1];
; 52   :             f7c = (U32)reg[2];
; 53   :         }
; 54   :     }
; 55   : #elif defined(__i386__) && defined(__PIC__) && !defined(__clang__) && defined(__GNUC__)
; 56   :     /* The following block like the normal cpuid branch below, but gcc
; 57   :      * reserves ebx for use of its pic register so we must specially
; 58   :      * handle the save and restore to avoid clobbering the register
; 59   :      */
; 60   :     U32 n;
; 61   :     __asm__(
; 62   :         "pushl %%ebx\n\t"
; 63   :         "cpuid\n\t"
; 64   :         "popl %%ebx\n\t"
; 65   :         : "=a"(n)
; 66   :         : "a"(0)
; 67   :         : "ecx", "edx");
; 68   :     if (n >= 1) {
; 69   :       U32 f1a;
; 70   :       __asm__(
; 71   :           "pushl %%ebx\n\t"
; 72   :           "cpuid\n\t"
; 73   :           "popl %%ebx\n\t"
; 74   :           : "=a"(f1a), "=c"(f1c), "=d"(f1d)
; 75   :           : "a"(1));
; 76   :     }
; 77   :     if (n >= 7) {
; 78   :       __asm__(
; 79   :           "pushl %%ebx\n\t"
; 80   :           "cpuid\n\t"
; 81   :           "movl %%ebx, %%eax\n\t"
; 82   :           "popl %%ebx"
; 83   :           : "=a"(f7b), "=c"(f7c)
; 84   :           : "a"(7), "c"(0)
; 85   :           : "edx");
; 86   :     }
; 87   : #elif defined(__x86_64__) || defined(_M_X64) || defined(__i386__)
; 88   :     U32 n;
; 89   :     __asm__("cpuid" : "=a"(n) : "a"(0) : "ebx", "ecx", "edx");
; 90   :     if (n >= 1) {
; 91   :       U32 f1a;
; 92   :       __asm__("cpuid" : "=a"(f1a), "=c"(f1c), "=d"(f1d) : "a"(1) : "ebx");
; 93   :     }
; 94   :     if (n >= 7) {
; 95   :       U32 f7a;
; 96   :       __asm__("cpuid"
; 97   :               : "=a"(f7a), "=b"(f7b), "=c"(f7c)
; 98   :               : "a"(7), "c"(0)
; 99   :               : "edx");
; 100  :     }
; 101  : #endif
; 102  :     {
; 103  :         ZSTD_cpuid_t cpuid;
; 104  :         cpuid.f1c = f1c;
; 105  :         cpuid.f1d = f1d;
; 106  :         cpuid.f7b = f7b;
; 107  :         cpuid.f7c = f7c;
; 108  :         return cpuid;
; 109  :     }
; 110  : }

	mov	rbx, QWORD PTR [rsp+32]
	mov	rax, r8
	mov	rsi, QWORD PTR [rsp+40]
	mov	DWORD PTR [r8], r9d
	mov	DWORD PTR [r8+4], edi
	mov	DWORD PTR [r8+8], r10d
	mov	DWORD PTR [r8+12], r11d
	add	rsp, 16
	pop	rdi
	ret	0
ZSTD_cpuid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\cpu.h
_TEXT	SEGMENT
cpuid$ = 8
ZSTD_cpuid_bmi2 PROC

; 187  :   B(bmi2, 8)

	mov	eax, DWORD PTR [rcx+8]
	shr	eax, 8
	and	eax, 1
	ret	0
ZSTD_cpuid_bmi2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
src$ = 64
srcSize$ = 72
ZSTD_limitCopy PROC

; 305  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 306  :     size_t const length = MIN(dstCapacity, srcSize);

	cmp	rdx, r9
	mov	rbx, r9
	mov	rax, r8
	cmovb	rbx, rdx

; 307  :     if (length > 0) {

	test	rbx, rbx
	je	SHORT $LN4@ZSTD_limit

; 308  :         memcpy(dst, src, length);

	mov	r8, rbx
	mov	rdx, rax
	call	memcpy
$LN4@ZSTD_limit:

; 309  :     }
; 310  :     return length;
; 311  : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_limitCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
val$ = 8
ZSTD_highbit32 PROC

; 394  :     assert(val != 0);
; 395  :     {
; 396  : #   if defined(_MSC_VER)   /* Visual */
; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 399  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
; 400  :         return __builtin_clz (val) ^ 31;
; 401  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 402  :         return 31 - __CLZ(val);
; 403  : #   else   /* Software version */
; 404  :         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
; 405  :         U32 v = val;
; 406  :         v |= v >> 1;
; 407  :         v |= v >> 2;
; 408  :         v |= v >> 4;
; 409  :         v |= v >> 8;
; 410  :         v |= v >> 16;
; 411  :         return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];
; 412  : #   endif
; 413  :     }
; 414  : }

	ret	0
ZSTD_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$dead$ = 8
ZSTD_cwksp_assert_internal_consistency PROC

; 152  :     (void)ws;
; 153  :     assert(ws->workspace <= ws->objectEnd);
; 154  :     assert(ws->objectEnd <= ws->tableEnd);
; 155  :     assert(ws->objectEnd <= ws->tableValidEnd);
; 156  :     assert(ws->tableEnd <= ws->allocStart);
; 157  :     assert(ws->tableValidEnd <= ws->allocStart);
; 158  :     assert(ws->allocStart <= ws->workspaceEnd);
; 159  : }

	ret	0
ZSTD_cwksp_assert_internal_consistency ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
size$ = 8
align$ = 16
ZSTD_cwksp_align PROC

; 165  :     size_t const mask = align - 1;

	dec	rdx

; 166  :     assert((align & mask) == 0);
; 167  :     return (size + mask) & ~mask;

	lea	rax, QWORD PTR [rdx+rcx]
	not	rdx
	and	rax, rdx

; 168  : }

	ret	0
ZSTD_cwksp_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
size$ = 8
ZSTD_cwksp_alloc_size PROC

; 181  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 182  :     return size + 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 183  : #else
; 184  :     return size;

	mov	rax, rcx

; 185  : #endif
; 186  : }

	ret	0
ZSTD_cwksp_alloc_size ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
phase$ = 16
ZSTD_cwksp_internal_advance_phase PROC

; 190  :     assert(phase >= ws->phase);
; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rcx+56]
	cmp	edx, eax
	jle	SHORT $LN2@ZSTD_cwksp

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN3@ZSTD_cwksp
	cmp	edx, 1
	jl	SHORT $LN7@ZSTD_cwksp

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+32], rax
	jmp	SHORT $LN7@ZSTD_cwksp
$LN3@ZSTD_cwksp:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&

	cmp	eax, 2
	jge	SHORT $LN5@ZSTD_cwksp
$LN7@ZSTD_cwksp:
	cmp	edx, 2
	jl	SHORT $LN5@ZSTD_cwksp

; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	and	QWORD PTR [rcx+40], -4
	mov	rax, QWORD PTR [rcx+40]

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rcx+32]
	jae	SHORT $LN5@ZSTD_cwksp

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rcx+32], rax
$LN5@ZSTD_cwksp:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rcx+56], edx
$LN2@ZSTD_cwksp:

; 211  :     }
; 212  : }

	ret	0
ZSTD_cwksp_internal_advance_phase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ptr$ = 16
ZSTD_cwksp_owns_buffer PROC

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	test	rdx, rdx
	je	SHORT $LN3@ZSTD_cwksp
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@ZSTD_cwksp
	cmp	rdx, QWORD PTR [rcx+8]
	ja	SHORT $LN3@ZSTD_cwksp
	mov	eax, 1

; 219  : }

	ret	0
$LN3@ZSTD_cwksp:

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	xor	eax, eax

; 219  : }

	ret	0
ZSTD_cwksp_owns_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
bytes$ = 16
phase$ = 24
ZSTD_cwksp_reserve_internal PROC

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rcx+56]
	cmp	r8d, eax
	jle	SHORT $LN6@ZSTD_cwksp

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN7@ZSTD_cwksp
	cmp	r8d, 1
	jl	SHORT $LN11@ZSTD_cwksp

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+32], rax
	jmp	SHORT $LN11@ZSTD_cwksp
$LN7@ZSTD_cwksp:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&

	cmp	eax, 2
	jge	SHORT $LN9@ZSTD_cwksp
$LN11@ZSTD_cwksp:
	cmp	r8d, 2
	jl	SHORT $LN9@ZSTD_cwksp

; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	and	QWORD PTR [rcx+40], -4
	mov	rax, QWORD PTR [rcx+40]

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rcx+32]
	jae	SHORT $LN9@ZSTD_cwksp

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rcx+32], rax
$LN9@ZSTD_cwksp:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rcx+56], r8d
$LN6@ZSTD_cwksp:

; 226  :     void* alloc;
; 227  :     void* bottom = ws->tableEnd;
; 228  :     ZSTD_cwksp_internal_advance_phase(ws, phase);
; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rcx+40]
	sub	rax, rdx

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rcx+24]
	jae	SHORT $LN2@ZSTD_cwksp

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rcx+48], 1

; 243  :         return NULL;

	xor	eax, eax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;
; 258  : }

	ret	0
$LN2@ZSTD_cwksp:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rcx+32]
	jae	SHORT $LN3@ZSTD_cwksp

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rcx+32], rax
$LN3@ZSTD_cwksp:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rcx+40], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;
; 258  : }

	ret	0
ZSTD_cwksp_reserve_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
bytes$ = 16
ZSTD_cwksp_reserve_buffer PROC

; 191  :     if (phase > ws->phase) {

	cmp	DWORD PTR [rcx+56], 1
	jge	SHORT $LN15@ZSTD_cwksp

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&
; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+32], rax

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));
; 206  :             if (ws->allocStart < ws->tableValidEnd) {
; 207  :                 ws->tableValidEnd = ws->allocStart;
; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rcx+56], 1
$LN15@ZSTD_cwksp:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rcx+40]
	sub	rax, rdx

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rcx+24]
	jae	SHORT $LN4@ZSTD_cwksp

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rcx+48], 1

; 264  :     return (BYTE*)ZSTD_cwksp_reserve_internal(ws, bytes, ZSTD_cwksp_alloc_buffers);

	xor	eax, eax

; 265  : }

	ret	0
$LN4@ZSTD_cwksp:

; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rcx+32]
	jae	SHORT $LN5@ZSTD_cwksp

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rcx+32], rax
$LN5@ZSTD_cwksp:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rcx+40], rax

; 265  : }

	ret	0
ZSTD_cwksp_reserve_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
bytes$ = 16
ZSTD_cwksp_reserve_aligned PROC

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rcx+56]
	cmp	eax, 2
	jge	SHORT $LN10@ZSTD_cwksp

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN17@ZSTD_cwksp

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+32], rax
$LN17@ZSTD_cwksp:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	and	QWORD PTR [rcx+40], -4
	mov	rax, QWORD PTR [rcx+40]

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rcx+32]
	jae	SHORT $LN13@ZSTD_cwksp

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rcx+32], rax
$LN13@ZSTD_cwksp:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rcx+56], 2
$LN10@ZSTD_cwksp:

; 167  :     return (size + mask) & ~mask;

	lea	rax, QWORD PTR [rdx+3]

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rdx, QWORD PTR [rcx+40]

; 167  :     return (size + mask) & ~mask;

	and	rax, -4

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	sub	rdx, rax

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rdx, QWORD PTR [rcx+24]
	jae	SHORT $LN6@ZSTD_cwksp

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rcx+48], 1

; 271  :     assert((bytes & (sizeof(U32)-1)) == 0);
; 272  :     return ZSTD_cwksp_reserve_internal(ws, ZSTD_cwksp_align(bytes, sizeof(U32)), ZSTD_cwksp_alloc_aligned);

	xor	eax, eax

; 273  : }

	ret	0
$LN6@ZSTD_cwksp:

; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rdx, QWORD PTR [rcx+32]
	jae	SHORT $LN7@ZSTD_cwksp

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rcx+32], rdx
$LN7@ZSTD_cwksp:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rcx+40], rdx

; 271  :     assert((bytes & (sizeof(U32)-1)) == 0);
; 272  :     return ZSTD_cwksp_reserve_internal(ws, ZSTD_cwksp_align(bytes, sizeof(U32)), ZSTD_cwksp_alloc_aligned);

	mov	rax, rdx

; 273  : }

	ret	0
ZSTD_cwksp_reserve_aligned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
bytes$ = 16
ZSTD_cwksp_reserve_table PROC

; 281  :     const ZSTD_cwksp_alloc_phase_e phase = ZSTD_cwksp_alloc_aligned;
; 282  :     void* alloc = ws->tableEnd;

	mov	r9, QWORD PTR [rcx+24]

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rcx+56]

; 283  :     void* end = (BYTE *)alloc + bytes;

	lea	r8, QWORD PTR [r9+rdx]

; 284  :     void* top = ws->allocStart;

	mov	rdx, QWORD PTR [rcx+40]

; 191  :     if (phase > ws->phase) {

	cmp	eax, 2
	jge	SHORT $LN5@ZSTD_cwksp

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN11@ZSTD_cwksp

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+32], rax
$LN11@ZSTD_cwksp:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, rdx
	and	rax, -4
	mov	QWORD PTR [rcx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rcx+32]
	jae	SHORT $LN8@ZSTD_cwksp

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rcx+32], rax
$LN8@ZSTD_cwksp:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rcx+56], 2
$LN5@ZSTD_cwksp:

; 285  : 
; 286  :     DEBUGLOG(5, "cwksp: reserving %p table %zd bytes, %zd bytes remaining",
; 287  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 288  :     assert((bytes & (sizeof(U32)-1)) == 0);
; 289  :     ZSTD_cwksp_internal_advance_phase(ws, phase);
; 290  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 291  :     assert(end <= top);
; 292  :     if (end > top) {

	cmp	r8, rdx
	jbe	SHORT $LN2@ZSTD_cwksp

; 293  :         DEBUGLOG(4, "cwksp: table alloc failed!");
; 294  :         ws->allocFailed = 1;

	mov	DWORD PTR [rcx+48], 1

; 295  :         return NULL;

	xor	eax, eax

; 304  : }

	ret	0
$LN2@ZSTD_cwksp:

; 296  :     }
; 297  :     ws->tableEnd = end;

	mov	QWORD PTR [rcx+24], r8

; 298  : 
; 299  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 300  :     __asan_unpoison_memory_region(alloc, bytes);
; 301  : #endif
; 302  : 
; 303  :     return alloc;

	mov	rax, r9

; 304  : }

	ret	0
ZSTD_cwksp_reserve_table ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
bytes$ = 16
ZSTD_cwksp_reserve_object PROC

; 310  :     size_t roundedBytes = ZSTD_cwksp_align(bytes, sizeof(void*));
; 311  :     void* alloc = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]

; 167  :     return (size + mask) & ~mask;

	add	rdx, 7
	and	rdx, -8

; 312  :     void* end = (BYTE*)alloc + roundedBytes;

	add	rdx, rax

; 313  : 
; 314  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 315  :     /* over-reserve space */
; 316  :     end = (BYTE *)end + 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 317  : #endif
; 318  : 
; 319  :     DEBUGLOG(5,
; 320  :         "cwksp: reserving %p object %zd bytes (rounded to %zd), %zd bytes remaining",
; 321  :         alloc, bytes, roundedBytes, ZSTD_cwksp_available_space(ws) - roundedBytes);
; 322  :     assert(((size_t)alloc & (sizeof(void*)-1)) == 0);
; 323  :     assert((bytes & (sizeof(void*)-1)) == 0);
; 324  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 325  :     /* we must be in the first phase, no advance is possible */
; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	DWORD PTR [rcx+56], 0
	jne	SHORT $LN3@ZSTD_cwksp
	cmp	rdx, QWORD PTR [rcx+8]
	ja	SHORT $LN3@ZSTD_cwksp

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR [rcx+16], rdx

; 332  :     ws->tableEnd = end;

	mov	QWORD PTR [rcx+24], rdx

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR [rcx+32], rdx

; 334  : 
; 335  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 336  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 337  :      * either size. */
; 338  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 339  :     __asan_unpoison_memory_region(alloc, bytes);
; 340  : #endif
; 341  : 
; 342  :     return alloc;
; 343  : }

	ret	0
$LN3@ZSTD_cwksp:

; 327  :         DEBUGLOG(4, "cwksp: object alloc failed!");
; 328  :         ws->allocFailed = 1;

	mov	DWORD PTR [rcx+48], 1

; 329  :         return NULL;

	xor	eax, eax

; 334  : 
; 335  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 336  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 337  :      * either size. */
; 338  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 339  :     __asan_unpoison_memory_region(alloc, bytes);
; 340  : #endif
; 341  : 
; 342  :     return alloc;
; 343  : }

	ret	0
ZSTD_cwksp_reserve_object ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_mark_tables_dirty PROC

; 346  :     DEBUGLOG(4, "cwksp: ZSTD_cwksp_mark_tables_dirty");
; 347  : 
; 348  : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 349  :     /* To validate that the table re-use logic is sound, and that we don't
; 350  :      * access table space that we haven't cleaned, we re-"poison" the table
; 351  :      * space every time we mark it dirty. */
; 352  :     {
; 353  :         size_t size = (BYTE*)ws->tableValidEnd - (BYTE*)ws->objectEnd;
; 354  :         assert(__msan_test_shadow(ws->objectEnd, size) == -1);
; 355  :         __msan_poison(ws->objectEnd, size);
; 356  :     }
; 357  : #endif
; 358  : 
; 359  :     assert(ws->tableValidEnd >= ws->objectEnd);
; 360  :     assert(ws->tableValidEnd <= ws->allocStart);
; 361  :     ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+32], rax

; 362  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 363  : }

	ret	0
ZSTD_cwksp_mark_tables_dirty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_mark_tables_clean PROC

; 366  :     DEBUGLOG(4, "cwksp: ZSTD_cwksp_mark_tables_clean");
; 367  :     assert(ws->tableValidEnd >= ws->objectEnd);
; 368  :     assert(ws->tableValidEnd <= ws->allocStart);
; 369  :     if (ws->tableValidEnd < ws->tableEnd) {

	mov	rax, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rcx+32], rax
	jae	SHORT $LN2@ZSTD_cwksp

; 370  :         ws->tableValidEnd = ws->tableEnd;

	mov	QWORD PTR [rcx+32], rax
$LN2@ZSTD_cwksp:

; 371  :     }
; 372  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 373  : }

	ret	0
ZSTD_cwksp_mark_tables_clean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 48
ZSTD_cwksp_clean_tables PROC

; 378  : MEM_STATIC void ZSTD_cwksp_clean_tables(ZSTD_cwksp* ws) {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 379  :     DEBUGLOG(4, "cwksp: ZSTD_cwksp_clean_tables");
; 380  :     assert(ws->tableValidEnd >= ws->objectEnd);
; 381  :     assert(ws->tableValidEnd <= ws->allocStart);
; 382  :     if (ws->tableValidEnd < ws->tableEnd) {

	mov	rcx, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rbx+24]
	cmp	rcx, rax
	jae	SHORT $LN5@ZSTD_cwksp

; 383  :         memset(ws->tableValidEnd, 0, (BYTE*)ws->tableEnd - (BYTE*)ws->tableValidEnd);

	sub	rax, rcx
	xor	edx, edx
	mov	r8, rax
	call	memset
	mov	rcx, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rbx+24]

; 369  :     if (ws->tableValidEnd < ws->tableEnd) {

	cmp	rcx, rax
	jae	SHORT $LN5@ZSTD_cwksp

; 370  :         ws->tableValidEnd = ws->tableEnd;

	mov	QWORD PTR [rbx+32], rax
$LN5@ZSTD_cwksp:

; 384  :     }
; 385  :     ZSTD_cwksp_mark_tables_clean(ws);
; 386  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_cwksp_clean_tables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_clear_tables PROC

; 393  :     DEBUGLOG(4, "cwksp: clearing tables!");
; 394  : 
; 395  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 396  :     {
; 397  :         size_t size = (BYTE*)ws->tableValidEnd - (BYTE*)ws->objectEnd;
; 398  :         __asan_poison_memory_region(ws->objectEnd, size);
; 399  :     }
; 400  : #endif
; 401  : 
; 402  :     ws->tableEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+24], rax

; 403  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 404  : }

	ret	0
ZSTD_cwksp_clear_tables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_clear PROC

; 411  :     DEBUGLOG(4, "cwksp: clearing!");
; 412  : 
; 413  : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 414  :     /* To validate that the context re-use logic is sound, and that we don't
; 415  :      * access stuff that this compression hasn't initialized, we re-"poison"
; 416  :      * the workspace (or at least the non-static, non-table parts of it)
; 417  :      * every time we start a new compression. */
; 418  :     {
; 419  :         size_t size = (BYTE*)ws->workspaceEnd - (BYTE*)ws->tableValidEnd;
; 420  :         __msan_poison(ws->tableValidEnd, size);
; 421  :     }
; 422  : #endif
; 423  : 
; 424  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 425  :     {
; 426  :         size_t size = (BYTE*)ws->workspaceEnd - (BYTE*)ws->objectEnd;
; 427  :         __asan_poison_memory_region(ws->objectEnd, size);
; 428  :     }
; 429  : #endif
; 430  : 
; 431  :     ws->tableEnd = ws->objectEnd;
; 432  :     ws->allocStart = ws->workspaceEnd;
; 433  :     ws->allocFailed = 0;
; 434  :     if (ws->phase > ZSTD_cwksp_alloc_buffers) {

	cmp	DWORD PTR [rcx+56], 1
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+24], rax
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], 0
	jle	SHORT $LN2@ZSTD_cwksp

; 435  :         ws->phase = ZSTD_cwksp_alloc_buffers;

	mov	DWORD PTR [rcx+56], 1
$LN2@ZSTD_cwksp:

; 436  :     }
; 437  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 438  : }

	ret	0
ZSTD_cwksp_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
start$ = 16
size$ = 24
ZSTD_cwksp_init PROC

; 446  :     DEBUGLOG(4, "cwksp: init'ing workspace with %zd bytes", size);
; 447  :     assert(((size_t)start & (sizeof(void*)-1)) == 0); /* ensure correct alignment */
; 448  :     ws->workspace = start;
; 449  :     ws->workspaceEnd = (BYTE*)start + size;

	lea	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR [rcx], rdx

; 452  :     ws->phase = ZSTD_cwksp_alloc_objects;

	xor	r8d, r8d
	mov	QWORD PTR [rcx+8], rax

; 453  :     ZSTD_cwksp_clear(ws);
; 454  :     ws->workspaceOversizedDuration = 0;

	mov	QWORD PTR [rcx+52], r8

; 433  :     ws->allocFailed = 0;

	mov	DWORD PTR [rcx+48], r8d

; 450  :     ws->objectEnd = ws->workspace;

	mov	QWORD PTR [rcx+16], rdx

; 451  :     ws->tableValidEnd = ws->objectEnd;

	mov	QWORD PTR [rcx+32], rdx

; 431  :     ws->tableEnd = ws->objectEnd;

	mov	QWORD PTR [rcx+24], rdx

; 432  :     ws->allocStart = ws->workspaceEnd;

	mov	QWORD PTR [rcx+40], rax

; 455  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 456  : }

	ret	0
ZSTD_cwksp_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
$T1 = 32
ws$ = 80
size$ = 88
customMem$ = 96
ZSTD_cwksp_create PROC

; 458  : MEM_STATIC size_t ZSTD_cwksp_create(ZSTD_cwksp* ws, size_t size, ZSTD_customMem customMem) {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [r8]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 458  : MEM_STATIC size_t ZSTD_cwksp_create(ZSTD_cwksp* ws, size_t size, ZSTD_customMem customMem) {

	mov	rdi, rdx

; 459  :     void* workspace = ZSTD_malloc(size, customMem);

	movsd	xmm0, QWORD PTR [r8+16]
	mov	rbx, rcx
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN6@ZSTD_cwksp

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN13@ZSTD_cwksp
$LN6@ZSTD_cwksp:

; 60   :     return malloc(size);

	mov	rcx, rdi
	call	QWORD PTR __imp_malloc
$LN13@ZSTD_cwksp:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 461  :     RETURN_ERROR_IF(workspace == NULL, memory_allocation, "NULL pointer!");

	mov	rcx, rax
	test	rax, rax
	jne	SHORT $LN2@ZSTD_cwksp
	lea	rax, QWORD PTR [rcx-64]

; 464  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN2@ZSTD_cwksp:

; 449  :     ws->workspaceEnd = (BYTE*)start + size;

	lea	rax, QWORD PTR [rcx+rdi]
	mov	QWORD PTR [rbx], rcx

; 452  :     ws->phase = ZSTD_cwksp_alloc_objects;

	xor	edx, edx
	mov	QWORD PTR [rbx+8], rax

; 432  :     ws->allocStart = ws->workspaceEnd;

	mov	QWORD PTR [rbx+40], rax

; 462  :     ZSTD_cwksp_init(ws, workspace, size);
; 463  :     return 0;

	xor	eax, eax

; 454  :     ws->workspaceOversizedDuration = 0;

	mov	QWORD PTR [rbx+52], rdx

; 433  :     ws->allocFailed = 0;

	mov	DWORD PTR [rbx+48], edx

; 450  :     ws->objectEnd = ws->workspace;

	mov	QWORD PTR [rbx+16], rcx

; 451  :     ws->tableValidEnd = ws->objectEnd;

	mov	QWORD PTR [rbx+32], rcx

; 431  :     ws->tableEnd = ws->objectEnd;

	mov	QWORD PTR [rbx+24], rcx

; 464  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTD_cwksp_create ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
$T1 = 32
ws$ = 80
customMem$ = 88
ZSTD_cwksp_free PROC

; 466  : MEM_STATIC void ZSTD_cwksp_free(ZSTD_cwksp* ws, ZSTD_customMem customMem) {

	sub	rsp, 72					; 00000048H

; 467  :     void *ptr = ws->workspace;

	mov	r8, QWORD PTR [rcx]
	xorps	xmm0, xmm0

; 468  :     DEBUGLOG(4, "cwksp: freeing workspace");
; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));
; 470  :     ZSTD_free(ptr, customMem);

	movsd	xmm1, QWORD PTR [rdx+16]
	movsd	QWORD PTR $T1[rsp+16], xmm1
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movaps	xmm0, XMMWORD PTR [rdx]
	movaps	XMMWORD PTR $T1[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	r8, r8
	je	SHORT $LN6@ZSTD_cwksp

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN5@ZSTD_cwksp

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, r8
	call	rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 471  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN5@ZSTD_cwksp:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, r8
	call	QWORD PTR __imp_free
$LN6@ZSTD_cwksp:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 471  : }

	add	rsp, 72					; 00000048H
	ret	0
ZSTD_cwksp_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_cwksp_move PROC

; 478  :     *dst = *src;

	movaps	xmm0, XMMWORD PTR [rdx]
	movaps	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movaps	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+16], xmm1
	movaps	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+32], xmm0
	xorps	xmm0, xmm0

; 479  :     memset(src, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	XMMWORD PTR [rdx+48], xmm0
	movups	XMMWORD PTR [rcx+48], xmm1

; 480  : }

	ret	0
ZSTD_cwksp_move ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_sizeof PROC

; 483  :     return (size_t)((BYTE*)ws->workspaceEnd - (BYTE*)ws->workspace);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]

; 484  : }

	ret	0
ZSTD_cwksp_sizeof ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_reserve_failed PROC

; 487  :     return ws->allocFailed;

	mov	eax, DWORD PTR [rcx+48]

; 488  : }

	ret	0
ZSTD_cwksp_reserve_failed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
ZSTD_cwksp_available_space PROC

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	mov	rax, QWORD PTR [rcx+40]
	sub	rax, QWORD PTR [rcx+24]

; 496  : }

	ret	0
ZSTD_cwksp_available_space ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
additionalNeededSpace$ = 16
ZSTD_cwksp_check_available PROC

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	mov	r8, QWORD PTR [rcx+40]

; 499  :     return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;

	xor	eax, eax

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	sub	r8, QWORD PTR [rcx+24]

; 499  :     return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;

	cmp	r8, rdx
	setae	al

; 500  : }

	ret	0
ZSTD_cwksp_check_available ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
additionalNeededSpace$ = 16
ZSTD_cwksp_check_too_large PROC

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	mov	r8, QWORD PTR [rcx+40]

; 499  :     return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;

	xor	eax, eax

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	sub	r8, QWORD PTR [rcx+24]

; 503  :     return ZSTD_cwksp_check_available(

	lea	rcx, QWORD PTR [rdx+rdx*2]

; 499  :     return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;

	cmp	r8, rcx
	setae	al

; 504  :         ws, additionalNeededSpace * ZSTD_WORKSPACETOOLARGE_FACTOR);
; 505  : }

	ret	0
ZSTD_cwksp_check_too_large ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
additionalNeededSpace$ = 16
ZSTD_cwksp_check_wasteful PROC

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	mov	r8, QWORD PTR [rcx+40]

; 503  :     return ZSTD_cwksp_check_available(

	lea	rax, QWORD PTR [rdx+rdx*2]

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	sub	r8, QWORD PTR [rcx+24]

; 499  :     return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;

	cmp	r8, rax

; 508  :     return ZSTD_cwksp_check_too_large(ws, additionalNeededSpace)

	jb	SHORT $LN3@ZSTD_cwksp
	cmp	DWORD PTR [rcx+52], 128			; 00000080H
	jle	SHORT $LN3@ZSTD_cwksp
	mov	eax, 1

; 509  :         && ws->workspaceOversizedDuration > ZSTD_WORKSPACETOOLARGE_MAXDURATION;
; 510  : }

	ret	0
$LN3@ZSTD_cwksp:

; 508  :     return ZSTD_cwksp_check_too_large(ws, additionalNeededSpace)

	xor	eax, eax

; 509  :         && ws->workspaceOversizedDuration > ZSTD_WORKSPACETOOLARGE_MAXDURATION;
; 510  : }

	ret	0
ZSTD_cwksp_check_wasteful ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
_TEXT	SEGMENT
ws$ = 8
additionalNeededSpace$dead$ = 16
ZSTD_cwksp_bump_oversized_duration PROC

; 514  :     if (ZSTD_cwksp_check_too_large(ws, additionalNeededSpace)) {
; 515  :         ws->workspaceOversizedDuration++;

	inc	DWORD PTR [rcx+52]

; 516  :     } else {
; 517  :         ws->workspaceOversizedDuration = 0;
; 518  :     }
; 519  : }

	ret	0
ZSTD_cwksp_bump_oversized_duration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
litLength$ = 8
ZSTD_LLcode PROC

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	cmp	ecx, 63					; 0000003fH
	jbe	SHORT $LN3@ZSTD_LLcod
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, ecx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	add	eax, 19

; 310  : }

	ret	0
$LN3@ZSTD_LLcod:

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	mov	eax, ecx
	lea	rcx, OFFSET FLAT:?LL_Code@?1??ZSTD_LLcode@@9@9
	movzx	eax, BYTE PTR [rax+rcx]

; 310  : }

	ret	0
ZSTD_LLcode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
mlBase$ = 8
ZSTD_MLcode PROC

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	cmp	ecx, 127				; 0000007fH
	jbe	SHORT $LN3@ZSTD_MLcod
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, ecx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	add	eax, 36					; 00000024H

; 327  : }

	ret	0
$LN3@ZSTD_MLcod:

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	mov	eax, ecx
	lea	rcx, OFFSET FLAT:?ML_Code@?1??ZSTD_MLcode@@9@9
	movzx	eax, BYTE PTR [rax+rcx]

; 327  : }

	ret	0
ZSTD_MLcode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
$T1 = 32
bounds$ = 32
cParam$ = 64
value$ = 72
ZSTD_cParam_withinBounds PROC

; 358  : {

	sub	rsp, 56					; 00000038H
	mov	r9d, edx

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, ecx
	lea	rcx, QWORD PTR $T1[rsp]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	SHORT $LN8@ZSTD_cPara

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$[rsp+8]
	cmp	r9d, eax
	jl	SHORT $LN8@ZSTD_cPara

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r9d, eax
	jg	SHORT $LN8@ZSTD_cPara

; 363  :     return 1;

	mov	eax, 1

; 364  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN8@ZSTD_cPara:

; 362  :     if (value > bounds.upperBound) return 0;

	xor	eax, eax

; 364  : }

	add	rsp, 56					; 00000038H
	ret	0
ZSTD_cParam_withinBounds ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
dst$ = 48
dstCapacity$ = 56
src$ = 64
srcSize$ = 72
lastBlock$ = 80
ZSTD_noCompressBlock PROC

; 370  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 371  :     U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);

	lea	rax, QWORD PTR [r9*8]
	mov	r10, r8
	add	eax, DWORD PTR lastBlock$[rsp]

; 372  :     RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,

	lea	rbx, QWORD PTR [r9+3]
	cmp	rbx, rdx
	jbe	SHORT $LN2@ZSTD_noCom
	mov	rax, -70				; ffffffffffffffbaH

; 377  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@ZSTD_noCom:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rcx], ax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	r8, r9
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	eax, 16
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	rdx, r10
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [rcx+2], al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	add	rcx, 3
	call	memcpy

; 376  :     return ZSTD_blockHeaderSize + srcSize;

	mov	rax, rbx

; 377  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_noCompressBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
dst$ = 8
dstCapacity$ = 16
src$ = 24
srcSize$ = 32
lastBlock$ = 40
ZSTD_rleCompressBlock PROC

; 381  :     BYTE* const op = (BYTE*)dst;
; 382  :     U32 const cBlockHeader = lastBlock + (((U32)bt_rle)<<1) + (U32)(srcSize << 3);

	lea	r10d, DWORD PTR [r9*8+2]
	add	r10d, DWORD PTR lastBlock$[rsp]

; 383  :     RETURN_ERROR_IF(dstCapacity < 4, dstSize_tooSmall, "");

	cmp	rdx, 4
	jae	SHORT $LN2@ZSTD_rleCo
	mov	rax, -70				; ffffffffffffffbaH

; 387  : }

	ret	0
$LN2@ZSTD_rleCo:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rcx], r10w
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 386  :     return 4;

	mov	eax, 4
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	r10d, 16
	mov	BYTE PTR [rcx+2], r10b
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 385  :     op[3] = src;

	mov	BYTE PTR [rcx+3], r8b

; 387  : }

	ret	0
ZSTD_rleCompressBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
srcSize$ = 8
strat$ = 16
ZSTD_minGain PROC

; 395  : {

	mov	rax, rcx

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	lea	ecx, DWORD PTR [rdx-1]
	cmp	edx, 8
	jge	SHORT $LN4@ZSTD_minGa
	mov	ecx, 6
$LN4@ZSTD_minGa:

; 397  :     ZSTD_STATIC_ASSERT(ZSTD_btultra == 8);
; 398  :     assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));
; 399  :     return (srcSize >> minlog) + 2;

	shr	rax, cl
	add	rax, 2

; 400  : }

	ret	0
ZSTD_minGain ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
cctxParams$ = 8
ZSTD_disableLiteralsCompression PROC

; 404  :     switch (cctxParams->literalCompressionMode) {

	mov	edx, DWORD PTR [rcx+72]
	test	edx, edx
	je	SHORT $LN6@ZSTD_disab
	sub	edx, 1
	je	SHORT $LN9@ZSTD_disab
	cmp	edx, 1
	je	SHORT $LN11@ZSTD_disab
$LN6@ZSTD_disab:

; 405  :     case ZSTD_lcm_huffman:
; 406  :         return 0;
; 407  :     case ZSTD_lcm_uncompressed:
; 408  :         return 1;
; 409  :     default:
; 410  :         assert(0 /* impossible: pre-validated */);
; 411  :         /* fall-through */
; 412  :     case ZSTD_lcm_auto:
; 413  :         return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);

	cmp	DWORD PTR [rcx+28], 1
	jne	SHORT $LN9@ZSTD_disab
	cmp	DWORD PTR [rcx+24], 0
	jbe	SHORT $LN9@ZSTD_disab
$LN11@ZSTD_disab:

; 414  :     }
; 415  : }

	mov	eax, 1
	ret	0
$LN9@ZSTD_disab:
	xor	eax, eax
	ret	0
ZSTD_disableLiteralsCompression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
base$dead$ = 8
exponent$ = 16
ZSTD_ipow PROC

; 646  : {

	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H

; 647  :     U64 power = 1;

	mov	eax, 1

; 648  :     while (exponent) {

	test	rdx, rdx
	je	SHORT $LN10@ZSTD_ipow
$LL2@ZSTD_ipow:

; 649  :       if (exponent & 1) power *= base;

	test	dl, 1
	je	SHORT $LN4@ZSTD_ipow
	imul	rax, rcx
$LN4@ZSTD_ipow:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rcx, rcx
	shr	rdx, 1
	jne	SHORT $LL2@ZSTD_ipow
$LN10@ZSTD_ipow:

; 652  :     }
; 653  :     return power;
; 654  : }

	ret	0
ZSTD_ipow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
length$ = 8
ZSTD_rollingHash_primePower PROC

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	dec	ecx
	mov	rdx, -3523014627327384477		; cf1bbcdcb7a56463H

; 647  :     U64 power = 1;

	mov	eax, 1

; 648  :     while (exponent) {

	test	rcx, rcx
	je	SHORT $LN12@ZSTD_rolli
$LL4@ZSTD_rolli:

; 649  :       if (exponent & 1) power *= base;

	test	cl, 1
	je	SHORT $LN6@ZSTD_rolli
	imul	rax, rdx
$LN6@ZSTD_rolli:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rdx, rdx
	shr	rcx, 1
	jne	SHORT $LL4@ZSTD_rolli
$LN12@ZSTD_rolli:

; 687  : }

	ret	0
ZSTD_rollingHash_primePower ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
ZSTD_window_clear PROC

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	mov	eax, DWORD PTR [rcx]
	sub	eax, DWORD PTR [rcx+8]

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rcx+28], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rcx+24], eax

; 724  : }

	ret	0
ZSTD_window_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
ZSTD_window_hasExtDict PROC

; 732  :     return window.lowLimit < window.dictLimit;

	mov	edx, DWORD PTR [rcx+24]
	xor	eax, eax
	cmp	DWORD PTR [rcx+28], edx
	setb	al

; 733  : }

	ret	0
ZSTD_window_hasExtDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 48
ZSTD_matchState_dictMode PROC

; 741  : {

	sub	rsp, 40					; 00000028H

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	movups	xmm1, XMMWORD PTR [rcx+16]

; 732  :     return window.lowLimit < window.dictLimit;

	psrldq	xmm1, 8
	movq	rdx, xmm1
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	cmp	eax, edx

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	jae	SHORT $LN3@ZSTD_match
	mov	eax, 1

; 743  :         ZSTD_extDict :
; 744  :         ms->dictMatchState != NULL ?
; 745  :             ZSTD_dictMatchState :
; 746  :             ZSTD_noDict;
; 747  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@ZSTD_match:

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	mov	rax, QWORD PTR [rcx+176]
	neg	rax
	sbb	eax, eax
	and	eax, 2

; 743  :         ZSTD_extDict :
; 744  :         ms->dictMatchState != NULL ?
; 745  :             ZSTD_dictMatchState :
; 746  :             ZSTD_noDict;
; 747  : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_matchState_dictMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
srcEnd$ = 16
ZSTD_window_needOverflowCorrection PROC

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	sub	edx, DWORD PTR [rcx+8]

; 758  :     return current > ZSTD_CURRENT_MAX;

	xor	eax, eax
	cmp	edx, -536870912				; e0000000H
	seta	al

; 759  : }

	ret	0
ZSTD_window_needOverflowCorrection ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
cycleLog$ = 16
maxDist$ = 24
src$ = 32
ZSTD_window_correctOverflow PROC

; 774  :     /* preemptive overflow correction:
; 775  :      * 1. correction is large enough:
; 776  :      *    lowLimit > (3<<29) ==> current > 3<<29 + 1<<windowLog
; 777  :      *    1<<windowLog <= newCurrent < 1<<chainLog + 1<<windowLog
; 778  :      *
; 779  :      *    current - newCurrent
; 780  :      *    > (3<<29 + 1<<windowLog) - (1<<windowLog + 1<<chainLog)
; 781  :      *    > (3<<29) - (1<<chainLog)
; 782  :      *    > (3<<29) - (1<<30)             (NOTE: chainLog <= 30)
; 783  :      *    > 1<<29
; 784  :      *
; 785  :      * 2. (ip+ZSTD_CHUNKSIZE_MAX - cctx->base) doesn't overflow:
; 786  :      *    After correction, current is less than (1<<chainLog + 1<<windowLog).
; 787  :      *    In 64-bit mode we are safe, because we have 64-bit ptrdiff_t.
; 788  :      *    In 32-bit mode we are safe, because (chainLog <= 29), so
; 789  :      *    ip+ZSTD_CHUNKSIZE_MAX - cctx->base < 1<<32.
; 790  :      * 3. (cctx->lowLimit + 1<<windowLog) < 1<<32:
; 791  :      *    windowLog <= 31 ==> 3<<29 + 1<<windowLog < 7<<29 < 1<<32.
; 792  :      */
; 793  :     U32 const cycleMask = (1U << cycleLog) - 1;
; 794  :     U32 const current = (U32)((BYTE const*)src - window->base);

	sub	r9d, DWORD PTR [rcx+8]
	mov	r10, rcx
	mov	r11d, 1
	mov	ecx, edx
	mov	edx, r11d
	shl	edx, cl
	lea	eax, DWORD PTR [rdx-1]
	and	eax, r9d

; 795  :     U32 const currentCycle0 = current & cycleMask;
; 796  :     /* Exclude zero so that newCurrent - maxDist >= 1. */
; 797  :     U32 const currentCycle1 = currentCycle0 == 0 ? (1U << cycleLog) : currentCycle0;
; 798  :     U32 const newCurrent = currentCycle1 + maxDist;
; 799  :     U32 const correction = current - newCurrent;

	cmovne	edx, eax
	sub	r9d, edx
	sub	r9d, r8d

; 800  :     assert((maxDist & cycleMask) == 0);
; 801  :     assert(current > newCurrent);
; 802  :     /* Loose bound, should be around 1<<29 (see above) */
; 803  :     assert(correction > 1<<28);
; 804  : 
; 805  :     window->base += correction;

	mov	eax, r9d
	add	QWORD PTR [r10+8], rax

; 806  :     window->dictBase += correction;

	add	QWORD PTR [r10+16], rax

; 807  :     if (window->lowLimit <= correction) window->lowLimit = 1;
; 808  :     else window->lowLimit -= correction;

	mov	eax, DWORD PTR [r10+28]
	sub	eax, r9d
	cmp	DWORD PTR [r10+28], r9d
	cmovbe	eax, r11d

; 809  :     if (window->dictLimit <= correction) window->dictLimit = 1;

	mov	DWORD PTR [r10+28], eax

; 810  :     else window->dictLimit -= correction;

	mov	eax, DWORD PTR [r10+24]
	sub	eax, r9d
	cmp	DWORD PTR [r10+24], r9d
	cmovbe	eax, r11d

; 811  : 
; 812  :     /* Ensure we can still reference the full window. */
; 813  :     assert(newCurrent >= maxDist);
; 814  :     assert(newCurrent - maxDist >= 1);
; 815  :     /* Ensure that lowLimit and dictLimit didn't underflow. */
; 816  :     assert(window->lowLimit <= newCurrent);
; 817  :     assert(window->dictLimit <= newCurrent);
; 818  : 
; 819  :     DEBUGLOG(4, "Correction of 0x%x bytes to lowLimit=0x%x", correction,
; 820  :              window->lowLimit);
; 821  :     return correction;

	mov	DWORD PTR [r10+24], eax
	mov	eax, r9d

; 822  : }

	ret	0
ZSTD_window_correctOverflow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
blockEnd$ = 16
maxDist$ = 24
loadedDictEndPtr$ = 32
dictMatchStatePtr$ = 40
ZSTD_checkDictValidity PROC

; 899  :     assert(loadedDictEndPtr != NULL);
; 900  :     assert(dictMatchStatePtr != NULL);
; 901  :     {   U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);

	sub	edx, DWORD PTR [rcx+8]

; 902  :         U32 const loadedDictEnd = *loadedDictEndPtr;
; 903  :         DEBUGLOG(5, "ZSTD_checkDictValidity: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u",
; 904  :                     (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);
; 905  :         assert(blockEndIdx >= loadedDictEnd);
; 906  : 
; 907  :         if (blockEndIdx > loadedDictEnd + maxDist) {

	mov	ecx, DWORD PTR [r9]
	add	ecx, r8d
	cmp	edx, ecx
	jbe	SHORT $LN2@ZSTD_check

; 908  :             /* On reaching window size, dictionaries are invalidated.
; 909  :              * For simplification, if window size is reached anywhere within next block,
; 910  :              * the dictionary is invalidated for the full block.
; 911  :              */
; 912  :             DEBUGLOG(6, "invalidating dictionary for current block (distance > windowSize)");
; 913  :             *loadedDictEndPtr = 0;
; 914  :             *dictMatchStatePtr = NULL;

	mov	rax, QWORD PTR dictMatchStatePtr$[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [r9], ecx
	mov	QWORD PTR [rax], rcx
$LN2@ZSTD_check:

; 915  :         } else {
; 916  :             if (*loadedDictEndPtr != 0) {
; 917  :                 DEBUGLOG(6, "dictionary considered valid for current block");
; 918  :     }   }   }
; 919  : }

	ret	0
ZSTD_checkDictValidity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
ZSTD_window_init PROC

; 922  :     memset(window, 0, sizeof(*window));
; 923  :     window->base = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294966450

; 924  :     window->dictBase = (BYTE const*)"";
; 925  :     window->dictLimit = 1;    /* start from 1, so that 1st position is valid */

	mov	DWORD PTR [rcx+24], 1
	mov	QWORD PTR [rcx+8], rax
	lea	rax, OFFSET FLAT:$SG4294966449
	mov	QWORD PTR [rcx+16], rax

; 926  :     window->lowLimit = 1;     /* it ensures first and later CCtx usages compress the same */
; 927  :     window->nextSrc = window->base + 1;   /* see issue #1241 */

	lea	rax, OFFSET FLAT:$SG4294966450+1
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+28], 1

; 928  : }

	ret	0
ZSTD_window_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 16
src$ = 24
srcSize$ = 32
ZSTD_window_update PROC

; 939  : {

	push	rsi
	mov	rsi, r8
	mov	r10, rdx
	mov	r9, rcx

; 940  :     BYTE const* const ip = (BYTE const*)src;
; 941  :     U32 contiguous = 1;

	mov	r11d, 1

; 942  :     DEBUGLOG(5, "ZSTD_window_update");
; 943  :     if (srcSize == 0)

	test	r8, r8
	je	$LN11@ZSTD_windo

; 944  :         return contiguous;
; 945  :     assert(window->base != NULL);
; 946  :     assert(window->dictBase != NULL);
; 947  :     /* Check if blocks follow each other */
; 948  :     if (src != window->nextSrc) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
	xor	edi, edi
	cmp	rdx, rcx
	je	SHORT $LN10@ZSTD_windo

; 949  :         /* not contiguous */
; 950  :         size_t const distanceFromBase = (size_t)(window->nextSrc - window->base);

	mov	rbx, QWORD PTR [r9+8]

; 951  :         DEBUGLOG(5, "Non contiguous blocks, new segment starts at %u", window->dictLimit);
; 952  :         window->lowLimit = window->dictLimit;
; 953  :         assert(distanceFromBase == (size_t)(U32)distanceFromBase);  /* should never overflow */
; 954  :         window->dictLimit = (U32)distanceFromBase;
; 955  :         window->dictBase = window->base;
; 956  :         window->base = ip - distanceFromBase;

	mov	rax, r10
	mov	edx, DWORD PTR [r9+24]
	sub	rcx, rbx
	sub	rax, rcx
	mov	DWORD PTR [r9+28], edx
	mov	QWORD PTR [r9+8], rax

; 957  :         /* ms->nextToUpdate = window->dictLimit; */
; 958  :         if (window->dictLimit - window->lowLimit < HASH_READ_SIZE) window->lowLimit = window->dictLimit;   /* too small extDict */

	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR [r9+24], ecx
	mov	QWORD PTR [r9+16], rbx
	cmp	eax, 8
	jae	SHORT $LN9@ZSTD_windo
	mov	DWORD PTR [r9+28], ecx
	mov	edx, ecx
$LN9@ZSTD_windo:

; 959  :         contiguous = 0;

	mov	r11d, edi
	jmp	SHORT $LN3@ZSTD_windo
$LN10@ZSTD_windo:
	mov	rbx, QWORD PTR [r9+16]
	mov	edx, DWORD PTR [r9+28]
	mov	ecx, DWORD PTR [r9+24]
$LN3@ZSTD_windo:

; 960  :     }
; 961  :     window->nextSrc = ip + srcSize;
; 962  :     /* if input and dictionary overlap : reduce dictionary (area presumed modified by input) */
; 963  :     if ( (ip+srcSize > window->dictBase + window->lowLimit)
; 964  :        & (ip < window->dictBase + window->dictLimit)) {

	mov	eax, edx
	mov	edx, edi
	add	rax, rbx
	mov	r8d, ecx
	lea	rcx, QWORD PTR [r10+rsi]
	cmp	rcx, rax
	mov	QWORD PTR [r9], rcx
	seta	dl
	lea	rax, QWORD PTR [r8+rbx]
	cmp	r10, rax
	setb	dil
	test	edx, edi
	mov	rdi, QWORD PTR [rsp+24]
	je	SHORT $LN5@ZSTD_windo

; 965  :         ptrdiff_t const highInputIdx = (ip + srcSize) - window->dictBase;

	sub	r10, rbx
	add	r10, rsi

; 966  :         U32 const lowLimitMax = (highInputIdx > (ptrdiff_t)window->dictLimit) ? window->dictLimit : (U32)highInputIdx;
; 967  :         window->lowLimit = lowLimitMax;

	cmp	r10, r8
	cmovle	r8d, r10d
	mov	DWORD PTR [r9+28], r8d
$LN5@ZSTD_windo:

; 968  :         DEBUGLOG(5, "Overlapping extDict and input : new lowLimit = %u", window->lowLimit);
; 969  :     }
; 970  :     return contiguous;

	mov	rbx, QWORD PTR [rsp+16]
$LN11@ZSTD_windo:

; 971  : }

	mov	eax, r11d
	pop	rsi
	ret	0
ZSTD_window_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
srcSize$ = 8
ZSTD_compressBound PROC

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	xor	edx, edx
	mov	eax, 131072				; 00020000H
	sub	rax, rcx
	shr	rax, 11
	cmp	rcx, 131072				; 00020000H
	cmovb	rdx, rax
	mov	rax, rcx
	shr	rax, 8
	add	rax, rdx
	add	rax, rcx

; 46   : }

	ret	0
ZSTD_compressBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 80
ZSTD_createCCtx PROC

; 65   : {

$LN11:
	push	rbx
	sub	rsp, 64					; 00000040H

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	movups	xmm0, XMMWORD PTR ZSTD_defaultCMem
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	mov	ecx, 1160				; 00000488H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	xmm0, QWORD PTR ZSTD_defaultCMem+16
	movsd	QWORD PTR $T3[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 60   :     return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 87   :         if (!cctx) return NULL;

	test	rax, rax
	jne	SHORT $LN5@ZSTD_creat

; 67   : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN5@ZSTD_creat:

; 88   :         ZSTD_initCCtx(cctx, customMem);

	movaps	xmm0, XMMWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	movsd	xmm1, QWORD PTR $T3[rsp]
	mov	rcx, rbx
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1
	call	ZSTD_initCCtx

; 66   :     return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);

	mov	rax, rbx

; 67   : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_createCCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\cpu.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\cpu.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\cpu.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 64
memManager$ = 72
ZSTD_initCCtx PROC

; 70   : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 71   :     assert(cctx != NULL);
; 72   :     memset(cctx, 0, sizeof(*cctx));

	xor	eax, eax
	mov	rbx, rdx
	mov	QWORD PTR [rcx], rax
	mov	rdi, rcx
	add	rcx, 12
	xor	edx, edx
	mov	r8d, 484				; 000001e4H
	call	memset
	lea	rcx, QWORD PTR [rdi+520]
	xor	edx, edx
	mov	r8d, 640				; 00000280H
	call	memset

; 73   :     cctx->customMem = memManager;

	movaps	xmm0, XMMWORD PTR [rbx]
; File E:\dev\pyzstd\lib\common\cpu.h

; 41   :     __cpuid((int*)reg, 0);

	xor	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 73   :     cctx->customMem = memManager;

	movsd	xmm1, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\common\cpu.h

; 41   :     __cpuid((int*)reg, 0);

	xor	ecx, ecx
	cpuid
	xor	r8d, r8d
	mov	r9d, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 73   :     cctx->customMem = memManager;

	movups	XMMWORD PTR [rdi+496], xmm0
	movsd	QWORD PTR [rdi+512], xmm1
; File E:\dev\pyzstd\lib\common\cpu.h

; 43   :         int const n = reg[0];

	cmp	eax, 1

; 44   :         if (n >= 1) {

	jl	SHORT $LN4@ZSTD_initC

; 45   :             __cpuid((int*)reg, 1);

	mov	eax, 1
	xor	ecx, ecx
	cpuid
$LN4@ZSTD_initC:

; 46   :             f1c = (U32)reg[2];
; 47   :             f1d = (U32)reg[3];
; 48   :         }
; 49   :         if (n >= 7) {

	cmp	r9d, 7
	jl	SHORT $LN5@ZSTD_initC

; 50   :             __cpuidex((int*)reg, 7, 0);

	mov	eax, 7
	xor	ecx, ecx
	cpuid
	mov	r8d, ebx
$LN5@ZSTD_initC:

; 187  :   B(bmi2, 8)

	shr	r8d, 8
	and	r8d, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 971  :         RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,

	cmp	DWORD PTR [rdi+1072], 0

; 74   :     cctx->bmi2 = ZSTD_cpuid_bmi2(ZSTD_cpuid());

	mov	DWORD PTR [rdi+8], r8d

; 971  :         RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,

	jne	SHORT $LN19@ZSTD_initC

; 972  :                         "Can't reset parameters only when not in init stage.");
; 973  :         ZSTD_clearAllDicts(cctx);

	mov	rcx, rdi
	call	ZSTD_clearAllDicts

; 974  :         return ZSTD_CCtxParams_reset(&cctx->requestedParams);

	lea	rax, QWORD PTR [rdi+16]

; 236  :     RETURN_ERROR_IF(!cctxParams, GENERIC, "NULL pointer!");

	test	rax, rax
	je	SHORT $LN19@ZSTD_initC
	xorps	xmm0, xmm0

; 237  :     memset(cctxParams, 0, sizeof(*cctxParams));

	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
	movups	XMMWORD PTR [rax+96], xmm0
	movups	XMMWORD PTR [rax+112], xmm0
	movups	XMMWORD PTR [rax+128], xmm0

; 238  :     cctxParams->compressionLevel = compressionLevel;

	mov	DWORD PTR [rax+44], 3

; 239  :     cctxParams->fParams.contentSizeFlag = 1;

	mov	DWORD PTR [rax+32], 1
$LN19@ZSTD_initC:

; 75   :     {   size_t const err = ZSTD_CCtx_reset(cctx, ZSTD_reset_parameters);
; 76   :         assert(!ZSTD_isError(err));
; 77   :         (void)err;
; 78   :     }
; 79   : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
ZSTD_initCCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
customMem$ = 80
ZSTD_createCCtx_advanced PROC

; 82   : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 83   :     ZSTD_STATIC_ASSERT(zcss_init==0);
; 84   :     ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN==(0ULL - 1));
; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	xor	edx, edx
	mov	rbx, rcx
	mov	eax, edx
	cmp	QWORD PTR [rcx+8], rax
	sete	al
	cmp	QWORD PTR [rcx], rdx
	sete	dl
	cmp	eax, edx
	jne	SHORT $LN8@ZSTD_creat
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rcx]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 86   :     {   ZSTD_CCtx* const cctx = (ZSTD_CCtx*)ZSTD_malloc(sizeof(ZSTD_CCtx), customMem);

	movsd	xmm0, QWORD PTR [rcx+16]
	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN6@ZSTD_creat

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	edx, 1160				; 00000488H
	call	rax
	jmp	SHORT $LN9@ZSTD_creat
$LN6@ZSTD_creat:

; 60   :     return malloc(size);

	mov	ecx, 1160				; 00000488H
	call	QWORD PTR __imp_malloc
$LN9@ZSTD_creat:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 87   :         if (!cctx) return NULL;

	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN8@ZSTD_creat

; 88   :         ZSTD_initCCtx(cctx, customMem);

	movaps	xmm0, XMMWORD PTR [rbx]
	lea	rdx, QWORD PTR $T1[rsp]
	movsd	xmm1, QWORD PTR [rbx+16]
	mov	rcx, rax
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	call	ZSTD_initCCtx

; 89   :         return cctx;

	mov	rax, rdi

; 90   :     }
; 91   : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN8@ZSTD_creat:
	mov	rbx, QWORD PTR [rsp+80]
	xor	eax, eax
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTD_createCCtx_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
cctx$ = 80
ZSTD_clearAllDicts PROC

; 121  : {

	push	rbx
	sub	rsp, 64					; 00000040H

; 122  :     ZSTD_free(cctx->localDict.dictBuffer, cctx->customMem);

	movups	xmm0, XMMWORD PTR [rcx+496]
	mov	rbx, rcx
	movsd	xmm1, QWORD PTR [rcx+512]
	mov	rcx, QWORD PTR [rcx+1080]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN6@ZSTD_clear

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN5@ZSTD_clear

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN6@ZSTD_clear
$LN5@ZSTD_clear:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN6@ZSTD_clear:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 123  :     ZSTD_freeCDict(cctx->localDict.cdict);

	mov	rcx, QWORD PTR [rbx+1112]
	call	ZSTD_freeCDict
	xorps	xmm0, xmm0

; 124  :     memset(&cctx->localDict, 0, sizeof(cctx->localDict));

	xor	eax, eax
	movups	XMMWORD PTR [rbx+1080], xmm0
	movups	XMMWORD PTR [rbx+1096], xmm0
	mov	QWORD PTR [rbx+1112], rax

; 125  :     memset(&cctx->prefixDict, 0, sizeof(cctx->prefixDict));

	movups	XMMWORD PTR [rbx+1128], xmm0
	mov	QWORD PTR [rbx+1144], rax

; 126  :     cctx->cdict = NULL;

	mov	QWORD PTR [rbx+1120], rax

; 127  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_clearAllDicts ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
cctx$ = 80
ZSTD_freeCCtxContent PROC

; 137  : {

	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx

; 138  :     assert(cctx != NULL);
; 139  :     assert(cctx->staticSize == 0);
; 140  :     ZSTD_clearAllDicts(cctx);

	call	ZSTD_clearAllDicts

; 141  : #ifdef ZSTD_MULTITHREAD
; 142  :     ZSTDMT_freeCCtx(cctx->mtctx); cctx->mtctx = NULL;

	mov	rcx, QWORD PTR [rbx+1152]
	call	ZSTDMT_freeCCtx

; 144  :     ZSTD_cwksp_free(&cctx->workspace, cctx->customMem);

	movups	xmm0, XMMWORD PTR [rbx+496]
	mov	QWORD PTR [rbx+1152], 0
	movsd	xmm1, QWORD PTR [rbx+512]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 467  :     void *ptr = ws->workspace;

	mov	rcx, QWORD PTR [rbx+312]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 144  :     ZSTD_cwksp_free(&cctx->workspace, cctx->customMem);

	movaps	XMMWORD PTR $T1[rsp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rbx+312], xmm0
	movups	XMMWORD PTR [rbx+328], xmm0
	movups	XMMWORD PTR [rbx+344], xmm0
	movups	XMMWORD PTR [rbx+360], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN8@ZSTD_freeC

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN7@ZSTD_freeC

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 145  : }

	add	rsp, 64					; 00000040H
	pop	rbx
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 79   :             customMem.customFree(customMem.opaque, ptr);

	rex_jmp	rax
$LN7@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 145  : }

	add	rsp, 64					; 00000040H
	pop	rbx
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN8@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 145  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_freeCCtxContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
cctx$ = 80
ZSTD_freeCCtx PROC

; 148  : {

$LN18:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx

; 149  :     if (cctx==NULL) return 0;   /* support free on NULL */

	test	rcx, rcx
	je	SHORT $LN14@ZSTD_freeC

; 150  :     RETURN_ERROR_IF(cctx->staticSize, memory_allocation,

	cmp	QWORD PTR [rcx+520], 0
	je	SHORT $LN3@ZSTD_freeC
	mov	rax, -64				; ffffffffffffffc0H

; 160  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN3@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	QWORD PTR [rcx+312], rbx
	ja	SHORT $LN9@ZSTD_freeC
	cmp	rbx, QWORD PTR [rcx+320]
	ja	SHORT $LN9@ZSTD_freeC
	call	ZSTD_freeCCtxContent
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 159  :     return 0;

	xor	eax, eax

; 160  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN9@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	call	ZSTD_freeCCtxContent
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 156  :             ZSTD_free(cctx, cctx->customMem);

	movups	xmm1, XMMWORD PTR [rbx+496]
	movsd	xmm0, QWORD PTR [rbx+512]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 156  :             ZSTD_free(cctx, cctx->customMem);

	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN13@ZSTD_freeC

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rbx
	call	rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 159  :     return 0;

	xor	eax, eax

; 160  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN13@ZSTD_freeC:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN14@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 159  :     return 0;

	xor	eax, eax

; 160  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_freeCCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ctx$ = 8
ZSTD_getSeqStore PROC

; 190  : const seqStore_t* ZSTD_getSeqStore(const ZSTD_CCtx* ctx) { return &(ctx->seqStore); }

	lea	rax, QWORD PTR [rcx+568]
	ret	0
ZSTD_getSeqStore ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
params$ = 8
ZSTD_CCtxParams_reset PROC

; 236  :     RETURN_ERROR_IF(!cctxParams, GENERIC, "NULL pointer!");

	test	rcx, rcx
	jne	SHORT $LN4@ZSTD_CCtxP

; 232  :     return ZSTD_CCtxParams_init(params, ZSTD_CLEVEL_DEFAULT);

	lea	rax, QWORD PTR [rcx-1]

; 233  : }

	ret	0
$LN4@ZSTD_CCtxP:
	xorps	xmm0, xmm0

; 232  :     return ZSTD_CCtxParams_init(params, ZSTD_CLEVEL_DEFAULT);

	xor	eax, eax

; 237  :     memset(cctxParams, 0, sizeof(*cctxParams));

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	movups	XMMWORD PTR [rcx+128], xmm0

; 238  :     cctxParams->compressionLevel = compressionLevel;

	mov	DWORD PTR [rcx+44], 3

; 239  :     cctxParams->fParams.contentSizeFlag = 1;

	mov	DWORD PTR [rcx+32], 1

; 233  : }

	ret	0
ZSTD_CCtxParams_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctxParams$ = 8
compressionLevel$dead$ = 16
ZSTD_CCtxParams_init PROC

; 236  :     RETURN_ERROR_IF(!cctxParams, GENERIC, "NULL pointer!");

	test	rcx, rcx
	jne	SHORT $LN2@ZSTD_CCtxP
	lea	rax, QWORD PTR [rcx-1]

; 241  : }

	ret	0
$LN2@ZSTD_CCtxP:
	xorps	xmm0, xmm0

; 237  :     memset(cctxParams, 0, sizeof(*cctxParams));
; 238  :     cctxParams->compressionLevel = compressionLevel;
; 239  :     cctxParams->fParams.contentSizeFlag = 1;
; 240  :     return 0;

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	movups	XMMWORD PTR [rcx+128], xmm0
	mov	DWORD PTR [rcx+44], 3
	mov	DWORD PTR [rcx+32], 1

; 241  : }

	ret	0
ZSTD_CCtxParams_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 8
param$ = 16
ZSTD_cParam_getBounds PROC

; 270  :     ZSTD_bounds bounds = { 0, 0, 0 };

	xor	eax, eax
	mov	r8, rcx
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 271  : 
; 272  :     switch(param)

	cmp	edx, 400				; 00000190H
	jg	$LN32@ZSTD_cPara
	je	$LN15@ZSTD_cPara
	add	edx, -10
	cmp	edx, 192				; 000000c0H
	ja	$LN30@ZSTD_cPara
	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN34@ZSTD_cPara[rdx+rax]
	mov	ecx, DWORD PTR $LN35@ZSTD_cPara[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN4@ZSTD_cPara:

; 273  :     {
; 274  :     case ZSTD_c_compressionLevel:
; 275  :         bounds.lowerBound = ZSTD_minCLevel();

	mov	DWORD PTR [r8+8], -131072		; fffffffffffe0000H

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 22
	ret	0
$LN5@ZSTD_cPara:

; 276  :         bounds.upperBound = ZSTD_maxCLevel();
; 277  :         return bounds;
; 278  : 
; 279  :     case ZSTD_c_windowLog:
; 280  :         bounds.lowerBound = ZSTD_WINDOWLOG_MIN;

	mov	DWORD PTR [r8+8], 10

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 31
	ret	0
$LN8@ZSTD_cPara:

; 281  :         bounds.upperBound = ZSTD_WINDOWLOG_MAX;
; 282  :         return bounds;
; 283  : 
; 284  :     case ZSTD_c_hashLog:
; 285  :         bounds.lowerBound = ZSTD_HASHLOG_MIN;
; 286  :         bounds.upperBound = ZSTD_HASHLOG_MAX;
; 287  :         return bounds;
; 288  : 
; 289  :     case ZSTD_c_chainLog:
; 290  :         bounds.lowerBound = ZSTD_CHAINLOG_MIN;
; 291  :         bounds.upperBound = ZSTD_CHAINLOG_MAX;
; 292  :         return bounds;
; 293  : 
; 294  :     case ZSTD_c_searchLog:
; 295  :         bounds.lowerBound = ZSTD_SEARCHLOG_MIN;

	mov	DWORD PTR [r8+8], 1

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 30
	ret	0
$LN9@ZSTD_cPara:

; 296  :         bounds.upperBound = ZSTD_SEARCHLOG_MAX;
; 297  :         return bounds;
; 298  : 
; 299  :     case ZSTD_c_minMatch:
; 300  :         bounds.lowerBound = ZSTD_MINMATCH_MIN;

	mov	DWORD PTR [r8+8], 3

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 7
	ret	0
$LN10@ZSTD_cPara:

; 301  :         bounds.upperBound = ZSTD_MINMATCH_MAX;
; 302  :         return bounds;
; 303  : 
; 304  :     case ZSTD_c_targetLength:
; 305  :         bounds.lowerBound = ZSTD_TARGETLENGTH_MIN;
; 306  :         bounds.upperBound = ZSTD_TARGETLENGTH_MAX;

	mov	DWORD PTR [r8+12], 131072		; 00020000H

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN11@ZSTD_cPara:

; 307  :         return bounds;
; 308  : 
; 309  :     case ZSTD_c_strategy:
; 310  :         bounds.lowerBound = ZSTD_STRATEGY_MIN;

	mov	DWORD PTR [r8+8], 1

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 9
	ret	0
$LN19@ZSTD_cPara:

; 351  : #else
; 352  :         bounds.lowerBound = 0;
; 353  :         bounds.upperBound = 0;
; 354  : #endif
; 355  :         return bounds;
; 356  : 
; 357  :     case ZSTD_c_enableLongDistanceMatching:
; 358  :         bounds.lowerBound = 0;
; 359  :         bounds.upperBound = 1;
; 360  :         return bounds;
; 361  : 
; 362  :     case ZSTD_c_ldmHashLog:
; 363  :         bounds.lowerBound = ZSTD_LDM_HASHLOG_MIN;

	mov	DWORD PTR [r8+8], 6

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 30
	ret	0
$LN20@ZSTD_cPara:

; 364  :         bounds.upperBound = ZSTD_LDM_HASHLOG_MAX;
; 365  :         return bounds;
; 366  : 
; 367  :     case ZSTD_c_ldmMinMatch:
; 368  :         bounds.lowerBound = ZSTD_LDM_MINMATCH_MIN;

	mov	DWORD PTR [r8+8], 4

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 4096			; 00001000H
	ret	0
$LN21@ZSTD_cPara:

; 369  :         bounds.upperBound = ZSTD_LDM_MINMATCH_MAX;
; 370  :         return bounds;
; 371  : 
; 372  :     case ZSTD_c_ldmBucketSizeLog:
; 373  :         bounds.lowerBound = ZSTD_LDM_BUCKETSIZELOG_MIN;

	mov	DWORD PTR [r8+8], 1

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [r8+12], 8
	ret	0
$LN22@ZSTD_cPara:

; 374  :         bounds.upperBound = ZSTD_LDM_BUCKETSIZELOG_MAX;
; 375  :         return bounds;
; 376  : 
; 377  :     case ZSTD_c_ldmHashRateLog:
; 378  :         bounds.lowerBound = ZSTD_LDM_HASHRATELOG_MIN;
; 379  :         bounds.upperBound = ZSTD_LDM_HASHRATELOG_MAX;

	mov	DWORD PTR [r8+12], 25

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN15@ZSTD_cPara:

; 311  :         bounds.upperBound = ZSTD_STRATEGY_MAX;
; 312  :         return bounds;
; 313  : 
; 314  :     case ZSTD_c_contentSizeFlag:
; 315  :         bounds.lowerBound = 0;
; 316  :         bounds.upperBound = 1;
; 317  :         return bounds;
; 318  : 
; 319  :     case ZSTD_c_checksumFlag:
; 320  :         bounds.lowerBound = 0;
; 321  :         bounds.upperBound = 1;
; 322  :         return bounds;
; 323  : 
; 324  :     case ZSTD_c_dictIDFlag:
; 325  :         bounds.lowerBound = 0;
; 326  :         bounds.upperBound = 1;
; 327  :         return bounds;
; 328  : 
; 329  :     case ZSTD_c_nbWorkers:
; 330  :         bounds.lowerBound = 0;
; 331  : #ifdef ZSTD_MULTITHREAD
; 332  :         bounds.upperBound = ZSTDMT_NBWORKERS_MAX;

	mov	DWORD PTR [rcx+12], 200			; 000000c8H

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN32@ZSTD_cPara:

; 271  : 
; 272  :     switch(param)

	cmp	edx, 1001				; 000003e9H
	jg	SHORT $LN33@ZSTD_cPara
	je	SHORT $LN26@ZSTD_cPara
	sub	edx, 401				; 00000191H
	je	SHORT $LN16@ZSTD_cPara
	sub	edx, 1
	je	SHORT $LN17@ZSTD_cPara
	sub	edx, 98					; 00000062H
	je	SHORT $LN23@ZSTD_cPara
	cmp	edx, 500				; 000001f4H
	jne	SHORT $LN30@ZSTD_cPara
$LN23@ZSTD_cPara:

; 380  :         return bounds;
; 381  : 
; 382  :     /* experimental parameters */
; 383  :     case ZSTD_c_rsyncable:
; 384  :         bounds.lowerBound = 0;
; 385  :         bounds.upperBound = 1;

	mov	DWORD PTR [r8+12], 1

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN17@ZSTD_cPara:

; 342  : #else
; 343  :         bounds.upperBound = 0;
; 344  : #endif
; 345  :         return bounds;
; 346  : 
; 347  :     case ZSTD_c_overlapLog:
; 348  : #ifdef ZSTD_MULTITHREAD
; 349  :         bounds.lowerBound = ZSTD_OVERLAPLOG_MIN;
; 350  :         bounds.upperBound = ZSTD_OVERLAPLOG_MAX;

	mov	DWORD PTR [rcx+12], 9

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN16@ZSTD_cPara:

; 333  : #else
; 334  :         bounds.upperBound = 0;
; 335  : #endif
; 336  :         return bounds;
; 337  : 
; 338  :     case ZSTD_c_jobSize:
; 339  :         bounds.lowerBound = 0;
; 340  : #ifdef ZSTD_MULTITHREAD
; 341  :         bounds.upperBound = ZSTDMT_JOBSIZE_MAX;

	mov	DWORD PTR [rcx+12], 1073741824		; 40000000H

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN26@ZSTD_cPara:

; 386  :         return bounds;
; 387  : 
; 388  :     case ZSTD_c_forceMaxWindow :
; 389  :         bounds.lowerBound = 0;
; 390  :         bounds.upperBound = 1;
; 391  :         return bounds;
; 392  : 
; 393  :     case ZSTD_c_format:
; 394  :         ZSTD_STATIC_ASSERT(ZSTD_f_zstd1 < ZSTD_f_zstd1_magicless);
; 395  :         bounds.lowerBound = ZSTD_f_zstd1;
; 396  :         bounds.upperBound = ZSTD_f_zstd1_magicless;   /* note : how to ensure at compile time that this is the highest value enum ? */
; 397  :         return bounds;
; 398  : 
; 399  :     case ZSTD_c_forceAttachDict:
; 400  :         ZSTD_STATIC_ASSERT(ZSTD_dictDefaultAttach < ZSTD_dictForceCopy);
; 401  :         bounds.lowerBound = ZSTD_dictDefaultAttach;
; 402  :         bounds.upperBound = ZSTD_dictForceLoad;       /* note : how to ensure at compile time that this is the highest value enum ? */

	mov	DWORD PTR [rcx+12], 3

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN33@ZSTD_cPara:

; 271  : 
; 272  :     switch(param)

	sub	edx, 1002				; 000003eaH
	je	SHORT $LN27@ZSTD_cPara
	sub	edx, 1
	je	SHORT $LN28@ZSTD_cPara
	cmp	edx, 1
	je	SHORT $LN29@ZSTD_cPara
$LN30@ZSTD_cPara:

; 419  :         return bounds;
; 420  : 
; 421  :     default:
; 422  :         bounds.error = ERROR(parameter_unsupported);

	mov	QWORD PTR [r8], -40			; ffffffffffffffd8H

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN29@ZSTD_cPara:

; 413  :         bounds.upperBound = ZSTD_TARGETCBLOCKSIZE_MAX;
; 414  :         return bounds;
; 415  : 
; 416  :     case ZSTD_c_srcSizeHint:
; 417  :         bounds.lowerBound = ZSTD_SRCSIZEHINT_MIN;
; 418  :         bounds.upperBound = ZSTD_SRCSIZEHINT_MAX;

	mov	DWORD PTR [rcx+12], 2147483647		; 7fffffffH

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN28@ZSTD_cPara:

; 409  :         return bounds;
; 410  : 
; 411  :     case ZSTD_c_targetCBlockSize:
; 412  :         bounds.lowerBound = ZSTD_TARGETCBLOCKSIZE_MIN;

	mov	DWORD PTR [rcx+8], 64			; 00000040H

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	mov	DWORD PTR [rcx+12], 131072		; 00020000H
	ret	0
$LN27@ZSTD_cPara:

; 403  :         return bounds;
; 404  : 
; 405  :     case ZSTD_c_literalCompressionMode:
; 406  :         ZSTD_STATIC_ASSERT(ZSTD_lcm_auto < ZSTD_lcm_huffman && ZSTD_lcm_huffman < ZSTD_lcm_uncompressed);
; 407  :         bounds.lowerBound = ZSTD_lcm_auto;
; 408  :         bounds.upperBound = ZSTD_lcm_uncompressed;

	mov	DWORD PTR [rcx+12], 2

; 423  :         return bounds;
; 424  :     }
; 425  : }

	mov	rax, r8
	ret	0
$LN35@ZSTD_cPara:
	DD	$LN23@ZSTD_cPara
	DD	$LN4@ZSTD_cPara
	DD	$LN5@ZSTD_cPara
	DD	$LN19@ZSTD_cPara
	DD	$LN8@ZSTD_cPara
	DD	$LN9@ZSTD_cPara
	DD	$LN10@ZSTD_cPara
	DD	$LN11@ZSTD_cPara
	DD	$LN20@ZSTD_cPara
	DD	$LN21@ZSTD_cPara
	DD	$LN22@ZSTD_cPara
	DD	$LN30@ZSTD_cPara
$LN34@ZSTD_cPara:
	DB	0
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	0
	DB	3
	DB	8
	DB	9
	DB	10
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	11
	DB	0
	DB	0
	DB	0
ZSTD_cParam_getBounds ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
bounds$ = 32
cParam$ = 64
value$ = 72
ZSTD_cParam_clampBounds PROC

; 431  : {

	sub	rsp, 56					; 00000038H
	mov	r9, rdx

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, ecx
	lea	rcx, QWORD PTR $T1[rsp]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 433  :     if (ZSTD_isError(bounds.error)) return bounds.error;

	ja	SHORT $LN1@ZSTD_cPara

; 434  :     if (*value < bounds.lowerBound) *value = bounds.lowerBound;

	mov	rax, QWORD PTR bounds$[rsp+8]
	mov	ecx, DWORD PTR [r9]
	cmp	ecx, eax
	jge	SHORT $LN3@ZSTD_cPara
	mov	DWORD PTR [r9], eax
	mov	ecx, eax
$LN3@ZSTD_cPara:

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	shr	rax, 32					; 00000020H
	cmp	ecx, eax
	jle	SHORT $LN4@ZSTD_cPara
	mov	DWORD PTR [r9], eax
$LN4@ZSTD_cPara:

; 436  :     return 0;

	xor	eax, eax
$LN1@ZSTD_cPara:

; 437  : }

	add	rsp, 56					; 00000038H
	ret	0
ZSTD_cParam_clampBounds ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
param$ = 8
ZSTD_isUpdateAuthorized PROC

; 447  :     switch(param)

	lea	eax, DWORD PTR [rcx-100]
	test	eax, -8					; fffffff8H
	jne	SHORT $LN5@ZSTD_isUpd
	cmp	ecx, 101				; 00000065H
	je	SHORT $LN5@ZSTD_isUpd

; 448  :     {
; 449  :     case ZSTD_c_compressionLevel:
; 450  :     case ZSTD_c_hashLog:
; 451  :     case ZSTD_c_chainLog:
; 452  :     case ZSTD_c_searchLog:
; 453  :     case ZSTD_c_minMatch:
; 454  :     case ZSTD_c_targetLength:
; 455  :     case ZSTD_c_strategy:
; 456  :         return 1;

	mov	eax, 1

; 479  :     }
; 480  : }

	ret	0
$LN5@ZSTD_isUpd:

; 457  : 
; 458  :     case ZSTD_c_format:
; 459  :     case ZSTD_c_windowLog:
; 460  :     case ZSTD_c_contentSizeFlag:
; 461  :     case ZSTD_c_checksumFlag:
; 462  :     case ZSTD_c_dictIDFlag:
; 463  :     case ZSTD_c_forceMaxWindow :
; 464  :     case ZSTD_c_nbWorkers:
; 465  :     case ZSTD_c_jobSize:
; 466  :     case ZSTD_c_overlapLog:
; 467  :     case ZSTD_c_rsyncable:
; 468  :     case ZSTD_c_enableLongDistanceMatching:
; 469  :     case ZSTD_c_ldmHashLog:
; 470  :     case ZSTD_c_ldmMinMatch:
; 471  :     case ZSTD_c_ldmBucketSizeLog:
; 472  :     case ZSTD_c_ldmHashRateLog:
; 473  :     case ZSTD_c_forceAttachDict:
; 474  :     case ZSTD_c_literalCompressionMode:
; 475  :     case ZSTD_c_targetCBlockSize:
; 476  :     case ZSTD_c_srcSizeHint:
; 477  :     default:
; 478  :         return 0;

	xor	eax, eax

; 479  :     }
; 480  : }

	ret	0
ZSTD_isUpdateAuthorized ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 8
param$ = 16
value$ = 24
ZSTD_CCtx_setParameter PROC

; 484  :     DEBUGLOG(4, "ZSTD_CCtx_setParameter (%i, %i)", (int)param, value);
; 485  :     if (cctx->streamStage != zcss_init) {

	cmp	DWORD PTR [rcx+1072], 0
	mov	r9, rcx
	je	SHORT $LN3@ZSTD_CCtx_

; 447  :     switch(param)

	lea	eax, DWORD PTR [rdx-100]
	test	eax, -8					; fffffff8H
	jne	SHORT $LN4@ZSTD_CCtx_
	cmp	edx, 101				; 00000065H
	je	SHORT $LN4@ZSTD_CCtx_

; 486  :         if (ZSTD_isUpdateAuthorized(param)) {
; 487  :             cctx->cParamsChanged = 1;

	mov	DWORD PTR [rcx+4], 1
$LN3@ZSTD_CCtx_:

; 490  :     }   }
; 491  : 
; 492  :     switch(param)

	cmp	edx, 400				; 00000190H
	jg	SHORT $LN21@ZSTD_CCtx_
	je	SHORT $LN14@ZSTD_CCtx_
	lea	eax, DWORD PTR [rdx-10]
	cmp	eax, 192				; 000000c0H
	ja	SHORT $LN9@ZSTD_CCtx_
	lea	r10, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN30@ZSTD_CCtx_[r10+rax]
	mov	ecx, DWORD PTR $LN31@ZSTD_CCtx_[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN4@ZSTD_CCtx_:

; 488  :         } else {
; 489  :             RETURN_ERROR(stage_wrong, "can only set params in ctx init stage");

	mov	rax, -60				; ffffffffffffffc4H

; 529  : }

	ret	0
$LN14@ZSTD_CCtx_:

; 493  :     {
; 494  :     case ZSTD_c_nbWorkers:
; 495  :         RETURN_ERROR_IF((value!=0) && cctx->staticSize, parameter_unsupported,

	test	r8d, r8d
	je	SHORT $LN8@ZSTD_CCtx_
	cmp	QWORD PTR [rcx+520], 0
	jne	SHORT $LN9@ZSTD_CCtx_
$LN8@ZSTD_CCtx_:

; 527  :     }
; 528  :     return ZSTD_CCtxParams_setParameter(&cctx->requestedParams, param, value);

	lea	rcx, QWORD PTR [r9+16]
	jmp	ZSTD_CCtxParams_setParameter
$LN21@ZSTD_CCtx_:

; 490  :     }   }
; 491  : 
; 492  :     switch(param)

	cmp	edx, 402				; 00000192H
	jle	SHORT $LN8@ZSTD_CCtx_
	cmp	edx, 500				; 000001f4H
	je	SHORT $LN8@ZSTD_CCtx_
	lea	eax, DWORD PTR [rdx-1000]
	cmp	eax, 4
	jbe	SHORT $LN8@ZSTD_CCtx_
$LN9@ZSTD_CCtx_:

; 496  :                         "MT not compatible with static alloc");
; 497  :         break;
; 498  : 
; 499  :     case ZSTD_c_compressionLevel:
; 500  :     case ZSTD_c_windowLog:
; 501  :     case ZSTD_c_hashLog:
; 502  :     case ZSTD_c_chainLog:
; 503  :     case ZSTD_c_searchLog:
; 504  :     case ZSTD_c_minMatch:
; 505  :     case ZSTD_c_targetLength:
; 506  :     case ZSTD_c_strategy:
; 507  :     case ZSTD_c_ldmHashRateLog:
; 508  :     case ZSTD_c_format:
; 509  :     case ZSTD_c_contentSizeFlag:
; 510  :     case ZSTD_c_checksumFlag:
; 511  :     case ZSTD_c_dictIDFlag:
; 512  :     case ZSTD_c_forceMaxWindow:
; 513  :     case ZSTD_c_forceAttachDict:
; 514  :     case ZSTD_c_literalCompressionMode:
; 515  :     case ZSTD_c_jobSize:
; 516  :     case ZSTD_c_overlapLog:
; 517  :     case ZSTD_c_rsyncable:
; 518  :     case ZSTD_c_enableLongDistanceMatching:
; 519  :     case ZSTD_c_ldmHashLog:
; 520  :     case ZSTD_c_ldmMinMatch:
; 521  :     case ZSTD_c_ldmBucketSizeLog:
; 522  :     case ZSTD_c_targetCBlockSize:
; 523  :     case ZSTD_c_srcSizeHint:
; 524  :         break;
; 525  : 
; 526  :     default: RETURN_ERROR(parameter_unsupported, "unknown parameter");

	mov	rax, -40				; ffffffffffffffd8H

; 529  : }

	ret	0
$LN31@ZSTD_CCtx_:
	DD	$LN8@ZSTD_CCtx_
	DD	$LN9@ZSTD_CCtx_
$LN30@ZSTD_CCtx_:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
ZSTD_CCtx_setParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
bounds$4 = 32
$T5 = 32
bounds$6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
bounds$11 = 32
$T12 = 32
bounds$13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
bounds$17 = 32
$T18 = 32
bounds$19 = 32
$T20 = 32
bounds$21 = 32
$T22 = 32
bounds$23 = 32
$T24 = 32
bounds$25 = 32
$T26 = 32
bounds$27 = 32
$T28 = 32
bounds$29 = 32
$T30 = 32
bounds$31 = 32
bounds$32 = 32
CCtxParams$ = 64
param$ = 72
value$ = 80
ZSTD_CCtxParams_setParameter PROC

; 533  : {

$LN469:
	push	rbp
	mov	rbp, rsp
	sub	rsp, 48					; 00000030H
	movsxd	r10, r8d
	mov	r11, rcx

; 534  :     DEBUGLOG(4, "ZSTD_CCtxParams_setParameter (%i, %i)", (int)param, value);
; 535  :     switch(param)

	cmp	edx, 400				; 00000190H
	jg	$LN107@ZSTD_CCtxP
	je	$LN9@ZSTD_CCtxP
	lea	eax, DWORD PTR [rdx-10]
	cmp	eax, 192				; 000000c0H
	ja	$LN21@ZSTD_CCtxP
	lea	r8, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN465@ZSTD_CCtxP[r8+rax]
	mov	ecx, DWORD PTR $LN466@ZSTD_CCtxP[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN22@ZSTD_CCtxP:

; 536  :     {
; 537  :     case ZSTD_c_format :
; 538  :         BOUNDCHECK(ZSTD_c_format, value);

	mov	edx, r10d
	mov	ecx, 10
	call	ZSTD_cParam_withinBounds
	test	eax, eax
	je	$LN464@ZSTD_CCtxP

; 539  :         CCtxParams->format = (ZSTD_format_e)value;

	mov	DWORD PTR [r11], r10d

; 540  :         return (size_t)CCtxParams->format;

	mov	rax, r10

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN6@ZSTD_CCtxP:

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T30[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$31[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 433  :     if (ZSTD_isError(bounds.error)) return bounds.error;

	ja	$LN20@ZSTD_CCtxP

; 434  :     if (*value < bounds.lowerBound) *value = bounds.lowerBound;

	mov	rax, QWORD PTR bounds$31[rbp-40]
	cmp	r10d, eax
	cmovl	r10d, eax

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	shr	rax, 32					; 00000020H
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	r10d, eax
	cmovle	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 544  :         if (value) {  /* 0 : does not change current level */

	test	eax, eax
	je	SHORT $LN450@ZSTD_CCtxP

; 545  :             CCtxParams->compressionLevel = value;

	mov	DWORD PTR [r11+44], eax
	jmp	SHORT $LN28@ZSTD_CCtxP
$LN450@ZSTD_CCtxP:
	mov	eax, DWORD PTR [r11+44]
$LN28@ZSTD_CCtxP:

; 546  :         }
; 547  :         if (CCtxParams->compressionLevel >= 0) return (size_t)CCtxParams->compressionLevel;

	test	eax, eax
	jns	$LN467@ZSTD_CCtxP

; 548  :         return 0;  /* return type (size_t) cannot represent negative values */

	xor	eax, eax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN30@ZSTD_CCtxP:

; 549  :     }
; 550  : 
; 551  :     case ZSTD_c_windowLog :
; 552  :         if (value!=0)   /* 0 => use default */

	test	r10d, r10d
	je	SHORT $LN32@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 101				; 00000065H
	lea	rcx, QWORD PTR $T28[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$29[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$29[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN32@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 554  :         CCtxParams->cParams.windowLog = (U32)value;

	mov	DWORD PTR [r11+4], r10d

; 555  :         return CCtxParams->cParams.windowLog;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN34@ZSTD_CCtxP:

; 556  : 
; 557  :     case ZSTD_c_hashLog :
; 558  :         if (value!=0)   /* 0 => use default */

	test	r10d, r10d
	je	SHORT $LN36@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 102				; 00000066H
	lea	rcx, QWORD PTR $T26[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$27[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$27[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN36@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 560  :         CCtxParams->cParams.hashLog = (U32)value;

	mov	DWORD PTR [r11+12], r10d

; 561  :         return CCtxParams->cParams.hashLog;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN38@ZSTD_CCtxP:

; 562  : 
; 563  :     case ZSTD_c_chainLog :
; 564  :         if (value!=0)   /* 0 => use default */

	test	r10d, r10d
	je	SHORT $LN40@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 103				; 00000067H
	lea	rcx, QWORD PTR $T24[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$25[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$25[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN40@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 566  :         CCtxParams->cParams.chainLog = (U32)value;

	mov	DWORD PTR [r11+8], r10d

; 567  :         return CCtxParams->cParams.chainLog;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN42@ZSTD_CCtxP:

; 568  : 
; 569  :     case ZSTD_c_searchLog :
; 570  :         if (value!=0)   /* 0 => use default */

	test	r10d, r10d
	je	SHORT $LN44@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 104				; 00000068H
	lea	rcx, QWORD PTR $T22[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$23[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$23[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN44@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 572  :         CCtxParams->cParams.searchLog = (U32)value;

	mov	DWORD PTR [r11+16], r10d

; 573  :         return (size_t)value;

	mov	rax, r10

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN46@ZSTD_CCtxP:

; 574  : 
; 575  :     case ZSTD_c_minMatch :
; 576  :         if (value!=0)   /* 0 => use default */

	test	r10d, r10d
	je	SHORT $LN48@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 105				; 00000069H
	lea	rcx, QWORD PTR $T20[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$21[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$21[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN48@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 578  :         CCtxParams->cParams.minMatch = value;

	mov	DWORD PTR [r11+20], r10d

; 579  :         return CCtxParams->cParams.minMatch;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN50@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 106				; 0000006aH
	lea	rcx, QWORD PTR $T18[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$19[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$19[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 584  :         return CCtxParams->cParams.targetLength;

	mov	DWORD PTR [r11+24], r10d
	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN53@ZSTD_CCtxP:

; 585  : 
; 586  :     case ZSTD_c_strategy :
; 587  :         if (value!=0)   /* 0 => use default */

	test	r10d, r10d
	je	SHORT $LN55@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 107				; 0000006bH
	lea	rcx, QWORD PTR $T16[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$17[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$17[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN55@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 589  :         CCtxParams->cParams.strategy = (ZSTD_strategy)value;

	mov	DWORD PTR [r11+28], r10d

; 590  :         return (size_t)CCtxParams->cParams.strategy;

	mov	rax, r10

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN57@ZSTD_CCtxP:

; 591  : 
; 592  :     case ZSTD_c_contentSizeFlag :
; 593  :         /* Content size written in frame header _when known_ (default:1) */
; 594  :         DEBUGLOG(4, "set content size flag = %u", (value!=0));
; 595  :         CCtxParams->fParams.contentSizeFlag = value != 0;

	xor	edx, edx
	test	r10d, r10d
	setne	dl
	mov	eax, edx
	mov	DWORD PTR [r11+32], eax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN58@ZSTD_CCtxP:

; 596  :         return CCtxParams->fParams.contentSizeFlag;
; 597  : 
; 598  :     case ZSTD_c_checksumFlag :
; 599  :         /* A 32-bits content checksum will be calculated and written at end of frame (default:0) */
; 600  :         CCtxParams->fParams.checksumFlag = value != 0;

	xor	edx, edx
	test	r10d, r10d
	setne	dl
	mov	eax, edx
	mov	DWORD PTR [r11+36], eax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN59@ZSTD_CCtxP:

; 601  :         return CCtxParams->fParams.checksumFlag;
; 602  : 
; 603  :     case ZSTD_c_dictIDFlag : /* When applicable, dictionary's dictID is provided in frame header (default:1) */
; 604  :         DEBUGLOG(4, "set dictIDFlag = %u", (value!=0));
; 605  :         CCtxParams->fParams.noDictIDFlag = !value;

	xor	edx, edx
	mov	ecx, edx
	test	r10d, r10d
	sete	cl

; 606  :         return !CCtxParams->fParams.noDictIDFlag;

	test	r10d, r10d
	mov	DWORD PTR [r11+40], ecx
	setne	dl
	mov	rax, rdx

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN80@ZSTD_CCtxP:

; 668  : #endif
; 669  : 
; 670  :     case ZSTD_c_enableLongDistanceMatching :
; 671  :         CCtxParams->ldmParams.enableLdm = (value!=0);

	xor	edx, edx
	test	r10d, r10d
	setne	dl
	mov	eax, edx
	mov	DWORD PTR [r11+96], eax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN81@ZSTD_CCtxP:

; 672  :         return CCtxParams->ldmParams.enableLdm;
; 673  : 
; 674  :     case ZSTD_c_ldmHashLog :
; 675  :         if (value!=0)   /* 0 ==> auto */

	test	r10d, r10d
	je	SHORT $LN83@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 161				; 000000a1H
	lea	rcx, QWORD PTR $T7[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$32[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$32[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN83@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 677  :         CCtxParams->ldmParams.hashLog = value;

	mov	DWORD PTR [r11+100], r10d

; 678  :         return CCtxParams->ldmParams.hashLog;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN85@ZSTD_CCtxP:

; 679  : 
; 680  :     case ZSTD_c_ldmMinMatch :
; 681  :         if (value!=0)   /* 0 ==> default */

	test	r10d, r10d
	je	SHORT $LN87@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 162				; 000000a2H
	lea	rcx, QWORD PTR $T5[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$6[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$6[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN87@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 683  :         CCtxParams->ldmParams.minMatchLength = value;

	mov	DWORD PTR [r11+108], r10d

; 684  :         return CCtxParams->ldmParams.minMatchLength;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN89@ZSTD_CCtxP:

; 685  : 
; 686  :     case ZSTD_c_ldmBucketSizeLog :
; 687  :         if (value!=0)   /* 0 ==> default */

	test	r10d, r10d
	je	SHORT $LN91@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 163				; 000000a3H
	lea	rcx, QWORD PTR $T3[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$4[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN464@ZSTD_CCtxP

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$4[rbp-40]
	cmp	r10d, eax
	jl	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
$LN91@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 689  :         CCtxParams->ldmParams.bucketSizeLog = value;

	mov	DWORD PTR [r11+104], r10d

; 690  :         return CCtxParams->ldmParams.bucketSizeLog;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN93@ZSTD_CCtxP:

; 691  : 
; 692  :     case ZSTD_c_ldmHashRateLog :
; 693  :         RETURN_ERROR_IF(value > ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN,

	cmp	r10d, 25
	jg	$LN464@ZSTD_CCtxP

; 694  :                         parameter_outOfBound, "Param out of bounds!");
; 695  :         CCtxParams->ldmParams.hashRateLog = value;

	mov	DWORD PTR [r11+112], r10d

; 696  :         return CCtxParams->ldmParams.hashRateLog;

	mov	eax, r10d

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN9@ZSTD_CCtxP:

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 400				; 00000190H
	lea	rcx, QWORD PTR $T12[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$13[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 433  :     if (ZSTD_isError(bounds.error)) return bounds.error;

	ja	$LN20@ZSTD_CCtxP

; 434  :     if (*value < bounds.lowerBound) *value = bounds.lowerBound;

	mov	rax, QWORD PTR bounds$13[rbp-40]
	cmp	r10d, eax
	cmovl	r10d, eax

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	shr	rax, 32					; 00000020H
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	r10d, eax
	cmovle	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 632  :         CCtxParams->nbWorkers = value;

	mov	DWORD PTR [r11+76], eax
$LN467@ZSTD_CCtxP:

; 711  :     }
; 712  : }

	cdqe
	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN107@ZSTD_CCtxP:

; 534  :     DEBUGLOG(4, "ZSTD_CCtxParams_setParameter (%i, %i)", (int)param, value);
; 535  :     switch(param)

	cmp	edx, 1001				; 000003e9H
	jg	$LN108@ZSTD_CCtxP
	je	$LN61@ZSTD_CCtxP
	sub	edx, 401				; 00000191H
	je	SHORT $LN70@ZSTD_CCtxP
	sub	edx, 1
	je	SHORT $LN15@ZSTD_CCtxP
	sub	edx, 98					; 00000062H
	je	SHORT $LN18@ZSTD_CCtxP
	cmp	edx, 500				; 000001f4H
	jne	$LN21@ZSTD_CCtxP

; 607  : 
; 608  :     case ZSTD_c_forceMaxWindow :
; 609  :         CCtxParams->forceWindow = (value != 0);

	xor	edx, edx
	test	r8d, r8d
	setne	dl
	mov	eax, edx
	mov	DWORD PTR [rcx+48], eax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN18@ZSTD_CCtxP:

; 349  :         bounds.lowerBound = ZSTD_OVERLAPLOG_MIN;

	xor	edx, edx

; 350  :         bounds.upperBound = ZSTD_OVERLAPLOG_MAX;

	mov	DWORD PTR $T8[rbp-36], 9

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	test	r8d, r8d

; 349  :         bounds.lowerBound = ZSTD_OVERLAPLOG_MIN;

	mov	DWORD PTR $T8[rbp-40], edx

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	rax, QWORD PTR $T8[rbp-40]
	cmovns	edx, r10d
	shr	rax, 32					; 00000020H

; 658  : #endif
; 659  : 
; 660  :     case ZSTD_c_rsyncable :
; 661  : #ifndef ZSTD_MULTITHREAD
; 662  :         RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
; 663  :         return 0;
; 664  : #else
; 665  :         FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(ZSTD_c_overlapLog, &value), "");
; 666  :         CCtxParams->rsyncable = value;

	cmp	edx, eax
	cmovle	eax, edx
	mov	DWORD PTR [rcx+92], eax

; 667  :         return CCtxParams->rsyncable;

	cdqe

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN15@ZSTD_CCtxP:

; 349  :         bounds.lowerBound = ZSTD_OVERLAPLOG_MIN;

	xor	edx, edx

; 350  :         bounds.upperBound = ZSTD_OVERLAPLOG_MAX;

	mov	DWORD PTR $T9[rbp-36], 9

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	test	r8d, r8d

; 349  :         bounds.lowerBound = ZSTD_OVERLAPLOG_MIN;

	mov	DWORD PTR $T9[rbp-40], edx

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	rax, QWORD PTR $T9[rbp-40]
	cmovns	edx, r10d
	shr	rax, 32					; 00000020H

; 647  :         return CCtxParams->jobSize;
; 648  : #endif
; 649  : 
; 650  :     case ZSTD_c_overlapLog :
; 651  : #ifndef ZSTD_MULTITHREAD
; 652  :         RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
; 653  :         return 0;
; 654  : #else
; 655  :         FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(ZSTD_c_overlapLog, &value), "");
; 656  :         CCtxParams->overlapLog = value;

	cmp	edx, eax
	cmovle	eax, edx
	mov	DWORD PTR [rcx+88], eax

; 657  :         return CCtxParams->overlapLog;

	cdqe

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN70@ZSTD_CCtxP:

; 633  :         return CCtxParams->nbWorkers;
; 634  : #endif
; 635  : 
; 636  :     case ZSTD_c_jobSize :
; 637  : #ifndef ZSTD_MULTITHREAD
; 638  :         RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
; 639  :         return 0;
; 640  : #else
; 641  :         /* Adjust to the minimum non-default value. */
; 642  :         if (value != 0 && value < ZSTDMT_JOBSIZE_MIN)

	test	r8d, r8d
	je	SHORT $LN12@ZSTD_CCtxP
	mov	eax, 1048576				; 00100000H
	cmp	r10d, eax
	cmovl	r10d, eax
$LN12@ZSTD_CCtxP:

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	mov	edx, 401				; 00000191H
	lea	rcx, QWORD PTR $T10[rbp-48]
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 432  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$11[rbp-48], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 433  :     if (ZSTD_isError(bounds.error)) return bounds.error;

	ja	$LN20@ZSTD_CCtxP

; 434  :     if (*value < bounds.lowerBound) *value = bounds.lowerBound;

	mov	rax, QWORD PTR bounds$11[rbp-40]
	cmp	r10d, eax
	cmovl	r10d, eax

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	shr	rax, 32					; 00000020H
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	r10d, eax
	cmovle	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 646  :         CCtxParams->jobSize = value;

	cdqe
	mov	QWORD PTR [r11+80], rax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN61@ZSTD_CCtxP:

; 401  :         bounds.lowerBound = ZSTD_dictDefaultAttach;

	xor	edx, edx

; 402  :         bounds.upperBound = ZSTD_dictForceLoad;       /* note : how to ensure at compile time that this is the highest value enum ? */

	mov	DWORD PTR $T15[rbp-36], 3
	mov	DWORD PTR $T15[rbp-40], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 361  :     if (value < bounds.lowerBound) return 0;

	test	r8d, r8d
	js	$LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T15[rbp-40]
	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN464@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 616  :         return CCtxParams->attachDictPref;

	mov	DWORD PTR [rcx+68], r10d
	mov	rax, r10

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN108@ZSTD_CCtxP:

; 534  :     DEBUGLOG(4, "ZSTD_CCtxParams_setParameter (%i, %i)", (int)param, value);
; 535  :     switch(param)

	sub	edx, 1002				; 000003eaH
	je	SHORT $LN64@ZSTD_CCtxP
	sub	edx, 1
	je	SHORT $LN96@ZSTD_CCtxP
	cmp	edx, 1
	je	SHORT $LN100@ZSTD_CCtxP
$LN21@ZSTD_CCtxP:

; 709  : 
; 710  :     default: RETURN_ERROR(parameter_unsupported, "unknown parameter");

	mov	rax, -40				; ffffffffffffffd8H

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN100@ZSTD_CCtxP:

; 702  :         return CCtxParams->targetCBlockSize;
; 703  : 
; 704  :     case ZSTD_c_srcSizeHint :
; 705  :         if (value!=0)    /* 0 ==> default */

	test	r8d, r8d
	je	SHORT $LN102@ZSTD_CCtxP

; 417  :         bounds.lowerBound = ZSTD_SRCSIZEHINT_MIN;

	xor	edx, edx

; 418  :         bounds.upperBound = ZSTD_SRCSIZEHINT_MAX;

	mov	DWORD PTR $T1[rbp-36], 2147483647	; 7fffffffH
	mov	DWORD PTR $T1[rbp-40], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 361  :     if (value < bounds.lowerBound) return 0;

	test	r8d, r8d
	js	SHORT $LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T1[rbp-40]
	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	SHORT $LN464@ZSTD_CCtxP
$LN102@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 707  :         CCtxParams->srcSizeHint = value;

	mov	DWORD PTR [rcx+64], r10d

; 708  :         return CCtxParams->srcSizeHint;

	mov	rax, r10

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN96@ZSTD_CCtxP:

; 697  : 
; 698  :     case ZSTD_c_targetCBlockSize :
; 699  :         if (value!=0)   /* 0 ==> default */

	test	r8d, r8d
	je	SHORT $LN98@ZSTD_CCtxP

; 412  :         bounds.lowerBound = ZSTD_TARGETCBLOCKSIZE_MIN;

	mov	DWORD PTR $T2[rbp-40], 64		; 00000040H

; 413  :         bounds.upperBound = ZSTD_TARGETCBLOCKSIZE_MAX;

	mov	DWORD PTR $T2[rbp-36], 131072		; 00020000H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 361  :     if (value < bounds.lowerBound) return 0;

	cmp	r10d, 64				; 00000040H
	jl	SHORT $LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T2[rbp-40]
	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	SHORT $LN464@ZSTD_CCtxP
$LN98@ZSTD_CCtxP:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 701  :         CCtxParams->targetCBlockSize = value;

	mov	rax, r10
	mov	QWORD PTR [rcx+56], rax

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN64@ZSTD_CCtxP:

; 407  :         bounds.lowerBound = ZSTD_lcm_auto;

	xor	edx, edx

; 408  :         bounds.upperBound = ZSTD_lcm_uncompressed;

	mov	DWORD PTR $T14[rbp-36], 2
	mov	DWORD PTR $T14[rbp-40], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 361  :     if (value < bounds.lowerBound) return 0;

	test	r8d, r8d
	js	SHORT $LN464@ZSTD_CCtxP

; 362  :     if (value > bounds.upperBound) return 0;

	mov	rax, QWORD PTR $T14[rbp-40]
	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	SHORT $LN464@ZSTD_CCtxP
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 623  :         return CCtxParams->literalCompressionMode;

	mov	DWORD PTR [rcx+72], r10d
	mov	rax, r10

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN464@ZSTD_CCtxP:

; 617  :     }
; 618  : 
; 619  :     case ZSTD_c_literalCompressionMode : {
; 620  :         const ZSTD_literalCompressionMode_e lcm = (ZSTD_literalCompressionMode_e)value;
; 621  :         BOUNDCHECK(ZSTD_c_literalCompressionMode, lcm);

	mov	rax, -42				; ffffffffffffffd6H
$LN20@ZSTD_CCtxP:

; 711  :     }
; 712  : }

	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
$LN466@ZSTD_CCtxP:
	DD	$LN22@ZSTD_CCtxP
	DD	$LN6@ZSTD_CCtxP
	DD	$LN30@ZSTD_CCtxP
	DD	$LN34@ZSTD_CCtxP
	DD	$LN38@ZSTD_CCtxP
	DD	$LN42@ZSTD_CCtxP
	DD	$LN46@ZSTD_CCtxP
	DD	$LN50@ZSTD_CCtxP
	DD	$LN53@ZSTD_CCtxP
	DD	$LN80@ZSTD_CCtxP
	DD	$LN81@ZSTD_CCtxP
	DD	$LN85@ZSTD_CCtxP
	DD	$LN89@ZSTD_CCtxP
	DD	$LN93@ZSTD_CCtxP
	DD	$LN57@ZSTD_CCtxP
	DD	$LN58@ZSTD_CCtxP
	DD	$LN59@ZSTD_CCtxP
	DD	$LN21@ZSTD_CCtxP
$LN465@ZSTD_CCtxP:
	DB	0
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	17
	DB	14
	DB	15
	DB	16
ZSTD_CCtxParams_setParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 8
pledgedSrcSize$ = 16
ZSTD_CCtx_setPledgedSrcSize PROC

; 846  :     DEBUGLOG(4, "ZSTD_CCtx_setPledgedSrcSize to %u bytes", (U32)pledgedSrcSize);
; 847  :     RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,

	cmp	DWORD PTR [rcx+1072], 0
	je	SHORT $LN2@ZSTD_CCtx_
	mov	rax, -60				; ffffffffffffffc4H

; 851  : }

	ret	0
$LN2@ZSTD_CCtx_:

; 848  :                     "Can't set pledgedSrcSize when not in init stage.");
; 849  :     cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx+384], rax

; 850  :     return 0;

	xor	eax, eax

; 851  : }

	ret	0
ZSTD_CCtx_setPledgedSrcSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 80
$T3 = 112
cctx$ = 160
ZSTD_initLocalDict PROC

; 859  : {

	push	rbx
	sub	rsp, 144				; 00000090H

; 860  :     ZSTD_localDict* const dl = &cctx->localDict;
; 861  :     ZSTD_compressionParameters const cParams = ZSTD_getCParamsFromCCtxParams(

	mov	r9, QWORD PTR [rcx+1096]
	lea	rdx, QWORD PTR [rcx+16]
	mov	rbx, rcx
	mov	r8, -1
	lea	rcx, QWORD PTR $T3[rsp]
	call	ZSTD_getCParamsFromCCtxParams

; 862  :             &cctx->requestedParams, ZSTD_CONTENTSIZE_UNKNOWN, dl->dictSize);
; 863  :     if (dl->dict == NULL) {

	mov	rcx, QWORD PTR [rbx+1088]
	test	rcx, rcx
	je	$LN7@ZSTD_initL

; 864  :         /* No local dictionary. */
; 865  :         assert(dl->dictBuffer == NULL);
; 866  :         assert(dl->cdict == NULL);
; 867  :         assert(dl->dictSize == 0);
; 868  :         return 0;
; 869  :     }
; 870  :     if (dl->cdict != NULL) {

	cmp	QWORD PTR [rbx+1112], 0
	jne	$LN7@ZSTD_initL

; 871  :         assert(cctx->cdict == dl->cdict);
; 872  :         /* Local dictionary already initialized. */
; 873  :         return 0;
; 874  :     }
; 875  :     assert(dl->dictSize > 0);
; 876  :     assert(cctx->cdict == NULL);
; 877  :     assert(cctx->prefixDict.dict == NULL);
; 878  : 
; 879  :     dl->cdict = ZSTD_createCDict_advanced(

	movups	xmm0, XMMWORD PTR [rbx+496]
	mov	r8d, 1
	mov	r9d, DWORD PTR [rbx+1104]
	movsd	xmm1, QWORD PTR [rbx+512]
	mov	rdx, QWORD PTR [rbx+1096]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rax]
	movsd	QWORD PTR $T1[rsp+16], xmm1
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR $T2[rsp+24], eax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1
	call	ZSTD_createCDict_advanced
	mov	QWORD PTR [rbx+1112], rax

; 880  :             dl->dict,
; 881  :             dl->dictSize,
; 882  :             ZSTD_dlm_byRef,
; 883  :             dl->dictContentType,
; 884  :             cParams,
; 885  :             cctx->customMem);
; 886  :     RETURN_ERROR_IF(!dl->cdict, memory_allocation, "ZSTD_createCDict_advanced failed");

	test	rax, rax
	jne	SHORT $LN4@ZSTD_initL
	mov	rax, -64				; ffffffffffffffc0H

; 888  :     return 0;
; 889  : }

	add	rsp, 144				; 00000090H
	pop	rbx
	ret	0
$LN4@ZSTD_initL:

; 887  :     cctx->cdict = dl->cdict;

	mov	QWORD PTR [rbx+1120], rax
$LN7@ZSTD_initL:

; 888  :     return 0;
; 889  : }

	xor	eax, eax
	add	rsp, 144				; 00000090H
	pop	rbx
	ret	0
ZSTD_initLocalDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
cctx$ = 80
dict$ = 88
dictSize$ = 96
dictLoadMethod$dead$ = 104
dictContentType$dead$ = 112
ZSTD_CCtx_loadDictionary_advanced PROC

; 894  : {

$LN20:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 64					; 00000040H

; 895  :     RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,

	cmp	DWORD PTR [rcx+1072], 0
	mov	rsi, r8
	mov	rbp, rdx
	mov	rbx, rcx
	je	SHORT $LN2@ZSTD_CCtx_
	mov	rax, -60				; ffffffffffffffc4H

; 915  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
$LN2@ZSTD_CCtx_:

; 896  :                     "Can't load a dictionary when ctx is not in init stage.");
; 897  :     RETURN_ERROR_IF(cctx->staticSize, memory_allocation,

	cmp	QWORD PTR [rcx+520], 0
	mov	QWORD PTR [rsp+80], rdi
	jne	SHORT $LN16@ZSTD_CCtx_

; 898  :                     "no malloc for static CCtx");
; 899  :     DEBUGLOG(4, "ZSTD_CCtx_loadDictionary_advanced (size: %u)", (U32)dictSize);
; 900  :     ZSTD_clearAllDicts(cctx);  /* in case one already exists */

	call	ZSTD_clearAllDicts

; 901  :     if (dict == NULL || dictSize == 0)  /* no dictionary mode */

	test	rbp, rbp
	je	SHORT $LN7@ZSTD_CCtx_
	test	rsi, rsi
	je	SHORT $LN7@ZSTD_CCtx_
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx+496]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 906  :         void* dictBuffer = ZSTD_malloc(dictSize, cctx->customMem);

	movsd	xmm0, QWORD PTR [rbx+512]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN14@ZSTD_CCtx_

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rsi
	call	rax
	jmp	SHORT $LN18@ZSTD_CCtx_
$LN14@ZSTD_CCtx_:

; 60   :     return malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
$LN18@ZSTD_CCtx_:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 907  :         RETURN_ERROR_IF(!dictBuffer, memory_allocation, "NULL pointer!");

	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN16@ZSTD_CCtx_

; 908  :         memcpy(dictBuffer, dict, dictSize);

	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, rax
	call	memcpy

; 909  :         cctx->localDict.dictBuffer = dictBuffer;

	mov	QWORD PTR [rbx+1080], rdi

; 910  :         cctx->localDict.dict = dictBuffer;
; 911  :     }
; 912  :     cctx->localDict.dictSize = dictSize;

	mov	QWORD PTR [rbx+1088], rdi
	mov	QWORD PTR [rbx+1096], rsi

; 913  :     cctx->localDict.dictContentType = dictContentType;

	mov	DWORD PTR [rbx+1104], 0
$LN7@ZSTD_CCtx_:

; 914  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN17@ZSTD_CCtx_
$LN16@ZSTD_CCtx_:

; 907  :         RETURN_ERROR_IF(!dictBuffer, memory_allocation, "NULL pointer!");

	mov	rax, -64				; ffffffffffffffc0H
$LN17@ZSTD_CCtx_:
	mov	rdi, QWORD PTR [rsp+80]

; 915  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
ZSTD_CCtx_loadDictionary_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 64
dict$ = 72
dictSize$ = 80
ZSTD_CCtx_loadDictionary PROC

; 925  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 926  :     return ZSTD_CCtx_loadDictionary_advanced(

	call	ZSTD_CCtx_loadDictionary_advanced

; 927  :             cctx, dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto);
; 928  : }

	add	rsp, 56					; 00000038H
	ret	0
ZSTD_CCtx_loadDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 48
cdict$ = 56
ZSTD_CCtx_refCDict PROC

; 932  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 933  :     RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,

	cmp	DWORD PTR [rcx+1072], 0
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN2@ZSTD_CCtx_
	mov	rax, -60				; ffffffffffffffc4H

; 939  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@ZSTD_CCtx_:

; 934  :                     "Can't ref a dict when ctx not in init stage.");
; 935  :     /* Free the existing local cdict (if any) to save memory. */
; 936  :     ZSTD_clearAllDicts(cctx);

	call	ZSTD_clearAllDicts

; 937  :     cctx->cdict = cdict;

	mov	QWORD PTR [rbx+1120], rdi

; 938  :     return 0;

	xor	eax, eax

; 939  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_CCtx_refCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 48
reset$ = 56
ZSTD_CCtx_reset PROC

; 963  : {

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 964  :     if ( (reset == ZSTD_reset_session_only)
; 965  :       || (reset == ZSTD_reset_session_and_parameters) ) {

	cmp	edx, 1
	jne	SHORT $LN2@ZSTD_CCtx_

; 966  :         cctx->streamStage = zcss_init;

	xor	eax, eax
	mov	DWORD PTR [rcx+1072], eax

; 967  :         cctx->pledgedSrcSizePlusOne = 0;

	mov	QWORD PTR [rcx+384], rax

; 975  :     }
; 976  :     return 0;
; 977  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@ZSTD_CCtx_:

; 968  :     }
; 969  :     if ( (reset == ZSTD_reset_parameters)
; 970  :       || (reset == ZSTD_reset_session_and_parameters) ) {

	cmp	edx, 2
	jne	SHORT $LN15@ZSTD_CCtx_

; 971  :         RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,

	cmp	DWORD PTR [rcx+1072], 0
	je	SHORT $LN6@ZSTD_CCtx_
	mov	rax, -60				; ffffffffffffffc4H

; 975  :     }
; 976  :     return 0;
; 977  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@ZSTD_CCtx_:

; 972  :                         "Can't reset parameters only when not in init stage.");
; 973  :         ZSTD_clearAllDicts(cctx);

	call	ZSTD_clearAllDicts

; 974  :         return ZSTD_CCtxParams_reset(&cctx->requestedParams);

	lea	rax, QWORD PTR [rbx+16]

; 236  :     RETURN_ERROR_IF(!cctxParams, GENERIC, "NULL pointer!");

	test	rax, rax
	jne	SHORT $LN12@ZSTD_CCtx_
	mov	rax, -1

; 975  :     }
; 976  :     return 0;
; 977  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@ZSTD_CCtx_:
	xorps	xmm0, xmm0

; 237  :     memset(cctxParams, 0, sizeof(*cctxParams));

	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
	movups	XMMWORD PTR [rax+96], xmm0
	movups	XMMWORD PTR [rax+112], xmm0
	movups	XMMWORD PTR [rax+128], xmm0

; 238  :     cctxParams->compressionLevel = compressionLevel;

	mov	DWORD PTR [rax+44], 3

; 239  :     cctxParams->fParams.contentSizeFlag = 1;

	mov	DWORD PTR [rax+32], 1
$LN15@ZSTD_CCtx_:

; 975  :     }
; 976  :     return 0;
; 977  : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_CCtx_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
bounds$2 = 32
$T3 = 32
bounds$4 = 32
$T5 = 32
bounds$6 = 32
$T7 = 32
bounds$8 = 32
$T9 = 32
bounds$10 = 32
$T11 = 32
bounds$12 = 32
$T13 = 32
bounds$14 = 32
cParams$ = 64
ZSTD_checkCParams PROC

; 984  : {

$LN74:
	sub	rsp, 56					; 00000038H

; 985  :     BOUNDCHECK(ZSTD_c_windowLog, (int)cParams.windowLog);

	mov	r10d, DWORD PTR [rcx]
	mov	r9, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T13[rsp]
	mov	edx, 101				; 00000065H
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$14[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$14[rsp+8]
	cmp	r10d, eax
	jl	$LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 986  :     BOUNDCHECK(ZSTD_c_chainLog,  (int)cParams.chainLog);

	mov	r10d, DWORD PTR [r9+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T11[rsp]
	mov	edx, 103				; 00000067H
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$12[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$12[rsp+8]
	cmp	r10d, eax
	jl	$LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 987  :     BOUNDCHECK(ZSTD_c_hashLog,   (int)cParams.hashLog);

	mov	r10d, DWORD PTR [r9+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T9[rsp]
	mov	edx, 102				; 00000066H
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$10[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$10[rsp+8]
	cmp	r10d, eax
	jl	$LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 988  :     BOUNDCHECK(ZSTD_c_searchLog, (int)cParams.searchLog);

	mov	r10d, DWORD PTR [r9+12]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T7[rsp]
	mov	edx, 104				; 00000068H
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$8[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$8[rsp+8]
	cmp	r10d, eax
	jl	$LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	$LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 989  :     BOUNDCHECK(ZSTD_c_minMatch,  (int)cParams.minMatch);

	mov	r10d, DWORD PTR [r9+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T5[rsp]
	mov	edx, 105				; 00000069H
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$6[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	$LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$6[rsp+8]
	cmp	r10d, eax
	jl	$LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	SHORT $LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 990  :     BOUNDCHECK(ZSTD_c_targetLength,(int)cParams.targetLength);

	mov	r10d, DWORD PTR [r9+20]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T3[rsp]
	mov	edx, 106				; 0000006aH
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$4[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	SHORT $LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$4[rsp+8]
	cmp	r10d, eax
	jl	SHORT $LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	SHORT $LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 991  :     BOUNDCHECK(ZSTD_c_strategy,  cParams.strategy);

	mov	r10d, DWORD PTR [r9+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	lea	rcx, QWORD PTR $T1[rsp]
	mov	edx, 107				; 0000006bH
	call	ZSTD_cParam_getBounds
	movups	xmm0, XMMWORD PTR [rax]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	movq	rax, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 359  :     ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);

	movups	XMMWORD PTR bounds$2[rsp], xmm0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 360  :     if (ZSTD_isError(bounds.error)) return 0;

	ja	SHORT $LN72@ZSTD_check

; 361  :     if (value < bounds.lowerBound) return 0;

	mov	rax, QWORD PTR bounds$2[rsp+8]
	cmp	r10d, eax
	jl	SHORT $LN72@ZSTD_check

; 362  :     if (value > bounds.upperBound) return 0;

	shr	rax, 32					; 00000020H
	cmp	r10d, eax
	jg	SHORT $LN72@ZSTD_check
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 992  :     return 0;

	xor	eax, eax

; 993  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN72@ZSTD_check:

; 991  :     BOUNDCHECK(ZSTD_c_strategy,  cParams.strategy);

	mov	rax, -42				; ffffffffffffffd6H

; 993  : }

	add	rsp, 56					; 00000038H
	ret	0
ZSTD_checkCParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
hashLog$ = 8
strat$ = 16
ZSTD_cycleLog PROC

; 1021 :     U32 const btScale = ((U32)strat >= (U32)ZSTD_btlazy2);

	xor	eax, eax
	cmp	edx, 6
	setae	al

; 1022 :     return hashLog - btScale;

	sub	ecx, eax
	mov	eax, ecx

; 1023 : }

	ret	0
ZSTD_cycleLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 8
cPar$ = 16
srcSize$ = 24
dictSize$ = 32
ZSTD_adjustCParams_internal PROC

; 1036 :     static const U64 minSrcSize = 513; /* (1<<9) + 1 */
; 1037 :     static const U64 maxWindowResize = 1ULL << (ZSTD_WINDOWLOG_MAX-1);
; 1038 :     assert(ZSTD_checkCParams(cPar)==0);
; 1039 : 
; 1040 :     if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)

	xor	r10d, r10d
	mov	r11, rcx
	test	r9, r9
	je	SHORT $LN2@ZSTD_adjus
	cmp	r8, -1
	jne	SHORT $LN2@ZSTD_adjus

; 1041 :         srcSize = minSrcSize;

	mov	r8d, 513				; 00000201H

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	jmp	SHORT $LN15@ZSTD_adjus
$LN2@ZSTD_adjus:
	cmp	r8, 1073741824				; 40000000H
	jae	SHORT $LN4@ZSTD_adjus
$LN15@ZSTD_adjus:
	cmp	r9, 1073741824				; 40000000H
	jae	SHORT $LN4@ZSTD_adjus

; 1046 :         U32 const tSize = (U32)(srcSize + dictSize);

	lea	eax, DWORD PTR [r9+r8]

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	cmp	eax, 64					; 00000040H
	jae	SHORT $LN9@ZSTD_adjus
	mov	eax, 6
	jmp	SHORT $LN10@ZSTD_adjus
$LN9@ZSTD_adjus:
	dec	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	inc	eax
$LN10@ZSTD_adjus:

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	cmp	DWORD PTR [rdx], eax
	jbe	SHORT $LN4@ZSTD_adjus
	mov	DWORD PTR [rdx], eax
$LN4@ZSTD_adjus:

; 1051 :     }
; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	ecx, DWORD PTR [rdx]
	lea	eax, DWORD PTR [rcx+1]
	cmp	DWORD PTR [rdx+8], eax
	jbe	SHORT $LN5@ZSTD_adjus
	mov	DWORD PTR [rdx+8], eax
$LN5@ZSTD_adjus:

; 1021 :     U32 const btScale = ((U32)strat >= (U32)ZSTD_btlazy2);

	cmp	DWORD PTR [rdx+24], 6

; 1022 :     return hashLog - btScale;

	mov	eax, DWORD PTR [rdx+4]
	setae	r10b
	sub	eax, r10d

; 1053 :     {   U32 const cycleLog = ZSTD_cycleLog(cPar.chainLog, cPar.strategy);
; 1054 :         if (cycleLog > cPar.windowLog)

	cmp	eax, ecx
	jbe	SHORT $LN6@ZSTD_adjus

; 1055 :             cPar.chainLog -= (cycleLog - cPar.windowLog);

	lea	eax, DWORD PTR [r10+rcx]
	mov	DWORD PTR [rdx+4], eax
$LN6@ZSTD_adjus:

; 1056 :     }
; 1057 : 
; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmp	ecx, 10
	jae	SHORT $LN7@ZSTD_adjus

; 1059 :         cPar.windowLog = ZSTD_WINDOWLOG_ABSOLUTEMIN;  /* minimum wlog required for valid frame header */

	mov	DWORD PTR [rdx], 10
$LN7@ZSTD_adjus:

; 1060 : 
; 1061 :     return cPar;

	mov	eax, DWORD PTR [rdx+24]
	movaps	xmm0, XMMWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [rdx+16]
	movups	XMMWORD PTR [r11], xmm0
	movsd	QWORD PTR [r11+16], xmm1
	mov	DWORD PTR [r11+24], eax
	mov	rax, r11

; 1062 : }

	ret	0
ZSTD_adjustCParams_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cParams$ = 32
$T1 = 64
$T2 = 64
$T3 = 128
CCtxParams$ = 136
srcSizeHint$ = 144
dictSize$ = 152
ZSTD_getCParamsFromCCtxParams PROC

; 1079 : {

$LN29:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r14
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
	mov	rsi, r9
	mov	rbx, r8
	mov	r14, rdx
	mov	rdi, rcx

; 1080 :     ZSTD_compressionParameters cParams;
; 1081 :     if (srcSizeHint == ZSTD_CONTENTSIZE_UNKNOWN && CCtxParams->srcSizeHint > 0) {

	cmp	r8, -1
	jne	SHORT $LN2@ZSTD_getCP
	movsxd	rax, DWORD PTR [rdx+64]
	test	eax, eax
	jle	SHORT $LN2@ZSTD_getCP

; 1082 :       srcSizeHint = CCtxParams->srcSizeHint;

	mov	rbx, rax
$LN2@ZSTD_getCP:

; 1083 :     }
; 1084 :     cParams = ZSTD_getCParams_internal(CCtxParams->compressionLevel, srcSizeHint, dictSize);

	mov	edx, DWORD PTR [rdx+44]
	lea	rcx, QWORD PTR $T2[rbp-96]
	mov	r8, rbx
	call	ZSTD_getCParams_internal

; 1085 :     if (CCtxParams->ldmParams.enableLdm) cParams.windowLog = ZSTD_LDM_DEFAULT_WINDOW_LOG;

	cmp	DWORD PTR [r14+96], 0

; 1086 :     if (CCtxParams->cParams.windowLog) cParams.windowLog = CCtxParams->cParams.windowLog;
; 1087 :     if (CCtxParams->cParams.hashLog) cParams.hashLog = CCtxParams->cParams.hashLog;

	mov	ecx, DWORD PTR [r14+12]
	movups	xmm2, XMMWORD PTR [rax]
	mov	r10d, DWORD PTR [rax+24]
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, 27
	movups	XMMWORD PTR cParams$[rbp-96], xmm2
	movsd	QWORD PTR cParams$[rbp-80], xmm0
	movd	r8d, xmm2
	cmovne	r8d, eax
	mov	eax, DWORD PTR [r14+4]
	test	eax, eax
	cmovne	r8d, eax
	mov	eax, DWORD PTR cParams$[rbp-88]
	test	ecx, ecx
	mov	DWORD PTR cParams$[rbp-96], r8d
	cmovne	eax, ecx

; 1088 :     if (CCtxParams->cParams.chainLog) cParams.chainLog = CCtxParams->cParams.chainLog;

	mov	ecx, DWORD PTR [r14+8]
	mov	DWORD PTR cParams$[rbp-88], eax
	test	ecx, ecx
	mov	eax, DWORD PTR cParams$[rbp-92]
	cmovne	eax, ecx

; 1089 :     if (CCtxParams->cParams.searchLog) cParams.searchLog = CCtxParams->cParams.searchLog;

	mov	ecx, DWORD PTR [r14+16]
	mov	DWORD PTR cParams$[rbp-92], eax
	test	ecx, ecx
	mov	eax, DWORD PTR cParams$[rbp-84]
	cmovne	eax, ecx

; 1090 :     if (CCtxParams->cParams.minMatch) cParams.minMatch = CCtxParams->cParams.minMatch;

	mov	ecx, DWORD PTR [r14+20]
	mov	DWORD PTR cParams$[rbp-84], eax
	test	ecx, ecx
	mov	eax, DWORD PTR cParams$[rbp-80]

; 1091 :     if (CCtxParams->cParams.targetLength) cParams.targetLength = CCtxParams->cParams.targetLength;
; 1092 :     if (CCtxParams->cParams.strategy) cParams.strategy = CCtxParams->cParams.strategy;
; 1093 :     assert(!ZSTD_checkCParams(cParams));
; 1094 :     /* srcSizeHint == 0 means 0 */
; 1095 :     return ZSTD_adjustCParams_internal(cParams, srcSizeHint, dictSize);

	movups	xmm0, XMMWORD PTR cParams$[rbp-96]
	cmovne	eax, ecx
	mov	ecx, DWORD PTR [r14+24]
	mov	DWORD PTR cParams$[rbp-80], eax
	test	ecx, ecx
	mov	eax, DWORD PTR cParams$[rbp-76]
	cmovne	eax, ecx
	movaps	XMMWORD PTR $T1[rbp-96], xmm0
	mov	DWORD PTR cParams$[rbp-76], eax
	mov	eax, DWORD PTR [r14+28]
	test	eax, eax
	cmovne	r10d, eax

; 1040 :     if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)

	xor	r9d, r9d
	test	rsi, rsi
	je	SHORT $LN13@ZSTD_getCP
	cmp	rbx, -1
	jne	SHORT $LN13@ZSTD_getCP

; 1041 :         srcSize = minSrcSize;

	mov	ebx, 513				; 00000201H

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	jmp	SHORT $LN26@ZSTD_getCP
$LN13@ZSTD_getCP:
	cmp	rbx, 1073741824				; 40000000H
	jae	SHORT $LN27@ZSTD_getCP
$LN26@ZSTD_getCP:
	cmp	rsi, 1073741824				; 40000000H
	jae	SHORT $LN27@ZSTD_getCP

; 1046 :         U32 const tSize = (U32)(srcSize + dictSize);

	lea	eax, DWORD PTR [rsi+rbx]

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	cmp	eax, 64					; 00000040H
	jae	SHORT $LN20@ZSTD_getCP

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	mov	edx, DWORD PTR $T1[rbp-96]
	mov	eax, 6
	cmp	r8d, eax
	cmova	edx, eax
	jmp	SHORT $LN15@ZSTD_getCP
$LN20@ZSTD_getCP:
	mov	edx, DWORD PTR $T1[rbp-96]
	dec	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r9d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	inc	eax

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	cmp	r8d, eax
	cmova	edx, eax
	jmp	SHORT $LN15@ZSTD_getCP
$LN27@ZSTD_getCP:

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	mov	edx, DWORD PTR $T1[rbp-96]
$LN15@ZSTD_getCP:

; 1051 :     }
; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	eax, DWORD PTR $T1[rbp-88]
	lea	ecx, DWORD PTR [rdx+1]
	cmp	eax, ecx
	cmova	eax, ecx

; 1022 :     return hashLog - btScale;

	mov	ecx, DWORD PTR $T1[rbp-92]
	cmp	r10d, 6

; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	DWORD PTR $T1[rbp-88], eax

; 1022 :     return hashLog - btScale;

	mov	r8d, ecx
	setae	r9b
	sub	r8d, r9d

; 1054 :         if (cycleLog > cPar.windowLog)

	cmp	r8d, edx
	jbe	SHORT $LN17@ZSTD_getCP

; 1055 :             cPar.chainLog -= (cycleLog - cPar.windowLog);

	mov	eax, edx
	sub	eax, r8d
	add	ecx, eax
	mov	DWORD PTR $T1[rbp-92], ecx
$LN17@ZSTD_getCP:

; 1091 :     if (CCtxParams->cParams.targetLength) cParams.targetLength = CCtxParams->cParams.targetLength;
; 1092 :     if (CCtxParams->cParams.strategy) cParams.strategy = CCtxParams->cParams.strategy;
; 1093 :     assert(!ZSTD_checkCParams(cParams));
; 1094 :     /* srcSizeHint == 0 means 0 */
; 1095 :     return ZSTD_adjustCParams_internal(cParams, srcSizeHint, dictSize);

	movsd	xmm1, QWORD PTR cParams$[rbp-80]

; 1096 : }

	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+40]

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	eax, 10

; 1096 : }

	mov	rsi, QWORD PTR [r11+48]

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmp	edx, eax
	cmovb	edx, eax

; 1091 :     if (CCtxParams->cParams.targetLength) cParams.targetLength = CCtxParams->cParams.targetLength;
; 1092 :     if (CCtxParams->cParams.strategy) cParams.strategy = CCtxParams->cParams.strategy;
; 1093 :     assert(!ZSTD_checkCParams(cParams));
; 1094 :     /* srcSizeHint == 0 means 0 */
; 1095 :     return ZSTD_adjustCParams_internal(cParams, srcSizeHint, dictSize);

	mov	rax, rdi

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	DWORD PTR $T1[rbp-96], edx

; 1091 :     if (CCtxParams->cParams.targetLength) cParams.targetLength = CCtxParams->cParams.targetLength;
; 1092 :     if (CCtxParams->cParams.strategy) cParams.strategy = CCtxParams->cParams.strategy;
; 1093 :     assert(!ZSTD_checkCParams(cParams));
; 1094 :     /* srcSizeHint == 0 means 0 */
; 1095 :     return ZSTD_adjustCParams_internal(cParams, srcSizeHint, dictSize);

	movaps	xmm0, XMMWORD PTR $T1[rbp-96]
	movups	XMMWORD PTR [rdi], xmm0
	movsd	QWORD PTR [rdi+16], xmm1
	mov	DWORD PTR [rdi+24], r10d

; 1096 : }

	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
ZSTD_getCParamsFromCCtxParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cParams$ = 8
forCCtx$ = 16
ZSTD_sizeof_matchState PROC

; 1101 : {

	mov	QWORD PTR [rsp+8], rbx

; 1102 :     size_t const chainSize = (cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cParams->chainLog);

	mov	r10d, DWORD PTR [rcx+24]
	mov	eax, 1
	xor	ebx, ebx
	mov	r11d, edx
	mov	r9, rcx
	cmp	r10d, eax
	jne	SHORT $LN3@ZSTD_sizeo
	mov	r8d, ebx
	jmp	SHORT $LN4@ZSTD_sizeo
$LN3@ZSTD_sizeo:
	mov	ecx, DWORD PTR [rcx+4]
	mov	r8, rax
	shl	r8, cl
$LN4@ZSTD_sizeo:

; 1103 :     size_t const hSize = ((size_t)1) << cParams->hashLog;

	mov	ecx, DWORD PTR [r9+8]
	mov	rdx, rax
	shl	rdx, cl

; 1104 :     U32    const hashLog3 = (forCCtx && cParams->minMatch==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams->windowLog) : 0;

	test	r11d, r11d
	je	SHORT $LN5@ZSTD_sizeo
	cmp	DWORD PTR [r9+16], 3
	jne	SHORT $LN5@ZSTD_sizeo
	mov	ecx, DWORD PTR [r9]
	mov	r9d, 17
	cmp	ecx, r9d
	cmova	ecx, r9d
	shl	rax, cl
	test	ecx, ecx
	cmove	rax, rbx
	add	rax, rdx
	add	rax, r8
	shl	rax, 2
	jmp	SHORT $LN13@ZSTD_sizeo
$LN5@ZSTD_sizeo:

; 1105 :     size_t const h3Size = hashLog3 ? ((size_t)1) << hashLog3 : 0;
; 1106 :     /* We don't use ZSTD_cwksp_alloc_size() here because the tables aren't
; 1107 :      * surrounded by redzones in ASAN. */
; 1108 :     size_t const tableSpace = chainSize * sizeof(U32)

	lea	rax, QWORD PTR [rdx+r8]
	shl	rax, 2

; 1109 :                             + hSize * sizeof(U32)
; 1110 :                             + h3Size * sizeof(U32);
; 1111 :     size_t const optPotentialSpace =
; 1112 :         ZSTD_cwksp_alloc_size((MaxML+1) * sizeof(U32))
; 1113 :       + ZSTD_cwksp_alloc_size((MaxLL+1) * sizeof(U32))
; 1114 :       + ZSTD_cwksp_alloc_size((MaxOff+1) * sizeof(U32))
; 1115 :       + ZSTD_cwksp_alloc_size((1<<Litbits) * sizeof(U32))
; 1116 :       + ZSTD_cwksp_alloc_size((ZSTD_OPT_NUM+1) * sizeof(ZSTD_match_t))
; 1117 :       + ZSTD_cwksp_alloc_size((ZSTD_OPT_NUM+1) * sizeof(ZSTD_optimal_t));
; 1118 :     size_t const optSpace = (forCCtx && (cParams->strategy >= ZSTD_btopt))

	test	r11d, r11d
	je	SHORT $LN11@ZSTD_sizeo
$LN13@ZSTD_sizeo:
	cmp	r10d, 7
	jl	SHORT $LN11@ZSTD_sizeo
	mov	ecx, 149000				; 00024608H

; 1119 :                                 ? optPotentialSpace
; 1120 :                                 : 0;
; 1121 :     DEBUGLOG(4, "chainSize: %u - hSize: %u - h3Size: %u",
; 1122 :                 (U32)chainSize, (U32)hSize, (U32)h3Size);
; 1123 :     return tableSpace + optSpace;

	add	rax, rcx

; 1124 : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN11@ZSTD_sizeo:

; 1119 :                                 ? optPotentialSpace
; 1120 :                                 : 0;
; 1121 :     DEBUGLOG(4, "chainSize: %u - hSize: %u - h3Size: %u",
; 1122 :                 (U32)chainSize, (U32)hSize, (U32)h3Size);
; 1123 :     return tableSpace + optSpace;

	add	rax, rbx

; 1124 : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
ZSTD_sizeof_matchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cParams1$dead$ = 8
cParams2$dead$ = 16
ZSTD_assertEqualCParams PROC

; 1271 :     (void)cParams1;
; 1272 :     (void)cParams2;
; 1273 :     assert(cParams1.windowLog    == cParams2.windowLog);
; 1274 :     assert(cParams1.chainLog     == cParams2.chainLog);
; 1275 :     assert(cParams1.hashLog      == cParams2.hashLog);
; 1276 :     assert(cParams1.searchLog    == cParams2.searchLog);
; 1277 :     assert(cParams1.minMatch     == cParams2.minMatch);
; 1278 :     assert(cParams1.targetLength == cParams2.targetLength);
; 1279 :     assert(cParams1.strategy     == cParams2.strategy);
; 1280 : }

	ret	0
ZSTD_assertEqualCParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
bs$ = 8
ZSTD_reset_compressedBlockState PROC

; 1284 :     int i;
; 1285 :     for (i = 0; i < ZSTD_REP_NUM; ++i)
; 1286 :         bs->rep[i] = repStartValue[i];

	mov	DWORD PTR [rcx+4580], 1

; 1287 :     bs->entropy.huf.repeatMode = HUF_repeat_none;

	xor	eax, eax
	mov	DWORD PTR [rcx+4584], 4
	mov	DWORD PTR [rcx+4588], 8
	mov	DWORD PTR [rcx+1024], eax

; 1288 :     bs->entropy.fse.offcode_repeatMode = FSE_repeat_none;

	mov	QWORD PTR [rcx+4568], rax

; 1289 :     bs->entropy.fse.matchlength_repeatMode = FSE_repeat_none;
; 1290 :     bs->entropy.fse.litlength_repeatMode = FSE_repeat_none;

	mov	DWORD PTR [rcx+4576], eax

; 1291 : }

	ret	0
ZSTD_reset_compressedBlockState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ms$ = 8
ZSTD_invalidateMatchState PROC
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	mov	eax, DWORD PTR [rcx]
	sub	eax, DWORD PTR [rcx+8]

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rcx+28], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rcx+24], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1301 :     ms->nextToUpdate = ms->window.dictLimit;

	mov	DWORD PTR [rcx+36], eax

; 1302 :     ms->loadedDictEnd = 0;

	xor	eax, eax
	mov	DWORD PTR [rcx+32], eax

; 1303 :     ms->opt.litLengthSum = 0;  /* force reset of btopt stats */

	mov	DWORD PTR [rcx+124], eax

; 1304 :     ms->dictMatchState = NULL;

	mov	QWORD PTR [rcx+176], rax

; 1305 : }

	ret	0
ZSTD_invalidateMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ms$ = 48
ws$ = 56
cParams$ = 64
crp$ = 72
forceResetIndex$ = 80
forWho$ = 88
ZSTD_reset_matchState PROC

; 1351 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1352 :     size_t const chainSize = (cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cParams->chainLog);

	xor	esi, esi
	mov	r11d, r9d
	cmp	DWORD PTR [r8+24], 1
	mov	r14, r8
	mov	rbx, rdx
	mov	rdi, rcx
	jne	SHORT $LN10@ZSTD_reset
	mov	edx, esi
	jmp	SHORT $LN11@ZSTD_reset
$LN10@ZSTD_reset:
	mov	ecx, DWORD PTR [r8+4]
	mov	edx, 1
	shl	rdx, cl
$LN11@ZSTD_reset:

; 1353 :     size_t const hSize = ((size_t)1) << cParams->hashLog;

	mov	ecx, DWORD PTR [r8+8]
	mov	r8d, 1
	shl	r8, cl

; 1354 :     U32    const hashLog3 = ((forWho == ZSTD_resetTarget_CCtx) && cParams->minMatch==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams->windowLog) : 0;

	cmp	DWORD PTR forWho$[rsp], 1
	jne	SHORT $LN12@ZSTD_reset
	cmp	DWORD PTR [r14+16], 3
	jne	SHORT $LN12@ZSTD_reset
	mov	ecx, DWORD PTR [r14]
	mov	eax, 17
	cmp	ecx, eax
	cmova	ecx, eax
	jmp	SHORT $LN15@ZSTD_reset
$LN12@ZSTD_reset:
	mov	ecx, esi
$LN15@ZSTD_reset:

; 1355 :     size_t const h3Size = hashLog3 ? ((size_t)1) << hashLog3 : 0;
; 1356 : 
; 1357 :     DEBUGLOG(4, "reset indices : %u", forceResetIndex == ZSTDirp_reset);
; 1358 :     if (forceResetIndex == ZSTDirp_reset) {

	mov	r9d, 1
	shl	r9, cl
	test	ecx, ecx
	cmove	r9, rsi
	cmp	DWORD PTR forceResetIndex$[rsp], 1
	jne	SHORT $LN148@ZSTD_reset
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 923  :     window->base = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294966450

; 924  :     window->dictBase = (BYTE const*)"";
; 925  :     window->dictLimit = 1;    /* start from 1, so that 1st position is valid */

	mov	DWORD PTR [rdi+24], 1
	mov	QWORD PTR [rdi+8], rax
	lea	rax, OFFSET FLAT:$SG4294966449
	mov	QWORD PTR [rdi+16], rax

; 926  :     window->lowLimit = 1;     /* it ensures first and later CCtx usages compress the same */
; 927  :     window->nextSrc = window->base + 1;   /* see issue #1241 */

	lea	rax, OFFSET FLAT:$SG4294966450+1
	mov	QWORD PTR [rdi], rax
	mov	DWORD PTR [rdi+28], 1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1360 :         ZSTD_cwksp_mark_tables_dirty(ws);

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN148@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	mov	eax, DWORD PTR [rdi]
	sub	eax, DWORD PTR [rdi+8]

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rdi+28], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rdi+24], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1301 :     ms->nextToUpdate = ms->window.dictLimit;

	mov	DWORD PTR [rdi+36], eax

; 1361 :     }
; 1362 : 
; 1363 :     ms->hashLog3 = hashLog3;

	mov	DWORD PTR [rdi+40], ecx

; 1302 :     ms->loadedDictEnd = 0;

	mov	DWORD PTR [rdi+32], esi

; 1303 :     ms->opt.litLengthSum = 0;  /* force reset of btopt stats */

	mov	DWORD PTR [rdi+124], esi

; 1304 :     ms->dictMatchState = NULL;

	mov	QWORD PTR [rdi+176], rsi

; 1369 :     ZSTD_cwksp_clear_tables(ws);

	mov	rcx, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1369 :     ZSTD_cwksp_clear_tables(ws);

	mov	QWORD PTR [rbx+24], rcx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 283  :     void* end = (BYTE *)alloc + bytes;

	lea	r10, QWORD PTR [rcx+r8*4]

; 284  :     void* top = ws->allocStart;

	mov	r8, QWORD PTR [rbx+40]

; 191  :     if (phase > ws->phase) {

	cmp	eax, 2
	jge	SHORT $LN28@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN166@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	QWORD PTR [rbx+32], rcx
$LN166@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, r8
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN31@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN31@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN28@ZSTD_reset:

; 292  :     if (end > top) {

	cmp	r10, r8
	jbe	SHORT $LN25@ZSTD_reset

; 293  :         DEBUGLOG(4, "cwksp: table alloc failed!");
; 294  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 295  :         return NULL;

	mov	rcx, rsi
	jmp	SHORT $LN24@ZSTD_reset
$LN25@ZSTD_reset:

; 296  :     }
; 297  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+24], r10
$LN24@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1373 :     ms->hashTable = (U32*)ZSTD_cwksp_reserve_table(ws, hSize * sizeof(U32));

	mov	QWORD PTR [rdi+48], rcx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 282  :     void* alloc = ws->tableEnd;

	mov	rcx, QWORD PTR [rbx+24]

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]

; 283  :     void* end = (BYTE *)alloc + bytes;

	lea	r8, QWORD PTR [rcx+rdx*4]

; 284  :     void* top = ws->allocStart;

	mov	rdx, QWORD PTR [rbx+40]

; 191  :     if (phase > ws->phase) {

	cmp	eax, 2
	jge	SHORT $LN37@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN165@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN165@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, rdx
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN40@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN40@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN37@ZSTD_reset:

; 292  :     if (end > top) {

	cmp	r8, rdx
	jbe	SHORT $LN34@ZSTD_reset

; 293  :         DEBUGLOG(4, "cwksp: table alloc failed!");
; 294  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 295  :         return NULL;

	mov	rcx, rsi
	jmp	SHORT $LN33@ZSTD_reset
$LN34@ZSTD_reset:

; 296  :     }
; 297  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+24], r8
$LN33@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1374 :     ms->chainTable = (U32*)ZSTD_cwksp_reserve_table(ws, chainSize * sizeof(U32));

	mov	QWORD PTR [rdi+64], rcx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 282  :     void* alloc = ws->tableEnd;

	mov	rcx, QWORD PTR [rbx+24]

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]

; 284  :     void* top = ws->allocStart;

	mov	r8, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rcx+r9*4]

; 191  :     if (phase > ws->phase) {

	cmp	eax, 2
	jge	SHORT $LN46@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN164@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN164@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, r8
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN49@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN49@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN46@ZSTD_reset:

; 292  :     if (end > top) {

	cmp	rdx, r8
	jbe	SHORT $LN43@ZSTD_reset

; 293  :         DEBUGLOG(4, "cwksp: table alloc failed!");
; 294  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 295  :         return NULL;

	mov	rcx, rsi
	jmp	SHORT $LN42@ZSTD_reset
$LN43@ZSTD_reset:

; 296  :     }
; 297  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+24], rdx
$LN42@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1375 :     ms->hashTable3 = (U32*)ZSTD_cwksp_reserve_table(ws, h3Size * sizeof(U32));

	mov	QWORD PTR [rdi+56], rcx

; 1376 :     RETURN_ERROR_IF(ZSTD_cwksp_reserve_failed(ws), memory_allocation,

	cmp	DWORD PTR [rbx+48], esi
	jne	$LN167@ZSTD_reset

; 1377 :                     "failed a workspace allocation in ZSTD_reset_matchState");
; 1378 : 
; 1379 :     DEBUGLOG(4, "reset table : %u", crp!=ZSTDcrp_leaveDirty);
; 1380 :     if (crp!=ZSTDcrp_leaveDirty) {

	cmp	r11d, 1
	je	SHORT $LN55@ZSTD_reset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 382  :     if (ws->tableValidEnd < ws->tableEnd) {

	mov	rcx, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rbx+24]
	cmp	rcx, rax
	jae	SHORT $LN55@ZSTD_reset

; 383  :         memset(ws->tableValidEnd, 0, (BYTE*)ws->tableEnd - (BYTE*)ws->tableValidEnd);

	sub	rax, rcx
	xor	edx, edx
	mov	r8, rax
	call	memset
	mov	rcx, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rbx+24]

; 369  :     if (ws->tableValidEnd < ws->tableEnd) {

	cmp	rcx, rax
	jae	SHORT $LN55@ZSTD_reset

; 370  :         ws->tableValidEnd = ws->tableEnd;

	mov	QWORD PTR [rbx+32], rax
$LN55@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1386 :     if ((forWho == ZSTD_resetTarget_CCtx) && (cParams->strategy >= ZSTD_btopt)) {

	cmp	DWORD PTR forWho$[rsp], 1
	jne	$LN6@ZSTD_reset
	cmp	DWORD PTR [r14+24], 7
	jl	$LN6@ZSTD_reset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, 2
	jge	SHORT $LN66@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN163@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN163@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+40]
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN69@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN69@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN66@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+40]
	sub	rax, 1024				; 00000400H

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+24]
	jae	SHORT $LN62@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 243  :         return NULL;

	mov	rax, rsi
	jmp	SHORT $LN61@ZSTD_reset
$LN62@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN63@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+32], rax
$LN63@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+40], rax
$LN61@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1388 :         ms->opt.litFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (1<<Litbits) * sizeof(unsigned));

	mov	QWORD PTR [rdi+72], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, 2
	jge	SHORT $LN80@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN162@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN162@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+40]
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN83@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN83@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN80@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+40]
	sub	rax, 144				; 00000090H

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+24]
	jae	SHORT $LN76@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 243  :         return NULL;

	mov	rax, rsi
	jmp	SHORT $LN75@ZSTD_reset
$LN76@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN77@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+32], rax
$LN77@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+40], rax
$LN75@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1389 :         ms->opt.litLengthFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (MaxLL+1) * sizeof(unsigned));

	mov	QWORD PTR [rdi+80], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, 2
	jge	SHORT $LN94@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN161@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN161@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+40]
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN97@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN97@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN94@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+40]
	sub	rax, 212				; 000000d4H

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+24]
	jae	SHORT $LN90@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 243  :         return NULL;

	mov	rax, rsi
	jmp	SHORT $LN89@ZSTD_reset
$LN90@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN91@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+32], rax
$LN91@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+40], rax
$LN89@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1390 :         ms->opt.matchLengthFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (MaxML+1) * sizeof(unsigned));

	mov	QWORD PTR [rdi+88], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, 2
	jge	SHORT $LN108@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN160@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN160@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+40]
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN111@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN111@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN108@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+40]
	add	rax, -128				; ffffffffffffff80H

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+24]
	jae	SHORT $LN104@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 243  :         return NULL;

	mov	rax, rsi
	jmp	SHORT $LN103@ZSTD_reset
$LN104@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN105@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+32], rax
$LN105@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+40], rax
$LN103@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1391 :         ms->opt.offCodeFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (MaxOff+1) * sizeof(unsigned));

	mov	QWORD PTR [rdi+96], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, 2
	jge	SHORT $LN122@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN159@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN159@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+40]
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN125@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN125@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN122@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+40]
	sub	rax, 32776				; 00008008H

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+24]
	jae	SHORT $LN118@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 243  :         return NULL;

	mov	rax, rsi
	jmp	SHORT $LN117@ZSTD_reset
$LN118@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN119@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+32], rax
$LN119@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+40], rax
$LN117@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1392 :         ms->opt.matchTable = (ZSTD_match_t*)ZSTD_cwksp_reserve_aligned(ws, (ZSTD_OPT_NUM+1) * sizeof(ZSTD_match_t));

	mov	QWORD PTR [rdi+104], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, 2
	jge	SHORT $LN136@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN158@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+32], rax
$LN158@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+40]
	and	rax, -4
	mov	QWORD PTR [rbx+40], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN139@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+32], rax
$LN139@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+56], 2
$LN136@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+40]
	sub	rax, 114716				; 0001c01cH

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+24]
	jae	SHORT $LN132@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+48], 1

; 243  :         return NULL;

	jmp	SHORT $LN131@ZSTD_reset
$LN132@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+32]
	jae	SHORT $LN133@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+32], rax
$LN133@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+40], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	rsi, rax
$LN131@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1393 :         ms->opt.priceTable = (ZSTD_optimal_t*)ZSTD_cwksp_reserve_aligned(ws, (ZSTD_OPT_NUM+1) * sizeof(ZSTD_optimal_t));

	mov	QWORD PTR [rdi+112], rsi
$LN6@ZSTD_reset:

; 1394 :     }
; 1395 : 
; 1396 :     ms->cParams = *cParams;

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rdi+184], xmm0
	movsd	xmm1, QWORD PTR [r14+16]
	movsd	QWORD PTR [rdi+200], xmm1
	mov	eax, DWORD PTR [r14+24]
	mov	DWORD PTR [rdi+208], eax

; 1397 : 
; 1398 :     RETURN_ERROR_IF(ZSTD_cwksp_reserve_failed(ws), memory_allocation,

	cmp	DWORD PTR [rbx+48], 0
	jne	SHORT $LN167@ZSTD_reset

; 1399 :                     "failed a workspace allocation in ZSTD_reset_matchState");
; 1400 : 
; 1401 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_reset
$LN167@ZSTD_reset:

; 1397 : 
; 1398 :     RETURN_ERROR_IF(ZSTD_cwksp_reserve_failed(ws), memory_allocation,

	mov	rax, -64				; ffffffffffffffc0H
$LN1@ZSTD_reset:

; 1402 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
ZSTD_reset_matchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
w$ = 8
ZSTD_indexTooCloseToMax PROC

; 1414 :     return (size_t)(w.nextSrc - w.base) > (ZSTD_CURRENT_MAX - ZSTD_INDEXOVERFLOW_MARGIN);

	mov	rdx, QWORD PTR [rcx]
	xor	eax, eax
	sub	rdx, QWORD PTR [rcx+8]
	mov	ecx, -553648128				; df000000H
	cmp	rdx, rcx
	seta	al

; 1415 : }

	ret	0
ZSTD_indexTooCloseToMax ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\xxhash.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\xxhash.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\xxhash.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
maxNbSeq$1$ = 80
tv2966 = 88
state$6 = 96
maxNbLdmSeq$1$ = 272
zc$ = 272
buffOutSize$1$ = 280
params$ = 280
tv2960 = 288
pledgedSrcSize$ = 288
crp$ = 296
needsIndexReset$2$ = 304
zbuff$ = 304
ZSTD_resetCCtx_internal PROC

; 1424 : {

	mov	DWORD PTR [rsp+32], r9d
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 200				; 000000c8H

; 1425 :     ZSTD_cwksp* const ws = &zc->workspace;
; 1426 :     DEBUGLOG(4, "ZSTD_resetCCtx_internal: pledgedSrcSize=%u, wlog=%u",
; 1427 :                 (U32)pledgedSrcSize, params.cParams.windowLog);
; 1428 :     assert(!ZSTD_isError(ZSTD_checkCParams(params.cParams)));
; 1429 : 
; 1430 :     zc->isFirstBlock = 1;
; 1431 : 
; 1432 :     if (params.ldmParams.enableLdm) {

	cmp	DWORD PTR [rdx+96], 0
	mov	r12d, 1
	mov	DWORD PTR [rcx+560], r12d
	mov	rbp, r8
	mov	rsi, rdx
	mov	rbx, rcx
	je	SHORT $LN8@ZSTD_reset

; 1433 :         /* Adjust long distance matching parameters */
; 1434 :         ZSTD_ldm_adjustParameters(&params.ldmParams, &params.cParams);

	add	rdx, 4
	lea	rcx, QWORD PTR [rsi+96]
	call	ZSTD_ldm_adjustParameters
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	mov	eax, DWORD PTR [rsi+108]
	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H

; 647  :     U64 power = 1;

	mov	edx, r12d

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	sub	eax, r12d

; 648  :     while (exponent) {

	je	SHORT $LN45@ZSTD_reset
$LL44@ZSTD_reset:

; 649  :       if (exponent & 1) power *= base;

	test	al, r12b
	je	SHORT $LN46@ZSTD_reset
	imul	rdx, rcx
$LN46@ZSTD_reset:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rcx, rcx
	shr	rax, 1
	jne	SHORT $LL44@ZSTD_reset
$LN45@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1437 :         zc->ldmState.hashPower = ZSTD_rollingHash_primePower(params.ldmParams.minMatchLength);

	mov	QWORD PTR [rbx+704], rdx
$LN8@ZSTD_reset:

; 1438 :     }
; 1439 : 
; 1440 :     {   size_t const windowSize = MAX(1, (size_t)MIN(((U64)1 << params.cParams.windowLog), pledgedSrcSize));

	mov	ecx, DWORD PTR [rsi+4]
	mov	rdx, r12
	shl	rdx, cl
	mov	rax, rbp
	cmp	rdx, rbp
	cmovb	rax, rdx
	cmp	rax, r12
	jae	SHORT $LN33@ZSTD_reset
	mov	r8, r12
	jmp	SHORT $LN31@ZSTD_reset
$LN33@ZSTD_reset:
	cmp	rdx, rbp
	mov	r8, rbp
	cmovb	r8, rdx
$LN31@ZSTD_reset:

; 1441 :         size_t const blockSize = MIN(ZSTD_BLOCKSIZE_MAX, windowSize);
; 1442 :         U32    const divider = (params.cParams.minMatch==3) ? 3 : 4;
; 1443 :         size_t const maxNbSeq = blockSize / divider;
; 1444 :         size_t const tokenSpace = ZSTD_cwksp_alloc_size(WILDCOPY_OVERLENGTH + blockSize)
; 1445 :                                 + ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(seqDef))
; 1446 :                                 + 3 * ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(BYTE));
; 1447 :         size_t const buffOutSize = (zbuff==ZSTDb_buffered) ? ZSTD_compressBound(blockSize)+1 : 0;

	mov	r9d, DWORD PTR zbuff$[rsp]
	mov	r10d, 131072				; 00020000H
	cmp	r8, r10
	mov	rdi, r8
	cmova	rdi, r10
	xor	r11d, r11d
	cmp	DWORD PTR [rsi+20], 3
	mov	ecx, r11d
	mov	rax, rdi
	setne	cl
	xor	edx, edx
	add	rcx, 3
	div	rcx
	mov	QWORD PTR maxNbSeq$1$[rsp], rax
	imul	rax, rax, 11
	add	rax, rdi
	mov	QWORD PTR tv2960[rsp], rax
	cmp	r9d, r12d
	jne	SHORT $LN35@ZSTD_reset

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	edx, r10d
	mov	ecx, r11d
	sub	rdx, rdi
	mov	rax, rdi
	shr	rdx, 11
	cmp	rdi, r10

; 1441 :         size_t const blockSize = MIN(ZSTD_BLOCKSIZE_MAX, windowSize);
; 1442 :         U32    const divider = (params.cParams.minMatch==3) ? 3 : 4;
; 1443 :         size_t const maxNbSeq = blockSize / divider;
; 1444 :         size_t const tokenSpace = ZSTD_cwksp_alloc_size(WILDCOPY_OVERLENGTH + blockSize)
; 1445 :                                 + ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(seqDef))
; 1446 :                                 + 3 * ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(BYTE));
; 1447 :         size_t const buffOutSize = (zbuff==ZSTDb_buffered) ? ZSTD_compressBound(blockSize)+1 : 0;

	lea	r10, QWORD PTR [rdi+1]

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	cmovb	rcx, rdx
	shr	rax, 8

; 1441 :         size_t const blockSize = MIN(ZSTD_BLOCKSIZE_MAX, windowSize);
; 1442 :         U32    const divider = (params.cParams.minMatch==3) ? 3 : 4;
; 1443 :         size_t const maxNbSeq = blockSize / divider;
; 1444 :         size_t const tokenSpace = ZSTD_cwksp_alloc_size(WILDCOPY_OVERLENGTH + blockSize)
; 1445 :                                 + ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(seqDef))
; 1446 :                                 + 3 * ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(BYTE));
; 1447 :         size_t const buffOutSize = (zbuff==ZSTDb_buffered) ? ZSTD_compressBound(blockSize)+1 : 0;

	add	rax, rcx
	add	r10, rax
	jmp	SHORT $LN336@ZSTD_reset
$LN35@ZSTD_reset:
	mov	r10, r11
$LN336@ZSTD_reset:

; 1448 :         size_t const buffInSize = (zbuff==ZSTDb_buffered) ? windowSize + blockSize : 0;
; 1449 :         size_t const matchStateSize = ZSTD_sizeof_matchState(&params.cParams, /* forCCtx */ 1);

	cmp	r9d, r12d
	mov	QWORD PTR buffOutSize$1$[rsp], r10
	lea	r13, QWORD PTR [rdi+r8]
	cmovne	r13, r11

; 1102 :     size_t const chainSize = (cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cParams->chainLog);

	cmp	DWORD PTR [rsi+28], r12d
	jne	SHORT $LN54@ZSTD_reset
	mov	rax, r11
	jmp	SHORT $LN55@ZSTD_reset
$LN54@ZSTD_reset:
	mov	ecx, DWORD PTR [rsi+8]
	mov	rax, r12
	shl	rax, cl
$LN55@ZSTD_reset:

; 1103 :     size_t const hSize = ((size_t)1) << cParams->hashLog;

	mov	ecx, DWORD PTR [rsi+12]
	mov	rdx, r12
	shl	rdx, cl

; 1104 :     U32    const hashLog3 = (forCCtx && cParams->minMatch==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams->windowLog) : 0;

	cmp	DWORD PTR [rsi+20], 3
	jne	SHORT $LN56@ZSTD_reset
	mov	ecx, DWORD PTR [rsi+4]
	mov	r8d, 17
	cmp	ecx, r8d
	cmova	ecx, r8d
	jmp	SHORT $LN59@ZSTD_reset
$LN56@ZSTD_reset:
	mov	ecx, r11d
$LN59@ZSTD_reset:

; 1450 :         size_t const maxNbLdmSeq = ZSTD_ldm_getMaxNbSeq(params.ldmParams, blockSize);

	movups	xmm1, XMMWORD PTR [rsi+96]

; 1108 :     size_t const tableSpace = chainSize * sizeof(U32)

	mov	r11, r12
	mov	r8d, 0

; 1450 :         size_t const maxNbLdmSeq = ZSTD_ldm_getMaxNbSeq(params.ldmParams, blockSize);

	movsd	xmm0, QWORD PTR [rsi+112]

; 1108 :     size_t const tableSpace = chainSize * sizeof(U32)

	shl	r11, cl
	test	ecx, ecx

; 1450 :         size_t const maxNbLdmSeq = ZSTD_ldm_getMaxNbSeq(params.ldmParams, blockSize);

	movaps	XMMWORD PTR $T5[rsp], xmm1
	movsd	QWORD PTR $T5[rsp+16], xmm0

; 1108 :     size_t const tableSpace = chainSize * sizeof(U32)

	cmove	r11, r8
	add	r11, rdx
	add	r11, rax
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 61   :     return params.enableLdm ? (maxChunkSize / params.minMatchLength) : 0;

	movd	eax, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1108 :     size_t const tableSpace = chainSize * sizeof(U32)

	shl	r11, 2
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 61   :     return params.enableLdm ? (maxChunkSize / params.minMatchLength) : 0;

	test	eax, eax
	je	SHORT $LN66@ZSTD_reset
	mov	rcx, QWORD PTR $T5[rsp+8]
	xor	edx, edx
	shr	rcx, 32					; 00000020H
	mov	rax, rdi
	div	rcx
	mov	QWORD PTR maxNbLdmSeq$1$[rsp], rax
	jmp	SHORT $LN67@ZSTD_reset
$LN66@ZSTD_reset:
	mov	QWORD PTR maxNbLdmSeq$1$[rsp], r8
$LN67@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1452 :         ZSTD_indexResetPolicy_e needsIndexReset = zc->initialized ? ZSTDirp_continue : ZSTDirp_reset;

	cmp	DWORD PTR [rbx+564], r8d
	mov	edx, r8d

; 1453 : 
; 1454 :         if (ZSTD_indexTooCloseToMax(zc->blockState.matchState.window)) {

	movups	xmm1, XMMWORD PTR [rbx+776]
	sete	dl
	movups	xmm0, XMMWORD PTR [rbx+792]

; 1414 :     return (size_t)(w.nextSrc - w.base) > (ZSTD_CURRENT_MAX - ZSTD_INDEXOVERFLOW_MARGIN);

	movq	rcx, xmm1
	psrldq	xmm1, 8
	movq	rax, xmm1

; 1453 : 
; 1454 :         if (ZSTD_indexTooCloseToMax(zc->blockState.matchState.window)) {

	movaps	XMMWORD PTR $T4[rsp+16], xmm0

; 1414 :     return (size_t)(w.nextSrc - w.base) > (ZSTD_CURRENT_MAX - ZSTD_INDEXOVERFLOW_MARGIN);

	sub	rcx, rax
	mov	eax, -553648128				; df000000H
	cmp	rcx, rax

; 1453 : 
; 1454 :         if (ZSTD_indexTooCloseToMax(zc->blockState.matchState.window)) {

	cmova	edx, r12d

; 1455 :             needsIndexReset = ZSTDirp_reset;
; 1456 :         }
; 1457 : 
; 1458 :         if (!zc->staticSize) ZSTD_cwksp_bump_oversized_duration(ws, 0);

	mov	r12, QWORD PTR [rbx+520]
	mov	DWORD PTR needsIndexReset$2$[rsp], edx
	test	r12, r12
	jne	SHORT $LN315@ZSTD_reset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 515  :         ws->workspaceOversizedDuration++;

	inc	DWORD PTR [rbx+364]
$LN315@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1465 :             size_t const ldmSpace = ZSTD_ldm_getTableSize(params.ldmParams);

	movups	xmm1, XMMWORD PTR [rsi+96]
	add	r10, r13
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 51   :     size_t const ldmHSize = ((size_t)1) << params.hashLog;

	mov	r9d, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1465 :             size_t const ldmSpace = ZSTD_ldm_getTableSize(params.ldmParams);

	movsd	xmm0, QWORD PTR [rsi+112]

; 1468 :             size_t const neededSpace =

	mov	r15d, 16744				; 00004168H
	movsd	QWORD PTR $T3[rsp+16], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 51   :     size_t const ldmHSize = ((size_t)1) << params.hashLog;

	movq	r8, xmm1
	shr	r8, 32					; 00000020H

; 52   :     size_t const ldmBucketSizeLog = MIN(params.bucketSizeLog, params.hashLog);

	movdqa	xmm0, xmm1
	mov	ecx, r8d
	psrldq	xmm0, 8
	shl	r9, cl
	movd	eax, xmm0
	cmp	eax, r8d
	cmovb	ecx, eax

; 56   :     return params.enableLdm ? totalSize : 0;

	xor	edx, edx
	mov	eax, ecx
	movzx	ecx, r8b
	sub	cl, al
	mov	eax, 1
	shl	rax, cl
	lea	rcx, QWORD PTR [rax+r9*8]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1466 :             size_t const ldmSeqSpace = ZSTD_cwksp_alloc_size(maxNbLdmSeq * sizeof(rawSeq));

	mov	rax, QWORD PTR maxNbLdmSeq$1$[rsp]

; 1468 :             size_t const neededSpace =

	mov	r9d, 15584				; 00003ce0H
	lea	r8, QWORD PTR [rax+rax*2]
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 56   :     return params.enableLdm ? totalSize : 0;

	movd	eax, xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1466 :             size_t const ldmSeqSpace = ZSTD_cwksp_alloc_size(maxNbLdmSeq * sizeof(rawSeq));

	shl	r8, 2
	mov	QWORD PTR tv2966[rsp], r8
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 56   :     return params.enableLdm ? totalSize : 0;

	test	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1468 :             size_t const neededSpace =

	mov	eax, 32					; 00000020H
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 56   :     return params.enableLdm ? totalSize : 0;

	cmovne	rdx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1468 :             size_t const neededSpace =

	cmp	DWORD PTR [rsi+28], 7
	mov	ecx, 149032				; 00024628H
	cmovl	ecx, eax
	add	rcx, QWORD PTR tv2960[rsp]
	test	r12, r12
	cmove	r15d, r9d
	add	rcx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 483  :     return (size_t)((BYTE*)ws->workspaceEnd - (BYTE*)ws->workspace);

	mov	rdx, QWORD PTR [rbx+320]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1468 :             size_t const neededSpace =

	add	r15, rcx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	mov	rcx, QWORD PTR [rbx+352]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1468 :             size_t const neededSpace =

	add	r15, r11
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 495  :     return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);

	sub	rcx, QWORD PTR [rbx+336]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1468 :             size_t const neededSpace =

	add	r15, r8
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 483  :     return (size_t)((BYTE*)ws->workspaceEnd - (BYTE*)ws->workspace);

	mov	r8, QWORD PTR [rbx+312]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1468 :             size_t const neededSpace =

	add	r15, r10
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 483  :     return (size_t)((BYTE*)ws->workspaceEnd - (BYTE*)ws->workspace);

	mov	r9, rdx
	sub	r9, r8

; 503  :     return ZSTD_cwksp_check_available(

	lea	rax, QWORD PTR [r15+r15*2]

; 499  :     return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;

	cmp	rcx, rax

; 508  :     return ZSTD_cwksp_check_too_large(ws, additionalNeededSpace)

	jb	SHORT $LN88@ZSTD_reset
	cmp	DWORD PTR [rbx+364], 128		; 00000080H
	jle	SHORT $LN88@ZSTD_reset
	mov	eax, 1
	xor	r11d, r11d
	jmp	SHORT $LN89@ZSTD_reset
$LN88@ZSTD_reset:
	xor	r11d, r11d
	mov	eax, r11d
$LN89@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1485 :             if (workspaceTooSmall || workspaceWasteful) {

	cmp	r9, r15
	jb	SHORT $LN12@ZSTD_reset
	test	eax, eax
	jne	SHORT $LN12@ZSTD_reset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 515  :         ws->workspaceOversizedDuration++;

	lea	r12, QWORD PTR [rbx+312]
	jmp	$LN294@ZSTD_reset
$LN12@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1490 :                 RETURN_ERROR_IF(zc->staticSize, memory_allocation, "static cctx : no resize");

	test	r12, r12
	jne	$LN334@ZSTD_reset

; 1493 : 
; 1494 :                 ZSTD_cwksp_free(ws, zc->customMem);

	movsd	xmm1, QWORD PTR [rbx+512]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	lea	r12, QWORD PTR [rbx+312]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1492 :                 needsIndexReset = ZSTDirp_reset;

	mov	DWORD PTR needsIndexReset$2$[rsp], 1

; 1493 : 
; 1494 :                 ZSTD_cwksp_free(ws, zc->customMem);

	movsd	QWORD PTR $T2[rsp+16], xmm1
	movups	xmm0, XMMWORD PTR [rbx+496]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	xorps	xmm0, xmm0
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [r12], xmm0
	movups	XMMWORD PTR [r12+16], xmm0
	movups	XMMWORD PTR [r12+32], xmm0
	movups	XMMWORD PTR [r12+48], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	r8, r8
	je	SHORT $LN4@ZSTD_reset

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T2[rsp+8]
	test	rax, rax
	je	SHORT $LN100@ZSTD_reset

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, r8
	call	rax
	jmp	SHORT $LN4@ZSTD_reset
$LN100@ZSTD_reset:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, r8
	call	QWORD PTR __imp_free
$LN4@ZSTD_reset:

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx+496]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 459  :     void* workspace = ZSTD_malloc(size, customMem);

	movsd	xmm0, QWORD PTR [rbx+512]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN108@ZSTD_reset

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, r15
	call	rax
	jmp	SHORT $LN107@ZSTD_reset
$LN108@ZSTD_reset:

; 60   :     return malloc(size);

	mov	rcx, r15
	call	QWORD PTR __imp_malloc
$LN107@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 461  :     RETURN_ERROR_IF(workspace == NULL, memory_allocation, "NULL pointer!");

	test	rax, rax
	je	$LN334@ZSTD_reset

; 449  :     ws->workspaceEnd = (BYTE*)start + size;

	lea	rdx, QWORD PTR [rax+r15]
	mov	QWORD PTR [r12], rax

; 452  :     ws->phase = ZSTD_cwksp_alloc_objects;

	xor	r11d, r11d
	mov	QWORD PTR [rbx+320], rdx

; 312  :     void* end = (BYTE*)alloc + roundedBytes;

	lea	rcx, QWORD PTR [rax+4592]

; 450  :     ws->objectEnd = ws->workspace;

	mov	QWORD PTR [rbx+328], rax

; 451  :     ws->tableValidEnd = ws->objectEnd;

	mov	QWORD PTR [rbx+344], rax

; 453  :     ZSTD_cwksp_clear(ws);
; 454  :     ws->workspaceOversizedDuration = 0;

	mov	QWORD PTR [rbx+364], r11

; 431  :     ws->tableEnd = ws->objectEnd;

	mov	QWORD PTR [rbx+336], rax

; 432  :     ws->allocStart = ws->workspaceEnd;

	mov	QWORD PTR [rbx+352], rdx

; 433  :     ws->allocFailed = 0;

	mov	DWORD PTR [rbx+360], r11d

; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	rcx, rdx
	ja	$LN291@ZSTD_reset

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR [rbx+328], rcx

; 332  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+336], rcx

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR [rbx+344], rcx

; 334  : 
; 335  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 336  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 337  :      * either size. */
; 338  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 339  :     __asan_unpoison_memory_region(alloc, bytes);
; 340  : #endif
; 341  : 
; 342  :     return alloc;

	mov	QWORD PTR [rbx+760], rax
	lea	rax, QWORD PTR [rcx+4592]

; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	rax, rdx
	ja	$LN317@ZSTD_reset

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR [rbx+328], rax

; 332  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+336], rax

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR [rbx+344], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1504 :                 zc->blockState.nextCBlock = (ZSTD_compressedBlockState_t*) ZSTD_cwksp_reserve_object(ws, sizeof(ZSTD_compressedBlockState_t));

	mov	QWORD PTR [rbx+768], rcx

; 1505 :                 RETURN_ERROR_IF(zc->blockState.nextCBlock == NULL, memory_allocation, "couldn't allocate nextCBlock");

	test	rcx, rcx
	je	$LN334@ZSTD_reset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 312  :     void* end = (BYTE*)alloc + roundedBytes;

	lea	rcx, QWORD PTR [rax+6400]

; 313  : 
; 314  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 315  :     /* over-reserve space */
; 316  :     end = (BYTE *)end + 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 317  : #endif
; 318  : 
; 319  :     DEBUGLOG(5,
; 320  :         "cwksp: reserving %p object %zd bytes (rounded to %zd), %zd bytes remaining",
; 321  :         alloc, bytes, roundedBytes, ZSTD_cwksp_available_space(ws) - roundedBytes);
; 322  :     assert(((size_t)alloc & (sizeof(void*)-1)) == 0);
; 323  :     assert((bytes & (sizeof(void*)-1)) == 0);
; 324  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 325  :     /* we must be in the first phase, no advance is possible */
; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	rcx, rdx
	ja	SHORT $LN293@ZSTD_reset

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR [rbx+328], rcx

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR [rbx+344], rcx

; 334  : 
; 335  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 336  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 337  :      * either size. */
; 338  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 339  :     __asan_unpoison_memory_region(alloc, bytes);
; 340  : #endif
; 341  : 
; 342  :     return alloc;

	mov	QWORD PTR [rbx+992], rax
	jmp	SHORT $LN294@ZSTD_reset
$LN293@ZSTD_reset:

; 329  :         return NULL;

	mov	QWORD PTR [rbx+992], r11
$LN294@ZSTD_reset:

; 431  :     ws->tableEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 434  :     if (ws->phase > ZSTD_cwksp_alloc_buffers) {

	mov	r15d, 1
	mov	QWORD PTR [rbx+336], rax
	mov	QWORD PTR [rbx+352], rdx
	mov	DWORD PTR [rbx+360], r11d
	cmp	DWORD PTR [rbx+368], r15d
	jle	SHORT $LN136@ZSTD_reset

; 435  :         ws->phase = ZSTD_cwksp_alloc_buffers;

	mov	DWORD PTR [rbx+368], r15d
$LN136@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1513 :         zc->appliedParams = params;

	movaps	xmm0, XMMWORD PTR [rsi]
	movaps	xmm1, XMMWORD PTR [rsi+16]

; 1514 :         zc->blockState.matchState.cParams = params.cParams;

	mov	eax, DWORD PTR [rsi+28]

; 1515 :         zc->pledgedSrcSizePlusOne = pledgedSrcSize+1;
; 1516 :         zc->consumedSrcSize = 0;

	mov	QWORD PTR [rbx+392], r11

; 1517 :         zc->producedCSize = 0;

	mov	QWORD PTR [rbx+400], r11
	movups	XMMWORD PTR [rbx+160], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+32]
	movups	XMMWORD PTR [rbx+176], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+48]
	movups	XMMWORD PTR [rbx+192], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+64]
	movups	XMMWORD PTR [rbx+208], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+80]
	movups	XMMWORD PTR [rbx+224], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+96]
	movups	XMMWORD PTR [rbx+240], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+112]
	movups	XMMWORD PTR [rbx+256], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+128]
	movups	XMMWORD PTR [rbx+272], xmm1
	movsd	xmm1, QWORD PTR [rsi+20]
	movups	XMMWORD PTR [rbx+288], xmm0
	movups	xmm0, XMMWORD PTR [rsi+4]
	movups	XMMWORD PTR [rbx+960], xmm0
	movsd	QWORD PTR [rbx+976], xmm1
	mov	DWORD PTR [rbx+984], eax
	lea	rax, QWORD PTR [rbp+1]
	mov	QWORD PTR [rbx+384], rax

; 1518 :         if (pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN)

	cmp	rbp, -1
	jne	SHORT $LN23@ZSTD_reset

; 1519 :             zc->appliedParams.fParams.contentSizeFlag = 0;

	mov	DWORD PTR [rbx+192], r11d
$LN23@ZSTD_reset:

; 1520 :         DEBUGLOG(4, "pledged content size : %u ; flag : %u",
; 1521 :             (unsigned)pledgedSrcSize, zc->appliedParams.fParams.contentSizeFlag);
; 1522 :         zc->blockSize = blockSize;

	mov	QWORD PTR [rbx+376], rdi
; File E:\dev\pyzstd\lib\common\xxhash.c

; 571  :     state.v1 = seed + PRIME64_1 + PRIME64_2;

	mov	rax, 6983438078262162902		; 60ea27eeadc0b5d6H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1525 :         zc->stage = ZSTDcs_init;

	mov	DWORD PTR [rbx], r15d
	xorps	xmm2, xmm2

; 1526 :         zc->dictID = 0;

	mov	DWORD PTR [rbx+304], r11d
	xorps	xmm3, xmm3
; File E:\dev\pyzstd\lib\common\xxhash.c

; 571  :     state.v1 = seed + PRIME64_1 + PRIME64_2;

	mov	QWORD PTR state$6[rsp+8], rax

; 572  :     state.v2 = seed + PRIME64_2;

	mov	rax, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	QWORD PTR state$6[rsp+16], rax

; 573  :     state.v3 = seed + 0;
; 574  :     state.v4 = seed - PRIME64_1;

	mov	rax, 7046029288634856825		; 61c8864e7a143579H
	mov	QWORD PTR state$6[rsp+32], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1528 :         ZSTD_reset_compressedBlockState(zc->blockState.prevCBlock);

	mov	rax, QWORD PTR [rbx+760]
; File E:\dev\pyzstd\lib\common\xxhash.c

; 570  :     memset(&state, 0, sizeof(state)-8);   /* do not write into reserved, for future removal */

	mov	QWORD PTR state$6[rsp], r11

; 575  :     memcpy(statePtr, &state, sizeof(state));

	movaps	xmm0, XMMWORD PTR state$6[rsp]
	movups	XMMWORD PTR [rbx+408], xmm0
	mov	QWORD PTR state$6[rsp+24], r11
	movaps	xmm1, XMMWORD PTR state$6[rsp+16]
	movups	XMMWORD PTR [rbx+424], xmm1
	mov	QWORD PTR state$6[rsp+40], r11
	movaps	xmm0, XMMWORD PTR state$6[rsp+32]
	movups	XMMWORD PTR [rbx+440], xmm0
	movsd	xmm0, QWORD PTR state$6[rsp+80]
	movups	XMMWORD PTR [rbx+456], xmm2
	movups	XMMWORD PTR [rbx+472], xmm3
	movsd	QWORD PTR [rbx+488], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1286 :         bs->rep[i] = repStartValue[i];

	mov	DWORD PTR [rax+4580], r15d
	mov	DWORD PTR [rax+4584], 4
	mov	DWORD PTR [rax+4588], 8

; 1287 :     bs->entropy.huf.repeatMode = HUF_repeat_none;

	mov	DWORD PTR [rax+1024], r11d

; 1288 :     bs->entropy.fse.offcode_repeatMode = FSE_repeat_none;

	mov	QWORD PTR [rax+4568], 0

; 1289 :     bs->entropy.fse.matchlength_repeatMode = FSE_repeat_none;
; 1290 :     bs->entropy.fse.litlength_repeatMode = FSE_repeat_none;

	mov	DWORD PTR [rax+4576], r11d
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	edx, DWORD PTR [rbx+368]

; 227  :     void* bottom = ws->tableEnd;

	mov	r8, QWORD PTR [rbx+336]

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN318@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	edx, r15d
	mov	QWORD PTR [rbx+344], rax
	mov	DWORD PTR [rbx+368], r15d
$LN318@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	r9, QWORD PTR [rbx+352]
	mov	rax, r9
	sub	rax, rdi
	sub	rax, 32					; 00000020H

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, r8
	jae	SHORT $LN148@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, r11
	jmp	SHORT $LN147@ZSTD_reset
$LN148@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN149@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN149@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	r9, rax
$LN147@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1533 :         zc->seqStore.litStart = ZSTD_cwksp_reserve_buffer(ws, blockSize + WILDCOPY_OVERLENGTH);

	mov	QWORD PTR [rbx+584], rax

; 1534 :         zc->seqStore.maxNbLit = blockSize;

	mov	QWORD PTR [rbx+632], rdi

; 1535 : 
; 1536 :         /* buffers */
; 1537 :         zc->inBuffSize = buffInSize;

	mov	QWORD PTR [rbx+1008], r13
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN319@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	edx, r15d
	mov	QWORD PTR [rbx+344], rax
	mov	DWORD PTR [rbx+368], r15d
$LN319@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, r9
	sub	rax, r13

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, r8
	jae	SHORT $LN160@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, r11
	jmp	SHORT $LN159@ZSTD_reset
$LN160@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN161@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN161@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	r9, rax
$LN159@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1539 :         zc->outBuffSize = buffOutSize;

	mov	rcx, QWORD PTR buffOutSize$1$[rsp]
	mov	QWORD PTR [rbx+1048], rcx
	mov	QWORD PTR [rbx+1000], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN320@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	edx, r15d
	mov	QWORD PTR [rbx+344], rax
	mov	DWORD PTR [rbx+368], r15d
$LN320@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, r9
	sub	rax, rcx

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, r8
	jae	SHORT $LN172@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, r11
	jmp	SHORT $LN171@ZSTD_reset
$LN172@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN173@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN173@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	r9, rax
$LN171@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1543 :         if (params.ldmParams.enableLdm) {

	mov	edi, DWORD PTR [rsi+96]
	mov	QWORD PTR [rbx+1040], rax
	test	edi, edi
	je	SHORT $LN24@ZSTD_reset

; 1544 :             /* TODO: avoid memset? */
; 1545 :             size_t const ldmBucketSize =

	mov	ecx, DWORD PTR [rsi+100]
	mov	r10, r15
	sub	ecx, DWORD PTR [rsi+104]
	shl	r10, cl
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN321@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]
	mov	QWORD PTR [rbx+344], rax

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+368], r15d
$LN321@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	sub	r9, r10

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	r9, r8
	jae	SHORT $LN184@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	r9, r11
	jmp	SHORT $LN183@ZSTD_reset
$LN184@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	r9, QWORD PTR [rbx+344]
	jae	SHORT $LN185@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], r9
$LN185@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], r9
$LN183@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1549 :             memset(zc->ldmState.bucketOffsets, 0, ldmBucketSize);

	mov	r8, r10
	mov	QWORD PTR [rbx+696], r9
	xor	edx, edx
	mov	rcx, r9
	call	memset
	mov	r8, QWORD PTR [rbx+336]
	xor	r11d, r11d
	mov	edx, DWORD PTR [rbx+368]
	mov	r9, QWORD PTR [rbx+352]
$LN24@ZSTD_reset:

; 2719 :     RETURN_ERROR_IF(cctx->stage != ZSTDcs_init, stage_wrong,

	cmp	DWORD PTR [rbx], 1
	jne	SHORT $LN193@ZSTD_reset

; 2720 :                     "wrong cctx stage");
; 2721 :     RETURN_ERROR_IF(cctx->appliedParams.ldmParams.enableLdm,

	cmp	DWORD PTR [rbx+256], 0
	jne	SHORT $LN193@ZSTD_reset

; 2722 :                     parameter_unsupported,
; 2723 :                     "incompatible with ldm");
; 2724 :     cctx->externSeqStore.seq = seq;

	mov	QWORD PTR [rbx+728], r11

; 2725 :     cctx->externSeqStore.size = nbSeq;

	mov	QWORD PTR [rbx+744], r11

; 2726 :     cctx->externSeqStore.capacity = nbSeq;

	mov	QWORD PTR [rbx+752], r11

; 2727 :     cctx->externSeqStore.pos = 0;

	mov	QWORD PTR [rbx+736], r11
$LN193@ZSTD_reset:

; 1550 :         }
; 1551 : 
; 1552 :         /* sequences storage */
; 1553 :         ZSTD_referenceExternalSequences(zc, NULL, 0);
; 1554 :         zc->seqStore.maxNbSeq = maxNbSeq;

	mov	rcx, QWORD PTR maxNbSeq$1$[rsp]
	mov	QWORD PTR [rbx+624], rcx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN322@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	edx, r15d
	mov	QWORD PTR [rbx+344], rax
	mov	DWORD PTR [rbx+368], r15d
$LN322@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, r9
	sub	rax, rcx

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, r8
	jae	SHORT $LN202@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, r11
	jmp	SHORT $LN201@ZSTD_reset
$LN202@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN203@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN203@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	r9, rax
$LN201@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1555 :         zc->seqStore.llCode = ZSTD_cwksp_reserve_buffer(ws, maxNbSeq * sizeof(BYTE));

	mov	QWORD PTR [rbx+600], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN323@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	edx, r15d
	mov	QWORD PTR [rbx+344], rax
	mov	DWORD PTR [rbx+368], r15d
$LN323@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, r9
	sub	rax, rcx

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, r8
	jae	SHORT $LN214@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, r11
	jmp	SHORT $LN213@ZSTD_reset
$LN214@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN215@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN215@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	r9, rax
$LN213@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1556 :         zc->seqStore.mlCode = ZSTD_cwksp_reserve_buffer(ws, maxNbSeq * sizeof(BYTE));

	mov	QWORD PTR [rbx+608], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 1
	jge	SHORT $LN324@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	edx, r15d
	mov	QWORD PTR [rbx+344], rax
	mov	DWORD PTR [rbx+368], r15d
$LN324@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, r9
	sub	rax, rcx

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, r8
	jae	SHORT $LN226@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, r11
	jmp	SHORT $LN225@ZSTD_reset
$LN226@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN227@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN227@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	mov	r9, rax
$LN225@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1557 :         zc->seqStore.ofCode = ZSTD_cwksp_reserve_buffer(ws, maxNbSeq * sizeof(BYTE));

	mov	QWORD PTR [rbx+616], rax
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	edx, 2
	jge	SHORT $LN244@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	edx, 1
	jge	SHORT $LN333@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]
	mov	QWORD PTR [rbx+344], rax
$LN333@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	and	r9, -4
	mov	QWORD PTR [rbx+352], r9

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	r9, QWORD PTR [rbx+344]
	jae	SHORT $LN247@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+344], r9
$LN247@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+368], 2
$LN244@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1558 :         zc->seqStore.sequencesStart = (seqDef*)ZSTD_cwksp_reserve_aligned(ws, maxNbSeq * sizeof(seqDef));

	lea	rax, QWORD PTR [rcx*8]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	sub	r9, rax

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	r9, r8
	jae	SHORT $LN240@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	r9, r11
	jmp	SHORT $LN239@ZSTD_reset
$LN240@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	r9, QWORD PTR [rbx+344]
	jae	SHORT $LN241@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], r9
$LN241@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], r9
$LN239@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1560 :         FORWARD_IF_ERROR(ZSTD_reset_matchState(

	mov	eax, DWORD PTR needsIndexReset$2$[rsp]
	lea	r8, QWORD PTR [rsi+4]
	mov	QWORD PTR [rbx+568], r9
	lea	rcx, QWORD PTR [rbx+776]
	mov	r9d, DWORD PTR crp$[rsp]
	mov	rdx, r12
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], eax
	call	ZSTD_reset_matchState
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1560 :         FORWARD_IF_ERROR(ZSTD_reset_matchState(

	ja	$LN1@ZSTD_reset

; 1561 :             &zc->blockState.matchState,
; 1562 :             ws,
; 1563 :             &params.cParams,
; 1564 :             crp,
; 1565 :             needsIndexReset,
; 1566 :             ZSTD_resetTarget_CCtx), "");
; 1567 : 
; 1568 :         /* ldm hash table */
; 1569 :         if (params.ldmParams.enableLdm) {

	test	edi, edi
	je	$LN27@ZSTD_reset

; 1571 :             size_t const ldmHSize = ((size_t)1) << params.ldmParams.hashLog;

	mov	ecx, DWORD PTR [rsi+100]
	mov	rdx, r15
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+368]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1571 :             size_t const ldmHSize = ((size_t)1) << params.ldmParams.hashLog;

	shl	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	cmp	eax, 2
	jge	SHORT $LN260@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN332@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]
	mov	QWORD PTR [rbx+344], rax
$LN332@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+352]
	and	rax, -4
	mov	QWORD PTR [rbx+352], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN263@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+344], rax
$LN263@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+368], 2
$LN260@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rcx, QWORD PTR [rbx+352]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1572 :             zc->ldmState.hashTable = (ldmEntry_t*)ZSTD_cwksp_reserve_aligned(ws, ldmHSize * sizeof(ldmEntry_t));

	lea	r8, QWORD PTR [rdx*8]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	sub	rcx, r8

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rcx, QWORD PTR [rbx+336]
	jae	SHORT $LN256@ZSTD_reset

; 243  :         return NULL;

	xor	edi, edi
	mov	DWORD PTR [rbx+360], r15d
	mov	ecx, edi
	jmp	SHORT $LN255@ZSTD_reset
$LN256@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rcx, QWORD PTR [rbx+344]
	jae	SHORT $LN257@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rcx
$LN257@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rcx

; 249  : 
; 250  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 251  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 252  :      * either size. */
; 253  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 254  :     __asan_unpoison_memory_region(alloc, bytes);
; 255  : #endif
; 256  : 
; 257  :     return alloc;

	xor	edi, edi
$LN255@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1573 :             memset(zc->ldmState.hashTable, 0, ldmHSize * sizeof(ldmEntry_t));

	xor	edx, edx
	mov	QWORD PTR [rbx+680], rcx
	call	memset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 191  :     if (phase > ws->phase) {

	mov	eax, DWORD PTR [rbx+368]
	cmp	eax, 2
	jge	SHORT $LN274@ZSTD_reset

; 192  :         if (ws->phase < ZSTD_cwksp_alloc_buffers &&

	cmp	eax, 1
	jge	SHORT $LN331@ZSTD_reset

; 193  :                 phase >= ZSTD_cwksp_alloc_buffers) {
; 194  :             ws->tableValidEnd = ws->objectEnd;

	mov	rax, QWORD PTR [rbx+328]
	mov	QWORD PTR [rbx+344], rax
$LN331@ZSTD_reset:

; 195  :         }
; 196  :         if (ws->phase < ZSTD_cwksp_alloc_aligned &&
; 197  :                 phase >= ZSTD_cwksp_alloc_aligned) {
; 198  :             /* If unaligned allocations down from a too-large top have left us
; 199  :              * unaligned, we need to realign our alloc ptr. Technically, this
; 200  :              * can consume space that is unaccounted for in the neededSpace
; 201  :              * calculation. However, I believe this can only happen when the
; 202  :              * workspace is too large, and specifically when it is too large
; 203  :              * by a larger margin than the space that will be consumed. */
; 204  :             /* TODO: cleaner, compiler warning friendly way to do this??? */
; 205  :             ws->allocStart = (BYTE*)ws->allocStart - ((size_t)ws->allocStart & (sizeof(U32)-1));

	mov	rax, QWORD PTR [rbx+352]
	and	rax, -4
	mov	QWORD PTR [rbx+352], rax

; 206  :             if (ws->allocStart < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN277@ZSTD_reset

; 207  :                 ws->tableValidEnd = ws->allocStart;

	mov	QWORD PTR [rbx+344], rax
$LN277@ZSTD_reset:

; 208  :             }
; 209  :         }
; 210  :         ws->phase = phase;

	mov	DWORD PTR [rbx+368], 2
$LN274@ZSTD_reset:

; 229  :     alloc = (BYTE *)ws->allocStart - bytes;

	mov	rax, QWORD PTR [rbx+352]
	sub	rax, QWORD PTR tv2966[rsp]

; 230  : 
; 231  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 232  :     /* over-reserve space */
; 233  :     alloc = (BYTE *)alloc - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 234  : #endif
; 235  : 
; 236  :     DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
; 237  :         alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
; 238  :     ZSTD_cwksp_assert_internal_consistency(ws);
; 239  :     assert(alloc >= bottom);
; 240  :     if (alloc < bottom) {

	cmp	rax, QWORD PTR [rbx+336]
	jae	SHORT $LN270@ZSTD_reset

; 241  :         DEBUGLOG(4, "cwksp: alloc failed!");
; 242  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], r15d

; 243  :         return NULL;

	mov	rax, rdi
	jmp	SHORT $LN269@ZSTD_reset
$LN270@ZSTD_reset:

; 244  :     }
; 245  :     if (alloc < ws->tableValidEnd) {

	cmp	rax, QWORD PTR [rbx+344]
	jae	SHORT $LN271@ZSTD_reset

; 246  :         ws->tableValidEnd = alloc;

	mov	QWORD PTR [rbx+344], rax
$LN271@ZSTD_reset:

; 247  :     }
; 248  :     ws->allocStart = alloc;

	mov	QWORD PTR [rbx+352], rax
$LN269@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1574 :             zc->ldmSequences = (rawSeq*)ZSTD_cwksp_reserve_aligned(ws, maxNbLdmSeq * sizeof(rawSeq));

	mov	QWORD PTR [rbx+712], rax

; 1575 :             zc->maxNbLdmSequences = maxNbLdmSeq;

	mov	rax, QWORD PTR maxNbLdmSeq$1$[rsp]
	mov	QWORD PTR [rbx+720], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 923  :     window->base = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294966450
	mov	QWORD PTR [rbx+656], rax

; 924  :     window->dictBase = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294966449
	mov	QWORD PTR [rbx+664], rax

; 925  :     window->dictLimit = 1;    /* start from 1, so that 1st position is valid */
; 926  :     window->lowLimit = 1;     /* it ensures first and later CCtx usages compress the same */
; 927  :     window->nextSrc = window->base + 1;   /* see issue #1241 */

	lea	rax, OFFSET FLAT:$SG4294966450+1
	mov	QWORD PTR [rbx+648], rax

; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rbx+676], r15d

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rbx+672], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1579 :             zc->ldmState.loadedDictEnd = 0;

	mov	DWORD PTR [rbx+688], edi
$LN27@ZSTD_reset:

; 1580 :         }
; 1581 : 
; 1582 :         DEBUGLOG(3, "wksp: finished allocating, %zd bytes remain available", ZSTD_cwksp_available_space(ws));
; 1583 :         zc->initialized = 1;

	mov	DWORD PTR [rbx+564], r15d

; 1584 : 
; 1585 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_reset
$LN317@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 328  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], 1

; 329  :         return NULL;

	mov	QWORD PTR [rbx+768], r11

; 194  :             ws->tableValidEnd = ws->objectEnd;

	jmp	SHORT $LN334@ZSTD_reset
$LN291@ZSTD_reset:

; 328  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+360], 1

; 329  :         return NULL;

	mov	QWORD PTR [rbx+760], r11
$LN334@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1507 :                 RETURN_ERROR_IF(zc->blockState.nextCBlock == NULL, memory_allocation, "couldn't allocate entropyWorkspace");

	mov	rax, -64				; ffffffffffffffc0H
$LN1@ZSTD_reset:

; 1586 :     }
; 1587 : }

	add	rsp, 200				; 000000c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_resetCCtx_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 8
ZSTD_invalidateRepCodes PROC

; 1594 :     int i;
; 1595 :     for (i=0; i<ZSTD_REP_NUM; i++) cctx->blockState.prevCBlock->rep[i] = 0;

	mov	rax, QWORD PTR [rcx+760]
	xor	edx, edx
	mov	DWORD PTR [rax+4580], edx
	mov	rax, QWORD PTR [rcx+760]
	mov	DWORD PTR [rax+4584], edx
	mov	rax, QWORD PTR [rcx+760]
	mov	DWORD PTR [rax+4588], edx

; 1596 :     assert(!ZSTD_window_hasExtDict(cctx->blockState.matchState.window));
; 1597 : }

	ret	0
ZSTD_invalidateRepCodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cdict$ = 8
params$ = 16
pledgedSrcSize$ = 24
ZSTD_shouldAttachDict PROC

; 1620 :     size_t cutoff = attachDictSizeCutoffs[cdict->matchState.cParams.strategy];

	movsxd	rax, DWORD PTR [rcx+296]
	lea	rcx, OFFSET FLAT:attachDictSizeCutoffs

; 1621 :     return ( pledgedSrcSize <= cutoff

	cmp	r8, QWORD PTR [rcx+rax*8]
	jbe	SHORT $LN3@ZSTD_shoul
	cmp	r8, -1
	je	SHORT $LN3@ZSTD_shoul
	cmp	DWORD PTR [rdx+68], 1
	jne	SHORT $LN4@ZSTD_shoul
$LN3@ZSTD_shoul:
	cmp	DWORD PTR [rdx+68], 2
	je	SHORT $LN4@ZSTD_shoul
	cmp	DWORD PTR [rdx+48], 0
	jne	SHORT $LN4@ZSTD_shoul
	mov	eax, 1

; 1622 :           || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
; 1623 :           || params->attachDictPref == ZSTD_dictForceAttach )
; 1624 :         && params->attachDictPref != ZSTD_dictForceCopy
; 1625 :         && !params->forceWindow; /* dictMatchState isn't correctly
; 1626 :                                  * handled in _enforceMaxDist */
; 1627 : }

	ret	0
$LN4@ZSTD_shoul:

; 1621 :     return ( pledgedSrcSize <= cutoff

	xor	eax, eax

; 1622 :           || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
; 1623 :           || params->attachDictPref == ZSTD_dictForceAttach )
; 1624 :         && params->attachDictPref != ZSTD_dictForceCopy
; 1625 :         && !params->forceWindow; /* dictMatchState isn't correctly
; 1626 :                                  * handled in _enforceMaxDist */
; 1627 : }

	ret	0
ZSTD_shouldAttachDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 80
cctx$ = 240
cdict$ = 248
params$ = 256
pledgedSrcSize$ = 264
zbuff$ = 272
ZSTD_resetCCtx_byAttachingCDict PROC

; 1635 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H

; 1636 :     {   const ZSTD_compressionParameters* const cdict_cParams = &cdict->matchState.cParams;
; 1637 :         unsigned const windowLog = params.cParams.windowLog;
; 1638 :         assert(windowLog != 0);
; 1639 :         /* Resize working context table params for input only, since the dict
; 1640 :          * has its own tables. */
; 1641 :         /* pledgeSrcSize == 0 means 0! */
; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	movups	xmm0, XMMWORD PTR [rdx+272]
	mov	ebp, DWORD PTR [r8+4]
	mov	r11, r9
	mov	esi, DWORD PTR [rdx+296]

; 1045 :       && (dictSize < maxWindowResize) )  {

	xor	r10d, r10d

; 1636 :     {   const ZSTD_compressionParameters* const cdict_cParams = &cdict->matchState.cParams;
; 1637 :         unsigned const windowLog = params.cParams.windowLog;
; 1638 :         assert(windowLog != 0);
; 1639 :         /* Resize working context table params for input only, since the dict
; 1640 :          * has its own tables. */
; 1641 :         /* pledgeSrcSize == 0 means 0! */
; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r9, r8
	mov	rdi, rdx
	mov	rbx, rcx

; 1045 :       && (dictSize < maxWindowResize) )  {

	cmp	r11, 1073741824				; 40000000H
	jae	SHORT $LN29@ZSTD_reset

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	cmp	r11d, 64				; 00000040H
	jae	SHORT $LN19@ZSTD_reset

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	mov	edx, DWORD PTR $T1[rsp]
	mov	eax, 6
	cmp	edx, eax
	cmova	edx, eax
	jmp	SHORT $LN14@ZSTD_reset
$LN19@ZSTD_reset:
	mov	edx, DWORD PTR $T1[rsp]
	lea	eax, DWORD PTR [r11-1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	inc	eax

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	cmp	edx, eax
	cmova	edx, eax
	jmp	SHORT $LN14@ZSTD_reset
$LN29@ZSTD_reset:

; 1023 : }
; 1024 : 
; 1025 : /** ZSTD_adjustCParams_internal() :
; 1026 :  *  optimize `cPar` for a specified input (`srcSize` and `dictSize`).
; 1027 :  *  mostly downsize to reduce memory consumption and initialization latency.
; 1028 :  * `srcSize` can be ZSTD_CONTENTSIZE_UNKNOWN when not known.
; 1029 :  *  note : `srcSize==0` means 0!
; 1030 :  *  condition : cPar is presumed validated (can be checked using ZSTD_checkCParams()). */
; 1031 : static ZSTD_compressionParameters
; 1032 : ZSTD_adjustCParams_internal(ZSTD_compressionParameters cPar,
; 1033 :                             unsigned long long srcSize,
; 1034 :                             size_t dictSize)
; 1035 : {
; 1036 :     static const U64 minSrcSize = 513; /* (1<<9) + 1 */
; 1037 :     static const U64 maxWindowResize = 1ULL << (ZSTD_WINDOWLOG_MAX-1);
; 1038 :     assert(ZSTD_checkCParams(cPar)==0);
; 1039 : 
; 1040 :     if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)
; 1041 :         srcSize = minSrcSize;
; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	mov	edx, DWORD PTR $T1[rsp]
$LN14@ZSTD_reset:

; 1051 :     }
; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	eax, DWORD PTR $T1[rsp+8]
	lea	ecx, DWORD PTR [rdx+1]
	cmp	eax, ecx
	cmova	eax, ecx

; 1022 :     return hashLog - btScale;

	mov	ecx, DWORD PTR $T1[rsp+4]
	cmp	esi, 6

; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	DWORD PTR $T1[rsp+8], eax

; 1022 :     return hashLog - btScale;

	mov	r8d, ecx
	setae	r10b
	sub	r8d, r10d

; 1054 :         if (cycleLog > cPar.windowLog)

	cmp	r8d, edx
	jbe	SHORT $LN16@ZSTD_reset

; 1055 :             cPar.chainLog -= (cycleLog - cPar.windowLog);

	mov	eax, edx
	sub	eax, r8d
	add	ecx, eax
	mov	DWORD PTR $T1[rsp+4], ecx
$LN16@ZSTD_reset:

; 1636 :     {   const ZSTD_compressionParameters* const cdict_cParams = &cdict->matchState.cParams;
; 1637 :         unsigned const windowLog = params.cParams.windowLog;
; 1638 :         assert(windowLog != 0);
; 1639 :         /* Resize working context table params for input only, since the dict
; 1640 :          * has its own tables. */
; 1641 :         /* pledgeSrcSize == 0 means 0! */
; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	movsd	xmm1, QWORD PTR [rdi+288]

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	eax, 10
	cmp	edx, eax

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	mov	r8, r11
	mov	rcx, rbx

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmovb	edx, eax

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	mov	eax, DWORD PTR zbuff$[rsp]

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	DWORD PTR $T1[rsp], edx

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	lea	rdx, QWORD PTR $T2[rsp]
	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movups	XMMWORD PTR [r9+4], xmm0
	mov	DWORD PTR [rsp+32], eax
	movsd	QWORD PTR [r9+20], xmm1
	mov	DWORD PTR [r9+28], esi
	mov	DWORD PTR [r9+4], ebp
	movaps	xmm0, XMMWORD PTR [r9]
	movaps	xmm1, XMMWORD PTR [r9+16]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [r9+32]
	movaps	XMMWORD PTR $T2[rsp+32], xmm0
	movaps	xmm0, XMMWORD PTR [r9+64]
	movaps	XMMWORD PTR $T2[rsp+16], xmm1
	movaps	xmm1, XMMWORD PTR [r9+48]
	movaps	XMMWORD PTR $T2[rsp+64], xmm0
	movaps	xmm0, XMMWORD PTR [r9+96]
	movaps	XMMWORD PTR $T2[rsp+48], xmm1
	movaps	xmm1, XMMWORD PTR [r9+80]
	movaps	XMMWORD PTR $T2[rsp+96], xmm0
	movaps	xmm0, XMMWORD PTR [r9+128]
	movaps	XMMWORD PTR $T2[rsp+80], xmm1
	movaps	xmm1, XMMWORD PTR [r9+112]
	xor	r9d, r9d
	movaps	XMMWORD PTR $T2[rsp+128], xmm0
	movaps	XMMWORD PTR $T2[rsp+112], xmm1
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	ja	SHORT $LN1@ZSTD_reset

; 1645 :                                                  ZSTDcrp_makeClean, zbuff), "");
; 1646 :         assert(cctx->appliedParams.cParams.strategy == cdict_cParams->strategy);
; 1647 :     }
; 1648 : 
; 1649 :     {   const U32 cdictEnd = (U32)( cdict->matchState.window.nextSrc

	mov	edx, DWORD PTR [rdi+88]
	lea	rcx, QWORD PTR [rdi+88]
	sub	edx, DWORD PTR [rdi+96]

; 1650 :                                   - cdict->matchState.window.base);
; 1651 :         const U32 cdictLen = cdictEnd - cdict->matchState.window.dictLimit;

	cmp	edx, DWORD PTR [rdi+112]

; 1652 :         if (cdictLen == 0) {

	je	SHORT $LN8@ZSTD_reset

; 1653 :             /* don't even attach dictionaries with no contents */
; 1654 :             DEBUGLOG(4, "skipping attaching empty dictionary");
; 1655 :         } else {
; 1656 :             DEBUGLOG(4, "attaching dictionary into context");
; 1657 :             cctx->blockState.matchState.dictMatchState = &cdict->matchState;
; 1658 : 
; 1659 :             /* prep working match state so dict matches never have negative indices
; 1660 :              * when they are translated to the working context's index space. */
; 1661 :             if (cctx->blockState.matchState.window.dictLimit < cdictEnd) {

	mov	eax, DWORD PTR [rbx+800]
	mov	QWORD PTR [rbx+952], rcx
	cmp	eax, edx
	jae	SHORT $LN27@ZSTD_reset

; 1662 :                 cctx->blockState.matchState.window.nextSrc =

	mov	rcx, QWORD PTR [rbx+784]
	mov	eax, edx
	add	rax, rcx
	mov	QWORD PTR [rbx+776], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	sub	eax, ecx

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rbx+804], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rbx+800], eax
$LN27@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1667 :             cctx->blockState.matchState.loadedDictEnd = cctx->blockState.matchState.window.dictLimit;

	mov	DWORD PTR [rbx+808], eax
$LN8@ZSTD_reset:

; 1668 :     }   }
; 1669 : 
; 1670 :     cctx->dictID = cdict->dictID;

	mov	eax, DWORD PTR [rdi+4920]

; 1671 : 
; 1672 :     /* copy block state */
; 1673 :     memcpy(cctx->blockState.prevCBlock, &cdict->cBlockState, sizeof(cdict->cBlockState));

	lea	rdx, QWORD PTR [rdi+304]
	mov	rcx, QWORD PTR [rbx+760]
	mov	r8d, 4592				; 000011f0H
	mov	DWORD PTR [rbx+304], eax
	call	memcpy

; 1674 : 
; 1675 :     return 0;

	xor	eax, eax
$LN1@ZSTD_reset:

; 1676 : }

	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
ZSTD_resetCCtx_byAttachingCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
cctx$ = 208
cdict$ = 216
params$ = 224
pledgedSrcSize$ = 232
zbuff$ = 240
ZSTD_resetCCtx_byCopyingCDict PROC

; 1683 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	sub	rsp, 192				; 000000c0H

; 1684 :     const ZSTD_compressionParameters *cdict_cParams = &cdict->matchState.cParams;
; 1685 : 
; 1686 :     DEBUGLOG(4, "copying dictionary into context");
; 1687 : 
; 1688 :     {   unsigned const windowLog = params.cParams.windowLog;

	mov	r10d, DWORD PTR [r8+4]
	mov	r11, r9

; 1689 :         assert(windowLog != 0);
; 1690 :         /* Copy only compression parameters related to tables. */
; 1691 :         params.cParams = *cdict_cParams;

	movups	xmm0, XMMWORD PTR [rdx+272]
	mov	rdi, rdx
	mov	eax, DWORD PTR [rdx+296]
	movsd	xmm1, QWORD PTR [rdx+288]

; 1693 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	mov	ebp, 1
	movups	XMMWORD PTR [r8+4], xmm0
	lea	rdx, QWORD PTR $T1[rsp]
	mov	r9d, ebp
	movsd	QWORD PTR [r8+20], xmm1
	mov	rbx, rcx
	mov	DWORD PTR [r8+28], eax
	mov	eax, DWORD PTR zbuff$[rsp]
	mov	DWORD PTR [r8+4], r10d
	movaps	xmm0, XMMWORD PTR [r8]
	movaps	xmm1, XMMWORD PTR [r8+16]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [r8+32]
	movaps	XMMWORD PTR $T1[rsp+32], xmm0
	movaps	xmm0, XMMWORD PTR [r8+64]
	movaps	XMMWORD PTR $T1[rsp+16], xmm1
	movaps	xmm1, XMMWORD PTR [r8+48]
	movaps	XMMWORD PTR $T1[rsp+64], xmm0
	movaps	xmm0, XMMWORD PTR [r8+96]
	movaps	XMMWORD PTR $T1[rsp+48], xmm1
	movaps	xmm1, XMMWORD PTR [r8+80]
	movaps	XMMWORD PTR $T1[rsp+96], xmm0
	movaps	xmm0, XMMWORD PTR [r8+128]
	movaps	XMMWORD PTR $T1[rsp+80], xmm1
	movaps	xmm1, XMMWORD PTR [r8+112]
	mov	r8, r11
	movaps	XMMWORD PTR $T1[rsp+128], xmm0
	movaps	XMMWORD PTR $T1[rsp+112], xmm1
	mov	DWORD PTR [rsp+32], eax
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1693 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	ja	$LN1@ZSTD_reset

; 1694 :                                                  ZSTDcrp_leaveDirty, zbuff), "");
; 1695 :         assert(cctx->appliedParams.cParams.strategy == cdict_cParams->strategy);
; 1696 :         assert(cctx->appliedParams.cParams.hashLog == cdict_cParams->hashLog);
; 1697 :         assert(cctx->appliedParams.cParams.chainLog == cdict_cParams->chainLog);
; 1698 :     }
; 1699 : 
; 1700 :     ZSTD_cwksp_mark_tables_dirty(&cctx->workspace);

	mov	rax, QWORD PTR [rbx+328]
	mov	QWORD PTR [rsp+208], rsi
	mov	QWORD PTR [rsp+216], r14

; 1701 : 
; 1702 :     /* copy tables */
; 1703 :     {   size_t const chainSize = (cdict_cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cdict_cParams->chainLog);

	xor	r14d, r14d
	mov	QWORD PTR [rbx+344], rax
	cmp	DWORD PTR [rdi+296], ebp
	jne	SHORT $LN8@ZSTD_reset
	mov	esi, r14d
	jmp	SHORT $LN9@ZSTD_reset
$LN8@ZSTD_reset:
	mov	ecx, DWORD PTR [rdi+276]
	mov	rsi, rbp
	shl	rsi, cl
$LN9@ZSTD_reset:

; 1704 :         size_t const hSize =  (size_t)1 << cdict_cParams->hashLog;

	mov	ecx, DWORD PTR [rdi+280]
	mov	r8, rbp

; 1705 : 
; 1706 :         memcpy(cctx->blockState.matchState.hashTable,

	mov	rdx, QWORD PTR [rdi+136]
	shl	r8, cl
	mov	rcx, QWORD PTR [rbx+824]
	shl	r8, 2
	call	memcpy

; 1707 :                cdict->matchState.hashTable,
; 1708 :                hSize * sizeof(U32));
; 1709 :         memcpy(cctx->blockState.matchState.chainTable,

	mov	rdx, QWORD PTR [rdi+152]
	lea	r8, QWORD PTR [rsi*4]
	mov	rcx, QWORD PTR [rbx+840]
	call	memcpy

; 1710 :                cdict->matchState.chainTable,
; 1711 :                chainSize * sizeof(U32));
; 1712 :     }
; 1713 : 
; 1714 :     /* Zero the hashTable3, since the cdict never fills it */
; 1715 :     {   int const h3log = cctx->blockState.matchState.hashLog3;

	mov	ecx, DWORD PTR [rbx+816]

; 1716 :         size_t const h3Size = h3log ? ((size_t)1 << h3log) : 0;
; 1717 :         assert(cdict->matchState.hashLog3 == 0);
; 1718 :         memset(cctx->blockState.matchState.hashTable3, 0, h3Size * sizeof(U32));

	shl	rbp, cl
	test	ecx, ecx
	mov	rcx, QWORD PTR [rbx+832]
	cmove	rbp, r14
	xor	edx, edx
	shl	rbp, 2
	mov	r8, rbp
	call	memset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 369  :     if (ws->tableValidEnd < ws->tableEnd) {

	mov	rax, QWORD PTR [rbx+336]
	mov	r14, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+208]
	cmp	QWORD PTR [rbx+344], rax
	jae	SHORT $LN15@ZSTD_reset

; 370  :         ws->tableValidEnd = ws->tableEnd;

	mov	QWORD PTR [rbx+344], rax
$LN15@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1726 :         dstMatchState->window       = srcMatchState->window;

	movups	xmm0, XMMWORD PTR [rdi+88]

; 1727 :         dstMatchState->nextToUpdate = srcMatchState->nextToUpdate;
; 1728 :         dstMatchState->loadedDictEnd= srcMatchState->loadedDictEnd;
; 1729 :     }
; 1730 : 
; 1731 :     cctx->dictID = cdict->dictID;
; 1732 : 
; 1733 :     /* copy block state */
; 1734 :     memcpy(cctx->blockState.prevCBlock, &cdict->cBlockState, sizeof(cdict->cBlockState));

	lea	rdx, QWORD PTR [rdi+304]
	mov	r8d, 4592				; 000011f0H
	movups	XMMWORD PTR [rbx+776], xmm0
	movups	xmm1, XMMWORD PTR [rdi+104]
	movups	XMMWORD PTR [rbx+792], xmm1
	mov	eax, DWORD PTR [rdi+124]
	mov	DWORD PTR [rbx+812], eax
	mov	eax, DWORD PTR [rdi+120]
	mov	DWORD PTR [rbx+808], eax
	mov	eax, DWORD PTR [rdi+4920]
	mov	rcx, QWORD PTR [rbx+760]
	mov	DWORD PTR [rbx+304], eax
	call	memcpy

; 1735 : 
; 1736 :     return 0;

	xor	eax, eax
$LN1@ZSTD_reset:

; 1737 : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
ZSTD_resetCCtx_byCopyingCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 80
$T3 = 80
$T4 = 224
$T5 = 224
cctx$ = 448
cdict$ = 456
params$ = 464
pledgedSrcSize$ = 472
zbuff$ = 480
ZSTD_resetCCtx_usingCDict PROC

; 1747 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rax-184]
	sub	rsp, 416				; 000001a0H
	movaps	XMMWORD PTR [rax-40], xmm6
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-56], xmm7

; 1620 :     size_t cutoff = attachDictSizeCutoffs[cdict->matchState.cParams.strategy];

	lea	rcx, OFFSET FLAT:attachDictSizeCutoffs
	movaps	XMMWORD PTR [rax-72], xmm8

; 1747 : {

	mov	r10, r9

; 1620 :     size_t cutoff = attachDictSizeCutoffs[cdict->matchState.cParams.strategy];

	movsxd	rax, DWORD PTR [rdx+296]

; 1747 : {

	mov	rdi, rdx

; 1621 :     return ( pledgedSrcSize <= cutoff

	cmp	r9, QWORD PTR [rcx+rax*8]
	jbe	SHORT $LN7@ZSTD_reset
	cmp	r9, -1
	je	SHORT $LN7@ZSTD_reset
	cmp	DWORD PTR [r8+68], 1
	jne	$LN8@ZSTD_reset
$LN7@ZSTD_reset:
	cmp	DWORD PTR [r8+68], 2
	je	$LN8@ZSTD_reset
	cmp	DWORD PTR [r8+48], 0
	jne	$LN8@ZSTD_reset

; 1748 : 
; 1749 :     DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
; 1750 :                 (unsigned)pledgedSrcSize);
; 1751 : 
; 1752 :     if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
; 1753 :         return ZSTD_resetCCtx_byAttachingCDict(

	movaps	xmm1, XMMWORD PTR [r8]

; 1045 :       && (dictSize < maxWindowResize) )  {

	xor	esi, esi

; 1748 : 
; 1749 :     DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
; 1750 :                 (unsigned)pledgedSrcSize);
; 1751 : 
; 1752 :     if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
; 1753 :         return ZSTD_resetCCtx_byAttachingCDict(

	movaps	xmm0, XMMWORD PTR [r8+16]

; 1637 :         unsigned const windowLog = params.cParams.windowLog;

	movq	r9, xmm1

; 1748 : 
; 1749 :     DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
; 1750 :                 (unsigned)pledgedSrcSize);
; 1751 : 
; 1752 :     if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
; 1753 :         return ZSTD_resetCCtx_byAttachingCDict(

	movaps	xmm2, XMMWORD PTR [r8+32]
	movaps	xmm3, XMMWORD PTR [r8+48]
	movaps	xmm4, XMMWORD PTR [r8+64]
	movaps	xmm5, XMMWORD PTR [r8+80]
	movaps	xmm6, XMMWORD PTR [r8+96]
	movaps	xmm7, XMMWORD PTR [r8+112]
	movaps	xmm8, XMMWORD PTR [r8+128]

; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	mov	r11d, DWORD PTR [rdx+296]

; 1748 : 
; 1749 :     DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
; 1750 :                 (unsigned)pledgedSrcSize);
; 1751 : 
; 1752 :     if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
; 1753 :         return ZSTD_resetCCtx_byAttachingCDict(

	movaps	XMMWORD PTR $T5[rbp-240], xmm0

; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	movups	xmm0, XMMWORD PTR [rdx+272]
	shr	r9, 32					; 00000020H

; 1748 : 
; 1749 :     DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
; 1750 :                 (unsigned)pledgedSrcSize);
; 1751 : 
; 1752 :     if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
; 1753 :         return ZSTD_resetCCtx_byAttachingCDict(

	movaps	XMMWORD PTR $T5[rbp-256], xmm1

; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	movsd	xmm1, QWORD PTR [rdx+288]
	movaps	XMMWORD PTR $T1[rsp], xmm0

; 1045 :       && (dictSize < maxWindowResize) )  {

	cmp	r10, 1073741824				; 40000000H
	jae	SHORT $LN55@ZSTD_reset

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	cmp	r10d, 64				; 00000040H
	jae	SHORT $LN28@ZSTD_reset

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	mov	edx, DWORD PTR $T1[rsp]
	mov	eax, 6
	cmp	edx, eax
	cmova	edx, eax
	jmp	SHORT $LN23@ZSTD_reset
$LN28@ZSTD_reset:
	mov	edx, DWORD PTR $T1[rsp]
	lea	eax, DWORD PTR [r10-1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, esi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	inc	eax

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	cmp	edx, eax
	cmova	edx, eax
	jmp	SHORT $LN23@ZSTD_reset
$LN55@ZSTD_reset:

; 1023 : }
; 1024 : 
; 1025 : /** ZSTD_adjustCParams_internal() :
; 1026 :  *  optimize `cPar` for a specified input (`srcSize` and `dictSize`).
; 1027 :  *  mostly downsize to reduce memory consumption and initialization latency.
; 1028 :  * `srcSize` can be ZSTD_CONTENTSIZE_UNKNOWN when not known.
; 1029 :  *  note : `srcSize==0` means 0!
; 1030 :  *  condition : cPar is presumed validated (can be checked using ZSTD_checkCParams()). */
; 1031 : static ZSTD_compressionParameters
; 1032 : ZSTD_adjustCParams_internal(ZSTD_compressionParameters cPar,
; 1033 :                             unsigned long long srcSize,
; 1034 :                             size_t dictSize)
; 1035 : {
; 1036 :     static const U64 minSrcSize = 513; /* (1<<9) + 1 */
; 1037 :     static const U64 maxWindowResize = 1ULL << (ZSTD_WINDOWLOG_MAX-1);
; 1038 :     assert(ZSTD_checkCParams(cPar)==0);
; 1039 : 
; 1040 :     if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)
; 1041 :         srcSize = minSrcSize;
; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	mov	edx, DWORD PTR $T1[rsp]
$LN23@ZSTD_reset:

; 1051 :     }
; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	eax, DWORD PTR $T1[rsp+8]
	lea	ecx, DWORD PTR [rdx+1]
	cmp	eax, ecx
	cmova	eax, ecx

; 1022 :     return hashLog - btScale;

	mov	ecx, DWORD PTR $T1[rsp+4]

; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	DWORD PTR $T1[rsp+8], eax

; 1021 :     U32 const btScale = ((U32)strat >= (U32)ZSTD_btlazy2);

	cmp	r11d, 6
	mov	eax, esi

; 1022 :     return hashLog - btScale;

	mov	r8d, ecx
	setae	al
	sub	r8d, eax

; 1054 :         if (cycleLog > cPar.windowLog)

	cmp	r8d, edx
	jbe	SHORT $LN25@ZSTD_reset

; 1055 :             cPar.chainLog -= (cycleLog - cPar.windowLog);

	mov	eax, edx
	sub	eax, r8d
	add	ecx, eax
	mov	DWORD PTR $T1[rsp+4], ecx
$LN25@ZSTD_reset:

; 1056 :     }
; 1057 : 
; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	eax, 10

; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	movsd	QWORD PTR $T5[rbp-236], xmm1

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmp	edx, eax

; 1642 :         params.cParams = ZSTD_adjustCParams_internal(*cdict_cParams, pledgedSrcSize, 0);

	mov	DWORD PTR $T5[rbp-228], r11d

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	mov	r8, r10
	movaps	XMMWORD PTR $T3[rsp+32], xmm2

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmovb	edx, eax

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	movaps	XMMWORD PTR $T3[rbp-208], xmm3
	mov	eax, DWORD PTR zbuff$[rbp-256]
	mov	rcx, rbx

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	DWORD PTR $T1[rsp], edx

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	lea	rdx, QWORD PTR $T3[rsp]
	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movups	XMMWORD PTR $T5[rbp-252], xmm0
	mov	DWORD PTR $T5[rbp-252], r9d
	xor	r9d, r9d
	movaps	xmm0, XMMWORD PTR $T5[rbp-256]
	movaps	xmm1, XMMWORD PTR $T5[rbp-240]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movaps	XMMWORD PTR $T3[rsp+16], xmm1
	movaps	XMMWORD PTR $T3[rbp-192], xmm4
	movaps	XMMWORD PTR $T3[rbp-176], xmm5
	movaps	XMMWORD PTR $T3[rbp-160], xmm6
	movaps	XMMWORD PTR $T3[rbp-144], xmm7
	movaps	XMMWORD PTR $T3[rbp-128], xmm8
	mov	DWORD PTR [rsp+32], eax
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1644 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	ja	$LN3@ZSTD_reset

; 1645 :                                                  ZSTDcrp_makeClean, zbuff), "");
; 1646 :         assert(cctx->appliedParams.cParams.strategy == cdict_cParams->strategy);
; 1647 :     }
; 1648 : 
; 1649 :     {   const U32 cdictEnd = (U32)( cdict->matchState.window.nextSrc

	mov	edx, DWORD PTR [rdi+88]
	lea	rcx, QWORD PTR [rdi+88]
	sub	edx, DWORD PTR [rdi+96]

; 1650 :                                   - cdict->matchState.window.base);
; 1651 :         const U32 cdictLen = cdictEnd - cdict->matchState.window.dictLimit;

	cmp	edx, DWORD PTR [rdi+112]

; 1652 :         if (cdictLen == 0) {

	je	SHORT $LN17@ZSTD_reset

; 1653 :             /* don't even attach dictionaries with no contents */
; 1654 :             DEBUGLOG(4, "skipping attaching empty dictionary");
; 1655 :         } else {
; 1656 :             DEBUGLOG(4, "attaching dictionary into context");
; 1657 :             cctx->blockState.matchState.dictMatchState = &cdict->matchState;
; 1658 : 
; 1659 :             /* prep working match state so dict matches never have negative indices
; 1660 :              * when they are translated to the working context's index space. */
; 1661 :             if (cctx->blockState.matchState.window.dictLimit < cdictEnd) {

	mov	eax, DWORD PTR [rbx+800]
	mov	QWORD PTR [rbx+952], rcx
	cmp	eax, edx
	jae	SHORT $LN36@ZSTD_reset

; 1662 :                 cctx->blockState.matchState.window.nextSrc =

	mov	rcx, QWORD PTR [rbx+784]
	mov	eax, edx
	add	rax, rcx
	mov	QWORD PTR [rbx+776], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	sub	eax, ecx

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rbx+804], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rbx+800], eax
$LN36@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1667 :             cctx->blockState.matchState.loadedDictEnd = cctx->blockState.matchState.window.dictLimit;

	mov	DWORD PTR [rbx+808], eax
$LN17@ZSTD_reset:

; 1668 :     }   }
; 1669 : 
; 1670 :     cctx->dictID = cdict->dictID;

	mov	eax, DWORD PTR [rdi+4920]

; 1671 : 
; 1672 :     /* copy block state */
; 1673 :     memcpy(cctx->blockState.prevCBlock, &cdict->cBlockState, sizeof(cdict->cBlockState));

	lea	rdx, QWORD PTR [rdi+304]
	mov	rcx, QWORD PTR [rbx+760]
	mov	r8d, 4592				; 000011f0H
	mov	DWORD PTR [rbx+304], eax
	call	memcpy

; 1748 : 
; 1749 :     DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
; 1750 :                 (unsigned)pledgedSrcSize);
; 1751 : 
; 1752 :     if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
; 1753 :         return ZSTD_resetCCtx_byAttachingCDict(

	jmp	$LN56@ZSTD_reset
$LN8@ZSTD_reset:

; 1754 :             cctx, cdict, *params, pledgedSrcSize, zbuff);
; 1755 :     } else {
; 1756 :         return ZSTD_resetCCtx_byCopyingCDict(

	movaps	xmm1, XMMWORD PTR [r8]
	movaps	xmm0, XMMWORD PTR [r8+16]

; 1688 :     {   unsigned const windowLog = params.cParams.windowLog;

	movq	rcx, xmm1

; 1689 :         assert(windowLog != 0);
; 1690 :         /* Copy only compression parameters related to tables. */
; 1691 :         params.cParams = *cdict_cParams;

	mov	eax, DWORD PTR [rdx+296]

; 1754 :             cctx, cdict, *params, pledgedSrcSize, zbuff);
; 1755 :     } else {
; 1756 :         return ZSTD_resetCCtx_byCopyingCDict(

	movaps	xmm2, XMMWORD PTR [r8+32]
	movaps	xmm3, XMMWORD PTR [r8+48]
	movaps	xmm4, XMMWORD PTR [r8+64]
	movaps	xmm5, XMMWORD PTR [r8+80]
	movaps	xmm6, XMMWORD PTR [r8+96]
	movaps	xmm7, XMMWORD PTR [r8+112]
	movaps	xmm8, XMMWORD PTR [r8+128]

; 1693 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	mov	r8, r10

; 1754 :             cctx, cdict, *params, pledgedSrcSize, zbuff);
; 1755 :     } else {
; 1756 :         return ZSTD_resetCCtx_byCopyingCDict(

	movaps	XMMWORD PTR $T4[rbp-240], xmm0

; 1691 :         params.cParams = *cdict_cParams;

	movups	xmm0, XMMWORD PTR [rdx+272]
	shr	rcx, 32					; 00000020H

; 1754 :             cctx, cdict, *params, pledgedSrcSize, zbuff);
; 1755 :     } else {
; 1756 :         return ZSTD_resetCCtx_byCopyingCDict(

	movaps	XMMWORD PTR $T4[rbp-256], xmm1

; 1691 :         params.cParams = *cdict_cParams;

	movsd	xmm1, QWORD PTR [rdx+288]

; 1693 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	lea	rdx, QWORD PTR $T2[rsp]
	movups	XMMWORD PTR $T4[rbp-252], xmm0
	mov	DWORD PTR $T4[rbp-252], ecx
	mov	rcx, rbx
	movaps	xmm0, XMMWORD PTR $T4[rbp-256]
	mov	DWORD PTR $T4[rbp-228], eax
	mov	eax, DWORD PTR zbuff$[rbp-256]
	movsd	QWORD PTR $T4[rbp-236], xmm1
	movaps	xmm1, XMMWORD PTR $T4[rbp-240]
	mov	QWORD PTR [rsp+448], r14
	mov	r14d, 1
	mov	r9d, r14d
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movaps	XMMWORD PTR $T2[rsp+16], xmm1
	movaps	XMMWORD PTR $T2[rsp+32], xmm2
	movaps	XMMWORD PTR $T2[rbp-208], xmm3
	movaps	XMMWORD PTR $T2[rbp-192], xmm4
	movaps	XMMWORD PTR $T2[rbp-176], xmm5
	movaps	XMMWORD PTR $T2[rbp-160], xmm6
	movaps	XMMWORD PTR $T2[rbp-144], xmm7
	movaps	XMMWORD PTR $T2[rbp-128], xmm8
	mov	DWORD PTR [rsp+32], eax
	call	ZSTD_resetCCtx_internal
	mov	rsi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1693 :         FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,

	ja	$LN38@ZSTD_reset

; 1694 :                                                  ZSTDcrp_leaveDirty, zbuff), "");
; 1695 :         assert(cctx->appliedParams.cParams.strategy == cdict_cParams->strategy);
; 1696 :         assert(cctx->appliedParams.cParams.hashLog == cdict_cParams->hashLog);
; 1697 :         assert(cctx->appliedParams.cParams.chainLog == cdict_cParams->chainLog);
; 1698 :     }
; 1699 : 
; 1700 :     ZSTD_cwksp_mark_tables_dirty(&cctx->workspace);

	mov	rax, QWORD PTR [rbx+328]

; 1701 : 
; 1702 :     /* copy tables */
; 1703 :     {   size_t const chainSize = (cdict_cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cdict_cParams->chainLog);

	xor	esi, esi
	mov	QWORD PTR [rbx+344], rax
	mov	QWORD PTR [rsp+464], r15
	cmp	DWORD PTR [rdi+296], r14d
	jne	SHORT $LN45@ZSTD_reset
	mov	r15d, esi
	jmp	SHORT $LN46@ZSTD_reset
$LN45@ZSTD_reset:
	mov	ecx, DWORD PTR [rdi+276]
	mov	r15, r14
	shl	r15, cl
$LN46@ZSTD_reset:

; 1704 :         size_t const hSize =  (size_t)1 << cdict_cParams->hashLog;

	mov	ecx, DWORD PTR [rdi+280]
	mov	r8, r14

; 1705 : 
; 1706 :         memcpy(cctx->blockState.matchState.hashTable,

	mov	rdx, QWORD PTR [rdi+136]
	shl	r8, cl
	mov	rcx, QWORD PTR [rbx+824]
	shl	r8, 2
	call	memcpy

; 1707 :                cdict->matchState.hashTable,
; 1708 :                hSize * sizeof(U32));
; 1709 :         memcpy(cctx->blockState.matchState.chainTable,

	mov	rdx, QWORD PTR [rdi+152]
	lea	r8, QWORD PTR [r15*4]
	mov	rcx, QWORD PTR [rbx+840]
	call	memcpy

; 1710 :                cdict->matchState.chainTable,
; 1711 :                chainSize * sizeof(U32));
; 1712 :     }
; 1713 : 
; 1714 :     /* Zero the hashTable3, since the cdict never fills it */
; 1715 :     {   int const h3log = cctx->blockState.matchState.hashLog3;

	mov	ecx, DWORD PTR [rbx+816]

; 1716 :         size_t const h3Size = h3log ? ((size_t)1 << h3log) : 0;
; 1717 :         assert(cdict->matchState.hashLog3 == 0);
; 1718 :         memset(cctx->blockState.matchState.hashTable3, 0, h3Size * sizeof(U32));

	shl	r14, cl
	test	ecx, ecx
	mov	rcx, QWORD PTR [rbx+832]
	cmove	r14, rsi
	xor	edx, edx
	shl	r14, 2
	mov	r8, r14
	call	memset
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 369  :     if (ws->tableValidEnd < ws->tableEnd) {

	mov	rax, QWORD PTR [rbx+336]
	mov	r15, QWORD PTR [rsp+464]
	cmp	QWORD PTR [rbx+344], rax
	jae	SHORT $LN52@ZSTD_reset

; 370  :         ws->tableValidEnd = ws->tableEnd;

	mov	QWORD PTR [rbx+344], rax
$LN52@ZSTD_reset:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1726 :         dstMatchState->window       = srcMatchState->window;

	movups	xmm0, XMMWORD PTR [rdi+88]

; 1727 :         dstMatchState->nextToUpdate = srcMatchState->nextToUpdate;
; 1728 :         dstMatchState->loadedDictEnd= srcMatchState->loadedDictEnd;
; 1729 :     }
; 1730 : 
; 1731 :     cctx->dictID = cdict->dictID;
; 1732 : 
; 1733 :     /* copy block state */
; 1734 :     memcpy(cctx->blockState.prevCBlock, &cdict->cBlockState, sizeof(cdict->cBlockState));

	lea	rdx, QWORD PTR [rdi+304]
	mov	r8d, 4592				; 000011f0H
	movups	XMMWORD PTR [rbx+776], xmm0
	movups	xmm1, XMMWORD PTR [rdi+104]
	movups	XMMWORD PTR [rbx+792], xmm1
	mov	ecx, DWORD PTR [rdi+124]
	mov	DWORD PTR [rbx+812], ecx
	mov	ecx, DWORD PTR [rdi+120]
	mov	DWORD PTR [rbx+808], ecx
	mov	ecx, DWORD PTR [rdi+4920]
	mov	DWORD PTR [rbx+304], ecx
	mov	rcx, QWORD PTR [rbx+760]
	call	memcpy
$LN38@ZSTD_reset:

; 1754 :             cctx, cdict, *params, pledgedSrcSize, zbuff);
; 1755 :     } else {
; 1756 :         return ZSTD_resetCCtx_byCopyingCDict(

	mov	r14, QWORD PTR [rsp+448]
$LN56@ZSTD_reset:

; 1757 :             cctx, cdict, *params, pledgedSrcSize, zbuff);
; 1758 :     }
; 1759 : }

	mov	rax, rsi
$LN3@ZSTD_reset:
	lea	r11, QWORD PTR [rsp+416]
	mov	rbx, QWORD PTR [r11+56]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_resetCCtx_usingCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
table$ = 16
size$ = 24
reducerValue$ = 32
preserveMark$ = 40
ZSTD_reduceTable_internal PROC

; 1857 : {

	sub	rsp, 8

; 1858 :     int const nbRows = (int)size / ZSTD_ROWSIZE;

	mov	eax, edx
	mov	r11d, r9d
	cdq
	mov	r10, rcx
	and	edx, 15
	add	eax, edx
	sar	eax, 4

; 1859 :     int cellNb = 0;
; 1860 :     int rowNb;
; 1861 :     assert((size & (ZSTD_ROWSIZE-1)) == 0);  /* multiple of ZSTD_ROWSIZE */
; 1862 :     assert(size < (1U<<31));   /* can be casted to int */
; 1863 : 
; 1864 : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 1865 :     /* To validate that the table re-use logic is sound, and that we don't
; 1866 :      * access table space that we haven't cleaned, we re-"poison" the table
; 1867 :      * space every time we mark it dirty.
; 1868 :      *
; 1869 :      * This function however is intended to operate on those dirty tables and
; 1870 :      * re-clean them. So when this function is used correctly, we can unpoison
; 1871 :      * the memory it operated on. This introduces a blind spot though, since
; 1872 :      * if we now try to operate on __actually__ poisoned memory, we will not
; 1873 :      * detect that. */
; 1874 :     __msan_unpoison(table, size * sizeof(U32));
; 1875 : #endif
; 1876 : 
; 1877 :     for (rowNb=0 ; rowNb < nbRows ; rowNb++) {

	test	eax, eax
	jle	$LN3@ZSTD_reduc
	mov	QWORD PTR [rsp], rbx
	xor	r9d, r9d
	mov	ebx, eax
$LL4@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	test	r11d, r11d
	je	SHORT $LN96@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4], ecx
$LN96@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4], eax
	test	r11d, r11d
	je	SHORT $LN97@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+4], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+4], ecx
$LN97@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+4]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+4], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+4], eax
	test	r11d, r11d
	je	SHORT $LN98@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+8], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+8], ecx
$LN98@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+8]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+8], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+8], eax
	test	r11d, r11d
	je	SHORT $LN99@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+12], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+12], ecx
$LN99@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+12]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+12], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+12], eax
	test	r11d, r11d
	je	SHORT $LN100@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+16], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+16], ecx
$LN100@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+16]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+16], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+16], eax
	test	r11d, r11d
	je	SHORT $LN101@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+20], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+20], ecx
$LN101@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+20]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+20], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+20], eax
	test	r11d, r11d
	je	SHORT $LN102@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+24], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+24], ecx
$LN102@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+24]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+24], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+24], eax
	test	r11d, r11d
	je	SHORT $LN103@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+28], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+28], ecx
$LN103@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+28]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+28], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+28], eax
	test	r11d, r11d
	je	SHORT $LN104@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+32], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+32], ecx
$LN104@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+32]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+32], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+32], eax
	test	r11d, r11d
	je	SHORT $LN105@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+36], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+36], ecx
$LN105@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+36]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+36], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+36], eax
	test	r11d, r11d
	je	SHORT $LN106@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+40], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+40], ecx
$LN106@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+40]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+40], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+40], eax
	test	r11d, r11d
	je	SHORT $LN107@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+44], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+44], ecx
$LN107@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+44]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+44], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+44], eax
	test	r11d, r11d
	je	SHORT $LN108@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+48], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+48], ecx
$LN108@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+48]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+48], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+48], eax
	test	r11d, r11d
	je	SHORT $LN109@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+52], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+52], ecx
$LN109@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+52]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+52], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+52], eax
	test	r11d, r11d
	je	SHORT $LN110@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+56], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+56], ecx
$LN110@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {

	mov	ecx, DWORD PTR [r10+r9*4+56]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+56], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+56], eax
	test	r11d, r11d
	je	SHORT $LN111@ZSTD_reduc

; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r10+r9*4+60], 1
	cmove	ecx, r8d

; 1882 :                 table[cellNb] += adder;

	add	DWORD PTR [r10+r9*4+60], ecx
$LN111@ZSTD_reduc:

; 1883 :             }
; 1884 :             if (table[cellNb] < reducerValue) table[cellNb] = 0;
; 1885 :             else table[cellNb] -= reducerValue;

	mov	ecx, DWORD PTR [r10+r9*4+60]
	xor	eax, eax
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+60], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4+60], eax
	add	r9, 16
	sub	rbx, 1
	jne	$LL4@ZSTD_reduc

; 1859 :     int cellNb = 0;
; 1860 :     int rowNb;
; 1861 :     assert((size & (ZSTD_ROWSIZE-1)) == 0);  /* multiple of ZSTD_ROWSIZE */
; 1862 :     assert(size < (1U<<31));   /* can be casted to int */
; 1863 : 
; 1864 : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 1865 :     /* To validate that the table re-use logic is sound, and that we don't
; 1866 :      * access table space that we haven't cleaned, we re-"poison" the table
; 1867 :      * space every time we mark it dirty.
; 1868 :      *
; 1869 :      * This function however is intended to operate on those dirty tables and
; 1870 :      * re-clean them. So when this function is used correctly, we can unpoison
; 1871 :      * the memory it operated on. This introduces a blind spot though, since
; 1872 :      * if we now try to operate on __actually__ poisoned memory, we will not
; 1873 :      * detect that. */
; 1874 :     __msan_unpoison(table, size * sizeof(U32));
; 1875 : #endif
; 1876 : 
; 1877 :     for (rowNb=0 ; rowNb < nbRows ; rowNb++) {

	mov	rbx, QWORD PTR [rsp]
$LN3@ZSTD_reduc:

; 1886 :             cellNb++;
; 1887 :     }   }
; 1888 : }

	add	rsp, 8
	ret	0
ZSTD_reduceTable_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
table$ = 8
size$ = 16
reducerValue$ = 24
ZSTD_reduceTable PROC

; 1858 :     int const nbRows = (int)size / ZSTD_ROWSIZE;

	mov	eax, edx

; 1891 : {

	mov	r10, rcx

; 1858 :     int const nbRows = (int)size / ZSTD_ROWSIZE;

	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4

; 1859 :     int cellNb = 0;
; 1860 :     int rowNb;
; 1861 :     assert((size & (ZSTD_ROWSIZE-1)) == 0);  /* multiple of ZSTD_ROWSIZE */
; 1862 :     assert(size < (1U<<31));   /* can be casted to int */
; 1863 : 
; 1864 : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 1865 :     /* To validate that the table re-use logic is sound, and that we don't
; 1866 :      * access table space that we haven't cleaned, we re-"poison" the table
; 1867 :      * space every time we mark it dirty.
; 1868 :      *
; 1869 :      * This function however is intended to operate on those dirty tables and
; 1870 :      * re-clean them. So when this function is used correctly, we can unpoison
; 1871 :      * the memory it operated on. This introduces a blind spot though, since
; 1872 :      * if we now try to operate on __actually__ poisoned memory, we will not
; 1873 :      * detect that. */
; 1874 :     __msan_unpoison(table, size * sizeof(U32));
; 1875 : #endif
; 1876 : 
; 1877 :     for (rowNb=0 ; rowNb < nbRows ; rowNb++) {

	test	eax, eax
	jle	$LN5@ZSTD_reduc
	xor	r9d, r9d
	mov	r11d, eax
	npad	4
$LL6@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {
; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;
; 1882 :                 table[cellNb] += adder;
; 1883 :             }
; 1884 :             if (table[cellNb] < reducerValue) table[cellNb] = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR [r10+r9*4]
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4], eax
	xor	eax, eax
	mov	ecx, DWORD PTR [r10+r9*4+4]
	sub	ecx, r8d
	cmp	DWORD PTR [r10+r9*4+4], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+8]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+4], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+8], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+12]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+8], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+12], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+16]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+12], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+16], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+20]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+16], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+20], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+24]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+20], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+24], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+28]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+24], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+28], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+32]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+28], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+32], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+36]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+32], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+36], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+40]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+36], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+40], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+44]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+40], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+44], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+48]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+44], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+48], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4+52]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4+48], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4+52], r8d

; 1885 :             else table[cellNb] -= reducerValue;

	lea	r9, QWORD PTR [r9+16]
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4-8]
	sub	ecx, r8d
	mov	DWORD PTR [r10+r9*4-12], eax
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4-8], r8d
	cmovae	eax, ecx
	mov	ecx, DWORD PTR [r10+r9*4-4]
	mov	DWORD PTR [r10+r9*4-8], eax
	sub	ecx, r8d
	xor	eax, eax
	cmp	DWORD PTR [r10+r9*4-4], r8d
	cmovae	eax, ecx
	mov	DWORD PTR [r10+r9*4-4], eax
	sub	r11, 1
	jne	$LL6@ZSTD_reduc
$LN5@ZSTD_reduc:

; 1892 :     ZSTD_reduceTable_internal(table, size, reducerValue, 0);
; 1893 : }

	ret	0
ZSTD_reduceTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
table$ = 8
size$ = 16
reducerValue$ = 24
ZSTD_reduceTable_btlazy2 PROC

; 1858 :     int const nbRows = (int)size / ZSTD_ROWSIZE;

	mov	eax, edx

; 1896 : {

	mov	r10, rcx

; 1858 :     int const nbRows = (int)size / ZSTD_ROWSIZE;

	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4

; 1859 :     int cellNb = 0;
; 1860 :     int rowNb;
; 1861 :     assert((size & (ZSTD_ROWSIZE-1)) == 0);  /* multiple of ZSTD_ROWSIZE */
; 1862 :     assert(size < (1U<<31));   /* can be casted to int */
; 1863 : 
; 1864 : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 1865 :     /* To validate that the table re-use logic is sound, and that we don't
; 1866 :      * access table space that we haven't cleaned, we re-"poison" the table
; 1867 :      * space every time we mark it dirty.
; 1868 :      *
; 1869 :      * This function however is intended to operate on those dirty tables and
; 1870 :      * re-clean them. So when this function is used correctly, we can unpoison
; 1871 :      * the memory it operated on. This introduces a blind spot though, since
; 1872 :      * if we now try to operate on __actually__ poisoned memory, we will not
; 1873 :      * detect that. */
; 1874 :     __msan_unpoison(table, size * sizeof(U32));
; 1875 : #endif
; 1876 : 
; 1877 :     for (rowNb=0 ; rowNb < nbRows ; rowNb++) {

	test	eax, eax
	jle	$LN5@ZSTD_reduc
	xor	r9d, r9d
	mov	r11d, eax
	npad	4
$LL6@ZSTD_reduc:

; 1878 :         int column;
; 1879 :         for (column=0; column<ZSTD_ROWSIZE; column++) {
; 1880 :             if (preserveMark) {
; 1881 :                 U32 const adder = (table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) ? reducerValue : 0;

	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4], 1
	cmove	edx, r8d
	xor	eax, eax

; 1882 :                 table[cellNb] += adder;

	add	edx, DWORD PTR [r10+r9*4]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	mov	DWORD PTR [r10+r9*4], eax
	cmp	DWORD PTR [r10+r9*4+4], 1
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+4]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4+8], 1
	mov	DWORD PTR [r10+r9*4+4], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+8]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4+12], 1
	mov	DWORD PTR [r10+r9*4+8], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+12]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4+16], 1
	mov	DWORD PTR [r10+r9*4+12], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+16]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4+20], 1
	mov	DWORD PTR [r10+r9*4+16], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+20]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4+24], 1
	mov	DWORD PTR [r10+r9*4+20], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+24]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4+28], 1
	mov	DWORD PTR [r10+r9*4+24], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4+28]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	mov	DWORD PTR [r10+r9*4+28], eax

; 1883 :             }
; 1884 :             if (table[cellNb] < reducerValue) table[cellNb] = 0;
; 1885 :             else table[cellNb] -= reducerValue;

	cmp	DWORD PTR [r10+r9*4+32], 1
	lea	r9, QWORD PTR [r9+16]
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-32]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-28], 1
	mov	DWORD PTR [r10+r9*4-32], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-28]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-24], 1
	mov	DWORD PTR [r10+r9*4-28], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-24]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-20], 1
	mov	DWORD PTR [r10+r9*4-24], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-20]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-16], 1
	mov	DWORD PTR [r10+r9*4-20], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-16]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-12], 1
	mov	DWORD PTR [r10+r9*4-16], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-12]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-8], 1
	mov	DWORD PTR [r10+r9*4-12], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-8]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	xor	edx, edx
	cmp	DWORD PTR [r10+r9*4-4], 1
	mov	DWORD PTR [r10+r9*4-8], eax
	cmove	edx, r8d
	xor	eax, eax
	add	edx, DWORD PTR [r10+r9*4-4]
	mov	ecx, edx
	sub	ecx, r8d
	cmp	edx, r8d
	cmovae	eax, ecx
	sub	r11, 1
	mov	DWORD PTR [r10+r9*4-4], eax

; 1859 :     int cellNb = 0;
; 1860 :     int rowNb;
; 1861 :     assert((size & (ZSTD_ROWSIZE-1)) == 0);  /* multiple of ZSTD_ROWSIZE */
; 1862 :     assert(size < (1U<<31));   /* can be casted to int */
; 1863 : 
; 1864 : #if defined (MEMORY_SANITIZER) && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
; 1865 :     /* To validate that the table re-use logic is sound, and that we don't
; 1866 :      * access table space that we haven't cleaned, we re-"poison" the table
; 1867 :      * space every time we mark it dirty.
; 1868 :      *
; 1869 :      * This function however is intended to operate on those dirty tables and
; 1870 :      * re-clean them. So when this function is used correctly, we can unpoison
; 1871 :      * the memory it operated on. This introduces a blind spot though, since
; 1872 :      * if we now try to operate on __actually__ poisoned memory, we will not
; 1873 :      * detect that. */
; 1874 :     __msan_unpoison(table, size * sizeof(U32));
; 1875 : #endif
; 1876 : 
; 1877 :     for (rowNb=0 ; rowNb < nbRows ; rowNb++) {

	jne	$LL6@ZSTD_reduc
$LN5@ZSTD_reduc:

; 1897 :     ZSTD_reduceTable_internal(table, size, reducerValue, 1);
; 1898 : }

	ret	0
ZSTD_reduceTable_btlazy2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ms$ = 48
params$ = 56
reducerValue$ = 64
ZSTD_reduceIndex PROC

; 1903 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rsi, rdx

; 1904 :     {   U32 const hSize = (U32)1 << params->cParams.hashLog;

	mov	ecx, DWORD PTR [rdx+12]
	mov	ebx, 1
	mov	edx, ebx
	shl	edx, cl

; 1905 :         ZSTD_reduceTable(ms->hashTable, hSize, reducerValue);

	mov	rcx, QWORD PTR [rdi+48]
	call	ZSTD_reduceTable

; 1906 :     }
; 1907 : 
; 1908 :     if (params->cParams.strategy != ZSTD_fast) {

	mov	eax, DWORD PTR [rsi+28]
	cmp	eax, ebx
	je	SHORT $LN4@ZSTD_reduc

; 1909 :         U32 const chainSize = (U32)1 << params->cParams.chainLog;

	mov	ecx, DWORD PTR [rsi+8]
	mov	edx, ebx
	shl	edx, cl

; 1910 :         if (params->cParams.strategy == ZSTD_btlazy2)

	mov	rcx, QWORD PTR [rdi+64]
	cmp	eax, 6
	jne	SHORT $LN3@ZSTD_reduc

; 1911 :             ZSTD_reduceTable_btlazy2(ms->chainTable, chainSize, reducerValue);

	call	ZSTD_reduceTable_btlazy2
	jmp	SHORT $LN4@ZSTD_reduc
$LN3@ZSTD_reduc:

; 1912 :         else
; 1913 :             ZSTD_reduceTable(ms->chainTable, chainSize, reducerValue);

	call	ZSTD_reduceTable
$LN4@ZSTD_reduc:

; 1914 :     }
; 1915 : 
; 1916 :     if (ms->hashLog3) {

	mov	ecx, DWORD PTR [rdi+40]
	test	ecx, ecx
	je	SHORT $LN5@ZSTD_reduc

; 1917 :         U32 const h3Size = (U32)1 << ms->hashLog3;

	shl	ebx, cl

; 1918 :         ZSTD_reduceTable(ms->hashTable3, h3Size, reducerValue);

	mov	rcx, QWORD PTR [rdi+56]
	mov	edx, ebx
	call	ZSTD_reduceTable
$LN5@ZSTD_reduc:

; 1919 :     }
; 1920 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_reduceIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
seqStorePtr$ = 32
ZSTD_seqToCodes PROC

; 1930 : {

$LN27:
	push	rsi
	sub	rsp, 16

; 1931 :     const seqDef* const sequences = seqStorePtr->sequencesStart;

	mov	rdx, QWORD PTR [rcx]
	mov	r10, rcx

; 1932 :     BYTE* const llCodeTable = seqStorePtr->llCode;
; 1933 :     BYTE* const ofCodeTable = seqStorePtr->ofCode;
; 1934 :     BYTE* const mlCodeTable = seqStorePtr->mlCode;
; 1935 :     U32 const nbSeq = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR [rcx+48]
	sub	rax, rdx
	mov	rsi, QWORD PTR [rcx+40]
	sar	rax, 3
	mov	QWORD PTR [rsp+48], rbp
	mov	rbp, QWORD PTR [rcx+32]

; 1936 :     U32 u;
; 1937 :     assert(nbSeq <= seqStorePtr->maxNbSeq);
; 1938 :     for (u=0; u<nbSeq; u++) {

	test	eax, eax
	je	$LN3@ZSTD_seqTo

; 1942 :         ofCodeTable[u] = (BYTE)ZSTD_highbit32(sequences[u].offset);

	mov	QWORD PTR [rsp+40], rbx
	add	rdx, 6
	mov	QWORD PTR [rsp+56], rdi
	mov	rbx, rsi
	mov	QWORD PTR [rsp+8], r14
	mov	rdi, rbp
	sub	rdi, r8
	mov	QWORD PTR [rsp], r15
	sub	rbx, r8
	mov	r11d, eax
	xor	r14d, r14d
	lea	r15, OFFSET FLAT:__ImageBase
$LL4@ZSTD_seqTo:

; 1939 :         U32 const llv = sequences[u].litLength;
; 1940 :         U32 const mlv = sequences[u].matchLength;

	movzx	eax, WORD PTR [rdx-2]
	movzx	r9d, WORD PTR [rdx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	cmp	eax, 63					; 0000003fH
	jbe	SHORT $LN10@ZSTD_seqTo
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	mov	ecx, r14d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 309  :     return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];

	add	ecx, 19
	jmp	SHORT $LN11@ZSTD_seqTo
$LN10@ZSTD_seqTo:
	movzx	ecx, BYTE PTR ?LL_Code@?1??ZSTD_LLcode@@9@9[rax+r15]
$LN11@ZSTD_seqTo:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1941 :         llCodeTable[u] = (BYTE)ZSTD_LLcode(llv);

	mov	BYTE PTR [rdi+r8], cl
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r14d
	bsr	eax, DWORD PTR [rdx-6]
	movzx	eax, al
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1942 :         ofCodeTable[u] = (BYTE)ZSTD_highbit32(sequences[u].offset);

	mov	BYTE PTR [r8], cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	cmp	r9d, 127				; 0000007fH
	jbe	SHORT $LN18@ZSTD_seqTo
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r9d
	mov	ecx, r14d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 326  :     return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];

	add	ecx, 36					; 00000024H
	jmp	SHORT $LN19@ZSTD_seqTo
$LN18@ZSTD_seqTo:
	movzx	ecx, BYTE PTR ?ML_Code@?1??ZSTD_MLcode@@9@9[r9+r15]
$LN19@ZSTD_seqTo:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1943 :         mlCodeTable[u] = (BYTE)ZSTD_MLcode(mlv);

	mov	BYTE PTR [rbx+r8], cl
	add	rdx, 8
	inc	r8
	sub	r11, 1
	jne	SHORT $LL4@ZSTD_seqTo

; 1936 :     U32 u;
; 1937 :     assert(nbSeq <= seqStorePtr->maxNbSeq);
; 1938 :     for (u=0; u<nbSeq; u++) {

	mov	r15, QWORD PTR [rsp]
	mov	r14, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+40]
$LN3@ZSTD_seqTo:

; 1944 :     }
; 1945 :     if (seqStorePtr->longLengthID==1)

	mov	eax, DWORD PTR [r10+72]
	cmp	eax, 1
	jne	SHORT $LN5@ZSTD_seqTo

; 1946 :         llCodeTable[seqStorePtr->longLengthPos] = MaxLL;

	mov	eax, DWORD PTR [r10+76]
	mov	BYTE PTR [rax+rbp], 35			; 00000023H
	mov	eax, DWORD PTR [r10+72]
$LN5@ZSTD_seqTo:

; 1947 :     if (seqStorePtr->longLengthID==2)

	mov	rbp, QWORD PTR [rsp+48]
	cmp	eax, 2
	jne	SHORT $LN6@ZSTD_seqTo

; 1948 :         mlCodeTable[seqStorePtr->longLengthPos] = MaxML;

	mov	eax, DWORD PTR [r10+76]
	mov	BYTE PTR [rax+rsi], 52			; 00000034H
$LN6@ZSTD_seqTo:

; 1949 : }

	add	rsp, 16
	pop	rsi
	ret	0
ZSTD_seqToCodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctxParams$ = 8
ZSTD_useTargetCBlockSize PROC

; 1957 :     DEBUGLOG(5, "ZSTD_useTargetCBlockSize (targetCBlockSize=%zu)", cctxParams->targetCBlockSize);
; 1958 :     return (cctxParams->targetCBlockSize != 0);

	xor	eax, eax
	cmp	QWORD PTR [rcx+56], rax
	setne	al

; 1959 : }

	ret	0
ZSTD_useTargetCBlockSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
max$1 = 128
max$2 = 128
max$3 = 128
nextEntropy$GSCopy$1$ = 136
tv2177 = 144
tv2163 = 144
prevEntropy$GSCopy$1$ = 152
basicCost$1$ = 160
$T4 = 160
strategy$1$ = 168
entropyWorkspace$GSCopy$1$ = 176
oend$1$ = 184
llCodeTable$1$ = 192
ofCodeTable$1$ = 200
mlCodeTable$1$ = 208
longOffsets$1$ = 216
NCountCost$1$ = 224
op$4$ = 224
basicCost$1$ = 232
op$3$ = 232
repeatCost$1$ = 240
CTable_OffsetBits$1$ = 248
CTable_MatchLength$1$ = 256
dst$GSCopy$1$ = 264
sequences$1$ = 272
CTable_LitLength$1$ = 280
count$ = 288
__$ArrayPad$ = 512
seqStorePtr$ = 608
prevEntropy$ = 616
nextEntropy$ = 624
cctxParams$ = 632
dst$ = 640
dstCapacity$ = 648
entropyWorkspace$ = 656
entropyWkspSize$dead$ = 664
bmi2$dead$ = 672
ZSTD_compressSequences_internal PROC

; 1971 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-280]
	sub	rsp, 536				; 00000218H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, QWORD PTR dst$[rbp-256]
	mov	rbx, rcx

; 1974 :     unsigned count[MaxSeq+1];
; 1975 :     FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;
; 1976 :     FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;
; 1977 :     FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;
; 1978 :     U32 LLtype, Offtype, MLtype;   /* compressed, raw or rle */
; 1979 :     const seqDef* const sequences = seqStorePtr->sequencesStart;

	mov	rcx, QWORD PTR [rcx]
	xor	r15d, r15d
	cmp	DWORD PTR [r9+4], 57			; 00000039H
	mov	eax, r15d
	mov	r10, QWORD PTR dstCapacity$[rbp-256]
	mov	rdi, rdx

; 1986 :     size_t const nbSeq = (size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rsi, QWORD PTR [rbx+8]
	seta	al
	mov	r12, QWORD PTR entropyWorkspace$[rbp-256]
	sub	rsi, rcx
	mov	r11d, DWORD PTR [r9+28]
	mov	r14, r8
	mov	DWORD PTR longOffsets$1$[rbp-256], eax
	lea	rax, QWORD PTR [r8+3252]
	mov	QWORD PTR CTable_LitLength$1$[rbp-256], rax
	lea	rax, QWORD PTR [r8+1028]
	mov	QWORD PTR CTable_OffsetBits$1$[rbp-256], rax
	lea	rax, QWORD PTR [r8+1800]
	mov	QWORD PTR CTable_MatchLength$1$[rbp-256], rax
	mov	rax, QWORD PTR [rbx+48]
	mov	QWORD PTR ofCodeTable$1$[rbp-256], rax
	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR llCodeTable$1$[rbp-256], rax
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR prevEntropy$GSCopy$1$[rbp-256], rdx

; 1987 :     BYTE* seqHead;
; 1988 :     BYTE* lastNCount = NULL;
; 1989 : 
; 1990 :     DEBUGLOG(5, "ZSTD_compressSequences_internal (nbSeq=%zu)", nbSeq);
; 1991 :     ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
; 1992 : 
; 1993 :     /* Compress literals */
; 1994 :     {   const BYTE* const literals = seqStorePtr->litStart;
; 1995 :         size_t const litSize = (size_t)(seqStorePtr->lit - literals);

	mov	rdx, QWORD PTR [rbx+24]
	mov	QWORD PTR mlCodeTable$1$[rbp-256], rax
	lea	rax, QWORD PTR [r10+r13]
	mov	QWORD PTR nextEntropy$GSCopy$1$[rbp-256], r8
	mov	r8, QWORD PTR [rbx+16]
	mov	QWORD PTR sequences$1$[rbp-256], rcx
	sub	rdx, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	mov	ecx, DWORD PTR [r9+72]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1986 :     size_t const nbSeq = (size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	sar	rsi, 3
	mov	QWORD PTR oend$1$[rbp-256], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	lea	eax, QWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1971 : {

	mov	QWORD PTR dst$GSCopy$1$[rbp-256], r13
	mov	QWORD PTR entropyWorkspace$GSCopy$1$[rbp-256], r12

; 1972 :     const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;
; 1973 :     ZSTD_strategy const strategy = cctxParams->cParams.strategy;

	mov	DWORD PTR strategy$1$[rbp-256], r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	test	ecx, ecx
	je	SHORT $LN44@ZSTD_compr
	sub	ecx, eax
	je	SHORT $LN47@ZSTD_compr
	cmp	ecx, eax
	je	SHORT $LN194@ZSTD_compr
$LN44@ZSTD_compr:

; 405  :     case ZSTD_lcm_huffman:
; 406  :         return 0;
; 407  :     case ZSTD_lcm_uncompressed:
; 408  :         return 1;
; 409  :     default:
; 410  :         assert(0 /* impossible: pre-validated */);
; 411  :         /* fall-through */
; 412  :     case ZSTD_lcm_auto:
; 413  :         return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);

	cmp	r11d, eax
	jne	SHORT $LN47@ZSTD_compr
	cmp	DWORD PTR [r9+24], r15d
	jbe	SHORT $LN47@ZSTD_compr
$LN194@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1996 :         size_t const cSize = ZSTD_compressLiterals(

	mov	r9d, eax
	jmp	SHORT $LN48@ZSTD_compr
$LN47@ZSTD_compr:
	mov	r9d, r15d
$LN48@ZSTD_compr:
	mov	QWORD PTR [rsp+64], r12
	mov	rcx, rdi
	mov	QWORD PTR [rsp+56], rdx
	mov	rdx, r14
	mov	QWORD PTR [rsp+48], r8
	mov	r8d, r11d
	mov	QWORD PTR [rsp+40], r10
	mov	QWORD PTR [rsp+32], r13
	call	ZSTD_compressLiterals
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2004 :         FORWARD_IF_ERROR(cSize, "ZSTD_compressLiterals failed");

	ja	$LN1@ZSTD_compr

; 2005 :         assert(cSize <= dstCapacity);
; 2006 :         op += cSize;

	lea	rcx, QWORD PTR [rax+r13]

; 2007 :     }
; 2008 : 
; 2009 :     /* Sequences Header */
; 2010 :     RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,

	mov	rax, QWORD PTR oend$1$[rbp-256]
	sub	rax, rcx
	mov	r13, rcx
	cmp	rax, 4
	jge	SHORT $LN19@ZSTD_compr
	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN1@ZSTD_compr
$LN19@ZSTD_compr:

; 2011 :                     dstSize_tooSmall, "Can't fit seq hdr in output buf!");
; 2012 :     if (nbSeq < 128) {

	mov	QWORD PTR repeatCost$1$[rbp-256], -1
	cmp	rsi, 128				; 00000080H
	jae	SHORT $LN21@ZSTD_compr

; 2022 :     }
; 2023 :     assert(op <= oend);
; 2024 :     if (nbSeq==0) {

	mov	BYTE PTR [rcx], sil
	lea	r13, QWORD PTR [rcx+1]
	test	rsi, rsi
	jne	SHORT $LN25@ZSTD_compr

; 2025 :         /* Copy the old tables over as if we repeated them */
; 2026 :         memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));

	mov	rcx, QWORD PTR CTable_OffsetBits$1$[rbp-256]
	lea	rdx, QWORD PTR [rdi+1028]
	mov	r8d, 3552				; 00000de0H
	call	memcpy

; 2027 :         return (size_t)(op - ostart);

	sub	r13, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	rax, r13
	jmp	$LN1@ZSTD_compr
$LN21@ZSTD_compr:

; 2013 :         *op++ = (BYTE)nbSeq;
; 2014 :     } else if (nbSeq < LONGNBSEQ) {

	mov	r8d, 32512				; 00007f00H
	cmp	rsi, r8
	jae	SHORT $LN23@ZSTD_compr

; 2015 :         op[0] = (BYTE)((nbSeq>>8) + 0x80);

	mov	rax, rsi

; 2016 :         op[1] = (BYTE)nbSeq;

	mov	BYTE PTR [rcx+1], sil
	shr	rax, 8

; 2017 :         op+=2;

	add	r13, 2
	add	al, 128					; 00000080H
	mov	BYTE PTR [rcx], al
$LN25@ZSTD_compr:

; 2028 :     }
; 2029 : 
; 2030 :     /* seqHead : flags for FSE encoding type */
; 2031 :     seqHead = op++;

	lea	rdi, QWORD PTR [r13+1]

; 2032 :     assert(op <= oend);
; 2033 : 
; 2034 :     /* convert length/distances into codes */
; 2035 :     ZSTD_seqToCodes(seqStorePtr);

	mov	rcx, rbx
	mov	QWORD PTR tv2163[rbp-256], rdi
	mov	r12, rdi
	call	ZSTD_seqToCodes

; 2036 :     /* build CTable for Literal Lengths */
; 2037 :     {   unsigned max = MaxLL;

	mov	DWORD PTR max$3[rbp-256], 35		; 00000023H
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN52@ZSTD_compr

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, QWORD PTR llCodeTable$1$[rbp-256]
	lea	rdx, QWORD PTR max$3[rbp-256]
	mov	r9, rsi
	lea	rcx, QWORD PTR count$[rbp-256]
	call	HIST_count_simple
	mov	ecx, eax
	jmp	SHORT $LN51@ZSTD_compr
$LN23@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2020 :         MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));

	movzx	eax, si

; 2021 :         op+=3;

	add	r13, 3
	sub	ax, r8w
	mov	WORD PTR [rcx+1], ax
	mov	BYTE PTR [rcx], 255			; 000000ffH
	mov	rcx, rbx
	lea	rdi, QWORD PTR [r13+1]
	mov	QWORD PTR tv2163[rbp-256], rdi
	call	ZSTD_seqToCodes
	mov	DWORD PTR max$3[rbp-256], 35		; 00000023H
	mov	r12, rdi
$LN52@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\hist.c

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	mov	rax, QWORD PTR entropyWorkspace$GSCopy$1$[rbp-256]
	test	al, 3
	je	SHORT $LN54@ZSTD_compr
	mov	rcx, -1
	jmp	SHORT $LN51@ZSTD_compr
$LN54@ZSTD_compr:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	r8, QWORD PTR llCodeTable$1$[rbp-256]
	lea	rdx, QWORD PTR max$3[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR count$[rbp-256]
	mov	r9, rsi
	mov	DWORD PTR [rsp+32], r15d
	call	HIST_count_parallel_wksp
	mov	rcx, rax
$LN51@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2040 :         nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;

	mov	r11, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	lea	rax, OFFSET FLAT:LL_defaultNorm
	lea	rbx, OFFSET FLAT:kInverseProbabilityLog256
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2040 :         nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;

	mov	r8d, DWORD PTR [r11+4576]
	mov	DWORD PTR [r14+4576], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	cmp	rcx, rsi
	jne	SHORT $LN57@ZSTD_compr

; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	cmp	rsi, 2
	mov	DWORD PTR [r14+4576], r15d
	mov	ebx, r15d
	seta	bl

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	jmp	$LN195@ZSTD_compr
$LN57@ZSTD_compr:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	edx, DWORD PTR strategy$1$[rbp-256]
	cmp	edx, 4
	jge	SHORT $LN59@ZSTD_compr

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	mov	eax, 10
	sub	eax, edx
	movsxd	rdx, eax

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	shl	rdx, 6
	shr	rdx, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	r8d, 2
	jne	SHORT $LN62@ZSTD_compr
	cmp	rsi, 1000				; 000003e8H
	jae	SHORT $LN62@ZSTD_compr

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;

	lea	ebx, QWORD PTR [r8+1]
	jmp	$LN195@ZSTD_compr
$LN62@ZSTD_compr:

; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rsi, rdx
	jb	SHORT $LN64@ZSTD_compr
	mov	rax, rsi
	shr	rax, 5
	cmp	rcx, rax
	jae	$LN67@ZSTD_compr
$LN64@ZSTD_compr:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r14+4576], r15d

; 187  :                 return set_basic;

	mov	ebx, r15d
	jmp	$LN195@ZSTD_compr
$LN59@ZSTD_compr:
	mov	r10, QWORD PTR tv2163[rbp-256]

; 128  :     size_t cost = 0;

	lea	r8, QWORD PTR count$[rbp-256]
	mov	rdx, rax
	mov	rdi, r15
	mov	eax, DWORD PTR max$3[rbp-256]
	mov	r11d, 1
	inc	eax
	mov	r14d, eax
	mov	r9d, eax
$LL76@ZSTD_compr:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [rdx]
	cmp	ax, -1
	jne	SHORT $LN79@ZSTD_compr
	mov	eax, r11d
$LN79@ZSTD_compr:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*4]
	add	rdx, 2

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [rbx+rax*4]
	imul	eax, DWORD PTR [r8]
	add	r8, 4
	add	rdi, rax
	sub	r9, r11
	jne	SHORT $LL76@ZSTD_compr

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	rax, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]
	mov	r11, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]

; 138  :     return cost >> 8;

	shr	rdi, 8
	mov	QWORD PTR tv2163[rbp-256], r10

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r10d, DWORD PTR max$3[rbp-256]

; 138  :     return cost >> 8;

	mov	QWORD PTR basicCost$1$[rbp-256], rdi

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	cmp	DWORD PTR [rax+4576], r15d
	je	SHORT $LN71@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2041 :         LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode,

	lea	rcx, QWORD PTR [r11+3252]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r8d, r10d
	lea	rdx, QWORD PTR count$[rbp-256]
	call	ZSTD_fseBitCost
	mov	r10d, DWORD PTR max$3[rbp-256]
	mov	rbx, rax
	jmp	SHORT $LN72@ZSTD_compr
$LN71@ZSTD_compr:
	mov	rbx, -1
$LN72@ZSTD_compr:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r9d, 9
	lea	rcx, QWORD PTR count$[rbp-256]
	mov	r8, rsi
	mov	edx, r10d
	call	ZSTD_NCountCost
	mov	r11, rax
	lea	r9, QWORD PTR count$[rbp-256]
	mov	rax, QWORD PTR tv2163[rbp-256]

; 73   :     unsigned cost = 0;

	mov	r10d, r15d

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	QWORD PTR tv2163[rbp-256], rax
	lea	r15, OFFSET FLAT:kInverseProbabilityLog256
	mov	edi, 1
$LL83@ZSTD_compr:

; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [r9]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rsi

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN84@ZSTD_compr
	test	eax, eax
	cmove	eax, edi
$LN84@ZSTD_compr:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	r9, 4
	mov	ecx, DWORD PTR [r15+rax*4]
	imul	ecx, r8d
	add	r10d, ecx
	sub	r14, rdi
	jne	SHORT $LL83@ZSTD_compr

; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	rdi, QWORD PTR basicCost$1$[rbp-256]
	mov	r15, r14
	mov	eax, r10d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r11*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	cmp	rdi, rbx
	ja	SHORT $LN66@ZSTD_compr
	cmp	rdi, rcx
	ja	SHORT $LN66@ZSTD_compr

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	r14, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]

; 208  :             return set_basic;

	mov	ebx, r15d
	mov	DWORD PTR [r14+4576], r15d
	jmp	SHORT $LN195@ZSTD_compr
$LN66@ZSTD_compr:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	mov	r14, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]
	cmp	rbx, rcx
	ja	SHORT $LN67@ZSTD_compr

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	mov	ebx, 3
	jmp	SHORT $LN195@ZSTD_compr
$LN67@ZSTD_compr:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	eax, 1

; 219  :     return set_compressed;

	mov	ebx, 2
	mov	DWORD PTR [r14+4576], eax
$LN195@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2048 :         {   size_t const countSize = ZSTD_buildCTable(

	mov	rax, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]
	lea	r8, QWORD PTR [r14+3252]
	mov	rdi, QWORD PTR entropyWorkspace$GSCopy$1$[rbp-256]
	add	rax, 3252				; 00000cb4H
	mov	rdx, QWORD PTR oend$1$[rbp-256]
	mov	r9d, 9
	mov	QWORD PTR [rsp+120], 6400		; 00001900H
	sub	rdx, r12
	mov	QWORD PTR [rsp+112], rdi
	mov	rcx, r12
	mov	QWORD PTR [rsp+104], 1316		; 00000524H
	mov	QWORD PTR [rsp+96], rax
	lea	rax, OFFSET FLAT:LL_defaultNorm
	mov	DWORD PTR [rsp+88], 35			; 00000023H
	mov	DWORD PTR [rsp+80], 6
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR llCodeTable$1$[rbp-256]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR max$3[rbp-256]
	mov	DWORD PTR [rsp+48], eax
	lea	rax, QWORD PTR count$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ebx
	mov	DWORD PTR $T4[rbp-256], ebx
	call	ZSTD_buildCTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2056 :             FORWARD_IF_ERROR(countSize, "ZSTD_buildCTable for LitLens failed");

	ja	$LN1@ZSTD_compr

; 2057 :             if (LLtype == set_compressed)
; 2058 :                 lastNCount = op;
; 2059 :             op += countSize;

	mov	rcx, QWORD PTR tv2163[rbp-256]
	cmp	ebx, 2
	cmovne	rcx, r15
	mov	QWORD PTR tv2163[rbp-256], rcx
	lea	rcx, QWORD PTR [rax+r12]
	mov	QWORD PTR op$3$[rbp-256], rcx

; 2060 :             assert(op <= oend);
; 2061 :     }   }
; 2062 :     /* build CTable for Offsets */
; 2063 :     {   unsigned max = MaxOff;

	mov	r12d, 31
	mov	DWORD PTR max$2[rbp-256], r12d
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN89@ZSTD_compr

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, QWORD PTR ofCodeTable$1$[rbp-256]
	lea	rdx, QWORD PTR max$2[rbp-256]
	mov	r9, rsi
	lea	rcx, QWORD PTR count$[rbp-256]
	call	HIST_count_simple
	mov	edx, eax
	jmp	SHORT $LN196@ZSTD_compr
$LN89@ZSTD_compr:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	dil, 3
	je	SHORT $LN91@ZSTD_compr
	mov	rdx, -1
	jmp	SHORT $LN88@ZSTD_compr
$LN91@ZSTD_compr:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	r8, QWORD PTR ofCodeTable$1$[rbp-256]
	lea	rdx, QWORD PTR max$2[rbp-256]
	mov	QWORD PTR [rsp+40], rdi
	lea	rcx, QWORD PTR count$[rbp-256]
	mov	r9, rsi
	mov	DWORD PTR [rsp+32], r15d
	call	HIST_count_parallel_wksp
	mov	rdx, rax
$LN196@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2067 :         ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;

	mov	r12d, DWORD PTR max$2[rbp-256]
$LN88@ZSTD_compr:

; 2068 :         DEBUGLOG(5, "Building OF table");
; 2069 :         nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;

	mov	rax, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	lea	r10, OFFSET FLAT:OF_defaultNorm
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2067 :         ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;

	cmp	r12d, 28
	mov	ecx, r15d
	setbe	cl

; 2068 :         DEBUGLOG(5, "Building OF table");
; 2069 :         nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;

	mov	r8d, DWORD PTR [rax+4568]
	mov	DWORD PTR [r14+4568], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	cmp	rdx, rsi
	jne	SHORT $LN94@ZSTD_compr

; 152  :         *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r14+4568], r15d

; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	test	ecx, ecx
	je	SHORT $LN95@ZSTD_compr
	cmp	rsi, 2
	ja	SHORT $LN95@ZSTD_compr

; 154  :             /* Prefer set_basic over set_rle when there are 2 or less symbols,
; 155  :              * since RLE uses 1 byte, but set_basic uses 5-6 bits per symbol.
; 156  :              * If basic encoding isn't possible, always choose RLE.
; 157  :              */
; 158  :             DEBUGLOG(5, "Selected set_basic");
; 159  :             return set_basic;

	mov	r12d, r15d
	mov	edi, 10
	jmp	$LN93@ZSTD_compr
$LN95@ZSTD_compr:

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	mov	edi, 10
	lea	r12d, QWORD PTR [rdi-9]
	jmp	$LN93@ZSTD_compr
$LN94@ZSTD_compr:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	r9d, DWORD PTR strategy$1$[rbp-256]
	cmp	r9d, 4
	jge	SHORT $LN96@ZSTD_compr

; 165  :         if (isDefaultAllowed) {

	mov	edi, 10
	test	ecx, ecx
	je	$LN104@ZSTD_compr

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	mov	eax, edi
	sub	eax, r9d
	movsxd	rcx, eax

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	shl	rcx, 5
	shr	rcx, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	r8d, 2
	jne	SHORT $LN99@ZSTD_compr
	cmp	rsi, 1000				; 000003e8H
	jae	SHORT $LN99@ZSTD_compr

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;

	lea	r12d, QWORD PTR [rdi-7]
	jmp	$LN93@ZSTD_compr
$LN99@ZSTD_compr:

; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rsi, rcx
	jb	SHORT $LN101@ZSTD_compr
	mov	rax, rsi
	shr	rax, 4
	cmp	rdx, rax
	jae	$LN104@ZSTD_compr
$LN101@ZSTD_compr:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r14+4568], r15d

; 187  :                 return set_basic;

	mov	r12d, r15d
	jmp	$LN93@ZSTD_compr
$LN96@ZSTD_compr:

; 188  :             }
; 189  :         }
; 190  :     } else {
; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	test	ecx, ecx
	je	SHORT $LN106@ZSTD_compr

; 127  :     unsigned const shift = 8 - accuracyLog;

	lea	r9d, DWORD PTR [r12+1]

; 128  :     size_t cost = 0;

	mov	rdi, r15
	mov	r12d, 1
	lea	r8, QWORD PTR count$[rbp-256]
	mov	rdx, r10
	lea	r14, OFFSET FLAT:kInverseProbabilityLog256
	npad	6
$LL113@ZSTD_compr:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [rdx]
	cmp	ax, -1
	jne	SHORT $LN116@ZSTD_compr
	mov	eax, r12d
$LN116@ZSTD_compr:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*8]
	add	rdx, 2

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [r14+rax*4]
	imul	eax, DWORD PTR [r8]
	add	r8, 4
	add	rdi, rax
	sub	r9, r12
	jne	SHORT $LL113@ZSTD_compr
	mov	r14, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]

; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	mov	r12d, DWORD PTR max$2[rbp-256]
	mov	rax, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]

; 138  :     return cost >> 8;

	shr	rdi, 8
	mov	r8d, DWORD PTR [r14+4568]

; 191  :         size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);

	jmp	SHORT $LN107@ZSTD_compr
$LN106@ZSTD_compr:
	mov	rdi, -1
$LN107@ZSTD_compr:

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	test	r8d, r8d
	je	SHORT $LN108@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2070 :         Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode,

	lea	rcx, QWORD PTR [rax+1028]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r8d, r12d
	lea	rdx, QWORD PTR count$[rbp-256]
	call	ZSTD_fseBitCost
	mov	rbx, rax
	jmp	SHORT $LN109@ZSTD_compr
$LN108@ZSTD_compr:
	mov	rbx, -1
$LN109@ZSTD_compr:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r9d, 8
	lea	rcx, QWORD PTR count$[rbp-256]
	mov	r8, rsi
	mov	edx, r12d
	call	ZSTD_NCountCost

; 73   :     unsigned cost = 0;

	mov	r10d, r15d

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	QWORD PTR NCountCost$1$[rbp-256], rax
	mov	r15d, 1
	lea	r9, QWORD PTR count$[rbp-256]
	lea	r11d, DWORD PTR [r12+1]
	lea	r14, OFFSET FLAT:kInverseProbabilityLog256
$LL120@ZSTD_compr:

; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [r9]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rsi

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN121@ZSTD_compr
	test	eax, eax
	cmove	eax, r15d
$LN121@ZSTD_compr:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	r9, 4
	mov	ecx, DWORD PTR [r14+rax*4]
	imul	ecx, r8d
	add	r10d, ecx
	sub	r11, r15
	jne	SHORT $LL120@ZSTD_compr

; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	r14, QWORD PTR NCountCost$1$[rbp-256]
	mov	r15, r11
	mov	eax, r10d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r14*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	cmp	rdi, rbx
	ja	SHORT $LN103@ZSTD_compr
	cmp	rdi, rcx
	ja	SHORT $LN103@ZSTD_compr

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	r14, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]

; 208  :             return set_basic;

	lea	edi, QWORD PTR [r11+10]
	mov	r12d, r15d
	mov	DWORD PTR [r14+4568], r15d
	jmp	SHORT $LN93@ZSTD_compr
$LN103@ZSTD_compr:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	mov	r14, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]
	mov	edi, 10
	cmp	rbx, rcx
	ja	SHORT $LN104@ZSTD_compr

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	lea	r12d, QWORD PTR [rdi-7]
	jmp	SHORT $LN93@ZSTD_compr
$LN104@ZSTD_compr:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	eax, 1
	mov	DWORD PTR [r14+4568], eax

; 219  :     return set_compressed;

	lea	r12d, QWORD PTR [rax+1]
$LN93@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2076 :         {   size_t const countSize = ZSTD_buildCTable(

	mov	rcx, QWORD PTR entropyWorkspace$GSCopy$1$[rbp-256]
	lea	r8, QWORD PTR [r14+1028]
	mov	rbx, QWORD PTR op$3$[rbp-256]
	mov	r9d, 8
	mov	rax, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]
	mov	rdx, QWORD PTR oend$1$[rbp-256]
	add	rax, 1028				; 00000404H
	mov	QWORD PTR [rsp+120], 6400		; 00001900H
	sub	rdx, rbx
	mov	QWORD PTR [rsp+112], rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+104], 772		; 00000304H
	mov	QWORD PTR [rsp+96], rax
	lea	rax, OFFSET FLAT:OF_defaultNorm
	mov	DWORD PTR [rsp+88], 28
	mov	DWORD PTR [rsp+80], 5
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR ofCodeTable$1$[rbp-256]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR max$2[rbp-256]
	mov	DWORD PTR [rsp+48], eax
	lea	rax, QWORD PTR count$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r12d
	call	ZSTD_buildCTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2084 :             FORWARD_IF_ERROR(countSize, "ZSTD_buildCTable for Offsets failed");

	ja	$LN1@ZSTD_compr

; 2085 :             if (Offtype == set_compressed)
; 2086 :                 lastNCount = op;
; 2087 :             op += countSize;

	cmp	r12d, 2
	mov	rcx, rbx

; 2088 :             assert(op <= oend);
; 2089 :     }   }
; 2090 :     /* build CTable for MatchLengths */
; 2091 :     {   unsigned max = MaxML;

	mov	r10d, 52				; 00000034H
	cmovne	rcx, QWORD PTR tv2163[rbp-256]
	add	rbx, rax
	mov	QWORD PTR tv2177[rbp-256], rcx
	mov	QWORD PTR op$4$[rbp-256], rbx
	mov	DWORD PTR max$1[rbp-256], r10d
; File E:\dev\pyzstd\lib\compress\hist.c

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN126@ZSTD_compr

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	mov	r8, QWORD PTR mlCodeTable$1$[rbp-256]
	lea	rdx, QWORD PTR max$1[rbp-256]
	mov	r9, rsi
	lea	rcx, QWORD PTR count$[rbp-256]
	call	HIST_count_simple
	mov	ecx, eax
	jmp	SHORT $LN197@ZSTD_compr
$LN126@ZSTD_compr:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	mov	rax, QWORD PTR entropyWorkspace$GSCopy$1$[rbp-256]
	test	al, 3
	je	SHORT $LN128@ZSTD_compr
	mov	rcx, -1
	jmp	SHORT $LN125@ZSTD_compr
$LN128@ZSTD_compr:

; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	r8, QWORD PTR mlCodeTable$1$[rbp-256]
	lea	rdx, QWORD PTR max$1[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR count$[rbp-256]
	mov	r9, rsi
	mov	DWORD PTR [rsp+32], r15d
	call	HIST_count_parallel_wksp
	mov	rcx, rax
$LN197@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2095 :         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;

	mov	r10d, DWORD PTR max$1[rbp-256]
$LN125@ZSTD_compr:
	mov	r11, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	lea	r9, OFFSET FLAT:ML_defaultNorm
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2095 :         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;

	mov	edx, DWORD PTR [r11+4572]
	mov	DWORD PTR [r14+4572], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 151  :     if (mostFrequent == nbSeq) {

	cmp	rcx, rsi
	jne	SHORT $LN131@ZSTD_compr

; 153  :         if (isDefaultAllowed && nbSeq <= 2) {

	cmp	rsi, 2
	mov	DWORD PTR [r14+4572], r15d
	seta	r15b

; 160  :         }
; 161  :         DEBUGLOG(5, "Selected set_rle");
; 162  :         return set_rle;

	jmp	$LN130@ZSTD_compr
$LN131@ZSTD_compr:

; 163  :     }
; 164  :     if (strategy < ZSTD_lazy) {

	mov	eax, DWORD PTR strategy$1$[rbp-256]
	cmp	eax, 4
	jge	SHORT $LN133@ZSTD_compr

; 166  :             size_t const staticFse_nbSeq_max = 1000;
; 167  :             size_t const mult = 10 - strategy;

	sub	edi, eax
	movsxd	rax, edi

; 168  :             size_t const baseLog = 3;
; 169  :             size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */

	shl	rax, 6
	shr	rax, 3

; 170  :             assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
; 171  :             assert(mult <= 9 && mult >= 7);
; 172  :             if ( (*repeatMode == FSE_repeat_valid)
; 173  :               && (nbSeq < staticFse_nbSeq_max) ) {

	cmp	edx, 2
	jne	SHORT $LN136@ZSTD_compr
	cmp	rsi, 1000				; 000003e8H
	jae	SHORT $LN136@ZSTD_compr

; 174  :                 DEBUGLOG(5, "Selected set_repeat");
; 175  :                 return set_repeat;

	lea	r15d, QWORD PTR [rdx+1]
	jmp	$LN130@ZSTD_compr
$LN136@ZSTD_compr:

; 176  :             }
; 177  :             if ( (nbSeq < dynamicFse_nbSeq_min)
; 178  :               || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {

	cmp	rsi, rax
	jb	SHORT $LN138@ZSTD_compr
	mov	rax, rsi
	shr	rax, 5
	cmp	rcx, rax
	jae	$LN141@ZSTD_compr
$LN138@ZSTD_compr:

; 179  :                 DEBUGLOG(5, "Selected set_basic");
; 180  :                 /* The format allows default tables to be repeated, but it isn't useful.
; 181  :                  * When using simple heuristics to select encoding type, we don't want
; 182  :                  * to confuse these tables with dictionaries. When running more careful
; 183  :                  * analysis, we don't need to waste time checking both repeating tables
; 184  :                  * and default tables.
; 185  :                  */
; 186  :                 *repeatMode = FSE_repeat_none;

	mov	DWORD PTR [r14+4572], r15d

; 187  :                 return set_basic;

	jmp	$LN130@ZSTD_compr
$LN133@ZSTD_compr:

; 128  :     size_t cost = 0;

	lea	eax, DWORD PTR [r10+1]
	mov	rdx, r9
	mov	r14d, eax
	lea	r8, QWORD PTR count$[rbp-256]
	mov	r9d, eax
	lea	r10, OFFSET FLAT:kInverseProbabilityLog256
	mov	rdi, r15
	mov	r11d, 1
	npad	1
$LL150@ZSTD_compr:

; 129  :     unsigned s;
; 130  :     assert(accuracyLog <= 8);
; 131  :     for (s = 0; s <= max; ++s) {
; 132  :         unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;

	movsx	eax, WORD PTR [rdx]
	cmp	ax, -1
	jne	SHORT $LN153@ZSTD_compr
	mov	eax, r11d
$LN153@ZSTD_compr:

; 133  :         unsigned const norm256 = normAcc << shift;

	lea	eax, DWORD PTR [rax*4]
	add	rdx, 2

; 134  :         assert(norm256 > 0);
; 135  :         assert(norm256 < 256);
; 136  :         cost += count[s] * kInverseProbabilityLog256[norm256];

	mov	eax, DWORD PTR [r10+rax*4]
	imul	eax, DWORD PTR [r8]
	add	r8, 4
	add	rdi, rax
	sub	r9, r11
	jne	SHORT $LL150@ZSTD_compr

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	rax, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]
	mov	r10d, DWORD PTR max$1[rbp-256]
	mov	r11, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]

; 138  :     return cost >> 8;

	shr	rdi, 8
	mov	QWORD PTR basicCost$1$[rbp-256], rdi

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	cmp	DWORD PTR [rax+4572], r9d
	je	SHORT $LN145@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2096 :         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode,

	lea	rcx, QWORD PTR [r11+1800]
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 192  :         size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);

	mov	r8d, r10d
	lea	rdx, QWORD PTR count$[rbp-256]
	call	ZSTD_fseBitCost
	mov	r10d, DWORD PTR max$1[rbp-256]
	mov	QWORD PTR repeatCost$1$[rbp-256], rax
$LN145@ZSTD_compr:

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	mov	r9d, 9
	lea	rcx, QWORD PTR count$[rbp-256]
	mov	r8, rsi
	mov	edx, r10d
	call	ZSTD_NCountCost
	mov	r11, rax
	lea	r9, QWORD PTR count$[rbp-256]

; 73   :     unsigned cost = 0;

	mov	r10d, r15d

; 193  :         size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);

	lea	rdi, OFFSET FLAT:kInverseProbabilityLog256
	mov	ebx, 1
	npad	2
$LL157@ZSTD_compr:

; 76   :         unsigned norm = (unsigned)((256 * count[s]) / total);

	mov	r8d, DWORD PTR [r9]
	xor	edx, edx
	mov	eax, r8d
	shl	eax, 8
	div	rsi

; 77   :         if (count[s] != 0 && norm == 0)

	test	r8d, r8d
	je	SHORT $LN158@ZSTD_compr
	test	eax, eax
	cmove	eax, ebx
$LN158@ZSTD_compr:

; 78   :             norm = 1;
; 79   :         assert(count[s] < total);
; 80   :         cost += count[s] * kInverseProbabilityLog256[norm];

	mov	eax, eax
	add	r9, 4
	mov	ecx, DWORD PTR [rdi+rax*4]
	imul	ecx, r8d
	add	r10d, ecx
	sub	r14, rbx
	jne	SHORT $LL157@ZSTD_compr

; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	rdi, QWORD PTR basicCost$1$[rbp-256]
	mov	rbx, QWORD PTR op$4$[rbp-256]
	mov	eax, r10d

; 82   :     return cost >> 8;

	shr	rax, 8

; 194  :         size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);

	lea	rcx, QWORD PTR [rax+r11*8]

; 195  : 
; 196  :         if (isDefaultAllowed) {
; 197  :             assert(!ZSTD_isError(basicCost));
; 198  :             assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
; 199  :         }
; 200  :         assert(!ZSTD_isError(NCountCost));
; 201  :         assert(compressedCost < ERROR(maxCode));
; 202  :         DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
; 203  :                     (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
; 204  :         if (basicCost <= repeatCost && basicCost <= compressedCost) {

	mov	rax, QWORD PTR repeatCost$1$[rbp-256]
	cmp	rdi, rax
	ja	SHORT $LN140@ZSTD_compr
	cmp	rdi, rcx
	ja	SHORT $LN140@ZSTD_compr

; 205  :             DEBUGLOG(5, "Selected set_basic");
; 206  :             assert(isDefaultAllowed);
; 207  :             *repeatMode = FSE_repeat_none;

	mov	rax, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rax+4572], r15d

; 208  :             return set_basic;

	jmp	SHORT $LN130@ZSTD_compr
$LN140@ZSTD_compr:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	cmp	rax, rcx
	ja	SHORT $LN190@ZSTD_compr

; 211  :             DEBUGLOG(5, "Selected set_repeat");
; 212  :             assert(!ZSTD_isError(repeatCost));
; 213  :             return set_repeat;

	mov	r15d, 3
	jmp	SHORT $LN130@ZSTD_compr
$LN190@ZSTD_compr:

; 209  :         }
; 210  :         if (repeatCost <= compressedCost) {

	mov	r14, QWORD PTR nextEntropy$GSCopy$1$[rbp-256]
$LN141@ZSTD_compr:

; 214  :         }
; 215  :         assert(compressedCost < basicCost && compressedCost < repeatCost);
; 216  :     }
; 217  :     DEBUGLOG(5, "Selected set_compressed");
; 218  :     *repeatMode = FSE_repeat_check;

	mov	eax, 1
	mov	DWORD PTR [r14+4572], eax

; 219  :     return set_compressed;

	lea	r15d, QWORD PTR [rax+1]
$LN130@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2102 :         {   size_t const countSize = ZSTD_buildCTable(

	mov	rcx, QWORD PTR entropyWorkspace$GSCopy$1$[rbp-256]
	mov	r9d, 9
	mov	rax, QWORD PTR prevEntropy$GSCopy$1$[rbp-256]
	mov	r14, QWORD PTR oend$1$[rbp-256]
	add	rax, 1800				; 00000708H
	mov	r8, QWORD PTR CTable_MatchLength$1$[rbp-256]
	mov	rdx, r14
	mov	QWORD PTR [rsp+120], 6400		; 00001900H
	sub	rdx, rbx
	mov	QWORD PTR [rsp+112], rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+104], 1452		; 000005acH
	mov	QWORD PTR [rsp+96], rax
	lea	rax, OFFSET FLAT:ML_defaultNorm
	mov	DWORD PTR [rsp+88], 52			; 00000034H
	mov	DWORD PTR [rsp+80], 6
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR mlCodeTable$1$[rbp-256]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR max$1[rbp-256]
	mov	DWORD PTR [rsp+48], eax
	lea	rax, QWORD PTR count$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r15d
	call	ZSTD_buildCTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2110 :             FORWARD_IF_ERROR(countSize, "ZSTD_buildCTable for MatchLengths failed");

	ja	$LN1@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	r9, QWORD PTR mlCodeTable$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2113 :             op += countSize;

	mov	rdi, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	r8, QWORD PTR CTable_MatchLength$1$[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2113 :             op += countSize;

	cmp	r15d, 2
	cmovne	rdi, QWORD PTR tv2177[rbp-256]
	add	rbx, rax

; 2117 :     *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));

	mov	eax, DWORD PTR $T4[rbp-256]

; 2118 : 
; 2119 :     {   size_t const bitstreamSize = ZSTD_encodeSequences(

	sub	r14, rbx
	shl	al, 2
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	rdx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2117 :     *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));

	add	al, r12b
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2117 :     *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));

	shl	al, 2
	add	al, r15b
	shl	al, 2
	mov	BYTE PTR [r13], al
; File E:\dev\pyzstd\lib\compress\zstd_compress_sequences.c

; 414  :     return ZSTD_encodeSequences_default(dst, dstCapacity,

	mov	eax, DWORD PTR longOffsets$1$[rbp-256]
	mov	DWORD PTR [rsp+80], eax
	mov	rax, QWORD PTR sequences$1$[rbp-256]
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR llCodeTable$1$[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR CTable_LitLength$1$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR ofCodeTable$1$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR CTable_OffsetBits$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_encodeSequences_default
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2126 :         FORWARD_IF_ERROR(bitstreamSize, "ZSTD_encodeSequences failed");

	ja	SHORT $LN1@ZSTD_compr

; 2127 :         op += bitstreamSize;

	add	rbx, rax

; 2128 :         assert(op <= oend);
; 2129 :         /* zstd versions <= 1.3.4 mistakenly report corruption when
; 2130 :          * FSE_readNCount() receives a buffer < 4 bytes.
; 2131 :          * Fixed by https://github.com/facebook/zstd/pull/1146.
; 2132 :          * This can happen when the last set_compressed table present is 2
; 2133 :          * bytes and the bitstream is only one byte.
; 2134 :          * In this exceedingly rare case, we will simply emit an uncompressed
; 2135 :          * block, since it isn't worth optimizing.
; 2136 :          */
; 2137 :         if (lastNCount && (op - lastNCount) < 4) {

	test	rdi, rdi
	je	SHORT $LN37@ZSTD_compr
	mov	rax, rbx
	sub	rax, rdi
	cmp	rax, 4
	jge	SHORT $LN37@ZSTD_compr

; 2138 :             /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */
; 2139 :             assert(op - lastNCount == 3);
; 2140 :             DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.3.4 by "
; 2141 :                         "emitting an uncompressed block.");
; 2142 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_compr
$LN37@ZSTD_compr:

; 2143 :         }
; 2144 :     }
; 2145 : 
; 2146 :     DEBUGLOG(5, "compressed block size : %u", (unsigned)(op - ostart));
; 2147 :     return (size_t)(op - ostart);

	sub	rbx, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	rax, rbx
$LN1@ZSTD_compr:

; 2148 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 536				; 00000218H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressSequences_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
seqStorePtr$ = 96
prevEntropy$ = 104
nextEntropy$ = 112
cctxParams$ = 120
dst$ = 128
dstCapacity$ = 136
srcSize$ = 144
entropyWorkspace$ = 152
entropyWkspSize$dead$ = 160
bmi2$dead$ = 168
ZSTD_compressSequences PROC

; 2159 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 2160 :     size_t const cSize = ZSTD_compressSequences_internal(

	mov	rax, QWORD PTR entropyWorkspace$[rsp]
	mov	rbx, r9
	mov	rdi, QWORD PTR dstCapacity$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressSequences_internal
	mov	r9, rax

; 2161 :                             seqStorePtr, prevEntropy, nextEntropy, cctxParams,
; 2162 :                             dst, dstCapacity,
; 2163 :                             entropyWorkspace, entropyWkspSize, bmi2);
; 2164 :     if (cSize == 0) return 0;

	test	rax, rax
	je	SHORT $LN17@ZSTD_compr

; 2165 :     /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.
; 2166 :      * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.
; 2167 :      */
; 2168 :     if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity))

	mov	r8, QWORD PTR srcSize$[rsp]
	xor	edx, edx
	cmp	r8, rdi
	mov	ecx, edx
	setbe	cl
	cmp	rax, -70				; ffffffffffffffbaH
	sete	dl
	test	ecx, edx
	jne	SHORT $LN17@ZSTD_compr
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2170 :     FORWARD_IF_ERROR(cSize, "ZSTD_compressSequences_internal failed");

	ja	SHORT $LN9@ZSTD_compr

; 2173 :     {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);

	mov	eax, DWORD PTR [rbx+28]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	lea	ecx, DWORD PTR [rax-1]
	cmp	eax, 8
	jge	SHORT $LN16@ZSTD_compr
	mov	ecx, 6
$LN16@ZSTD_compr:

; 397  :     ZSTD_STATIC_ASSERT(ZSTD_btultra == 8);
; 398  :     assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));
; 399  :     return (srcSize >> minlog) + 2;

	mov	rax, r8
	shr	rax, cl
	sub	r8, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2173 :     {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);

	sub	r8, 2

; 2174 :         if (cSize >= maxCSize) return 0;  /* block not compressed */

	cmp	r9, r8
	jae	SHORT $LN17@ZSTD_compr
$LN9@ZSTD_compr:

; 2175 :     }
; 2176 : 
; 2177 :     return cSize;

	mov	rax, r9

; 2178 : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN17@ZSTD_compr:
	mov	rbx, QWORD PTR [rsp+96]
	xor	eax, eax
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
ZSTD_compressSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
strat$ = 8
dictMode$ = 16
ZSTD_selectBlockCompressor PROC

; 2185 :     static const ZSTD_blockCompressor blockCompressor[3][ZSTD_STRATEGY_MAX+1] = {
; 2186 :         { ZSTD_compressBlock_fast  /* default for 0 */,
; 2187 :           ZSTD_compressBlock_fast,
; 2188 :           ZSTD_compressBlock_doubleFast,
; 2189 :           ZSTD_compressBlock_greedy,
; 2190 :           ZSTD_compressBlock_lazy,
; 2191 :           ZSTD_compressBlock_lazy2,
; 2192 :           ZSTD_compressBlock_btlazy2,
; 2193 :           ZSTD_compressBlock_btopt,
; 2194 :           ZSTD_compressBlock_btultra,
; 2195 :           ZSTD_compressBlock_btultra2 },
; 2196 :         { ZSTD_compressBlock_fast_extDict  /* default for 0 */,
; 2197 :           ZSTD_compressBlock_fast_extDict,
; 2198 :           ZSTD_compressBlock_doubleFast_extDict,
; 2199 :           ZSTD_compressBlock_greedy_extDict,
; 2200 :           ZSTD_compressBlock_lazy_extDict,
; 2201 :           ZSTD_compressBlock_lazy2_extDict,
; 2202 :           ZSTD_compressBlock_btlazy2_extDict,
; 2203 :           ZSTD_compressBlock_btopt_extDict,
; 2204 :           ZSTD_compressBlock_btultra_extDict,
; 2205 :           ZSTD_compressBlock_btultra_extDict },
; 2206 :         { ZSTD_compressBlock_fast_dictMatchState  /* default for 0 */,
; 2207 :           ZSTD_compressBlock_fast_dictMatchState,
; 2208 :           ZSTD_compressBlock_doubleFast_dictMatchState,
; 2209 :           ZSTD_compressBlock_greedy_dictMatchState,
; 2210 :           ZSTD_compressBlock_lazy_dictMatchState,
; 2211 :           ZSTD_compressBlock_lazy2_dictMatchState,
; 2212 :           ZSTD_compressBlock_btlazy2_dictMatchState,
; 2213 :           ZSTD_compressBlock_btopt_dictMatchState,
; 2214 :           ZSTD_compressBlock_btultra_dictMatchState,
; 2215 :           ZSTD_compressBlock_btultra_dictMatchState }
; 2216 :     };
; 2217 :     ZSTD_blockCompressor selectedCompressor;
; 2218 :     ZSTD_STATIC_ASSERT((unsigned)ZSTD_fast == 1);
; 2219 : 
; 2220 :     assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));
; 2221 :     selectedCompressor = blockCompressor[(int)dictMode][(int)strat];

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*4]
	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:?blockCompressor@?1??ZSTD_selectBlockCompressor@@9@9
	lea	rax, QWORD PTR [rax+rdx*2]

; 2222 :     assert(selectedCompressor != NULL);
; 2223 :     return selectedCompressor;

	mov	rax, QWORD PTR [rcx+rax*8]

; 2224 : }

	ret	0
ZSTD_selectBlockCompressor ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
seqStorePtr$ = 48
anchor$ = 56
lastLLSize$ = 64
ZSTD_storeLastLiterals PROC

; 2228 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, r8

; 2229 :     memcpy(seqStorePtr->lit, anchor, lastLLSize);

	mov	rcx, QWORD PTR [rcx+24]
	call	memcpy

; 2230 :     seqStorePtr->lit += lastLLSize;

	add	QWORD PTR [rbx+24], rdi

; 2231 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_storeLastLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ssPtr$ = 8
ZSTD_resetSeqStore PROC

; 2235 :     ssPtr->lit = ssPtr->litStart;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+24], rax

; 2236 :     ssPtr->sequences = ssPtr->sequencesStart;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 2237 :     ssPtr->longLengthID = 0;

	mov	DWORD PTR [rcx+72], 0

; 2238 : }

	ret	0
ZSTD_resetSeqStore ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
ldmSeqStore$2 = 48
zc$ = 96
src$ = 104
srcSize$ = 112
ZSTD_buildSeqStore PROC

; 2243 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 2244 :     ZSTD_matchState_t* const ms = &zc->blockState.matchState;

	lea	rsi, QWORD PTR [rcx+776]
	mov	rbp, r8
	mov	rdi, rdx
	mov	rbx, rcx

; 2245 :     DEBUGLOG(5, "ZSTD_buildSeqStore (srcSize=%zu)", srcSize);
; 2246 :     assert(srcSize <= ZSTD_BLOCKSIZE_MAX);
; 2247 :     /* Assert that we have correctly flushed the ctx params into the ms's copy */
; 2248 :     ZSTD_assertEqualCParams(zc->appliedParams.cParams, ms->cParams);
; 2249 :     if (srcSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) {

	cmp	r8, 7
	jae	SHORT $LN8@ZSTD_build

; 2250 :         ZSTD_ldm_skipSequences(&zc->externSeqStore, srcSize, zc->appliedParams.cParams.minMatch);

	mov	r8d, DWORD PTR [rbx+180]
	add	rcx, 728				; 000002d8H
	mov	rdx, rbp
	call	ZSTD_ldm_skipSequences

; 2251 :         return ZSTDbss_noCompress; /* don't even attempt compression below a certain srcSize */

	mov	eax, 1
	jmp	$LN1@ZSTD_build
$LN8@ZSTD_build:

; 2237 :     ssPtr->longLengthID = 0;

	xor	r9d, r9d
	mov	QWORD PTR [rsp+96], r14

; 2252 :     }
; 2253 :     ZSTD_resetSeqStore(&(zc->seqStore));

	lea	r14, QWORD PTR [rcx+568]

; 2235 :     ssPtr->lit = ssPtr->litStart;

	mov	rax, QWORD PTR [r14+16]
	mov	QWORD PTR [r14+24], rax

; 2236 :     ssPtr->sequences = ssPtr->sequencesStart;

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [r14+8], rax

; 2237 :     ssPtr->longLengthID = 0;

	mov	DWORD PTR [r14+72], r9d

; 2254 :     /* required for optimal parser to read stats from dictionary */
; 2255 :     ms->opt.symbolCosts = &zc->blockState.prevCBlock->entropy;

	mov	rax, QWORD PTR [rcx+760]

; 2256 :     /* tell the optimal parser how we expect to compress literals */
; 2257 :     ms->opt.literalCompressionMode = zc->appliedParams.literalCompressionMode;
; 2258 :     /* a gap between an attached dict and the current window is not safe,
; 2259 :      * they must remain adjacent,
; 2260 :      * and when that stops being the case, the dict must be unset */
; 2261 :     assert(ms->dictMatchState == NULL || ms->loadedDictEnd == ms->window.dictLimit);
; 2262 : 
; 2263 :     /* limited update after a very long match */
; 2264 :     {   const BYTE* const base = ms->window.base;
; 2265 :         const BYTE* const istart = (const BYTE*)src;
; 2266 :         const U32 current = (U32)(istart-base);
; 2267 :         if (sizeof(ptrdiff_t)==8) assert(istart - base < (ptrdiff_t)(U32)(-1));   /* ensure no overflow */
; 2268 :         if (current > ms->nextToUpdate + 384)

	mov	edx, DWORD PTR [rsi+36]
	mov	QWORD PTR [rsi+160], rax
	mov	eax, DWORD PTR [rcx+232]
	mov	ecx, edi
	sub	ecx, DWORD PTR [rsi+8]
	mov	DWORD PTR [rsi+168], eax
	lea	eax, DWORD PTR [rdx+384]
	cmp	ecx, eax
	jbe	SHORT $LN10@ZSTD_build

; 2269 :             ms->nextToUpdate = current - MIN(192, (U32)(current - ms->nextToUpdate - 384));

	mov	eax, ecx
	sub	eax, edx
	mov	edx, 192				; 000000c0H
	add	eax, -384				; fffffe80H
	cmp	eax, edx
	cmova	eax, edx
	sub	ecx, eax
	mov	DWORD PTR [rsi+36], ecx
$LN10@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	xmm0, XMMWORD PTR [rsi]

; 732  :     return window.lowLimit < window.dictLimit;

	psrldq	xmm1, 8
	movq	rcx, xmm1

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	movaps	XMMWORD PTR $T1[rsp], xmm0

; 732  :     return window.lowLimit < window.dictLimit;

	mov	rax, rcx
	shr	rax, 32					; 00000020H
	cmp	eax, ecx

; 742  :     return ZSTD_window_hasExtDict(ms->window) ?

	jae	SHORT $LN24@ZSTD_build
	mov	edx, 1
	jmp	SHORT $LN25@ZSTD_build
$LN24@ZSTD_build:
	mov	rax, QWORD PTR [rsi+176]
	neg	rax
	sbb	rdx, rdx
	and	edx, 2
$LN25@ZSTD_build:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2277 :                 zc->blockState.nextCBlock->rep[i] = zc->blockState.prevCBlock->rep[i];

	mov	rax, QWORD PTR [rbx+760]
	mov	rcx, QWORD PTR [rbx+768]
	mov	eax, DWORD PTR [rax+4580]
	mov	DWORD PTR [rcx+4580], eax
	mov	rax, QWORD PTR [rbx+760]
	mov	rcx, QWORD PTR [rbx+768]
	mov	eax, DWORD PTR [rax+4584]
	mov	DWORD PTR [rcx+4584], eax
	mov	rax, QWORD PTR [rbx+760]
	mov	rcx, QWORD PTR [rbx+768]
	mov	eax, DWORD PTR [rax+4588]
	mov	DWORD PTR [rcx+4588], eax

; 2278 :         }
; 2279 :         if (zc->externSeqStore.pos < zc->externSeqStore.size) {

	mov	rax, QWORD PTR [rbx+744]
	cmp	QWORD PTR [rbx+736], rax
	jae	SHORT $LN11@ZSTD_build

; 2280 :             assert(!zc->appliedParams.ldmParams.enableLdm);
; 2281 :             /* Updates ldmSeqStore.pos */
; 2282 :             lastLLSize =

	mov	r9, QWORD PTR [rbx+768]
	lea	rcx, QWORD PTR [rbx+728]
	add	r9, 4580				; 000011e4H
	mov	QWORD PTR [rsp+40], rbp
	mov	r8, r14
	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rsi
	call	ZSTD_ldm_blockCompress
	jmp	$LN41@ZSTD_build
$LN11@ZSTD_build:

; 2283 :                 ZSTD_ldm_blockCompress(&zc->externSeqStore,
; 2284 :                                        ms, &zc->seqStore,
; 2285 :                                        zc->blockState.nextCBlock->rep,
; 2286 :                                        src, srcSize);
; 2287 :             assert(zc->externSeqStore.pos <= zc->externSeqStore.size);
; 2288 :         } else if (zc->appliedParams.ldmParams.enableLdm) {

	lea	r8, QWORD PTR [rbx+256]
	mov	QWORD PTR [rsp+32], rbp
	cmp	DWORD PTR [r8], r9d
	je	SHORT $LN13@ZSTD_build

; 2289 :             rawSeqStore_t ldmSeqStore = {NULL, 0, 0, 0};
; 2290 : 
; 2291 :             ldmSeqStore.seq = zc->ldmSequences;

	mov	rax, QWORD PTR [rbx+712]

; 2294 :             FORWARD_IF_ERROR(ZSTD_ldm_generateSequences(&zc->ldmState, &ldmSeqStore,

	lea	rcx, QWORD PTR [rbx+648]
	mov	QWORD PTR ldmSeqStore$2[rsp], rax
	lea	rdx, QWORD PTR ldmSeqStore$2[rsp]
	mov	rax, QWORD PTR [rbx+720]
	mov	QWORD PTR ldmSeqStore$2[rsp+8], r9
	mov	QWORD PTR ldmSeqStore$2[rsp+16], r9
	mov	r9, rdi
	mov	QWORD PTR ldmSeqStore$2[rsp+24], rax
	call	ZSTD_ldm_generateSequences
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2294 :             FORWARD_IF_ERROR(ZSTD_ldm_generateSequences(&zc->ldmState, &ldmSeqStore,

	ja	SHORT $LN40@ZSTD_build

; 2295 :                                                &zc->appliedParams.ldmParams,
; 2296 :                                                src, srcSize), "");
; 2297 :             /* Updates ldmSeqStore.pos */
; 2298 :             lastLLSize =

	mov	r9, QWORD PTR [rbx+768]
	lea	rcx, QWORD PTR ldmSeqStore$2[rsp]
	add	r9, 4580				; 000011e4H
	mov	QWORD PTR [rsp+40], rbp
	mov	r8, r14
	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rsi
	call	ZSTD_ldm_blockCompress

; 2299 :                 ZSTD_ldm_blockCompress(&ldmSeqStore,
; 2300 :                                        ms, &zc->seqStore,
; 2301 :                                        zc->blockState.nextCBlock->rep,
; 2302 :                                        src, srcSize);
; 2303 :             assert(ldmSeqStore.pos == ldmSeqStore.size);
; 2304 :         } else {   /* not long range mode */

	jmp	SHORT $LN41@ZSTD_build
$LN13@ZSTD_build:

; 2221 :     selectedCompressor = blockCompressor[(int)dictMode][(int)strat];

	movsxd	rcx, DWORD PTR [rbx+188]
	lea	rax, QWORD PTR [rdx+rdx*4]

; 2306 :             lastLLSize = blockCompressor(ms, &zc->seqStore, zc->blockState.nextCBlock->rep, src, srcSize);

	mov	r8, QWORD PTR [rbx+768]
	mov	r9, rdi
	add	r8, 4580				; 000011e4H
	mov	rdx, r14

; 2221 :     selectedCompressor = blockCompressor[(int)dictMode][(int)strat];

	lea	rcx, QWORD PTR [rcx+rax*2]
	lea	rax, OFFSET FLAT:?blockCompressor@?1??ZSTD_selectBlockCompressor@@9@9

; 2305 :             ZSTD_blockCompressor const blockCompressor = ZSTD_selectBlockCompressor(zc->appliedParams.cParams.strategy, dictMode);

	mov	rax, QWORD PTR [rax+rcx*8]

; 2306 :             lastLLSize = blockCompressor(ms, &zc->seqStore, zc->blockState.nextCBlock->rep, src, srcSize);

	mov	rcx, rsi
	call	rax
$LN41@ZSTD_build:

; 2229 :     memcpy(seqStorePtr->lit, anchor, lastLLSize);

	mov	rcx, QWORD PTR [rbx+592]
	sub	rdi, rax
	mov	r8, rax
	mov	rsi, rax

; 2307 :         }
; 2308 :         {   const BYTE* const lastLiterals = (const BYTE*)src + srcSize - lastLLSize;

	lea	rdx, QWORD PTR [rdi+rbp]

; 2229 :     memcpy(seqStorePtr->lit, anchor, lastLLSize);

	call	memcpy

; 2230 :     seqStorePtr->lit += lastLLSize;

	add	QWORD PTR [rbx+592], rsi

; 2309 :             ZSTD_storeLastLiterals(&zc->seqStore, lastLiterals, lastLLSize);
; 2310 :     }   }
; 2311 :     return ZSTDbss_compress;

	xor	eax, eax
$LN40@ZSTD_build:
	mov	r14, QWORD PTR [rsp+96]
$LN1@ZSTD_build:

; 2312 : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
ZSTD_buildSeqStore ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
zc$ = 32
ZSTD_copyBlockSequences PROC

; 2315 : {

	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15

; 2317 :     const seqDef* seqs = seqStore->sequencesStart;

	mov	rbp, QWORD PTR [rcx+568]
	mov	rsi, rcx

; 2318 :     size_t seqsSize = seqStore->sequences - seqs;

	mov	r14, QWORD PTR [rcx+576]

; 2319 : 
; 2320 :     ZSTD_Sequence* outSeqs = &zc->seqCollector.seqStart[zc->seqCollector.seqIndex];
; 2321 :     size_t i; size_t position; int repIdx;
; 2322 : 
; 2323 :     assert(zc->seqCollector.seqIndex + 1 < zc->seqCollector.maxSequences);
; 2324 :     for (i = 0, position = 0; i < seqsSize; ++i) {

	xor	r10d, r10d
	mov	rcx, QWORD PTR [rcx+544]
	sub	r14, rbp
	sar	r14, 3
	mov	r9d, r10d
	mov	rax, QWORD PTR [rsi+536]
	lea	rdx, QWORD PTR [rcx+rcx*4]
	lea	r15, QWORD PTR [rax+rdx*4]
	test	r14, r14
	je	$LN22@ZSTD_copyB

; 2316 :     const seqStore_t* seqStore = ZSTD_getSeqStore(zc);

	mov	QWORD PTR [rsp+32], rbx
	lea	rax, QWORD PTR [r15+12]
	mov	QWORD PTR [rsp+40], rdi
	add	rbp, 6
	mov	QWORD PTR [rsp+48], r12
	lea	r12, OFFSET FLAT:repStartValue
	npad	11
$LL4@ZSTD_copyB:

; 2325 :         outSeqs[i].offset = seqs[i].offset;

	mov	edx, DWORD PTR [rbp-6]
	mov	DWORD PTR [rax-8], edx

; 2326 :         outSeqs[i].litLength = seqs[i].litLength;

	movzx	ebx, WORD PTR [rbp-2]
	mov	DWORD PTR [rax-4], ebx

; 2327 :         outSeqs[i].matchLength = seqs[i].matchLength + MINMATCH;
; 2328 : 
; 2329 :         if (i == seqStore->longLengthPos) {

	mov	r8d, ebx
	movzx	edi, WORD PTR [rbp]
	add	edi, 3
	mov	DWORD PTR [rax], edi
	mov	r11d, edi
	mov	ecx, DWORD PTR [rsi+644]
	cmp	r10, rcx
	jne	SHORT $LN8@ZSTD_copyB

; 2330 :             if (seqStore->longLengthID == 1) {

	mov	ecx, DWORD PTR [rsi+640]
	cmp	ecx, 1
	jne	SHORT $LN6@ZSTD_copyB

; 2331 :                 outSeqs[i].litLength += 0x10000;

	lea	r8d, DWORD PTR [rbx+65536]
	mov	DWORD PTR [rax-4], r8d
	jmp	SHORT $LN8@ZSTD_copyB
$LN6@ZSTD_copyB:

; 2332 :             } else if (seqStore->longLengthID == 2) {

	cmp	ecx, 2
	jne	SHORT $LN8@ZSTD_copyB

; 2333 :                 outSeqs[i].matchLength += 0x10000;

	lea	r11d, DWORD PTR [rdi+65536]
	mov	DWORD PTR [rax], r11d
$LN8@ZSTD_copyB:

; 2334 :             }
; 2335 :         }
; 2336 : 
; 2337 :         if (outSeqs[i].offset <= ZSTD_REP_NUM) {

	cmp	edx, 3
	ja	SHORT $LN9@ZSTD_copyB

; 2338 :             outSeqs[i].rep = outSeqs[i].offset;
; 2339 :             repIdx = (unsigned int)i - outSeqs[i].offset;

	mov	ecx, r10d
	mov	DWORD PTR [rax+4], edx
	sub	ecx, edx

; 2340 : 
; 2341 :             if (outSeqs[i].litLength == 0) {

	mov	ebx, edx
	test	r8d, r8d
	jne	SHORT $LN11@ZSTD_copyB

; 2342 :                 if (outSeqs[i].offset < 3) {
; 2343 :                     --repIdx;
; 2344 :                 } else {
; 2345 :                     repIdx = (unsigned int)i - 1;
; 2346 :                 }
; 2347 :                 ++outSeqs[i].rep;

	cmp	edx, 3
	lea	ebx, DWORD PTR [rdx+1]
	mov	DWORD PTR [rax+4], ebx
	cmovae	ecx, r10d
	dec	ecx
$LN11@ZSTD_copyB:

; 2348 :             }
; 2349 :             assert(repIdx >= -3);
; 2350 :             outSeqs[i].offset = repIdx >= 0 ? outSeqs[repIdx].offset : repStartValue[-repIdx - 1];

	test	ecx, ecx
	js	SHORT $LN16@ZSTD_copyB
	movsxd	rcx, ecx
	lea	rdx, QWORD PTR [rcx+rcx*4]
	mov	ecx, DWORD PTR [r15+rdx*4+4]
	jmp	SHORT $LN17@ZSTD_copyB
$LN16@ZSTD_copyB:
	not	ecx
	movsxd	rcx, ecx
	mov	ecx, DWORD PTR [r12+rcx*4]
$LN17@ZSTD_copyB:
	mov	DWORD PTR [rax-8], ecx

; 2351 :             if (outSeqs[i].rep == 4) {

	cmp	ebx, 4
	jne	SHORT $LN10@ZSTD_copyB

; 2352 :                 --outSeqs[i].offset;

	dec	ecx

; 2353 :             }
; 2354 :         } else {

	jmp	SHORT $LN23@ZSTD_copyB
$LN9@ZSTD_copyB:

; 2355 :             outSeqs[i].offset -= ZSTD_REP_NUM;

	lea	ecx, DWORD PTR [rdx-3]
$LN23@ZSTD_copyB:

; 2356 :         }
; 2357 : 
; 2358 :         position += outSeqs[i].litLength;

	mov	DWORD PTR [rax-8], ecx
$LN10@ZSTD_copyB:
	mov	ecx, r8d
	inc	r10
	add	r9, rcx
	add	rbp, 8

; 2359 :         outSeqs[i].matchPos = (unsigned int)position;

	mov	DWORD PTR [rax-12], r9d
	add	rax, 20

; 2360 :         position += outSeqs[i].matchLength;

	mov	ecx, r11d
	add	r9, rcx
	cmp	r10, r14
	jb	$LL4@ZSTD_copyB

; 2361 :     }
; 2362 :     zc->seqCollector.seqIndex += seqsSize;

	add	QWORD PTR [rsi+544], r14
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+32]

; 2363 : }

	mov	rbp, QWORD PTR [rsp+56]
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN22@ZSTD_copyB:
	mov	rbp, QWORD PTR [rsp+56]
	add	rcx, r14
	mov	QWORD PTR [rsi+544], rcx
	pop	r15
	pop	r14
	pop	rsi
	ret	0
ZSTD_copyBlockSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ip$ = 8
length$ = 16
ZSTD_isRLE PROC

; 2387 :     size_t i;
; 2388 :     if (length < 2) return 1;

	cmp	rdx, 2
	jb	SHORT $LN3@ZSTD_isRLE

; 2390 :         if (ip[0] != ip[i]) return 0;

	movzx	r8d, BYTE PTR [rcx]
	mov	eax, 1
	npad	1
$LL4@ZSTD_isRLE:
	cmp	r8b, BYTE PTR [rax+rcx]
	jne	SHORT $LN9@ZSTD_isRLE

; 2389 :     for (i = 1; i < length; ++i) {

	inc	rax
	cmp	rax, rdx
	jb	SHORT $LL4@ZSTD_isRLE
$LN3@ZSTD_isRLE:

; 2391 :     }
; 2392 :     return 1;

	mov	eax, 1

; 2393 : }

	ret	0
$LN9@ZSTD_isRLE:

; 2390 :         if (ip[0] != ip[i]) return 0;

	xor	eax, eax

; 2393 : }

	ret	0
ZSTD_isRLE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
seqStore$ = 8
ZSTD_maybeRLE PROC

; 2401 :     size_t const nbSeqs = (size_t)(seqStore->sequences - seqStore->sequencesStart);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 2403 : 
; 2404 :     return nbSeqs < 4 && nbLits < 10;

	cmp	rax, 4
	jae	SHORT $LN3@ZSTD_maybe

; 2402 :     size_t const nbLits = (size_t)(seqStore->lit - seqStore->litStart);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]

; 2403 : 
; 2404 :     return nbSeqs < 4 && nbLits < 10;

	cmp	rax, 10
	jae	SHORT $LN3@ZSTD_maybe
	mov	eax, 1

; 2405 : }

	ret	0
$LN3@ZSTD_maybe:

; 2403 : 
; 2404 :     return nbSeqs < 4 && nbLits < 10;

	xor	eax, eax

; 2405 : }

	ret	0
ZSTD_maybeRLE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
zc$ = 8
ZSTD_confirmRepcodesAndEntropyTables PROC

; 2409 :     ZSTD_compressedBlockState_t* const tmp = zc->blockState.prevCBlock;

	mov	rdx, QWORD PTR [rcx+760]

; 2410 :     zc->blockState.prevCBlock = zc->blockState.nextCBlock;

	mov	rax, QWORD PTR [rcx+768]
	mov	QWORD PTR [rcx+760], rax

; 2411 :     zc->blockState.nextCBlock = tmp;

	mov	QWORD PTR [rcx+768], rdx

; 2412 : }

	ret	0
ZSTD_confirmRepcodesAndEntropyTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
zc$ = 112
dst$ = 120
dstCapacity$ = 128
src$ = 136
srcSize$ = 144
frame$ = 152
ZSTD_compressBlock_internal PROC

; 2417 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 80					; 00000050H

; 2418 :     /* This the upper bound for the length of an rle block.
; 2419 :      * This isn't the actual upper bound. Finding the real threshold
; 2420 :      * needs further investigation.
; 2421 :      */
; 2422 :     const U32 rleMaxLength = 25;
; 2423 :     size_t cSize;
; 2424 :     const BYTE* ip = (const BYTE*)src;
; 2425 :     BYTE* op = (BYTE*)dst;
; 2426 :     DEBUGLOG(5, "ZSTD_compressBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)",
; 2427 :                 (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit,
; 2428 :                 (unsigned)zc->blockState.matchState.nextToUpdate);
; 2429 : 
; 2430 :     {   const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);

	mov	rdi, QWORD PTR srcSize$[rsp]
	mov	rbp, r8
	mov	r15, rdx
	mov	r8, rdi
	mov	rdx, r9
	mov	rsi, r9
	mov	rbx, rcx
	call	ZSTD_buildSeqStore
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2431 :         FORWARD_IF_ERROR(bss, "ZSTD_buildSeqStore failed");

	ja	$LN1@ZSTD_compr

; 2432 :         if (bss == ZSTDbss_noCompress) { cSize = 0; goto out; }

	cmp	rax, 1
	jne	SHORT $LN7@ZSTD_compr
	xor	r8d, r8d
	jmp	$LN40@ZSTD_compr
$LN7@ZSTD_compr:

; 2433 :     }
; 2434 : 
; 2435 :     if (zc->seqCollector.collectSequences) {

	cmp	DWORD PTR [rbx+528], 0
	je	SHORT $LN8@ZSTD_compr

; 2436 :         ZSTD_copyBlockSequences(zc);

	mov	rcx, rbx
	call	ZSTD_copyBlockSequences

; 2437 :         return 0;

	xor	eax, eax
	jmp	$LN1@ZSTD_compr
$LN8@ZSTD_compr:

; 2438 :     }
; 2439 : 
; 2440 :     /* encode sequences and literals */
; 2441 :     cSize = ZSTD_compressSequences(&zc->seqStore,

	mov	rax, QWORD PTR [rbx+992]
	lea	rcx, QWORD PTR [rbx+568]

; 2160 :     size_t const cSize = ZSTD_compressSequences_internal(

	mov	r8, QWORD PTR [rbx+768]
	lea	r9, QWORD PTR [rbx+160]
	mov	rdx, QWORD PTR [rbx+760]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+32], r15
	mov	QWORD PTR [rsp+112], r14
	call	ZSTD_compressSequences_internal

; 2161 :                             seqStorePtr, prevEntropy, nextEntropy, cctxParams,
; 2162 :                             dst, dstCapacity,
; 2163 :                             entropyWorkspace, entropyWkspSize, bmi2);
; 2164 :     if (cSize == 0) return 0;

	xor	r8d, r8d
	mov	rdx, rax
	test	rax, rax
	je	SHORT $LN23@ZSTD_compr

; 2165 :     /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.
; 2166 :      * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.
; 2167 :      */
; 2168 :     if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity))

	cmp	rdi, rbp
	mov	ecx, r8d
	mov	eax, r8d
	setbe	cl
	cmp	rdx, -70				; ffffffffffffffbaH
	sete	al
	test	ecx, eax
	jne	SHORT $LN23@ZSTD_compr
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2170 :     FORWARD_IF_ERROR(cSize, "ZSTD_compressSequences_internal failed");

	ja	SHORT $LN50@ZSTD_compr

; 2173 :     {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);

	mov	eax, DWORD PTR [rbx+188]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	lea	ecx, DWORD PTR [rax-1]
	cmp	eax, 8
	jge	SHORT $LN30@ZSTD_compr
	mov	ecx, 6
$LN30@ZSTD_compr:

; 397  :     ZSTD_STATIC_ASSERT(ZSTD_btultra == 8);
; 398  :     assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));
; 399  :     return (srcSize >> minlog) + 2;

	mov	rax, rdi
	shr	rax, cl
	mov	rcx, rdi
	sub	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2173 :     {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);

	sub	rcx, 2

; 2174 :         if (cSize >= maxCSize) return 0;  /* block not compressed */

	cmp	rdx, rcx
	cmovae	rdx, r8
$LN50@ZSTD_compr:

; 2442 :             &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy,
; 2443 :             &zc->appliedParams,
; 2444 :             dst, dstCapacity,
; 2445 :             srcSize,
; 2446 :             zc->entropyWorkspace, HUF_WORKSPACE_SIZE /* statically allocated in resetCCtx */,
; 2447 :             zc->bmi2);
; 2448 : 
; 2449 :     if (frame &&
; 2450 :         /* We don't want to emit our first block as a RLE even if it qualifies because
; 2451 :          * doing so will cause the decoder (cli only) to throw a "should consume all input error."
; 2452 :          * This is only an issue for zstd <= v1.4.3
; 2453 :          */
; 2454 :         !zc->isFirstBlock &&
; 2455 :         cSize < rleMaxLength &&

	mov	r8, rdx
$LN23@ZSTD_compr:
	cmp	DWORD PTR frame$[rsp], 0
	mov	r14, QWORD PTR [rsp+112]
	je	SHORT $out$52
	cmp	DWORD PTR [rbx+560], 0
	jne	SHORT $out$52
	cmp	r8, 25
	jae	SHORT $out$52

; 2388 :     if (length < 2) return 1;

	cmp	rdi, 2
	jb	SHORT $LN33@ZSTD_compr

; 2390 :         if (ip[0] != ip[i]) return 0;

	movzx	ecx, BYTE PTR [rsi]
	mov	eax, 1
	npad	2
$LL34@ZSTD_compr:
	cmp	cl, BYTE PTR [rax+rsi]
	jne	SHORT $LN49@ZSTD_compr

; 2389 :     for (i = 1; i < length; ++i) {

	inc	rax
	cmp	rax, rdi
	jb	SHORT $LL34@ZSTD_compr
$LN33@ZSTD_compr:

; 2456 :         ZSTD_isRLE(ip, srcSize))
; 2457 :     {
; 2458 :         cSize = 1;
; 2459 :         op[0] = ip[0];

	movzx	eax, BYTE PTR [rsi]
	mov	r8d, 1
	mov	BYTE PTR [r15], al
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	jmp	SHORT $LN40@ZSTD_compr
$out$52:
	cmp	r8, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2463 :     if (!ZSTD_isError(cSize) && cSize > 1) {

	ja	SHORT $LN40@ZSTD_compr
$LN49@ZSTD_compr:
	cmp	r8, 1
	jbe	SHORT $LN40@ZSTD_compr

; 2409 :     ZSTD_compressedBlockState_t* const tmp = zc->blockState.prevCBlock;

	mov	rdx, QWORD PTR [rbx+760]

; 2410 :     zc->blockState.prevCBlock = zc->blockState.nextCBlock;

	mov	rcx, QWORD PTR [rbx+768]
	mov	QWORD PTR [rbx+760], rcx

; 2411 :     zc->blockState.nextCBlock = tmp;

	mov	QWORD PTR [rbx+768], rdx
$LN40@ZSTD_compr:

; 2464 :         ZSTD_confirmRepcodesAndEntropyTables(zc);
; 2465 :     }
; 2466 :     /* We check that dictionaries have offset codes available for the first
; 2467 :      * block. After the first block, the offcode table might not have large
; 2468 :      * enough codes to represent the offsets in the data.
; 2469 :      */
; 2470 :     if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)

	mov	rax, QWORD PTR [rbx+760]
	cmp	DWORD PTR [rax+4568], 2
	jne	SHORT $LN11@ZSTD_compr

; 2471 :         zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;

	mov	DWORD PTR [rax+4568], 1
$LN11@ZSTD_compr:

; 2472 : 
; 2473 :     return cSize;

	mov	rax, r8
$LN1@ZSTD_compr:

; 2474 : }

	mov	rbx, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
ZSTD_compressBlock_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
prevEntropy$1$ = 112
nextEntropy$1$ = 120
entropyMetadata$1 = 128
__$ArrayPad$ = 1168
zc$ = 1264
dst$ = 1272
dstCapacity$ = 1280
src$ = 1288
srcSize$ = 1296
bss$ = 1304
lastBlock$ = 1312
ZSTD_compressBlock_targetCBlockSize_body PROC

; 2480 : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 1216				; 000004c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2481 :     DEBUGLOG(6, "Attempting ZSTD_compressSuperBlock()");
; 2482 :     if (bss == ZSTDbss_compress) {

	cmp	QWORD PTR bss$[rsp], 0
	mov	rsi, r9
	mov	rdi, QWORD PTR srcSize$[rsp]
	mov	r12, r8
	mov	r14, rdx
	mov	rbx, rcx
	jne	$LN10@ZSTD_compr

; 2483 :         if (/* We don't want to emit our first block as a RLE even if it qualifies because
; 2484 :             * doing so will cause the decoder (cli only) to throw a "should consume all input error."
; 2485 :             * This is only an issue for zstd <= v1.4.3
; 2486 :             */
; 2487 :             !zc->isFirstBlock &&
; 2488 :             ZSTD_maybeRLE(&zc->seqStore) &&

	cmp	DWORD PTR [rcx+560], 0
	mov	edx, 1
	jne	$LN32@ZSTD_compr

; 2401 :     size_t const nbSeqs = (size_t)(seqStore->sequences - seqStore->sequencesStart);

	mov	rax, QWORD PTR [rcx+576]
	sub	rax, QWORD PTR [rcx+568]
	sar	rax, 3

; 2403 : 
; 2404 :     return nbSeqs < 4 && nbLits < 10;

	cmp	rax, 4
	jae	SHORT $LN32@ZSTD_compr

; 2402 :     size_t const nbLits = (size_t)(seqStore->lit - seqStore->litStart);

	mov	rax, QWORD PTR [rcx+592]
	sub	rax, QWORD PTR [rcx+584]

; 2403 : 
; 2404 :     return nbSeqs < 4 && nbLits < 10;

	cmp	rax, 10
	jae	SHORT $LN32@ZSTD_compr

; 2388 :     if (length < 2) return 1;

	cmp	rdi, 2
	jb	SHORT $LN18@ZSTD_compr

; 2390 :         if (ip[0] != ip[i]) return 0;

	movzx	ecx, BYTE PTR [r9]
	mov	eax, edx
	npad	2
$LL19@ZSTD_compr:
	cmp	cl, BYTE PTR [r9+rax]
	jne	SHORT $LN32@ZSTD_compr

; 2389 :     for (i = 1; i < length; ++i) {

	inc	rax
	cmp	rax, rdi
	jb	SHORT $LL19@ZSTD_compr
$LN18@ZSTD_compr:

; 2491 :             return ZSTD_rleCompressBlock(dst, dstCapacity, *(BYTE const*)src, srcSize, lastBlock);

	movzx	edx, BYTE PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 382  :     U32 const cBlockHeader = lastBlock + (((U32)bt_rle)<<1) + (U32)(srcSize << 3);

	lea	ecx, DWORD PTR [rdi*8+2]
	add	ecx, DWORD PTR lastBlock$[rsp]

; 383  :     RETURN_ERROR_IF(dstCapacity < 4, dstSize_tooSmall, "");

	cmp	r12, 4
	jb	$LN88@ZSTD_compr
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [r14], cx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 386  :     return 4;

	mov	ebx, 4
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	ecx, 16
	mov	BYTE PTR [r14+2], cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 385  :     op[3] = src;

	mov	BYTE PTR [r14+3], dl
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2491 :             return ZSTD_rleCompressBlock(dst, dstCapacity, *(BYTE const*)src, srcSize, lastBlock);

	jmp	$LN72@ZSTD_compr
$LN32@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	mov	r11, QWORD PTR [rbx+584]
	mov	r10, QWORD PTR [rbx+592]

; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	mov	r8, QWORD PTR [rbx+768]

; 281  :     size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;

	sub	r10, r11

; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	mov	rax, QWORD PTR [rbx+760]
	mov	QWORD PTR [rsp+1208], rbp
	lea	rbp, QWORD PTR [rbx+160]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	mov	ecx, DWORD PTR [rbp+72]
	mov	QWORD PTR [rsp+1200], r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	mov	r13, QWORD PTR [rbx+992]
	mov	QWORD PTR [rsp+1192], r15
	mov	QWORD PTR nextEntropy$1$[rsp], r8
	mov	QWORD PTR prevEntropy$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 404  :     switch (cctxParams->literalCompressionMode) {

	test	ecx, ecx
	je	SHORT $LN53@ZSTD_compr
	sub	ecx, edx
	je	SHORT $LN56@ZSTD_compr
	cmp	ecx, edx
	je	SHORT $LN57@ZSTD_compr
$LN53@ZSTD_compr:

; 405  :     case ZSTD_lcm_huffman:
; 406  :         return 0;
; 407  :     case ZSTD_lcm_uncompressed:
; 408  :         return 1;
; 409  :     default:
; 410  :         assert(0 /* impossible: pre-validated */);
; 411  :         /* fall-through */
; 412  :     case ZSTD_lcm_auto:
; 413  :         return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);

	cmp	DWORD PTR [rbp+28], edx
	jne	SHORT $LN56@ZSTD_compr
	cmp	DWORD PTR [rbp+24], 0
	ja	SHORT $LN57@ZSTD_compr
$LN56@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 283  :     entropyMetadata->hufMetadata.hufDesSize =

	xor	edx, edx
$LN57@ZSTD_compr:
	mov	QWORD PTR [rsp+48], r13
	lea	rax, QWORD PTR entropyMetadata$1[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	r9, r8
	mov	r8, QWORD PTR prevEntropy$1$[rsp]
	mov	rdx, r10
	mov	rcx, r11
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_buildSuperBlockEntropy_literal
	mov	QWORD PTR entropyMetadata$1[rsp+504], rax
	mov	rdx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 289  :     FORWARD_IF_ERROR(entropyMetadata->hufMetadata.hufDesSize, "ZSTD_buildSuperBlockEntropy_literal failed");

	ja	SHORT $LN36@ZSTD_compr

; 290  :     entropyMetadata->fseMetadata.fseTablesSize =

	mov	r8, QWORD PTR nextEntropy$1$[rsp]
	lea	rax, QWORD PTR entropyMetadata$1[rsp+512]
	mov	rdx, QWORD PTR prevEntropy$1$[rsp]
	lea	rcx, QWORD PTR [rbx+568]
	add	r8, 1028				; 00000404H
	mov	QWORD PTR [rsp+40], r13
	add	rdx, 1028				; 00000404H
	mov	QWORD PTR [rsp+32], rax
	mov	r9, rbp
	call	ZSTD_buildSuperBlockEntropy_sequences
	mov	QWORD PTR entropyMetadata$1[rsp+1024], rax
	mov	rdx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 296  :     FORWARD_IF_ERROR(entropyMetadata->fseMetadata.fseTablesSize, "ZSTD_buildSuperBlockEntropy_sequences failed");

	jbe	SHORT $LN30@ZSTD_compr
$LN36@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress_superblock.c

; 829  :     FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,

	ja	SHORT $LN29@ZSTD_compr
$LN30@ZSTD_compr:

; 830  :           &zc->blockState.prevCBlock->entropy,
; 831  :           &zc->blockState.nextCBlock->entropy,
; 832  :           &zc->appliedParams,
; 833  :           &entropyMetadata,
; 834  :           zc->entropyWorkspace, HUF_WORKSPACE_SIZE /* statically allocated in resetCCtx */), "");
; 835  : 
; 836  :     return ZSTD_compressSubBlock_multi(&zc->seqStore,

	mov	rax, QWORD PTR [rbx+992]
	lea	r9, QWORD PTR entropyMetadata$1[rsp]
	mov	r8, QWORD PTR [rbx+768]
	lea	rcx, QWORD PTR [rbx+568]
	mov	rdx, QWORD PTR [rbx+760]
	mov	QWORD PTR [rsp+88], rax
	mov	eax, DWORD PTR lastBlock$[rsp]
	mov	DWORD PTR [rsp+80], eax
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], rbp
	call	ZSTD_compressSubBlock_multi
	mov	rdx, rax
$LN29@ZSTD_compr:
	mov	r15, QWORD PTR [rsp+1192]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2513 :             if (cSize != ERROR(dstSize_tooSmall)) {

	mov	r13, QWORD PTR [rsp+1200]
	mov	rbp, QWORD PTR [rsp+1208]
	cmp	rdx, -70				; ffffffffffffffbaH
	je	SHORT $LN10@ZSTD_compr

; 2514 :                 size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, zc->appliedParams.cParams.strategy);

	mov	eax, DWORD PTR [rbx+188]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 396  :     U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;

	lea	ecx, DWORD PTR [rax-1]
	cmp	eax, 8
	jge	SHORT $LN67@ZSTD_compr
	mov	ecx, 6
$LN67@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2515 :                 FORWARD_IF_ERROR(cSize, "ZSTD_compressSuperBlock failed");

	ja	SHORT $LN89@ZSTD_compr

; 2516 :                 if (cSize != 0 && cSize < maxCSize + ZSTD_blockHeaderSize) {

	test	rdx, rdx
	je	SHORT $LN10@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 399  :     return (srcSize >> minlog) + 2;

	mov	rax, rdi
	shr	rax, cl
	mov	rcx, rdi
	sub	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2516 :                 if (cSize != 0 && cSize < maxCSize + ZSTD_blockHeaderSize) {

	inc	rcx
	cmp	rdx, rcx
	jae	SHORT $LN10@ZSTD_compr

; 2409 :     ZSTD_compressedBlockState_t* const tmp = zc->blockState.prevCBlock;

	mov	rcx, QWORD PTR [rbx+760]

; 2410 :     zc->blockState.prevCBlock = zc->blockState.nextCBlock;

	mov	rax, QWORD PTR [rbx+768]
	mov	QWORD PTR [rbx+760], rax

; 2411 :     zc->blockState.nextCBlock = tmp;

	mov	QWORD PTR [rbx+768], rcx
$LN89@ZSTD_compr:

; 2529 : }

	mov	rax, rdx
	jmp	SHORT $LN1@ZSTD_compr
$LN10@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 371  :     U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);

	lea	rax, QWORD PTR [rdi*8]
	add	eax, DWORD PTR lastBlock$[rsp]

; 372  :     RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,

	lea	rbx, QWORD PTR [rdi+3]
	cmp	rbx, r12
	jbe	SHORT $LN73@ZSTD_compr
$LN88@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2529 : }

	mov	rbx, -70				; ffffffffffffffbaH
	jmp	SHORT $LN72@ZSTD_compr
$LN73@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [r14], ax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	lea	rcx, QWORD PTR [r14+3]
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	eax, 16
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	r8, rdi
	mov	rdx, rsi
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [r14+2], al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	call	memcpy
$LN72@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2529 : }

	mov	rax, rbx
$LN1@ZSTD_compr:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1216				; 000004c0H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ZSTD_compressBlock_targetCBlockSize_body ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
zc$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
lastBlock$ = 120
ZSTD_compressBlock_targetCBlockSize PROC

; 2535 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 2536 :     size_t cSize = 0;
; 2537 :     const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);

	mov	rsi, QWORD PTR srcSize$[rsp]
	mov	rbp, r8
	mov	r14, rdx
	mov	r8, rsi
	mov	rdx, r9
	mov	rdi, r9
	mov	rbx, rcx
	call	ZSTD_buildSeqStore
	mov	r10, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2540 :     FORWARD_IF_ERROR(bss, "ZSTD_buildSeqStore failed");

	ja	SHORT $LN12@ZSTD_compr

; 2541 : 
; 2542 :     cSize = ZSTD_compressBlock_targetCBlockSize_body(zc, dst, dstCapacity, src, srcSize, bss, lastBlock);

	mov	eax, DWORD PTR lastBlock$[rsp]
	mov	r9, rdi
	mov	DWORD PTR [rsp+48], eax
	mov	r8, rbp
	mov	QWORD PTR [rsp+40], r10
	mov	rdx, r14
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rsi
	call	ZSTD_compressBlock_targetCBlockSize_body
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2543 :     FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_targetCBlockSize_body failed");

	ja	SHORT $LN12@ZSTD_compr

; 2544 : 
; 2545 :     if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)

	mov	rcx, QWORD PTR [rbx+760]
	cmp	DWORD PTR [rcx+4568], 2
	jne	SHORT $LN12@ZSTD_compr

; 2546 :         zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;

	mov	DWORD PTR [rcx+4568], 1
$LN12@ZSTD_compr:

; 2547 : 
; 2548 :     return cSize;
; 2549 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
ZSTD_compressBlock_targetCBlockSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ms$ = 80
ws$ = 88
params$ = 96
ip$ = 104
iend$ = 112
ZSTD_overflowCorrectIfNeeded PROC

; 2556 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 2557 :     if (ZSTD_window_needOverflowCorrection(ms->window, iend)) {

	movups	xmm1, XMMWORD PTR [rcx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	mov	r10d, DWORD PTR iend$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2556 : {

	mov	rdi, r9
	mov	r14, r8
	mov	rsi, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	psrldq	xmm1, 8
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2556 : {

	mov	rbx, rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 757  :     U32 const current = (U32)((BYTE const*)srcEnd - window.base);

	movq	rax, xmm1
	sub	r10d, eax

; 758  :     return current > ZSTD_CURRENT_MAX;

	cmp	r10d, -536870912			; e0000000H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2557 :     if (ZSTD_window_needOverflowCorrection(ms->window, iend)) {

	jbe	$LN2@ZSTD_overf
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 794  :     U32 const current = (U32)((BYTE const*)src - window->base);

	sub	edi, DWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1021 :     U32 const btScale = ((U32)strat >= (U32)ZSTD_btlazy2);

	xor	eax, eax
	cmp	DWORD PTR [r8+28], 6

; 1022 :     return hashLog - btScale;

	mov	ecx, DWORD PTR [r8+8]
	setae	al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 794  :     U32 const current = (U32)((BYTE const*)src - window->base);

	mov	QWORD PTR [rsp+80], rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1022 :     return hashLog - btScale;

	sub	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 794  :     U32 const current = (U32)((BYTE const*)src - window->base);

	mov	ebp, 1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2558 :         U32 const maxDist = (U32)1 << params->cParams.windowLog;

	mov	eax, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 794  :     U32 const current = (U32)((BYTE const*)src - window->base);

	mov	r8d, ebp
	shl	r8d, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2558 :         U32 const maxDist = (U32)1 << params->cParams.windowLog;

	mov	ecx, DWORD PTR [r14+4]
	shl	eax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 793  :     U32 const cycleMask = (1U << cycleLog) - 1;

	lea	edx, DWORD PTR [r8-1]
	and	edx, edi

; 799  :     U32 const correction = current - newCurrent;

	sub	edi, eax
	test	edx, edx
	cmovne	r8d, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1904 :     {   U32 const hSize = (U32)1 << params->cParams.hashLog;

	mov	edx, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 799  :     U32 const correction = current - newCurrent;

	sub	edi, r8d

; 805  :     window->base += correction;

	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1905 :         ZSTD_reduceTable(ms->hashTable, hSize, reducerValue);

	mov	r8d, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 805  :     window->base += correction;

	add	QWORD PTR [rbx+8], rax

; 806  :     window->dictBase += correction;

	add	QWORD PTR [rbx+16], rax

; 807  :     if (window->lowLimit <= correction) window->lowLimit = 1;
; 808  :     else window->lowLimit -= correction;

	mov	eax, DWORD PTR [rbx+28]
	sub	eax, edi
	cmp	DWORD PTR [rbx+28], edi
	cmovbe	eax, ebp

; 809  :     if (window->dictLimit <= correction) window->dictLimit = 1;

	mov	DWORD PTR [rbx+28], eax

; 810  :     else window->dictLimit -= correction;

	mov	eax, DWORD PTR [rbx+24]
	sub	eax, edi
	cmp	DWORD PTR [rbx+24], edi
	cmovbe	eax, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2564 :         ZSTD_cwksp_mark_tables_dirty(ws);

	mov	DWORD PTR [rbx+24], eax
	mov	rax, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi+32], rax

; 1904 :     {   U32 const hSize = (U32)1 << params->cParams.hashLog;

	mov	ecx, DWORD PTR [r14+12]
	shl	edx, cl

; 1905 :         ZSTD_reduceTable(ms->hashTable, hSize, reducerValue);

	mov	rcx, QWORD PTR [rbx+48]
	call	ZSTD_reduceTable

; 1906 :     }
; 1907 : 
; 1908 :     if (params->cParams.strategy != ZSTD_fast) {

	mov	r8d, DWORD PTR [r14+28]
	cmp	r8d, ebp
	je	SHORT $LN21@ZSTD_overf

; 1909 :         U32 const chainSize = (U32)1 << params->cParams.chainLog;

	mov	ecx, DWORD PTR [r14+8]
	mov	edx, ebp
	shl	edx, cl

; 1910 :         if (params->cParams.strategy == ZSTD_btlazy2)

	mov	rcx, QWORD PTR [rbx+64]
	cmp	r8d, 6
	mov	r8d, edi
	jne	SHORT $LN20@ZSTD_overf

; 1911 :             ZSTD_reduceTable_btlazy2(ms->chainTable, chainSize, reducerValue);

	call	ZSTD_reduceTable_btlazy2
	jmp	SHORT $LN21@ZSTD_overf
$LN20@ZSTD_overf:

; 1912 :         else
; 1913 :             ZSTD_reduceTable(ms->chainTable, chainSize, reducerValue);

	call	ZSTD_reduceTable
$LN21@ZSTD_overf:

; 1914 :     }
; 1915 : 
; 1916 :     if (ms->hashLog3) {

	mov	ecx, DWORD PTR [rbx+40]
	test	ecx, ecx
	je	SHORT $LN22@ZSTD_overf

; 1917 :         U32 const h3Size = (U32)1 << ms->hashLog3;

	shl	ebp, cl

; 1918 :         ZSTD_reduceTable(ms->hashTable3, h3Size, reducerValue);

	mov	r8d, edi
	mov	rcx, QWORD PTR [rbx+56]
	mov	edx, ebp
	call	ZSTD_reduceTable
$LN22@ZSTD_overf:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 369  :     if (ws->tableValidEnd < ws->tableEnd) {

	mov	rax, QWORD PTR [rsi+24]
	mov	rbp, QWORD PTR [rsp+80]
	cmp	QWORD PTR [rsi+32], rax
	jae	SHORT $LN25@ZSTD_overf

; 370  :         ws->tableValidEnd = ws->tableEnd;

	mov	QWORD PTR [rsi+32], rax
$LN25@ZSTD_overf:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2570 :         ms->loadedDictEnd = 0;

	mov	ecx, DWORD PTR [rbx+36]
	xor	eax, eax
	sub	ecx, edi
	cmp	DWORD PTR [rbx+36], edi
	cmovae	eax, ecx
	mov	DWORD PTR [rbx+36], eax
	mov	DWORD PTR [rbx+32], 0

; 2571 :         ms->dictMatchState = NULL;

	mov	QWORD PTR [rbx+176], 0
$LN2@ZSTD_overf:

; 2572 :     }
; 2573 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
ZSTD_overflowCorrectIfNeeded ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
maxDist$1$ = 128
cctx$ = 128
dst$ = 136
dstCapacity$ = 144
tv1262 = 152
src$ = 152
srcSize$ = 160
lastFrameChunk$ = 168
ZSTD_compress_frameChunk PROC

; 2586 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 2587 :     size_t blockSize = cctx->blockSize;

	mov	rdi, QWORD PTR [rcx+376]
	mov	r12, r8

; 2588 :     size_t remaining = srcSize;
; 2589 :     const BYTE* ip = (const BYTE*)src;
; 2590 :     BYTE* const ostart = (BYTE*)dst;
; 2591 :     BYTE* op = ostart;
; 2592 :     U32 const maxDist = (U32)1 << cctx->appliedParams.cParams.windowLog;
; 2593 : 
; 2594 :     assert(cctx->appliedParams.cParams.windowLog <= ZSTD_WINDOWLOG_MAX);
; 2595 : 
; 2596 :     DEBUGLOG(5, "ZSTD_compress_frameChunk (blockSize=%u)", (unsigned)blockSize);
; 2597 :     if (cctx->appliedParams.fParams.checksumFlag && srcSize)

	mov	eax, DWORD PTR lastFrameChunk$[rsp]
	mov	r15, rcx
	mov	ecx, DWORD PTR [rcx+164]
	mov	ebx, 1
	shl	ebx, cl
	mov	r8, rdx
	mov	r14, rdx
	mov	DWORD PTR maxDist$1$[rsp], ebx
	mov	rdx, QWORD PTR srcSize$[rsp]
	mov	rbp, r9
	test	rdx, rdx
	je	$LN3@ZSTD_compr
	cmp	DWORD PTR [r15+196], 0
	je	SHORT $LN363@ZSTD_compr

; 2598 :         XXH64_update(&cctx->xxhState, src, srcSize);

	mov	r8, rdx
	lea	rcx, QWORD PTR [r15+408]
	mov	rdx, r9
	call	XXH64_update
	mov	rdx, QWORD PTR srcSize$[rsp]
	mov	eax, DWORD PTR lastFrameChunk$[rsp]
$LN363@ZSTD_compr:
	lea	r13, QWORD PTR [r15+776]
	npad	3
$LL2@ZSTD_compr:

; 2601 :         ZSTD_matchState_t* const ms = &cctx->blockState.matchState;
; 2602 :         U32 const lastBlock = lastFrameChunk & (blockSize >= remaining);

	xor	esi, esi
	cmp	rdi, rdx
	setae	sil
	and	esi, eax

; 2603 : 
; 2604 :         RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize + MIN_CBLOCK_SIZE,

	cmp	r12, 6
	jb	$LN364@ZSTD_compr

; 2605 :                         dstSize_tooSmall,
; 2606 :                         "not enough space to store compressed block");
; 2607 :         if (remaining < blockSize) blockSize = remaining;
; 2608 : 
; 2609 :         ZSTD_overflowCorrectIfNeeded(

	cmp	rdx, rdi
	lea	r8, QWORD PTR [r15+160]
	mov	rax, rdx
	mov	r9, rbp
	cmovae	rax, rdi
	lea	rdx, QWORD PTR [r15+312]
	mov	rdi, rax
	mov	rcx, r13
	add	rax, rbp
	mov	QWORD PTR tv1262[rsp], rax
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_overflowCorrectIfNeeded
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 907  :         if (blockEndIdx > loadedDictEnd + maxDist) {

	mov	ecx, DWORD PTR [r13+32]
	mov	edx, edi
	sub	edx, DWORD PTR [r13+8]
	add	ecx, ebx
	add	edx, ebp
	cmp	edx, ecx
	jbe	SHORT $LN326@ZSTD_compr

; 908  :             /* On reaching window size, dictionaries are invalidated.
; 909  :              * For simplification, if window size is reached anywhere within next block,
; 910  :              * the dictionary is invalidated for the full block.
; 911  :              */
; 912  :             DEBUGLOG(6, "invalidating dictionary for current block (distance > windowSize)");
; 913  :             *loadedDictEndPtr = 0;

	xor	eax, eax
	mov	DWORD PTR [r13+32], eax

; 914  :             *dictMatchStatePtr = NULL;

	mov	QWORD PTR [r13+176], rax
$LN326@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2614 :         if (ms->nextToUpdate < ms->window.lowLimit) ms->nextToUpdate = ms->window.lowLimit;

	mov	eax, DWORD PTR [r13+28]
	cmp	DWORD PTR [r13+36], eax
	jae	SHORT $LN17@ZSTD_compr
	mov	DWORD PTR [r13+36], eax
$LN17@ZSTD_compr:

; 1958 :     return (cctxParams->targetCBlockSize != 0);

	cmp	QWORD PTR [r15+216], 0

; 2615 : 
; 2616 :         {   size_t cSize;
; 2617 :             if (ZSTD_useTargetCBlockSize(&cctx->appliedParams)) {

	mov	rcx, r15
	je	SHORT $LN18@ZSTD_compr

; 2537 :     const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);

	mov	r8, rdi
	mov	rdx, rbp
	call	ZSTD_buildSeqStore
	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2540 :     FORWARD_IF_ERROR(bss, "ZSTD_buildSeqStore failed");

	ja	$LN367@ZSTD_compr

; 2541 : 
; 2542 :     cSize = ZSTD_compressBlock_targetCBlockSize_body(zc, dst, dstCapacity, src, srcSize, bss, lastBlock);

	mov	DWORD PTR [rsp+48], esi
	mov	r9, rbp
	mov	QWORD PTR [rsp+40], rax
	mov	r8, r12
	mov	rdx, r14
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r15
	call	ZSTD_compressBlock_targetCBlockSize_body
	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2543 :     FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_targetCBlockSize_body failed");

	ja	$LN367@ZSTD_compr

; 2544 : 
; 2545 :     if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)

	mov	rax, QWORD PTR [r15+760]
	cmp	DWORD PTR [rax+4568], 2
	jne	$LN25@ZSTD_compr

; 2546 :         zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;

	mov	DWORD PTR [rax+4568], 1

; 2618 :                 cSize = ZSTD_compressBlock_targetCBlockSize(cctx, op, dstCapacity, ip, blockSize, lastBlock);
; 2619 :                 FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_targetCBlockSize failed");
; 2620 :                 assert(cSize > 0);
; 2621 :                 assert(cSize <= blockSize + ZSTD_blockHeaderSize);
; 2622 :             } else {

	jmp	$LN25@ZSTD_compr
$LN18@ZSTD_compr:

; 2623 :                 cSize = ZSTD_compressBlock_internal(cctx,

	lea	rdx, QWORD PTR [r14+3]
	mov	DWORD PTR [rsp+40], 1
	lea	r8, QWORD PTR [r12-3]
	mov	QWORD PTR [rsp+32], rdi
	mov	r9, rbp
	call	ZSTD_compressBlock_internal
	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2626 :                 FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_internal failed");

	ja	$LN1@ZSTD_compr

; 2627 : 
; 2628 :                 if (cSize == 0) {  /* block is not compressible */

	test	rax, rax
	jne	SHORT $LN24@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 371  :     U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);

	lea	rax, QWORD PTR [rdi*8]
	add	eax, esi

; 372  :     RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,

	lea	rbx, QWORD PTR [rdi+3]
	cmp	rbx, r12
	ja	$LN371@ZSTD_compr
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [r14], ax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	lea	rcx, QWORD PTR [r14+3]
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	eax, 16
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	mov	r8, rdi
	mov	rdx, rbp
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [r14+2], al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 375  :     memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);

	call	memcpy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2630 :                     FORWARD_IF_ERROR(cSize, "ZSTD_noCompressBlock failed");

	ja	SHORT $LN367@ZSTD_compr

; 2631 :                 } else {

	jmp	SHORT $LN25@ZSTD_compr
$LN24@ZSTD_compr:

; 2632 :                     U32 const cBlockHeader = cSize == 1 ?

	cmp	rbx, 1
	jne	SHORT $LN30@ZSTD_compr
	lea	eax, DWORD PTR [rdi*8+2]
	jmp	SHORT $LN378@ZSTD_compr
$LN30@ZSTD_compr:
	lea	eax, DWORD PTR [rax*8+4]
$LN378@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	add	eax, esi
	mov	WORD PTR [r14], ax

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	shr	eax, 16
	mov	BYTE PTR [r14+2], al
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2636 :                     cSize += ZSTD_blockHeaderSize;

	add	rbx, 3
$LN25@ZSTD_compr:

; 2637 :                 }
; 2638 :             }
; 2639 : 
; 2640 : 
; 2641 :             ip += blockSize;
; 2642 :             assert(remaining >= blockSize);
; 2643 :             remaining -= blockSize;

	mov	rdx, QWORD PTR srcSize$[rsp]

; 2644 :             op += cSize;

	add	r14, rbx
	mov	rbp, QWORD PTR tv1262[rsp]
	sub	rdx, rdi
	mov	eax, DWORD PTR lastFrameChunk$[rsp]

; 2645 :             assert(dstCapacity >= cSize);
; 2646 :             dstCapacity -= cSize;

	sub	r12, rbx
	mov	QWORD PTR srcSize$[rsp], rdx

; 2647 :             cctx->isFirstBlock = 0;

	mov	DWORD PTR [r15+560], 0
	test	rdx, rdx
	je	SHORT $LN377@ZSTD_compr

; 2599 : 
; 2600 :     while (remaining) {

	mov	ebx, DWORD PTR maxDist$1$[rsp]
	jmp	$LL2@ZSTD_compr
$LN371@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 372  :     RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,

	mov	rbx, -70				; ffffffffffffffbaH
$LN367@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2654 : }

	mov	rax, rbx
	jmp	SHORT $LN1@ZSTD_compr
$LN364@ZSTD_compr:

; 2603 : 
; 2604 :         RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize + MIN_CBLOCK_SIZE,

	mov	rax, -70				; ffffffffffffffbaH
	jmp	SHORT $LN1@ZSTD_compr
$LN377@ZSTD_compr:

; 2599 : 
; 2600 :     while (remaining) {

	mov	r8, QWORD PTR dst$[rsp]
$LN3@ZSTD_compr:

; 2648 :             DEBUGLOG(5, "ZSTD_compress_frameChunk: adding a block of size %u",
; 2649 :                         (unsigned)cSize);
; 2650 :     }   }
; 2651 : 
; 2652 :     if (lastFrameChunk && (op>ostart)) cctx->stage = ZSTDcs_ending;

	test	eax, eax
	je	SHORT $LN28@ZSTD_compr
	cmp	r14, r8
	jbe	SHORT $LN28@ZSTD_compr
	mov	DWORD PTR [r15], 3
$LN28@ZSTD_compr:

; 2653 :     return (size_t)(op-ostart);

	sub	r14, r8
	mov	rax, r14
$LN1@ZSTD_compr:

; 2654 : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compress_frameChunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
dst$ = 32
dstCapacity$ = 40
params$ = 48
pledgedSrcSize$ = 56
dictID$ = 64
ZSTD_writeFrameHeader PROC

; 2659 : {   BYTE* const op = (BYTE*)dst;

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15

; 2660 :     U32   const dictIDSizeCodeLength = (dictID>0) + (dictID>=256) + (dictID>=65536);   /* 0-3 */

	mov	esi, DWORD PTR dictID$[rsp]
	xor	r10d, r10d

; 2664 :     U32   const singleSegment = params->fParams.contentSizeFlag && (windowSize >= pledgedSrcSize);

	mov	edi, DWORD PTR [r8+32]
	mov	eax, r10d
	mov	ebx, r10d
	mov	r12d, 256				; 00000100H
	cmp	esi, r12d
	mov	rbp, r8
	mov	r14, rdx
	mov	r11, rcx
	setae	bl
	cmp	esi, 65536				; 00010000H
	setae	al
	add	ebx, eax
	mov	eax, r10d
	test	esi, esi
	setne	al
	add	ebx, eax
	cmp	DWORD PTR [r8+40], r10d
	cmovne	ebx, r10d
	test	edi, edi
	je	SHORT $LN27@ZSTD_write

; 2661 :     U32   const dictIDSizeCode = params->fParams.noDictIDFlag ? 0 : dictIDSizeCodeLength;   /* 0-3 */
; 2662 :     U32   const checksumFlag = params->fParams.checksumFlag>0;
; 2663 :     U32   const windowSize = (U32)1 << params->cParams.windowLog;

	mov	edx, DWORD PTR [r8+4]
	mov	r8d, 1
	mov	eax, r8d
	mov	ecx, edx
	shl	eax, cl

; 2664 :     U32   const singleSegment = params->fParams.contentSizeFlag && (windowSize >= pledgedSrcSize);

	cmp	rax, r9
	jb	SHORT $LN27@ZSTD_write
	sub	dl, 10
	shl	dl, 3
	jmp	SHORT $LN28@ZSTD_write
$LN27@ZSTD_write:

; 2665 :     BYTE  const windowLogByte = (BYTE)((params->cParams.windowLog - ZSTD_WINDOWLOG_ABSOLUTEMIN) << 3);

	movzx	edx, BYTE PTR [rbp+4]
	mov	r8d, r10d
	sub	dl, 10
	shl	dl, 3

; 2666 :     U32   const fcsCode = params->fParams.contentSizeFlag ?

	test	edi, edi
	je	SHORT $LN24@ZSTD_write
$LN28@ZSTD_write:
	cmp	r9, 65792				; 00010100H
	mov	eax, r10d
	mov	ecx, r10d
	mov	edi, -1					; ffffffffH
	setae	cl
	cmp	r9, r12
	setae	al
	add	ecx, eax
	mov	eax, r10d
	cmp	r9, rdi
	setae	al
	add	ecx, eax
	jmp	SHORT $LN25@ZSTD_write
$LN24@ZSTD_write:
	mov	ecx, r10d
$LN25@ZSTD_write:

; 2667 :                      (pledgedSrcSize>=256) + (pledgedSrcSize>=65536+256) + (pledgedSrcSize>=0xFFFFFFFFU) : 0;  /* 0-3 */
; 2668 :     BYTE  const frameHeaderDescriptionByte = (BYTE)(dictIDSizeCode + (checksumFlag<<2) + (singleSegment<<5) + (fcsCode<<6) );

	mov	eax, r10d
	movzx	edi, cl
	add	dil, dil
	mov	r15d, 4
	add	dil, r8b
	shl	dil, 5
	cmp	DWORD PTR [rbp+36], eax
	cmovg	eax, r15d
	add	dil, al
	add	dil, bl

; 2669 :     size_t pos=0;
; 2670 : 
; 2671 :     assert(!(params->fParams.contentSizeFlag && pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN));
; 2672 :     RETURN_ERROR_IF(dstCapacity < ZSTD_FRAMEHEADERSIZE_MAX, dstSize_tooSmall,

	cmp	r14, 18
	jae	SHORT $LN6@ZSTD_write
	lea	rax, QWORD PTR [r15-74]
	jmp	$LN1@ZSTD_write
$LN6@ZSTD_write:

; 2673 :                     "dst buf is too small to fit worst-case frame header size.");
; 2674 :     DEBUGLOG(4, "ZSTD_writeFrameHeader : dictIDFlag : %u ; dictID : %u ; dictIDSizeCode : %u",
; 2675 :                 !params->fParams.noDictIDFlag, (unsigned)dictID, (unsigned)dictIDSizeCode);
; 2676 : 
; 2677 :     if (params->format == ZSTD_f_zstd1) {

	cmp	DWORD PTR [rbp], r10d
	jne	SHORT $LN8@ZSTD_write

; 2678 :         MEM_writeLE32(dst, ZSTD_MAGICNUMBER);

	mov	DWORD PTR [r11], -47205080		; fd2fb528H

; 2679 :         pos = 4;

	mov	r10, r15
$LN8@ZSTD_write:

; 2680 :     }
; 2681 :     op[pos++] = frameHeaderDescriptionByte;

	mov	BYTE PTR [r10+r11], dil
	inc	r10

; 2682 :     if (!singleSegment) op[pos++] = windowLogByte;

	test	r8d, r8d
	jne	SHORT $LN9@ZSTD_write
	mov	BYTE PTR [r10+r11], dl
	inc	r10
$LN9@ZSTD_write:

; 2683 :     switch(dictIDSizeCode)

	sub	ebx, 1
	je	SHORT $LN12@ZSTD_write
	sub	ebx, 1
	je	SHORT $LN13@ZSTD_write
	cmp	ebx, 1
	jne	SHORT $LN2@ZSTD_write

; 2689 :         case 3 : MEM_writeLE32(op+pos, dictID); pos+=4; break;

	mov	DWORD PTR [r10+r11], esi
	add	r10, r15
	jmp	SHORT $LN2@ZSTD_write
$LN13@ZSTD_write:

; 2688 :         case 2 : MEM_writeLE16(op+pos, (U16)dictID); pos+=2; break;

	mov	WORD PTR [r10+r11], si
	add	r10, 2
	jmp	SHORT $LN2@ZSTD_write
$LN12@ZSTD_write:

; 2684 :     {
; 2685 :         default:  assert(0); /* impossible */
; 2686 :         case 0 : break;
; 2687 :         case 1 : op[pos] = (BYTE)(dictID); pos++; break;

	mov	BYTE PTR [r10+r11], sil
	inc	r10
$LN2@ZSTD_write:

; 2690 :     }
; 2691 :     switch(fcsCode)

	test	ecx, ecx
	je	SHORT $LN15@ZSTD_write
	sub	ecx, 1
	je	SHORT $LN18@ZSTD_write
	sub	ecx, 1
	je	SHORT $LN19@ZSTD_write
	cmp	ecx, 1
	jne	SHORT $LN15@ZSTD_write

; 2697 :         case 3 : MEM_writeLE64(op+pos, (U64)(pledgedSrcSize)); pos+=8; break;

	mov	QWORD PTR [r10+r11], r9
	add	r10, 8
	jmp	SHORT $LN17@ZSTD_write
$LN19@ZSTD_write:

; 2696 :         case 2 : MEM_writeLE32(op+pos, (U32)(pledgedSrcSize)); pos+=4; break;

	mov	DWORD PTR [r10+r11], r9d
	add	r10, r15
	jmp	SHORT $LN17@ZSTD_write
$LN18@ZSTD_write:

; 2695 :         case 1 : MEM_writeLE16(op+pos, (U16)(pledgedSrcSize-256)); pos+=2; break;

	sub	r9w, r12w
	mov	WORD PTR [r10+r11], r9w
	add	r10, 2
	jmp	SHORT $LN17@ZSTD_write
$LN15@ZSTD_write:

; 2692 :     {
; 2693 :         default:  assert(0); /* impossible */
; 2694 :         case 0 : if (singleSegment) op[pos++] = (BYTE)(pledgedSrcSize); break;

	test	r8d, r8d
	je	SHORT $LN17@ZSTD_write
	mov	BYTE PTR [r10+r11], r9b
	inc	r10
$LN17@ZSTD_write:

; 2698 :     }
; 2699 :     return pos;

	mov	rax, r10
$LN1@ZSTD_write:

; 2700 : }

	mov	rbx, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]
	pop	r15
	pop	r14
	pop	r12
	ret	0
ZSTD_writeFrameHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
dst$ = 8
dstCapacity$ = 16
ZSTD_writeLastEmptyBlock PROC

; 2709 :     RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall,

	cmp	rdx, 3
	jae	SHORT $LN2@ZSTD_write
	mov	rax, -70				; ffffffffffffffbaH

; 2715 : }

	ret	0
$LN2@ZSTD_write:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	eax, 1
	mov	WORD PTR [rcx], ax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2713 :         return ZSTD_blockHeaderSize;

	mov	eax, 3
; File E:\dev\pyzstd\lib\common\mem.h

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [rcx+2], 0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2715 : }

	ret	0
ZSTD_writeLastEmptyBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 8
seq$ = 16
nbSeq$ = 24
ZSTD_referenceExternalSequences PROC

; 2719 :     RETURN_ERROR_IF(cctx->stage != ZSTDcs_init, stage_wrong,

	cmp	DWORD PTR [rcx], 1
	je	SHORT $LN2@ZSTD_refer
	mov	rax, -60				; ffffffffffffffc4H

; 2729 : }

	ret	0
$LN2@ZSTD_refer:

; 2720 :                     "wrong cctx stage");
; 2721 :     RETURN_ERROR_IF(cctx->appliedParams.ldmParams.enableLdm,

	cmp	DWORD PTR [rcx+256], 0
	je	SHORT $LN4@ZSTD_refer
	mov	rax, -40				; ffffffffffffffd8H

; 2729 : }

	ret	0
$LN4@ZSTD_refer:

; 2722 :                     parameter_unsupported,
; 2723 :                     "incompatible with ldm");
; 2724 :     cctx->externSeqStore.seq = seq;

	mov	QWORD PTR [rcx+728], rdx

; 2725 :     cctx->externSeqStore.size = nbSeq;
; 2726 :     cctx->externSeqStore.capacity = nbSeq;
; 2727 :     cctx->externSeqStore.pos = 0;
; 2728 :     return 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+744], r8
	mov	QWORD PTR [rcx+752], r8
	mov	QWORD PTR [rcx+736], 0

; 2729 : }

	ret	0
ZSTD_referenceExternalSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
frame$ = 120
lastFrameChunk$ = 128
ZSTD_compressContinue_internal PROC

; 2736 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 2737 :     ZSTD_matchState_t* const ms = &cctx->blockState.matchState;
; 2738 :     size_t fhSize = 0;
; 2739 : 
; 2740 :     DEBUGLOG(5, "ZSTD_compressContinue_internal, stage: %u, srcSize: %u",
; 2741 :                 cctx->stage, (unsigned)srcSize);
; 2742 :     RETURN_ERROR_IF(cctx->stage==ZSTDcs_created, stage_wrong,

	mov	eax, DWORD PTR [rcx]
	xor	edi, edi
	mov	r15, r9
	mov	rbp, r8
	mov	r14, rdx
	mov	rbx, rcx
	test	eax, eax
	jne	SHORT $LN8@ZSTD_compr
	lea	rax, QWORD PTR [rdi-60]
	jmp	$LN1@ZSTD_compr
$LN8@ZSTD_compr:

; 2743 :                     "missing init (ZSTD_compressBegin)");
; 2744 : 
; 2745 :     if (frame && (cctx->stage==ZSTDcs_init)) {

	cmp	DWORD PTR frame$[rsp], edi
	je	SHORT $LN10@ZSTD_compr
	cmp	eax, 1
	jne	SHORT $LN10@ZSTD_compr

; 2746 :         fhSize = ZSTD_writeFrameHeader(dst, dstCapacity, &cctx->appliedParams,

	mov	r9, QWORD PTR [rcx+384]
	lea	r8, QWORD PTR [rcx+160]
	mov	eax, DWORD PTR [rcx+304]
	dec	r9
	mov	rdx, rbp
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, r14
	call	ZSTD_writeFrameHeader
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2748 :         FORWARD_IF_ERROR(fhSize, "ZSTD_writeFrameHeader failed");

	ja	$LN1@ZSTD_compr

; 2749 :         assert(fhSize <= dstCapacity);
; 2750 :         dstCapacity -= fhSize;

	sub	rbp, rax

; 2751 :         dst = (char*)dst + fhSize;
; 2752 :         cctx->stage = ZSTDcs_ongoing;

	mov	DWORD PTR [rbx], 2
	add	r14, rax
$LN10@ZSTD_compr:

; 2753 :     }
; 2754 : 
; 2755 :     if (!srcSize) return fhSize;  /* do not generate an empty block if no input */

	mov	QWORD PTR [rsp+80], rsi
	mov	rsi, QWORD PTR srcSize$[rsp]
	test	rsi, rsi
	jne	SHORT $LN13@ZSTD_compr
	mov	rax, rdi
	jmp	$LN30@ZSTD_compr
$LN13@ZSTD_compr:

; 2756 : 
; 2757 :     if (!ZSTD_window_update(&ms->window, src, srcSize)) {

	mov	r8, rsi
	lea	rcx, QWORD PTR [rbx+776]
	mov	rdx, r15
	call	ZSTD_window_update
	test	eax, eax
	jne	SHORT $LN14@ZSTD_compr

; 2758 :         ms->nextToUpdate = ms->window.dictLimit;

	mov	eax, DWORD PTR [rbx+800]
	mov	DWORD PTR [rbx+812], eax
$LN14@ZSTD_compr:

; 2759 :     }
; 2760 :     if (cctx->appliedParams.ldmParams.enableLdm) {

	cmp	DWORD PTR [rbx+256], 0
	je	SHORT $LN15@ZSTD_compr

; 2761 :         ZSTD_window_update(&cctx->ldmState.window, src, srcSize);

	lea	rcx, QWORD PTR [rbx+648]
	mov	r8, rsi
	mov	rdx, r15
	call	ZSTD_window_update
$LN15@ZSTD_compr:

; 2762 :     }
; 2763 : 
; 2764 :     if (!frame) {

	cmp	DWORD PTR frame$[rsp], 0
	mov	r9, r15
	jne	SHORT $LN29@ZSTD_compr

; 2765 :         /* overflow check and correction for block mode */
; 2766 :         ZSTD_overflowCorrectIfNeeded(

	lea	rax, QWORD PTR [r15+rsi]
	lea	r8, QWORD PTR [rbx+160]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rbx+312]
	lea	rcx, QWORD PTR [rbx+776]
	call	ZSTD_overflowCorrectIfNeeded

; 2767 :             ms, &cctx->workspace, &cctx->appliedParams,
; 2768 :             src, (BYTE const*)src + srcSize);
; 2769 :     }
; 2770 : 
; 2771 :     DEBUGLOG(5, "ZSTD_compressContinue_internal (blockSize=%u)", (unsigned)cctx->blockSize);
; 2772 :     {   size_t const cSize = frame ?

	mov	r9, r15
	mov	DWORD PTR [rsp+40], 0
	mov	r8, rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	rdx, r14
	mov	rcx, rbx
	call	ZSTD_compressBlock_internal
	jmp	SHORT $LN31@ZSTD_compr
$LN29@ZSTD_compr:
	mov	eax, DWORD PTR lastFrameChunk$[rsp]
	mov	r8, rbp
	mov	DWORD PTR [rsp+40], eax
	mov	rdx, r14
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rsi
	call	ZSTD_compress_frameChunk
$LN31@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rcx, rax
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2775 :         FORWARD_IF_ERROR(cSize, "%s", frame ? "ZSTD_compress_frameChunk failed" : "ZSTD_compressBlock_internal failed");

	jbe	SHORT $LN5@ZSTD_compr
	jmp	SHORT $LN30@ZSTD_compr
$LN5@ZSTD_compr:

; 2776 :         cctx->consumedSrcSize += srcSize;

	mov	rdx, QWORD PTR [rbx+392]

; 2777 :         cctx->producedCSize += (cSize + fhSize);

	lea	rax, QWORD PTR [rcx+rdi]
	add	QWORD PTR [rbx+400], rax
	add	rdx, rsi

; 2778 :         assert(!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0));
; 2779 :         if (cctx->pledgedSrcSizePlusOne != 0) {  /* control src size */

	mov	r8, QWORD PTR [rbx+384]
	mov	QWORD PTR [rbx+392], rdx
	test	r8, r8
	je	SHORT $LN20@ZSTD_compr

; 2780 :             ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1);
; 2781 :             RETURN_ERROR_IF(

	lea	rax, QWORD PTR [rdx+1]
	cmp	rax, r8
	mov	rax, -72				; ffffffffffffffb8H
	ja	SHORT $LN30@ZSTD_compr
$LN20@ZSTD_compr:

; 2782 :                 cctx->consumedSrcSize+1 > cctx->pledgedSrcSizePlusOne,
; 2783 :                 srcSize_wrong,
; 2784 :                 "error : pledgedSrcSize = %u, while realSrcSize >= %u",
; 2785 :                 (unsigned)cctx->pledgedSrcSizePlusOne-1,
; 2786 :                 (unsigned)cctx->consumedSrcSize);
; 2787 :         }
; 2788 :         return cSize + fhSize;

	lea	rax, QWORD PTR [rcx+rdi]
$LN30@ZSTD_compr:
	mov	rsi, QWORD PTR [rsp+80]
$LN1@ZSTD_compr:

; 2789 :     }
; 2790 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	ret	0
ZSTD_compressContinue_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
ZSTD_compressContinue PROC

; 2795 : {

$LN4:
	sub	rsp, 72					; 00000048H

; 2796 :     DEBUGLOG(5, "ZSTD_compressContinue (srcSize=%u)", (unsigned)srcSize);
; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	rax, QWORD PTR srcSize$[rsp]
	mov	DWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressContinue_internal

; 2798 : }

	add	rsp, 72					; 00000048H
	ret	0
ZSTD_compressContinue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 48
ZSTD_getBlockSize PROC

; 2802 : {

$LN6:
	sub	rsp, 40					; 00000028H

; 2803 :     ZSTD_compressionParameters const cParams = cctx->appliedParams.cParams;
; 2804 :     assert(!ZSTD_checkCParams(cParams));
; 2805 :     return MIN (ZSTD_BLOCKSIZE_MAX, (U32)1 << cParams.windowLog);

	mov	ecx, DWORD PTR [rcx+164]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, 131072				; 00020000H
	cmp	eax, ecx
	cmova	eax, ecx

; 2806 : }

	add	rsp, 40					; 00000028H
	ret	0
ZSTD_getBlockSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 112
dst$ = 120
dstCapacity$dead$ = 128
src$ = 136
srcSize$ = 144
ZSTD_compressBlock PROC

; 2809 : {

$LN10:
	sub	rsp, 104				; 00000068H
	mov	r10, rcx

; 2805 :     return MIN (ZSTD_BLOCKSIZE_MAX, (U32)1 << cParams.windowLog);

	mov	eax, 1
	mov	ecx, DWORD PTR [rcx+164]
	mov	r8d, 131072				; 00020000H
	shl	eax, cl

; 2810 :     DEBUGLOG(5, "ZSTD_compressBlock: srcSize = %u", (unsigned)srcSize);
; 2811 :     { size_t const blockSizeMax = ZSTD_getBlockSize(cctx);
; 2812 :       RETURN_ERROR_IF(srcSize > blockSizeMax, srcSize_wrong, "input is larger than a block"); }

	mov	rcx, QWORD PTR srcSize$[rsp]

; 2805 :     return MIN (ZSTD_BLOCKSIZE_MAX, (U32)1 << cParams.windowLog);

	cmp	eax, r8d
	cmova	eax, r8d

; 2810 :     DEBUGLOG(5, "ZSTD_compressBlock: srcSize = %u", (unsigned)srcSize);
; 2811 :     { size_t const blockSizeMax = ZSTD_getBlockSize(cctx);
; 2812 :       RETURN_ERROR_IF(srcSize > blockSizeMax, srcSize_wrong, "input is larger than a block"); }

	cmp	rcx, rax
	jbe	SHORT $LN2@ZSTD_compr
	mov	rax, -72				; ffffffffffffffb8H

; 2815 : }

	add	rsp, 104				; 00000068H
	ret	0
$LN2@ZSTD_compr:

; 2813 : 
; 2814 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 0 /* frame mode */, 0 /* last chunk */);

	xor	eax, eax
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r10
	call	ZSTD_compressContinue_internal

; 2815 : }

	add	rsp, 104				; 00000068H
	ret	0
ZSTD_compressBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_opt.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ms$ = 112
ls$ = 120
ws$ = 128
params$ = 136
src$ = 144
$T1 = 152
srcSize$ = 152
dtlm$ = 160
ZSTD_loadDictionaryContent PROC

; 2826 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 2827 :     const BYTE* ip = (const BYTE*) src;

	mov	r14, QWORD PTR src$[rsp]
	mov	r13, rdx

; 2828 :     const BYTE* const iend = ip + srcSize;

	mov	rsi, QWORD PTR srcSize$[rsp]

; 2829 : 
; 2830 :     ZSTD_window_update(&ms->window, src, srcSize);

	mov	rdx, r14
	mov	r8, rsi
	mov	r15, r9
	mov	rdi, rcx
	mov	rbx, r14
	lea	r12, QWORD PTR [r14+rsi]
	call	ZSTD_window_update

; 2831 :     ms->loadedDictEnd = params->forceWindow ? 0 : (U32)(iend - ms->window.base);

	cmp	DWORD PTR [r15+48], 0
	mov	ebp, r12d
	mov	DWORD PTR $T1[rsp], r12d
	je	SHORT $LN17@ZSTD_loadD
	xor	eax, eax
	jmp	SHORT $LN18@ZSTD_loadD
$LN17@ZSTD_loadD:
	mov	eax, r12d
	sub	eax, DWORD PTR [rdi+8]
$LN18@ZSTD_loadD:
	mov	DWORD PTR [rdi+32], eax

; 2832 : 
; 2833 :     if (params->ldmParams.enableLdm && ls != NULL) {

	cmp	DWORD PTR [r15+96], 0
	je	SHORT $LN6@ZSTD_loadD
	test	r13, r13
	je	SHORT $LN6@ZSTD_loadD

; 2834 :         ZSTD_window_update(&ls->window, src, srcSize);

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, r13
	call	ZSTD_window_update

; 2835 :         ls->loadedDictEnd = params->forceWindow ? 0 : (U32)(iend - ls->window.base);

	cmp	DWORD PTR [r15+48], 0
	je	SHORT $LN19@ZSTD_loadD
	xor	eax, eax
	jmp	SHORT $LN20@ZSTD_loadD
$LN19@ZSTD_loadD:
	mov	eax, ebp
	sub	eax, DWORD PTR [r13+8]
$LN20@ZSTD_loadD:
	mov	DWORD PTR [r13+40], eax
$LN6@ZSTD_loadD:

; 2836 :     }
; 2837 : 
; 2838 :     /* Assert that we the ms params match the params we're being given */
; 2839 :     ZSTD_assertEqualCParams(params->cParams, ms->cParams);
; 2840 : 
; 2841 :     if (srcSize <= HASH_READ_SIZE) return 0;

	cmp	rsi, 8
	jbe	$LN38@ZSTD_loadD

; 2843 :     while (iend - ip > HASH_READ_SIZE) {

	jle	$LN3@ZSTD_loadD
	mov	ebp, DWORD PTR dtlm$[rsp]
	npad	2
$LL2@ZSTD_loadD:

; 2844 :         size_t const remaining = (size_t)(iend - ip);
; 2845 :         size_t const chunk = MIN(remaining, ZSTD_CHUNKSIZE_MAX);
; 2846 :         const BYTE* const ichunk = ip + chunk;
; 2847 : 
; 2848 :         ZSTD_overflowCorrectIfNeeded(ms, ws, params, ip, ichunk);

	mov	rdx, QWORD PTR ws$[rsp]
	mov	r14d, 536870911				; 1fffffffH
	mov	rax, r12
	mov	r9, rbx
	sub	rax, rbx
	mov	r8, r15
	cmp	rax, r14
	mov	rcx, rdi
	cmovb	r14, rax
	lea	rsi, QWORD PTR [r14+rbx]
	mov	QWORD PTR [rsp+32], rsi
	call	ZSTD_overflowCorrectIfNeeded

; 2849 : 
; 2850 :         if (params->ldmParams.enableLdm && ls != NULL)

	cmp	DWORD PTR [r15+96], 0
	je	SHORT $LN8@ZSTD_loadD
	test	r13, r13
	je	SHORT $LN8@ZSTD_loadD

; 2851 :             ZSTD_ldm_fillHashTable(ls, (const BYTE*)src, (const BYTE*)src + srcSize, &params->ldmParams);

	mov	rdx, QWORD PTR src$[rsp]
	lea	r9, QWORD PTR [r15+96]
	mov	r8, r12
	mov	rcx, r13
	call	ZSTD_ldm_fillHashTable
$LN8@ZSTD_loadD:

; 2852 : 
; 2853 :         switch(params->cParams.strategy)

	mov	eax, DWORD PTR [r15+28]
	dec	eax
	cmp	eax, 8
	ja	$LN25@ZSTD_loadD
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN37@ZSTD_loadD[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN9@ZSTD_loadD:

; 2854 :         {
; 2855 :         case ZSTD_fast:
; 2856 :             ZSTD_fillHashTable(ms, ichunk, dtlm);

	mov	r8d, ebp
	mov	rdx, rsi
	mov	rcx, rdi
	call	ZSTD_fillHashTable

; 2857 :             break;

	jmp	$LN25@ZSTD_loadD
$LN10@ZSTD_loadD:

; 2858 :         case ZSTD_dfast:
; 2859 :             ZSTD_fillDoubleHashTable(ms, ichunk, dtlm);

	mov	r8d, ebp
	mov	rdx, rsi
	mov	rcx, rdi
	call	ZSTD_fillDoubleHashTable

; 2860 :             break;

	jmp	SHORT $LN25@ZSTD_loadD
$LN11@ZSTD_loadD:

; 2861 : 
; 2862 :         case ZSTD_greedy:
; 2863 :         case ZSTD_lazy:
; 2864 :         case ZSTD_lazy2:
; 2865 :             if (chunk >= HASH_READ_SIZE)

	cmp	r14, 8
	jb	SHORT $LN25@ZSTD_loadD
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 475  :     return ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, ms->cParams.minMatch);

	mov	r9d, DWORD PTR [rdi+200]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2866 :                 ZSTD_insertAndFindFirstIndex(ms, ichunk-HASH_READ_SIZE);

	lea	r8, QWORD PTR [rsi-8]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 474  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;

	lea	rdx, QWORD PTR [rdi+184]

; 475  :     return ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, ms->cParams.minMatch);

	mov	rcx, rdi
	call	ZSTD_insertAndFindFirstIndex_internal
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2867 :             break;

	jmp	SHORT $LN25@ZSTD_loadD
$LN13@ZSTD_loadD:

; 2868 : 
; 2869 :         case ZSTD_btlazy2:   /* we want the dictionary table fully sorted */
; 2870 :         case ZSTD_btopt:
; 2871 :         case ZSTD_btultra:
; 2872 :         case ZSTD_btultra2:
; 2873 :             if (chunk >= HASH_READ_SIZE)

	cmp	r14, 8
	jb	SHORT $LN25@ZSTD_loadD
; File E:\dev\pyzstd\lib\compress\zstd_opt.c

; 488  :     const BYTE* const base = ms->window.base;

	mov	r14, QWORD PTR [rdi+8]

; 489  :     U32 const target = (U32)(ip - base);

	mov	ebp, esi

; 490  :     U32 idx = ms->nextToUpdate;

	mov	ebx, DWORD PTR [rdi+36]
	sub	ebp, r14d

; 505  :     ZSTD_updateTree_internal(ms, ip, iend, ms->cParams.minMatch, ZSTD_noDict);

	mov	r15d, DWORD PTR [rdi+200]

; 489  :     U32 const target = (U32)(ip - base);

	sub	ebp, 8

; 491  :     DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
; 492  :                 idx, target, dictMode);
; 493  : 
; 494  :     while(idx < target) {

	cmp	ebx, ebp
	jae	SHORT $LN27@ZSTD_loadD
	npad	2
$LL26@ZSTD_loadD:

; 495  :         U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);

	mov	edx, ebx
	mov	r9d, r15d
	add	rdx, r14
	mov	DWORD PTR [rsp+32], 0
	mov	r8, rsi
	mov	rcx, rdi
	call	ZSTD_insertBt1

; 496  :         assert(idx < (U32)(idx + forward));
; 497  :         idx += forward;

	add	ebx, eax
	cmp	ebx, ebp
	jb	SHORT $LL26@ZSTD_loadD
$LN27@ZSTD_loadD:
	mov	r15, QWORD PTR params$[rsp]

; 498  :     }
; 499  :     assert((size_t)(ip - base) <= (size_t)(U32)(-1));
; 500  :     assert((size_t)(iend - base) <= (size_t)(U32)(-1));
; 501  :     ms->nextToUpdate = target;

	mov	DWORD PTR [rdi+36], ebp
	mov	ebp, DWORD PTR dtlm$[rsp]
$LN25@ZSTD_loadD:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2843 :     while (iend - ip > HASH_READ_SIZE) {

	mov	rax, r12

; 2874 :                 ZSTD_updateTree(ms, ichunk-HASH_READ_SIZE, ichunk);
; 2875 :             break;
; 2876 : 
; 2877 :         default:
; 2878 :             assert(0);  /* not possible : not a valid strategy id */
; 2879 :         }
; 2880 : 
; 2881 :         ip = ichunk;

	mov	rbx, rsi
	sub	rax, rsi
	cmp	rax, 8
	jg	$LL2@ZSTD_loadD
$LN3@ZSTD_loadD:

; 2882 :     }
; 2883 : 
; 2884 :     ms->nextToUpdate = (U32)(iend - ms->window.base);

	mov	eax, DWORD PTR $T1[rsp]
	sub	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rdi+36], eax
$LN38@ZSTD_loadD:

; 2885 :     return 0;
; 2886 : }

	mov	rbx, QWORD PTR [rsp+112]
	xor	eax, eax
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	npad	2
$LN37@ZSTD_loadD:
	DD	$LN9@ZSTD_loadD
	DD	$LN10@ZSTD_loadD
	DD	$LN11@ZSTD_loadD
	DD	$LN11@ZSTD_loadD
	DD	$LN11@ZSTD_loadD
	DD	$LN13@ZSTD_loadD
	DD	$LN13@ZSTD_loadD
	DD	$LN13@ZSTD_loadD
	DD	$LN13@ZSTD_loadD
ZSTD_loadDictionaryContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
normalizedCounter$ = 8
dictMaxSymbolValue$ = 16
maxSymbolValue$ = 24
ZSTD_checkDictNCount PROC

; 2894 :     U32 s;
; 2895 :     RETURN_ERROR_IF(dictMaxSymbolValue < maxSymbolValue, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	edx, r8d
	jb	SHORT $LN11@ZSTD_check

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	xor	eax, eax
$LL4@ZSTD_check:

; 2897 :         RETURN_ERROR_IF(normalizedCounter[s] == 0, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	WORD PTR [rcx], 0
	je	SHORT $LN11@ZSTD_check

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	inc	eax
	add	rcx, 2
	cmp	eax, r8d
	jbe	SHORT $LL4@ZSTD_check

; 2898 :     }
; 2899 :     return 0;

	xor	eax, eax

; 2900 : }

	ret	0
$LN11@ZSTD_check:

; 2897 :         RETURN_ERROR_IF(normalizedCounter[s] == 0, dictionary_corrupted, "dict fse tables don't have all symbols");

	mov	rax, -30

; 2900 : }

	ret	0
ZSTD_checkDictNCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
litlengthMaxValue$1 = 48
matchlengthLog$2 = 48
hasZeroWeights$3 = 48
matchlengthMaxValue$4 = 52
offcodeLog$5 = 52
maxSymbolValue$6 = 52
litlengthLog$7 = 56
litlengthNCount$8 = 64
matchlengthNCount$9 = 64
__$ArrayPad$ = 176
bs$ = 272
workspace$ = 280
offcodeNCount$ = 288
offcodeMaxValue$ = 296
dict$ = 304
dictSize$ = 312
ZSTD_loadCEntropy PROC

; 2905 : {

$LN88:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-15]
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax
	mov	r13, QWORD PTR dict$[rbp-185]

; 2906 :     const BYTE* dictPtr = (const BYTE*)dict;    /* skip magic num and dict ID */
; 2907 :     const BYTE* const dictEnd = dictPtr + dictSize;
; 2908 :     dictPtr += 8;
; 2909 :     bs->entropy.huf.repeatMode = HUF_repeat_check;
; 2910 : 
; 2911 :     {   unsigned maxSymbolValue = 255;
; 2912 :         unsigned hasZeroWeights = 1;
; 2913 :         size_t const hufHeaderSize = HUF_readCTable((HUF_CElt*)bs->entropy.huf.CTable, &maxSymbolValue, dictPtr,

	lea	rax, QWORD PTR hasZeroWeights$3[rsp]
	mov	r15, QWORD PTR dictSize$[rbp-185]
	mov	rdi, r9
	mov	r14, r8
	mov	DWORD PTR [rcx+1024], 1
	mov	r12, rdx
	mov	DWORD PTR maxSymbolValue$6[rsp], 255	; 000000ffH
	lea	rbx, QWORD PTR [r13+8]
	mov	DWORD PTR hasZeroWeights$3[rsp], 1
	add	r15, r13
	mov	QWORD PTR [rsp+32], rax
	mov	r9, r15
	lea	rdx, QWORD PTR maxSymbolValue$6[rsp]
	sub	r9, rbx
	mov	r8, rbx
	mov	rsi, rcx
	call	HUF_readCTable

; 2914 :             dictEnd-dictPtr, &hasZeroWeights);
; 2915 : 
; 2916 :         /* We only set the loaded table as valid if it contains all non-zero
; 2917 :          * weights. Otherwise, we set it to check */
; 2918 :         if (!hasZeroWeights)

	cmp	DWORD PTR hasZeroWeights$3[rsp], 0
	jne	SHORT $LN8@ZSTD_loadC

; 2919 :             bs->entropy.huf.repeatMode = HUF_repeat_valid;

	mov	DWORD PTR [rsi+1024], 2
$LN8@ZSTD_loadC:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2921 :         RETURN_ERROR_IF(HUF_isError(hufHeaderSize), dictionary_corrupted, "");

	ja	$LN86@ZSTD_loadC

; 2922 :         RETURN_ERROR_IF(maxSymbolValue < 255, dictionary_corrupted, "");

	cmp	DWORD PTR maxSymbolValue$6[rsp], 255	; 000000ffH
	jb	$LN86@ZSTD_loadC

; 2923 :         dictPtr += hufHeaderSize;

	add	rbx, rax

; 2924 :     }
; 2925 : 
; 2926 :     {   unsigned offcodeLog;
; 2927 :         size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, offcodeMaxValue, &offcodeLog, dictPtr, dictEnd-dictPtr);

	lea	r8, QWORD PTR offcodeLog$5[rsp]
	mov	rax, r15
	mov	r9, rbx
	sub	rax, rbx
	mov	rdx, rdi
	mov	rcx, r14
	mov	QWORD PTR [rsp+32], rax
	call	FSE_readNCount
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2928 :         RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, "");

	ja	$LN86@ZSTD_loadC

; 2929 :         RETURN_ERROR_IF(offcodeLog > OffFSELog, dictionary_corrupted, "");

	mov	r9d, DWORD PTR offcodeLog$5[rsp]
	cmp	r9d, 8
	ja	$LN86@ZSTD_loadC

; 2932 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(

	lea	rcx, QWORD PTR [rsi+1028]
	mov	QWORD PTR [rsp+40], 6400		; 00001900H
	mov	r8d, 31
	mov	QWORD PTR [rsp+32], r12
	mov	rdx, r14
	call	FSE_buildCTable_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2932 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(

	ja	$LN86@ZSTD_loadC

; 2933 :                 bs->entropy.fse.offcodeCTable,
; 2934 :                 offcodeNCount, MaxOff, offcodeLog,
; 2935 :                 workspace, HUF_WORKSPACE_SIZE)),
; 2936 :             dictionary_corrupted, "");
; 2937 :         dictPtr += offcodeHeaderSize;

	add	rbx, rdi

; 2938 :     }
; 2939 : 
; 2940 :     {   short matchlengthNCount[MaxML+1];
; 2941 :         unsigned matchlengthMaxValue = MaxML, matchlengthLog;

	mov	DWORD PTR matchlengthMaxValue$4[rsp], 52 ; 00000034H

; 2942 :         size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, dictEnd-dictPtr);

	mov	rax, r15
	lea	r8, QWORD PTR matchlengthLog$2[rsp]
	sub	rax, rbx
	lea	rdx, QWORD PTR matchlengthMaxValue$4[rsp]
	mov	r9, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR matchlengthNCount$9[rbp-185]
	call	FSE_readNCount
	mov	r14, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2943 :         RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, "");

	ja	$LN86@ZSTD_loadC

; 2944 :         RETURN_ERROR_IF(matchlengthLog > MLFSELog, dictionary_corrupted, "");

	mov	r9d, DWORD PTR matchlengthLog$2[rsp]
	cmp	r9d, 9
	ja	$LN86@ZSTD_loadC

; 2895 :     RETURN_ERROR_IF(dictMaxSymbolValue < maxSymbolValue, dictionary_corrupted, "dict fse tables don't have all symbols");

	mov	r8d, DWORD PTR matchlengthMaxValue$4[rsp]
	cmp	r8d, 52					; 00000034H
	jb	$LN86@ZSTD_loadC

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	xor	edi, edi
	lea	rax, QWORD PTR matchlengthNCount$9[rbp-185]
	mov	ecx, edi
	npad	5
$LL49@ZSTD_loadC:

; 2897 :         RETURN_ERROR_IF(normalizedCounter[s] == 0, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	WORD PTR [rax], di
	je	$LN86@ZSTD_loadC

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	inc	ecx
	add	rax, 2
	cmp	ecx, 52					; 00000034H
	jbe	SHORT $LL49@ZSTD_loadC

; 2947 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(

	lea	rcx, QWORD PTR [rsi+1800]
	mov	QWORD PTR [rsp+40], 6400		; 00001900H
	lea	rdx, QWORD PTR matchlengthNCount$9[rbp-185]
	mov	QWORD PTR [rsp+32], r12
	call	FSE_buildCTable_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2947 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(

	ja	$LN86@ZSTD_loadC

; 2948 :                 bs->entropy.fse.matchlengthCTable,
; 2949 :                 matchlengthNCount, matchlengthMaxValue, matchlengthLog,
; 2950 :                 workspace, HUF_WORKSPACE_SIZE)),
; 2951 :             dictionary_corrupted, "");
; 2952 :         dictPtr += matchlengthHeaderSize;

	add	rbx, r14

; 2953 :     }
; 2954 : 
; 2955 :     {   short litlengthNCount[MaxLL+1];
; 2956 :         unsigned litlengthMaxValue = MaxLL, litlengthLog;

	mov	DWORD PTR litlengthMaxValue$1[rsp], 35	; 00000023H

; 2957 :         size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, dictEnd-dictPtr);

	mov	rax, r15
	lea	r8, QWORD PTR litlengthLog$7[rsp]
	sub	rax, rbx
	lea	rdx, QWORD PTR litlengthMaxValue$1[rsp]
	mov	r9, rbx
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR litlengthNCount$8[rbp-185]
	call	FSE_readNCount
	mov	r14, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2958 :         RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, "");

	ja	$LN86@ZSTD_loadC

; 2959 :         RETURN_ERROR_IF(litlengthLog > LLFSELog, dictionary_corrupted, "");

	mov	r9d, DWORD PTR litlengthLog$7[rsp]
	cmp	r9d, 9
	ja	SHORT $LN86@ZSTD_loadC

; 2895 :     RETURN_ERROR_IF(dictMaxSymbolValue < maxSymbolValue, dictionary_corrupted, "dict fse tables don't have all symbols");

	mov	r8d, DWORD PTR litlengthMaxValue$1[rsp]
	cmp	r8d, 35					; 00000023H
	jb	SHORT $LN86@ZSTD_loadC

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	lea	rax, QWORD PTR litlengthNCount$8[rbp-185]
	npad	1
$LL64@ZSTD_loadC:

; 2897 :         RETURN_ERROR_IF(normalizedCounter[s] == 0, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	WORD PTR [rax], 0
	je	SHORT $LN86@ZSTD_loadC

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	inc	edi
	add	rax, 2
	cmp	edi, 35					; 00000023H
	jbe	SHORT $LL64@ZSTD_loadC

; 2962 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(

	lea	rcx, QWORD PTR [rsi+3252]
	mov	QWORD PTR [rsp+40], 6400		; 00001900H
	lea	rdx, QWORD PTR litlengthNCount$8[rbp-185]
	mov	QWORD PTR [rsp+32], r12
	call	FSE_buildCTable_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2962 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(

	ja	SHORT $LN86@ZSTD_loadC

; 2963 :                 bs->entropy.fse.litlengthCTable,
; 2964 :                 litlengthNCount, litlengthMaxValue, litlengthLog,
; 2965 :                 workspace, HUF_WORKSPACE_SIZE)),
; 2966 :             dictionary_corrupted, "");
; 2967 :         dictPtr += litlengthHeaderSize;

	add	rbx, r14

; 2968 :     }
; 2969 : 
; 2970 :     RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, "");

	lea	rcx, QWORD PTR [rbx+12]
	cmp	rcx, r15
	ja	SHORT $LN86@ZSTD_loadC

; 2971 :     bs->rep[0] = MEM_readLE32(dictPtr+0);

	mov	ecx, DWORD PTR [rbx]
	mov	DWORD PTR [rsi+4580], ecx

; 2972 :     bs->rep[1] = MEM_readLE32(dictPtr+4);

	mov	ecx, DWORD PTR [rbx+4]
	mov	DWORD PTR [rsi+4584], ecx

; 2973 :     bs->rep[2] = MEM_readLE32(dictPtr+8);

	mov	ecx, DWORD PTR [rbx+8]

; 2974 :     dictPtr += 12;
; 2975 : 
; 2976 :     return dictPtr - (const BYTE*)dict;

	sub	rbx, r13
	mov	DWORD PTR [rsi+4588], ecx
	lea	rax, QWORD PTR [rbx+12]
	jmp	SHORT $LN1@ZSTD_loadC
$LN86@ZSTD_loadC:

; 2968 :     }
; 2969 : 
; 2970 :     RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, "");

	mov	rax, -30
$LN1@ZSTD_loadC:

; 2977 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_loadCEntropy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
offcodeMaxValue$ = 64
ws$GSCopy$1$ = 72
offcodeNCount$ = 80
__$ArrayPad$ = 144
bs$ = 240
ms$ = 248
ws$ = 256
params$ = 264
dict$ = 272
dictSize$ = 280
dtlm$ = 288
workspace$ = 296
ZSTD_loadZstdDictionary PROC

; 2995 : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, QWORD PTR dict$[rsp]

; 2996 :     const BYTE* dictPtr = (const BYTE*)dict;
; 2997 :     const BYTE* const dictEnd = dictPtr + dictSize;
; 2998 :     short offcodeNCount[MaxOff+1];
; 2999 :     unsigned offcodeMaxValue = MaxOff;
; 3000 :     size_t dictID;
; 3001 :     size_t eSize;
; 3002 : 
; 3003 :     ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
; 3004 :     assert(dictSize >= 8);
; 3005 :     assert(MEM_readLE32(dictPtr) == ZSTD_MAGIC_DICTIONARY);
; 3006 : 
; 3007 :     dictID = params->fParams.noDictIDFlag ? 0 :  MEM_readLE32(dictPtr + 4 /* skip magic number */ );

	xor	ebx, ebx
	mov	r13, rdx
	mov	rdx, QWORD PTR dictSize$[rsp]
	mov	edi, 31
	mov	r10, QWORD PTR workspace$[rsp]
	mov	r12, r9
	mov	QWORD PTR ws$GSCopy$1$[rsp], r8
	mov	rbp, rcx
	mov	DWORD PTR offcodeMaxValue$[rsp], edi
	lea	rsi, QWORD PTR [rdx+r14]
	mov	eax, ebx
	cmp	DWORD PTR [r9+40], ebx
	jne	SHORT $LN27@ZSTD_loadZ
	mov	eax, DWORD PTR [r14+4]
$LN27@ZSTD_loadZ:

; 3008 :     eSize = ZSTD_loadCEntropy(bs, workspace, offcodeNCount, &offcodeMaxValue, dict, dictSize);

	mov	QWORD PTR [rsp+40], rdx
	lea	r9, QWORD PTR offcodeMaxValue$[rsp]
	mov	rdx, r10
	mov	r15d, eax
	lea	r8, QWORD PTR offcodeNCount$[rsp]
	mov	QWORD PTR [rsp+32], r14
	call	ZSTD_loadCEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3009 :     FORWARD_IF_ERROR(eSize, "ZSTD_loadCEntropy failed");

	ja	$LN1@ZSTD_loadZ

; 3010 :     dictPtr += eSize;

	lea	r10, QWORD PTR [r14+rax]

; 3011 : 
; 3012 :     {   size_t const dictContentSize = (size_t)(dictEnd - dictPtr);
; 3013 :         U32 offcodeMax = MaxOff;
; 3014 :         if (dictContentSize <= ((U32)-1) - 128 KB) {

	mov	ecx, -131073				; fffdffffH
	sub	rsi, r10
	mov	eax, edi
	cmp	rsi, rcx
	ja	SHORT $LN7@ZSTD_loadZ

; 3015 :             U32 const maxOffset = (U32)dictContentSize + 128 KB; /* The maximum offset that must be supported */

	lea	eax, DWORD PTR [rsi+131072]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, ebx
	cmovne	eax, ecx
$LN7@ZSTD_loadZ:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3019 :         FORWARD_IF_ERROR(ZSTD_checkDictNCount(offcodeNCount, offcodeMaxValue, MIN(offcodeMax, MaxOff)), "");

	cmp	eax, edi
	cmovb	edi, eax

; 2895 :     RETURN_ERROR_IF(dictMaxSymbolValue < maxSymbolValue, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	DWORD PTR offcodeMaxValue$[rsp], edi
	jb	$LN49@ZSTD_loadZ

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	mov	ecx, ebx
	lea	rax, QWORD PTR offcodeNCount$[rsp]
$LL35@ZSTD_loadZ:

; 2897 :         RETURN_ERROR_IF(normalizedCounter[s] == 0, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	WORD PTR [rax], bx
	je	SHORT $LN49@ZSTD_loadZ

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	inc	ecx
	add	rax, 2
	cmp	ecx, edi
	jbe	SHORT $LL35@ZSTD_loadZ

; 3020 :         /* All repCodes must be <= dictContentSize and != 0*/
; 3021 :         {   U32 u;
; 3022 :             for (u=0; u<3; u++) {

	lea	rdx, QWORD PTR [rbp+4580]
	npad	3
$LL10@ZSTD_loadZ:

; 3023 :                 RETURN_ERROR_IF(bs->rep[u] == 0, dictionary_corrupted, "");

	mov	eax, DWORD PTR [rdx]
	test	eax, eax
	je	SHORT $LN49@ZSTD_loadZ

; 3024 :                 RETURN_ERROR_IF(bs->rep[u] > dictContentSize, dictionary_corrupted, "");

	cmp	rax, rsi
	ja	SHORT $LN49@ZSTD_loadZ

; 3020 :         /* All repCodes must be <= dictContentSize and != 0*/
; 3021 :         {   U32 u;
; 3022 :             for (u=0; u<3; u++) {

	inc	ebx
	add	rdx, 4
	cmp	ebx, 3
	jb	SHORT $LL10@ZSTD_loadZ

; 3030 :         FORWARD_IF_ERROR(ZSTD_loadDictionaryContent(

	mov	edx, DWORD PTR dtlm$[rsp]
	mov	r9, r12
	mov	r8, QWORD PTR ws$GSCopy$1$[rsp]
	mov	rcx, r13
	mov	DWORD PTR [rsp+48], edx
	xor	edx, edx
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], r10
	mov	DWORD PTR [rbp+4568], 2
	mov	DWORD PTR [rbp+4572], 2
	mov	DWORD PTR [rbp+4576], 2
	call	ZSTD_loadDictionaryContent
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3030 :         FORWARD_IF_ERROR(ZSTD_loadDictionaryContent(

	cmova	r15, rax
	mov	rax, r15

; 3031 :             ms, NULL, ws, params, dictPtr, dictContentSize, dtlm), "");
; 3032 :         return dictID;

	jmp	SHORT $LN1@ZSTD_loadZ
$LN49@ZSTD_loadZ:

; 3024 :                 RETURN_ERROR_IF(bs->rep[u] > dictContentSize, dictionary_corrupted, "");

	mov	rax, -30
$LN1@ZSTD_loadZ:

; 3033 :     }
; 3034 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_loadZstdDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
offcodeMaxValue$1 = 64
ws$GSCopy$1$ = 72
dictID$1$ = 80
offcodeNCount$2 = 96
__$ArrayPad$ = 160
bs$ = 256
ms$ = 264
ls$ = 272
ws$ = 280
params$ = 288
dict$ = 296
dictSize$ = 304
dictContentType$ = 312
dtlm$ = 320
workspace$ = 328
ZSTD_compress_insertDictionary PROC

; 3048 : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, QWORD PTR dict$[rsp]
	mov	r13, rdx
	mov	r12, QWORD PTR params$[rsp]
	mov	rsi, r9
	mov	rdx, QWORD PTR workspace$[rsp]
	mov	r11, r8
	mov	QWORD PTR ws$GSCopy$1$[rsp], r9
	mov	r15, rcx

; 3049 :     DEBUGLOG(4, "ZSTD_compress_insertDictionary (dictSize=%u)", (U32)dictSize);
; 3050 :     if ((dict==NULL) || (dictSize<8)) {

	test	r14, r14
	je	$LN3@ZSTD_compr
	mov	r10, QWORD PTR dictSize$[rsp]
	cmp	r10, 8
	jb	$LN3@ZSTD_compr

; 3053 :     }
; 3054 : 
; 3055 :     ZSTD_reset_compressedBlockState(bs);
; 3056 : 
; 3057 :     /* dict restricted modes */
; 3058 :     if (dictContentType == ZSTD_dct_rawContent)

	mov	eax, DWORD PTR dictContentType$[rsp]

; 1286 :         bs->rep[i] = repStartValue[i];

	lea	rdi, QWORD PTR [rcx+4580]
	mov	DWORD PTR [rdi], 1

; 1287 :     bs->entropy.huf.repeatMode = HUF_repeat_none;

	xor	ebx, ebx
	mov	DWORD PTR [rcx+4584], 4
	mov	DWORD PTR [rcx+4588], 8
	mov	DWORD PTR [rcx+1024], ebx

; 1288 :     bs->entropy.fse.offcode_repeatMode = FSE_repeat_none;

	mov	QWORD PTR [rcx+4568], rbx

; 1289 :     bs->entropy.fse.matchlength_repeatMode = FSE_repeat_none;
; 1290 :     bs->entropy.fse.litlength_repeatMode = FSE_repeat_none;

	mov	DWORD PTR [rcx+4576], ebx

; 3053 :     }
; 3054 : 
; 3055 :     ZSTD_reset_compressedBlockState(bs);
; 3056 : 
; 3057 :     /* dict restricted modes */
; 3058 :     if (dictContentType == ZSTD_dct_rawContent)

	cmp	eax, 1
	jne	SHORT $LN6@ZSTD_compr
$LN82@ZSTD_compr:

; 3073 :         bs, ms, ws, params, dict, dictSize, dtlm, workspace);
; 3074 : }

	mov	eax, DWORD PTR dtlm$[rsp]
	mov	r9, r12
	mov	DWORD PTR [rsp+48], eax
	mov	r8, rsi
	mov	QWORD PTR [rsp+40], r10
	mov	rdx, r11
	mov	rcx, r13
	mov	QWORD PTR [rsp+32], r14
	call	ZSTD_loadDictionaryContent
	jmp	$LN1@ZSTD_compr
$LN6@ZSTD_compr:

; 3059 :         return ZSTD_loadDictionaryContent(ms, ls, ws, params, dict, dictSize, dtlm);
; 3060 : 
; 3061 :     if (MEM_readLE32(dict) != ZSTD_MAGIC_DICTIONARY) {

	cmp	DWORD PTR [r14], -332356553		; ec30a437H
	je	SHORT $LN9@ZSTD_compr

; 3062 :         if (dictContentType == ZSTD_dct_auto) {

	test	eax, eax
	je	SHORT $LN82@ZSTD_compr

; 3063 :             DEBUGLOG(4, "raw content dictionary detected");
; 3064 :             return ZSTD_loadDictionaryContent(
; 3065 :                 ms, ls, ws, params, dict, dictSize, dtlm);
; 3066 :         }
; 3067 :         RETURN_ERROR_IF(dictContentType == ZSTD_dct_fullDict, dictionary_wrong, "");

	cmp	eax, 2
	je	$LN79@ZSTD_compr
$LN9@ZSTD_compr:

; 2999 :     unsigned offcodeMaxValue = MaxOff;

	mov	esi, 31
	mov	QWORD PTR [rsp+184], rbp

; 2898 :     }
; 2899 :     return 0;
; 2900 : }
; 2901 : 
; 2902 : size_t ZSTD_loadCEntropy(ZSTD_compressedBlockState_t* bs, void* workspace,
; 2903 :                          short* offcodeNCount, unsigned* offcodeMaxValue,
; 2904 :                          const void* const dict, size_t dictSize)
; 2905 : {
; 2906 :     const BYTE* dictPtr = (const BYTE*)dict;    /* skip magic num and dict ID */
; 2907 :     const BYTE* const dictEnd = dictPtr + dictSize;
; 2908 :     dictPtr += 8;
; 2909 :     bs->entropy.huf.repeatMode = HUF_repeat_check;
; 2910 : 
; 2911 :     {   unsigned maxSymbolValue = 255;
; 2912 :         unsigned hasZeroWeights = 1;
; 2913 :         size_t const hufHeaderSize = HUF_readCTable((HUF_CElt*)bs->entropy.huf.CTable, &maxSymbolValue, dictPtr,
; 2914 :             dictEnd-dictPtr, &hasZeroWeights);
; 2915 : 
; 2916 :         /* We only set the loaded table as valid if it contains all non-zero
; 2917 :          * weights. Otherwise, we set it to check */
; 2918 :         if (!hasZeroWeights)
; 2919 :             bs->entropy.huf.repeatMode = HUF_repeat_valid;
; 2920 : 
; 2921 :         RETURN_ERROR_IF(HUF_isError(hufHeaderSize), dictionary_corrupted, "");
; 2922 :         RETURN_ERROR_IF(maxSymbolValue < 255, dictionary_corrupted, "");
; 2923 :         dictPtr += hufHeaderSize;
; 2924 :     }
; 2925 : 
; 2926 :     {   unsigned offcodeLog;
; 2927 :         size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, offcodeMaxValue, &offcodeLog, dictPtr, dictEnd-dictPtr);
; 2928 :         RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, "");
; 2929 :         RETURN_ERROR_IF(offcodeLog > OffFSELog, dictionary_corrupted, "");
; 2930 :         /* Defer checking offcodeMaxValue because we need to know the size of the dictionary content */
; 2931 :         /* fill all offset symbols to avoid garbage at end of table */
; 2932 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(
; 2933 :                 bs->entropy.fse.offcodeCTable,
; 2934 :                 offcodeNCount, MaxOff, offcodeLog,
; 2935 :                 workspace, HUF_WORKSPACE_SIZE)),
; 2936 :             dictionary_corrupted, "");
; 2937 :         dictPtr += offcodeHeaderSize;
; 2938 :     }
; 2939 : 
; 2940 :     {   short matchlengthNCount[MaxML+1];
; 2941 :         unsigned matchlengthMaxValue = MaxML, matchlengthLog;
; 2942 :         size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, dictEnd-dictPtr);
; 2943 :         RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, "");
; 2944 :         RETURN_ERROR_IF(matchlengthLog > MLFSELog, dictionary_corrupted, "");
; 2945 :         /* Every match length code must have non-zero probability */
; 2946 :         FORWARD_IF_ERROR( ZSTD_checkDictNCount(matchlengthNCount, matchlengthMaxValue, MaxML), "");
; 2947 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(
; 2948 :                 bs->entropy.fse.matchlengthCTable,
; 2949 :                 matchlengthNCount, matchlengthMaxValue, matchlengthLog,
; 2950 :                 workspace, HUF_WORKSPACE_SIZE)),
; 2951 :             dictionary_corrupted, "");
; 2952 :         dictPtr += matchlengthHeaderSize;
; 2953 :     }
; 2954 : 
; 2955 :     {   short litlengthNCount[MaxLL+1];
; 2956 :         unsigned litlengthMaxValue = MaxLL, litlengthLog;
; 2957 :         size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, dictEnd-dictPtr);
; 2958 :         RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, "");
; 2959 :         RETURN_ERROR_IF(litlengthLog > LLFSELog, dictionary_corrupted, "");
; 2960 :         /* Every literal length code must have non-zero probability */
; 2961 :         FORWARD_IF_ERROR( ZSTD_checkDictNCount(litlengthNCount, litlengthMaxValue, MaxLL), "");
; 2962 :         RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(
; 2963 :                 bs->entropy.fse.litlengthCTable,
; 2964 :                 litlengthNCount, litlengthMaxValue, litlengthLog,
; 2965 :                 workspace, HUF_WORKSPACE_SIZE)),
; 2966 :             dictionary_corrupted, "");
; 2967 :         dictPtr += litlengthHeaderSize;
; 2968 :     }
; 2969 : 
; 2970 :     RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, "");
; 2971 :     bs->rep[0] = MEM_readLE32(dictPtr+0);
; 2972 :     bs->rep[1] = MEM_readLE32(dictPtr+4);
; 2973 :     bs->rep[2] = MEM_readLE32(dictPtr+8);
; 2974 :     dictPtr += 12;
; 2975 : 
; 2976 :     return dictPtr - (const BYTE*)dict;
; 2977 : }
; 2978 : 
; 2979 : /* Dictionary format :
; 2980 :  * See :
; 2981 :  * https://github.com/facebook/zstd/blob/master/doc/zstd_compression_format.md#dictionary-format
; 2982 :  */
; 2983 : /*! ZSTD_loadZstdDictionary() :
; 2984 :  * @return : dictID, or an error code
; 2985 :  *  assumptions : magic number supposed already checked
; 2986 :  *                dictSize supposed >= 8
; 2987 :  */
; 2988 : static size_t ZSTD_loadZstdDictionary(ZSTD_compressedBlockState_t* bs,
; 2989 :                                       ZSTD_matchState_t* ms,
; 2990 :                                       ZSTD_cwksp* ws,
; 2991 :                                       ZSTD_CCtx_params const* params,
; 2992 :                                       const void* dict, size_t dictSize,
; 2993 :                                       ZSTD_dictTableLoadMethod_e dtlm,
; 2994 :                                       void* workspace)
; 2995 : {
; 2996 :     const BYTE* dictPtr = (const BYTE*)dict;
; 2997 :     const BYTE* const dictEnd = dictPtr + dictSize;

	lea	rbp, QWORD PTR [r14+r10]

; 2998 :     short offcodeNCount[MaxOff+1];
; 2999 :     unsigned offcodeMaxValue = MaxOff;

	mov	DWORD PTR offcodeMaxValue$1[rsp], esi

; 3000 :     size_t dictID;
; 3001 :     size_t eSize;
; 3002 : 
; 3003 :     ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
; 3004 :     assert(dictSize >= 8);
; 3005 :     assert(MEM_readLE32(dictPtr) == ZSTD_MAGIC_DICTIONARY);
; 3006 : 
; 3007 :     dictID = params->fParams.noDictIDFlag ? 0 :  MEM_readLE32(dictPtr + 4 /* skip magic number */ );

	mov	eax, ebx
	cmp	DWORD PTR [r12+40], ebx
	jne	SHORT $LN43@ZSTD_compr
	mov	eax, DWORD PTR [r14+4]
$LN43@ZSTD_compr:

; 3008 :     eSize = ZSTD_loadCEntropy(bs, workspace, offcodeNCount, &offcodeMaxValue, dict, dictSize);

	mov	QWORD PTR [rsp+40], r10
	lea	r9, QWORD PTR offcodeMaxValue$1[rsp]
	lea	r8, QWORD PTR offcodeNCount$2[rsp]
	mov	QWORD PTR [rsp+32], r14
	mov	QWORD PTR dictID$1$[rsp], rax
	call	ZSTD_loadCEntropy
	mov	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3009 :     FORWARD_IF_ERROR(eSize, "ZSTD_loadCEntropy failed");

	ja	$LN17@ZSTD_compr

; 3010 :     dictPtr += eSize;

	lea	rdx, QWORD PTR [rax+r14]

; 3011 : 
; 3012 :     {   size_t const dictContentSize = (size_t)(dictEnd - dictPtr);
; 3013 :         U32 offcodeMax = MaxOff;
; 3014 :         if (dictContentSize <= ((U32)-1) - 128 KB) {

	mov	ecx, -131073				; fffdffffH
	sub	rbp, rdx
	mov	eax, esi
	cmp	rbp, rcx
	ja	SHORT $LN23@ZSTD_compr

; 3015 :             U32 const maxOffset = (U32)dictContentSize + 128 KB; /* The maximum offset that must be supported */

	lea	eax, DWORD PTR [rbp+131072]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, ebx
	cmovne	eax, ecx
$LN23@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3019 :         FORWARD_IF_ERROR(ZSTD_checkDictNCount(offcodeNCount, offcodeMaxValue, MIN(offcodeMax, MaxOff)), "");

	cmp	eax, esi
	cmovb	esi, eax

; 2895 :     RETURN_ERROR_IF(dictMaxSymbolValue < maxSymbolValue, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	DWORD PTR offcodeMaxValue$1[rsp], esi
	jb	$LN78@ZSTD_compr

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	mov	ecx, ebx
	lea	rax, QWORD PTR offcodeNCount$2[rsp]
$LL51@ZSTD_compr:

; 2897 :         RETURN_ERROR_IF(normalizedCounter[s] == 0, dictionary_corrupted, "dict fse tables don't have all symbols");

	cmp	WORD PTR [rax], bx
	je	$LN78@ZSTD_compr

; 2896 :     for (s = 0; s <= maxSymbolValue; ++s) {

	inc	ecx
	add	rax, 2
	cmp	ecx, esi
	jbe	SHORT $LL51@ZSTD_compr
$LL26@ZSTD_compr:

; 3023 :                 RETURN_ERROR_IF(bs->rep[u] == 0, dictionary_corrupted, "");

	mov	eax, DWORD PTR [rdi]
	test	eax, eax
	je	SHORT $LN78@ZSTD_compr

; 3024 :                 RETURN_ERROR_IF(bs->rep[u] > dictContentSize, dictionary_corrupted, "");

	cmp	rax, rbp
	ja	SHORT $LN78@ZSTD_compr

; 3020 :         /* All repCodes must be <= dictContentSize and != 0*/
; 3021 :         {   U32 u;
; 3022 :             for (u=0; u<3; u++) {

	inc	ebx
	add	rdi, 4
	cmp	ebx, 3
	jb	SHORT $LL26@ZSTD_compr

; 3025 :         }   }
; 3026 : 
; 3027 :         bs->entropy.fse.offcode_repeatMode = FSE_repeat_valid;
; 3028 :         bs->entropy.fse.matchlength_repeatMode = FSE_repeat_valid;
; 3029 :         bs->entropy.fse.litlength_repeatMode = FSE_repeat_valid;
; 3030 :         FORWARD_IF_ERROR(ZSTD_loadDictionaryContent(

	mov	eax, DWORD PTR dtlm$[rsp]
	mov	r9, r12
	mov	r8, QWORD PTR ws$GSCopy$1$[rsp]
	mov	rcx, r13
	mov	DWORD PTR [rsp+48], eax
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+32], rdx
	xor	edx, edx
	mov	DWORD PTR [r15+4568], 2
	mov	DWORD PTR [r15+4572], 2
	mov	DWORD PTR [r15+4576], 2
	call	ZSTD_loadDictionaryContent
	mov	rcx, QWORD PTR dictID$1$[rsp]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3072 :     return ZSTD_loadZstdDictionary(

	mov	rbp, QWORD PTR [rsp+184]

; 3030 :         FORWARD_IF_ERROR(ZSTD_loadDictionaryContent(

	cmova	rcx, rax

; 3072 :     return ZSTD_loadZstdDictionary(

	mov	rax, rcx
	jmp	SHORT $LN1@ZSTD_compr
$LN78@ZSTD_compr:
	mov	rcx, -30
$LN17@ZSTD_compr:
	mov	rbp, QWORD PTR [rsp+184]
	mov	rax, rcx
	jmp	SHORT $LN1@ZSTD_compr
$LN3@ZSTD_compr:

; 3051 :         RETURN_ERROR_IF(dictContentType == ZSTD_dct_fullDict, dictionary_wrong, "");

	cmp	DWORD PTR dictContentType$[rsp], 2
	jne	SHORT $LN4@ZSTD_compr
$LN79@ZSTD_compr:
	mov	rax, -32				; ffffffffffffffe0H
	jmp	SHORT $LN1@ZSTD_compr
$LN4@ZSTD_compr:

; 3052 :         return 0;

	xor	eax, eax
$LN1@ZSTD_compr:

; 3073 :         bs, ms, ws, params, dict, dictSize, dtlm, workspace);
; 3074 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ZSTD_compress_insertDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 80
cctx$ = 240
dict$ = 248
dictSize$ = 256
dictContentType$ = 264
dtlm$dead$ = 272
cdict$ = 280
params$ = 288
pledgedSrcSize$ = 296
zbuff$ = 304
ZSTD_compressBegin_internal PROC

; 3088 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 224				; 000000e0H

; 3089 :     DEBUGLOG(4, "ZSTD_compressBegin_internal: wlog=%u", params->cParams.windowLog);
; 3090 :     /* params are supposed to be fully validated at this point */
; 3091 :     assert(!ZSTD_isError(ZSTD_checkCParams(params->cParams)));
; 3092 :     assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
; 3093 :     if ( (cdict)
; 3094 :       && (cdict->dictContentSize > 0)
; 3095 :       && ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF
; 3096 :         || pledgedSrcSize < cdict->dictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER
; 3097 :         || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
; 3098 :         || cdict->compressionLevel == 0)
; 3099 :       && (params->attachDictPref != ZSTD_dictForceLoad) ) {

	mov	rdi, QWORD PTR cdict$[rsp]
	mov	rbp, r8
	mov	r8, QWORD PTR pledgedSrcSize$[rsp]
	mov	rbx, rcx
	mov	rcx, QWORD PTR params$[rsp]
	mov	r14d, r9d
	mov	rsi, rdx
	test	rdi, rdi
	je	SHORT $LN4@ZSTD_compr
	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN4@ZSTD_compr
	cmp	r8, 131072				; 00020000H
	jb	SHORT $LN9@ZSTD_compr
	lea	rax, QWORD PTR [rax+rax*2]
	add	rax, rax
	cmp	r8, rax
	jb	SHORT $LN9@ZSTD_compr
	cmp	r8, -1
	je	SHORT $LN9@ZSTD_compr
	cmp	DWORD PTR [rdi+4924], 0
	jne	SHORT $LN4@ZSTD_compr
$LN9@ZSTD_compr:
	cmp	DWORD PTR [rcx+68], 3
	je	SHORT $LN4@ZSTD_compr

; 3100 :         return ZSTD_resetCCtx_usingCDict(cctx, cdict, params, pledgedSrcSize, zbuff);

	mov	eax, DWORD PTR zbuff$[rsp]
	mov	r9, r8
	mov	r8, rcx
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, rbx
	mov	rdx, rdi
	call	ZSTD_resetCCtx_usingCDict
	jmp	$LN1@ZSTD_compr
$LN4@ZSTD_compr:

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	movaps	xmm0, XMMWORD PTR [rcx]
	lea	rdx, QWORD PTR $T1[rsp]
	movaps	xmm1, XMMWORD PTR [rcx+16]
	xor	r9d, r9d
	mov	eax, DWORD PTR zbuff$[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [rcx+32]
	movaps	XMMWORD PTR $T1[rsp+32], xmm0
	movaps	xmm0, XMMWORD PTR [rcx+64]
	movaps	XMMWORD PTR $T1[rsp+16], xmm1
	movaps	xmm1, XMMWORD PTR [rcx+48]
	movaps	XMMWORD PTR $T1[rsp+64], xmm0
	movaps	xmm0, XMMWORD PTR [rcx+96]
	movaps	XMMWORD PTR $T1[rsp+48], xmm1
	movaps	xmm1, XMMWORD PTR [rcx+80]
	movaps	XMMWORD PTR $T1[rsp+96], xmm0
	movaps	xmm0, XMMWORD PTR [rcx+128]
	movaps	XMMWORD PTR $T1[rsp+80], xmm1
	movaps	xmm1, XMMWORD PTR [rcx+112]
	mov	rcx, rbx
	movaps	XMMWORD PTR $T1[rsp+128], xmm0
	movaps	XMMWORD PTR $T1[rsp+112], xmm1
	mov	DWORD PTR [rsp+32], eax
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	ja	SHORT $LN1@ZSTD_compr

; 3104 :                                      ZSTDcrp_makeClean, zbuff) , "");
; 3105 :     {   size_t const dictID = cdict ?

	mov	rax, QWORD PTR [rbx+992]
	lea	rcx, QWORD PTR [rbx+160]
	lea	r9, QWORD PTR [rbx+312]
	lea	r8, QWORD PTR [rbx+648]
	lea	rdx, QWORD PTR [rbx+776]
	test	rdi, rdi
	je	SHORT $LN15@ZSTD_compr
	mov	rsi, QWORD PTR [rdi]
	mov	rbp, QWORD PTR [rdi+8]
$LN15@ZSTD_compr:

; 3115 :         FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");

	mov	QWORD PTR [rsp+72], rax
	mov	DWORD PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], r14d
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR [rbx+760]
	call	ZSTD_compress_insertDictionary
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3115 :         FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");

	ja	SHORT $LN1@ZSTD_compr

; 3116 :         assert(dictID <= UINT_MAX);
; 3117 :         cctx->dictID = (U32)dictID;

	mov	DWORD PTR [rbx+304], eax

; 3118 :     }
; 3119 :     return 0;

	xor	eax, eax
$LN1@ZSTD_compr:

; 3120 : }

	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
ZSTD_compressBegin_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 80
cctx$ = 128
dict$ = 136
dictSize$ = 144
dictContentType$ = 152
dtlm$dead$ = 160
cdict$ = 168
params$ = 176
pledgedSrcSize$ = 184
ZSTD_compressBegin_advanced_internal PROC

; 3129 : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 112				; 00000070H

; 3132 :     FORWARD_IF_ERROR( ZSTD_checkCParams(params->cParams) , "");

	mov	r11, QWORD PTR params$[rsp]
	mov	rbp, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	mov	ebx, r9d
	mov	rdi, r8
	mov	rsi, rdx
	movups	xmm0, XMMWORD PTR [r11+4]
	mov	eax, DWORD PTR [r11+28]
	movsd	xmm1, QWORD PTR [r11+20]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	mov	DWORD PTR $T1[rsp+24], eax
	call	ZSTD_checkCParams
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3132 :     FORWARD_IF_ERROR( ZSTD_checkCParams(params->cParams) , "");

	ja	SHORT $LN1@ZSTD_compr

; 3133 :     return ZSTD_compressBegin_internal(cctx,

	mov	rax, QWORD PTR pledgedSrcSize$[rsp]
	mov	r9d, ebx
	mov	DWORD PTR [rsp+64], 0
	mov	r8, rdi
	mov	QWORD PTR [rsp+56], rax
	mov	rdx, rsi
	mov	rax, QWORD PTR cdict$[rsp]
	mov	rcx, rbp
	mov	QWORD PTR [rsp+48], r11
	mov	QWORD PTR [rsp+40], rax
	call	ZSTD_compressBegin_internal
$LN1@ZSTD_compr:

; 3134 :                                        dict, dictSize, dictContentType, dtlm,
; 3135 :                                        cdict,
; 3136 :                                        params, pledgedSrcSize,
; 3137 :                                        ZSTDb_not_buffered);
; 3138 : }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
ZSTD_compressBegin_advanced_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 48
dst$ = 56
dstCapacity$ = 64
ZSTD_writeEpilogue PROC

; 3174 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 3175 :     BYTE* const ostart = (BYTE*)dst;
; 3176 :     BYTE* op = ostart;
; 3177 :     size_t fhSize = 0;
; 3178 : 
; 3179 :     DEBUGLOG(4, "ZSTD_writeEpilogue");
; 3180 :     RETURN_ERROR_IF(cctx->stage == ZSTDcs_created, stage_wrong, "init missing");

	mov	eax, DWORD PTR [rcx]
	mov	rsi, rdx
	mov	rdi, rcx
	mov	rbx, rdx
	test	eax, eax
	jne	SHORT $LN5@ZSTD_write
	mov	rax, -60				; ffffffffffffffc4H

; 3210 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@ZSTD_write:

; 3181 : 
; 3182 :     /* special case : empty frame */
; 3183 :     if (cctx->stage == ZSTDcs_init) {

	cmp	eax, 1
	jne	$LN7@ZSTD_write

; 2664 :     U32   const singleSegment = params->fParams.contentSizeFlag && (windowSize >= pledgedSrcSize);

	movzx	r10d, BYTE PTR [rcx+164]

; 2665 :     BYTE  const windowLogByte = (BYTE)((params->cParams.windowLog - ZSTD_WINDOWLOG_ABSOLUTEMIN) << 3);
; 2666 :     U32   const fcsCode = params->fParams.contentSizeFlag ?
; 2667 :                      (pledgedSrcSize>=256) + (pledgedSrcSize>=65536+256) + (pledgedSrcSize>=0xFFFFFFFFU) : 0;  /* 0-3 */
; 2668 :     BYTE  const frameHeaderDescriptionByte = (BYTE)(dictIDSizeCode + (checksumFlag<<2) + (singleSegment<<5) + (fcsCode<<6) );

	xor	edx, edx
	mov	r11d, DWORD PTR [rcx+192]
	sub	r10b, 10
	shl	r10b, 3
	mov	ebx, 4
	cmp	DWORD PTR [rcx+196], edx
	mov	eax, r11d
	cmovg	edx, ebx
	neg	eax
	sbb	cl, cl

; 2669 :     size_t pos=0;

	xor	r9d, r9d
	and	cl, 32					; 00000020H
	add	dl, cl

; 2670 : 
; 2671 :     assert(!(params->fParams.contentSizeFlag && pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN));
; 2672 :     RETURN_ERROR_IF(dstCapacity < ZSTD_FRAMEHEADERSIZE_MAX, dstSize_tooSmall,

	cmp	r8, 18
	jae	SHORT $LN22@ZSTD_write
$LN48@ZSTD_write:

; 3210 : }

	mov	rax, -70				; ffffffffffffffbaH
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@ZSTD_write:

; 2677 :     if (params->format == ZSTD_f_zstd1) {

	cmp	DWORD PTR [rdi+160], r9d
	jne	SHORT $LN24@ZSTD_write

; 2678 :         MEM_writeLE32(dst, ZSTD_MAGICNUMBER);

	mov	DWORD PTR [rsi], -47205080		; fd2fb528H

; 2679 :         pos = 4;

	mov	r9, rbx
$LN24@ZSTD_write:

; 2680 :     }
; 2681 :     op[pos++] = frameHeaderDescriptionByte;
; 2682 :     if (!singleSegment) op[pos++] = windowLogByte;

	xor	ecx, ecx
	mov	BYTE PTR [r9+rsi], dl
	test	r11d, r11d
	movzx	eax, r10b
	lea	rdx, QWORD PTR [r9+2]
	cmove	ecx, eax

; 3187 :         op += fhSize;

	lea	rbx, QWORD PTR [rdx+rsi]

; 2682 :     if (!singleSegment) op[pos++] = windowLogByte;

	mov	BYTE PTR [rsi+r9+1], cl

; 3184 :         fhSize = ZSTD_writeFrameHeader(dst, dstCapacity, &cctx->appliedParams, 0, 0);
; 3185 :         FORWARD_IF_ERROR(fhSize, "ZSTD_writeFrameHeader failed");
; 3186 :         dstCapacity -= fhSize;

	sub	r8, rdx

; 3188 :         cctx->stage = ZSTDcs_ongoing;

	mov	DWORD PTR [rdi], 2

; 3189 :     }
; 3190 : 
; 3191 :     if (cctx->stage != ZSTDcs_ending) {

	jmp	SHORT $LN47@ZSTD_write
$LN7@ZSTD_write:
	cmp	eax, 3
	je	SHORT $LN10@ZSTD_write
$LN47@ZSTD_write:

; 3192 :         /* write one last empty block, make it the "last" block */
; 3193 :         U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1) + 0;
; 3194 :         RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for epilogue");

	cmp	r8, 4
	jb	SHORT $LN48@ZSTD_write

; 3195 :         MEM_writeLE32(op, cBlockHeader24);

	mov	DWORD PTR [rbx], 1

; 3196 :         op += ZSTD_blockHeaderSize;

	add	rbx, 3

; 3197 :         dstCapacity -= ZSTD_blockHeaderSize;

	sub	r8, 3
$LN10@ZSTD_write:

; 3198 :     }
; 3199 : 
; 3200 :     if (cctx->appliedParams.fParams.checksumFlag) {

	cmp	DWORD PTR [rdi+196], 0
	je	SHORT $LN13@ZSTD_write

; 3202 :         RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for checksum");

	cmp	r8, 4
	jb	SHORT $LN48@ZSTD_write

; 3201 :         U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);

	lea	rcx, QWORD PTR [rdi+408]
	call	XXH64_digest

; 3203 :         DEBUGLOG(4, "ZSTD_writeEpilogue: write checksum : %08X", (unsigned)checksum);
; 3204 :         MEM_writeLE32(op, checksum);

	mov	DWORD PTR [rbx], eax

; 3205 :         op += 4;

	add	rbx, 4
$LN13@ZSTD_write:

; 3206 :     }
; 3207 : 
; 3208 :     cctx->stage = ZSTDcs_created;  /* return to "created but no init" status */
; 3209 :     return op-ostart;

	sub	rbx, rsi
	mov	DWORD PTR [rdi], 0

; 3210 : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_writeEpilogue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
ZSTD_compressEnd PROC

; 3215 : {

$LN71:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 3216 :     size_t endResult;
; 3217 :     size_t const cSize = ZSTD_compressContinue_internal(cctx,

	mov	rax, QWORD PTR srcSize$[rsp]
	mov	rsi, r8
	mov	DWORD PTR [rsp+48], 1
	mov	rbx, rdx
	mov	DWORD PTR [rsp+40], 1
	mov	rdi, rcx
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressContinue_internal
	mov	r14, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3220 :     FORWARD_IF_ERROR(cSize, "ZSTD_compressContinue_internal failed");

	ja	$LN1@ZSTD_compr

; 3221 :     endResult = ZSTD_writeEpilogue(cctx, (char*)dst + cSize, dstCapacity-cSize);

	sub	rsi, rax
	mov	QWORD PTR [rsp+80], r15
	lea	r15, QWORD PTR [rax+rbx]

; 3180 :     RETURN_ERROR_IF(cctx->stage == ZSTDcs_created, stage_wrong, "init missing");

	mov	eax, DWORD PTR [rdi]
	mov	rbx, r15
	test	eax, eax
	jne	SHORT $LN22@ZSTD_compr
	mov	rbx, -60				; ffffffffffffffc4H

; 3222 :     FORWARD_IF_ERROR(endResult, "ZSTD_writeEpilogue failed");

	mov	rax, rbx
	jmp	$LN68@ZSTD_compr
$LN22@ZSTD_compr:

; 3183 :     if (cctx->stage == ZSTDcs_init) {

	cmp	eax, 1
	jne	SHORT $LN24@ZSTD_compr

; 2664 :     U32   const singleSegment = params->fParams.contentSizeFlag && (windowSize >= pledgedSrcSize);

	movzx	r9d, BYTE PTR [rdi+164]

; 2665 :     BYTE  const windowLogByte = (BYTE)((params->cParams.windowLog - ZSTD_WINDOWLOG_ABSOLUTEMIN) << 3);
; 2666 :     U32   const fcsCode = params->fParams.contentSizeFlag ?
; 2667 :                      (pledgedSrcSize>=256) + (pledgedSrcSize>=65536+256) + (pledgedSrcSize>=0xFFFFFFFFU) : 0;  /* 0-3 */
; 2668 :     BYTE  const frameHeaderDescriptionByte = (BYTE)(dictIDSizeCode + (checksumFlag<<2) + (singleSegment<<5) + (fcsCode<<6) );

	xor	edx, edx
	mov	r10d, DWORD PTR [rdi+192]
	sub	r9b, 10
	shl	r9b, 3
	mov	r11d, 4
	cmp	DWORD PTR [rdi+196], edx
	mov	eax, r10d
	cmovg	edx, r11d
	neg	eax
	sbb	cl, cl

; 2669 :     size_t pos=0;

	xor	r8d, r8d
	and	cl, 32					; 00000020H
	add	dl, cl

; 2670 : 
; 2671 :     assert(!(params->fParams.contentSizeFlag && pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN));
; 2672 :     RETURN_ERROR_IF(dstCapacity < ZSTD_FRAMEHEADERSIZE_MAX, dstSize_tooSmall,

	cmp	rsi, 18
	jb	SHORT $LN69@ZSTD_compr

; 2673 :                     "dst buf is too small to fit worst-case frame header size.");
; 2674 :     DEBUGLOG(4, "ZSTD_writeFrameHeader : dictIDFlag : %u ; dictID : %u ; dictIDSizeCode : %u",
; 2675 :                 !params->fParams.noDictIDFlag, (unsigned)dictID, (unsigned)dictIDSizeCode);
; 2676 : 
; 2677 :     if (params->format == ZSTD_f_zstd1) {

	cmp	DWORD PTR [rdi+160], r8d
	jne	SHORT $LN41@ZSTD_compr

; 2678 :         MEM_writeLE32(dst, ZSTD_MAGICNUMBER);

	mov	DWORD PTR [r15], -47205080		; fd2fb528H

; 2679 :         pos = 4;

	mov	r8d, r11d
$LN41@ZSTD_compr:

; 2680 :     }
; 2681 :     op[pos++] = frameHeaderDescriptionByte;
; 2682 :     if (!singleSegment) op[pos++] = windowLogByte;

	xor	ecx, ecx
	mov	BYTE PTR [r8+r15], dl
	test	r10d, r10d
	movzx	eax, r9b
	lea	rdx, QWORD PTR [r8+2]
	cmove	ecx, eax

; 3187 :         op += fhSize;

	lea	rbx, QWORD PTR [rdx+r15]

; 2682 :     if (!singleSegment) op[pos++] = windowLogByte;

	mov	BYTE PTR [r15+r8+1], cl

; 3186 :         dstCapacity -= fhSize;

	sub	rsi, rdx

; 3188 :         cctx->stage = ZSTDcs_ongoing;

	mov	DWORD PTR [rdi], 2

; 3189 :     }
; 3190 : 
; 3191 :     if (cctx->stage != ZSTDcs_ending) {

	jmp	SHORT $LN67@ZSTD_compr
$LN24@ZSTD_compr:
	cmp	eax, 3
	je	SHORT $LN27@ZSTD_compr
$LN67@ZSTD_compr:

; 3192 :         /* write one last empty block, make it the "last" block */
; 3193 :         U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1) + 0;
; 3194 :         RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for epilogue");

	cmp	rsi, 4
	jae	SHORT $LN28@ZSTD_compr
$LN69@ZSTD_compr:

; 3222 :     FORWARD_IF_ERROR(endResult, "ZSTD_writeEpilogue failed");

	mov	rbx, -70				; ffffffffffffffbaH
	mov	rax, rbx
	jmp	SHORT $LN68@ZSTD_compr
$LN28@ZSTD_compr:

; 3195 :         MEM_writeLE32(op, cBlockHeader24);

	mov	DWORD PTR [rbx], 1

; 3196 :         op += ZSTD_blockHeaderSize;

	add	rbx, 3

; 3197 :         dstCapacity -= ZSTD_blockHeaderSize;

	sub	rsi, 3
$LN27@ZSTD_compr:

; 3198 :     }
; 3199 : 
; 3200 :     if (cctx->appliedParams.fParams.checksumFlag) {

	cmp	DWORD PTR [rdi+196], 0
	je	SHORT $LN30@ZSTD_compr

; 3202 :         RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for checksum");

	cmp	rsi, 4
	jb	SHORT $LN69@ZSTD_compr

; 3201 :         U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);

	lea	rcx, QWORD PTR [rdi+408]
	call	XXH64_digest

; 3203 :         DEBUGLOG(4, "ZSTD_writeEpilogue: write checksum : %08X", (unsigned)checksum);
; 3204 :         MEM_writeLE32(op, checksum);

	mov	DWORD PTR [rbx], eax

; 3205 :         op += 4;

	add	rbx, 4
$LN30@ZSTD_compr:

; 3206 :     }
; 3207 : 
; 3208 :     cctx->stage = ZSTDcs_created;  /* return to "created but no init" status */
; 3209 :     return op-ostart;

	sub	rbx, r15
	mov	DWORD PTR [rdi], 0
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3222 :     FORWARD_IF_ERROR(endResult, "ZSTD_writeEpilogue failed");

	jbe	SHORT $LN5@ZSTD_compr
	mov	rax, rbx
	jmp	SHORT $LN68@ZSTD_compr
$LN5@ZSTD_compr:

; 3223 :     assert(!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0));
; 3224 :     if (cctx->pledgedSrcSizePlusOne != 0) {  /* control src size */

	mov	rcx, QWORD PTR [rdi+384]
	test	rcx, rcx
	je	SHORT $LN13@ZSTD_compr

; 3225 :         ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1);
; 3226 :         DEBUGLOG(4, "end of frame : controlling src size");
; 3227 :         RETURN_ERROR_IF(

	mov	rax, QWORD PTR [rdi+392]
	inc	rax
	cmp	rcx, rax
	mov	rax, -72				; ffffffffffffffb8H
	jne	SHORT $LN68@ZSTD_compr
$LN13@ZSTD_compr:

; 3228 :             cctx->pledgedSrcSizePlusOne != cctx->consumedSrcSize+1,
; 3229 :             srcSize_wrong,
; 3230 :              "error : pledgedSrcSize = %u, while realSrcSize = %u",
; 3231 :             (unsigned)cctx->pledgedSrcSizePlusOne-1,
; 3232 :             (unsigned)cctx->consumedSrcSize);
; 3233 :     }
; 3234 :     return cSize + endResult;

	lea	rax, QWORD PTR [rbx+r14]
$LN68@ZSTD_compr:
	mov	r15, QWORD PTR [rsp+80]
$LN1@ZSTD_compr:

; 3235 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
ZSTD_compressEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
cctx$ = 240
dst$ = 248
dstCapacity$ = 256
src$ = 264
srcSize$ = 272
dict$dead$ = 280
dictSize$dead$ = 288
params$ = 296
ZSTD_compress_advanced_internal PROC

; 3276 : {

$LN108:
	mov	r11, rsp
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR params$[rsp]
	mov	r14, r9

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	mov	rdi, QWORD PTR srcSize$[rsp]

; 3276 : {

	mov	rbp, r8
	mov	rsi, rdx

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T1[rsp]
	movups	xmm0, XMMWORD PTR [rax]
	mov	r8, rdi

; 3276 : {

	mov	rbx, rcx

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR $T1[rsp+16], xmm1
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR $T1[rsp+32], xmm0
	movups	xmm0, XMMWORD PTR [rax+64]
	movaps	XMMWORD PTR $T1[rsp+48], xmm1
	movups	xmm1, XMMWORD PTR [rax+80]
	movaps	XMMWORD PTR $T1[rsp+64], xmm0
	movups	xmm0, XMMWORD PTR [rax+96]
	movaps	XMMWORD PTR [r11-104], xmm1
	movups	xmm1, XMMWORD PTR [rax+112]
	movaps	XMMWORD PTR [r11-88], xmm0
	movups	xmm0, XMMWORD PTR [rax+128]
	movaps	XMMWORD PTR [r11-72], xmm1
	movaps	XMMWORD PTR [r11-56], xmm0
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	ja	SHORT $LN8@ZSTD_compr

; 3277 :     DEBUGLOG(4, "ZSTD_compress_advanced_internal (srcSize:%u)", (unsigned)srcSize);
; 3278 :     FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,
; 3279 :                          dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, NULL,
; 3280 :                          params, srcSize, ZSTDb_not_buffered) , "");
; 3281 :     return ZSTD_compressEnd(cctx, dst, dstCapacity, src, srcSize);

	mov	r9, r14

; 3117 :         cctx->dictID = (U32)dictID;

	mov	DWORD PTR [rbx+304], 0

; 3277 :     DEBUGLOG(4, "ZSTD_compress_advanced_internal (srcSize:%u)", (unsigned)srcSize);
; 3278 :     FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,
; 3279 :                          dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, NULL,
; 3280 :                          params, srcSize, ZSTDb_not_buffered) , "");
; 3281 :     return ZSTD_compressEnd(cctx, dst, dstCapacity, src, srcSize);

	mov	r8, rbp
	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rsi
	mov	rcx, rbx
	call	ZSTD_compressEnd
$LN8@ZSTD_compr:

; 3282 : }

	add	rsp, 192				; 000000c0H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compress_advanced_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
params$1 = 80
cdict$ = 240
dictBuffer$ = 248
dictSize$ = 256
dictLoadMethod$ = 264
dictContentType$ = 272
cParams$ = 280
ZSTD_initCDict_internal PROC

; 3357 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H

; 3358 :     DEBUGLOG(3, "ZSTD_initCDict_internal (dictContentType:%u)", (unsigned)dictContentType);
; 3359 :     assert(!ZSTD_checkCParams(cParams));
; 3360 :     cdict->matchState.cParams = cParams;

	mov	rsi, QWORD PTR cParams$[rsp]
	mov	rdi, r8
	mov	rbx, rcx
	movaps	xmm0, XMMWORD PTR [rsi]
	movsd	xmm1, QWORD PTR [rsi+16]
	mov	eax, DWORD PTR [rsi+24]
	movups	XMMWORD PTR [rcx+272], xmm0
	movsd	QWORD PTR [rcx+288], xmm1
	mov	DWORD PTR [rcx+296], eax

; 3361 :     if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dictBuffer) || (!dictSize)) {

	cmp	r9d, 1
	je	SHORT $LN10@ZSTD_initC
	test	rdx, rdx
	je	SHORT $LN10@ZSTD_initC
	test	r8, r8
	je	SHORT $LN10@ZSTD_initC
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 311  :     void* alloc = ws->objectEnd;

	mov	rcx, QWORD PTR [rcx+40]

; 167  :     return (size + mask) & ~mask;

	lea	rax, QWORD PTR [r8+7]
	and	rax, -8

; 312  :     void* end = (BYTE*)alloc + roundedBytes;

	add	rax, rcx

; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	DWORD PTR [rbx+80], 0
	jne	SHORT $LN46@ZSTD_initC
	cmp	rax, QWORD PTR [rbx+32]
	ja	SHORT $LN46@ZSTD_initC

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR [rbx+40], rax

; 332  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+48], rax

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR [rbx+56], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3365 :         RETURN_ERROR_IF(!internalBuffer, memory_allocation, "NULL pointer!");

	test	rcx, rcx
	je	SHORT $LN48@ZSTD_initC

; 3366 :         cdict->dictContent = internalBuffer;

	mov	QWORD PTR [rbx], rcx

; 3367 :         memcpy(internalBuffer, dictBuffer, dictSize);

	call	memcpy
	jmp	SHORT $LN9@ZSTD_initC
$LN46@ZSTD_initC:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 328  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+72], 1
$LN48@ZSTD_initC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3365 :         RETURN_ERROR_IF(!internalBuffer, memory_allocation, "NULL pointer!");

	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN1@ZSTD_initC
$LN10@ZSTD_initC:

; 3362 :         cdict->dictContent = dictBuffer;

	mov	QWORD PTR [rcx], rdx
$LN9@ZSTD_initC:

; 3368 :     }
; 3369 :     cdict->dictContentSize = dictSize;

	mov	QWORD PTR [rbx+8], rdi
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	xor	edx, edx
	mov	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rsp+240], rbp
	mov	QWORD PTR [rsp+248], r14

; 312  :     void* end = (BYTE*)alloc + roundedBytes;

	lea	rax, QWORD PTR [rcx+6400]

; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	DWORD PTR [rbx+80], edx
	jne	SHORT $LN28@ZSTD_initC
	cmp	rax, QWORD PTR [rbx+32]
	ja	SHORT $LN28@ZSTD_initC

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR [rbx+40], rax

; 332  :     ws->tableEnd = end;

	mov	QWORD PTR [rbx+48], rax

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR [rbx+56], rax

; 334  : 
; 335  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 336  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 337  :      * either size. */
; 338  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 339  :     __asan_unpoison_memory_region(alloc, bytes);
; 340  : #endif
; 341  : 
; 342  :     return alloc;

	jmp	SHORT $LN26@ZSTD_initC
$LN28@ZSTD_initC:

; 328  :         ws->allocFailed = 1;

	mov	DWORD PTR [rbx+72], 1

; 329  :         return NULL;

	mov	rcx, rdx
$LN26@ZSTD_initC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3371 :     cdict->entropyWorkspace = (U32*)ZSTD_cwksp_reserve_object(&cdict->workspace, HUF_WORKSPACE_SIZE);

	mov	QWORD PTR [rbx+16], rcx

; 3376 :     FORWARD_IF_ERROR(ZSTD_reset_matchState(

	xor	r9d, r9d

; 1286 :         bs->rep[i] = repStartValue[i];

	mov	DWORD PTR [rbx+4884], 1

; 3376 :     FORWARD_IF_ERROR(ZSTD_reset_matchState(

	lea	rcx, QWORD PTR [rbx+88]

; 1286 :         bs->rep[i] = repStartValue[i];

	mov	DWORD PTR [rbx+4888], 4

; 3376 :     FORWARD_IF_ERROR(ZSTD_reset_matchState(

	mov	r8, rsi

; 1286 :         bs->rep[i] = repStartValue[i];

	mov	DWORD PTR [rbx+4892], 8

; 3376 :     FORWARD_IF_ERROR(ZSTD_reset_matchState(

	mov	DWORD PTR [rsp+40], edx

; 1287 :     bs->entropy.huf.repeatMode = HUF_repeat_none;

	mov	DWORD PTR [rbx+1328], edx

; 1288 :     bs->entropy.fse.offcode_repeatMode = FSE_repeat_none;

	mov	QWORD PTR [rbx+4872], rdx

; 1289 :     bs->entropy.fse.matchlength_repeatMode = FSE_repeat_none;
; 1290 :     bs->entropy.fse.litlength_repeatMode = FSE_repeat_none;

	mov	DWORD PTR [rbx+4880], edx

; 3376 :     FORWARD_IF_ERROR(ZSTD_reset_matchState(

	lea	rdx, QWORD PTR [rbx+24]
	mov	DWORD PTR [rsp+32], 1
	call	ZSTD_reset_matchState
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3376 :     FORWARD_IF_ERROR(ZSTD_reset_matchState(

	ja	$LN50@ZSTD_initC

; 3377 :         &cdict->matchState,
; 3378 :         &cdict->workspace,
; 3379 :         &cParams,
; 3380 :         ZSTDcrp_makeClean,
; 3381 :         ZSTDirp_reset,
; 3382 :         ZSTD_resetTarget_CDict), "");
; 3383 :     /* (Maybe) load the dictionary
; 3384 :      * Skips loading the dictionary if it is < 8 bytes.
; 3385 :      */
; 3386 :     {   ZSTD_CCtx_params params;
; 3387 :         memset(&params, 0, sizeof(params));
; 3388 :         params.compressionLevel = ZSTD_CLEVEL_DEFAULT;
; 3389 :         params.fParams.contentSizeFlag = 1;
; 3390 :         params.cParams = cParams;

	movsd	xmm1, QWORD PTR [rsi+16]

; 3391 :         {   size_t const dictID = ZSTD_compress_insertDictionary(

	lea	r9, QWORD PTR [rbx+24]
	xor	eax, eax
	mov	DWORD PTR params$1[rsp+44], 3
	xorps	xmm0, xmm0
	mov	DWORD PTR params$1[rsp], eax
	mov	QWORD PTR params$1[rsp+36], rax
	lea	rdx, QWORD PTR [rbx+88]
	mov	eax, DWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+304]
	mov	DWORD PTR params$1[rsp+28], eax
	xor	r8d, r8d
	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR dictContentType$[rsp]
	mov	DWORD PTR [rsp+64], 1
	mov	DWORD PTR [rsp+56], eax
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR params$1[rsp]
	movups	XMMWORD PTR params$1[rsp+48], xmm0
	mov	QWORD PTR [rsp+32], rax
	movups	XMMWORD PTR params$1[rsp+64], xmm0
	mov	DWORD PTR params$1[rsp+32], 1
	movups	XMMWORD PTR params$1[rsp+80], xmm0
	movups	XMMWORD PTR params$1[rsp+96], xmm0
	movups	XMMWORD PTR params$1[rsp+112], xmm0
	movups	XMMWORD PTR params$1[rsp+128], xmm0
	movaps	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR params$1[rsp+4], xmm0
	movsd	QWORD PTR params$1[rsp+20], xmm1
	call	ZSTD_compress_insertDictionary
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3395 :             FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");

	ja	SHORT $LN50@ZSTD_initC

; 3396 :             assert(dictID <= (size_t)(U32)-1);
; 3397 :             cdict->dictID = (U32)dictID;

	mov	DWORD PTR [rbx+4920], eax

; 3398 :         }
; 3399 :     }
; 3400 : 
; 3401 :     return 0;

	xor	eax, eax
$LN50@ZSTD_initC:
	mov	rbp, QWORD PTR [rsp+240]
	mov	r14, QWORD PTR [rsp+248]
$LN1@ZSTD_initC:

; 3402 : }

	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
ZSTD_initCDict_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
ws$3 = 80
dictBuffer$ = 192
dictSize$ = 200
dictLoadMethod$ = 208
dictContentType$ = 216
cParams$ = 224
customMem$ = 232
ZSTD_createCDict_advanced PROC

; 3408 : {

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H

; 3409 :     DEBUGLOG(3, "ZSTD_createCDict_advanced, mode %u", (unsigned)dictContentType);
; 3410 :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	mov	rsi, QWORD PTR customMem$[rsp]
	xor	r10d, r10d
	mov	r12d, r9d
	mov	r14d, r8d
	mov	r15, rdx
	mov	r13, rcx
	cmp	QWORD PTR [rsi+8], r10
	sete	r10b
	xor	eax, eax
	cmp	QWORD PTR [rsi], rax
	sete	al
	cmp	r10d, eax
	jne	$LN45@ZSTD_creat

; 3411 : 
; 3412 :     {   size_t const workspaceSize =

	cmp	r8d, 1
	jne	SHORT $LN6@ZSTD_creat
	xor	edx, edx
	jmp	SHORT $LN7@ZSTD_creat
$LN6@ZSTD_creat:
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 167  :     return (size + mask) & ~mask;

	add	rdx, 7
	and	rdx, -8
$LN7@ZSTD_creat:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1102 :     size_t const chainSize = (cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cParams->chainLog);

	mov	rdi, QWORD PTR cParams$[rsp]
	cmp	DWORD PTR [rdi+24], 1
	jne	SHORT $LN12@ZSTD_creat
	xor	r8d, r8d
	jmp	SHORT $LN13@ZSTD_creat
$LN12@ZSTD_creat:
	mov	ecx, DWORD PTR [rdi+4]
	mov	r8d, 1
	shl	r8, cl
$LN13@ZSTD_creat:

; 1103 :     size_t const hSize = ((size_t)1) << cParams->hashLog;

	mov	ecx, DWORD PTR [rdi+8]
	mov	eax, 1

; 3413 :             ZSTD_cwksp_alloc_size(sizeof(ZSTD_CDict)) +
; 3414 :             ZSTD_cwksp_alloc_size(HUF_WORKSPACE_SIZE) +
; 3415 :             ZSTD_sizeof_matchState(&cParams, /* forCCtx */ 0) +
; 3416 :             (dictLoadMethod == ZSTD_dlm_byRef ? 0
; 3417 :              : ZSTD_cwksp_alloc_size(ZSTD_cwksp_align(dictSize, sizeof(void*))));
; 3418 :         void* const workspace = ZSTD_malloc(workspaceSize, customMem);

	movsd	xmm0, QWORD PTR [rsi+16]

; 1103 :     size_t const hSize = ((size_t)1) << cParams->hashLog;

	shl	rax, cl

; 3411 : 
; 3412 :     {   size_t const workspaceSize =

	add	rax, 2832				; 00000b10H

; 3413 :             ZSTD_cwksp_alloc_size(sizeof(ZSTD_CDict)) +
; 3414 :             ZSTD_cwksp_alloc_size(HUF_WORKSPACE_SIZE) +
; 3415 :             ZSTD_sizeof_matchState(&cParams, /* forCCtx */ 0) +
; 3416 :             (dictLoadMethod == ZSTD_dlm_byRef ? 0
; 3417 :              : ZSTD_cwksp_alloc_size(ZSTD_cwksp_align(dictSize, sizeof(void*))));
; 3418 :         void* const workspace = ZSTD_malloc(workspaceSize, customMem);

	movsd	QWORD PTR $T2[rsp+16], xmm0
	add	rax, r8
	lea	rbp, QWORD PTR [rdx+rax*4]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rsi]
	test	rax, rax
	je	SHORT $LN23@ZSTD_creat

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rbp
	call	rax
	jmp	SHORT $LN46@ZSTD_creat
$LN23@ZSTD_creat:

; 60   :     return malloc(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
$LN46@ZSTD_creat:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3422 :         if (!workspace) {

	mov	rbx, rax
	test	rax, rax
	je	$LN45@ZSTD_creat
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 452  :     ws->phase = ZSTD_cwksp_alloc_objects;

	xor	edx, edx
	mov	QWORD PTR ws$3[rsp], rax
	lea	rax, QWORD PTR [rax+rbp]
	mov	QWORD PTR ws$3[rsp+16], rbx

; 312  :     void* end = (BYTE*)alloc + roundedBytes;

	lea	rcx, QWORD PTR [rbx+4928]

; 449  :     ws->workspaceEnd = (BYTE*)start + size;

	mov	QWORD PTR ws$3[rsp+8], rax

; 450  :     ws->objectEnd = ws->workspace;
; 451  :     ws->tableValidEnd = ws->objectEnd;

	mov	QWORD PTR ws$3[rsp+32], rbx

; 453  :     ZSTD_cwksp_clear(ws);
; 454  :     ws->workspaceOversizedDuration = 0;

	mov	QWORD PTR ws$3[rsp+52], rdx

; 431  :     ws->tableEnd = ws->objectEnd;

	mov	QWORD PTR ws$3[rsp+24], rbx

; 432  :     ws->allocStart = ws->workspaceEnd;

	mov	QWORD PTR ws$3[rsp+40], rax

; 433  :     ws->allocFailed = 0;

	mov	DWORD PTR ws$3[rsp+48], edx

; 326  :     if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {

	cmp	rcx, rax
	ja	SHORT $LN37@ZSTD_creat

; 330  :     }
; 331  :     ws->objectEnd = end;

	mov	QWORD PTR ws$3[rsp+16], rcx

; 332  :     ws->tableEnd = end;

	mov	QWORD PTR ws$3[rsp+24], rcx

; 333  :     ws->tableValidEnd = end;

	mov	QWORD PTR ws$3[rsp+32], rcx

; 334  : 
; 335  : #if defined (ADDRESS_SANITIZER) && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
; 336  :     /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
; 337  :      * either size. */
; 338  :     alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
; 339  :     __asan_unpoison_memory_region(alloc, bytes);
; 340  : #endif
; 341  : 
; 342  :     return alloc;

	jmp	SHORT $LN35@ZSTD_creat
$LN37@ZSTD_creat:

; 327  :         DEBUGLOG(4, "cwksp: object alloc failed!");
; 328  :         ws->allocFailed = 1;

	mov	DWORD PTR ws$3[rsp+48], 1

; 329  :         return NULL;

	mov	rbx, rdx
$LN35@ZSTD_creat:

; 478  :     *dst = *src;

	movaps	xmm0, XMMWORD PTR ws$3[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	mov	r9d, r14d
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 478  :     *dst = *src;

	movaps	xmm1, XMMWORD PTR ws$3[rsp+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	mov	r8, r15
	mov	eax, DWORD PTR [rdi+24]
	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 478  :     *dst = *src;

	movups	XMMWORD PTR [rbx+24], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	mov	DWORD PTR $T1[rsp+24], eax
	lea	rax, QWORD PTR $T1[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 478  :     *dst = *src;

	movaps	xmm0, XMMWORD PTR ws$3[rsp+32]
	movups	XMMWORD PTR [rbx+40], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3433 :         cdict->compressionLevel = 0; /* signals advanced API usage */

	mov	DWORD PTR [rbx+4924], edx

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	mov	rdx, r13
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 478  :     *dst = *src;

	movaps	xmm1, XMMWORD PTR ws$3[rsp+48]
	movups	XMMWORD PTR [rbx+56], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	mov	QWORD PTR [rsp+40], rax
	movaps	xmm0, XMMWORD PTR [rsi]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 478  :     *dst = *src;

	movups	XMMWORD PTR [rbx+72], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	mov	DWORD PTR [rsp+32], r12d
	movsd	xmm1, QWORD PTR [rsi+16]
	movups	XMMWORD PTR [rbx+4896], xmm0
	movaps	xmm0, XMMWORD PTR [rdi]
	movsd	QWORD PTR [rbx+4912], xmm1
	movsd	xmm1, QWORD PTR [rdi+16]
	movsd	QWORD PTR $T1[rsp+16], xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	ZSTD_initCDict_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3435 :         if (ZSTD_isError( ZSTD_initCDict_internal(cdict,

	jbe	SHORT $LN4@ZSTD_creat

; 3436 :                                         dictBuffer, dictSize,
; 3437 :                                         dictLoadMethod, dictContentType,
; 3438 :                                         cParams) )) {
; 3439 :             ZSTD_freeCDict(cdict);

	mov	rcx, rbx
	call	ZSTD_freeCDict
$LN45@ZSTD_creat:

; 3444 :     }
; 3445 : }

	xor	eax, eax
$LN1@ZSTD_creat:
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN4@ZSTD_creat:

; 3440 :             return NULL;
; 3441 :         }
; 3442 : 
; 3443 :         return cdict;

	mov	rax, rbx
	jmp	SHORT $LN1@ZSTD_creat
ZSTD_createCDict_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
$T2 = 80
$T3 = 112
dict$ = 160
dictSize$ = 168
compressionLevel$ = 176
ZSTD_createCDict PROC

; 3448 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 144				; 00000090H

; 3449 :     ZSTD_compressionParameters cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize);
; 3450 :     ZSTD_CDict* cdict = ZSTD_createCDict_advanced(dict, dictSize,

	movups	xmm0, XMMWORD PTR ZSTD_defaultCMem
	mov	esi, r8d
	mov	rbx, rdx
	movsd	xmm1, QWORD PTR ZSTD_defaultCMem+16
	mov	rdi, rcx
	mov	r9, rdx
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, -1
	movsd	QWORD PTR $T1[rsp+16], xmm1
	mov	edx, esi
	lea	rcx, QWORD PTR $T3[rsp]
	call	ZSTD_getCParams_internal
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, rbx
	mov	rcx, rdi
	movups	xmm2, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR $T2[rsp+24], eax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T2[rsp], xmm2
	movsd	QWORD PTR $T2[rsp+16], xmm0
	call	ZSTD_createCDict_advanced

; 3451 :                                                   ZSTD_dlm_byCopy, ZSTD_dct_auto,
; 3452 :                                                   cParams, ZSTD_defaultCMem);
; 3453 :     if (cdict)

	test	rax, rax
	je	SHORT $LN4@ZSTD_creat

; 3454 :         cdict->compressionLevel = compressionLevel == 0 ? ZSTD_CLEVEL_DEFAULT : compressionLevel;

	test	esi, esi
	mov	ecx, 3
	cmove	esi, ecx
	mov	DWORD PTR [rax+4924], esi
$LN4@ZSTD_creat:

; 3455 :     return cdict;
; 3456 : }

	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
ZSTD_createCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
cMem$2 = 64
cdict$ = 112
ZSTD_freeCDict PROC

; 3467 : {

$LN24:
	push	rbx
	sub	rsp, 96					; 00000060H
	mov	rbx, rcx

; 3468 :     if (cdict==NULL) return 0;   /* support free on NULL */

	test	rcx, rcx
	je	$LN22@ZSTD_freeC

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movups	xmm0, XMMWORD PTR [rcx+4896]
	mov	QWORD PTR [rsp+112], rdi
	movsd	xmm1, QWORD PTR [rcx+4912]
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	mov	rcx, QWORD PTR [rcx+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3469 :     {   ZSTD_customMem const cMem = cdict->customMem;

	movsd	QWORD PTR cMem$2[rsp+16], xmm1
	movups	XMMWORD PTR cMem$2[rsp], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 218  :     return (ptr != NULL) && (ws->workspace <= ptr) && (ptr <= ws->workspaceEnd);

	cmp	rcx, rbx
	ja	SHORT $LN7@ZSTD_freeC
	cmp	rbx, QWORD PTR [rbx+32]
	ja	SHORT $LN7@ZSTD_freeC
	mov	edi, 1
	jmp	SHORT $LN8@ZSTD_freeC
$LN7@ZSTD_freeC:
	xor	edi, edi
$LN8@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3471 :         ZSTD_cwksp_free(&cdict->workspace, cMem);

	movaps	XMMWORD PTR $T1[rsp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_cwksp.h

; 469  :     memset(ws, 0, sizeof(ZSTD_cwksp));

	movups	XMMWORD PTR [rbx+24], xmm0
	movups	XMMWORD PTR [rbx+40], xmm0
	movups	XMMWORD PTR [rbx+56], xmm0
	movups	XMMWORD PTR [rbx+72], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN14@ZSTD_freeC

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN13@ZSTD_freeC

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN14@ZSTD_freeC
$LN13@ZSTD_freeC:

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN14@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3472 :         if (!cdictInWorkspace) {

	test	edi, edi
	mov	rdi, QWORD PTR [rsp+112]
	jne	SHORT $LN22@ZSTD_freeC
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR cMem$2[rsp+8]
	test	rax, rax
	je	SHORT $LN18@ZSTD_freeC

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$2[rsp+16]
	mov	rdx, rbx
	call	rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3477 : }

	xor	eax, eax
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
$LN18@ZSTD_freeC:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN22@ZSTD_freeC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3477 : }

	xor	eax, eax
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
ZSTD_freeCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 8
cdict$ = 16
ZSTD_getCParamsFromCDict PROC

; 3532 :     assert(cdict != NULL);
; 3533 :     return cdict->matchState.cParams;

	mov	eax, DWORD PTR [rdx+296]
	movups	xmm0, XMMWORD PTR [rdx+272]
	movsd	xmm1, QWORD PTR [rdx+288]
	movups	XMMWORD PTR [rcx], xmm0
	movsd	QWORD PTR [rcx+16], xmm1
	mov	DWORD PTR [rcx+24], eax
	mov	rax, rcx

; 3534 : }

	ret	0
ZSTD_getCParamsFromCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 80
$T2 = 80
params$3 = 112
$T4 = 256
cctx$ = 320
cdict$ = 328
fParams$ = 336
pledgedSrcSize$ = 344
ZSTD_compressBegin_usingCDict_advanced PROC

; 3541 : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H
	mov	rdi, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 3542 :     DEBUGLOG(4, "ZSTD_compressBegin_usingCDict_advanced");
; 3543 :     RETURN_ERROR_IF(cdict==NULL, dictionary_wrong, "NULL pointer!");

	test	rdx, rdx
	jne	SHORT $LN2@ZSTD_compr
	lea	rax, QWORD PTR [rdx-32]
	jmp	$LN1@ZSTD_compr
$LN2@ZSTD_compr:

; 3544 :     {   ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm0, XMMWORD PTR [rcx+16]
	movups	xmm1, XMMWORD PTR [rcx+32]
	movaps	XMMWORD PTR params$3[rsp], xmm0
	movaps	XMMWORD PTR params$3[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rcx+48]
	movups	xmm1, XMMWORD PTR [rcx+64]
	movaps	XMMWORD PTR params$3[rbp-224], xmm0
	movaps	XMMWORD PTR params$3[rbp-208], xmm1
	movups	xmm0, XMMWORD PTR [rcx+80]
	movups	xmm1, XMMWORD PTR [rcx+96]
	movaps	XMMWORD PTR params$3[rbp-192], xmm0
	movaps	XMMWORD PTR params$3[rbp-176], xmm1
	movups	xmm0, XMMWORD PTR [rcx+112]
	movups	xmm1, XMMWORD PTR [rcx+128]
	movaps	XMMWORD PTR params$3[rbp-160], xmm0
	movaps	XMMWORD PTR params$3[rbp-144], xmm1
	movups	xmm0, XMMWORD PTR [rcx+144]
	movaps	XMMWORD PTR params$3[rbp-128], xmm0

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	cmp	rdi, 131072				; 00020000H
	jb	SHORT $LN6@ZSTD_compr
	mov	rax, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	add	rcx, rcx
	cmp	rdi, rcx
	jb	SHORT $LN6@ZSTD_compr
	cmp	rdi, -1
	je	SHORT $LN6@ZSTD_compr
	cmp	DWORD PTR [rdx+4924], 0
	jne	SHORT $LN19@ZSTD_compr
$LN6@ZSTD_compr:
	cmp	DWORD PTR params$3[rbp-188], 3
	je	SHORT $LN19@ZSTD_compr

; 3533 :     return cdict->matchState.cParams;

	movups	xmm0, XMMWORD PTR [rdx+272]
	mov	eax, DWORD PTR [rdx+296]
	movsd	xmm1, QWORD PTR [rdx+288]
	movups	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	jmp	SHORT $LN20@ZSTD_compr
$LN19@ZSTD_compr:

; 4254 :     return ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize);

	mov	r9, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR $T4[rbp-256]
	mov	edx, DWORD PTR [rdx+4924]
	test	rdi, rdi
	mov	r8, -1
	cmovne	r8, rdi
	call	ZSTD_getCParams_internal
	movups	xmm2, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR $T1[rsp], xmm2
	movsd	QWORD PTR $T1[rsp+16], xmm0
$LN20@ZSTD_compr:

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	mov	DWORD PTR $T1[rsp+24], eax

; 3546 :                         || pledgedSrcSize < cdict->dictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER
; 3547 :                         || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
; 3548 :                         || cdict->compressionLevel == 0 )
; 3549 :                       && (params.attachDictPref != ZSTD_dictForceLoad) ?
; 3550 :                 ZSTD_getCParamsFromCDict(cdict)
; 3551 :               : ZSTD_getCParams(cdict->compressionLevel,
; 3552 :                                 pledgedSrcSize,
; 3553 :                                 cdict->dictContentSize);
; 3554 :         /* Increase window log to fit the entire dictionary and source if the
; 3555 :          * source size is known. Limit the increase to 19, which is the
; 3556 :          * window log for compression level 1 with the largest source size.
; 3557 :          */
; 3558 :         if (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN) {

	xor	r8d, r8d
	lea	rax, QWORD PTR $T1[rsp]
	movsd	xmm1, QWORD PTR [rax+16]
	movsd	QWORD PTR params$3[rbp-236], xmm1
	movups	xmm0, XMMWORD PTR [rax]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR params$3[rbp-228], eax
	movups	XMMWORD PTR params$3[rsp+4], xmm0
	cmp	rdi, -1
	je	SHORT $LN4@ZSTD_compr

; 3559 :             U32 const limitedSrcSize = (U32)MIN(pledgedSrcSize, 1U << 19);

	mov	eax, 524288				; 00080000H
	cmp	rdi, rax
	cmovb	eax, edi

; 3560 :             U32 const limitedSrcLog = limitedSrcSize > 1 ? ZSTD_highbit32(limitedSrcSize - 1) + 1 : 1;

	cmp	eax, 1
	jbe	SHORT $LN9@ZSTD_compr
	dec	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	edx, r8d
	bsr	ecx, eax
	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3560 :             U32 const limitedSrcLog = limitedSrcSize > 1 ? ZSTD_highbit32(limitedSrcSize - 1) + 1 : 1;

	inc	edx
	jmp	SHORT $LN10@ZSTD_compr
$LN9@ZSTD_compr:
	mov	edx, 1
$LN10@ZSTD_compr:

; 3561 :             params.cParams.windowLog = MAX(params.cParams.windowLog, limitedSrcLog);

	cmp	DWORD PTR params$3[rsp+4], edx
	cmova	edx, DWORD PTR params$3[rsp+4]
	mov	DWORD PTR params$3[rsp+4], edx
$LN4@ZSTD_compr:

; 3562 :         }
; 3563 :         params.fParams = fParams;

	mov	eax, DWORD PTR [r14+8]

; 3564 :         return ZSTD_compressBegin_internal(cctx,

	xor	r9d, r9d
	movsd	xmm0, QWORD PTR [r14]
	xor	edx, edx
	mov	DWORD PTR [rsp+64], r8d
	mov	rcx, rsi
	mov	DWORD PTR params$3[rbp-216], eax
	lea	rax, QWORD PTR params$3[rsp]
	mov	QWORD PTR [rsp+56], rdi
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rbx
	movsd	QWORD PTR params$3[rbp-224], xmm0
	call	ZSTD_compressBegin_internal
$LN1@ZSTD_compr:

; 3565 :                                            NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast,
; 3566 :                                            cdict,
; 3567 :                                            &params, pledgedSrcSize,
; 3568 :                                            ZSTDb_not_buffered);
; 3569 :     }
; 3570 : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
ZSTD_compressBegin_usingCDict_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 80
$T2 = 80
fParams$ = 112
params$3 = 128
$T4 = 272
$T5 = 416
cctx$ = 528
cdict$ = 536
ZSTD_compressBegin_usingCDict PROC

; 3576 : {

$LN190:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-240]
	sub	rsp, 496				; 000001f0H

; 3577 :     ZSTD_frameParameters const fParams = { 0 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };

	xor	r14d, r14d
	mov	rdi, rdx
	mov	QWORD PTR fParams$[rsp], r14
	mov	rbx, rcx

; 3543 :     RETURN_ERROR_IF(cdict==NULL, dictionary_wrong, "NULL pointer!");

	test	rdx, rdx
	jne	SHORT $LN4@ZSTD_compr

; 3578 :     DEBUGLOG(4, "ZSTD_compressBegin_usingCDict : dictIDFlag == %u", !fParams.noDictIDFlag);
; 3579 :     return ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, ZSTD_CONTENTSIZE_UNKNOWN);

	lea	rax, QWORD PTR [rdx-32]

; 3543 :     RETURN_ERROR_IF(cdict==NULL, dictionary_wrong, "NULL pointer!");

	jmp	$LN3@ZSTD_compr
$LN4@ZSTD_compr:

; 3544 :     {   ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm0, XMMWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+544], rsi
	movups	xmm3, XMMWORD PTR [rcx+80]
	movups	xmm1, XMMWORD PTR [rcx+32]
	movups	xmm4, XMMWORD PTR [rcx+64]
	movups	xmm5, XMMWORD PTR [rcx+96]
	movaps	XMMWORD PTR params$3[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rcx+48]
	movaps	XMMWORD PTR [rsp+480], xmm6
	movups	xmm6, XMMWORD PTR [rcx+112]
	movaps	XMMWORD PTR params$3[rbp-224], xmm0

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	movdqa	xmm0, xmm3
	movaps	XMMWORD PTR [rsp+464], xmm7

; 3544 :     {   ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm7, XMMWORD PTR [rcx+128]

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	psrldq	xmm0, 4
	movd	esi, xmm0
	movaps	XMMWORD PTR [rsp+448], xmm8

; 3544 :     {   ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm8, XMMWORD PTR [rcx+144]
	movaps	XMMWORD PTR params$3[rbp-240], xmm1
	movaps	XMMWORD PTR params$3[rbp-208], xmm4
	movaps	XMMWORD PTR params$3[rbp-192], xmm3
	movaps	XMMWORD PTR params$3[rbp-176], xmm5
	movaps	XMMWORD PTR params$3[rbp-160], xmm6
	movaps	XMMWORD PTR params$3[rbp-144], xmm7
	movaps	XMMWORD PTR params$3[rbp-128], xmm8

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	cmp	esi, 3
	je	SHORT $LN9@ZSTD_compr

; 3533 :     return cdict->matchState.cParams;

	movups	xmm0, XMMWORD PTR [rdx+272]
	mov	eax, DWORD PTR [rdx+296]
	movsd	xmm1, QWORD PTR [rdx+288]
	movups	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	jmp	SHORT $LN188@ZSTD_compr
$LN9@ZSTD_compr:

; 4254 :     return ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize);

	mov	r9, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR $T5[rbp-256]
	mov	edx, DWORD PTR [rdx+4924]
	mov	r8, -1
	call	ZSTD_getCParams_internal
	movups	xmm2, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR $T1[rsp], xmm2
	movsd	QWORD PTR $T1[rsp+16], xmm0
$LN188@ZSTD_compr:

; 3545 :         params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF

	mov	DWORD PTR $T1[rsp+24], eax
	lea	rax, QWORD PTR $T1[rsp]
	movups	xmm0, XMMWORD PTR [rax]

; 3546 :                         || pledgedSrcSize < cdict->dictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER
; 3547 :                         || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
; 3548 :                         || cdict->compressionLevel == 0 )
; 3549 :                       && (params.attachDictPref != ZSTD_dictForceLoad) ?
; 3550 :                 ZSTD_getCParamsFromCDict(cdict)
; 3551 :               : ZSTD_getCParams(cdict->compressionLevel,
; 3552 :                                 pledgedSrcSize,
; 3553 :                                 cdict->dictContentSize);
; 3554 :         /* Increase window log to fit the entire dictionary and source if the
; 3555 :          * source size is known. Limit the increase to 19, which is the
; 3556 :          * window log for compression level 1 with the largest source size.
; 3557 :          */
; 3558 :         if (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN) {
; 3559 :             U32 const limitedSrcSize = (U32)MIN(pledgedSrcSize, 1U << 19);
; 3560 :             U32 const limitedSrcLog = limitedSrcSize > 1 ? ZSTD_highbit32(limitedSrcSize - 1) + 1 : 1;
; 3561 :             params.cParams.windowLog = MAX(params.cParams.windowLog, limitedSrcLog);
; 3562 :         }
; 3563 :         params.fParams = fParams;

	mov	DWORD PTR params$3[rbp-216], r14d
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR params$3[rbp-252], xmm0
	mov	DWORD PTR params$3[rbp-228], eax
	movsd	xmm0, QWORD PTR fParams$[rsp]
	movsd	QWORD PTR params$3[rbp-224], xmm0
	movsd	QWORD PTR params$3[rbp-236], xmm1

; 3099 :       && (params->attachDictPref != ZSTD_dictForceLoad) ) {

	cmp	QWORD PTR [rdi+8], r14
	jbe	SHORT $LN23@ZSTD_compr
	cmp	esi, 3
	je	SHORT $LN23@ZSTD_compr

; 3100 :         return ZSTD_resetCCtx_usingCDict(cctx, cdict, params, pledgedSrcSize, zbuff);

	mov	r9, -1
	mov	DWORD PTR [rsp+32], r14d
	lea	r8, QWORD PTR params$3[rbp-256]
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_resetCCtx_usingCDict
	jmp	$LN20@ZSTD_compr
$LN23@ZSTD_compr:

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	movaps	xmm0, XMMWORD PTR params$3[rbp-256]
	lea	rdx, QWORD PTR $T4[rbp-256]
	movaps	xmm1, XMMWORD PTR params$3[rbp-240]
	xor	r9d, r9d
	movaps	XMMWORD PTR $T4[rbp-256], xmm0
	mov	rcx, rbx
	movaps	xmm0, XMMWORD PTR params$3[rbp-224]
	movaps	XMMWORD PTR $T4[rbp-240], xmm1
	lea	r8, QWORD PTR [r9-1]
	movaps	XMMWORD PTR $T4[rbp-224], xmm0
	movaps	XMMWORD PTR $T4[rbp-208], xmm4
	movaps	XMMWORD PTR $T4[rbp-192], xmm3
	movaps	XMMWORD PTR $T4[rbp-176], xmm5
	movaps	XMMWORD PTR $T4[rbp-160], xmm6
	movaps	XMMWORD PTR $T4[rbp-144], xmm7
	movaps	XMMWORD PTR $T4[rbp-128], xmm8
	mov	DWORD PTR [rsp+32], r14d
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	ja	SHORT $LN20@ZSTD_compr

; 3104 :                                      ZSTDcrp_makeClean, zbuff) , "");
; 3105 :     {   size_t const dictID = cdict ?

	mov	rax, QWORD PTR [rbx+992]
	lea	rcx, QWORD PTR [rbx+160]
	mov	QWORD PTR [rsp+72], rax
	lea	r9, QWORD PTR [rbx+312]
	mov	rax, QWORD PTR [rdi+8]
	lea	r8, QWORD PTR [rbx+648]
	mov	DWORD PTR [rsp+64], r14d
	lea	rdx, QWORD PTR [rbx+776]
	mov	DWORD PTR [rsp+56], r14d
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR [rbx+760]
	call	ZSTD_compress_insertDictionary
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3115 :         FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");

	ja	SHORT $LN20@ZSTD_compr

; 3116 :         assert(dictID <= UINT_MAX);
; 3117 :         cctx->dictID = (U32)dictID;

	mov	DWORD PTR [rbx+304], eax

; 3118 :     }
; 3119 :     return 0;

	mov	rax, r14
$LN20@ZSTD_compr:

; 3578 :     DEBUGLOG(4, "ZSTD_compressBegin_usingCDict : dictIDFlag == %u", !fParams.noDictIDFlag);
; 3579 :     return ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, ZSTD_CONTENTSIZE_UNKNOWN);

	movaps	xmm8, XMMWORD PTR [rsp+448]
	movaps	xmm7, XMMWORD PTR [rsp+464]
	movaps	xmm6, XMMWORD PTR [rsp+480]
	mov	rsi, QWORD PTR [rsp+544]
$LN3@ZSTD_compr:

; 3580 : }

	mov	rbx, QWORD PTR [rsp+552]
	add	rsp, 496				; 000001f0H
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
ZSTD_compressBegin_usingCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
cctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
cdict$ = 120
fParams$ = 128
ZSTD_compress_usingCDict_advanced PROC

; 3586 : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	rax, QWORD PTR fParams$[rsp]
	mov	rsi, r9
	mov	rdi, QWORD PTR srcSize$[rsp]
	mov	rbp, r8
	mov	r14, rdx
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR cdict$[rsp]
	mov	r9, rdi
	movsd	xmm0, QWORD PTR [rax]
	mov	rbx, rcx
	mov	eax, DWORD PTR [rax+8]
	movsd	QWORD PTR $T1[rsp], xmm0
	mov	DWORD PTR $T1[rsp+8], eax
	call	ZSTD_compressBegin_usingCDict_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	ja	SHORT $LN1@ZSTD_compr

; 3588 :     return ZSTD_compressEnd(cctx, dst, dstCapacity, src, srcSize);

	mov	r9, rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbp
	mov	rdx, r14
	mov	rcx, rbx
	call	ZSTD_compressEnd
$LN1@ZSTD_compr:

; 3589 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
ZSTD_compress_usingCDict_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 48
cctx$ = 80
dst$ = 88
dstCapacity$ = 96
src$ = 104
srcSize$ = 112
cdict$ = 120
ZSTD_compress_usingCDict PROC

; 3600 : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	rdi, QWORD PTR srcSize$[rsp]

; 3600 : {

	mov	rsi, r9
	mov	rbp, r8

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	mov	QWORD PTR $T1[rsp], 1

; 3600 : {

	mov	r14, rdx

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR cdict$[rsp]
	xor	eax, eax
	mov	r9, rdi
	mov	DWORD PTR $T1[rsp+8], eax

; 3600 : {

	mov	rbx, rcx

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	call	ZSTD_compressBegin_usingCDict_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	ja	SHORT $LN3@ZSTD_compr

; 3588 :     return ZSTD_compressEnd(cctx, dst, dstCapacity, src, srcSize);

	mov	r9, rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rbp
	mov	rdx, r14
	mov	rcx, rbx
	call	ZSTD_compressEnd
$LN3@ZSTD_compr:

; 3601 :     ZSTD_frameParameters const fParams = { 1 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };
; 3602 :     return ZSTD_compress_usingCDict_advanced(cctx, dst, dstCapacity, src, srcSize, cdict, fParams);
; 3603 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
ZSTD_compress_usingCDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 80
cctx$ = 176
dict$ = 184
dictSize$ = 192
dictContentType$ = 200
cdict$ = 208
params$ = 216
pledgedSrcSize$ = 224
ZSTD_resetCStream_internal PROC

; 3647 : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	rbx, QWORD PTR params$[rsp]
	mov	esi, r9d
	mov	r12, QWORD PTR pledgedSrcSize$[rsp]

; 3648 :     DEBUGLOG(4, "ZSTD_resetCStream_internal");
; 3649 :     /* Finalize the compression parameters */
; 3650 :     params.cParams = ZSTD_getCParamsFromCCtxParams(&params, pledgedSrcSize, dictSize);

	mov	r9, r8
	mov	rdi, QWORD PTR cdict$[rsp]
	mov	r14, r8
	mov	rbp, rdx
	mov	r15, rcx
	mov	r8, r12
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdx, rbx
	call	ZSTD_getCParamsFromCCtxParams

; 3655 :     FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,

	mov	DWORD PTR [rsp+64], 1
	mov	r9d, esi
	mov	QWORD PTR [rsp+56], r12
	mov	r8, r14
	mov	QWORD PTR [rsp+48], rbx
	mov	rdx, rbp
	movups	xmm0, XMMWORD PTR [rax]
	mov	rcx, r15
	mov	QWORD PTR [rsp+40], rdi
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR [rbx+4], xmm0
	movsd	QWORD PTR [rbx+20], xmm1
	mov	DWORD PTR [rbx+28], eax
	call	ZSTD_compressBegin_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3655 :     FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,

	ja	SHORT $LN1@ZSTD_reset

; 3656 :                                          dict, dictSize, dictContentType, ZSTD_dtlm_fast,
; 3657 :                                          cdict,
; 3658 :                                          &params, pledgedSrcSize,
; 3659 :                                          ZSTDb_buffered) , "");
; 3660 : 
; 3661 :     cctx->inToCompress = 0;
; 3662 :     cctx->inBuffPos = 0;
; 3663 :     cctx->inBuffTarget = cctx->blockSize

	mov	rax, QWORD PTR [r15+376]
	xor	edx, edx
	cmp	rax, r12
	mov	QWORD PTR [r15+1016], rdx
	mov	ecx, edx
	mov	QWORD PTR [r15+1024], rdx
	sete	cl

; 3664 :                       + (cctx->blockSize == pledgedSrcSize);   /* for small input: avoid automatic flush on reaching end of block, since it would require to add a 3-bytes null block to end frame */
; 3665 :     cctx->outBuffContentSize = cctx->outBuffFlushedSize = 0;

	mov	QWORD PTR [r15+1064], rdx
	add	rcx, rax
	mov	QWORD PTR [r15+1056], rdx
	mov	QWORD PTR [r15+1032], rcx

; 3666 :     cctx->streamStage = zcss_load;
; 3667 :     cctx->frameEnded = 0;
; 3668 :     return 0;   /* ready to go */

	xor	eax, eax
	mov	QWORD PTR [r15+1072], 1
$LN1@ZSTD_reset:

; 3669 : }

	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_resetCStream_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
zcs$ = 80
dict$ = 88
dictSize$ = 96
cdict$ = 104
params$ = 112
pledgedSrcSize$ = 120
ZSTD_initCStream_internal PROC

; 3694 : {

$LN75:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 849  :     cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;

	mov	rax, QWORD PTR pledgedSrcSize$[rsp]

; 3694 : {

	mov	rdi, r9

; 849  :     cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;

	inc	rax

; 966  :         cctx->streamStage = zcss_init;

	mov	DWORD PTR [rcx+1072], 0

; 849  :     cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;

	mov	QWORD PTR [rcx+384], rax

; 3694 : {

	mov	rsi, r8

; 3695 :     DEBUGLOG(4, "ZSTD_initCStream_internal");
; 3696 :     FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
; 3697 :     FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , "");
; 3698 :     assert(!ZSTD_isError(ZSTD_checkCParams(params->cParams)));
; 3699 :     zcs->requestedParams = *params;

	mov	rax, QWORD PTR params$[rsp]
	mov	rbp, rdx
	mov	rbx, rcx
	movaps	xmm0, XMMWORD PTR [rax]
	movaps	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx+16], xmm0
	movaps	xmm0, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+32], xmm1
	movaps	xmm1, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+48], xmm0
	movaps	xmm0, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+64], xmm1
	movaps	xmm1, XMMWORD PTR [rax+80]
	movups	XMMWORD PTR [rcx+80], xmm0
	movaps	xmm0, XMMWORD PTR [rax+96]
	movups	XMMWORD PTR [rcx+96], xmm1
	movaps	xmm1, XMMWORD PTR [rax+112]
	movups	XMMWORD PTR [rcx+112], xmm0
	movaps	xmm0, XMMWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx+128], xmm1
	movups	XMMWORD PTR [rcx+144], xmm0

; 3700 :     assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
; 3701 :     if (dict) {

	test	rdx, rdx
	je	$LN13@ZSTD_initC

; 897  :     RETURN_ERROR_IF(cctx->staticSize, memory_allocation,

	cmp	QWORD PTR [rcx+520], 0
	jne	SHORT $LN72@ZSTD_initC

; 898  :                     "no malloc for static CCtx");
; 899  :     DEBUGLOG(4, "ZSTD_CCtx_loadDictionary_advanced (size: %u)", (U32)dictSize);
; 900  :     ZSTD_clearAllDicts(cctx);  /* in case one already exists */

	call	ZSTD_clearAllDicts

; 901  :     if (dict == NULL || dictSize == 0)  /* no dictionary mode */

	test	rsi, rsi
	je	SHORT $LN12@ZSTD_initC
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx+496]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 906  :         void* dictBuffer = ZSTD_malloc(dictSize, cctx->customMem);

	movsd	xmm0, QWORD PTR [rbx+512]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN62@ZSTD_initC

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rsi
	call	rax
	jmp	SHORT $LN73@ZSTD_initC
$LN62@ZSTD_initC:

; 60   :     return malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
$LN73@ZSTD_initC:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 907  :         RETURN_ERROR_IF(!dictBuffer, memory_allocation, "NULL pointer!");

	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN72@ZSTD_initC

; 908  :         memcpy(dictBuffer, dict, dictSize);

	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, rax
	call	memcpy

; 909  :         cctx->localDict.dictBuffer = dictBuffer;

	mov	QWORD PTR [rbx+1080], rdi

; 910  :         cctx->localDict.dict = dictBuffer;

	mov	QWORD PTR [rbx+1088], rdi

; 911  :     }
; 912  :     cctx->localDict.dictSize = dictSize;

	mov	QWORD PTR [rbx+1096], rsi

; 913  :     cctx->localDict.dictContentType = dictContentType;

	mov	DWORD PTR [rbx+1104], 0

; 914  :     return 0;

	jmp	SHORT $LN12@ZSTD_initC
$LN72@ZSTD_initC:

; 3702 :         FORWARD_IF_ERROR( ZSTD_CCtx_loadDictionary(zcs, dict, dictSize) , "");

	mov	rax, -64				; ffffffffffffffc0H
	jmp	SHORT $LN1@ZSTD_initC
$LN13@ZSTD_initC:

; 936  :     ZSTD_clearAllDicts(cctx);

	call	ZSTD_clearAllDicts

; 937  :     cctx->cdict = cdict;

	mov	QWORD PTR [rbx+1120], rdi
$LN12@ZSTD_initC:

; 3703 :     } else {
; 3704 :         /* Dictionary is cleared if !cdict */
; 3705 :         FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, cdict) , "");
; 3706 :     }
; 3707 :     return 0;

	xor	eax, eax
$LN1@ZSTD_initC:

; 3708 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTD_initCStream_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
cctx$ = 8
ZSTD_nextInputSizeHint PROC

; 3794 :     size_t hintInSize = cctx->inBuffTarget - cctx->inBuffPos;

	mov	rax, QWORD PTR [rcx+1032]
	sub	rax, QWORD PTR [rcx+1024]

; 3795 :     if (hintInSize==0) hintInSize = cctx->blockSize;

	jne	SHORT $LN4@ZSTD_nextI

; 3796 :     return hintInSize;

	mov	rax, QWORD PTR [rcx+376]
$LN4@ZSTD_nextI:

; 3797 : }

	ret	0
ZSTD_nextInputSizeHint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
someMoreWork$1$ = 64
istart$1$ = 72
ostart$1$ = 80
zcs$ = 160
output$ = 168
input$ = 176
flushMode$ = 184
ZSTD_compressStream_generic PROC

; 3807 : {

	mov	r11, rsp
	mov	QWORD PTR [r11+24], r8
	mov	QWORD PTR [r11+16], rdx
	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H

; 3808 :     const char* const istart = (const char*)input->src;
; 3809 :     const char* const iend = input->size != 0 ? istart + input->size : istart;

	mov	rax, QWORD PTR [r8+8]
	mov	r15d, r9d

; 3810 :     const char* ip = input->pos != 0 ? istart + input->pos : istart;

	test	rax, rax

; 3811 :     char* const ostart = (char*)output->dst;
; 3812 :     char* const oend = output->size != 0 ? ostart + output->size : ostart;
; 3813 :     char* op = output->pos != 0 ? ostart + output->pos : ostart;
; 3814 :     U32 someMoreWork = 1;

	mov	QWORD PTR [r11+8], rsi
	mov	r9, rdx
	mov	DWORD PTR someMoreWork$1$[rsp], 1
	mov	rdx, QWORD PTR [r8]
	mov	rbx, rcx
	mov	rcx, QWORD PTR [r8+16]
	mov	QWORD PTR istart$1$[rsp], rdx
	mov	r8, QWORD PTR [r9]
	lea	r13, QWORD PTR [rax+rdx]
	mov	QWORD PTR ostart$1$[rsp], r8
	mov	rax, QWORD PTR [r9+8]
	lea	rbp, QWORD PTR [rcx+rdx]
	cmove	r13, rdx
	mov	QWORD PTR [r11-56], r14
	test	rax, rax
	lea	r12, QWORD PTR [rax+r8]
	mov	rax, QWORD PTR [r9+16]
	cmove	r12, r8
	test	rcx, rcx
	cmove	rbp, rdx
	test	rax, rax
	lea	rdi, QWORD PTR [rax+r8]
	cmove	rdi, r8
	xor	r10d, r10d
$LL2@ZSTD_compr:

; 3826 :         switch(zcs->streamStage)

	mov	ecx, DWORD PTR [rbx+1072]
	test	ecx, ecx
	je	$LN8@ZSTD_compr
	sub	ecx, 1
	je	SHORT $LN7@ZSTD_compr
	cmp	ecx, 1
	jne	SHORT $LL2@ZSTD_compr
	jmp	$LN32@ZSTD_compr
$LN7@ZSTD_compr:

; 3830 : 
; 3831 :         case zcss_load:
; 3832 :             if ( (flushMode == ZSTD_e_end)
; 3833 :               && ((size_t)(oend-op) >= ZSTD_compressBound(iend-ip))  /* enough dstCapacity */
; 3834 :               && (zcs->inBuffPos == 0) ) {

	cmp	r15d, 2
	jne	SHORT $LN18@ZSTD_compr
	mov	rdx, r13

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	eax, 131072				; 00020000H

; 3830 : 
; 3831 :         case zcss_load:
; 3832 :             if ( (flushMode == ZSTD_e_end)
; 3833 :               && ((size_t)(oend-op) >= ZSTD_compressBound(iend-ip))  /* enough dstCapacity */
; 3834 :               && (zcs->inBuffPos == 0) ) {

	sub	rdx, rbp

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	rcx, r10
	sub	rax, rdx

; 3830 : 
; 3831 :         case zcss_load:
; 3832 :             if ( (flushMode == ZSTD_e_end)
; 3833 :               && ((size_t)(oend-op) >= ZSTD_compressBound(iend-ip))  /* enough dstCapacity */
; 3834 :               && (zcs->inBuffPos == 0) ) {

	mov	r8, r12

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	shr	rax, 11
	cmp	rdx, 131072				; 00020000H
	cmovb	rcx, rax
	mov	rax, rdx
	shr	rax, 8

; 3830 : 
; 3831 :         case zcss_load:
; 3832 :             if ( (flushMode == ZSTD_e_end)
; 3833 :               && ((size_t)(oend-op) >= ZSTD_compressBound(iend-ip))  /* enough dstCapacity */
; 3834 :               && (zcs->inBuffPos == 0) ) {

	sub	r8, rdi

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	add	rax, rcx
	add	rax, rdx

; 3830 : 
; 3831 :         case zcss_load:
; 3832 :             if ( (flushMode == ZSTD_e_end)
; 3833 :               && ((size_t)(oend-op) >= ZSTD_compressBound(iend-ip))  /* enough dstCapacity */
; 3834 :               && (zcs->inBuffPos == 0) ) {

	cmp	r8, rax
	jb	SHORT $LN18@ZSTD_compr
	cmp	QWORD PTR [rbx+1024], 0
	je	$LN124@ZSTD_compr
$LN18@ZSTD_compr:

; 3845 :             }
; 3846 :             /* complete loading into inBuffer */
; 3847 :             {   size_t const toLoad = zcs->inBuffTarget - zcs->inBuffPos;

	mov	rcx, QWORD PTR [rbx+1024]

; 3848 :                 size_t const loaded = ZSTD_limitCopy(

	mov	rsi, r13
	mov	rax, QWORD PTR [rbx+1032]
	sub	rsi, rbp
	sub	rax, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 306  :     size_t const length = MIN(dstCapacity, srcSize);

	cmp	rax, rsi
	cmovb	rsi, rax

; 307  :     if (length > 0) {

	test	rsi, rsi
	je	SHORT $LN72@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3848 :                 size_t const loaded = ZSTD_limitCopy(

	add	rcx, QWORD PTR [rbx+1000]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 308  :         memcpy(dst, src, length);

	mov	r8, rsi
	mov	rdx, rbp
	call	memcpy
	mov	rcx, QWORD PTR [rbx+1024]
	xor	r10d, r10d
$LN72@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3851 :                 zcs->inBuffPos += loaded;

	add	rcx, rsi

; 3852 :                 if (loaded != 0)
; 3853 :                     ip += loaded;
; 3854 :                 if ( (flushMode == ZSTD_e_continue)
; 3855 :                   && (zcs->inBuffPos < zcs->inBuffTarget) ) {

	lea	rax, QWORD PTR [rsi+rbp]
	test	rsi, rsi
	mov	QWORD PTR [rbx+1024], rcx
	cmove	rax, rbp
	mov	rbp, rax
	test	r15d, r15d
	jne	SHORT $LN22@ZSTD_compr
	cmp	rcx, QWORD PTR [rbx+1032]
	jb	$LN127@ZSTD_compr

; 3856 :                     /* not enough input to fill full block : stop here */
; 3857 :                     someMoreWork = 0; break;
; 3858 :                 }
; 3859 :                 if ( (flushMode == ZSTD_e_flush)
; 3860 :                   && (zcs->inBuffPos == zcs->inToCompress) ) {

	mov	r9, QWORD PTR [rbx+1016]
	mov	r8, r12
	sub	rcx, r9
	sub	r8, rdi
	jmp	SHORT $LN121@ZSTD_compr
$LN22@ZSTD_compr:
	cmp	r15d, 1
	jne	SHORT $LN120@ZSTD_compr
	cmp	rcx, QWORD PTR [rbx+1016]
	je	$LN127@ZSTD_compr
$LN120@ZSTD_compr:

; 3861 :                     /* empty */
; 3862 :                     someMoreWork = 0; break;
; 3863 :                 }
; 3864 :             }
; 3865 :             /* compress current block (note : this stage cannot be stopped in the middle) */
; 3866 :             DEBUGLOG(5, "stream compression stage (flushMode==%u)", flushMode);
; 3867 :             {   void* cDst;
; 3868 :                 size_t cSize;
; 3869 :                 size_t const iSize = zcs->inBuffPos - zcs->inToCompress;

	mov	r9, QWORD PTR [rbx+1016]

; 3870 :                 size_t oSize = oend-op;

	mov	r8, r12
	sub	rcx, r9
	sub	r8, rdi

; 3871 :                 unsigned const lastBlock = (flushMode == ZSTD_e_end) && (ip==iend);

	cmp	r15d, 2
	jne	SHORT $LN121@ZSTD_compr
	lea	r14d, QWORD PTR [r15-1]
	cmp	rax, r13
	je	SHORT $LN48@ZSTD_compr
$LN121@ZSTD_compr:
	mov	r14d, r10d
$LN48@ZSTD_compr:

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	cmp	rcx, 131072				; 00020000H
	jae	SHORT $LN76@ZSTD_compr
	mov	edx, 131072				; 00020000H
	sub	rdx, rcx
	shr	rdx, 11
	jmp	SHORT $LN77@ZSTD_compr
$LN76@ZSTD_compr:
	mov	rdx, r10
$LN77@ZSTD_compr:
	mov	rax, rcx
	shr	rax, 8
	add	rax, rdx
	add	rax, rcx

; 3872 :                 if (oSize >= ZSTD_compressBound(iSize))

	cmp	r8, rax
	jb	SHORT $LN24@ZSTD_compr

; 3873 :                     cDst = op;   /* compress into output buffer, to skip flush stage */

	mov	rsi, rdi
	jmp	SHORT $LN25@ZSTD_compr
$LN24@ZSTD_compr:

; 3874 :                 else
; 3875 :                     cDst = zcs->outBuff, oSize = zcs->outBuffSize;

	mov	rsi, QWORD PTR [rbx+1040]
	mov	r8, QWORD PTR [rbx+1048]
$LN25@ZSTD_compr:

; 3876 :                 cSize = lastBlock ?

	add	r9, QWORD PTR [rbx+1000]
	mov	rdx, rsi
	test	r14d, r14d
	je	SHORT $LN49@ZSTD_compr
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	ZSTD_compressEnd
	jmp	SHORT $LN132@ZSTD_compr
$LN49@ZSTD_compr:

; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	DWORD PTR [rsp+48], r10d
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	ZSTD_compressContinue_internal
$LN132@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rcx, rax
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3881 :                 FORWARD_IF_ERROR(cSize, "%s", lastBlock ? "ZSTD_compressEnd failed" : "ZSTD_compressContinue failed");

	ja	$LN118@ZSTD_compr

; 3882 :                 zcs->frameEnded = lastBlock;
; 3883 :                 /* prepare next block */
; 3884 :                 zcs->inBuffTarget = zcs->inBuffPos + zcs->blockSize;

	mov	rdx, QWORD PTR [rbx+1024]

; 3885 :                 if (zcs->inBuffTarget > zcs->inBuffSize)

	xor	r10d, r10d
	mov	r8, QWORD PTR [rbx+376]
	mov	DWORD PTR [rbx+1076], r14d
	lea	rax, QWORD PTR [r8+rdx]
	mov	QWORD PTR [rbx+1032], rax
	cmp	rax, QWORD PTR [rbx+1008]
	jbe	SHORT $LN28@ZSTD_compr

; 3886 :                     zcs->inBuffPos = 0, zcs->inBuffTarget = zcs->blockSize;

	mov	QWORD PTR [rbx+1024], r10
	mov	edx, r10d
	mov	QWORD PTR [rbx+1032], r8
$LN28@ZSTD_compr:

; 3887 :                 DEBUGLOG(5, "inBuffTarget:%u / inBuffSize:%u",
; 3888 :                          (unsigned)zcs->inBuffTarget, (unsigned)zcs->inBuffSize);
; 3889 :                 if (!lastBlock)
; 3890 :                     assert(zcs->inBuffTarget <= zcs->inBuffSize);
; 3891 :                 zcs->inToCompress = zcs->inBuffPos;

	mov	QWORD PTR [rbx+1016], rdx

; 3892 :                 if (cDst == op) {  /* no need to flush */

	cmp	rsi, rdi
	jne	SHORT $LN30@ZSTD_compr

; 3893 :                     op += cSize;

	add	rdi, rcx

; 3894 :                     if (zcs->frameEnded) {

	test	r14d, r14d
	je	$LN36@ZSTD_compr

; 3895 :                         DEBUGLOG(5, "Frame completed directly in outBuffer");
; 3896 :                         someMoreWork = 0;

	mov	DWORD PTR someMoreWork$1$[rsp], r10d

; 966  :         cctx->streamStage = zcss_init;

	mov	DWORD PTR [rbx+1072], r10d

; 967  :         cctx->pledgedSrcSizePlusOne = 0;

	mov	QWORD PTR [rbx+384], r10

; 3897 :                         ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
; 3898 :                     }
; 3899 :                     break;

	jmp	$LN36@ZSTD_compr
$LN30@ZSTD_compr:

; 3900 :                 }
; 3901 :                 zcs->outBuffContentSize = cSize;

	mov	QWORD PTR [rbx+1056], rcx

; 3902 :                 zcs->outBuffFlushedSize = 0;

	mov	QWORD PTR [rbx+1064], r10

; 3903 :                 zcs->streamStage = zcss_flush; /* pass-through to flush stage */

	mov	DWORD PTR [rbx+1072], 2
$LN32@ZSTD_compr:

; 3904 :             }
; 3905 : 	    /* fall-through */
; 3906 :         case zcss_flush:
; 3907 :             DEBUGLOG(5, "flush stage");
; 3908 :             {   size_t const toFlush = zcs->outBuffContentSize - zcs->outBuffFlushedSize;

	mov	rcx, QWORD PTR [rbx+1064]

; 3909 :                 size_t const flushed = ZSTD_limitCopy(op, (size_t)(oend-op),

	mov	rax, r12
	mov	r14, QWORD PTR [rbx+1056]
	sub	rax, rdi
	sub	r14, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 306  :     size_t const length = MIN(dstCapacity, srcSize);

	cmp	rax, r14
	mov	rsi, r14
	cmovb	rsi, rax

; 307  :     if (length > 0) {

	test	rsi, rsi
	je	SHORT $LN97@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3909 :                 size_t const flushed = ZSTD_limitCopy(op, (size_t)(oend-op),

	mov	rdx, QWORD PTR [rbx+1040]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 308  :         memcpy(dst, src, length);

	mov	r8, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3909 :                 size_t const flushed = ZSTD_limitCopy(op, (size_t)(oend-op),

	add	rdx, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 308  :         memcpy(dst, src, length);

	mov	rcx, rdi
	call	memcpy
	mov	rcx, QWORD PTR [rbx+1064]
$LN97@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3915 :                 zcs->outBuffFlushedSize += flushed;

	test	rsi, rsi
	lea	rax, QWORD PTR [rsi+rdi]
	cmove	rax, rdi
	mov	rdi, rax
	lea	rax, QWORD PTR [rcx+rsi]
	mov	QWORD PTR [rbx+1064], rax

; 3916 :                 if (toFlush!=flushed) {

	cmp	r14, rsi
	jne	SHORT $LN127@ZSTD_compr

; 3917 :                     /* flush not fully completed, presumably because dst is too small */
; 3918 :                     assert(op==oend);
; 3919 :                     someMoreWork = 0;
; 3920 :                     break;
; 3921 :                 }
; 3922 :                 zcs->outBuffContentSize = zcs->outBuffFlushedSize = 0;

	xor	r10d, r10d
	mov	QWORD PTR [rbx+1064], r10
	mov	QWORD PTR [rbx+1056], r10

; 3923 :                 if (zcs->frameEnded) {

	cmp	DWORD PTR [rbx+1076], r10d
	jne	SHORT $LN128@ZSTD_compr

; 3924 :                     DEBUGLOG(5, "Frame completed on flush");
; 3925 :                     someMoreWork = 0;
; 3926 :                     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
; 3927 :                     break;
; 3928 :                 }
; 3929 :                 zcs->streamStage = zcss_load;

	mov	DWORD PTR [rbx+1072], 1
$LN36@ZSTD_compr:

; 3815 : 
; 3816 :     /* check expectations */
; 3817 :     DEBUGLOG(5, "ZSTD_compressStream_generic, flush=%u", (unsigned)flushMode);
; 3818 :     assert(zcs->inBuff != NULL);
; 3819 :     assert(zcs->inBuffSize > 0);
; 3820 :     assert(zcs->outBuff !=  NULL);
; 3821 :     assert(zcs->outBuffSize > 0);
; 3822 :     assert(output->pos <= output->size);
; 3823 :     assert(input->pos <= input->size);
; 3824 : 
; 3825 :     while (someMoreWork) {

	cmp	DWORD PTR someMoreWork$1$[rsp], 0
	jne	$LL2@ZSTD_compr
	jmp	SHORT $LN127@ZSTD_compr
$LN124@ZSTD_compr:

; 3835 :                 /* shortcut to compression pass directly into output buffer */
; 3836 :                 size_t const cSize = ZSTD_compressEnd(zcs,

	mov	QWORD PTR [rsp+32], rdx
	mov	r9, rbp
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_compressEnd
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3839 :                 FORWARD_IF_ERROR(cSize, "ZSTD_compressEnd failed");

	ja	$LN1@ZSTD_compr

; 3841 :                 op += cSize;

	add	rdi, rax

; 3842 :                 zcs->frameEnded = 1;

	mov	DWORD PTR [rbx+1076], 1

; 966  :         cctx->streamStage = zcss_init;

	xor	eax, eax

; 3840 :                 ip = iend;

	mov	rbp, r13

; 966  :         cctx->streamStage = zcss_init;

	mov	DWORD PTR [rbx+1072], eax

; 967  :         cctx->pledgedSrcSizePlusOne = 0;

	mov	QWORD PTR [rbx+384], rax

; 3843 :                 ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
; 3844 :                 someMoreWork = 0; break;

	jmp	SHORT $LN127@ZSTD_compr
$LN128@ZSTD_compr:

; 966  :         cctx->streamStage = zcss_init;

	mov	DWORD PTR [rbx+1072], r10d

; 967  :         cctx->pledgedSrcSizePlusOne = 0;

	mov	QWORD PTR [rbx+384], r10
$LN127@ZSTD_compr:

; 3930 :                 break;
; 3931 :             }
; 3932 : 
; 3933 :         default: /* impossible */
; 3934 :             assert(0);
; 3935 :         }
; 3936 :     }
; 3937 : 
; 3938 :     input->pos = ip - istart;

	mov	rax, QWORD PTR input$[rsp]
	sub	rbp, QWORD PTR istart$1$[rsp]

; 3939 :     output->pos = op - ostart;

	sub	rdi, QWORD PTR ostart$1$[rsp]
	mov	QWORD PTR [rax+16], rbp

; 3940 :     if (zcs->frameEnded) return 0;

	cmp	DWORD PTR [rbx+1076], 0
	mov	rax, QWORD PTR output$[rsp]
	mov	QWORD PTR [rax+16], rdi
	je	SHORT $LN37@ZSTD_compr
	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_compr
$LN37@ZSTD_compr:

; 3794 :     size_t hintInSize = cctx->inBuffTarget - cctx->inBuffPos;

	mov	rax, QWORD PTR [rbx+1032]
	sub	rax, QWORD PTR [rbx+1024]

; 3795 :     if (hintInSize==0) hintInSize = cctx->blockSize;

	jne	SHORT $LN1@ZSTD_compr
	mov	rax, QWORD PTR [rbx+376]

; 3941 :     return ZSTD_nextInputSizeHint(zcs);

	jmp	SHORT $LN1@ZSTD_compr
$LN118@ZSTD_compr:

; 3881 :                 FORWARD_IF_ERROR(cSize, "%s", lastBlock ? "ZSTD_compressEnd failed" : "ZSTD_compressContinue failed");

	mov	rax, rcx
	jmp	SHORT $LN1@ZSTD_compr
$LN8@ZSTD_compr:

; 3827 :         {
; 3828 :         case zcss_init:
; 3829 :             RETURN_ERROR(init_missing, "call ZSTD_initCStream() first!");

	mov	rax, -62				; ffffffffffffffc2H
$LN1@ZSTD_compr:
	mov	r14, QWORD PTR [rsp+96]

; 3942 : }

	mov	rsi, QWORD PTR [rsp+160]
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressStream_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
prefixDict$1 = 80
$T2 = 112
$T3 = 112
cParams$4 = 144
$T5 = 144
params$4$ = 176
params$2$ = 192
params$3$ = 208
params$5$ = 224
params$6$ = 240
params$7$ = 256
params$8$ = 272
$T6 = 288
$T7 = 288
$T8 = 432
$T9 = 432
$T10 = 432
$T11 = 432
params$12 = 464
cctx$ = 736
output$ = 744
input$ = 752
endOp$ = 760
ZSTD_compressStream2 PROC

; 3967 : {

$LN119:
	mov	r11, rsp
	push	rbp
	push	rbx
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [r11-472]
	sub	rsp, 688				; 000002b0H

; 3968 :     DEBUGLOG(5, "ZSTD_compressStream2, endOp=%u ", (unsigned)endOp);
; 3969 :     /* check conditions */
; 3970 :     RETURN_ERROR_IF(output->pos > output->size, GENERIC, "invalid buffer");

	mov	rax, QWORD PTR [rdx+8]
	mov	r15d, r9d
	mov	r13, r8
	mov	r14, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rdx+16], rax
	ja	$LN107@ZSTD_compr

; 3971 :     RETURN_ERROR_IF(input->pos  > input->size, GENERIC, "invalid buffer");

	mov	rax, QWORD PTR [r8+8]
	cmp	QWORD PTR [r8+16], rax
	ja	$LN107@ZSTD_compr

; 3972 :     assert(cctx!=NULL);
; 3973 : 
; 3974 :     /* transparent initialization stage */
; 3975 :     if (cctx->streamStage == zcss_init) {

	mov	QWORD PTR [r11+8], rsi
	xor	esi, esi
	mov	QWORD PTR [r11+16], rdi
	mov	QWORD PTR [r11+24], r12
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movaps	XMMWORD PTR [r11-120], xmm10
	cmp	DWORD PTR [rcx+1072], esi
	jne	$LN9@ZSTD_compr

; 3976 :         ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm0, XMMWORD PTR [rcx+16]

; 861  :     ZSTD_compressionParameters const cParams = ZSTD_getCParamsFromCCtxParams(

	mov	r9, QWORD PTR [rcx+1096]
	lea	rdx, QWORD PTR [rcx+16]

; 3976 :         ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm1, XMMWORD PTR [rcx+32]

; 861  :     ZSTD_compressionParameters const cParams = ZSTD_getCParamsFromCCtxParams(

	lea	r8, QWORD PTR [rsi-1]

; 3976 :         ZSTD_CCtx_params params = cctx->requestedParams;

	movups	xmm4, XMMWORD PTR [rcx+80]
	movups	xmm5, XMMWORD PTR [rcx+48]
	movups	xmm6, XMMWORD PTR [rcx+64]
	movups	xmm7, XMMWORD PTR [rcx+96]
	movups	xmm8, XMMWORD PTR [rcx+112]
	movups	xmm9, XMMWORD PTR [rcx+128]
	movups	xmm10, XMMWORD PTR [rcx+144]
	movaps	XMMWORD PTR params$12[rbp-256], xmm0

; 3977 :         ZSTD_prefixDict const prefixDict = cctx->prefixDict;

	movups	xmm0, XMMWORD PTR [rcx+1128]
	movaps	XMMWORD PTR params$12[rbp-240], xmm1
	movsd	xmm1, QWORD PTR [rcx+1144]

; 861  :     ZSTD_compressionParameters const cParams = ZSTD_getCParamsFromCCtxParams(

	lea	rcx, QWORD PTR $T10[rbp-256]

; 3977 :         ZSTD_prefixDict const prefixDict = cctx->prefixDict;

	movups	XMMWORD PTR prefixDict$1[rsp], xmm0
	movups	XMMWORD PTR params$2$[rbp-256], xmm5
	movups	XMMWORD PTR params$3$[rbp-256], xmm6
	movups	XMMWORD PTR params$4$[rbp-256], xmm4
	movaps	XMMWORD PTR params$12[rbp-192], xmm4
	movups	XMMWORD PTR params$5$[rbp-256], xmm7
	movups	XMMWORD PTR params$6$[rbp-256], xmm8
	movups	XMMWORD PTR params$7$[rbp-256], xmm9
	movups	XMMWORD PTR params$8$[rbp-256], xmm10
	movsd	QWORD PTR prefixDict$1[rsp+16], xmm1

; 861  :     ZSTD_compressionParameters const cParams = ZSTD_getCParamsFromCCtxParams(

	call	ZSTD_getCParamsFromCCtxParams

; 862  :             &cctx->requestedParams, ZSTD_CONTENTSIZE_UNKNOWN, dl->dictSize);
; 863  :     if (dl->dict == NULL) {

	mov	rcx, QWORD PTR [rbx+1088]
	test	rcx, rcx
	je	$LN2@ZSTD_compr

; 864  :         /* No local dictionary. */
; 865  :         assert(dl->dictBuffer == NULL);
; 866  :         assert(dl->cdict == NULL);
; 867  :         assert(dl->dictSize == 0);
; 868  :         return 0;
; 869  :     }
; 870  :     if (dl->cdict != NULL) {

	cmp	QWORD PTR [rbx+1112], rsi
	jne	$LN2@ZSTD_compr

; 871  :         assert(cctx->cdict == dl->cdict);
; 872  :         /* Local dictionary already initialized. */
; 873  :         return 0;
; 874  :     }
; 875  :     assert(dl->dictSize > 0);
; 876  :     assert(cctx->cdict == NULL);
; 877  :     assert(cctx->prefixDict.dict == NULL);
; 878  : 
; 879  :     dl->cdict = ZSTD_createCDict_advanced(

	movups	xmm0, XMMWORD PTR [rbx+496]
	lea	r8d, QWORD PTR [rsi+1]
	mov	r9d, DWORD PTR [rbx+1104]
	movsd	xmm1, QWORD PTR [rbx+512]
	mov	rdx, QWORD PTR [rbx+1096]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rax]
	movsd	QWORD PTR $T3[rbp-240], xmm1
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR $T5[rbp-232], eax
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T5[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T5[rbp-256], xmm0
	movsd	QWORD PTR $T5[rbp-240], xmm1
	call	ZSTD_createCDict_advanced
	mov	QWORD PTR [rbx+1112], rax

; 880  :             dl->dict,
; 881  :             dl->dictSize,
; 882  :             ZSTD_dlm_byRef,
; 883  :             dl->dictContentType,
; 884  :             cParams,
; 885  :             cctx->customMem);
; 886  :     RETURN_ERROR_IF(!dl->cdict, memory_allocation, "ZSTD_createCDict_advanced failed");

	test	rax, rax
	je	$LN106@ZSTD_compr
	movups	xmm4, XMMWORD PTR params$4$[rbp-256]

; 887  :     cctx->cdict = dl->cdict;

	mov	QWORD PTR [rbx+1120], rax
	movups	xmm5, XMMWORD PTR params$2$[rbp-256]
	movups	xmm6, XMMWORD PTR params$3$[rbp-256]
	movups	xmm7, XMMWORD PTR params$5$[rbp-256]
	movups	xmm8, XMMWORD PTR params$6$[rbp-256]
	movups	xmm9, XMMWORD PTR params$7$[rbp-256]
	movups	xmm10, XMMWORD PTR params$8$[rbp-256]
$LN2@ZSTD_compr:

; 3978 :         FORWARD_IF_ERROR( ZSTD_initLocalDict(cctx) , ""); /* Init the local dict if present. */
; 3979 :         memset(&cctx->prefixDict, 0, sizeof(cctx->prefixDict));   /* single usage */

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rbx+1128], xmm0
	mov	QWORD PTR [rbx+1144], rax

; 3980 :         assert(prefixDict.dict==NULL || cctx->cdict==NULL);    /* only one can be set */
; 3981 :         DEBUGLOG(4, "ZSTD_compressStream2 : transparent init stage");
; 3982 :         if (endOp == ZSTD_e_end) cctx->pledgedSrcSizePlusOne = input->size + 1;  /* auto-fix pledgedSrcSize */

	cmp	r15d, 2
	jne	SHORT $LN100@ZSTD_compr
	mov	r8, QWORD PTR [r13+8]
	inc	r8
	mov	QWORD PTR [rbx+384], r8
	jmp	SHORT $LN27@ZSTD_compr
$LN100@ZSTD_compr:
	mov	r8, QWORD PTR [rbx+384]
$LN27@ZSTD_compr:

; 3983 :         params.cParams = ZSTD_getCParamsFromCCtxParams(

	dec	r8
	lea	rdx, QWORD PTR [rbx+16]
	xor	r9d, r9d
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	ZSTD_getCParamsFromCCtxParams
	movups	xmm3, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR params$12[rbp-228], eax

; 3984 :                 &cctx->requestedParams, cctx->pledgedSrcSizePlusOne-1, 0 /*dictSize*/);
; 3985 : 
; 3986 : 
; 3987 : #ifdef ZSTD_MULTITHREAD
; 3988 :         if ((cctx->pledgedSrcSizePlusOne-1) <= ZSTDMT_JOBSIZE_MIN) {

	mov	rax, QWORD PTR [rbx+384]
	movups	XMMWORD PTR params$12[rbp-252], xmm3
	movsd	QWORD PTR params$12[rbp-236], xmm0
	lea	r12, QWORD PTR [rax-1]
	cmp	r12, 1048576				; 00100000H
	ja	$LN28@ZSTD_compr

; 3989 :             params.nbWorkers = 0; /* do not invoke multi-threading when src size is too small */

	mov	DWORD PTR params$12[rbp-180], esi

; 3990 :         }
; 3991 :         if (params.nbWorkers > 0) {

	movaps	xmm4, XMMWORD PTR params$12[rbp-192]
$LN10@ZSTD_compr:

; 4008 : #endif
; 4009 :         {   FORWARD_IF_ERROR( ZSTD_resetCStream_internal(cctx,

	movaps	xmm0, XMMWORD PTR params$12[rbp-256]

; 3650 :     params.cParams = ZSTD_getCParamsFromCCtxParams(&params, pledgedSrcSize, dictSize);

	lea	rdx, QWORD PTR $T6[rbp-256]

; 4008 : #endif
; 4009 :         {   FORWARD_IF_ERROR( ZSTD_resetCStream_internal(cctx,

	movaps	xmm1, XMMWORD PTR params$12[rbp-240]

; 3650 :     params.cParams = ZSTD_getCParamsFromCCtxParams(&params, pledgedSrcSize, dictSize);

	lea	rcx, QWORD PTR $T9[rbp-256]
	mov	r9, QWORD PTR prefixDict$1[rsp+8]
	mov	r8, r12

; 4008 : #endif
; 4009 :         {   FORWARD_IF_ERROR( ZSTD_resetCStream_internal(cctx,

	mov	rdi, QWORD PTR [rbx+1120]
	movaps	XMMWORD PTR $T6[rbp-256], xmm0
	movaps	XMMWORD PTR $T6[rbp-240], xmm1
	movaps	XMMWORD PTR $T6[rbp-224], xmm5
	movaps	XMMWORD PTR $T6[rbp-208], xmm6
	movaps	XMMWORD PTR $T6[rbp-192], xmm4
	movaps	XMMWORD PTR $T6[rbp-176], xmm7
	movaps	XMMWORD PTR $T6[rbp-160], xmm8
	movaps	XMMWORD PTR $T6[rbp-144], xmm9
	movaps	XMMWORD PTR $T6[rbp-128], xmm10

; 3650 :     params.cParams = ZSTD_getCParamsFromCCtxParams(&params, pledgedSrcSize, dictSize);

	call	ZSTD_getCParamsFromCCtxParams

; 3655 :     FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,

	mov	r9d, DWORD PTR prefixDict$1[rsp+16]
	mov	rcx, rbx
	mov	r8, QWORD PTR prefixDict$1[rsp+8]
	mov	rdx, QWORD PTR prefixDict$1[rsp]
	movups	xmm3, XMMWORD PTR [rax]
	mov	DWORD PTR [rsp+64], 1
	movsd	xmm0, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR $T6[rbp-228], eax
	lea	rax, QWORD PTR $T6[rbp-256]
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rdi
	movups	XMMWORD PTR $T6[rbp-252], xmm3
	movsd	QWORD PTR $T6[rbp-236], xmm0
	call	ZSTD_compressBegin_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3655 :     FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,

	ja	$LN117@ZSTD_compr

; 3656 :                                          dict, dictSize, dictContentType, ZSTD_dtlm_fast,
; 3657 :                                          cdict,
; 3658 :                                          &params, pledgedSrcSize,
; 3659 :                                          ZSTDb_buffered) , "");
; 3660 : 
; 3661 :     cctx->inToCompress = 0;
; 3662 :     cctx->inBuffPos = 0;
; 3663 :     cctx->inBuffTarget = cctx->blockSize

	mov	rax, QWORD PTR [rbx+376]
	mov	rcx, rsi
	cmp	rax, r12
	mov	QWORD PTR [rbx+1016], rsi
	mov	QWORD PTR [rbx+1024], rsi
	sete	cl

; 3664 :                       + (cctx->blockSize == pledgedSrcSize);   /* for small input: avoid automatic flush on reaching end of block, since it would require to add a 3-bytes null block to end frame */
; 3665 :     cctx->outBuffContentSize = cctx->outBuffFlushedSize = 0;

	mov	QWORD PTR [rbx+1064], rsi
	add	rcx, rax
	mov	QWORD PTR [rbx+1056], rsi
	mov	QWORD PTR [rbx+1032], rcx

; 3666 :     cctx->streamStage = zcss_load;

	mov	QWORD PTR [rbx+1072], 1
$LN9@ZSTD_compr:

; 4010 :                             prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType,
; 4011 :                             cctx->cdict,
; 4012 :                             params, cctx->pledgedSrcSizePlusOne-1) , "");
; 4013 :             assert(cctx->streamStage == zcss_load);
; 4014 :             assert(cctx->appliedParams.nbWorkers == 0);
; 4015 :     }   }
; 4016 :     /* end of transparent initialization stage */
; 4017 : 
; 4018 :     /* compression stage */
; 4019 : #ifdef ZSTD_MULTITHREAD
; 4020 :     if (cctx->appliedParams.nbWorkers > 0) {

	cmp	DWORD PTR [rbx+236], 0
	jle	$LN19@ZSTD_compr

; 4021 :         int const forceMaxProgress = (endOp == ZSTD_e_flush || endOp == ZSTD_e_end);

	lea	eax, DWORD PTR [r15-1]
	mov	r12, rsi
	cmp	eax, 1
	setbe	r12b

; 4022 :         size_t flushMin;
; 4023 :         assert(forceMaxProgress || endOp == ZSTD_e_continue /* Protection for a new flush type */);
; 4024 :         if (cctx->cParamsChanged) {

	cmp	DWORD PTR [rbx+4], 0
	je	SHORT $LL13@ZSTD_compr

; 4025 :             ZSTDMT_updateCParams_whileCompressing(cctx->mtctx, &cctx->requestedParams);

	mov	rsi, QWORD PTR [rbx+1152]
	lea	rdx, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1100 :     mtctx->params.compressionLevel = compressionLevel;

	mov	eax, DWORD PTR [rdx+44]

; 1101 :     {   ZSTD_compressionParameters cParams = ZSTD_getCParamsFromCCtxParams(cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, 0);

	lea	rcx, QWORD PTR $T8[rbp-256]
	xor	r9d, r9d
	mov	edi, DWORD PTR [rsi+44]
	mov	DWORD PTR [rsi+84], eax
	lea	r8, QWORD PTR [r9-1]
	call	ZSTD_getCParamsFromCCtxParams
	movups	xmm3, XMMWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+24]
	movsd	xmm1, QWORD PTR [rax+16]
	movups	XMMWORD PTR cParams$4[rbp-256], xmm3

; 1102 :         cParams.windowLog = saved_wlog;

	mov	DWORD PTR cParams$4[rbp-256], edi

; 1103 :         mtctx->params.cParams = cParams;

	movups	xmm0, XMMWORD PTR cParams$4[rbp-256]
	movups	XMMWORD PTR [rsi+44], xmm0
	movsd	QWORD PTR [rsi+60], xmm1
	mov	DWORD PTR [rsi+68], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4026 :             cctx->cParamsChanged = 0;

	xor	esi, esi
	mov	DWORD PTR [rbx+4], esi
	npad	14
$LL13@ZSTD_compr:

; 4027 :         }
; 4028 :         do {
; 4029 :             flushMin = ZSTDMT_compressStream_generic(cctx->mtctx, output, input, endOp);

	mov	rcx, QWORD PTR [rbx+1152]
	mov	r9d, r15d
	mov	r8, r13
	mov	rdx, r14
	call	ZSTDMT_compressStream_generic
	mov	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4031 :               || (endOp == ZSTD_e_end && flushMin == 0) ) { /* compression completed */

	ja	SHORT $LN41@ZSTD_compr
	cmp	r15d, 2
	jne	SHORT $LN105@ZSTD_compr
	test	rax, rax
	jne	SHORT $LN105@ZSTD_compr
$LN41@ZSTD_compr:

; 966  :         cctx->streamStage = zcss_init;

	mov	DWORD PTR [rbx+1072], esi

; 967  :         cctx->pledgedSrcSizePlusOne = 0;

	mov	QWORD PTR [rbx+384], rsi
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rcx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4034 :             FORWARD_IF_ERROR(flushMin, "ZSTDMT_compressStream_generic failed");

	ja	SHORT $LN44@ZSTD_compr
$LN105@ZSTD_compr:

; 4035 :         } while (forceMaxProgress && flushMin != 0 && output->pos < output->size);

	test	r12, r12
	je	SHORT $LN44@ZSTD_compr
	test	rcx, rcx
	je	SHORT $LN44@ZSTD_compr
	mov	rax, QWORD PTR [r14+8]
	cmp	QWORD PTR [r14+16], rax
	jb	SHORT $LL13@ZSTD_compr
$LN44@ZSTD_compr:

; 4036 :         DEBUGLOG(5, "completed ZSTD_compressStream2 delegating to ZSTDMT_compressStream_generic");
; 4037 :         /* Either we don't require maximum forward progress, we've finished the
; 4038 :          * flush, or we are out of output space.
; 4039 :          */
; 4040 :         assert(!forceMaxProgress || flushMin == 0 || output->pos == output->size);
; 4041 :         return flushMin;

	mov	rax, rcx
$LN117@ZSTD_compr:
	movaps	xmm9, XMMWORD PTR [rsp+624]
	movaps	xmm8, XMMWORD PTR [rsp+640]
	movaps	xmm7, XMMWORD PTR [rsp+656]
	movaps	xmm6, XMMWORD PTR [rsp+672]
	mov	r12, QWORD PTR [rsp+752]
	mov	rdi, QWORD PTR [rsp+744]
	mov	rsi, QWORD PTR [rsp+736]
	movaps	xmm10, XMMWORD PTR [rsp+608]

; 4047 : }

	add	rsp, 688				; 000002b0H
	pop	r15
	pop	r14
	pop	r13
	pop	rbx
	pop	rbp
	ret	0
$LN28@ZSTD_compr:

; 3990 :         }
; 3991 :         if (params.nbWorkers > 0) {

	movdqa	xmm0, xmm4
	psrldq	xmm0, 12
	movd	edi, xmm0
	test	edi, edi
	jle	$LN10@ZSTD_compr

; 3992 :             /* mt context creation */
; 3993 :             if (cctx->mtctx == NULL) {

	mov	rcx, QWORD PTR [rbx+1152]
	test	rcx, rcx
	jne	SHORT $LN7@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 931  :     return ZSTDMT_createCCtx_advanced_internal(nbWorkers, cMem);

	movups	xmm0, XMMWORD PTR [rbx+496]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	ecx, edi
	movsd	xmm1, QWORD PTR [rbx+512]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rbp-240], xmm1
	call	ZSTDMT_createCCtx_advanced_internal
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3996 :                 cctx->mtctx = ZSTDMT_createCCtx_advanced((U32)params.nbWorkers, cctx->customMem);

	mov	QWORD PTR [rbx+1152], rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 931  :     return ZSTDMT_createCCtx_advanced_internal(nbWorkers, cMem);

	mov	rcx, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3997 :                 RETURN_ERROR_IF(cctx->mtctx == NULL, memory_allocation, "NULL pointer!");

	test	rax, rax
	jne	SHORT $LN101@ZSTD_compr
$LN106@ZSTD_compr:
	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN117@ZSTD_compr
$LN101@ZSTD_compr:

; 3980 :         assert(prefixDict.dict==NULL || cctx->cdict==NULL);    /* only one can be set */
; 3981 :         DEBUGLOG(4, "ZSTD_compressStream2 : transparent init stage");
; 3982 :         if (endOp == ZSTD_e_end) cctx->pledgedSrcSizePlusOne = input->size + 1;  /* auto-fix pledgedSrcSize */

	mov	rax, QWORD PTR [rbx+384]
	movups	xmm4, XMMWORD PTR params$4$[rbp-256]
$LN7@ZSTD_compr:

; 4001 :             FORWARD_IF_ERROR( ZSTDMT_initCStream_internal(

	movaps	xmm0, XMMWORD PTR params$12[rbp-256]
	dec	rax
	movaps	xmm1, XMMWORD PTR params$12[rbp-240]
	mov	r9d, DWORD PTR prefixDict$1[rsp+16]
	mov	r8, QWORD PTR prefixDict$1[rsp+8]
	mov	rdx, QWORD PTR prefixDict$1[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T7[rbp-256]
	movaps	XMMWORD PTR $T7[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR params$2$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR [rbx+1120]
	movaps	XMMWORD PTR $T7[rbp-240], xmm1
	movups	xmm1, XMMWORD PTR params$3$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T7[rbp-224], xmm0
	movups	xmm0, XMMWORD PTR params$5$[rbp-256]
	movaps	XMMWORD PTR $T7[rbp-208], xmm1
	movups	xmm1, XMMWORD PTR params$6$[rbp-256]
	movaps	XMMWORD PTR $T7[rbp-176], xmm0
	movups	xmm0, XMMWORD PTR params$7$[rbp-256]
	movaps	XMMWORD PTR $T7[rbp-160], xmm1
	movups	xmm1, XMMWORD PTR params$8$[rbp-256]
	movaps	XMMWORD PTR $T7[rbp-144], xmm0
	movaps	XMMWORD PTR $T7[rbp-128], xmm1
	movaps	XMMWORD PTR $T7[rbp-192], xmm4
	call	ZSTDMT_initCStream_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4001 :             FORWARD_IF_ERROR( ZSTDMT_initCStream_internal(

	ja	$LN117@ZSTD_compr

; 4002 :                         cctx->mtctx,
; 4003 :                         prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType,
; 4004 :                         cctx->cdict, params, cctx->pledgedSrcSizePlusOne-1) , "");
; 4005 :             cctx->streamStage = zcss_load;

	mov	DWORD PTR [rbx+1072], 1

; 4006 :             cctx->appliedParams.nbWorkers = params.nbWorkers;

	mov	DWORD PTR [rbx+236], edi

; 4007 :         } else

	jmp	$LN9@ZSTD_compr
$LN19@ZSTD_compr:

; 4044 :     FORWARD_IF_ERROR( ZSTD_compressStream_generic(cctx, output, input, endOp) , "");

	mov	r9d, r15d
	mov	r8, r13
	mov	rdx, r14
	mov	rcx, rbx
	call	ZSTD_compressStream_generic
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 4044 :     FORWARD_IF_ERROR( ZSTD_compressStream_generic(cctx, output, input, endOp) , "");

	ja	$LN117@ZSTD_compr

; 4045 :     DEBUGLOG(5, "completed ZSTD_compressStream2");
; 4046 :     return cctx->outBuffContentSize - cctx->outBuffFlushedSize; /* remaining to flush */

	mov	rax, QWORD PTR [rbx+1056]
	sub	rax, QWORD PTR [rbx+1064]
	jmp	$LN117@ZSTD_compr
$LN107@ZSTD_compr:

; 3971 :     RETURN_ERROR_IF(input->pos  > input->size, GENERIC, "invalid buffer");

	mov	rax, -1

; 4047 : }

	add	rsp, 688				; 000002b0H
	pop	r15
	pop	r14
	pop	r13
	pop	rbx
	pop	rbp
	ret	0
ZSTD_compressStream2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ZSTD_maxCLevel PROC

; 4116 : int ZSTD_maxCLevel(void) { return ZSTD_MAX_CLEVEL; }

	mov	eax, 22
	ret	0
ZSTD_maxCLevel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
ZSTD_minCLevel PROC

; 4117 : int ZSTD_minCLevel(void) { return (int)-ZSTD_TARGETLENGTH_MAX; }

	mov	eax, -131072				; fffffffffffe0000H
	ret	0
ZSTD_minCLevel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 0
cp$2 = 32
$T3 = 80
compressionLevel$ = 88
srcSizeHint$ = 96
dictSize$ = 104
ZSTD_getCParams_internal PROC

; 4231 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 4232 :     int const unknown = srcSizeHint == ZSTD_CONTENTSIZE_UNKNOWN;
; 4233 :     size_t const addedSize = unknown && dictSize > 0 ? 500 : 0;

	xor	r10d, r10d
	mov	ebx, edx
	mov	rdi, rcx
	cmp	r8, -1
	jne	$LN7@ZSTD_getCP
	test	r9, r9
	je	$LN7@ZSTD_getCP
	mov	eax, 500				; 000001f4H
$LN9@ZSTD_getCP:

; 4234 :     U64 const rSize = unknown && dictSize == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : srcSizeHint+dictSize+addedSize;

	lea	r11, QWORD PTR [rax+r8]
	add	r11, r9
$LN10@ZSTD_getCP:

; 4235 :     U32 const tableID = (rSize <= 256 KB) + (rSize <= 128 KB) + (rSize <= 16 KB);
; 4236 :     int row = compressionLevel;
; 4237 :     DEBUGLOG(5, "ZSTD_getCParams_internal (cLevel=%i)", compressionLevel);
; 4238 :     if (compressionLevel == 0) row = ZSTD_CLEVEL_DEFAULT;   /* 0 == default */
; 4239 :     if (compressionLevel < 0) row = 0;   /* entry 0 is baseline for fast mode */

	test	ebx, ebx

; 4240 :     if (compressionLevel > ZSTD_MAX_CLEVEL) row = ZSTD_MAX_CLEVEL;
; 4241 :     {   ZSTD_compressionParameters cp = ZSTD_defaultCParameters[tableID][row];

	mov	esi, 23
	mov	eax, 3
	mov	edx, r10d
	cmovne	eax, ebx
	mov	rcx, r10
	cmovns	edx, eax
	mov	eax, 22
	cmp	ebx, eax
	cmovg	edx, eax
	cmp	r11, 16384				; 00004000H
	mov	rax, r10
	cmovbe	rcx, rsi
	cmp	r11, 262144				; 00040000H
	cmovbe	rax, rsi
	add	rcx, rax
	mov	rax, r10
	cmp	r11, 131072				; 00020000H
	cmovbe	rax, rsi
	add	rcx, rax
	movsxd	rax, edx
	add	rcx, rax
	imul	rax, rcx, 28
	lea	rcx, OFFSET FLAT:ZSTD_defaultCParameters
	movsd	xmm0, QWORD PTR [rax+rcx+16]
	mov	r11d, DWORD PTR [rax+rcx+24]
	movsd	QWORD PTR cp$2[rsp+16], xmm0
	movups	xmm1, XMMWORD PTR [rax+rcx]
	movups	XMMWORD PTR cp$2[rsp], xmm1

; 4242 :         if (compressionLevel < 0) cp.targetLength = (unsigned)(-compressionLevel);   /* acceleration factor */

	test	ebx, ebx
	jns	SHORT $LN5@ZSTD_getCP
	neg	ebx
	mov	DWORD PTR cp$2[rsp+20], ebx
	movsd	xmm0, QWORD PTR cp$2[rsp+16]
$LN5@ZSTD_getCP:

; 4243 :         /* refine parameters based on srcSize & dictSize */
; 4244 :         return ZSTD_adjustCParams_internal(cp, srcSizeHint, dictSize);

	movaps	XMMWORD PTR $T1[rsp], xmm1
	movaps	xmm1, xmm0

; 1040 :     if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)

	test	r9, r9
	je	SHORT $LN12@ZSTD_getCP
	cmp	r8, -1
	jne	SHORT $LN12@ZSTD_getCP

; 1041 :         srcSize = minSrcSize;

	mov	r8d, 513				; 00000201H

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	jmp	SHORT $LN26@ZSTD_getCP
$LN7@ZSTD_getCP:

; 4232 :     int const unknown = srcSizeHint == ZSTD_CONTENTSIZE_UNKNOWN;
; 4233 :     size_t const addedSize = unknown && dictSize > 0 ? 500 : 0;

	mov	rax, r10

; 4234 :     U64 const rSize = unknown && dictSize == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : srcSizeHint+dictSize+addedSize;

	cmp	r8, -1
	jne	$LN9@ZSTD_getCP
	test	r9, r9
	jne	$LN9@ZSTD_getCP
	mov	r11, r8
	jmp	$LN10@ZSTD_getCP
$LN12@ZSTD_getCP:

; 1045 :       && (dictSize < maxWindowResize) )  {

	cmp	r8, 1073741824				; 40000000H
	jae	SHORT $LN27@ZSTD_getCP
$LN26@ZSTD_getCP:
	cmp	r9, 1073741824				; 40000000H
	jae	SHORT $LN27@ZSTD_getCP

; 1046 :         U32 const tSize = (U32)(srcSize + dictSize);

	lea	eax, DWORD PTR [r9+r8]

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	cmp	eax, 64					; 00000040H
	jae	SHORT $LN19@ZSTD_getCP

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	mov	edx, DWORD PTR $T1[rsp]
	mov	eax, 6
	cmp	DWORD PTR cp$2[rsp], eax
	cmova	edx, eax
	jmp	SHORT $LN14@ZSTD_getCP
$LN19@ZSTD_getCP:
	mov	edx, DWORD PTR $T1[rsp]
	dec	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1048 :         U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :

	inc	eax

; 1049 :                             ZSTD_highbit32(tSize-1) + 1;
; 1050 :         if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;

	cmp	DWORD PTR cp$2[rsp], eax
	cmova	edx, eax
	jmp	SHORT $LN14@ZSTD_getCP
$LN27@ZSTD_getCP:

; 1042 : 
; 1043 :     /* resize windowLog if input is small enough, to use less memory */
; 1044 :     if ( (srcSize < maxWindowResize)
; 1045 :       && (dictSize < maxWindowResize) )  {

	mov	edx, DWORD PTR $T1[rsp]
$LN14@ZSTD_getCP:

; 1051 :     }
; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	eax, DWORD PTR $T1[rsp+8]
	lea	ecx, DWORD PTR [rdx+1]
	cmp	eax, ecx
	cmova	eax, ecx

; 1022 :     return hashLog - btScale;

	mov	ecx, DWORD PTR $T1[rsp+4]
	cmp	r11d, 6

; 1052 :     if (cPar.hashLog > cPar.windowLog+1) cPar.hashLog = cPar.windowLog+1;

	mov	DWORD PTR $T1[rsp+8], eax

; 1022 :     return hashLog - btScale;

	mov	r8d, ecx
	setae	r10b
	sub	r8d, r10d

; 1054 :         if (cycleLog > cPar.windowLog)

	cmp	r8d, edx
	jbe	SHORT $LN16@ZSTD_getCP

; 1055 :             cPar.chainLog -= (cycleLog - cPar.windowLog);

	mov	eax, edx
	sub	eax, r8d
	add	ecx, eax
	mov	DWORD PTR $T1[rsp+4], ecx
$LN16@ZSTD_getCP:

; 4245 :     }
; 4246 : }

	mov	rbx, QWORD PTR [rsp+80]

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	eax, 10

; 4245 :     }
; 4246 : }

	mov	rsi, QWORD PTR [rsp+96]

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	cmp	edx, eax
	cmovb	edx, eax

; 4243 :         /* refine parameters based on srcSize & dictSize */
; 4244 :         return ZSTD_adjustCParams_internal(cp, srcSizeHint, dictSize);

	mov	rax, rdi

; 1058 :     if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)

	mov	DWORD PTR $T1[rsp], edx

; 4243 :         /* refine parameters based on srcSize & dictSize */
; 4244 :         return ZSTD_adjustCParams_internal(cp, srcSizeHint, dictSize);

	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movups	XMMWORD PTR [rdi], xmm0
	movsd	QWORD PTR [rdi+16], xmm1
	mov	DWORD PTR [rdi+24], r11d

; 4245 :     }
; 4246 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTD_getCParams_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 80
compressionLevel$ = 88
srcSizeHint$ = 96
dictSize$ = 104
ZSTD_getCParams PROC

; 4252 : {

$LN5:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, r8
	mov	rbx, rcx

; 4253 :     if (srcSizeHint == 0) srcSizeHint = ZSTD_CONTENTSIZE_UNKNOWN;
; 4254 :     return ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize);

	test	rax, rax
	lea	rcx, QWORD PTR $T1[rsp]
	mov	r8, -1
	cmovne	r8, rax
	call	ZSTD_getCParams_internal
	movups	xmm0, XMMWORD PTR [rax]
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR [rbx], xmm0
	movsd	QWORD PTR [rbx+16], xmm1
	mov	DWORD PTR [rbx+24], eax
	mov	rax, rbx

; 4255 : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_getCParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 80
compressionLevel$ = 88
srcSizeHint$ = 96
dictSize$ = 104
ZSTD_getParams_internal PROC

; 4261 : static ZSTD_parameters ZSTD_getParams_internal(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize) {

	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx

; 4262 :     ZSTD_parameters params;
; 4263 :     ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize);

	lea	rcx, QWORD PTR $T1[rsp]
	call	ZSTD_getCParams_internal

; 4264 :     DEBUGLOG(5, "ZSTD_getParams (cLevel=%i)", compressionLevel);
; 4265 :     memset(&params, 0, sizeof(params));

	mov	QWORD PTR [rbx+32], 0

; 4266 :     params.cParams = cParams;
; 4267 :     params.fParams.contentSizeFlag = 1;

	mov	DWORD PTR [rbx+28], 1
	movups	xmm0, XMMWORD PTR [rax]
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]
	movups	XMMWORD PTR [rbx], xmm0
	movsd	QWORD PTR [rbx+16], xmm1
	mov	DWORD PTR [rbx+24], eax

; 4268 :     return params;

	mov	rax, rbx

; 4269 : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTD_getParams_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 128
compressionLevel$ = 136
srcSizeHint$ = 144
dictSize$ = 152
ZSTD_getParams PROC

; 4275 : ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize) {

$LN7:
	push	rbx
	sub	rsp, 112				; 00000070H
	mov	rax, r8
	mov	rbx, rcx

; 4263 :     ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize);

	test	rax, rax
	lea	rcx, QWORD PTR $T1[rsp]
	mov	r8, -1
	cmovne	r8, rax
	call	ZSTD_getCParams_internal

; 4267 :     params.fParams.contentSizeFlag = 1;

	mov	DWORD PTR $T2[rsp+28], 1
	mov	QWORD PTR $T2[rsp+32], 0
	movups	xmm0, XMMWORD PTR [rax]
	movsd	xmm1, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rax+24]

; 4276 :     if (srcSizeHint == 0) srcSizeHint = ZSTD_CONTENTSIZE_UNKNOWN;
; 4277 :     return ZSTD_getParams_internal(compressionLevel, srcSizeHint, dictSize);

	movups	XMMWORD PTR [rbx], xmm0

; 4266 :     params.cParams = cParams;

	mov	DWORD PTR $T2[rsp+24], eax

; 4276 :     if (srcSizeHint == 0) srcSizeHint = ZSTD_CONTENTSIZE_UNKNOWN;
; 4277 :     return ZSTD_getParams_internal(compressionLevel, srcSizeHint, dictSize);

	mov	rax, rbx
	movups	xmm0, XMMWORD PTR $T2[rsp+16]
	movsd	xmm0, xmm1
	movups	XMMWORD PTR [rbx+16], xmm0
	movsd	xmm0, QWORD PTR $T2[rsp+32]
	movsd	QWORD PTR [rbx+32], xmm0

; 4278 : }

	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
ZSTD_getParams ENDP
_TEXT	ENDS
END
