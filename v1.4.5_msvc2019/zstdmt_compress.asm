; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

kNullRawSeqStore DB 020H DUP (?)
_BSS	ENDS
prime8bytes DQ	cf1bbcdcb7a56463H
kNullRange DQ	0000000000000000H
	DQ	0000000000000000H
g_nullBuffer DQ	0000000000000000H
	DQ	0000000000000000H
kNullRoundBuff DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
PUBLIC	ZSTDMT_CCtxParam_setNbWorkers
PUBLIC	ZSTDMT_freeCCtx
PUBLIC	ZSTDMT_updateCParams_whileCompressing
PUBLIC	ZSTDMT_compressStream_generic
PUBLIC	ZSTDMT_initCStream_internal
PUBLIC	ZSTDMT_createCCtx_advanced
	ALIGN	4

$SG4294965451 DB 01H DUP (?)
	ALIGN	4

$SG4294965452 DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$findSynchronizationPoint DD imagerel findSynchronizationPoint
	DD	imagerel findSynchronizationPoint+111
	DD	imagerel $unwind$findSynchronizationPoint
$pdata$1$findSynchronizationPoint DD imagerel findSynchronizationPoint+111
	DD	imagerel findSynchronizationPoint+151
	DD	imagerel $chain$1$findSynchronizationPoint
$pdata$2$findSynchronizationPoint DD imagerel findSynchronizationPoint+151
	DD	imagerel findSynchronizationPoint+288
	DD	imagerel $chain$2$findSynchronizationPoint
$pdata$3$findSynchronizationPoint DD imagerel findSynchronizationPoint+288
	DD	imagerel findSynchronizationPoint+388
	DD	imagerel $chain$3$findSynchronizationPoint
$pdata$4$findSynchronizationPoint DD imagerel findSynchronizationPoint+388
	DD	imagerel findSynchronizationPoint+472
	DD	imagerel $chain$4$findSynchronizationPoint
$pdata$5$findSynchronizationPoint DD imagerel findSynchronizationPoint+472
	DD	imagerel findSynchronizationPoint+487
	DD	imagerel $chain$5$findSynchronizationPoint
$pdata$ZSTDMT_tryGetInputRange DD imagerel ZSTDMT_tryGetInputRange
	DD	imagerel ZSTDMT_tryGetInputRange+503
	DD	imagerel $unwind$ZSTDMT_tryGetInputRange
$pdata$ZSTDMT_waitForLdmComplete DD imagerel ZSTDMT_waitForLdmComplete
	DD	imagerel ZSTDMT_waitForLdmComplete+36
	DD	imagerel $unwind$ZSTDMT_waitForLdmComplete
$pdata$0$ZSTDMT_waitForLdmComplete DD imagerel ZSTDMT_waitForLdmComplete+36
	DD	imagerel ZSTDMT_waitForLdmComplete+306
	DD	imagerel $chain$0$ZSTDMT_waitForLdmComplete
$pdata$1$ZSTDMT_waitForLdmComplete DD imagerel ZSTDMT_waitForLdmComplete+306
	DD	imagerel ZSTDMT_waitForLdmComplete+317
	DD	imagerel $chain$1$ZSTDMT_waitForLdmComplete
$pdata$ZSTDMT_doesOverlapWindow DD imagerel ZSTDMT_doesOverlapWindow
	DD	imagerel ZSTDMT_doesOverlapWindow+209
	DD	imagerel $unwind$ZSTDMT_doesOverlapWindow
$pdata$ZSTDMT_getInputDataInUse DD imagerel ZSTDMT_getInputDataInUse
	DD	imagerel ZSTDMT_getInputDataInUse+237
	DD	imagerel $unwind$ZSTDMT_getInputDataInUse
$pdata$ZSTDMT_flushProduced DD imagerel ZSTDMT_flushProduced
	DD	imagerel ZSTDMT_flushProduced+251
	DD	imagerel $unwind$ZSTDMT_flushProduced
$pdata$1$ZSTDMT_flushProduced DD imagerel ZSTDMT_flushProduced+251
	DD	imagerel ZSTDMT_flushProduced+547
	DD	imagerel $chain$1$ZSTDMT_flushProduced
$pdata$2$ZSTDMT_flushProduced DD imagerel ZSTDMT_flushProduced+547
	DD	imagerel ZSTDMT_flushProduced+648
	DD	imagerel $chain$2$ZSTDMT_flushProduced
$pdata$ZSTDMT_createCompressionJob DD imagerel ZSTDMT_createCompressionJob
	DD	imagerel ZSTDMT_createCompressionJob+78
	DD	imagerel $unwind$ZSTDMT_createCompressionJob
$pdata$0$ZSTDMT_createCompressionJob DD imagerel ZSTDMT_createCompressionJob+78
	DD	imagerel ZSTDMT_createCompressionJob+824
	DD	imagerel $chain$0$ZSTDMT_createCompressionJob
$pdata$1$ZSTDMT_createCompressionJob DD imagerel ZSTDMT_createCompressionJob+824
	DD	imagerel ZSTDMT_createCompressionJob+845
	DD	imagerel $chain$1$ZSTDMT_createCompressionJob
$pdata$2$ZSTDMT_createCompressionJob DD imagerel ZSTDMT_createCompressionJob+845
	DD	imagerel ZSTDMT_createCompressionJob+949
	DD	imagerel $chain$2$ZSTDMT_createCompressionJob
$pdata$ZSTDMT_writeLastEmptyBlock DD imagerel ZSTDMT_writeLastEmptyBlock
	DD	imagerel ZSTDMT_writeLastEmptyBlock+118
	DD	imagerel $unwind$ZSTDMT_writeLastEmptyBlock
$pdata$ZSTDMT_compress_advanced_internal DD imagerel ZSTDMT_compress_advanced_internal
	DD	imagerel ZSTDMT_compress_advanced_internal+2158
	DD	imagerel $unwind$ZSTDMT_compress_advanced_internal
$pdata$ZSTDMT_resize DD imagerel ZSTDMT_resize
	DD	imagerel ZSTDMT_resize+244
	DD	imagerel $unwind$ZSTDMT_resize
$pdata$ZSTDMT_waitForAllJobsCompleted DD imagerel ZSTDMT_waitForAllJobsCompleted
	DD	imagerel ZSTDMT_waitForAllJobsCompleted+27
	DD	imagerel $unwind$ZSTDMT_waitForAllJobsCompleted
$pdata$1$ZSTDMT_waitForAllJobsCompleted DD imagerel ZSTDMT_waitForAllJobsCompleted+27
	DD	imagerel ZSTDMT_waitForAllJobsCompleted+209
	DD	imagerel $chain$1$ZSTDMT_waitForAllJobsCompleted
$pdata$2$ZSTDMT_waitForAllJobsCompleted DD imagerel ZSTDMT_waitForAllJobsCompleted+209
	DD	imagerel ZSTDMT_waitForAllJobsCompleted+215
	DD	imagerel $chain$2$ZSTDMT_waitForAllJobsCompleted
$pdata$ZSTDMT_releaseAllJobResources DD imagerel ZSTDMT_releaseAllJobResources
	DD	imagerel ZSTDMT_releaseAllJobResources+366
	DD	imagerel $unwind$ZSTDMT_releaseAllJobResources
$pdata$ZSTDMT_createCCtx_advanced_internal DD imagerel ZSTDMT_createCCtx_advanced_internal
	DD	imagerel ZSTDMT_createCCtx_advanced_internal+200
	DD	imagerel $unwind$ZSTDMT_createCCtx_advanced_internal
$pdata$1$ZSTDMT_createCCtx_advanced_internal DD imagerel ZSTDMT_createCCtx_advanced_internal+200
	DD	imagerel ZSTDMT_createCCtx_advanced_internal+566
	DD	imagerel $chain$1$ZSTDMT_createCCtx_advanced_internal
$pdata$2$ZSTDMT_createCCtx_advanced_internal DD imagerel ZSTDMT_createCCtx_advanced_internal+566
	DD	imagerel ZSTDMT_createCCtx_advanced_internal+793
	DD	imagerel $chain$2$ZSTDMT_createCCtx_advanced_internal
$pdata$ZSTDMT_CCtxParam_setNbWorkers DD imagerel $LN553
	DD	imagerel $LN553+52
	DD	imagerel $unwind$ZSTDMT_CCtxParam_setNbWorkers
$pdata$ZSTDMT_expandJobsTable DD imagerel ZSTDMT_expandJobsTable
	DD	imagerel ZSTDMT_expandJobsTable+355
	DD	imagerel $unwind$ZSTDMT_expandJobsTable
$pdata$ZSTDMT_createJobsTable DD imagerel ZSTDMT_createJobsTable
	DD	imagerel ZSTDMT_createJobsTable+183
	DD	imagerel $unwind$ZSTDMT_createJobsTable
$pdata$ZSTDMT_freeJobsTable DD imagerel ZSTDMT_freeJobsTable
	DD	imagerel ZSTDMT_freeJobsTable+29
	DD	imagerel $unwind$ZSTDMT_freeJobsTable
$pdata$1$ZSTDMT_freeJobsTable DD imagerel ZSTDMT_freeJobsTable+29
	DD	imagerel ZSTDMT_freeJobsTable+80
	DD	imagerel $chain$1$ZSTDMT_freeJobsTable
$pdata$2$ZSTDMT_freeJobsTable DD imagerel ZSTDMT_freeJobsTable+80
	DD	imagerel ZSTDMT_freeJobsTable+151
	DD	imagerel $chain$2$ZSTDMT_freeJobsTable
$pdata$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob
	DD	imagerel ZSTDMT_compressionJob+45
	DD	imagerel $unwind$ZSTDMT_compressionJob
$pdata$0$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+45
	DD	imagerel ZSTDMT_compressionJob+129
	DD	imagerel $chain$0$ZSTDMT_compressionJob
$pdata$2$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+129
	DD	imagerel ZSTDMT_compressionJob+480
	DD	imagerel $chain$2$ZSTDMT_compressionJob
$pdata$3$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+480
	DD	imagerel ZSTDMT_compressionJob+841
	DD	imagerel $chain$3$ZSTDMT_compressionJob
$pdata$4$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+841
	DD	imagerel ZSTDMT_compressionJob+1682
	DD	imagerel $chain$4$ZSTDMT_compressionJob
$pdata$5$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+1682
	DD	imagerel ZSTDMT_compressionJob+1690
	DD	imagerel $chain$5$ZSTDMT_compressionJob
$pdata$6$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+1690
	DD	imagerel ZSTDMT_compressionJob+1733
	DD	imagerel $chain$6$ZSTDMT_compressionJob
$pdata$7$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+1733
	DD	imagerel ZSTDMT_compressionJob+1892
	DD	imagerel $chain$7$ZSTDMT_compressionJob
$pdata$8$ZSTDMT_compressionJob DD imagerel ZSTDMT_compressionJob+1892
	DD	imagerel ZSTDMT_compressionJob+1996
	DD	imagerel $chain$8$ZSTDMT_compressionJob
$pdata$ZSTDMT_serialState_ensureFinished DD imagerel ZSTDMT_serialState_ensureFinished
	DD	imagerel ZSTDMT_serialState_ensureFinished+131
	DD	imagerel $unwind$ZSTDMT_serialState_ensureFinished
$pdata$ZSTDMT_serialState_update DD imagerel ZSTDMT_serialState_update
	DD	imagerel ZSTDMT_serialState_update+8
	DD	imagerel $unwind$ZSTDMT_serialState_update
$pdata$3$ZSTDMT_serialState_update DD imagerel ZSTDMT_serialState_update+8
	DD	imagerel ZSTDMT_serialState_update+126
	DD	imagerel $chain$3$ZSTDMT_serialState_update
$pdata$4$ZSTDMT_serialState_update DD imagerel ZSTDMT_serialState_update+126
	DD	imagerel ZSTDMT_serialState_update+242
	DD	imagerel $chain$4$ZSTDMT_serialState_update
$pdata$5$ZSTDMT_serialState_update DD imagerel ZSTDMT_serialState_update+242
	DD	imagerel ZSTDMT_serialState_update+327
	DD	imagerel $chain$5$ZSTDMT_serialState_update
$pdata$6$ZSTDMT_serialState_update DD imagerel ZSTDMT_serialState_update+327
	DD	imagerel ZSTDMT_serialState_update+386
	DD	imagerel $chain$6$ZSTDMT_serialState_update
$pdata$ZSTDMT_serialState_free DD imagerel ZSTDMT_serialState_free
	DD	imagerel ZSTDMT_serialState_free+156
	DD	imagerel $unwind$ZSTDMT_serialState_free
$pdata$ZSTDMT_serialState_init DD imagerel ZSTDMT_serialState_init
	DD	imagerel ZSTDMT_serialState_init+75
	DD	imagerel $unwind$ZSTDMT_serialState_init
$pdata$ZSTDMT_serialState_reset DD imagerel ZSTDMT_serialState_reset
	DD	imagerel ZSTDMT_serialState_reset+260
	DD	imagerel $unwind$ZSTDMT_serialState_reset
$pdata$1$ZSTDMT_serialState_reset DD imagerel ZSTDMT_serialState_reset+260
	DD	imagerel ZSTDMT_serialState_reset+1069
	DD	imagerel $chain$1$ZSTDMT_serialState_reset
$pdata$ZSTDMT_releaseCCtx DD imagerel ZSTDMT_releaseCCtx
	DD	imagerel ZSTDMT_releaseCCtx+74
	DD	imagerel $unwind$ZSTDMT_releaseCCtx
$pdata$ZSTDMT_getCCtx DD imagerel ZSTDMT_getCCtx
	DD	imagerel ZSTDMT_getCCtx+236
	DD	imagerel $unwind$ZSTDMT_getCCtx
$pdata$ZSTDMT_expandCCtxPool DD imagerel ZSTDMT_expandCCtxPool
	DD	imagerel ZSTDMT_expandCCtxPool+100
	DD	imagerel $unwind$ZSTDMT_expandCCtxPool
$pdata$ZSTDMT_createCCtxPool DD imagerel ZSTDMT_createCCtxPool
	DD	imagerel ZSTDMT_createCCtxPool+207
	DD	imagerel $unwind$ZSTDMT_createCCtxPool
$pdata$ZSTDMT_freeCCtxPool DD imagerel ZSTDMT_freeCCtxPool
	DD	imagerel ZSTDMT_freeCCtxPool+6
	DD	imagerel $unwind$ZSTDMT_freeCCtxPool
$pdata$0$ZSTDMT_freeCCtxPool DD imagerel ZSTDMT_freeCCtxPool+6
	DD	imagerel ZSTDMT_freeCCtxPool+21
	DD	imagerel $chain$0$ZSTDMT_freeCCtxPool
$pdata$1$ZSTDMT_freeCCtxPool DD imagerel ZSTDMT_freeCCtxPool+21
	DD	imagerel ZSTDMT_freeCCtxPool+56
	DD	imagerel $chain$1$ZSTDMT_freeCCtxPool
$pdata$2$ZSTDMT_freeCCtxPool DD imagerel ZSTDMT_freeCCtxPool+56
	DD	imagerel ZSTDMT_freeCCtxPool+100
	DD	imagerel $chain$2$ZSTDMT_freeCCtxPool
$pdata$3$ZSTDMT_freeCCtxPool DD imagerel ZSTDMT_freeCCtxPool+100
	DD	imagerel ZSTDMT_freeCCtxPool+131
	DD	imagerel $chain$3$ZSTDMT_freeCCtxPool
$pdata$ZSTDMT_createSeqPool DD imagerel ZSTDMT_createSeqPool
	DD	imagerel ZSTDMT_createSeqPool+84
	DD	imagerel $unwind$ZSTDMT_createSeqPool
$pdata$ZSTDMT_setNbSeq DD imagerel ZSTDMT_setNbSeq
	DD	imagerel ZSTDMT_setNbSeq+54
	DD	imagerel $unwind$ZSTDMT_setNbSeq
$pdata$ZSTDMT_releaseSeq DD imagerel ZSTDMT_releaseSeq
	DD	imagerel ZSTDMT_releaseSeq+183
	DD	imagerel $unwind$ZSTDMT_releaseSeq
$pdata$ZSTDMT_getSeq DD imagerel ZSTDMT_getSeq
	DD	imagerel ZSTDMT_getSeq+135
	DD	imagerel $unwind$ZSTDMT_getSeq
$pdata$ZSTDMT_releaseBuffer DD imagerel ZSTDMT_releaseBuffer
	DD	imagerel ZSTDMT_releaseBuffer+155
	DD	imagerel $unwind$ZSTDMT_releaseBuffer
$pdata$ZSTDMT_getBuffer DD imagerel ZSTDMT_getBuffer
	DD	imagerel ZSTDMT_getBuffer+299
	DD	imagerel $unwind$ZSTDMT_getBuffer
$pdata$ZSTDMT_expandBufferPool DD imagerel ZSTDMT_expandBufferPool
	DD	imagerel ZSTDMT_expandBufferPool+167
	DD	imagerel $unwind$ZSTDMT_expandBufferPool
$pdata$ZSTDMT_setBufferSize DD imagerel ZSTDMT_setBufferSize
	DD	imagerel ZSTDMT_setBufferSize+46
	DD	imagerel $unwind$ZSTDMT_setBufferSize
$pdata$ZSTDMT_freeBufferPool DD imagerel ZSTDMT_freeBufferPool
	DD	imagerel ZSTDMT_freeBufferPool+14
	DD	imagerel $unwind$ZSTDMT_freeBufferPool
$pdata$0$ZSTDMT_freeBufferPool DD imagerel ZSTDMT_freeBufferPool+14
	DD	imagerel ZSTDMT_freeBufferPool+149
	DD	imagerel $chain$0$ZSTDMT_freeBufferPool
$pdata$1$ZSTDMT_freeBufferPool DD imagerel ZSTDMT_freeBufferPool+149
	DD	imagerel ZSTDMT_freeBufferPool+180
	DD	imagerel $chain$1$ZSTDMT_freeBufferPool
$pdata$ZSTDMT_createBufferPool DD imagerel ZSTDMT_createBufferPool
	DD	imagerel ZSTDMT_createBufferPool+179
	DD	imagerel $unwind$ZSTDMT_createBufferPool
$pdata$ZSTD_window_update DD imagerel ZSTD_window_update
	DD	imagerel ZSTD_window_update+29
	DD	imagerel $unwind$ZSTD_window_update
$pdata$0$ZSTD_window_update DD imagerel ZSTD_window_update+29
	DD	imagerel ZSTD_window_update+34
	DD	imagerel $chain$0$ZSTD_window_update
$pdata$1$ZSTD_window_update DD imagerel ZSTD_window_update+34
	DD	imagerel ZSTD_window_update+154
	DD	imagerel $chain$1$ZSTD_window_update
$pdata$2$ZSTD_window_update DD imagerel ZSTD_window_update+154
	DD	imagerel ZSTD_window_update+176
	DD	imagerel $chain$2$ZSTD_window_update
$pdata$3$ZSTD_window_update DD imagerel ZSTD_window_update+176
	DD	imagerel ZSTD_window_update+181
	DD	imagerel $chain$3$ZSTD_window_update
$pdata$ZSTDMT_freeCCtx DD imagerel $LN46
	DD	imagerel $LN46+21
	DD	imagerel $unwind$ZSTDMT_freeCCtx
$pdata$0$ZSTDMT_freeCCtx DD imagerel $LN46+21
	DD	imagerel $LN46+26
	DD	imagerel $chain$0$ZSTDMT_freeCCtx
$pdata$2$ZSTDMT_freeCCtx DD imagerel $LN46+26
	DD	imagerel $LN46+296
	DD	imagerel $chain$2$ZSTDMT_freeCCtx
$pdata$3$ZSTDMT_freeCCtx DD imagerel $LN46+296
	DD	imagerel $LN46+351
	DD	imagerel $chain$3$ZSTDMT_freeCCtx
$pdata$4$ZSTDMT_freeCCtx DD imagerel $LN46+351
	DD	imagerel $LN46+476
	DD	imagerel $chain$4$ZSTDMT_freeCCtx
$pdata$ZSTDMT_updateCParams_whileCompressing DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$ZSTDMT_updateCParams_whileCompressing
$pdata$ZSTDMT_compressStream_generic DD imagerel $LN99
	DD	imagerel $LN99+91
	DD	imagerel $unwind$ZSTDMT_compressStream_generic
$pdata$0$ZSTDMT_compressStream_generic DD imagerel $LN99+91
	DD	imagerel $LN99+435
	DD	imagerel $chain$0$ZSTDMT_compressStream_generic
$pdata$1$ZSTDMT_compressStream_generic DD imagerel $LN99+435
	DD	imagerel $LN99+606
	DD	imagerel $chain$1$ZSTDMT_compressStream_generic
$pdata$2$ZSTDMT_compressStream_generic DD imagerel $LN99+606
	DD	imagerel $LN99+736
	DD	imagerel $chain$2$ZSTDMT_compressStream_generic
$pdata$3$ZSTDMT_compressStream_generic DD imagerel $LN99+736
	DD	imagerel $LN99+761
	DD	imagerel $chain$3$ZSTDMT_compressStream_generic
$pdata$ZSTDMT_initCStream_internal DD imagerel $LN700
	DD	imagerel $LN700+1772
	DD	imagerel $unwind$ZSTDMT_initCStream_internal
$pdata$ZSTDMT_createCCtx_advanced DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$ZSTDMT_createCCtx_advanced
xdata	SEGMENT
$unwind$findSynchronizationPoint DD 061001H
	DD	0f00c1210H
	DD	07008c00aH
	DD	030066007H
$chain$1$findSynchronizationPoint DD 041a21H
	DD	0e41aH
	DD	0a5405H
	DD	imagerel findSynchronizationPoint
	DD	imagerel findSynchronizationPoint+111
	DD	imagerel $unwind$findSynchronizationPoint
$chain$2$findSynchronizationPoint DD 020521H
	DD	01d405H
	DD	imagerel findSynchronizationPoint+111
	DD	imagerel findSynchronizationPoint+151
	DD	imagerel $chain$1$findSynchronizationPoint
$chain$3$findSynchronizationPoint DD 021H
	DD	imagerel findSynchronizationPoint+111
	DD	imagerel findSynchronizationPoint+151
	DD	imagerel $chain$1$findSynchronizationPoint
$chain$4$findSynchronizationPoint DD 020021H
	DD	0e400H
	DD	imagerel findSynchronizationPoint
	DD	imagerel findSynchronizationPoint+111
	DD	imagerel $unwind$findSynchronizationPoint
$chain$5$findSynchronizationPoint DD 021H
	DD	imagerel findSynchronizationPoint
	DD	imagerel findSynchronizationPoint+111
	DD	imagerel $unwind$findSynchronizationPoint
$unwind$ZSTDMT_tryGetInputRange DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
$unwind$ZSTDMT_waitForLdmComplete DD 040a01H
	DD	07340aH
	DD	06006320aH
$chain$0$ZSTDMT_waitForLdmComplete DD 020521H
	DD	067405H
	DD	imagerel ZSTDMT_waitForLdmComplete
	DD	imagerel ZSTDMT_waitForLdmComplete+36
	DD	imagerel $unwind$ZSTDMT_waitForLdmComplete
$chain$1$ZSTDMT_waitForLdmComplete DD 021H
	DD	imagerel ZSTDMT_waitForLdmComplete
	DD	imagerel ZSTDMT_waitForLdmComplete+36
	DD	imagerel $unwind$ZSTDMT_waitForLdmComplete
$unwind$ZSTDMT_doesOverlapWindow DD 040a01H
	DD	02740aH
	DD	013405H
$unwind$ZSTDMT_getInputDataInUse DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$ZSTDMT_flushProduced DD 09f901H
	DD	0e54f9H
	DD	0e0136217H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0300bH
$chain$1$ZSTDMT_flushProduced DD 020521H
	DD	06f405H
	DD	imagerel ZSTDMT_flushProduced
	DD	imagerel ZSTDMT_flushProduced+251
	DD	imagerel $unwind$ZSTDMT_flushProduced
$chain$2$ZSTDMT_flushProduced DD 021H
	DD	imagerel ZSTDMT_flushProduced
	DD	imagerel ZSTDMT_flushProduced+251
	DD	imagerel $unwind$ZSTDMT_flushProduced
$unwind$ZSTDMT_createCompressionJob DD 081201H
	DD	0c5412H
	DD	0b3412H
	DD	0e00e5212H
	DD	0600b700cH
$chain$0$ZSTDMT_createCompressionJob DD 020521H
	DD	0af405H
	DD	imagerel ZSTDMT_createCompressionJob
	DD	imagerel ZSTDMT_createCompressionJob+78
	DD	imagerel $unwind$ZSTDMT_createCompressionJob
$chain$1$ZSTDMT_createCompressionJob DD 021H
	DD	imagerel ZSTDMT_createCompressionJob
	DD	imagerel ZSTDMT_createCompressionJob+78
	DD	imagerel $unwind$ZSTDMT_createCompressionJob
$chain$2$ZSTDMT_createCompressionJob DD 020021H
	DD	0af400H
	DD	imagerel ZSTDMT_createCompressionJob
	DD	imagerel ZSTDMT_createCompressionJob+78
	DD	imagerel $unwind$ZSTDMT_createCompressionJob
$unwind$ZSTDMT_writeLastEmptyBlock DD 020601H
	DD	030025206H
$unwind$ZSTDMT_compress_advanced_internal DD 0a1c01H
	DD	047011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
$unwind$ZSTDMT_resize DD 040a01H
	DD	0b340aH
	DD	07006720aH
$unwind$ZSTDMT_waitForAllJobsCompleted DD 020601H
	DD	030023206H
$chain$1$ZSTDMT_waitForAllJobsCompleted DD 040a21H
	DD	07740aH
	DD	066405H
	DD	imagerel ZSTDMT_waitForAllJobsCompleted
	DD	imagerel ZSTDMT_waitForAllJobsCompleted+27
	DD	imagerel $unwind$ZSTDMT_waitForAllJobsCompleted
$chain$2$ZSTDMT_waitForAllJobsCompleted DD 021H
	DD	imagerel ZSTDMT_waitForAllJobsCompleted
	DD	imagerel ZSTDMT_waitForAllJobsCompleted+27
	DD	imagerel $unwind$ZSTDMT_waitForAllJobsCompleted
$unwind$ZSTDMT_releaseAllJobResources DD 0a1801H
	DD	0156418H
	DD	0145418H
	DD	0133418H
	DD	0f014d218H
	DD	07010e012H
$unwind$ZSTDMT_createCCtx_advanced_internal DD 070e01H
	DD	0f00a820eH
	DD	0c006e008H
	DD	060037004H
	DD	03002H
$chain$1$ZSTDMT_createCCtx_advanced_internal DD 040d21H
	DD	08d40dH
	DD	0115408H
	DD	imagerel ZSTDMT_createCCtx_advanced_internal
	DD	imagerel ZSTDMT_createCCtx_advanced_internal+200
	DD	imagerel $unwind$ZSTDMT_createCCtx_advanced_internal
$chain$2$ZSTDMT_createCCtx_advanced_internal DD 021H
	DD	imagerel ZSTDMT_createCCtx_advanced_internal
	DD	imagerel ZSTDMT_createCCtx_advanced_internal+200
	DD	imagerel $unwind$ZSTDMT_createCCtx_advanced_internal
$unwind$ZSTDMT_CCtxParam_setNbWorkers DD 010401H
	DD	02204H
$unwind$ZSTDMT_expandJobsTable DD 081201H
	DD	0e5412H
	DD	0c3412H
	DD	0e00e7212H
	DD	0600b700cH
$unwind$ZSTDMT_createJobsTable DD 081201H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
$unwind$ZSTDMT_freeJobsTable DD 041301H
	DD	0c5413H
	DD	0600f7213H
$chain$1$ZSTDMT_freeJobsTable DD 040e21H
	DD	0b740eH
	DD	0a3405H
	DD	imagerel ZSTDMT_freeJobsTable
	DD	imagerel ZSTDMT_freeJobsTable+29
	DD	imagerel $unwind$ZSTDMT_freeJobsTable
$chain$2$ZSTDMT_freeJobsTable DD 021H
	DD	imagerel ZSTDMT_freeJobsTable
	DD	imagerel ZSTDMT_freeJobsTable+29
	DD	imagerel $unwind$ZSTDMT_freeJobsTable
$unwind$ZSTDMT_compressionJob DD 071801H
	DD	0340118H
	DD	0e008f00aH
	DD	030056006H
	DD	05004H
$chain$0$ZSTDMT_compressionJob DD 020421H
	DD	03c7404H
	DD	imagerel ZSTDMT_compressionJob
	DD	imagerel ZSTDMT_compressionJob+45
	DD	imagerel $unwind$ZSTDMT_compressionJob
$chain$2$ZSTDMT_compressionJob DD 040c21H
	DD	017780cH
	DD	0186804H
	DD	imagerel ZSTDMT_compressionJob+45
	DD	imagerel ZSTDMT_compressionJob+129
	DD	imagerel $chain$0$ZSTDMT_compressionJob
$chain$3$ZSTDMT_compressionJob DD 020821H
	DD	033c408H
	DD	imagerel ZSTDMT_compressionJob+129
	DD	imagerel ZSTDMT_compressionJob+480
	DD	imagerel $chain$2$ZSTDMT_compressionJob
$chain$4$ZSTDMT_compressionJob DD 020821H
	DD	032d408H
	DD	imagerel ZSTDMT_compressionJob+480
	DD	imagerel ZSTDMT_compressionJob+841
	DD	imagerel $chain$3$ZSTDMT_compressionJob
$chain$5$ZSTDMT_compressionJob DD 021H
	DD	imagerel ZSTDMT_compressionJob+480
	DD	imagerel ZSTDMT_compressionJob+841
	DD	imagerel $chain$3$ZSTDMT_compressionJob
$chain$6$ZSTDMT_compressionJob DD 021H
	DD	imagerel ZSTDMT_compressionJob+129
	DD	imagerel ZSTDMT_compressionJob+480
	DD	imagerel $chain$2$ZSTDMT_compressionJob
$chain$7$ZSTDMT_compressionJob DD 021H
	DD	imagerel ZSTDMT_compressionJob+45
	DD	imagerel ZSTDMT_compressionJob+129
	DD	imagerel $chain$0$ZSTDMT_compressionJob
$chain$8$ZSTDMT_compressionJob DD 021H
	DD	imagerel ZSTDMT_compressionJob
	DD	imagerel ZSTDMT_compressionJob+45
	DD	imagerel $unwind$ZSTDMT_compressionJob
$unwind$ZSTDMT_serialState_ensureFinished DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTDMT_serialState_update DD 030801H
	DD	0c0046208H
	DD	05002H
$chain$3$ZSTDMT_serialState_update DD 081d21H
	DD	06f41dH
	DD	0de415H
	DD	0c740dH
	DD	0a3405H
	DD	imagerel ZSTDMT_serialState_update
	DD	imagerel ZSTDMT_serialState_update+8
	DD	imagerel $unwind$ZSTDMT_serialState_update
$chain$4$ZSTDMT_serialState_update DD 020521H
	DD	0b6405H
	DD	imagerel ZSTDMT_serialState_update+8
	DD	imagerel ZSTDMT_serialState_update+126
	DD	imagerel $chain$3$ZSTDMT_serialState_update
$chain$5$ZSTDMT_serialState_update DD 021H
	DD	imagerel ZSTDMT_serialState_update+8
	DD	imagerel ZSTDMT_serialState_update+126
	DD	imagerel $chain$3$ZSTDMT_serialState_update
$chain$6$ZSTDMT_serialState_update DD 021H
	DD	imagerel ZSTDMT_serialState_update
	DD	imagerel ZSTDMT_serialState_update+8
	DD	imagerel $unwind$ZSTDMT_serialState_update
$unwind$ZSTDMT_serialState_free DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$ZSTDMT_serialState_init DD 020601H
	DD	030023206H
$unwind$ZSTDMT_serialState_reset DD 081a01H
	DD	017011aH
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
$chain$1$ZSTDMT_serialState_reset DD 041021H
	DD	016f410H
	DD	01f3408H
	DD	imagerel ZSTDMT_serialState_reset
	DD	imagerel ZSTDMT_serialState_reset+260
	DD	imagerel $unwind$ZSTDMT_serialState_reset
$unwind$ZSTDMT_releaseCCtx DD 040f01H
	DD	06340fH
	DD	0700b320fH
$unwind$ZSTDMT_getCCtx DD 040a01H
	DD	0f340aH
	DD	07006b20aH
$unwind$ZSTDMT_expandCCtxPool DD 020601H
	DD	030027206H
$unwind$ZSTDMT_createCCtxPool DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$ZSTDMT_freeCCtxPool DD 020601H
	DD	060027206H
$chain$0$ZSTDMT_freeCCtxPool DD 020521H
	DD	0b7405H
	DD	imagerel ZSTDMT_freeCCtxPool
	DD	imagerel ZSTDMT_freeCCtxPool+6
	DD	imagerel $unwind$ZSTDMT_freeCCtxPool
$chain$1$ZSTDMT_freeCCtxPool DD 020521H
	DD	0a3405H
	DD	imagerel ZSTDMT_freeCCtxPool+6
	DD	imagerel ZSTDMT_freeCCtxPool+21
	DD	imagerel $chain$0$ZSTDMT_freeCCtxPool
$chain$2$ZSTDMT_freeCCtxPool DD 021H
	DD	imagerel ZSTDMT_freeCCtxPool+6
	DD	imagerel ZSTDMT_freeCCtxPool+21
	DD	imagerel $chain$0$ZSTDMT_freeCCtxPool
$chain$3$ZSTDMT_freeCCtxPool DD 021H
	DD	imagerel ZSTDMT_freeCCtxPool
	DD	imagerel ZSTDMT_freeCCtxPool+6
	DD	imagerel $unwind$ZSTDMT_freeCCtxPool
$unwind$ZSTDMT_createSeqPool DD 020601H
	DD	030027206H
$unwind$ZSTDMT_setNbSeq DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTDMT_releaseSeq DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$ZSTDMT_getSeq DD 020601H
	DD	030027206H
$unwind$ZSTDMT_releaseBuffer DD 040a01H
	DD	0a340aH
	DD	07006720aH
$unwind$ZSTDMT_getBuffer DD 081401H
	DD	0106414H
	DD	0f5414H
	DD	0e3414H
	DD	07010b214H
$unwind$ZSTDMT_expandBufferPool DD 040a01H
	DD	0b340aH
	DD	07006720aH
$unwind$ZSTDMT_setBufferSize DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTDMT_freeBufferPool DD 020e01H
	DD	0300a720eH
$chain$0$ZSTDMT_freeBufferPool DD 020521H
	DD	0a7405H
	DD	imagerel ZSTDMT_freeBufferPool
	DD	imagerel ZSTDMT_freeBufferPool+14
	DD	imagerel $unwind$ZSTDMT_freeBufferPool
$chain$1$ZSTDMT_freeBufferPool DD 021H
	DD	imagerel ZSTDMT_freeBufferPool
	DD	imagerel ZSTDMT_freeBufferPool+14
	DD	imagerel $unwind$ZSTDMT_freeBufferPool
$unwind$ZSTDMT_createBufferPool DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$ZSTD_window_update DD 010201H
	DD	06002H
$chain$0$ZSTD_window_update DD 020521H
	DD	023405H
	DD	imagerel ZSTD_window_update
	DD	imagerel ZSTD_window_update+29
	DD	imagerel $unwind$ZSTD_window_update
$chain$1$ZSTD_window_update DD 020521H
	DD	037405H
	DD	imagerel ZSTD_window_update+29
	DD	imagerel ZSTD_window_update+34
	DD	imagerel $chain$0$ZSTD_window_update
$chain$2$ZSTD_window_update DD 021H
	DD	imagerel ZSTD_window_update+29
	DD	imagerel ZSTD_window_update+34
	DD	imagerel $chain$0$ZSTD_window_update
$chain$3$ZSTD_window_update DD 021H
	DD	imagerel ZSTD_window_update
	DD	imagerel ZSTD_window_update+29
	DD	imagerel $unwind$ZSTD_window_update
$unwind$ZSTDMT_freeCCtx DD 020601H
	DD	030027206H
$chain$0$ZSTDMT_freeCCtx DD 020521H
	DD	0a5405H
	DD	imagerel $LN46
	DD	imagerel $LN46+21
	DD	imagerel $unwind$ZSTDMT_freeCCtx
$chain$2$ZSTDMT_freeCCtx DD 040a21H
	DD	0c740aH
	DD	0b6405H
	DD	imagerel $LN46+21
	DD	imagerel $LN46+26
	DD	imagerel $chain$0$ZSTDMT_freeCCtx
$chain$3$ZSTDMT_freeCCtx DD 020021H
	DD	0c7400H
	DD	imagerel $LN46+21
	DD	imagerel $LN46+26
	DD	imagerel $chain$0$ZSTDMT_freeCCtx
$chain$4$ZSTDMT_freeCCtx DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+21
	DD	imagerel $unwind$ZSTDMT_freeCCtx
$unwind$ZSTDMT_updateCParams_whileCompressing DD 040a01H
	DD	0e340aH
	DD	07006b20aH
$unwind$ZSTDMT_compressStream_generic DD 091501H
	DD	0286415H
	DD	0200115H
	DD	0e00cf00eH
	DD	0c008d00aH
	DD	07006H
$chain$0$ZSTDMT_compressStream_generic DD 020821H
	DD	0275408H
	DD	imagerel $LN99
	DD	imagerel $LN99+91
	DD	imagerel $unwind$ZSTDMT_compressStream_generic
$chain$1$ZSTDMT_compressStream_generic DD 020821H
	DD	0263408H
	DD	imagerel $LN99+91
	DD	imagerel $LN99+435
	DD	imagerel $chain$0$ZSTDMT_compressStream_generic
$chain$2$ZSTDMT_compressStream_generic DD 021H
	DD	imagerel $LN99+91
	DD	imagerel $LN99+435
	DD	imagerel $chain$0$ZSTDMT_compressStream_generic
$chain$3$ZSTDMT_compressStream_generic DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+91
	DD	imagerel $unwind$ZSTDMT_compressStream_generic
$unwind$ZSTDMT_initCStream_internal DD 0b1c01H
	DD	031341cH
	DD	026011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
$unwind$ZSTDMT_createCCtx_advanced DD 010401H
	DD	08204H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
nbWorkers$ = 80
cMem$ = 88
ZSTDMT_createCCtx_advanced PROC

; 929  : {

$LN4:
	sub	rsp, 72					; 00000048H

; 930  : #ifdef ZSTD_MULTITHREAD
; 931  :     return ZSTDMT_createCCtx_advanced_internal(nbWorkers, cMem);

	movaps	xmm0, XMMWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [rdx+16]
	lea	rdx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	call	ZSTDMT_createCCtx_advanced_internal

; 932  : #else
; 933  :     (void)nbWorkers;
; 934  :     (void)cMem;
; 935  :     return NULL;
; 936  : #endif
; 937  : }

	add	rsp, 72					; 00000048H
	ret	0
ZSTDMT_createCCtx_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
dictContentType$1$ = 64
cMem$1$ = 80
cMem$1$ = 80
$T1 = 80
$T2 = 80
$T3 = 80
$T4 = 80
$T5 = 80
dictSize$GSCopy$1$ = 112
dict$GSCopy$1$ = 120
cMem$2$ = 128
cMem$2$ = 128
$T6 = 128
$T7 = 128
$T8 = 160
$T9 = 160
mtctx$ = 368
dict$ = 376
dictSize$ = 384
dictContentType$ = 392
cdict$ = 400
params$ = 408
pledgedSrcSize$ = 416
ZSTDMT_initCStream_internal PROC

; 1420 : {

$LN700:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-48]
	sub	rsp, 304				; 00000130H
	mov	r13, QWORD PTR params$[rbp-256]

; 1421 :     DEBUGLOG(4, "ZSTDMT_initCStream_internal (pledgedSrcSize=%u, nbWorkers=%u, cctxPool=%u)",
; 1422 :                 (U32)pledgedSrcSize, params.nbWorkers, mtctx->cctxPool->totalCCtx);
; 1423 : 
; 1424 :     /* params supposed partially fully validated at this point */
; 1425 :     assert(!ZSTD_isError(ZSTD_checkCParams(params.cParams)));
; 1426 :     assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
; 1427 : 
; 1428 :     /* init */
; 1429 :     if (params.nbWorkers != mtctx->params.nbWorkers)

	xor	r14d, r14d
	mov	DWORD PTR dictContentType$1$[rsp], r9d
	mov	rsi, rcx
	mov	QWORD PTR dictSize$GSCopy$1$[rsp], r8
	mov	QWORD PTR dict$GSCopy$1$[rsp], rdx
	mov	ebx, DWORD PTR [r13+76]
	cmp	ebx, DWORD PTR [rcx+116]
	je	$LN3@ZSTDMT_ini

; 1078 :     if (POOL_resize(mtctx->factory, nbWorkers)) return ERROR(memory_allocation);

	mov	rcx, QWORD PTR [rcx]
	mov	edx, ebx
	call	POOL_resize
	test	eax, eax
	jne	$LN698@ZSTDMT_ini

; 1079 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbWorkers) , "");

	mov	edx, ebx
	mov	rcx, rsi
	call	ZSTDMT_expandJobsTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1079 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbWorkers) , "");

	ja	$LN1@ZSTDMT_ini

; 1080 :     mtctx->bufPool = ZSTDMT_expandBufferPool(mtctx->bufPool, nbWorkers);

	mov	rdi, QWORD PTR [rsi+16]

; 167  :     if (srcBufPool==NULL) return NULL;

	test	rdi, rdi
	je	$LN696@ZSTDMT_ini

; 168  :     if (srcBufPool->totalBuffers >= maxNbBuffers) /* good enough */

	lea	eax, DWORD PTR [rbx*2+3]
	cmp	DWORD PTR [rdi+48], eax
	jae	SHORT $LN34@ZSTDMT_ini

; 169  :         return srcBufPool;
; 170  :     /* need a larger buffer pool */
; 171  :     {   ZSTD_customMem const cMem = srcBufPool->cMem;

	movups	xmm0, XMMWORD PTR [rdi+56]

; 172  :         size_t const bSize = srcBufPool->bufferSize;   /* forward parameters */

	mov	r12, QWORD PTR [rdi+40]

; 173  :         ZSTDMT_bufferPool* newBufPool;
; 174  :         ZSTDMT_freeBufferPool(srcBufPool);

	mov	rcx, rdi
	movups	XMMWORD PTR cMem$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rdi+72]
	movsd	QWORD PTR cMem$2$[rbp-256], xmm0
	call	ZSTDMT_freeBufferPool

; 175  :         newBufPool = ZSTDMT_createBufferPool(nbWorkers, cMem);

	movups	xmm0, XMMWORD PTR cMem$1$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	ecx, ebx
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	xmm0, QWORD PTR cMem$2$[rbp-256]
	movsd	QWORD PTR $T2[rsp+16], xmm0
	call	ZSTDMT_createBufferPool
	mov	rdi, rax

; 176  :         if (newBufPool==NULL) return newBufPool;

	test	rax, rax
	je	$LN696@ZSTDMT_ini

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rax
	call	QWORD PTR __imp_EnterCriticalSection

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rdi
	mov	QWORD PTR [rdi+40], r12
	call	QWORD PTR __imp_LeaveCriticalSection
$LN34@ZSTDMT_ini:

; 1082 :     mtctx->cctxPool = ZSTDMT_expandCCtxPool(mtctx->cctxPool, nbWorkers);

	mov	QWORD PTR [rsi+16], rdi
	mov	rcx, QWORD PTR [rsi+24]

; 385  :     if (srcPool==NULL) return NULL;

	test	rcx, rcx
	jne	SHORT $LN48@ZSTDMT_ini
	mov	QWORD PTR [rsi+24], r14

; 1531 : }

	lea	rax, QWORD PTR [rcx-64]
	jmp	$LN1@ZSTDMT_ini
$LN48@ZSTDMT_ini:

; 386  :     if (nbWorkers <= srcPool->totalCCtx) return srcPool;   /* good enough */

	cmp	ebx, DWORD PTR [rcx+40]
	jg	SHORT $LN49@ZSTDMT_ini
	mov	QWORD PTR [rsi+24], rcx
	jmp	SHORT $LN35@ZSTDMT_ini
$LN49@ZSTDMT_ini:

; 387  :     /* need a larger cctx pool */
; 388  :     {   ZSTD_customMem const cMem = srcPool->cMem;

	movups	xmm0, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR cMem$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rcx+64]
	movsd	QWORD PTR cMem$2$[rbp-256], xmm0

; 389  :         ZSTDMT_freeCCtxPool(srcPool);

	call	ZSTDMT_freeCCtxPool

; 390  :         return ZSTDMT_createCCtxPool(nbWorkers, cMem);

	movups	xmm0, XMMWORD PTR cMem$1$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	ecx, ebx
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	xmm0, QWORD PTR cMem$2$[rbp-256]
	movsd	QWORD PTR $T1[rsp+16], xmm0
	call	ZSTDMT_createCCtxPool

; 1082 :     mtctx->cctxPool = ZSTDMT_expandCCtxPool(mtctx->cctxPool, nbWorkers);

	mov	QWORD PTR [rsi+24], rax

; 1083 :     if (mtctx->cctxPool == NULL) return ERROR(memory_allocation);

	test	rax, rax
	je	SHORT $LN698@ZSTDMT_ini
$LN35@ZSTDMT_ini:

; 335  :     return ZSTDMT_expandBufferPool(pool, nbWorkers);

	mov	rcx, QWORD PTR [rsi+32]
	mov	edx, ebx
	call	ZSTDMT_expandBufferPool

; 1084 :     mtctx->seqPool = ZSTDMT_expandSeqPool(mtctx->seqPool, nbWorkers);

	mov	QWORD PTR [rsi+32], rax

; 1085 :     if (mtctx->seqPool == NULL) return ERROR(memory_allocation);

	test	rax, rax
	je	SHORT $LN698@ZSTDMT_ini
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 632  :         CCtxParams->nbWorkers = value;

	mov	rdx, QWORD PTR dict$GSCopy$1$[rsp]

; 434  :     if (*value < bounds.lowerBound) *value = bounds.lowerBound;

	test	ebx, ebx

; 632  :         CCtxParams->nbWorkers = value;

	mov	r8, QWORD PTR dictSize$GSCopy$1$[rsp]

; 434  :     if (*value < bounds.lowerBound) *value = bounds.lowerBound;

	cmovs	ebx, r14d

; 330  :         bounds.lowerBound = 0;

	mov	DWORD PTR $T6[rbp-248], r14d

; 331  : #ifdef ZSTD_MULTITHREAD
; 332  :         bounds.upperBound = ZSTDMT_NBWORKERS_MAX;

	mov	DWORD PTR $T6[rbp-244], 200		; 000000c8H

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	rax, QWORD PTR $T6[rbp-248]
	shr	rax, 32					; 00000020H

; 632  :         CCtxParams->nbWorkers = value;

	cmp	ebx, eax
	cmovle	eax, ebx
	mov	DWORD PTR [rsi+116], eax
$LN3@ZSTDMT_ini:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1432 :     if (params.jobSize != 0 && params.jobSize < ZSTDMT_JOBSIZE_MIN) params.jobSize = ZSTDMT_JOBSIZE_MIN;

	mov	r15, QWORD PTR [r13+80]
	lea	rax, QWORD PTR [r15-1]
	cmp	rax, 1048574				; 000ffffeH
	ja	SHORT $LN8@ZSTDMT_ini
	mov	QWORD PTR [r13+80], 1048576		; 00100000H
	mov	r15d, 1048576				; 00100000H
	jmp	SHORT $LN9@ZSTDMT_ini
$LN696@ZSTDMT_ini:

; 176  :         if (newBufPool==NULL) return newBufPool;

	mov	QWORD PTR [rsi+16], r14
$LN698@ZSTDMT_ini:

; 1531 : }

	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN1@ZSTDMT_ini
$LN8@ZSTDMT_ini:

; 1433 :     if (params.jobSize > (size_t)ZSTDMT_JOBSIZE_MAX) params.jobSize = (size_t)ZSTDMT_JOBSIZE_MAX;

	cmp	r15, 1073741824				; 40000000H
	jbe	SHORT $LN9@ZSTDMT_ini
	mov	QWORD PTR [r13+80], 1073741824		; 40000000H
	mov	r15d, 1073741824			; 40000000H
$LN9@ZSTDMT_ini:

; 1434 : 
; 1435 :     mtctx->singleBlockingThread = (pledgedSrcSize <= ZSTDMT_JOBSIZE_MIN);  /* do not trigger multi-threading when srcSize is too small */

	mov	rdi, QWORD PTR pledgedSrcSize$[rbp-256]
	mov	eax, r14d
	cmp	rdi, 1048576				; 00100000H
	setbe	al
	mov	DWORD PTR [rsi+728], eax

; 1436 :     if (mtctx->singleBlockingThread) {

	ja	$LN10@ZSTDMT_ini

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm1, XMMWORD PTR [r13+64]

; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));

	xor	eax, eax
	movaps	xmm0, XMMWORD PTR [r13+48]
	movaps	xmm2, XMMWORD PTR [r13]
	movaps	xmm3, XMMWORD PTR [r13+16]
	movaps	xmm4, XMMWORD PTR [r13+32]
	movups	XMMWORD PTR $T9[rbp-208], xmm0
	mov	DWORD PTR $T9[rbp-208], r14d
	movaps	xmm0, XMMWORD PTR [r13+80]
	movups	XMMWORD PTR $T9[rbp-176], xmm0
	mov	QWORD PTR $T9[rbp-176], r14
	movaps	xmm0, XMMWORD PTR [r13+112]
	mov	DWORD PTR $T9[rbp-168], r14d
	movups	XMMWORD PTR $T9[rbp-192], xmm1
	mov	DWORD PTR $T9[rbp-180], r14d
	movaps	xmm1, XMMWORD PTR [r13+96]
	movups	XMMWORD PTR $T9[rbp-160], xmm1
	movaps	xmm1, XMMWORD PTR [r13+128]
	movups	XMMWORD PTR $T9[rbp-144], xmm0
	xorps	xmm0, xmm0

; 391  :     }
; 392  : }
; 393  : 
; 394  : /* only works during initialization phase, not during compression */
; 395  : static size_t ZSTDMT_sizeof_CCtxPool(ZSTDMT_CCtxPool* cctxPool)
; 396  : {
; 397  :     ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);
; 398  :     {   unsigned const nbWorkers = cctxPool->totalCCtx;
; 399  :         size_t const poolSize = sizeof(*cctxPool)
; 400  :                                 + (nbWorkers-1) * sizeof(ZSTD_CCtx*);
; 401  :         unsigned u;
; 402  :         size_t totalCCtxSize = 0;
; 403  :         for (u=0; u<nbWorkers; u++) {
; 404  :             totalCCtxSize += ZSTD_sizeof_CCtx(cctxPool->cctx[u]);
; 405  :         }
; 406  :         ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);
; 407  :         assert(nbWorkers > 0);
; 408  :         return poolSize + totalCCtxSize;
; 409  :     }
; 410  : }
; 411  : 
; 412  : static ZSTD_CCtx* ZSTDMT_getCCtx(ZSTDMT_CCtxPool* cctxPool)
; 413  : {
; 414  :     DEBUGLOG(5, "ZSTDMT_getCCtx");
; 415  :     ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);
; 416  :     if (cctxPool->availCCtx) {
; 417  :         cctxPool->availCCtx--;
; 418  :         {   ZSTD_CCtx* const cctx = cctxPool->cctx[cctxPool->availCCtx];
; 419  :             ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);
; 420  :             return cctx;
; 421  :     }   }
; 422  :     ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);
; 423  :     DEBUGLOG(5, "create one more CCtx");
; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */
; 425  : }
; 426  : 
; 427  : static void ZSTDMT_releaseCCtx(ZSTDMT_CCtxPool* pool, ZSTD_CCtx* cctx)
; 428  : {
; 429  :     if (cctx==NULL) return;   /* compatibility with release on NULL */
; 430  :     ZSTD_pthread_mutex_lock(&pool->poolMutex);
; 431  :     if (pool->availCCtx < pool->totalCCtx)
; 432  :         pool->cctx[pool->availCCtx++] = cctx;
; 433  :     else {
; 434  :         /* pool overflow : should not happen, since totalCCtx==nbWorkers */
; 435  :         DEBUGLOG(4, "CCtx pool overflow : free cctx");
; 436  :         ZSTD_freeCCtx(cctx);
; 437  :     }
; 438  :     ZSTD_pthread_mutex_unlock(&pool->poolMutex);
; 439  : }
; 440  : 
; 441  : /* ====   Serial State   ==== */
; 442  : 
; 443  : typedef struct {
; 444  :     void const* start;
; 445  :     size_t size;
; 446  : } range_t;
; 447  : 
; 448  : typedef struct {
; 449  :     /* All variables in the struct are protected by mutex. */
; 450  :     ZSTD_pthread_mutex_t mutex;
; 451  :     ZSTD_pthread_cond_t cond;
; 452  :     ZSTD_CCtx_params params;
; 453  :     ldmState_t ldmState;
; 454  :     XXH64_state_t xxhState;
; 455  :     unsigned nextJobID;
; 456  :     /* Protects ldmWindow.
; 457  :      * Must be acquired after the main mutex when acquiring both.
; 458  :      */
; 459  :     ZSTD_pthread_mutex_t ldmWindowMutex;
; 460  :     ZSTD_pthread_cond_t ldmWindowCond;  /* Signaled when ldmWindow is updated */
; 461  :     ZSTD_window_t ldmWindow;  /* A thread-safe copy of ldmState.window */
; 462  : } serialState_t;
; 463  : 
; 464  : static int
; 465  : ZSTDMT_serialState_reset(serialState_t* serialState,
; 466  :                          ZSTDMT_seqPool* seqPool,
; 467  :                          ZSTD_CCtx_params params,
; 468  :                          size_t jobSize,
; 469  :                          const void* dict, size_t const dictSize,
; 470  :                          ZSTD_dictContentType_e dictContentType)
; 471  : {
; 472  :     /* Adjust parameters */
; 473  :     if (params.ldmParams.enableLdm) {
; 474  :         DEBUGLOG(4, "LDM window size = %u KB", (1U << params.cParams.windowLog) >> 10);
; 475  :         ZSTD_ldm_adjustParameters(&params.ldmParams, &params.cParams);
; 476  :         assert(params.ldmParams.hashLog >= params.ldmParams.bucketSizeLog);
; 477  :         assert(params.ldmParams.hashRateLog < 32);
; 478  :         serialState->ldmState.hashPower =
; 479  :                 ZSTD_rollingHash_primePower(params.ldmParams.minMatchLength);
; 480  :     } else {
; 481  :         memset(&params.ldmParams, 0, sizeof(params.ldmParams));
; 482  :     }
; 483  :     serialState->nextJobID = 0;
; 484  :     if (params.fParams.checksumFlag)
; 485  :         XXH64_reset(&serialState->xxhState, 0);
; 486  :     if (params.ldmParams.enableLdm) {
; 487  :         ZSTD_customMem cMem = params.customMem;
; 488  :         unsigned const hashLog = params.ldmParams.hashLog;
; 489  :         size_t const hashSize = ((size_t)1 << hashLog) * sizeof(ldmEntry_t);
; 490  :         unsigned const bucketLog =
; 491  :             params.ldmParams.hashLog - params.ldmParams.bucketSizeLog;
; 492  :         size_t const bucketSize = (size_t)1 << bucketLog;
; 493  :         unsigned const prevBucketLog =
; 494  :             serialState->params.ldmParams.hashLog -
; 495  :             serialState->params.ldmParams.bucketSizeLog;
; 496  :         /* Size the seq pool tables */
; 497  :         ZSTDMT_setNbSeq(seqPool, ZSTD_ldm_getMaxNbSeq(params.ldmParams, jobSize));
; 498  :         /* Reset the window */
; 499  :         ZSTD_window_init(&serialState->ldmState.window);
; 500  :         /* Resize tables and output space if necessary. */
; 501  :         if (serialState->ldmState.hashTable == NULL || serialState->params.ldmParams.hashLog < hashLog) {
; 502  :             ZSTD_free(serialState->ldmState.hashTable, cMem);
; 503  :             serialState->ldmState.hashTable = (ldmEntry_t*)ZSTD_malloc(hashSize, cMem);
; 504  :         }
; 505  :         if (serialState->ldmState.bucketOffsets == NULL || prevBucketLog < bucketLog) {
; 506  :             ZSTD_free(serialState->ldmState.bucketOffsets, cMem);
; 507  :             serialState->ldmState.bucketOffsets = (BYTE*)ZSTD_malloc(bucketSize, cMem);
; 508  :         }
; 509  :         if (!serialState->ldmState.hashTable || !serialState->ldmState.bucketOffsets)
; 510  :             return 1;
; 511  :         /* Zero the tables */
; 512  :         memset(serialState->ldmState.hashTable, 0, hashSize);
; 513  :         memset(serialState->ldmState.bucketOffsets, 0, bucketSize);
; 514  : 
; 515  :         /* Update window state and fill hash table with dict */
; 516  :         serialState->ldmState.loadedDictEnd = 0;
; 517  :         if (dictSize > 0) {
; 518  :             if (dictContentType == ZSTD_dct_rawContent) {
; 519  :                 BYTE const* const dictEnd = (const BYTE*)dict + dictSize;
; 520  :                 ZSTD_window_update(&serialState->ldmState.window, dict, dictSize);
; 521  :                 ZSTD_ldm_fillHashTable(&serialState->ldmState, (const BYTE*)dict, dictEnd, &params.ldmParams);
; 522  :                 serialState->ldmState.loadedDictEnd = params.forceWindow ? 0 : (U32)(dictEnd - serialState->ldmState.window.base);
; 523  :             } else {
; 524  :                 /* don't even load anything */
; 525  :             }
; 526  :         }
; 527  : 
; 528  :         /* Initialize serialState's copy of ldmWindow. */
; 529  :         serialState->ldmWindow = serialState->ldmState.window;
; 530  :     }
; 531  : 
; 532  :     serialState->params = params;
; 533  :     serialState->params.jobSize = (U32)jobSize;
; 534  :     return 0;
; 535  : }
; 536  : 
; 537  : static int ZSTDMT_serialState_init(serialState_t* serialState)
; 538  : {
; 539  :     int initError = 0;
; 540  :     memset(serialState, 0, sizeof(*serialState));
; 541  :     initError |= ZSTD_pthread_mutex_init(&serialState->mutex, NULL);
; 542  :     initError |= ZSTD_pthread_cond_init(&serialState->cond, NULL);
; 543  :     initError |= ZSTD_pthread_mutex_init(&serialState->ldmWindowMutex, NULL);
; 544  :     initError |= ZSTD_pthread_cond_init(&serialState->ldmWindowCond, NULL);
; 545  :     return initError;
; 546  : }
; 547  : 
; 548  : static void ZSTDMT_serialState_free(serialState_t* serialState)
; 549  : {
; 550  :     ZSTD_customMem cMem = serialState->params.customMem;
; 551  :     ZSTD_pthread_mutex_destroy(&serialState->mutex);
; 552  :     ZSTD_pthread_cond_destroy(&serialState->cond);
; 553  :     ZSTD_pthread_mutex_destroy(&serialState->ldmWindowMutex);
; 554  :     ZSTD_pthread_cond_destroy(&serialState->ldmWindowCond);
; 555  :     ZSTD_free(serialState->ldmState.hashTable, cMem);
; 556  :     ZSTD_free(serialState->ldmState.bucketOffsets, cMem);
; 557  : }
; 558  : 
; 559  : static void ZSTDMT_serialState_update(serialState_t* serialState,
; 560  :                                       ZSTD_CCtx* jobCCtx, rawSeqStore_t seqStore,
; 561  :                                       range_t src, unsigned jobID)
; 562  : {
; 563  :     /* Wait for our turn */
; 564  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);
; 565  :     while (serialState->nextJobID < jobID) {
; 566  :         DEBUGLOG(5, "wait for serialState->cond");
; 567  :         ZSTD_pthread_cond_wait(&serialState->cond, &serialState->mutex);
; 568  :     }
; 569  :     /* A future job may error and skip our job */
; 570  :     if (serialState->nextJobID == jobID) {
; 571  :         /* It is now our turn, do any processing necessary */
; 572  :         if (serialState->params.ldmParams.enableLdm) {
; 573  :             size_t error;
; 574  :             assert(seqStore.seq != NULL && seqStore.pos == 0 &&
; 575  :                    seqStore.size == 0 && seqStore.capacity > 0);
; 576  :             assert(src.size <= serialState->params.jobSize);
; 577  :             ZSTD_window_update(&serialState->ldmState.window, src.start, src.size);
; 578  :             error = ZSTD_ldm_generateSequences(
; 579  :                 &serialState->ldmState, &seqStore,
; 580  :                 &serialState->params.ldmParams, src.start, src.size);
; 581  :             /* We provide a large enough buffer to never fail. */
; 582  :             assert(!ZSTD_isError(error)); (void)error;
; 583  :             /* Update ldmWindow to match the ldmState.window and signal the main
; 584  :              * thread if it is waiting for a buffer.
; 585  :              */
; 586  :             ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);
; 587  :             serialState->ldmWindow = serialState->ldmState.window;
; 588  :             ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);
; 589  :             ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);
; 590  :         }
; 591  :         if (serialState->params.fParams.checksumFlag && src.size > 0)
; 592  :             XXH64_update(&serialState->xxhState, src.start, src.size);
; 593  :     }
; 594  :     /* Now it is the next jobs turn */
; 595  :     serialState->nextJobID++;
; 596  :     ZSTD_pthread_cond_broadcast(&serialState->cond);
; 597  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);
; 598  : 
; 599  :     if (seqStore.size > 0) {
; 600  :         size_t const err = ZSTD_referenceExternalSequences(
; 601  :             jobCCtx, seqStore.seq, seqStore.size);
; 602  :         assert(serialState->params.ldmParams.enableLdm);
; 603  :         assert(!ZSTD_isError(err));
; 604  :         (void)err;
; 605  :     }
; 606  : }
; 607  : 
; 608  : static void ZSTDMT_serialState_ensureFinished(serialState_t* serialState,
; 609  :                                               unsigned jobID, size_t cSize)
; 610  : {
; 611  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);
; 612  :     if (serialState->nextJobID <= jobID) {
; 613  :         assert(ZSTD_isError(cSize)); (void)cSize;
; 614  :         DEBUGLOG(5, "Skipping past job %u because of error", jobID);
; 615  :         serialState->nextJobID = jobID + 1;
; 616  :         ZSTD_pthread_cond_broadcast(&serialState->cond);
; 617  : 
; 618  :         ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);
; 619  :         ZSTD_window_clear(&serialState->ldmWindow);
; 620  :         ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);
; 621  :         ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);
; 622  :     }
; 623  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);
; 624  : 
; 625  : }
; 626  : 
; 627  : 
; 628  : /* ------------------------------------------ */
; 629  : /* =====          Worker thread         ===== */
; 630  : /* ------------------------------------------ */
; 631  : 
; 632  : static const range_t kNullRange = { NULL, 0 };
; 633  : 
; 634  : typedef struct {
; 635  :     size_t   consumed;                   /* SHARED - set0 by mtctx, then modified by worker AND read by mtctx */
; 636  :     size_t   cSize;                      /* SHARED - set0 by mtctx, then modified by worker AND read by mtctx, then set0 by mtctx */
; 637  :     ZSTD_pthread_mutex_t job_mutex;      /* Thread-safe - used by mtctx and worker */
; 638  :     ZSTD_pthread_cond_t job_cond;        /* Thread-safe - used by mtctx and worker */
; 639  :     ZSTDMT_CCtxPool* cctxPool;           /* Thread-safe - used by mtctx and (all) workers */
; 640  :     ZSTDMT_bufferPool* bufPool;          /* Thread-safe - used by mtctx and (all) workers */
; 641  :     ZSTDMT_seqPool* seqPool;             /* Thread-safe - used by mtctx and (all) workers */
; 642  :     serialState_t* serial;               /* Thread-safe - used by mtctx and (all) workers */
; 643  :     buffer_t dstBuff;                    /* set by worker (or mtctx), then read by worker & mtctx, then modified by mtctx => no barrier */
; 644  :     range_t prefix;                      /* set by mtctx, then read by worker & mtctx => no barrier */
; 645  :     range_t src;                         /* set by mtctx, then read by worker & mtctx => no barrier */
; 646  :     unsigned jobID;                      /* set by mtctx, then read by worker => no barrier */
; 647  :     unsigned firstJob;                   /* set by mtctx, then read by worker => no barrier */
; 648  :     unsigned lastJob;                    /* set by mtctx, then read by worker => no barrier */
; 649  :     ZSTD_CCtx_params params;             /* set by mtctx, then read by worker => no barrier */
; 650  :     const ZSTD_CDict* cdict;             /* set by mtctx, then read by worker => no barrier */
; 651  :     unsigned long long fullFrameSize;    /* set by mtctx, then read by worker => no barrier */
; 652  :     size_t   dstFlushed;                 /* used only by mtctx */
; 653  :     unsigned frameChecksumNeeded;        /* used only by mtctx */
; 654  : } ZSTDMT_jobDescription;
; 655  : 
; 656  : #define JOB_ERROR(e) {                          \
; 657  :     ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);   \
; 658  :     job->cSize = e;                             \
; 659  :     ZSTD_pthread_mutex_unlock(&job->job_mutex); \
; 660  :     goto _endJob;                               \
; 661  : }
; 662  : 
; 663  : /* ZSTDMT_compressionJob() is a POOL_function type */
; 664  : static void ZSTDMT_compressionJob(void* jobDescription)
; 665  : {
; 666  :     ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;
; 667  :     ZSTD_CCtx_params jobParams = job->params;   /* do not modify job->params ! copy it, modify the copy */
; 668  :     ZSTD_CCtx* const cctx = ZSTDMT_getCCtx(job->cctxPool);
; 669  :     rawSeqStore_t rawSeqStore = ZSTDMT_getSeq(job->seqPool);
; 670  :     buffer_t dstBuff = job->dstBuff;
; 671  :     size_t lastCBlockSize = 0;
; 672  : 
; 673  :     /* resources */
; 674  :     if (cctx==NULL) JOB_ERROR(ERROR(memory_allocation));
; 675  :     if (dstBuff.start == NULL) {   /* streaming job : doesn't provide a dstBuffer */
; 676  :         dstBuff = ZSTDMT_getBuffer(job->bufPool);
; 677  :         if (dstBuff.start==NULL) JOB_ERROR(ERROR(memory_allocation));
; 678  :         job->dstBuff = dstBuff;   /* this value can be read in ZSTDMT_flush, when it copies the whole job */
; 679  :     }
; 680  :     if (jobParams.ldmParams.enableLdm && rawSeqStore.seq == NULL)
; 681  :         JOB_ERROR(ERROR(memory_allocation));
; 682  : 
; 683  :     /* Don't compute the checksum for chunks, since we compute it externally,
; 684  :      * but write it in the header.
; 685  :      */
; 686  :     if (job->jobID != 0) jobParams.fParams.checksumFlag = 0;
; 687  :     /* Don't run LDM for the chunks, since we handle it externally */
; 688  :     jobParams.ldmParams.enableLdm = 0;
; 689  : 
; 690  : 
; 691  :     /* init */
; 692  :     if (job->cdict) {
; 693  :         size_t const initError = ZSTD_compressBegin_advanced_internal(cctx, NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast, job->cdict, &jobParams, job->fullFrameSize);
; 694  :         assert(job->firstJob);  /* only allowed for first job */
; 695  :         if (ZSTD_isError(initError)) JOB_ERROR(initError);
; 696  :     } else {  /* srcStart points at reloaded section */
; 697  :         U64 const pledgedSrcSize = job->firstJob ? job->fullFrameSize : job->src.size;
; 698  :         {   size_t const forceWindowError = ZSTD_CCtxParams_setParameter(&jobParams, ZSTD_c_forceMaxWindow, !job->firstJob);
; 699  :             if (ZSTD_isError(forceWindowError)) JOB_ERROR(forceWindowError);
; 700  :         }
; 701  :         {   size_t const initError = ZSTD_compressBegin_advanced_internal(cctx,
; 702  :                                         job->prefix.start, job->prefix.size, ZSTD_dct_rawContent, /* load dictionary in "content-only" mode (no header analysis) */
; 703  :                                         ZSTD_dtlm_fast,
; 704  :                                         NULL, /*cdict*/
; 705  :                                         &jobParams, pledgedSrcSize);
; 706  :             if (ZSTD_isError(initError)) JOB_ERROR(initError);
; 707  :     }   }
; 708  : 
; 709  :     /* Perform serial step as early as possible, but after CCtx initialization */
; 710  :     ZSTDMT_serialState_update(job->serial, cctx, rawSeqStore, job->src, job->jobID);
; 711  : 
; 712  :     if (!job->firstJob) {  /* flush and overwrite frame header when it's not first job */
; 713  :         size_t const hSize = ZSTD_compressContinue(cctx, dstBuff.start, dstBuff.capacity, job->src.start, 0);
; 714  :         if (ZSTD_isError(hSize)) JOB_ERROR(hSize);
; 715  :         DEBUGLOG(5, "ZSTDMT_compressionJob: flush and overwrite %u bytes of frame header (not first job)", (U32)hSize);
; 716  :         ZSTD_invalidateRepCodes(cctx);
; 717  :     }
; 718  : 
; 719  :     /* compress */
; 720  :     {   size_t const chunkSize = 4*ZSTD_BLOCKSIZE_MAX;
; 721  :         int const nbChunks = (int)((job->src.size + (chunkSize-1)) / chunkSize);
; 722  :         const BYTE* ip = (const BYTE*) job->src.start;
; 723  :         BYTE* const ostart = (BYTE*)dstBuff.start;
; 724  :         BYTE* op = ostart;
; 725  :         BYTE* oend = op + dstBuff.capacity;
; 726  :         int chunkNb;
; 727  :         if (sizeof(size_t) > sizeof(int)) assert(job->src.size < ((size_t)INT_MAX) * chunkSize);   /* check overflow */
; 728  :         DEBUGLOG(5, "ZSTDMT_compressionJob: compress %u bytes in %i blocks", (U32)job->src.size, nbChunks);
; 729  :         assert(job->cSize == 0);
; 730  :         for (chunkNb = 1; chunkNb < nbChunks; chunkNb++) {
; 731  :             size_t const cSize = ZSTD_compressContinue(cctx, op, oend-op, ip, chunkSize);
; 732  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);
; 733  :             ip += chunkSize;
; 734  :             op += cSize; assert(op < oend);
; 735  :             /* stats */
; 736  :             ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);
; 737  :             job->cSize += cSize;
; 738  :             job->consumed = chunkSize * chunkNb;
; 739  :             DEBUGLOG(5, "ZSTDMT_compressionJob: compress new block : cSize==%u bytes (total: %u)",
; 740  :                         (U32)cSize, (U32)job->cSize);
; 741  :             ZSTD_pthread_cond_signal(&job->job_cond);   /* warns some more data is ready to be flushed */
; 742  :             ZSTD_pthread_mutex_unlock(&job->job_mutex);
; 743  :         }
; 744  :         /* last block */
; 745  :         assert(chunkSize > 0);
; 746  :         assert((chunkSize & (chunkSize - 1)) == 0);  /* chunkSize must be power of 2 for mask==(chunkSize-1) to work */
; 747  :         if ((nbChunks > 0) | job->lastJob /*must output a "last block" flag*/ ) {
; 748  :             size_t const lastBlockSize1 = job->src.size & (chunkSize-1);
; 749  :             size_t const lastBlockSize = ((lastBlockSize1==0) & (job->src.size>=chunkSize)) ? chunkSize : lastBlockSize1;
; 750  :             size_t const cSize = (job->lastJob) ?
; 751  :                  ZSTD_compressEnd     (cctx, op, oend-op, ip, lastBlockSize) :
; 752  :                  ZSTD_compressContinue(cctx, op, oend-op, ip, lastBlockSize);
; 753  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);
; 754  :             lastCBlockSize = cSize;
; 755  :     }   }
; 756  : 
; 757  : _endJob:
; 758  :     ZSTDMT_serialState_ensureFinished(job->serial, job->jobID, job->cSize);
; 759  :     if (job->prefix.size > 0)
; 760  :         DEBUGLOG(5, "Finished with prefix: %zx", (size_t)job->prefix.start);
; 761  :     DEBUGLOG(5, "Finished with source: %zx", (size_t)job->src.start);
; 762  :     /* release resources */
; 763  :     ZSTDMT_releaseSeq(job->seqPool, rawSeqStore);
; 764  :     ZSTDMT_releaseCCtx(job->cctxPool, cctx);
; 765  :     /* report */
; 766  :     ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);
; 767  :     if (ZSTD_isError(job->cSize)) assert(lastCBlockSize == 0);
; 768  :     job->cSize += lastCBlockSize;
; 769  :     job->consumed = job->src.size;  /* when job->consumed == job->src.size , compression job is presumed completed */
; 770  :     ZSTD_pthread_cond_signal(&job->job_cond);
; 771  :     ZSTD_pthread_mutex_unlock(&job->job_mutex);
; 772  : }
; 773  : 
; 774  : 
; 775  : /* ------------------------------------------ */
; 776  : /* =====   Multi-threaded compression   ===== */
; 777  : /* ------------------------------------------ */
; 778  : 
; 779  : typedef struct {
; 780  :     range_t prefix;         /* read-only non-owned prefix buffer */
; 781  :     buffer_t buffer;
; 782  :     size_t filled;
; 783  : } inBuff_t;
; 784  : 
; 785  : typedef struct {
; 786  :   BYTE* buffer;     /* The round input buffer. All jobs get references
; 787  :                      * to pieces of the buffer. ZSTDMT_tryGetInputRange()
; 788  :                      * handles handing out job input buffers, and makes
; 789  :                      * sure it doesn't overlap with any pieces still in use.
; 790  :                      */
; 791  :   size_t capacity;  /* The capacity of buffer. */
; 792  :   size_t pos;       /* The position of the current inBuff in the round
; 793  :                      * buffer. Updated past the end if the inBuff once
; 794  :                      * the inBuff is sent to the worker thread.
; 795  :                      * pos <= capacity.
; 796  :                      */
; 797  : } roundBuff_t;
; 798  : 
; 799  : static const roundBuff_t kNullRoundBuff = {NULL, 0, 0};
; 800  : 
; 801  : #define RSYNC_LENGTH 32
; 802  : 
; 803  : typedef struct {
; 804  :   U64 hash;
; 805  :   U64 hitMask;
; 806  :   U64 primePower;
; 807  : } rsyncState_t;
; 808  : 
; 809  : struct ZSTDMT_CCtx_s {
; 810  :     POOL_ctx* factory;
; 811  :     ZSTDMT_jobDescription* jobs;
; 812  :     ZSTDMT_bufferPool* bufPool;
; 813  :     ZSTDMT_CCtxPool* cctxPool;
; 814  :     ZSTDMT_seqPool* seqPool;
; 815  :     ZSTD_CCtx_params params;
; 816  :     size_t targetSectionSize;
; 817  :     size_t targetPrefixSize;
; 818  :     int jobReady;        /* 1 => one job is already prepared, but pool has shortage of workers. Don't create a new job. */
; 819  :     inBuff_t inBuff;
; 820  :     roundBuff_t roundBuff;
; 821  :     serialState_t serial;
; 822  :     rsyncState_t rsync;
; 823  :     unsigned singleBlockingThread;
; 824  :     unsigned jobIDMask;
; 825  :     unsigned doneJobID;
; 826  :     unsigned nextJobID;
; 827  :     unsigned frameEnded;
; 828  :     unsigned allJobsCompleted;
; 829  :     unsigned long long frameContentSize;
; 830  :     unsigned long long consumed;
; 831  :     unsigned long long produced;
; 832  :     ZSTD_customMem cMem;
; 833  :     ZSTD_CDict* cdictLocal;
; 834  :     const ZSTD_CDict* cdict;
; 835  : };
; 836  : 
; 837  : static void ZSTDMT_freeJobsTable(ZSTDMT_jobDescription* jobTable, U32 nbJobs, ZSTD_customMem cMem)
; 838  : {
; 839  :     U32 jobNb;
; 840  :     if (jobTable == NULL) return;
; 841  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {
; 842  :         ZSTD_pthread_mutex_destroy(&jobTable[jobNb].job_mutex);
; 843  :         ZSTD_pthread_cond_destroy(&jobTable[jobNb].job_cond);
; 844  :     }
; 845  :     ZSTD_free(jobTable, cMem);
; 846  : }
; 847  : 
; 848  : /* ZSTDMT_allocJobsTable()
; 849  :  * allocate and init a job table.
; 850  :  * update *nbJobsPtr to next power of 2 value, as size of table */
; 851  : static ZSTDMT_jobDescription* ZSTDMT_createJobsTable(U32* nbJobsPtr, ZSTD_customMem cMem)
; 852  : {
; 853  :     U32 const nbJobsLog2 = ZSTD_highbit32(*nbJobsPtr) + 1;
; 854  :     U32 const nbJobs = 1 << nbJobsLog2;
; 855  :     U32 jobNb;
; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)
; 857  :                 ZSTD_calloc(nbJobs * sizeof(ZSTDMT_jobDescription), cMem);
; 858  :     int initError = 0;
; 859  :     if (jobTable==NULL) return NULL;
; 860  :     *nbJobsPtr = nbJobs;
; 861  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {
; 862  :         initError |= ZSTD_pthread_mutex_init(&jobTable[jobNb].job_mutex, NULL);
; 863  :         initError |= ZSTD_pthread_cond_init(&jobTable[jobNb].job_cond, NULL);
; 864  :     }
; 865  :     if (initError != 0) {
; 866  :         ZSTDMT_freeJobsTable(jobTable, nbJobs, cMem);
; 867  :         return NULL;
; 868  :     }
; 869  :     return jobTable;
; 870  : }
; 871  : 
; 872  : static size_t ZSTDMT_expandJobsTable (ZSTDMT_CCtx* mtctx, U32 nbWorkers) {
; 873  :     U32 nbJobs = nbWorkers + 2;
; 874  :     if (nbJobs > mtctx->jobIDMask+1) {  /* need more job capacity */
; 875  :         ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);
; 876  :         mtctx->jobIDMask = 0;
; 877  :         mtctx->jobs = ZSTDMT_createJobsTable(&nbJobs, mtctx->cMem);
; 878  :         if (mtctx->jobs==NULL) return ERROR(memory_allocation);
; 879  :         assert((nbJobs != 0) && ((nbJobs & (nbJobs - 1)) == 0));  /* ensure nbJobs is a power of 2 */
; 880  :         mtctx->jobIDMask = nbJobs - 1;
; 881  :     }
; 882  :     return 0;
; 883  : }
; 884  : 
; 885  : 
; 886  : /* ZSTDMT_CCtxParam_setNbWorkers():
; 887  :  * Internal use only */
; 888  : size_t ZSTDMT_CCtxParam_setNbWorkers(ZSTD_CCtx_params* params, unsigned nbWorkers)
; 889  : {
; 890  :     return ZSTD_CCtxParams_setParameter(params, ZSTD_c_nbWorkers, (int)nbWorkers);
; 891  : }
; 892  : 
; 893  : MEM_STATIC ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced_internal(unsigned nbWorkers, ZSTD_customMem cMem)
; 894  : {
; 895  :     ZSTDMT_CCtx* mtctx;
; 896  :     U32 nbJobs = nbWorkers + 2;
; 897  :     int initError;
; 898  :     DEBUGLOG(3, "ZSTDMT_createCCtx_advanced (nbWorkers = %u)", nbWorkers);
; 899  : 
; 900  :     if (nbWorkers < 1) return NULL;
; 901  :     nbWorkers = MIN(nbWorkers , ZSTDMT_NBWORKERS_MAX);
; 902  :     if ((cMem.customAlloc!=NULL) ^ (cMem.customFree!=NULL))
; 903  :         /* invalid custom allocator */
; 904  :         return NULL;
; 905  : 
; 906  :     mtctx = (ZSTDMT_CCtx*) ZSTD_calloc(sizeof(ZSTDMT_CCtx), cMem);
; 907  :     if (!mtctx) return NULL;
; 908  :     ZSTDMT_CCtxParam_setNbWorkers(&mtctx->params, nbWorkers);
; 909  :     mtctx->cMem = cMem;
; 910  :     mtctx->allJobsCompleted = 1;
; 911  :     mtctx->factory = POOL_create_advanced(nbWorkers, 0, cMem);
; 912  :     mtctx->jobs = ZSTDMT_createJobsTable(&nbJobs, cMem);
; 913  :     assert(nbJobs > 0); assert((nbJobs & (nbJobs - 1)) == 0);  /* ensure nbJobs is a power of 2 */
; 914  :     mtctx->jobIDMask = nbJobs - 1;
; 915  :     mtctx->bufPool = ZSTDMT_createBufferPool(nbWorkers, cMem);
; 916  :     mtctx->cctxPool = ZSTDMT_createCCtxPool(nbWorkers, cMem);
; 917  :     mtctx->seqPool = ZSTDMT_createSeqPool(nbWorkers, cMem);
; 918  :     initError = ZSTDMT_serialState_init(&mtctx->serial);
; 919  :     mtctx->roundBuff = kNullRoundBuff;
; 920  :     if (!mtctx->factory | !mtctx->jobs | !mtctx->bufPool | !mtctx->cctxPool | !mtctx->seqPool | initError) {
; 921  :         ZSTDMT_freeCCtx(mtctx);
; 922  :         return NULL;
; 923  :     }
; 924  :     DEBUGLOG(3, "mt_cctx created, for %u threads", nbWorkers);
; 925  :     return mtctx;
; 926  : }
; 927  : 
; 928  : ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced(unsigned nbWorkers, ZSTD_customMem cMem)
; 929  : {
; 930  : #ifdef ZSTD_MULTITHREAD
; 931  :     return ZSTDMT_createCCtx_advanced_internal(nbWorkers, cMem);
; 932  : #else
; 933  :     (void)nbWorkers;
; 934  :     (void)cMem;
; 935  :     return NULL;
; 936  : #endif
; 937  : }
; 938  : 
; 939  : ZSTDMT_CCtx* ZSTDMT_createCCtx(unsigned nbWorkers)
; 940  : {
; 941  :     return ZSTDMT_createCCtx_advanced(nbWorkers, ZSTD_defaultCMem);
; 942  : }
; 943  : 
; 944  : 
; 945  : /* ZSTDMT_releaseAllJobResources() :
; 946  :  * note : ensure all workers are killed first ! */
; 947  : static void ZSTDMT_releaseAllJobResources(ZSTDMT_CCtx* mtctx)
; 948  : {
; 949  :     unsigned jobID;
; 950  :     DEBUGLOG(3, "ZSTDMT_releaseAllJobResources");
; 951  :     for (jobID=0; jobID <= mtctx->jobIDMask; jobID++) {
; 952  :         /* Copy the mutex/cond out */
; 953  :         ZSTD_pthread_mutex_t const mutex = mtctx->jobs[jobID].job_mutex;
; 954  :         ZSTD_pthread_cond_t const cond = mtctx->jobs[jobID].job_cond;
; 955  : 
; 956  :         DEBUGLOG(4, "job%02u: release dst address %08X", jobID, (U32)(size_t)mtctx->jobs[jobID].dstBuff.start);
; 957  :         ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[jobID].dstBuff);
; 958  : 
; 959  :         /* Clear the job description, but keep the mutex/cond */
; 960  :         memset(&mtctx->jobs[jobID], 0, sizeof(mtctx->jobs[jobID]));
; 961  :         mtctx->jobs[jobID].job_mutex = mutex;
; 962  :         mtctx->jobs[jobID].job_cond = cond;
; 963  :     }
; 964  :     mtctx->inBuff.buffer = g_nullBuffer;
; 965  :     mtctx->inBuff.filled = 0;
; 966  :     mtctx->allJobsCompleted = 1;
; 967  : }
; 968  : 
; 969  : static void ZSTDMT_waitForAllJobsCompleted(ZSTDMT_CCtx* mtctx)
; 970  : {
; 971  :     DEBUGLOG(4, "ZSTDMT_waitForAllJobsCompleted");
; 972  :     while (mtctx->doneJobID < mtctx->nextJobID) {
; 973  :         unsigned const jobID = mtctx->doneJobID & mtctx->jobIDMask;
; 974  :         ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[jobID].job_mutex);
; 975  :         while (mtctx->jobs[jobID].consumed < mtctx->jobs[jobID].src.size) {
; 976  :             DEBUGLOG(4, "waiting for jobCompleted signal from job %u", mtctx->doneJobID);   /* we want to block when waiting for data to flush */
; 977  :             ZSTD_pthread_cond_wait(&mtctx->jobs[jobID].job_cond, &mtctx->jobs[jobID].job_mutex);
; 978  :         }
; 979  :         ZSTD_pthread_mutex_unlock(&mtctx->jobs[jobID].job_mutex);
; 980  :         mtctx->doneJobID++;
; 981  :     }
; 982  : }
; 983  : 
; 984  : size_t ZSTDMT_freeCCtx(ZSTDMT_CCtx* mtctx)
; 985  : {
; 986  :     if (mtctx==NULL) return 0;   /* compatible with free on NULL */
; 987  :     POOL_free(mtctx->factory);   /* stop and free worker threads */
; 988  :     ZSTDMT_releaseAllJobResources(mtctx);  /* release job resources into pools first */
; 989  :     ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);
; 990  :     ZSTDMT_freeBufferPool(mtctx->bufPool);
; 991  :     ZSTDMT_freeCCtxPool(mtctx->cctxPool);
; 992  :     ZSTDMT_freeSeqPool(mtctx->seqPool);
; 993  :     ZSTDMT_serialState_free(&mtctx->serial);
; 994  :     ZSTD_freeCDict(mtctx->cdictLocal);
; 995  :     if (mtctx->roundBuff.buffer)
; 996  :         ZSTD_free(mtctx->roundBuff.buffer, mtctx->cMem);
; 997  :     ZSTD_free(mtctx, mtctx->cMem);
; 998  :     return 0;
; 999  : }
; 1000 : 
; 1001 : size_t ZSTDMT_sizeof_CCtx(ZSTDMT_CCtx* mtctx)
; 1002 : {
; 1003 :     if (mtctx == NULL) return 0;   /* supports sizeof NULL */
; 1004 :     return sizeof(*mtctx)
; 1005 :             + POOL_sizeof(mtctx->factory)
; 1006 :             + ZSTDMT_sizeof_bufferPool(mtctx->bufPool)
; 1007 :             + (mtctx->jobIDMask+1) * sizeof(ZSTDMT_jobDescription)
; 1008 :             + ZSTDMT_sizeof_CCtxPool(mtctx->cctxPool)
; 1009 :             + ZSTDMT_sizeof_seqPool(mtctx->seqPool)
; 1010 :             + ZSTD_sizeof_CDict(mtctx->cdictLocal)
; 1011 :             + mtctx->roundBuff.capacity;
; 1012 : }
; 1013 : 
; 1014 : /* Internal only */
; 1015 : size_t
; 1016 : ZSTDMT_CCtxParam_setMTCtxParameter(ZSTD_CCtx_params* params,
; 1017 :                                    ZSTDMT_parameter parameter,
; 1018 :                                    int value)
; 1019 : {
; 1020 :     DEBUGLOG(4, "ZSTDMT_CCtxParam_setMTCtxParameter");
; 1021 :     switch(parameter)
; 1022 :     {
; 1023 :     case ZSTDMT_p_jobSize :
; 1024 :         DEBUGLOG(4, "ZSTDMT_CCtxParam_setMTCtxParameter : set jobSize to %i", value);
; 1025 :         return ZSTD_CCtxParams_setParameter(params, ZSTD_c_jobSize, value);
; 1026 :     case ZSTDMT_p_overlapLog :
; 1027 :         DEBUGLOG(4, "ZSTDMT_p_overlapLog : %i", value);
; 1028 :         return ZSTD_CCtxParams_setParameter(params, ZSTD_c_overlapLog, value);
; 1029 :     case ZSTDMT_p_rsyncable :
; 1030 :         DEBUGLOG(4, "ZSTD_p_rsyncable : %i", value);
; 1031 :         return ZSTD_CCtxParams_setParameter(params, ZSTD_c_rsyncable, value);
; 1032 :     default :
; 1033 :         return ERROR(parameter_unsupported);
; 1034 :     }
; 1035 : }
; 1036 : 
; 1037 : size_t ZSTDMT_setMTCtxParameter(ZSTDMT_CCtx* mtctx, ZSTDMT_parameter parameter, int value)
; 1038 : {
; 1039 :     DEBUGLOG(4, "ZSTDMT_setMTCtxParameter");
; 1040 :     return ZSTDMT_CCtxParam_setMTCtxParameter(&mtctx->params, parameter, value);
; 1041 : }
; 1042 : 
; 1043 : size_t ZSTDMT_getMTCtxParameter(ZSTDMT_CCtx* mtctx, ZSTDMT_parameter parameter, int* value)
; 1044 : {
; 1045 :     switch (parameter) {
; 1046 :     case ZSTDMT_p_jobSize:
; 1047 :         return ZSTD_CCtxParams_getParameter(&mtctx->params, ZSTD_c_jobSize, value);
; 1048 :     case ZSTDMT_p_overlapLog:
; 1049 :         return ZSTD_CCtxParams_getParameter(&mtctx->params, ZSTD_c_overlapLog, value);
; 1050 :     case ZSTDMT_p_rsyncable:
; 1051 :         return ZSTD_CCtxParams_getParameter(&mtctx->params, ZSTD_c_rsyncable, value);
; 1052 :     default:
; 1053 :         return ERROR(parameter_unsupported);
; 1054 :     }
; 1055 : }
; 1056 : 
; 1057 : /* Sets parameters relevant to the compression job,
; 1058 :  * initializing others to default values. */
; 1059 : static ZSTD_CCtx_params ZSTDMT_initJobCCtxParams(const ZSTD_CCtx_params* params)
; 1060 : {
; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movups	XMMWORD PTR $T9[rbp-128], xmm1

; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));

	mov	DWORD PTR $T9[rbp-116], eax

; 1440 :         return ZSTD_initCStream_internal(mtctx->cctxPool->cctx[0],

	mov	rax, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3699 :     zcs->requestedParams = *params;

	movups	xmm1, XMMWORD PTR $T9[rbp-192]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));

	movups	XMMWORD PTR $T9[rbp-164], xmm0

; 1440 :         return ZSTD_initCStream_internal(mtctx->cctxPool->cctx[0],

	mov	rbx, QWORD PTR [rax+72]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 849  :     cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;

	lea	rax, QWORD PTR [rdi+1]

; 3701 :     if (dict) {

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));

	movups	XMMWORD PTR $T9[rbp-148], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 966  :         cctx->streamStage = zcss_init;

	mov	DWORD PTR [rbx+1072], r14d

; 849  :     cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;

	mov	QWORD PTR [rbx+384], rax

; 3699 :     zcs->requestedParams = *params;

	movups	XMMWORD PTR [rbx+16], xmm2
	movups	XMMWORD PTR [rbx+32], xmm3
	movups	XMMWORD PTR [rbx+48], xmm4
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));

	movups	XMMWORD PTR $T9[rbp-132], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3699 :     zcs->requestedParams = *params;

	movups	xmm0, XMMWORD PTR $T9[rbp-208]
	movups	XMMWORD PTR [rbx+64], xmm0
	movups	xmm0, XMMWORD PTR $T9[rbp-176]
	movups	XMMWORD PTR [rbx+80], xmm1
	movups	xmm1, XMMWORD PTR $T9[rbp-160]
	movups	XMMWORD PTR [rbx+96], xmm0
	movups	xmm0, XMMWORD PTR $T9[rbp-144]
	movups	XMMWORD PTR [rbx+112], xmm1
	movups	xmm1, XMMWORD PTR $T9[rbp-128]
	movups	XMMWORD PTR [rbx+128], xmm0
	movups	XMMWORD PTR [rbx+144], xmm1

; 3700 :     assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
; 3701 :     if (dict) {

	test	rdx, rdx
	je	SHORT $LN619@ZSTDMT_ini

; 926  :     return ZSTD_CCtx_loadDictionary_advanced(

	call	ZSTD_CCtx_loadDictionary_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3702 :         FORWARD_IF_ERROR( ZSTD_CCtx_loadDictionary(zcs, dict, dictSize) , "");

	jbe	SHORT $LN618@ZSTDMT_ini
	jmp	$LN1@ZSTDMT_ini
$LN619@ZSTDMT_ini:

; 936  :     ZSTD_clearAllDicts(cctx);

	call	ZSTD_clearAllDicts

; 937  :     cctx->cdict = cdict;

	mov	rax, QWORD PTR cdict$[rbp-256]
	mov	QWORD PTR [rbx+1120], rax
$LN618@ZSTDMT_ini:

; 3707 :     return 0;

	mov	rax, r14
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1440 :         return ZSTD_initCStream_internal(mtctx->cctxPool->cctx[0],

	jmp	$LN1@ZSTDMT_ini
$LN10@ZSTDMT_ini:

; 1441 :                                          dict, dictSize, cdict,
; 1442 :                                          &singleThreadParams, pledgedSrcSize);
; 1443 :     }
; 1444 : 
; 1445 :     DEBUGLOG(4, "ZSTDMT_initCStream_internal: %u workers", params.nbWorkers);
; 1446 : 
; 1447 :     if (mtctx->allJobsCompleted == 0) {   /* previous compression not correctly finished */

	mov	r12d, 1
	cmp	DWORD PTR [rsi+748], r14d
	jne	SHORT $LN11@ZSTDMT_ini

; 1448 :         ZSTDMT_waitForAllJobsCompleted(mtctx);

	mov	rcx, rsi
	call	ZSTDMT_waitForAllJobsCompleted

; 1449 :         ZSTDMT_releaseAllJobResources(mtctx);

	mov	rcx, rsi
	call	ZSTDMT_releaseAllJobResources

; 1450 :         mtctx->allJobsCompleted = 1;

	mov	DWORD PTR [rsi+748], r12d
$LN11@ZSTDMT_ini:

; 1451 :     }
; 1452 : 
; 1453 :     mtctx->params = params;

	movaps	xmm0, XMMWORD PTR [r13]
	movaps	xmm1, XMMWORD PTR [r13+16]

; 1454 :     mtctx->frameContentSize = pledgedSrcSize;

	mov	rcx, QWORD PTR [rsi+800]

; 1455 :     if (dict) {

	mov	rbx, QWORD PTR dict$GSCopy$1$[rsp]
	movups	XMMWORD PTR [rsi+40], xmm0
	mov	QWORD PTR [rsi+752], rdi
	movaps	xmm0, XMMWORD PTR [r13+32]
	movups	XMMWORD PTR [rsi+56], xmm1
	movaps	xmm1, XMMWORD PTR [r13+48]
	movups	XMMWORD PTR [rsi+72], xmm0
	movaps	xmm0, XMMWORD PTR [r13+64]
	movups	XMMWORD PTR [rsi+88], xmm1
	movaps	xmm1, XMMWORD PTR [r13+80]
	movups	XMMWORD PTR [rsi+104], xmm0
	movaps	xmm0, XMMWORD PTR [r13+96]
	movups	XMMWORD PTR [rsi+120], xmm1
	movaps	xmm1, XMMWORD PTR [r13+112]
	movups	XMMWORD PTR [rsi+136], xmm0
	movaps	xmm0, XMMWORD PTR [r13+128]
	movups	XMMWORD PTR [rsi+152], xmm1
	movups	XMMWORD PTR [rsi+168], xmm0
	call	ZSTD_freeCDict
	test	rbx, rbx
	je	SHORT $LN12@ZSTDMT_ini

; 1456 :         ZSTD_freeCDict(mtctx->cdictLocal);
; 1457 :         mtctx->cdictLocal = ZSTD_createCDict_advanced(dict, dictSize,

	movups	xmm0, XMMWORD PTR [rsi+776]
	xor	r8d, r8d
	mov	eax, DWORD PTR [r13+28]
	movsd	xmm1, QWORD PTR [rsi+792]
	mov	rcx, rbx
	mov	r9d, DWORD PTR dictContentType$1$[rsp]
	mov	rdx, QWORD PTR dictSize$GSCopy$1$[rsp]
	mov	DWORD PTR $T7[rbp-232], eax
	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T7[rbp-256]
	movaps	XMMWORD PTR $T5[rsp], xmm0
	movups	xmm0, XMMWORD PTR [r13+4]
	mov	QWORD PTR [rsp+32], rax
	movsd	QWORD PTR $T5[rsp+16], xmm1
	movsd	xmm1, QWORD PTR [r13+20]
	movaps	XMMWORD PTR $T7[rbp-256], xmm0
	movsd	QWORD PTR $T7[rbp-240], xmm1
	call	ZSTD_createCDict_advanced
	mov	QWORD PTR [rsi+800], rax

; 1458 :                                                     ZSTD_dlm_byCopy, dictContentType, /* note : a loadPrefix becomes an internal CDict */
; 1459 :                                                     params.cParams, mtctx->cMem);
; 1460 :         mtctx->cdict = mtctx->cdictLocal;

	mov	QWORD PTR [rsi+808], rax

; 1461 :         if (mtctx->cdictLocal == NULL) return ERROR(memory_allocation);

	test	rax, rax
	jne	SHORT $LN13@ZSTDMT_ini

; 1531 : }

	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN1@ZSTDMT_ini
$LN12@ZSTDMT_ini:

; 1462 :     } else {
; 1463 :         ZSTD_freeCDict(mtctx->cdictLocal);
; 1464 :         mtctx->cdictLocal = NULL;
; 1465 :         mtctx->cdict = cdict;

	mov	rax, QWORD PTR cdict$[rbp-256]
	mov	QWORD PTR [rsi+808], rax
	mov	QWORD PTR [rsi+800], r14
$LN13@ZSTDMT_ini:

; 1466 :     }
; 1467 : 
; 1468 :     mtctx->targetPrefixSize = ZSTDMT_computeOverlapSize(&params);

	mov	rcx, r13
	call	ZSTDMT_computeOverlapSize
	mov	QWORD PTR [rsi+192], rax
	mov	r8, rax

; 1469 :     DEBUGLOG(4, "overlapLog=%i => %u KB", params.overlapLog, (U32)(mtctx->targetPrefixSize>>10));
; 1470 :     mtctx->targetSectionSize = params.jobSize;

	mov	QWORD PTR [rsi+184], r15

; 1471 :     if (mtctx->targetSectionSize == 0) {

	test	r15, r15
	jne	SHORT $LN15@ZSTDMT_ini

; 1472 :         mtctx->targetSectionSize = 1ULL << ZSTDMT_computeTargetJobLog(&params);

	mov	rcx, r13
	call	ZSTDMT_computeTargetJobLog
	mov	ecx, eax
	mov	r15, r12
	shl	r15, cl
	mov	QWORD PTR [rsi+184], r15
$LN15@ZSTDMT_ini:

; 1473 :     }
; 1474 :     assert(mtctx->targetSectionSize <= (size_t)ZSTDMT_JOBSIZE_MAX);
; 1475 : 
; 1476 :     if (params.rsyncable) {

	cmp	DWORD PTR [r13+92], r14d
	je	SHORT $LN16@ZSTDMT_ini

; 1477 :         /* Aim for the targetsectionSize as the average job size. */
; 1478 :         U32 const jobSizeMB = (U32)(mtctx->targetSectionSize >> 20);

	shr	r15, 20
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r14d
	bsr	eax, r15d
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1482 :         mtctx->rsync.hash = 0;

	mov	QWORD PTR [rsi+704], r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 647  :     U64 power = 1;

	mov	rdx, r12
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1483 :         mtctx->rsync.hitMask = (1ULL << rsyncBits) - 1;

	mov	rax, r12
	add	ecx, 20
	shl	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	mov	ecx, 31
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1483 :         mtctx->rsync.hitMask = (1ULL << rsyncBits) - 1;

	dec	rax
	mov	QWORD PTR [rsi+712], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
$LL668@ZSTDMT_ini:

; 649  :       if (exponent & 1) power *= base;

	test	cl, r12b
	je	SHORT $LN670@ZSTDMT_ini
	imul	rdx, rax
$LN670@ZSTDMT_ini:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rax, rax
	shr	rcx, 1
	jne	SHORT $LL668@ZSTDMT_ini
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 545  :             CCtxParams->compressionLevel = value;

	mov	r15, QWORD PTR [rsi+184]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1484 :         mtctx->rsync.primePower = ZSTD_rollingHash_primePower(RSYNC_LENGTH);

	mov	QWORD PTR [rsi+720], rdx
$LN16@ZSTDMT_ini:

; 1485 :     }
; 1486 :     if (mtctx->targetSectionSize < mtctx->targetPrefixSize) mtctx->targetSectionSize = mtctx->targetPrefixSize;  /* job size must be >= overlap size */

	cmp	r15, r8
	jae	SHORT $LN17@ZSTDMT_ini
	mov	QWORD PTR [rsi+184], r8
	mov	r15, r8
$LN17@ZSTDMT_ini:

; 1487 :     DEBUGLOG(4, "Job Size : %u KB (note : set to %u)", (U32)(mtctx->targetSectionSize>>10), (U32)params.jobSize);
; 1488 :     DEBUGLOG(4, "inBuff Size : %u KB", (U32)(mtctx->targetSectionSize>>10));
; 1489 :     ZSTDMT_setBufferSize(mtctx->bufPool, ZSTD_compressBound(mtctx->targetSectionSize));

	mov	rbx, QWORD PTR [rsi+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	eax, 131072				; 00020000H
	sub	rax, r15
	mov	rdi, r14
	shr	rax, 11
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	cmp	r15, 131072				; 00020000H
	cmovb	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	rax, r15
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	shr	rax, 8
	add	rax, r15
	add	rax, rdi
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 159  :     bufPool->bufferSize = bSize;

	mov	QWORD PTR [rbx+40], rax

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 1490 :     {
; 1491 :         /* If ldm is enabled we need windowSize space. */
; 1492 :         size_t const windowSize = mtctx->params.ldmParams.enableLdm ? (1U << mtctx->params.cParams.windowLog) : 0;

	cmp	DWORD PTR [rsi+136], r14d
	je	SHORT $LN23@ZSTDMT_ini
	mov	ecx, DWORD PTR [rsi+44]
	mov	eax, r12d
	shl	eax, cl
	jmp	SHORT $LN24@ZSTDMT_ini
$LN23@ZSTDMT_ini:
	mov	eax, r14d
$LN24@ZSTDMT_ini:

; 1493 :         /* Two buffers of slack, plus extra space for the overlap
; 1494 :          * This is the minimum slack that LDM works with. One extra because
; 1495 :          * flush might waste up to targetSectionSize-1 bytes. Another extra
; 1496 :          * for the overlap (if > 0), then one to fill which doesn't overlap
; 1497 :          * with the LDM window.
; 1498 :          */
; 1499 :         size_t const nbSlackBuffers = 2 + (mtctx->targetPrefixSize > 0);

	cmp	QWORD PTR [rsi+192], r14
	mov	rdx, r14

; 1500 :         size_t const slackSize = mtctx->targetSectionSize * nbSlackBuffers;

	mov	r9, QWORD PTR [rsi+184]
	seta	dl
	mov	ecx, eax
	add	rdx, 2
	imul	rdx, r9

; 1501 :         /* Compute the total size, and always have enough slack */
; 1502 :         size_t const nbWorkers = MAX(mtctx->params.nbWorkers, 1);

	cmp	DWORD PTR [rsi+116], r12d
	cmovg	r12d, DWORD PTR [rsi+116]
	movsxd	rbx, r12d

; 1503 :         size_t const sectionsSize = mtctx->targetSectionSize * nbWorkers;

	imul	rbx, r9

; 1504 :         size_t const capacity = MAX(windowSize, sectionsSize) + slackSize;

	cmp	rcx, rbx
	cmova	rbx, rcx
	add	rbx, rdx

; 1505 :         if (mtctx->roundBuff.capacity < capacity) {

	cmp	QWORD PTR [rsi+256], rbx
	jae	$LN18@ZSTDMT_ini

; 1506 :             if (mtctx->roundBuff.buffer)

	mov	rcx, QWORD PTR [rsi+248]
	test	rcx, rcx
	je	SHORT $LN681@ZSTDMT_ini

; 1507 :                 ZSTD_free(mtctx->roundBuff.buffer, mtctx->cMem);

	movups	xmm1, XMMWORD PTR [rsi+776]
	movsd	xmm0, QWORD PTR [rsi+792]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1507 :                 ZSTD_free(mtctx->roundBuff.buffer, mtctx->cMem);

	movsd	QWORD PTR $T4[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN680@ZSTDMT_ini

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T4[rsp+16]
	call	rax
	jmp	SHORT $LN681@ZSTDMT_ini
$LN680@ZSTDMT_ini:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN681@ZSTDMT_ini:

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rsi+776]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1508 :             mtctx->roundBuff.buffer = (BYTE*)ZSTD_malloc(capacity, mtctx->cMem);

	movsd	xmm0, QWORD PTR [rsi+792]
	movsd	QWORD PTR $T3[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN684@ZSTDMT_ini

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T3[rsp+16]
	mov	rdx, rbx
	call	rax
	jmp	SHORT $LN683@ZSTDMT_ini
$LN684@ZSTDMT_ini:

; 60   :     return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
$LN683@ZSTDMT_ini:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1508 :             mtctx->roundBuff.buffer = (BYTE*)ZSTD_malloc(capacity, mtctx->cMem);

	mov	QWORD PTR [rsi+248], rax

; 1509 :             if (mtctx->roundBuff.buffer == NULL) {

	test	rax, rax
	jne	SHORT $LN20@ZSTDMT_ini

; 1510 :                 mtctx->roundBuff.capacity = 0;

	mov	QWORD PTR [rsi+256], r14

; 1511 :                 return ERROR(memory_allocation);

	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN1@ZSTDMT_ini
$LN20@ZSTDMT_ini:

; 1512 :             }
; 1513 :             mtctx->roundBuff.capacity = capacity;

	mov	r9, QWORD PTR [rsi+184]
	mov	QWORD PTR [rsi+256], rbx
$LN18@ZSTDMT_ini:

; 1514 :         }
; 1515 :     }
; 1516 :     DEBUGLOG(4, "roundBuff capacity : %u KB", (U32)(mtctx->roundBuff.capacity>>10));
; 1517 :     mtctx->roundBuff.pos = 0;
; 1518 :     mtctx->inBuff.buffer = g_nullBuffer;

	movaps	xmm0, XMMWORD PTR g_nullBuffer

; 1519 :     mtctx->inBuff.filled = 0;
; 1520 :     mtctx->inBuff.prefix = kNullRange;
; 1521 :     mtctx->doneJobID = 0;
; 1522 :     mtctx->nextJobID = 0;
; 1523 :     mtctx->frameEnded = 0;
; 1524 :     mtctx->allJobsCompleted = 0;
; 1525 :     mtctx->consumed = 0;
; 1526 :     mtctx->produced = 0;
; 1527 :     if (ZSTDMT_serialState_reset(&mtctx->serial, mtctx->seqPool, params, mtctx->targetSectionSize,

	lea	rcx, QWORD PTR [rsi+272]
	movaps	xmm1, XMMWORD PTR [r13+16]
	lea	r8, QWORD PTR $T8[rbp-256]
	mov	eax, DWORD PTR dictContentType$1$[rsp]
	mov	rdx, QWORD PTR [rsi+32]
	movups	XMMWORD PTR [rsi+224], xmm0
	mov	DWORD PTR [rsp+48], eax
	movups	xmm0, XMMWORD PTR kNullRange
	mov	rax, QWORD PTR dictSize$GSCopy$1$[rsp]
	movaps	XMMWORD PTR $T8[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR [r13+48]
	movups	XMMWORD PTR [rsi+208], xmm0
	mov	QWORD PTR [rsp+40], rax
	movaps	xmm0, XMMWORD PTR [r13]
	mov	rax, QWORD PTR dict$GSCopy$1$[rsp]
	movaps	XMMWORD PTR $T8[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR [r13+32]
	movaps	XMMWORD PTR $T8[rbp-224], xmm0
	movaps	xmm0, XMMWORD PTR [r13+64]
	movaps	XMMWORD PTR $T8[rbp-192], xmm0
	movaps	xmm0, XMMWORD PTR [r13+96]
	movaps	XMMWORD PTR $T8[rbp-208], xmm1
	movaps	xmm1, XMMWORD PTR [r13+80]
	movaps	XMMWORD PTR $T8[rbp-160], xmm0
	movaps	xmm0, XMMWORD PTR [r13+128]
	movaps	XMMWORD PTR $T8[rbp-176], xmm1
	movaps	xmm1, XMMWORD PTR [r13+112]
	movaps	XMMWORD PTR $T8[rbp-128], xmm0
	mov	QWORD PTR [rsi+264], r14
	mov	QWORD PTR [rsi+240], r14
	mov	QWORD PTR [rsi+736], r14
	mov	QWORD PTR [rsi+744], r14
	mov	QWORD PTR [rsi+760], r14
	mov	QWORD PTR [rsi+768], r14
	movaps	XMMWORD PTR $T8[rbp-144], xmm1
	mov	QWORD PTR [rsp+32], rax
	call	ZSTDMT_serialState_reset
	test	eax, eax
	jne	$LN698@ZSTDMT_ini

; 1528 :                                  dict, dictSize, dictContentType))
; 1529 :         return ERROR(memory_allocation);
; 1530 :     return 0;

	xor	eax, eax
$LN1@ZSTDMT_ini:

; 1531 : }

	mov	rbx, QWORD PTR [rsp+392]
	add	rsp, 304				; 00000130H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTDMT_initCStream_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 64
syncPoint$2 = 64
$T3 = 80
$T4 = 112
mtctx$ = 304
output$ = 312
input$ = 320
endOp$ = 328
ZSTDMT_compressStream_generic PROC

; 2018 : {

$LN99:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 256				; 00000100H

; 2019 :     unsigned forwardInputProgress = 0;

	xor	r12d, r12d
	mov	esi, r9d
	mov	r14, r8
	mov	r15, rdx
	mov	rdi, rcx
	mov	r13d, r12d

; 2020 :     DEBUGLOG(5, "ZSTDMT_compressStream_generic (endOp=%u, srcSize=%u)",
; 2021 :                 (U32)endOp, (U32)(input->size - input->pos));
; 2022 :     assert(output->pos <= output->size);
; 2023 :     assert(input->pos  <= input->size);
; 2024 : 
; 2025 :     if (mtctx->singleBlockingThread) {  /* delegate to single-thread (synchronous) */

	cmp	DWORD PTR [rcx+728], r12d
	je	SHORT $LN5@ZSTDMT_com

; 2026 :         return ZSTD_compressStream2(mtctx->cctxPool->cctx[0], output, input, endOp);

	mov	rcx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rcx+72]
	call	ZSTD_compressStream2
	jmp	$LN1@ZSTDMT_com
$LN5@ZSTDMT_com:

; 2027 :     }
; 2028 : 
; 2029 :     if ((mtctx->frameEnded) && (endOp==ZSTD_e_continue)) {

	cmp	DWORD PTR [rcx+744], r12d
	je	SHORT $LN6@ZSTDMT_com
	test	esi, esi
	jne	SHORT $LN6@ZSTDMT_com

; 2030 :         /* current frame being ended. Only flush/end are allowed */
; 2031 :         return ERROR(stage_wrong);

	mov	rax, -60				; ffffffffffffffc4H
	jmp	$LN1@ZSTDMT_com
$LN6@ZSTDMT_com:
	mov	QWORD PTR [rsp+312], rbp

; 2032 :     }
; 2033 : 
; 2034 :     /* single-pass shortcut (note : synchronous-mode) */
; 2035 :     if ( (!mtctx->params.rsyncable)   /* rsyncable mode is disabled */
; 2036 :       && (mtctx->nextJobID == 0)      /* just started */
; 2037 :       && (mtctx->inBuff.filled == 0)  /* nothing buffered */
; 2038 :       && (!mtctx->jobReady)           /* no job already created */
; 2039 :       && (endOp == ZSTD_e_end)        /* end order */
; 2040 :       && (output->size - output->pos >= ZSTD_compressBound(input->size - input->pos)) ) { /* enough space in dst */

	cmp	DWORD PTR [rcx+132], r12d
	jne	$LN7@ZSTDMT_com
	cmp	DWORD PTR [rcx+740], r12d
	jne	$LN7@ZSTDMT_com
	cmp	QWORD PTR [rcx+240], r12
	jne	$LN7@ZSTDMT_com
	cmp	DWORD PTR [rcx+200], r12d
	jne	$LN7@ZSTDMT_com
	cmp	esi, 2
	jne	$LN7@ZSTDMT_com
	mov	r9, QWORD PTR [r8+16]
	mov	rcx, QWORD PTR [r8+8]
	mov	r8, QWORD PTR [rdx+8]
	sub	rcx, r9
	mov	r10, QWORD PTR [rdx+16]
	sub	r8, r10
	call	ZSTD_compressBound
	cmp	r8, rax
	jb	$LN7@ZSTDMT_com

; 2041 :         size_t const cSize = ZSTDMT_compress_advanced_internal(mtctx,

	movups	xmm0, XMMWORD PTR [rdi+40]
	mov	rdx, QWORD PTR [r15]
	lea	rax, QWORD PTR $T4[rsp]
	movups	xmm1, XMMWORD PTR [rdi+56]
	add	r9, QWORD PTR [r14]
	add	rdx, r10
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rdi+72]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR [rdi+808]
	movaps	XMMWORD PTR $T4[rsp+32], xmm0
	movups	xmm0, XMMWORD PTR [rdi+104]
	mov	QWORD PTR [rsp+40], rax
	movaps	XMMWORD PTR $T4[rsp+16], xmm1
	movups	xmm1, XMMWORD PTR [rdi+88]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rdi
	movaps	XMMWORD PTR $T4[rsp+64], xmm0
	movups	xmm0, XMMWORD PTR [rdi+136]
	movaps	XMMWORD PTR $T4[rsp+48], xmm1
	movups	xmm1, XMMWORD PTR [rdi+120]
	movaps	XMMWORD PTR $T4[rsp+96], xmm0
	movups	xmm0, XMMWORD PTR [rdi+168]
	movaps	XMMWORD PTR $T4[rsp+80], xmm1
	movups	xmm1, XMMWORD PTR [rdi+152]
	movaps	XMMWORD PTR $T4[rsp+128], xmm0
	movaps	XMMWORD PTR $T4[rsp+112], xmm1
	call	ZSTDMT_compress_advanced_internal
	mov	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 2045 :         if (ZSTD_isError(cSize)) return cSize;

	ja	$LN21@ZSTDMT_com

; 2046 :         input->pos = input->size;

	mov	rax, QWORD PTR [r14+8]

; 2047 :         output->pos += cSize;
; 2048 :         mtctx->allJobsCompleted = 1;

	mov	ebp, 1
	add	QWORD PTR [r15+16], rcx
	mov	QWORD PTR [r14+16], rax

; 2049 :         mtctx->frameEnded = 1;
; 2050 :         return 0;

	xor	eax, eax
	mov	DWORD PTR [rdi+748], ebp
	mov	DWORD PTR [rdi+744], ebp
	jmp	$LN21@ZSTDMT_com
$LN7@ZSTDMT_com:

; 2051 :     }
; 2052 : 
; 2053 :     /* fill input buffer */
; 2054 :     if ( (!mtctx->jobReady)
; 2055 :       && (input->size > input->pos) ) {   /* support NULL input */

	mov	ebp, 1
	cmp	DWORD PTR [rdi+200], r12d
	jne	$LN17@ZSTDMT_com
	mov	rax, QWORD PTR [r14+16]
	cmp	QWORD PTR [r14+8], rax
	jbe	$LN15@ZSTDMT_com

; 2056 :         if (mtctx->inBuff.buffer.start == NULL) {

	mov	QWORD PTR [rsp+304], rbx
	mov	rbx, QWORD PTR [rdi+224]
	test	rbx, rbx
	jne	SHORT $LN97@ZSTDMT_com

; 2057 :             assert(mtctx->inBuff.filled == 0); /* Can't fill an empty buffer */
; 2058 :             if (!ZSTDMT_tryGetInputRange(mtctx)) {

	mov	rcx, rdi
	call	ZSTDMT_tryGetInputRange
	mov	rbx, QWORD PTR [rdi+224]

; 2059 :                 /* It is only possible for this operation to fail if there are
; 2060 :                  * still compression jobs ongoing.
; 2061 :                  */
; 2062 :                 DEBUGLOG(5, "ZSTDMT_tryGetInputRange failed");
; 2063 :                 assert(mtctx->doneJobID != mtctx->nextJobID);
; 2064 :             } else
; 2065 :                 DEBUGLOG(5, "ZSTDMT_tryGetInputRange completed successfully : mtctx->inBuff.buffer.start = %p", mtctx->inBuff.buffer.start);
; 2066 :         }
; 2067 :         if (mtctx->inBuff.buffer.start != NULL) {

	test	rbx, rbx
	je	SHORT $LN93@ZSTDMT_com
$LN97@ZSTDMT_com:

; 2068 :             syncPoint_t const syncPoint = findSynchronizationPoint(mtctx, *input);

	movups	xmm0, XMMWORD PTR [r14]
	lea	r8, QWORD PTR $T3[rsp]
	mov	rdx, rdi
	movsd	xmm1, QWORD PTR [r14+16]
	lea	rcx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movsd	QWORD PTR $T3[rsp+16], xmm1
	call	findSynchronizationPoint
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR syncPoint$2[rsp], xmm0

; 2069 :             if (syncPoint.flush && endOp == ZSTD_e_continue) {

	psrldq	xmm0, 8
	movd	eax, xmm0
	test	eax, eax
	je	SHORT $LN14@ZSTDMT_com
	test	esi, esi
	cmove	esi, ebp
$LN14@ZSTDMT_com:

; 2070 :                 endOp = ZSTD_e_flush;
; 2071 :             }
; 2072 :             assert(mtctx->inBuff.buffer.capacity >= mtctx->targetSectionSize);
; 2073 :             DEBUGLOG(5, "ZSTDMT_compressStream_generic: adding %u bytes on top of %u to buffer of size %u",
; 2074 :                         (U32)syncPoint.toLoad, (U32)mtctx->inBuff.filled, (U32)mtctx->targetSectionSize);
; 2075 :             memcpy((char*)mtctx->inBuff.buffer.start + mtctx->inBuff.filled, (const char*)input->src + input->pos, syncPoint.toLoad);

	mov	rcx, QWORD PTR [rdi+240]
	mov	rdx, QWORD PTR [r14]
	add	rcx, rbx
	mov	rbx, QWORD PTR syncPoint$2[rsp]
	add	rdx, QWORD PTR [r14+16]
	mov	r8, rbx
	call	memcpy

; 2076 :             input->pos += syncPoint.toLoad;

	add	QWORD PTR [r14+16], rbx

; 2077 :             mtctx->inBuff.filled += syncPoint.toLoad;

	add	QWORD PTR [rdi+240], rbx

; 2078 :             forwardInputProgress = syncPoint.toLoad>0;

	test	rbx, rbx
	setne	r13b
$LN93@ZSTDMT_com:

; 2079 :         }
; 2080 :         if ((input->pos < input->size) && (endOp == ZSTD_e_end))

	mov	rax, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [rsp+304]
	cmp	QWORD PTR [r14+16], rax
	jae	SHORT $LN15@ZSTDMT_com
	cmp	esi, 2
	cmove	esi, ebp
$LN15@ZSTDMT_com:

; 2081 :             endOp = ZSTD_e_flush;   /* can't end now : not all input consumed */
; 2082 :     }
; 2083 : 
; 2084 :     if ( (mtctx->jobReady)
; 2085 :       || (mtctx->inBuff.filled >= mtctx->targetSectionSize)  /* filled enough : let's compress */
; 2086 :       || ((endOp != ZSTD_e_continue) && (mtctx->inBuff.filled > 0))  /* something to flush : let's go */
; 2087 :       || ((endOp == ZSTD_e_end) && (!mtctx->frameEnded)) ) {   /* must finish the frame with a zero-size block */

	cmp	DWORD PTR [rdi+200], r12d
	jne	SHORT $LN17@ZSTDMT_com
	mov	rax, QWORD PTR [rdi+240]
	cmp	rax, QWORD PTR [rdi+184]
	jae	SHORT $LN17@ZSTDMT_com
	test	esi, esi
	je	SHORT $LN3@ZSTDMT_com
	test	rax, rax
	jne	SHORT $LN17@ZSTDMT_com
	cmp	esi, 2
	jne	SHORT $LN3@ZSTDMT_com
	cmp	DWORD PTR [rdi+744], r12d
	jne	SHORT $LN3@ZSTDMT_com
$LN17@ZSTDMT_com:

; 2090 :         FORWARD_IF_ERROR( ZSTDMT_createCompressionJob(mtctx, jobSize, endOp) , "");

	mov	rdx, QWORD PTR [rdi+240]
	mov	r8d, esi
	mov	rcx, rdi
	call	ZSTDMT_createCompressionJob
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 2090 :         FORWARD_IF_ERROR( ZSTDMT_createCompressionJob(mtctx, jobSize, endOp) , "");

	ja	SHORT $LN21@ZSTDMT_com
$LN3@ZSTDMT_com:

; 2091 :     }
; 2092 : 
; 2093 :     /* check for potential compressed data ready to be flushed */
; 2094 :     {   size_t const remainingToFlush = ZSTDMT_flushProduced(mtctx, output, !forwardInputProgress, endOp); /* block if there was no forward input progress */

	test	r13d, r13d
	mov	r9d, esi
	mov	rdx, r15
	mov	rcx, rdi
	sete	r12b
	mov	r8d, r12d
	call	ZSTDMT_flushProduced

; 2095 :         if (input->pos < input->size) return MAX(remainingToFlush, 1);  /* input not consumed : do not end flush yet */

	mov	rcx, QWORD PTR [r14+8]
	cmp	QWORD PTR [r14+16], rcx
	jae	SHORT $LN21@ZSTDMT_com
	cmp	rax, rbp
	cmova	rbp, rax
	mov	rax, rbp
$LN21@ZSTDMT_com:
	mov	rbp, QWORD PTR [rsp+312]
$LN1@ZSTDMT_com:

; 2096 :         DEBUGLOG(5, "end of ZSTDMT_compressStream_generic: remainingToFlush = %u", (U32)remainingToFlush);
; 2097 :         return remainingToFlush;
; 2098 :     }
; 2099 : }

	mov	rsi, QWORD PTR [rsp+320]
	add	rsp, 256				; 00000100H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
ZSTDMT_compressStream_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
cParams$1 = 32
$T2 = 64
mtctx$ = 112
cctxParams$ = 120
ZSTDMT_updateCParams_whileCompressing PROC

; 1095 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 96					; 00000060H

; 1096 :     U32 const saved_wlog = mtctx->params.cParams.windowLog;   /* Do not modify windowLog while compressing */
; 1097 :     int const compressionLevel = cctxParams->compressionLevel;
; 1098 :     DEBUGLOG(5, "ZSTDMT_updateCParams_whileCompressing (level:%i)",
; 1099 :                 compressionLevel);
; 1100 :     mtctx->params.compressionLevel = compressionLevel;

	mov	eax, DWORD PTR [rdx+44]

; 1101 :     {   ZSTD_compressionParameters cParams = ZSTD_getCParamsFromCCtxParams(cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, 0);

	xor	r9d, r9d
	mov	ebx, DWORD PTR [rcx+44]
	mov	rdi, rcx
	mov	DWORD PTR [rcx+84], eax
	lea	rcx, QWORD PTR $T2[rsp]
	lea	r8, QWORD PTR [r9-1]
	call	ZSTD_getCParamsFromCCtxParams
	movups	xmm3, XMMWORD PTR [rax]
	mov	ecx, DWORD PTR [rax+24]
	movsd	xmm1, QWORD PTR [rax+16]
	movups	XMMWORD PTR cParams$1[rsp], xmm3

; 1102 :         cParams.windowLog = saved_wlog;

	mov	DWORD PTR cParams$1[rsp], ebx

; 1103 :         mtctx->params.cParams = cParams;

	movups	xmm0, XMMWORD PTR cParams$1[rsp]

; 1104 :     }
; 1105 : }

	mov	rbx, QWORD PTR [rsp+112]
	movups	XMMWORD PTR [rdi+44], xmm0
	movsd	QWORD PTR [rdi+60], xmm1
	mov	DWORD PTR [rdi+68], ecx
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
ZSTDMT_updateCParams_whileCompressing ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
cMem$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
mtctx$ = 80
ZSTDMT_freeCCtx PROC

; 985  : {

$LN46:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx

; 986  :     if (mtctx==NULL) return 0;   /* compatible with free on NULL */

	test	rcx, rcx
	je	$LN44@ZSTDMT_fre

; 987  :     POOL_free(mtctx->factory);   /* stop and free worker threads */

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+96], rdi
	call	POOL_free

; 988  :     ZSTDMT_releaseAllJobResources(mtctx);  /* release job resources into pools first */

	mov	rcx, rbx
	call	ZSTDMT_releaseAllJobResources

; 989  :     ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);

	movups	xmm0, XMMWORD PTR [rbx+776]
	mov	rbp, QWORD PTR [rbx+8]
	movsd	xmm1, QWORD PTR [rbx+792]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movsd	QWORD PTR $T4[rsp+16], xmm1

; 840  :     if (jobTable == NULL) return;

	test	rbp, rbp
	je	SHORT $LN14@ZSTDMT_fre

; 989  :     ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);

	mov	eax, DWORD PTR [rbx+732]
	add	eax, 1

; 841  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	je	SHORT $LN7@ZSTDMT_fre

; 989  :     ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);

	lea	rdi, QWORD PTR [rbp+16]
	mov	esi, eax
$LL8@ZSTDMT_fre:

; 842  :         ZSTD_pthread_mutex_destroy(&jobTable[jobNb].job_mutex);

	mov	rcx, rdi
	call	QWORD PTR __imp_DeleteCriticalSection
	add	rdi, 336				; 00000150H
	sub	rsi, 1
	jne	SHORT $LL8@ZSTDMT_fre
$LN7@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T4[rsp+8]
	test	rax, rax
	je	SHORT $LN13@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T4[rsp+16]
	mov	rdx, rbp
	call	rax
	jmp	SHORT $LN14@ZSTDMT_fre
$LN13@ZSTDMT_fre:

; 81   :             free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN14@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 990  :     ZSTDMT_freeBufferPool(mtctx->bufPool);

	mov	rcx, QWORD PTR [rbx+16]
	call	ZSTDMT_freeBufferPool

; 991  :     ZSTDMT_freeCCtxPool(mtctx->cctxPool);

	mov	rcx, QWORD PTR [rbx+24]
	call	ZSTDMT_freeCCtxPool

; 330  :     ZSTDMT_freeBufferPool(seqPool);

	mov	rcx, QWORD PTR [rbx+32]
	call	ZSTDMT_freeBufferPool

; 550  :     ZSTD_customMem cMem = serialState->params.customMem;

	movups	xmm0, XMMWORD PTR [rbx+440]

; 992  :     ZSTDMT_freeSeqPool(mtctx->seqPool);
; 993  :     ZSTDMT_serialState_free(&mtctx->serial);

	lea	rsi, QWORD PTR [rbx+272]

; 550  :     ZSTD_customMem cMem = serialState->params.customMem;

	movsd	xmm1, QWORD PTR [rsi+184]

; 551  :     ZSTD_pthread_mutex_destroy(&serialState->mutex);

	mov	rcx, rsi
	movups	XMMWORD PTR cMem$1[rsp], xmm0
	movsd	QWORD PTR cMem$1[rsp+16], xmm1
	call	QWORD PTR __imp_DeleteCriticalSection

; 552  :     ZSTD_pthread_cond_destroy(&serialState->cond);
; 553  :     ZSTD_pthread_mutex_destroy(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rsi+352]
	call	QWORD PTR __imp_DeleteCriticalSection

; 554  :     ZSTD_pthread_cond_destroy(&serialState->ldmWindowCond);
; 555  :     ZSTD_free(serialState->ldmState.hashTable, cMem);

	mov	rcx, QWORD PTR [rsi+224]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	mov	rbp, QWORD PTR cMem$1[rsp+16]
	mov	rdi, QWORD PTR cMem$1[rsp+8]
	test	rcx, rcx
	je	SHORT $LN23@ZSTDMT_fre

; 78   :         if (customMem.customFree)

	test	rdi, rdi
	je	SHORT $LN22@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, rbp
	call	rdi
	jmp	SHORT $LN23@ZSTDMT_fre
$LN22@ZSTDMT_fre:

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN23@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 556  :     ZSTD_free(serialState->ldmState.bucketOffsets, cMem);

	mov	rcx, QWORD PTR [rsi+240]
	mov	rsi, QWORD PTR [rsp+88]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN28@ZSTDMT_fre

; 78   :         if (customMem.customFree)

	test	rdi, rdi
	je	SHORT $LN27@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, rbp
	call	rdi
	jmp	SHORT $LN28@ZSTDMT_fre
$LN27@ZSTDMT_fre:

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN28@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 994  :     ZSTD_freeCDict(mtctx->cdictLocal);

	mov	rcx, QWORD PTR [rbx+800]
	call	ZSTD_freeCDict

; 995  :     if (mtctx->roundBuff.buffer)

	mov	rcx, QWORD PTR [rbx+248]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+80]
	test	rcx, rcx
	je	SHORT $LN33@ZSTDMT_fre

; 996  :         ZSTD_free(mtctx->roundBuff.buffer, mtctx->cMem);

	movups	xmm1, XMMWORD PTR [rbx+776]
	movsd	xmm0, QWORD PTR [rbx+792]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 996  :         ZSTD_free(mtctx->roundBuff.buffer, mtctx->cMem);

	movsd	QWORD PTR $T3[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN32@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T3[rsp+16]
	call	rax
	jmp	SHORT $LN33@ZSTDMT_fre
$LN32@ZSTDMT_fre:

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN33@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 997  :     ZSTD_free(mtctx, mtctx->cMem);

	movups	xmm1, XMMWORD PTR [rbx+776]
	movsd	xmm0, QWORD PTR [rbx+792]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 997  :     ZSTD_free(mtctx, mtctx->cMem);

	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN37@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rbx
	call	rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 999  : }

	xor	eax, eax
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN37@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN44@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 999  : }

	xor	eax, eax
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTDMT_freeCCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
val$ = 8
ZSTD_highbit32 PROC

; 394  :     assert(val != 0);
; 395  :     {
; 396  : #   if defined(_MSC_VER)   /* Visual */
; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 399  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
; 400  :         return __builtin_clz (val) ^ 31;
; 401  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 402  :         return 31 - __CLZ(val);
; 403  : #   else   /* Software version */
; 404  :         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
; 405  :         U32 v = val;
; 406  :         v |= v >> 1;
; 407  :         v |= v >> 2;
; 408  :         v |= v >> 4;
; 409  :         v |= v >> 8;
; 410  :         v |= v >> 16;
; 411  :         return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];
; 412  : #   endif
; 413  :     }
; 414  : }

	ret	0
ZSTD_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
base$dead$ = 8
exponent$ = 16
ZSTD_ipow PROC

; 646  : {

	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H

; 647  :     U64 power = 1;

	mov	eax, 1

; 648  :     while (exponent) {

	test	rdx, rdx
	je	SHORT $LN10@ZSTD_ipow
$LL2@ZSTD_ipow:

; 649  :       if (exponent & 1) power *= base;

	test	dl, 1
	je	SHORT $LN4@ZSTD_ipow
	imul	rax, rcx
$LN4@ZSTD_ipow:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rcx, rcx
	shr	rdx, 1
	jne	SHORT $LL2@ZSTD_ipow
$LN10@ZSTD_ipow:

; 652  :     }
; 653  :     return power;
; 654  : }

	ret	0
ZSTD_ipow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
hash$ = 8
buf$ = 16
size$ = 24
ZSTD_rollingHash_append PROC

; 663  :     BYTE const* istart = (BYTE const*)buf;

	xor	r9d, r9d

; 664  :     size_t pos;
; 665  :     for (pos = 0; pos < size; ++pos) {

	test	r8, r8
	je	SHORT $LN12@ZSTD_rolli
	mov	r10, -3523014627327384477		; cf1bbcdcb7a56463H
	npad	14
$LL8@ZSTD_rolli:

; 666  :         hash *= prime8bytes;
; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	eax, BYTE PTR [r9+rdx]
	inc	r9
	imul	rcx, r10
	add	rcx, 10
	add	rcx, rax
	cmp	r9, r8
	jb	SHORT $LL8@ZSTD_rolli
$LN12@ZSTD_rolli:

; 668  :     }
; 669  :     return hash;
; 670  : }

	mov	rax, rcx
	ret	0
ZSTD_rollingHash_append ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
buf$ = 8
size$ = 16
ZSTD_rollingHash_compute PROC

; 677  :     return ZSTD_rollingHash_append(0, buf, size);

	xor	eax, eax
	mov	r9d, eax

; 665  :     for (pos = 0; pos < size; ++pos) {

	test	rdx, rdx
	je	SHORT $LN14@ZSTD_rolli
	mov	r10, -3523014627327384477		; cf1bbcdcb7a56463H
	npad	12
$LL10@ZSTD_rolli:

; 666  :         hash *= prime8bytes;
; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	r8d, BYTE PTR [r9+rcx]
	inc	r9
	imul	rax, r10
	add	rax, 10
	add	rax, r8
	cmp	r9, rdx
	jb	SHORT $LL10@ZSTD_rolli
$LN14@ZSTD_rolli:

; 678  : }

	ret	0
ZSTD_rollingHash_compute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
length$ = 8
ZSTD_rollingHash_primePower PROC

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	dec	ecx
	mov	rdx, -3523014627327384477		; cf1bbcdcb7a56463H

; 647  :     U64 power = 1;

	mov	eax, 1

; 648  :     while (exponent) {

	test	rcx, rcx
	je	SHORT $LN12@ZSTD_rolli
$LL4@ZSTD_rolli:

; 649  :       if (exponent & 1) power *= base;

	test	cl, 1
	je	SHORT $LN6@ZSTD_rolli
	imul	rax, rdx
$LN6@ZSTD_rolli:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rdx, rdx
	shr	rcx, 1
	jne	SHORT $LL4@ZSTD_rolli
$LN12@ZSTD_rolli:

; 687  : }

	ret	0
ZSTD_rollingHash_primePower ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
hash$ = 8
toRemove$ = 16
toAdd$ = 24
primePower$ = 32
ZSTD_rollingHash_rotate PROC

; 694  :     hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;
; 695  :     hash *= prime8bytes;
; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	movzx	edx, dl
	add	edx, 10
	imul	rdx, r9
	sub	rcx, rdx
	imul	rcx, rax
	movzx	eax, r8b
	add	eax, 10
	add	rax, rcx

; 697  :     return hash;
; 698  : }

	ret	0
ZSTD_rollingHash_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
ZSTD_window_clear PROC

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	mov	eax, DWORD PTR [rcx]
	sub	eax, DWORD PTR [rcx+8]

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rcx+28], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rcx+24], eax

; 724  : }

	ret	0
ZSTD_window_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 8
ZSTD_window_init PROC

; 922  :     memset(window, 0, sizeof(*window));
; 923  :     window->base = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294965452

; 924  :     window->dictBase = (BYTE const*)"";
; 925  :     window->dictLimit = 1;    /* start from 1, so that 1st position is valid */

	mov	DWORD PTR [rcx+24], 1
	mov	QWORD PTR [rcx+8], rax
	lea	rax, OFFSET FLAT:$SG4294965451
	mov	QWORD PTR [rcx+16], rax

; 926  :     window->lowLimit = 1;     /* it ensures first and later CCtx usages compress the same */
; 927  :     window->nextSrc = window->base + 1;   /* see issue #1241 */

	lea	rax, OFFSET FLAT:$SG4294965452+1
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+28], 1

; 928  : }

	ret	0
ZSTD_window_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
window$ = 16
src$ = 24
srcSize$ = 32
ZSTD_window_update PROC

; 939  : {

	push	rsi
	mov	rsi, r8
	mov	r10, rdx
	mov	r9, rcx

; 940  :     BYTE const* const ip = (BYTE const*)src;
; 941  :     U32 contiguous = 1;

	mov	r11d, 1

; 942  :     DEBUGLOG(5, "ZSTD_window_update");
; 943  :     if (srcSize == 0)

	test	r8, r8
	je	$LN11@ZSTD_windo

; 944  :         return contiguous;
; 945  :     assert(window->base != NULL);
; 946  :     assert(window->dictBase != NULL);
; 947  :     /* Check if blocks follow each other */
; 948  :     if (src != window->nextSrc) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
	xor	edi, edi
	cmp	rdx, rcx
	je	SHORT $LN10@ZSTD_windo

; 949  :         /* not contiguous */
; 950  :         size_t const distanceFromBase = (size_t)(window->nextSrc - window->base);

	mov	rbx, QWORD PTR [r9+8]

; 951  :         DEBUGLOG(5, "Non contiguous blocks, new segment starts at %u", window->dictLimit);
; 952  :         window->lowLimit = window->dictLimit;
; 953  :         assert(distanceFromBase == (size_t)(U32)distanceFromBase);  /* should never overflow */
; 954  :         window->dictLimit = (U32)distanceFromBase;
; 955  :         window->dictBase = window->base;
; 956  :         window->base = ip - distanceFromBase;

	mov	rax, r10
	mov	edx, DWORD PTR [r9+24]
	sub	rcx, rbx
	sub	rax, rcx
	mov	DWORD PTR [r9+28], edx
	mov	QWORD PTR [r9+8], rax

; 957  :         /* ms->nextToUpdate = window->dictLimit; */
; 958  :         if (window->dictLimit - window->lowLimit < HASH_READ_SIZE) window->lowLimit = window->dictLimit;   /* too small extDict */

	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR [r9+24], ecx
	mov	QWORD PTR [r9+16], rbx
	cmp	eax, 8
	jae	SHORT $LN9@ZSTD_windo
	mov	DWORD PTR [r9+28], ecx
	mov	edx, ecx
$LN9@ZSTD_windo:

; 959  :         contiguous = 0;

	mov	r11d, edi
	jmp	SHORT $LN3@ZSTD_windo
$LN10@ZSTD_windo:
	mov	rbx, QWORD PTR [r9+16]
	mov	edx, DWORD PTR [r9+28]
	mov	ecx, DWORD PTR [r9+24]
$LN3@ZSTD_windo:

; 960  :     }
; 961  :     window->nextSrc = ip + srcSize;
; 962  :     /* if input and dictionary overlap : reduce dictionary (area presumed modified by input) */
; 963  :     if ( (ip+srcSize > window->dictBase + window->lowLimit)
; 964  :        & (ip < window->dictBase + window->dictLimit)) {

	mov	eax, edx
	mov	edx, edi
	add	rax, rbx
	mov	r8d, ecx
	lea	rcx, QWORD PTR [r10+rsi]
	cmp	rcx, rax
	mov	QWORD PTR [r9], rcx
	seta	dl
	lea	rax, QWORD PTR [r8+rbx]
	cmp	r10, rax
	setb	dil
	test	edx, edi
	mov	rdi, QWORD PTR [rsp+24]
	je	SHORT $LN5@ZSTD_windo

; 965  :         ptrdiff_t const highInputIdx = (ip + srcSize) - window->dictBase;

	sub	r10, rbx
	add	r10, rsi

; 966  :         U32 const lowLimitMax = (highInputIdx > (ptrdiff_t)window->dictLimit) ? window->dictLimit : (U32)highInputIdx;
; 967  :         window->lowLimit = lowLimitMax;

	cmp	r10, r8
	cmovle	r8d, r10d
	mov	DWORD PTR [r9+28], r8d
$LN5@ZSTD_windo:

; 968  :         DEBUGLOG(5, "Overlapping extDict and input : new lowLimit = %u", window->lowLimit);
; 969  :     }
; 970  :     return contiguous;

	mov	rbx, QWORD PTR [rsp+16]
$LN11@ZSTD_windo:

; 971  : }

	mov	eax, r11d
	pop	rsi
	ret	0
ZSTD_window_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
nbWorkers$ = 80
cMem$ = 88
ZSTDMT_createBufferPool PROC

; 107  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [rdx]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 108  :     unsigned const maxNbBuffers = 2*nbWorkers + 3;

	lea	ebp, DWORD PTR [rcx*2+3]

; 109  :     ZSTDMT_bufferPool* const bufPool = (ZSTDMT_bufferPool*)ZSTD_calloc(

	movsd	xmm0, QWORD PTR [rdx+16]
	lea	edi, DWORD PTR [rbp-1]
	add	rdi, 6
	movsd	QWORD PTR $T1[rsp+16], xmm0
	shl	rdi, 4
	mov	rsi, rdx
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rdx, rdi
	test	rax, rax
	je	SHORT $LN6@ZSTDMT_cre

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN5@ZSTDMT_cre
$LN6@ZSTDMT_cre:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	ecx, 1
	call	QWORD PTR __imp_calloc
	mov	rbx, rax
$LN5@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 111  :     if (bufPool==NULL) return NULL;

	test	rbx, rbx
	jne	SHORT $LN2@ZSTDMT_cre
	xor	eax, eax
	jmp	SHORT $LN1@ZSTDMT_cre
$LN2@ZSTDMT_cre:

; 112  :     if (ZSTD_pthread_mutex_init(&bufPool->poolMutex, NULL)) {

	mov	rcx, rbx
	call	QWORD PTR __imp_InitializeCriticalSection

; 113  :         ZSTD_free(bufPool, cMem);
; 114  :         return NULL;
; 115  :     }
; 116  :     bufPool->bufferSize = 64 KB;
; 117  :     bufPool->totalBuffers = maxNbBuffers;
; 118  :     bufPool->nbBuffers = 0;
; 119  :     bufPool->cMem = cMem;

	movaps	xmm0, XMMWORD PTR [rsi]

; 120  :     return bufPool;

	mov	rax, rbx
	movsd	xmm1, QWORD PTR [rsi+16]
	movups	XMMWORD PTR [rbx+56], xmm0
	mov	QWORD PTR [rbx+40], 65536		; 00010000H
	movsd	QWORD PTR [rbx+72], xmm1
	mov	DWORD PTR [rbx+48], ebp
	mov	DWORD PTR [rbx+52], 0
$LN1@ZSTDMT_cre:

; 121  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_createBufferPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
bufPool$ = 80
ZSTDMT_freeBufferPool PROC

; 125  :     unsigned u;
; 126  :     DEBUGLOG(3, "ZSTDMT_freeBufferPool (address:%08X)", (U32)(size_t)bufPool);
; 127  :     if (!bufPool) return;   /* compatibility with free on NULL */

	test	rcx, rcx
	je	$LN21@ZSTDMT_fre
	push	rbx
	sub	rsp, 64					; 00000040H

; 128  :     for (u=0; u<bufPool->totalBuffers; u++) {

	mov	QWORD PTR [rsp+80], rdi
	mov	rbx, rcx
	xor	edi, edi
	cmp	DWORD PTR [rcx+48], edi
	jbe	SHORT $LN3@ZSTDMT_fre
	npad	3
$LL4@ZSTDMT_fre:

; 129  :         DEBUGLOG(4, "free buffer %2u (address:%08X)", u, (U32)(size_t)bufPool->bTable[u].start);
; 130  :         ZSTD_free(bufPool->bTable[u].start, bufPool->cMem);

	movups	xmm0, XMMWORD PTR [rbx+56]
	mov	eax, edi
	movsd	xmm1, QWORD PTR [rbx+72]
	add	rax, 5
	add	rax, rax
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1
	mov	rcx, QWORD PTR [rbx+rax*8]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN2@ZSTDMT_fre

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T2[rsp+8]
	test	rax, rax
	je	SHORT $LN9@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax
	jmp	SHORT $LN2@ZSTDMT_fre
$LN9@ZSTDMT_fre:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN2@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 128  :     for (u=0; u<bufPool->totalBuffers; u++) {

	inc	edi
	cmp	edi, DWORD PTR [rbx+48]
	jb	SHORT $LL4@ZSTDMT_fre
$LN3@ZSTDMT_fre:

; 131  :     }
; 132  :     ZSTD_pthread_mutex_destroy(&bufPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_DeleteCriticalSection

; 133  :     ZSTD_free(bufPool, bufPool->cMem);

	movups	xmm1, XMMWORD PTR [rbx+56]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rdi, QWORD PTR [rsp+80]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 133  :     ZSTD_free(bufPool, bufPool->cMem);

	movsd	xmm0, QWORD PTR [rbx+72]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 133  :     ZSTD_free(bufPool, bufPool->cMem);

	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN14@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rbx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 134  : }

	add	rsp, 64					; 00000040H
	pop	rbx
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 79   :             customMem.customFree(customMem.opaque, ptr);

	rex_jmp	rax
$LN14@ZSTDMT_fre:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 134  : }

	add	rsp, 64					; 00000040H
	pop	rbx
$LN21@ZSTDMT_fre:
	ret	0
ZSTDMT_freeBufferPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
bufPool$ = 48
bSize$ = 56
ZSTDMT_setBufferSize PROC

; 156  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 158  :     DEBUGLOG(4, "ZSTDMT_setBufferSize: bSize = %u", (U32)bSize);
; 159  :     bufPool->bufferSize = bSize;
; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rdi
	mov	QWORD PTR [rdi+40], rbx

; 161  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 158  :     DEBUGLOG(4, "ZSTDMT_setBufferSize: bSize = %u", (U32)bSize);
; 159  :     bufPool->bufferSize = bSize;
; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
ZSTDMT_setBufferSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
cMem$1$ = 32
$T1 = 32
cMem$2$ = 80
srcBufPool$ = 80
nbWorkers$ = 88
ZSTDMT_expandBufferPool PROC

; 165  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	ebx, edx

; 166  :     unsigned const maxNbBuffers = 2*nbWorkers + 3;
; 167  :     if (srcBufPool==NULL) return NULL;

	test	rcx, rcx
	je	$LN8@ZSTDMT_exp

; 168  :     if (srcBufPool->totalBuffers >= maxNbBuffers) /* good enough */

	lea	eax, DWORD PTR [rdx*2+3]
	cmp	DWORD PTR [rcx+48], eax
	jb	SHORT $LN3@ZSTDMT_exp

; 169  :         return srcBufPool;

	mov	rax, rcx

; 179  :     }
; 180  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN3@ZSTDMT_exp:

; 170  :     /* need a larger buffer pool */
; 171  :     {   ZSTD_customMem const cMem = srcBufPool->cMem;

	movups	xmm0, XMMWORD PTR [rcx+56]

; 172  :         size_t const bSize = srcBufPool->bufferSize;   /* forward parameters */

	mov	rdi, QWORD PTR [rcx+40]
	movups	XMMWORD PTR cMem$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rcx+72]
	movsd	QWORD PTR cMem$2$[rsp], xmm0

; 173  :         ZSTDMT_bufferPool* newBufPool;
; 174  :         ZSTDMT_freeBufferPool(srcBufPool);

	call	ZSTDMT_freeBufferPool

; 175  :         newBufPool = ZSTDMT_createBufferPool(nbWorkers, cMem);

	movups	xmm0, XMMWORD PTR cMem$1$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	ecx, ebx
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	xmm0, QWORD PTR cMem$2$[rsp]
	movsd	QWORD PTR $T1[rsp+16], xmm0
	call	ZSTDMT_createBufferPool
	mov	rbx, rax

; 176  :         if (newBufPool==NULL) return newBufPool;

	test	rax, rax
	je	SHORT $LN8@ZSTDMT_exp

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rax
	call	QWORD PTR __imp_EnterCriticalSection

; 158  :     DEBUGLOG(4, "ZSTDMT_setBufferSize: bSize = %u", (U32)bSize);
; 159  :     bufPool->bufferSize = bSize;
; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rbx
	mov	QWORD PTR [rbx+40], rdi
	call	QWORD PTR __imp_LeaveCriticalSection

; 177  :         ZSTDMT_setBufferSize(newBufPool, bSize);
; 178  :         return newBufPool;

	mov	rax, rbx

; 179  :     }
; 180  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN8@ZSTDMT_exp:
	mov	rbx, QWORD PTR [rsp+88]
	xor	eax, eax
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_expandBufferPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
buf$3$ = 32
$T1 = 32
$T2 = 64
buf$3 = 64
$T4 = 112
bufPool$ = 120
ZSTDMT_getBuffer PROC

; 187  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 188  :     size_t const bSize = bufPool->bufferSize;

	mov	rdi, QWORD PTR [rdx+40]
	mov	rsi, rcx

; 189  :     DEBUGLOG(5, "ZSTDMT_getBuffer: bSize = %u", (U32)bufPool->bufferSize);
; 190  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rdx
	mov	rbx, rdx
	call	QWORD PTR __imp_EnterCriticalSection

; 191  :     if (bufPool->nbBuffers) {   /* try to use an existing buffer */

	mov	eax, DWORD PTR [rbx+52]
	xor	ebp, ebp
	test	eax, eax
	je	$LN10@ZSTDMT_get

; 192  :         buffer_t const buf = bufPool->bTable[--(bufPool->nbBuffers)];
; 193  :         size_t const availBufferSize = buf.capacity;
; 194  :         bufPool->bTable[bufPool->nbBuffers] = g_nullBuffer;

	movaps	xmm0, XMMWORD PTR g_nullBuffer
	dec	eax
	mov	DWORD PTR [rbx+52], eax

; 195  :         if ((availBufferSize >= bSize) & ((availBufferSize>>3) <= bSize)) {

	mov	edx, ebp
	mov	r8d, eax
	add	r8, 5
	add	r8, r8
	movups	xmm1, XMMWORD PTR [rbx+r8*8]
	movups	XMMWORD PTR [rbx+r8*8], xmm0
	movups	XMMWORD PTR buf$3$[rsp], xmm1
	movups	XMMWORD PTR buf$3[rsp], xmm1
	psrldq	xmm1, 8
	movq	rcx, xmm1
	mov	rax, rcx
	shr	rax, 3
	cmp	rax, rdi
	mov	eax, ebp
	setbe	dl
	cmp	rcx, rdi
	setae	al
	test	edx, eax
	je	SHORT $LN3@ZSTDMT_get

; 196  :             /* large enough, but not too much */
; 197  :             DEBUGLOG(5, "ZSTDMT_getBuffer: provide buffer %u of size %u",
; 198  :                         bufPool->nbBuffers, (U32)buf.capacity);
; 199  :             ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 200  :             return buf;

	movups	xmm0, XMMWORD PTR buf$3$[rsp]
	movups	XMMWORD PTR [rsi], xmm0
	jmp	SHORT $LN15@ZSTDMT_get
$LN3@ZSTDMT_get:

; 204  :         ZSTD_free(buf.start, bufPool->cMem);

	movups	xmm0, XMMWORD PTR [rbx+56]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	mov	rcx, QWORD PTR buf$3[rsp]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 204  :         ZSTD_free(buf.start, bufPool->cMem);

	movsd	xmm1, QWORD PTR [rbx+72]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN10@ZSTDMT_get

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN9@ZSTDMT_get

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN10@ZSTDMT_get
$LN9@ZSTDMT_get:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN10@ZSTDMT_get:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 206  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx+56]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 210  :         void* const start = ZSTD_malloc(bSize, bufPool->cMem);

	movsd	xmm0, QWORD PTR [rbx+72]
	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN13@ZSTDMT_get

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rdi
	call	rax
	jmp	SHORT $LN12@ZSTDMT_get
$LN13@ZSTDMT_get:

; 60   :     return malloc(size);

	mov	rcx, rdi
	call	QWORD PTR __imp_malloc
$LN12@ZSTDMT_get:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 212  :         buffer.capacity = (start==NULL) ? 0 : bSize;

	test	rax, rax

; 213  :         if (start==NULL) {
; 214  :             DEBUGLOG(5, "ZSTDMT_getBuffer: buffer allocation failure !!");
; 215  :         } else {
; 216  :             DEBUGLOG(5, "ZSTDMT_getBuffer: created buffer of size %u", (U32)bSize);
; 217  :         }
; 218  :         return buffer;

	mov	QWORD PTR [rsi], rax
	cmove	rdi, rbp
	mov	QWORD PTR [rsi+8], rdi
$LN15@ZSTDMT_get:

; 219  :     }
; 220  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
ZSTDMT_getBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
bufPool$ = 80
buf$ = 88
ZSTDMT_releaseBuffer PROC

; 250  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 251  :     DEBUGLOG(5, "ZSTDMT_releaseBuffer");
; 252  :     if (buf.start == NULL) return;   /* compatible with release on NULL */

	cmp	QWORD PTR [rdx], 0
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN8@ZSTDMT_rel

; 253  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 254  :     if (bufPool->nbBuffers < bufPool->totalBuffers) {

	mov	eax, DWORD PTR [rbx+52]
	mov	rcx, rbx
	cmp	eax, DWORD PTR [rbx+48]
	jae	SHORT $LN3@ZSTDMT_rel

; 255  :         bufPool->bTable[bufPool->nbBuffers++] = buf;  /* stored for later use */

	movaps	xmm0, XMMWORD PTR [rdi]
	add	rax, 5
	add	rax, rax
	movups	XMMWORD PTR [rbx+rax*8], xmm0
	inc	DWORD PTR [rbx+52]

; 256  :         DEBUGLOG(5, "ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u",
; 257  :                     (U32)buf.capacity, (U32)(bufPool->nbBuffers-1));
; 258  :         ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 265  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN3@ZSTDMT_rel:

; 259  :         return;
; 260  :     }
; 261  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 262  :     /* Reached bufferPool capacity (should not happen) */
; 263  :     DEBUGLOG(5, "ZSTDMT_releaseBuffer: pool capacity reached => freeing ");
; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movups	xmm0, XMMWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rdi]
	movsd	xmm1, QWORD PTR [rbx+72]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN8@ZSTDMT_rel

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN7@ZSTDMT_rel

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 265  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN7@ZSTDMT_rel:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN8@ZSTDMT_rel:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 265  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_releaseBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 8
buffer$ = 16
bufferToSeq PROC

; 281  :     rawSeqStore_t seq = {NULL, 0, 0, 0};

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 282  :     seq.seq = (rawSeq*)buffer.start;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 283  :     seq.capacity = buffer.capacity / sizeof(rawSeq);

	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mul	QWORD PTR [rdx+8]

; 284  :     return seq;

	mov	rax, rcx
	shr	rdx, 3
	mov	QWORD PTR [rcx+24], rdx

; 285  : }

	ret	0
bufferToSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 8
seq$ = 16
seqToBuffer PROC

; 289  :     buffer_t buffer;
; 290  :     buffer.start = seq.seq;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 291  :     buffer.capacity = seq.capacity * sizeof(rawSeq);

	mov	rax, QWORD PTR [rdx+24]
	lea	rdx, QWORD PTR [rax+rax*2]

; 292  :     return buffer;

	mov	rax, rcx
	shl	rdx, 2
	mov	QWORD PTR [rcx+8], rdx

; 293  : }

	ret	0
seqToBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 80
seqPool$ = 88
ZSTDMT_getSeq PROC

; 296  : {

	push	rbx
	sub	rsp, 64					; 00000040H

; 297  :     if (seqPool->bufferSize == 0) {

	cmp	QWORD PTR [rdx+40], 0
	mov	rbx, rcx
	jne	SHORT $LN2@ZSTDMT_get

; 298  :         return kNullRawSeqStore;

	movups	xmm0, XMMWORD PTR kNullRawSeqStore

; 301  : }

	mov	rax, rcx
	movups	xmm1, XMMWORD PTR kNullRawSeqStore+16
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN2@ZSTDMT_get:

; 299  :     }
; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	lea	rcx, QWORD PTR $T2[rsp]
	call	ZSTDMT_getBuffer
	movups	xmm0, XMMWORD PTR [rax]

; 281  :     rawSeqStore_t seq = {NULL, 0, 0, 0};

	xor	eax, eax
	mov	QWORD PTR $T1[rsp+8], rax
	mov	QWORD PTR $T1[rsp+16], rax

; 282  :     seq.seq = (rawSeq*)buffer.start;
; 283  :     seq.capacity = buffer.capacity / sizeof(rawSeq);

	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	movq	QWORD PTR $T1[rsp], xmm0
	psrldq	xmm0, 8
	movq	rcx, xmm0

; 299  :     }
; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	movups	xmm0, XMMWORD PTR $T1[rsp]

; 283  :     seq.capacity = buffer.capacity / sizeof(rawSeq);

	mul	rcx

; 299  :     }
; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	movups	XMMWORD PTR [rbx], xmm0

; 301  : }

	mov	rax, rbx

; 283  :     seq.capacity = buffer.capacity / sizeof(rawSeq);

	shr	rdx, 3
	mov	QWORD PTR $T1[rsp+24], rdx

; 299  :     }
; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	movups	xmm1, XMMWORD PTR $T1[rsp+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 301  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTDMT_getSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
seqPool$ = 80
seq$ = 88
ZSTDMT_releaseSeq PROC

; 311  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 290  :     buffer.start = seq.seq;

	mov	rdi, QWORD PTR [rdx]

; 311  : {

	mov	rbx, rcx

; 312  :   ZSTDMT_releaseBuffer(seqPool, seqToBuffer(seq));

	movaps	xmm1, XMMWORD PTR [rdx+16]

; 291  :     buffer.capacity = seq.capacity * sizeof(rawSeq);

	psrldq	xmm1, 8
	movq	rax, xmm1
	mov	QWORD PTR $T2[rsp], rdi
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	mov	QWORD PTR $T2[rsp+8], rdx

; 252  :     if (buf.start == NULL) return;   /* compatible with release on NULL */

	test	rdi, rdi
	je	SHORT $LN12@ZSTDMT_rel

; 253  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 254  :     if (bufPool->nbBuffers < bufPool->totalBuffers) {

	mov	eax, DWORD PTR [rbx+52]
	mov	rcx, rbx
	cmp	eax, DWORD PTR [rbx+48]
	jae	SHORT $LN7@ZSTDMT_rel

; 255  :         bufPool->bTable[bufPool->nbBuffers++] = buf;  /* stored for later use */

	movups	xmm0, XMMWORD PTR $T2[rsp]
	add	rax, 5
	add	rax, rax
	movups	XMMWORD PTR [rbx+rax*8], xmm0
	inc	DWORD PTR [rbx+52]

; 256  :         DEBUGLOG(5, "ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u",
; 257  :                     (U32)buf.capacity, (U32)(bufPool->nbBuffers-1));
; 258  :         ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 313  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN7@ZSTDMT_rel:

; 261  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movups	xmm1, XMMWORD PTR [rbx+56]
	movsd	xmm0, QWORD PTR [rbx+72]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN11@ZSTDMT_rel

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rdi
	call	rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 313  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN11@ZSTDMT_rel:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN12@ZSTDMT_rel:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 313  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_releaseSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
seqPool$ = 48
nbSeq$ = 56
ZSTDMT_setNbSeq PROC

; 316  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 317  :   ZSTDMT_setBufferSize(seqPool, nbSeq * sizeof(rawSeq));

	lea	rax, QWORD PTR [rbx+rbx*2]

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rdi

; 317  :   ZSTDMT_setBufferSize(seqPool, nbSeq * sizeof(rawSeq));

	shl	rax, 2

; 159  :     bufPool->bufferSize = bSize;

	mov	QWORD PTR [rdi+40], rax

; 318  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
ZSTDMT_setNbSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
nbWorkers$ = 80
cMem$ = 88
ZSTDMT_createSeqPool PROC

; 321  : {

	push	rbx
	sub	rsp, 64					; 00000040H

; 322  :     ZSTDMT_seqPool* const seqPool = ZSTDMT_createBufferPool(nbWorkers, cMem);

	movaps	xmm0, XMMWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [rdx+16]
	lea	rdx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	call	ZSTDMT_createBufferPool
	mov	rbx, rax

; 323  :     if (seqPool == NULL) return NULL;

	test	rax, rax
	jne	SHORT $LN2@ZSTDMT_cre

; 326  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN2@ZSTDMT_cre:

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 158  :     DEBUGLOG(4, "ZSTDMT_setBufferSize: bSize = %u", (U32)bSize);
; 159  :     bufPool->bufferSize = bSize;
; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rbx
	mov	QWORD PTR [rbx+40], 0
	call	QWORD PTR __imp_LeaveCriticalSection

; 324  :     ZSTDMT_setNbSeq(seqPool, 0);
; 325  :     return seqPool;

	mov	rax, rbx

; 326  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTDMT_createSeqPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
seqPool$ = 8
ZSTDMT_freeSeqPool PROC

; 330  :     ZSTDMT_freeBufferPool(seqPool);

	jmp	ZSTDMT_freeBufferPool
ZSTDMT_freeSeqPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
pool$ = 8
nbWorkers$ = 16
ZSTDMT_expandSeqPool PROC

; 335  :     return ZSTDMT_expandBufferPool(pool, nbWorkers);

	jmp	ZSTDMT_expandBufferPool
ZSTDMT_expandSeqPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
pool$ = 80
ZSTDMT_freeCCtxPool PROC

; 352  : {

	push	rsi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rsp+88], rdi
	mov	rsi, rcx

; 353  :     int cid;
; 354  :     for (cid=0; cid<pool->totalCCtx; cid++)

	xor	edi, edi
	cmp	DWORD PTR [rcx+40], edi
	jle	SHORT $LN3@ZSTDMT_fre
	mov	QWORD PTR [rsp+80], rbx
	lea	rbx, QWORD PTR [rcx+72]
	npad	2
$LL4@ZSTDMT_fre:

; 355  :         ZSTD_freeCCtx(pool->cctx[cid]);  /* note : compatible with free on NULL */

	mov	rcx, QWORD PTR [rbx]
	call	ZSTD_freeCCtx
	inc	edi
	lea	rbx, QWORD PTR [rbx+8]
	cmp	edi, DWORD PTR [rsi+40]
	jl	SHORT $LL4@ZSTDMT_fre

; 353  :     int cid;
; 354  :     for (cid=0; cid<pool->totalCCtx; cid++)

	mov	rbx, QWORD PTR [rsp+80]
$LN3@ZSTDMT_fre:

; 356  :     ZSTD_pthread_mutex_destroy(&pool->poolMutex);

	mov	rcx, rsi
	call	QWORD PTR __imp_DeleteCriticalSection

; 357  :     ZSTD_free(pool, pool->cMem);

	movups	xmm1, XMMWORD PTR [rsi+48]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rdi, QWORD PTR [rsp+88]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 357  :     ZSTD_free(pool, pool->cMem);

	movsd	xmm0, QWORD PTR [rsi+64]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 357  :     ZSTD_free(pool, pool->cMem);

	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN39@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rsi
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 358  : }

	add	rsp, 64					; 00000040H
	pop	rsi
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 79   :             customMem.customFree(customMem.opaque, ptr);

	rex_jmp	rax
$LN39@ZSTDMT_fre:

; 81   :             free(ptr);

	mov	rcx, rsi
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 358  : }

	add	rsp, 64					; 00000040H
	pop	rsi
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	rex_jmp	QWORD PTR __imp_free
ZSTDMT_freeCCtxPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
nbWorkers$ = 80
cMem$ = 88
ZSTDMT_createCCtxPool PROC

; 364  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 365  :     ZSTDMT_CCtxPool* const cctxPool = (ZSTDMT_CCtxPool*) ZSTD_calloc(

	movsd	xmm0, QWORD PTR [rdx+16]
	lea	eax, DWORD PTR [rcx-1]
	movsxd	r8, eax
	mov	rsi, rdx
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [rdx]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 364  : {

	mov	ebp, ecx

; 365  :     ZSTDMT_CCtxPool* const cctxPool = (ZSTDMT_CCtxPool*) ZSTD_calloc(

	movsd	QWORD PTR $T2[rsp+16], xmm0
	lea	rdi, QWORD PTR [r8*8+80]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rdx, rdi
	test	rax, rax
	je	SHORT $LN7@ZSTDMT_cre

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN6@ZSTDMT_cre
$LN7@ZSTDMT_cre:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	ecx, 1
	call	QWORD PTR __imp_calloc
	mov	rbx, rax
$LN6@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 368  :     if (!cctxPool) return NULL;

	test	rbx, rbx
	je	SHORT $LN14@ZSTDMT_cre

; 369  :     if (ZSTD_pthread_mutex_init(&cctxPool->poolMutex, NULL)) {

	mov	rcx, rbx
	call	QWORD PTR __imp_InitializeCriticalSection

; 370  :         ZSTD_free(cctxPool, cMem);
; 371  :         return NULL;
; 372  :     }
; 373  :     cctxPool->cMem = cMem;

	movaps	xmm0, XMMWORD PTR [rsi]

; 374  :     cctxPool->totalCCtx = nbWorkers;
; 375  :     cctxPool->availCCtx = 1;   /* at least one cctx for single-thread mode */
; 376  :     cctxPool->cctx[0] = ZSTD_createCCtx_advanced(cMem);

	lea	rcx, QWORD PTR $T1[rsp]
	movsd	xmm1, QWORD PTR [rsi+16]
	movups	XMMWORD PTR [rbx+48], xmm0
	mov	DWORD PTR [rbx+40], ebp
	movsd	QWORD PTR [rbx+64], xmm1
	mov	DWORD PTR [rbx+44], 1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1
	call	ZSTD_createCCtx_advanced
	mov	QWORD PTR [rbx+72], rax

; 377  :     if (!cctxPool->cctx[0]) { ZSTDMT_freeCCtxPool(cctxPool); return NULL; }

	test	rax, rax
	jne	SHORT $LN4@ZSTDMT_cre
	mov	rcx, rbx
	call	ZSTDMT_freeCCtxPool
$LN14@ZSTDMT_cre:

; 380  : }

	xor	eax, eax
	jmp	SHORT $LN1@ZSTDMT_cre
$LN4@ZSTDMT_cre:

; 378  :     DEBUGLOG(3, "cctxPool created, with %u workers", nbWorkers);
; 379  :     return cctxPool;

	mov	rax, rbx
$LN1@ZSTDMT_cre:

; 380  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_createCCtxPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
cMem$1$ = 32
$T1 = 32
cMem$2$ = 80
srcPool$ = 80
nbWorkers$ = 88
ZSTDMT_expandCCtxPool PROC

; 384  : {

	push	rbx
	sub	rsp, 64					; 00000040H
	mov	ebx, edx

; 385  :     if (srcPool==NULL) return NULL;

	test	rcx, rcx
	jne	SHORT $LN2@ZSTDMT_exp
	xor	eax, eax

; 391  :     }
; 392  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN2@ZSTDMT_exp:

; 386  :     if (nbWorkers <= srcPool->totalCCtx) return srcPool;   /* good enough */

	cmp	ebx, DWORD PTR [rcx+40]
	jg	SHORT $LN3@ZSTDMT_exp
	mov	rax, rcx

; 391  :     }
; 392  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN3@ZSTDMT_exp:

; 387  :     /* need a larger cctx pool */
; 388  :     {   ZSTD_customMem const cMem = srcPool->cMem;

	movups	xmm0, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR cMem$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rcx+64]
	movsd	QWORD PTR cMem$2$[rsp], xmm0

; 389  :         ZSTDMT_freeCCtxPool(srcPool);

	call	ZSTDMT_freeCCtxPool

; 390  :         return ZSTDMT_createCCtxPool(nbWorkers, cMem);

	movups	xmm0, XMMWORD PTR cMem$1$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	ecx, ebx
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	xmm0, QWORD PTR cMem$2$[rsp]
	movsd	QWORD PTR $T1[rsp+16], xmm0
	call	ZSTDMT_createCCtxPool

; 391  :     }
; 392  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
ZSTDMT_expandCCtxPool ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 64
$T4 = 112
cctxPool$ = 112
ZSTDMT_getCCtx PROC

; 413  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rcx

; 414  :     DEBUGLOG(5, "ZSTDMT_getCCtx");
; 415  :     ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 416  :     if (cctxPool->availCCtx) {

	movsxd	rcx, DWORD PTR [rdi+44]
	test	ecx, ecx
	je	SHORT $LN2@ZSTDMT_get

; 417  :         cctxPool->availCCtx--;

	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rdi+44], eax

; 418  :         {   ZSTD_CCtx* const cctx = cctxPool->cctx[cctxPool->availCCtx];

	mov	rbx, QWORD PTR [rdi+rcx*8+64]

; 419  :             ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection

; 425  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN2@ZSTDMT_get:

; 420  :             return cctx;
; 421  :     }   }
; 422  :     ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection

; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */

	movups	xmm1, XMMWORD PTR [rdi+48]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	xor	ebx, ebx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */

	movsd	xmm0, QWORD PTR [rdi+64]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	mov	edx, ebx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */

	movsd	QWORD PTR $T4[rsp], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	mov	ecx, ebx
	movdqa	xmm0, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */

	movaps	XMMWORD PTR $T1[rsp], xmm1
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	psrldq	xmm0, 8
	movq	rax, xmm0
	test	rax, rax
	movq	rax, xmm1
	sete	dl
	test	rax, rax
	sete	cl
	cmp	edx, ecx
	jne	SHORT $LN4@ZSTDMT_get
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rdi+48]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 86   :     {   ZSTD_CCtx* const cctx = (ZSTD_CCtx*)ZSTD_malloc(sizeof(ZSTD_CCtx), customMem);

	movsd	xmm0, QWORD PTR [rdi+64]
	movsd	QWORD PTR $T3[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN9@ZSTDMT_get

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T3[rsp+16]
	mov	edx, 1160				; 00000488H
	call	rax
	jmp	SHORT $LN11@ZSTDMT_get
$LN9@ZSTDMT_get:

; 60   :     return malloc(size);

	mov	ecx, 1160				; 00000488H
	call	QWORD PTR __imp_malloc
$LN11@ZSTDMT_get:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 87   :         if (!cctx) return NULL;

	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN4@ZSTDMT_get

; 88   :         ZSTD_initCCtx(cctx, customMem);

	movaps	xmm0, XMMWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	movsd	xmm1, QWORD PTR $T4[rsp]
	mov	rcx, rax
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1
	call	ZSTD_initCCtx

; 89   :         return cctx;

	mov	rbx, rdi
$LN4@ZSTDMT_get:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 425  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
ZSTDMT_getCCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
pool$ = 48
cctx$ = 56
ZSTDMT_releaseCCtx PROC

; 429  :     if (cctx==NULL) return;   /* compatibility with release on NULL */

	test	rdx, rdx
	je	SHORT $LN6@ZSTDMT_rel
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 428  : {

	mov	rdi, rdx
	mov	rbx, rcx

; 430  :     ZSTD_pthread_mutex_lock(&pool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 431  :     if (pool->availCCtx < pool->totalCCtx)

	movsxd	rax, DWORD PTR [rbx+44]
	cmp	eax, DWORD PTR [rbx+40]
	jge	SHORT $LN3@ZSTDMT_rel

; 432  :         pool->cctx[pool->availCCtx++] = cctx;

	mov	QWORD PTR [rbx+rax*8+72], rdi
	inc	DWORD PTR [rbx+44]
	jmp	SHORT $LN4@ZSTDMT_rel
$LN3@ZSTDMT_rel:

; 433  :     else {
; 434  :         /* pool overflow : should not happen, since totalCCtx==nbWorkers */
; 435  :         DEBUGLOG(4, "CCtx pool overflow : free cctx");
; 436  :         ZSTD_freeCCtx(cctx);

	mov	rcx, rdi
	call	ZSTD_freeCCtx
$LN4@ZSTDMT_rel:

; 437  :     }
; 438  :     ZSTD_pthread_mutex_unlock(&pool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 439  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN6@ZSTDMT_rel:
	ret	0
ZSTDMT_releaseCCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\xxhash.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
bucketLog$1$ = 64
bucketSize$1$ = 72
state$6 = 80
hashLog$1$ = 240
serialState$ = 240
seqPool$ = 248
prevBucketLog$1$ = 256
params$ = 256
jobSize$ = 264
dict$ = 272
dictSize$ = 280
dictContentType$ = 288
ZSTDMT_serialState_reset PROC

; 471  : {

	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 184				; 000000b8H

; 472  :     /* Adjust parameters */
; 473  :     if (params.ldmParams.enableLdm) {

	cmp	DWORD PTR [r8+96], 0
	mov	rsi, r8
	mov	r12, rdx
	mov	rdi, rcx
	je	SHORT $LN2@ZSTDMT_ser

; 474  :         DEBUGLOG(4, "LDM window size = %u KB", (1U << params.cParams.windowLog) >> 10);
; 475  :         ZSTD_ldm_adjustParameters(&params.ldmParams, &params.cParams);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR [r8+96]
	call	ZSTD_ldm_adjustParameters
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	mov	eax, DWORD PTR [rsi+108]
	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H

; 647  :     U64 power = 1;

	mov	edx, 1

; 686  :     return ZSTD_ipow(prime8bytes, length - 1);

	sub	eax, 1

; 648  :     while (exponent) {

	je	SHORT $LN22@ZSTDMT_ser
	npad	2
$LL21@ZSTDMT_ser:

; 649  :       if (exponent & 1) power *= base;

	test	al, 1
	je	SHORT $LN23@ZSTDMT_ser
	imul	rdx, rcx
$LN23@ZSTDMT_ser:

; 650  :       exponent >>= 1;
; 651  :       base *= base;

	imul	rcx, rcx
	shr	rax, 1
	jne	SHORT $LL21@ZSTDMT_ser
$LN22@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 480  :     } else {

	mov	r9, QWORD PTR jobSize$[rbp-161]
	mov	QWORD PTR [rdi+248], rdx
	jmp	SHORT $LN3@ZSTDMT_ser
$LN2@ZSTDMT_ser:
	xorps	xmm0, xmm0

; 481  :         memset(&params.ldmParams, 0, sizeof(params.ldmParams));

	xor	eax, eax
	movups	XMMWORD PTR [r8+96], xmm0
	mov	QWORD PTR [r8+112], rax
$LN3@ZSTDMT_ser:

; 482  :     }
; 483  :     serialState->nextJobID = 0;

	xor	r14d, r14d
	mov	DWORD PTR [rdi+344], r14d

; 484  :     if (params.fParams.checksumFlag)

	cmp	DWORD PTR [rsi+36], r14d
	je	SHORT $LN4@ZSTDMT_ser
; File E:\dev\pyzstd\lib\common\xxhash.c

; 571  :     state.v1 = seed + PRIME64_1 + PRIME64_2;

	mov	rax, 6983438078262162902		; 60ea27eeadc0b5d6H
	mov	QWORD PTR state$6[rbp-161], r14
	mov	QWORD PTR state$6[rbp-153], rax
	xorps	xmm2, xmm2

; 572  :     state.v2 = seed + PRIME64_2;
; 573  :     state.v3 = seed + 0;
; 574  :     state.v4 = seed - PRIME64_1;
; 575  :     memcpy(statePtr, &state, sizeof(state));

	movaps	xmm0, XMMWORD PTR state$6[rbp-161]
	mov	rax, -4417276706812531889		; c2b2ae3d27d4eb4fH
	movups	XMMWORD PTR [rdi+256], xmm0
	mov	QWORD PTR state$6[rbp-145], rax
	mov	rax, 7046029288634856825		; 61c8864e7a143579H
	mov	QWORD PTR state$6[rbp-137], r14
	xorps	xmm3, xmm3
	movaps	xmm1, XMMWORD PTR state$6[rbp-145]
	movups	XMMWORD PTR [rdi+272], xmm1
	mov	QWORD PTR state$6[rbp-129], rax
	mov	QWORD PTR state$6[rbp-121], r14
	movaps	xmm0, XMMWORD PTR state$6[rbp-129]
	movups	XMMWORD PTR [rdi+288], xmm0
	movsd	xmm0, QWORD PTR state$6[rbp-81]
	movups	XMMWORD PTR [rdi+304], xmm2
	movups	XMMWORD PTR [rdi+320], xmm3
	movsd	QWORD PTR [rdi+336], xmm0
$LN4@ZSTDMT_ser:
	mov	QWORD PTR [rsp+248], rbx
	mov	QWORD PTR [rsp+176], r15
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 486  :     if (params.ldmParams.enableLdm) {

	cmp	DWORD PTR [rsi+96], r14d
	je	$LN5@ZSTDMT_ser

; 487  :         ZSTD_customMem cMem = params.customMem;
; 488  :         unsigned const hashLog = params.ldmParams.hashLog;

	mov	eax, DWORD PTR [rsi+100]

; 489  :         size_t const hashSize = ((size_t)1 << hashLog) * sizeof(ldmEntry_t);

	mov	r15d, 1

; 497  :         ZSTDMT_setNbSeq(seqPool, ZSTD_ldm_getMaxNbSeq(params.ldmParams, jobSize));

	movups	xmm1, XMMWORD PTR [rsi+96]
	mov	ecx, eax
	mov	DWORD PTR hashLog$1$[rbp-161], eax
	movsd	xmm0, QWORD PTR [rsi+112]
	sub	eax, DWORD PTR [rsi+104]
	mov	DWORD PTR bucketLog$1$[rbp-161], eax
	shl	r15, cl
	mov	ecx, eax
	mov	eax, 1
	shl	r15, 3
	shl	rax, cl
	mov	QWORD PTR bucketSize$1$[rbp-161], rax
	mov	eax, DWORD PTR [rdi+148]
	sub	eax, DWORD PTR [rdi+152]
	mov	DWORD PTR prevBucketLog$1$[rbp-161], eax
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 61   :     return params.enableLdm ? (maxChunkSize / params.minMatchLength) : 0;

	movd	eax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 497  :         ZSTDMT_setNbSeq(seqPool, ZSTD_ldm_getMaxNbSeq(params.ldmParams, jobSize));

	movaps	XMMWORD PTR $T5[rsp], xmm1
	movsd	QWORD PTR $T5[rbp-145], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_ldm.c

; 61   :     return params.enableLdm ? (maxChunkSize / params.minMatchLength) : 0;

	test	eax, eax
	je	SHORT $LN29@ZSTDMT_ser
	mov	rcx, QWORD PTR $T5[rbp-153]
	xor	edx, edx
	shr	rcx, 32					; 00000020H
	mov	rax, r9
	div	rcx
	mov	rbx, rax
	jmp	SHORT $LN30@ZSTDMT_ser
$LN29@ZSTDMT_ser:
	mov	rbx, r14
$LN30@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, r12
	call	QWORD PTR __imp_EnterCriticalSection

; 317  :   ZSTDMT_setBufferSize(seqPool, nbSeq * sizeof(rawSeq));

	lea	rax, QWORD PTR [rbx+rbx*2]

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, r12

; 317  :   ZSTDMT_setBufferSize(seqPool, nbSeq * sizeof(rawSeq));

	shl	rax, 2

; 159  :     bufPool->bufferSize = bSize;

	mov	QWORD PTR [r12+40], rax

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 922  :     memset(window, 0, sizeof(*window));

	mov	QWORD PTR [rdi+200], r14
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 499  :         ZSTD_window_init(&serialState->ldmState.window);

	lea	r12, QWORD PTR [rdi+192]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 922  :     memset(window, 0, sizeof(*window));

	mov	QWORD PTR [rdi+208], r14

; 923  :     window->base = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294965452
	mov	QWORD PTR [rdi+216], r14
	mov	QWORD PTR [r12+8], rax

; 924  :     window->dictBase = (BYTE const*)"";

	lea	rax, OFFSET FLAT:$SG4294965451
	mov	QWORD PTR [r12+16], rax

; 925  :     window->dictLimit = 1;    /* start from 1, so that 1st position is valid */
; 926  :     window->lowLimit = 1;     /* it ensures first and later CCtx usages compress the same */
; 927  :     window->nextSrc = window->base + 1;   /* see issue #1241 */

	lea	rax, OFFSET FLAT:$SG4294965452+1
	mov	QWORD PTR [r12], rax
	mov	DWORD PTR [r12+24], 1
	mov	DWORD PTR [r12+28], 1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 501  :         if (serialState->ldmState.hashTable == NULL || serialState->params.ldmParams.hashLog < hashLog) {

	mov	rax, QWORD PTR [rdi+224]
	test	rax, rax
	je	SHORT $LN7@ZSTDMT_ser
	mov	ecx, DWORD PTR hashLog$1$[rbp-161]
	cmp	DWORD PTR [rdi+148], ecx
	jae	SHORT $LN6@ZSTDMT_ser
$LN7@ZSTDMT_ser:

; 502  :             ZSTD_free(serialState->ldmState.hashTable, cMem);

	movsd	xmm1, QWORD PTR [rsi+136]
	movsd	QWORD PTR $T4[rbp-145], xmm1
	movups	xmm0, XMMWORD PTR [rsi+120]
	movaps	XMMWORD PTR $T4[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rax, rax
	je	SHORT $LN40@ZSTDMT_ser

; 78   :         if (customMem.customFree)

	mov	r8, QWORD PTR $T4[rbp-153]
	test	r8, r8
	je	SHORT $LN39@ZSTDMT_ser

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T4[rbp-145]
	mov	rdx, rax
	call	r8
	jmp	SHORT $LN40@ZSTDMT_ser
$LN39@ZSTDMT_ser:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
$LN40@ZSTDMT_ser:

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rsi+120]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 503  :             serialState->ldmState.hashTable = (ldmEntry_t*)ZSTD_malloc(hashSize, cMem);

	movsd	xmm0, QWORD PTR [rsi+136]
	movsd	QWORD PTR $T3[rbp-145], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN43@ZSTDMT_ser

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T3[rbp-145]
	mov	rdx, r15
	call	rax
	jmp	SHORT $LN42@ZSTDMT_ser
$LN43@ZSTDMT_ser:

; 60   :     return malloc(size);

	mov	rcx, r15
	call	QWORD PTR __imp_malloc
$LN42@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 503  :             serialState->ldmState.hashTable = (ldmEntry_t*)ZSTD_malloc(hashSize, cMem);

	mov	QWORD PTR [rdi+224], rax
$LN6@ZSTDMT_ser:

; 504  :         }
; 505  :         if (serialState->ldmState.bucketOffsets == NULL || prevBucketLog < bucketLog) {

	mov	rcx, QWORD PTR [rdi+240]
	test	rcx, rcx
	je	SHORT $LN9@ZSTDMT_ser
	mov	edx, DWORD PTR prevBucketLog$1$[rbp-161]
	cmp	edx, DWORD PTR bucketLog$1$[rbp-161]
	jae	SHORT $LN57@ZSTDMT_ser
$LN9@ZSTDMT_ser:

; 506  :             ZSTD_free(serialState->ldmState.bucketOffsets, cMem);

	movsd	xmm1, QWORD PTR [rsi+136]
	movsd	QWORD PTR $T2[rbp-145], xmm1
	movups	xmm0, XMMWORD PTR [rsi+120]
	movaps	XMMWORD PTR $T2[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN48@ZSTDMT_ser

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T2[rbp-153]
	test	rax, rax
	je	SHORT $LN47@ZSTDMT_ser

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T2[rbp-145]
	call	rax
	jmp	SHORT $LN48@ZSTDMT_ser
$LN47@ZSTDMT_ser:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN48@ZSTDMT_ser:

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rsi+120]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 507  :             serialState->ldmState.bucketOffsets = (BYTE*)ZSTD_malloc(bucketSize, cMem);

	movsd	xmm0, QWORD PTR [rsi+136]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rbx, QWORD PTR bucketSize$1$[rbp-161]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 507  :             serialState->ldmState.bucketOffsets = (BYTE*)ZSTD_malloc(bucketSize, cMem);

	movsd	QWORD PTR $T1[rbp-145], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN51@ZSTDMT_ser

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rbp-145]
	mov	rdx, rbx
	call	rax
	jmp	SHORT $LN58@ZSTDMT_ser
$LN51@ZSTDMT_ser:

; 60   :     return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
$LN58@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 507  :             serialState->ldmState.bucketOffsets = (BYTE*)ZSTD_malloc(bucketSize, cMem);

	mov	rcx, rax
	mov	QWORD PTR [rdi+240], rax
	mov	rax, QWORD PTR [rdi+224]
	jmp	SHORT $LN8@ZSTDMT_ser
$LN57@ZSTDMT_ser:

; 504  :         }
; 505  :         if (serialState->ldmState.bucketOffsets == NULL || prevBucketLog < bucketLog) {

	mov	rbx, QWORD PTR bucketSize$1$[rbp-161]
$LN8@ZSTDMT_ser:

; 508  :         }
; 509  :         if (!serialState->ldmState.hashTable || !serialState->ldmState.bucketOffsets)

	test	rax, rax
	je	$LN11@ZSTDMT_ser
	test	rcx, rcx
	je	$LN11@ZSTDMT_ser

; 511  :         /* Zero the tables */
; 512  :         memset(serialState->ldmState.hashTable, 0, hashSize);

	mov	r8, r15
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 513  :         memset(serialState->ldmState.bucketOffsets, 0, bucketSize);

	mov	rcx, QWORD PTR [rdi+240]
	mov	r8, rbx
	xor	edx, edx
	call	memset

; 514  : 
; 515  :         /* Update window state and fill hash table with dict */
; 516  :         serialState->ldmState.loadedDictEnd = 0;
; 517  :         if (dictSize > 0) {

	mov	r8, QWORD PTR dictSize$[rbp-161]
	mov	DWORD PTR [rdi+232], r14d
	test	r8, r8
	je	SHORT $LN13@ZSTDMT_ser

; 518  :             if (dictContentType == ZSTD_dct_rawContent) {

	cmp	DWORD PTR dictContentType$[rbp-161], 1
	jne	SHORT $LN13@ZSTDMT_ser

; 519  :                 BYTE const* const dictEnd = (const BYTE*)dict + dictSize;

	mov	rbx, QWORD PTR dict$[rbp-161]

; 520  :                 ZSTD_window_update(&serialState->ldmState.window, dict, dictSize);

	mov	rcx, r12
	mov	rdx, rbx
	lea	r15, QWORD PTR [rbx+r8]
	call	ZSTD_window_update

; 521  :                 ZSTD_ldm_fillHashTable(&serialState->ldmState, (const BYTE*)dict, dictEnd, &params.ldmParams);

	lea	r9, QWORD PTR [rsi+96]
	mov	r8, r15
	mov	rdx, rbx
	mov	rcx, r12
	call	ZSTD_ldm_fillHashTable

; 522  :                 serialState->ldmState.loadedDictEnd = params.forceWindow ? 0 : (U32)(dictEnd - serialState->ldmState.window.base);

	cmp	DWORD PTR [rsi+48], r14d
	jne	SHORT $LN17@ZSTDMT_ser
	sub	r15d, DWORD PTR [rdi+200]
	mov	r14d, r15d
$LN17@ZSTDMT_ser:
	mov	DWORD PTR [rdi+232], r14d
$LN13@ZSTDMT_ser:

; 523  :             } else {
; 524  :                 /* don't even load anything */
; 525  :             }
; 526  :         }
; 527  : 
; 528  :         /* Initialize serialState's copy of ldmWindow. */
; 529  :         serialState->ldmWindow = serialState->ldmState.window;

	movups	xmm0, XMMWORD PTR [r12]
	movups	xmm1, XMMWORD PTR [r12+16]
	movups	XMMWORD PTR [rdi+400], xmm0
	movups	XMMWORD PTR [rdi+416], xmm1
$LN5@ZSTDMT_ser:

; 530  :     }
; 531  : 
; 532  :     serialState->params = params;

	movaps	xmm0, XMMWORD PTR [rsi]
	movaps	xmm1, XMMWORD PTR [rsi+16]

; 533  :     serialState->params.jobSize = (U32)jobSize;

	mov	eax, DWORD PTR jobSize$[rbp-161]
	movups	XMMWORD PTR [rdi+48], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+32]
	movups	XMMWORD PTR [rdi+64], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+48]
	movups	XMMWORD PTR [rdi+80], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+64]
	movups	XMMWORD PTR [rdi+96], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+80]
	movups	XMMWORD PTR [rdi+112], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+96]
	movups	XMMWORD PTR [rdi+128], xmm1
	movaps	xmm1, XMMWORD PTR [rsi+112]
	movups	XMMWORD PTR [rdi+144], xmm0
	movaps	xmm0, XMMWORD PTR [rsi+128]
	movups	XMMWORD PTR [rdi+160], xmm1
	movups	XMMWORD PTR [rdi+176], xmm0
	mov	QWORD PTR [rdi+128], rax

; 534  :     return 0;

	xor	eax, eax
$LN1@ZSTDMT_ser:

; 535  : }

	mov	r15, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [rsp+248]
	add	rsp, 184				; 000000b8H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN11@ZSTDMT_ser:

; 510  :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ZSTDMT_ser
ZSTDMT_serialState_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
serialState$ = 48
ZSTDMT_serialState_init PROC

; 538  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 539  :     int initError = 0;
; 540  :     memset(serialState, 0, sizeof(*serialState));

	xor	edx, edx
	mov	r8d, 432				; 000001b0H
	mov	rbx, rcx
	call	memset

; 541  :     initError |= ZSTD_pthread_mutex_init(&serialState->mutex, NULL);

	mov	rcx, rbx
	call	QWORD PTR __imp_InitializeCriticalSection

; 542  :     initError |= ZSTD_pthread_cond_init(&serialState->cond, NULL);

	lea	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_InitializeConditionVariable

; 543  :     initError |= ZSTD_pthread_mutex_init(&serialState->ldmWindowMutex, NULL);

	lea	rcx, QWORD PTR [rbx+352]
	call	QWORD PTR __imp_InitializeCriticalSection

; 544  :     initError |= ZSTD_pthread_cond_init(&serialState->ldmWindowCond, NULL);

	lea	rcx, QWORD PTR [rbx+392]
	call	QWORD PTR __imp_InitializeConditionVariable

; 545  :     return initError;

	xor	eax, eax

; 546  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTDMT_serialState_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
cMem$ = 32
serialState$ = 80
ZSTDMT_serialState_free PROC

; 549  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 550  :     ZSTD_customMem cMem = serialState->params.customMem;

	movups	xmm0, XMMWORD PTR [rcx+168]
	mov	rdi, rcx
	movsd	xmm1, QWORD PTR [rcx+184]
	movups	XMMWORD PTR cMem$[rsp], xmm0
	movsd	QWORD PTR cMem$[rsp+16], xmm1

; 551  :     ZSTD_pthread_mutex_destroy(&serialState->mutex);

	call	QWORD PTR __imp_DeleteCriticalSection

; 552  :     ZSTD_pthread_cond_destroy(&serialState->cond);
; 553  :     ZSTD_pthread_mutex_destroy(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rdi+352]
	call	QWORD PTR __imp_DeleteCriticalSection

; 554  :     ZSTD_pthread_cond_destroy(&serialState->ldmWindowCond);
; 555  :     ZSTD_free(serialState->ldmState.hashTable, cMem);

	mov	rcx, QWORD PTR [rdi+224]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	mov	rbx, QWORD PTR cMem$[rsp+8]
	test	rcx, rcx
	je	SHORT $LN6@ZSTDMT_ser

; 78   :         if (customMem.customFree)

	test	rbx, rbx
	je	SHORT $LN5@ZSTDMT_ser

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR cMem$[rsp+16]
	call	rbx
	jmp	SHORT $LN6@ZSTDMT_ser
$LN5@ZSTDMT_ser:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN6@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 556  :     ZSTD_free(serialState->ldmState.bucketOffsets, cMem);

	mov	rcx, QWORD PTR [rdi+240]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN11@ZSTDMT_ser

; 78   :         if (customMem.customFree)

	test	rbx, rbx
	je	SHORT $LN10@ZSTDMT_ser

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR cMem$[rsp+16]
	mov	rax, rbx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 557  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 79   :             customMem.customFree(customMem.opaque, ptr);

	rex_jmp	rax
$LN10@ZSTDMT_ser:

; 80   :         else
; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN11@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 557  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_serialState_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
serialState$ = 80
jobCCtx$ = 88
seqStore$ = 96
src$ = 104
jobID$ = 112
ZSTDMT_serialState_update PROC

; 562  : {

	push	rbp
	push	r12
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+80], rbx
	mov	r12, r8
	mov	QWORD PTR [rsp+96], rdi
	mov	rbp, rdx
	mov	QWORD PTR [rsp+104], r14
	mov	rbx, rcx
	mov	QWORD PTR [rsp+48], r15
	mov	r15, r9

; 563  :     /* Wait for our turn */
; 564  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 565  :     while (serialState->nextJobID < jobID) {

	mov	eax, DWORD PTR [rbx+344]
	mov	edi, DWORD PTR jobID$[rsp]
	cmp	eax, edi
	jae	SHORT $LN313@ZSTDMT_ser
	npad	4
$LL2@ZSTDMT_ser:

; 566  :         DEBUGLOG(5, "wait for serialState->cond");
; 567  :         ZSTD_pthread_cond_wait(&serialState->cond, &serialState->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rbx
	call	QWORD PTR __imp_SleepConditionVariableCS
	mov	eax, DWORD PTR [rbx+344]
	cmp	eax, edi
	jb	SHORT $LL2@ZSTDMT_ser
$LN313@ZSTDMT_ser:

; 568  :     }
; 569  :     /* A future job may error and skip our job */
; 570  :     if (serialState->nextJobID == jobID) {

	jne	$LN6@ZSTDMT_ser

; 571  :         /* It is now our turn, do any processing necessary */
; 572  :         if (serialState->params.ldmParams.enableLdm) {

	cmp	DWORD PTR [rbx+144], 0
	je	$LN5@ZSTDMT_ser

; 573  :             size_t error;
; 574  :             assert(seqStore.seq != NULL && seqStore.pos == 0 &&
; 575  :                    seqStore.size == 0 && seqStore.capacity > 0);
; 576  :             assert(src.size <= serialState->params.jobSize);
; 577  :             ZSTD_window_update(&serialState->ldmState.window, src.start, src.size);

	mov	r8, QWORD PTR [r15+8]
	lea	rcx, QWORD PTR [rbx+192]
	mov	rdx, QWORD PTR [r15]
	mov	QWORD PTR [rsp+88], rsi
	call	ZSTD_window_update

; 578  :             error = ZSTD_ldm_generateSequences(

	mov	rax, QWORD PTR [r15+8]
	lea	r8, QWORD PTR [rbx+144]
	mov	r9, QWORD PTR [r15]
	lea	rcx, QWORD PTR [rbx+192]
	mov	rdx, r12
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_ldm_generateSequences

; 579  :                 &serialState->ldmState, &seqStore,
; 580  :                 &serialState->params.ldmParams, src.start, src.size);
; 581  :             /* We provide a large enough buffer to never fail. */
; 582  :             assert(!ZSTD_isError(error)); (void)error;
; 583  :             /* Update ldmWindow to match the ldmState.window and signal the main
; 584  :              * thread if it is waiting for a buffer.
; 585  :              */
; 586  :             ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rbx+352]
	call	QWORD PTR __imp_EnterCriticalSection

; 587  :             serialState->ldmWindow = serialState->ldmState.window;

	movups	xmm0, XMMWORD PTR [rbx+192]

; 588  :             ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);

	lea	rcx, QWORD PTR [rbx+392]
	movups	xmm1, XMMWORD PTR [rbx+208]
	movups	XMMWORD PTR [rbx+400], xmm0
	movups	XMMWORD PTR [rbx+416], xmm1
	call	QWORD PTR __imp_WakeConditionVariable

; 589  :             ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rbx+352]
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rsi, QWORD PTR [rsp+88]
$LN5@ZSTDMT_ser:

; 590  :         }
; 591  :         if (serialState->params.fParams.checksumFlag && src.size > 0)

	cmp	DWORD PTR [rbx+84], 0
	je	SHORT $LN6@ZSTDMT_ser
	mov	r8, QWORD PTR [r15+8]
	test	r8, r8
	je	SHORT $LN6@ZSTDMT_ser

; 592  :             XXH64_update(&serialState->xxhState, src.start, src.size);

	mov	rdx, QWORD PTR [r15]
	lea	rcx, QWORD PTR [rbx+256]
	call	XXH64_update
$LN6@ZSTDMT_ser:

; 593  :     }
; 594  :     /* Now it is the next jobs turn */
; 595  :     serialState->nextJobID++;

	inc	DWORD PTR [rbx+344]

; 596  :     ZSTD_pthread_cond_broadcast(&serialState->cond);

	lea	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 597  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 598  : 
; 599  :     if (seqStore.size > 0) {

	mov	rcx, QWORD PTR [r12+16]
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+80]
	test	rcx, rcx
	je	SHORT $LN302@ZSTDMT_ser
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2719 :     RETURN_ERROR_IF(cctx->stage != ZSTDcs_init, stage_wrong,

	cmp	DWORD PTR [rbp], 1
	jne	SHORT $LN302@ZSTDMT_ser

; 2720 :                     "wrong cctx stage");
; 2721 :     RETURN_ERROR_IF(cctx->appliedParams.ldmParams.enableLdm,

	cmp	DWORD PTR [rbp+256], 0
	jne	SHORT $LN302@ZSTDMT_ser

; 2722 :                     parameter_unsupported,
; 2723 :                     "incompatible with ldm");
; 2724 :     cctx->externSeqStore.seq = seq;

	mov	rax, QWORD PTR [r12]
	mov	QWORD PTR [rbp+728], rax

; 2725 :     cctx->externSeqStore.size = nbSeq;

	mov	QWORD PTR [rbp+744], rcx

; 2726 :     cctx->externSeqStore.capacity = nbSeq;

	mov	QWORD PTR [rbp+752], rcx

; 2727 :     cctx->externSeqStore.pos = 0;

	mov	QWORD PTR [rbp+736], 0
$LN302@ZSTDMT_ser:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 606  : }

	add	rsp, 56					; 00000038H
	pop	r12
	pop	rbp
	ret	0
ZSTDMT_serialState_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
serialState$ = 48
jobID$ = 56
cSize$dead$ = 64
ZSTDMT_serialState_ensureFinished PROC

; 610  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx

; 611  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 612  :     if (serialState->nextJobID <= jobID) {

	cmp	DWORD PTR [rdi+344], ebx
	ja	SHORT $LN2@ZSTDMT_ser

; 613  :         assert(ZSTD_isError(cSize)); (void)cSize;
; 614  :         DEBUGLOG(5, "Skipping past job %u because of error", jobID);
; 615  :         serialState->nextJobID = jobID + 1;

	lea	eax, DWORD PTR [rbx+1]

; 616  :         ZSTD_pthread_cond_broadcast(&serialState->cond);

	lea	rcx, QWORD PTR [rdi+40]
	mov	DWORD PTR [rdi+344], eax
	call	QWORD PTR __imp_WakeAllConditionVariable

; 617  : 
; 618  :         ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rdi+352]
	call	QWORD PTR __imp_EnterCriticalSection
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	mov	eax, DWORD PTR [rdi+400]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 620  :         ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);

	lea	rcx, QWORD PTR [rdi+392]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	sub	eax, DWORD PTR [rdi+408]

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rdi+428], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rdi+424], eax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 620  :         ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);

	call	QWORD PTR __imp_WakeConditionVariable

; 621  :         ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rdi+352]
	call	QWORD PTR __imp_LeaveCriticalSection
$LN2@ZSTDMT_ser:

; 622  :     }
; 623  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);

	mov	rcx, rdi

; 624  : 
; 625  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 622  :     }
; 623  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
ZSTDMT_serialState_ensureFinished ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 80
$T2 = 80
$T3 = 80
dstBuff$ = 80
$T4 = 96
$T5 = 96
$T6 = 96
$T7 = 96
$T8 = 128
$T9 = 128
$T10 = 160
$T11 = 192
jobParams$ = 224
oend$1$ = 464
jobDescription$ = 464
tv3830 = 472
ZSTDMT_compressionJob PROC

; 665  : {

	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-200]
	sub	rsp, 416				; 000001a0H

; 666  :     ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;
; 667  :     ZSTD_CCtx_params jobParams = job->params;   /* do not modify job->params ! copy it, modify the copy */

	movups	xmm0, XMMWORD PTR [rcx+160]

; 668  :     ZSTD_CCtx* const cctx = ZSTDMT_getCCtx(job->cctxPool);

	mov	rbx, QWORD PTR [rcx+64]
	mov	rsi, rcx
	movups	xmm1, XMMWORD PTR [rcx+176]
	mov	QWORD PTR [rax+24], rdi
	movaps	XMMWORD PTR jobParams$[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rcx+192]
	movaps	XMMWORD PTR jobParams$[rbp-240], xmm1
	movups	xmm1, XMMWORD PTR [rcx+208]
	movaps	XMMWORD PTR jobParams$[rbp-224], xmm0
	movups	xmm0, XMMWORD PTR [rcx+224]
	movaps	XMMWORD PTR jobParams$[rbp-208], xmm1
	movups	xmm1, XMMWORD PTR [rcx+240]
	movaps	XMMWORD PTR jobParams$[rbp-192], xmm0
	movups	xmm0, XMMWORD PTR [rcx+256]
	movaps	XMMWORD PTR jobParams$[rbp-176], xmm1
	movups	xmm1, XMMWORD PTR [rcx+272]
	movaps	XMMWORD PTR jobParams$[rbp-160], xmm0
	movups	xmm0, XMMWORD PTR [rcx+288]

; 415  :     ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);

	mov	rcx, rbx

; 665  : {

	movaps	XMMWORD PTR [rax-72], xmm6

; 666  :     ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;
; 667  :     ZSTD_CCtx_params jobParams = job->params;   /* do not modify job->params ! copy it, modify the copy */

	movaps	XMMWORD PTR jobParams$[rbp-128], xmm0
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR jobParams$[rbp-144], xmm1

; 415  :     ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 416  :     if (cctxPool->availCCtx) {

	movsxd	rcx, DWORD PTR [rbx+44]
	xor	r15d, r15d
	test	ecx, ecx
	je	SHORT $LN29@ZSTDMT_com

; 417  :         cctxPool->availCCtx--;

	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rbx+44], eax

; 418  :         {   ZSTD_CCtx* const cctx = cctxPool->cctx[cctxPool->availCCtx];

	mov	r14, QWORD PTR [rbx+rcx*8+64]

; 419  :             ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 420  :             return cctx;

	jmp	$LN31@ZSTDMT_com
$LN29@ZSTDMT_com:

; 421  :     }   }
; 422  :     ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection

; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */

	movups	xmm6, XMMWORD PTR [rbx+48]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	mov	edx, r15d
	mov	ecx, r15d
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 424  :     return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */

	movsd	xmm7, QWORD PTR [rbx+64]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 85   :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	movdqa	xmm0, xmm6
	psrldq	xmm0, 8
	movq	rax, xmm0
	test	rax, rax
	movq	rax, xmm6
	sete	dl
	test	rax, rax
	sete	cl
	cmp	edx, ecx
	je	SHORT $LN32@ZSTDMT_com
	mov	r14, r15
	jmp	SHORT $LN31@ZSTDMT_com
$LN32@ZSTDMT_com:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rbx+48]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 86   :     {   ZSTD_CCtx* const cctx = (ZSTD_CCtx*)ZSTD_malloc(sizeof(ZSTD_CCtx), customMem);

	movsd	QWORD PTR $T6[rsp+16], xmm7
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN36@ZSTDMT_com

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T6[rsp+16]
	mov	edx, 1160				; 00000488H
	call	rax
	jmp	SHORT $LN965@ZSTDMT_com
$LN36@ZSTDMT_com:

; 60   :     return malloc(size);

	mov	ecx, 1160				; 00000488H
	call	QWORD PTR __imp_malloc
$LN965@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 87   :         if (!cctx) return NULL;

	mov	r14, rax
	test	rax, rax
	jne	SHORT $LN33@ZSTDMT_com
	mov	r14, r15
	jmp	SHORT $LN31@ZSTDMT_com
$LN33@ZSTDMT_com:

; 88   :         ZSTD_initCCtx(cctx, customMem);

	lea	rdx, QWORD PTR $T5[rsp]
	movaps	XMMWORD PTR $T5[rsp], xmm6
	mov	rcx, r14
	movsd	QWORD PTR $T5[rsp+16], xmm7
	call	ZSTD_initCCtx
$LN31@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 669  :     rawSeqStore_t rawSeqStore = ZSTDMT_getSeq(job->seqPool);

	mov	rdx, QWORD PTR [rsi+80]

; 297  :     if (seqPool->bufferSize == 0) {

	cmp	QWORD PTR [rdx+40], r15
	jne	SHORT $LN39@ZSTDMT_com

; 298  :         return kNullRawSeqStore;

	movups	xmm6, XMMWORD PTR kNullRawSeqStore
	movups	xmm7, XMMWORD PTR kNullRawSeqStore+16
	jmp	SHORT $LN966@ZSTDMT_com
$LN39@ZSTDMT_com:

; 299  :     }
; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	lea	rcx, QWORD PTR $T3[rsp]
	call	ZSTDMT_getBuffer

; 281  :     rawSeqStore_t seq = {NULL, 0, 0, 0};

	mov	QWORD PTR $T4[rsp+8], r15
	mov	QWORD PTR $T4[rsp+16], r15

; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	movups	xmm0, XMMWORD PTR [rax]

; 283  :     seq.capacity = buffer.capacity / sizeof(rawSeq);

	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	movq	QWORD PTR $T4[rsp], xmm0

; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	movups	xmm6, XMMWORD PTR $T4[rsp]

; 283  :     seq.capacity = buffer.capacity / sizeof(rawSeq);

	psrldq	xmm0, 8
	movq	rcx, xmm0
	mul	rcx
	shr	rdx, 3
	mov	QWORD PTR $T4[rsp+24], rdx

; 300  :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));

	movups	xmm7, XMMWORD PTR $T4[rsp+16]
$LN966@ZSTDMT_com:

; 670  :     buffer_t dstBuff = job->dstBuff;

	movups	xmm0, XMMWORD PTR [rsi+96]
	movups	XMMWORD PTR $T10[rbp-240], xmm7
	movups	XMMWORD PTR dstBuff$[rsp], xmm0
	movups	XMMWORD PTR $T10[rbp-256], xmm6

; 671  :     size_t lastCBlockSize = 0;
; 672  : 
; 673  :     /* resources */
; 674  :     if (cctx==NULL) JOB_ERROR(ERROR(memory_allocation));

	test	r14, r14
	jne	SHORT $LN5@ZSTDMT_com
	lea	rcx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_EnterCriticalSection
	lea	rcx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi+8], -64			; ffffffffffffffc0H
	call	QWORD PTR __imp_LeaveCriticalSection
	jmp	$_endJob$974
$LN5@ZSTDMT_com:
	mov	QWORD PTR [rsp+408], r12

; 675  :     if (dstBuff.start == NULL) {   /* streaming job : doesn't provide a dstBuffer */

	mov	r12, QWORD PTR dstBuff$[rsp]
	test	r12, r12
	jne	SHORT $LN6@ZSTDMT_com

; 676  :         dstBuff = ZSTDMT_getBuffer(job->bufPool);

	mov	rdx, QWORD PTR [rsi+72]
	lea	rcx, QWORD PTR $T7[rsp]
	call	ZSTDMT_getBuffer
	movups	xmm0, XMMWORD PTR [rax]

; 677  :         if (dstBuff.start==NULL) JOB_ERROR(ERROR(memory_allocation));

	movq	r12, xmm0
	movups	XMMWORD PTR dstBuff$[rsp], xmm0
	test	r12, r12
	je	SHORT $LN972@ZSTDMT_com

; 678  :         job->dstBuff = dstBuff;   /* this value can be read in ZSTDMT_flush, when it copies the whole job */

	movups	XMMWORD PTR [rsi+96], xmm0
$LN6@ZSTDMT_com:

; 679  :     }
; 680  :     if (jobParams.ldmParams.enableLdm && rawSeqStore.seq == NULL)

	cmp	DWORD PTR jobParams$[rbp-160], r15d
	je	SHORT $LN8@ZSTDMT_com
	cmp	QWORD PTR $T10[rbp-256], r15
	jne	SHORT $LN8@ZSTDMT_com
$LN972@ZSTDMT_com:

; 706  :             if (ZSTD_isError(initError)) JOB_ERROR(initError);

	lea	rcx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_EnterCriticalSection
	lea	rcx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi+8], -64			; ffffffffffffffc0H
	call	QWORD PTR __imp_LeaveCriticalSection
	jmp	$LN963@ZSTDMT_com
$LN8@ZSTDMT_com:

; 681  :         JOB_ERROR(ERROR(memory_allocation));
; 682  : 
; 683  :     /* Don't compute the checksum for chunks, since we compute it externally,
; 684  :      * but write it in the header.
; 685  :      */
; 686  :     if (job->jobID != 0) jobParams.fParams.checksumFlag = 0;

	cmp	DWORD PTR [rsi+144], r15d
	mov	eax, DWORD PTR jobParams$[rbp-220]

; 687  :     /* Don't run LDM for the chunks, since we handle it externally */
; 688  :     jobParams.ldmParams.enableLdm = 0;
; 689  : 
; 690  : 
; 691  :     /* init */
; 692  :     if (job->cdict) {

	mov	r11, QWORD PTR [rsi+304]
	cmovne	eax, r15d
	mov	DWORD PTR jobParams$[rbp-220], eax
	mov	DWORD PTR jobParams$[rbp-160], r15d
	test	r11, r11
	je	SHORT $LN10@ZSTDMT_com
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3132 :     FORWARD_IF_ERROR( ZSTD_checkCParams(params->cParams) , "");

	movups	xmm0, XMMWORD PTR jobParams$[rbp-252]
	lea	rcx, QWORD PTR $T8[rbp-256]
	mov	eax, DWORD PTR jobParams$[rbp-228]
	movsd	xmm1, QWORD PTR jobParams$[rbp-236]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 693  :         size_t const initError = ZSTD_compressBegin_advanced_internal(cctx, NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast, job->cdict, &jobParams, job->fullFrameSize);

	mov	rbx, QWORD PTR [rsi+312]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3132 :     FORWARD_IF_ERROR( ZSTD_checkCParams(params->cParams) , "");

	movaps	XMMWORD PTR $T8[rbp-256], xmm0
	movsd	QWORD PTR $T8[rbp-240], xmm1
	mov	DWORD PTR $T8[rbp-232], eax
	call	ZSTD_checkCParams
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3132 :     FORWARD_IF_ERROR( ZSTD_checkCParams(params->cParams) , "");

	ja	$LN962@ZSTDMT_com

; 3133 :     return ZSTD_compressBegin_internal(cctx,

	mov	DWORD PTR [rsp+64], r15d
	lea	rax, QWORD PTR jobParams$[rbp-256]
	mov	QWORD PTR [rsp+56], rbx
	xor	r9d, r9d
	mov	QWORD PTR [rsp+48], rax
	xor	r8d, r8d
	xor	edx, edx
	mov	QWORD PTR [rsp+40], r11
	mov	rcx, r14
	call	ZSTD_compressBegin_internal
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 695  :         if (ZSTD_isError(initError)) JOB_ERROR(initError);

	jmp	SHORT $LN970@ZSTDMT_com
$LN10@ZSTDMT_com:

; 696  :     } else {  /* srcStart points at reloaded section */
; 697  :         U64 const pledgedSrcSize = job->firstJob ? job->fullFrameSize : job->src.size;

	mov	ecx, DWORD PTR [rsi+148]
	test	ecx, ecx
	je	SHORT $LN24@ZSTDMT_com
	mov	eax, r15d
	sete	al
	mov	DWORD PTR jobParams$[rbp-208], eax
	mov	rax, QWORD PTR [rsi+312]
	jmp	SHORT $LN13@ZSTDMT_com
$LN24@ZSTDMT_com:
	mov	rax, QWORD PTR [rsi+136]
	mov	DWORD PTR jobParams$[rbp-208], 1
$LN13@ZSTDMT_com:

; 698  :         {   size_t const forceWindowError = ZSTD_CCtxParams_setParameter(&jobParams, ZSTD_c_forceMaxWindow, !job->firstJob);
; 699  :             if (ZSTD_isError(forceWindowError)) JOB_ERROR(forceWindowError);
; 700  :         }
; 701  :         {   size_t const initError = ZSTD_compressBegin_advanced_internal(cctx,

	mov	r8, QWORD PTR [rsi+120]
	mov	r9d, 1
	mov	rdx, QWORD PTR [rsi+112]
	mov	rcx, r14
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR jobParams$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], r15
	call	ZSTD_compressBegin_advanced_internal
$LN970@ZSTDMT_com:
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 706  :             if (ZSTD_isError(initError)) JOB_ERROR(initError);

	jbe	SHORT $LN14@ZSTDMT_com
$LN962@ZSTDMT_com:
	lea	rcx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_EnterCriticalSection
	lea	rcx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi+8], rdi
	call	QWORD PTR __imp_LeaveCriticalSection
	jmp	$LN963@ZSTDMT_com
$LN14@ZSTDMT_com:

; 707  :     }   }
; 708  : 
; 709  :     /* Perform serial step as early as possible, but after CCtx initialization */
; 710  :     ZSTDMT_serialState_update(job->serial, cctx, rawSeqStore, job->src, job->jobID);

	movups	xmm0, XMMWORD PTR [rsi+128]
	mov	ebx, DWORD PTR [rsi+144]
	mov	QWORD PTR [rsp+400], r13
	mov	r13, QWORD PTR [rsi+88]

; 564  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);

	mov	rcx, r13

; 707  :     }   }
; 708  : 
; 709  :     /* Perform serial step as early as possible, but after CCtx initialization */
; 710  :     ZSTDMT_serialState_update(job->serial, cctx, rawSeqStore, job->src, job->jobID);

	movaps	XMMWORD PTR $T9[rbp-256], xmm0
	movaps	XMMWORD PTR $T11[rbp-256], xmm6
	movaps	XMMWORD PTR $T11[rbp-240], xmm7

; 564  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 565  :     while (serialState->nextJobID < jobID) {

	mov	eax, DWORD PTR [r13+344]
	cmp	eax, ebx
	jae	SHORT $LN967@ZSTDMT_com
	npad	11
$LL607@ZSTDMT_com:

; 566  :         DEBUGLOG(5, "wait for serialState->cond");
; 567  :         ZSTD_pthread_cond_wait(&serialState->cond, &serialState->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rcx, QWORD PTR [r13+40]
	mov	rdx, r13
	call	QWORD PTR __imp_SleepConditionVariableCS
	mov	eax, DWORD PTR [r13+344]
	cmp	eax, ebx
	jb	SHORT $LL607@ZSTDMT_com
$LN967@ZSTDMT_com:

; 568  :     }
; 569  :     /* A future job may error and skip our job */
; 570  :     if (serialState->nextJobID == jobID) {

	jne	$LN611@ZSTDMT_com

; 571  :         /* It is now our turn, do any processing necessary */
; 572  :         if (serialState->params.ldmParams.enableLdm) {

	mov	rdx, QWORD PTR $T9[rbp-256]
	cmp	DWORD PTR [r13+144], r15d
	je	SHORT $LN610@ZSTDMT_com

; 573  :             size_t error;
; 574  :             assert(seqStore.seq != NULL && seqStore.pos == 0 &&
; 575  :                    seqStore.size == 0 && seqStore.capacity > 0);
; 576  :             assert(src.size <= serialState->params.jobSize);
; 577  :             ZSTD_window_update(&serialState->ldmState.window, src.start, src.size);

	mov	rbx, QWORD PTR $T9[rbp-248]
	lea	rcx, QWORD PTR [r13+192]
	mov	r8, rbx
	call	ZSTD_window_update

; 578  :             error = ZSTD_ldm_generateSequences(

	mov	r9, QWORD PTR $T9[rbp-256]
	lea	r8, QWORD PTR [r13+144]
	lea	rdx, QWORD PTR $T11[rbp-256]
	mov	QWORD PTR [rsp+32], rbx
	lea	rcx, QWORD PTR [r13+192]
	call	ZSTD_ldm_generateSequences

; 579  :                 &serialState->ldmState, &seqStore,
; 580  :                 &serialState->params.ldmParams, src.start, src.size);
; 581  :             /* We provide a large enough buffer to never fail. */
; 582  :             assert(!ZSTD_isError(error)); (void)error;
; 583  :             /* Update ldmWindow to match the ldmState.window and signal the main
; 584  :              * thread if it is waiting for a buffer.
; 585  :              */
; 586  :             ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [r13+352]
	call	QWORD PTR __imp_EnterCriticalSection

; 587  :             serialState->ldmWindow = serialState->ldmState.window;

	movups	xmm0, XMMWORD PTR [r13+192]

; 588  :             ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);

	lea	rcx, QWORD PTR [r13+392]
	movups	xmm1, XMMWORD PTR [r13+208]
	movups	XMMWORD PTR [r13+400], xmm0
	movups	XMMWORD PTR [r13+416], xmm1
	call	QWORD PTR __imp_WakeConditionVariable

; 589  :             ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [r13+352]
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rdx, QWORD PTR $T9[rbp-256]
$LN610@ZSTDMT_com:

; 590  :         }
; 591  :         if (serialState->params.fParams.checksumFlag && src.size > 0)

	cmp	DWORD PTR [r13+84], r15d
	je	SHORT $LN611@ZSTDMT_com
	mov	rax, QWORD PTR $T9[rbp-248]
	test	rax, rax
	je	SHORT $LN611@ZSTDMT_com

; 592  :             XXH64_update(&serialState->xxhState, src.start, src.size);

	lea	rcx, QWORD PTR [r13+256]
	mov	r8, rax
	call	XXH64_update
$LN611@ZSTDMT_com:

; 593  :     }
; 594  :     /* Now it is the next jobs turn */
; 595  :     serialState->nextJobID++;

	inc	DWORD PTR [r13+344]

; 596  :     ZSTD_pthread_cond_broadcast(&serialState->cond);

	lea	rcx, QWORD PTR [r13+40]
	call	QWORD PTR __imp_WakeAllConditionVariable

; 597  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);

	mov	rcx, r13
	call	QWORD PTR __imp_LeaveCriticalSection

; 598  : 
; 599  :     if (seqStore.size > 0) {

	mov	rcx, QWORD PTR $T11[rbp-240]
	test	rcx, rcx
	je	SHORT $LN907@ZSTDMT_com
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2719 :     RETURN_ERROR_IF(cctx->stage != ZSTDcs_init, stage_wrong,

	cmp	DWORD PTR [r14], 1
	jne	SHORT $LN907@ZSTDMT_com

; 2720 :                     "wrong cctx stage");
; 2721 :     RETURN_ERROR_IF(cctx->appliedParams.ldmParams.enableLdm,

	cmp	DWORD PTR [r14+256], r15d
	jne	SHORT $LN907@ZSTDMT_com

; 2722 :                     parameter_unsupported,
; 2723 :                     "incompatible with ldm");
; 2724 :     cctx->externSeqStore.seq = seq;

	mov	rax, QWORD PTR $T11[rbp-256]
	mov	QWORD PTR [r14+728], rax

; 2725 :     cctx->externSeqStore.size = nbSeq;

	mov	QWORD PTR [r14+744], rcx

; 2726 :     cctx->externSeqStore.capacity = nbSeq;

	mov	QWORD PTR [r14+752], rcx

; 2727 :     cctx->externSeqStore.pos = 0;

	mov	QWORD PTR [r14+736], r15
$LN907@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 712  :     if (!job->firstJob) {  /* flush and overwrite frame header when it's not first job */

	mov	rbx, QWORD PTR dstBuff$[rsp+8]
	cmp	DWORD PTR [rsi+148], r15d
	jne	SHORT $LN919@ZSTDMT_com
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	r9, QWORD PTR [rsi+128]
	mov	r8, rbx
	mov	DWORD PTR [rsp+48], r15d
	mov	rdx, r12
	mov	DWORD PTR [rsp+40], 1
	mov	rcx, r14
	mov	QWORD PTR [rsp+32], r15
	call	ZSTD_compressContinue_internal
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 714  :         if (ZSTD_isError(hSize)) JOB_ERROR(hSize);

	ja	$LN969@ZSTDMT_com
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 1595 :     for (i=0; i<ZSTD_REP_NUM; i++) cctx->blockState.prevCBlock->rep[i] = 0;

	mov	rax, QWORD PTR [r14+760]
	mov	DWORD PTR [rax+4580], r15d
	mov	rax, QWORD PTR [r14+760]
	mov	DWORD PTR [rax+4584], r15d
	mov	rax, QWORD PTR [r14+760]
	mov	DWORD PTR [rax+4588], r15d
$LN919@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 721  :         int const nbChunks = (int)((job->src.size + (chunkSize-1)) / chunkSize);

	mov	r9, QWORD PTR [rsi+136]

; 722  :         const BYTE* ip = (const BYTE*) job->src.start;
; 723  :         BYTE* const ostart = (BYTE*)dstBuff.start;
; 724  :         BYTE* op = ostart;

	lea	rdx, QWORD PTR [r12+rbx]
	mov	r13, QWORD PTR [rsi+128]

; 725  :         BYTE* oend = op + dstBuff.capacity;
; 726  :         int chunkNb;
; 727  :         if (sizeof(size_t) > sizeof(int)) assert(job->src.size < ((size_t)INT_MAX) * chunkSize);   /* check overflow */
; 728  :         DEBUGLOG(5, "ZSTDMT_compressionJob: compress %u bytes in %i blocks", (U32)job->src.size, nbChunks);
; 729  :         assert(job->cSize == 0);
; 730  :         for (chunkNb = 1; chunkNb < nbChunks; chunkNb++) {

	mov	edi, 1
	mov	QWORD PTR oend$1$[rbp-256], rdx
	mov	r11d, 524288				; 00080000H
	lea	rax, QWORD PTR [r9+524287]
	shr	rax, 19
	mov	QWORD PTR tv3830[rbp-256], rax
	cmp	eax, edi
	jle	$LN3@ZSTDMT_com
	npad	7
$LL4@ZSTDMT_com:

; 731  :             size_t const cSize = ZSTD_compressContinue(cctx, op, oend-op, ip, chunkSize);

	mov	r8, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	DWORD PTR [rsp+48], r15d
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 731  :             size_t const cSize = ZSTD_compressContinue(cctx, op, oend-op, ip, chunkSize);

	sub	r8, r12
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	DWORD PTR [rsp+40], 1
	mov	r9, r13
	mov	QWORD PTR [rsp+32], r11
	mov	rdx, r12
	mov	rcx, r14
	call	ZSTD_compressContinue_internal
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 732  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);

	lea	rcx, QWORD PTR [rsi+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	rbx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 732  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);

	ja	$LN949@ZSTDMT_com

; 733  :             ip += chunkSize;

	add	r13, 524288				; 00080000H

; 734  :             op += cSize; assert(op < oend);

	add	r12, rax

; 735  :             /* stats */
; 736  :             ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 737  :             job->cSize += cSize;

	add	QWORD PTR [rsi+8], rbx

; 738  :             job->consumed = chunkSize * chunkNb;
; 739  :             DEBUGLOG(5, "ZSTDMT_compressionJob: compress new block : cSize==%u bytes (total: %u)",
; 740  :                         (U32)cSize, (U32)job->cSize);
; 741  :             ZSTD_pthread_cond_signal(&job->job_cond);   /* warns some more data is ready to be flushed */

	lea	rcx, QWORD PTR [rsi+56]
	mov	eax, edi
	shl	rax, 19
	mov	QWORD PTR [rsi], rax
	call	QWORD PTR __imp_WakeConditionVariable

; 742  :             ZSTD_pthread_mutex_unlock(&job->job_mutex);

	lea	rcx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rdx, QWORD PTR oend$1$[rbp-256]
	inc	edi
	mov	r11d, 524288				; 00080000H
	cmp	edi, DWORD PTR tv3830[rbp-256]
	jl	SHORT $LL4@ZSTDMT_com

; 732  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);

	mov	r9, QWORD PTR [rsi+136]
$LN3@ZSTDMT_com:

; 743  :         }
; 744  :         /* last block */
; 745  :         assert(chunkSize > 0);
; 746  :         assert((chunkSize & (chunkSize - 1)) == 0);  /* chunkSize must be power of 2 for mask==(chunkSize-1) to work */
; 747  :         if ((nbChunks > 0) | job->lastJob /*must output a "last block" flag*/ ) {

	mov	r10d, DWORD PTR [rsi+152]
	mov	eax, r15d
	cmp	DWORD PTR tv3830[rbp-256], eax
	setg	al
	or	eax, r10d
	je	$LN964@ZSTDMT_com

; 748  :             size_t const lastBlockSize1 = job->src.size & (chunkSize-1);

	mov	r8, r9

; 749  :             size_t const lastBlockSize = ((lastBlockSize1==0) & (job->src.size>=chunkSize)) ? chunkSize : lastBlockSize1;

	mov	ecx, r15d
	and	r8d, 524287				; 0007ffffH
	mov	eax, r15d
	sete	cl
	cmp	r9, r11

; 750  :             size_t const cSize = (job->lastJob) ?

	mov	r9, r13
	setae	al
	test	ecx, eax
	mov	rcx, r14
	cmovne	r8, r11
	sub	rdx, r12
	test	r10d, r10d
	je	SHORT $LN26@ZSTDMT_com
	mov	QWORD PTR [rsp+32], r8
	mov	r8, rdx
	mov	rdx, r12
	call	ZSTD_compressEnd
	jmp	SHORT $LN968@ZSTDMT_com
$LN949@ZSTDMT_com:

; 732  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);

	call	QWORD PTR __imp_EnterCriticalSection
	lea	rcx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi+8], rbx
	call	QWORD PTR __imp_LeaveCriticalSection
	jmp	SHORT $LN964@ZSTDMT_com
$LN26@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2797 :     return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);

	mov	DWORD PTR [rsp+48], r15d
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], r8
	mov	r8, rdx
	mov	rdx, r12
	call	ZSTD_compressContinue_internal
$LN968@ZSTDMT_com:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rdi, rax
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 753  :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);

	jbe	SHORT $LN20@ZSTDMT_com
$LN969@ZSTDMT_com:
	lea	rcx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_EnterCriticalSection
	lea	rcx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi+8], rdi
	call	QWORD PTR __imp_LeaveCriticalSection
	jmp	SHORT $LN964@ZSTDMT_com
$LN20@ZSTDMT_com:

; 754  :             lastCBlockSize = cSize;

	mov	r15, rdi
$LN964@ZSTDMT_com:
	mov	r13, QWORD PTR [rsp+400]
$LN963@ZSTDMT_com:
	mov	r12, QWORD PTR [rsp+408]
$_endJob$974:

; 755  :     }   }
; 756  : 
; 757  : _endJob:
; 758  :     ZSTDMT_serialState_ensureFinished(job->serial, job->jobID, job->cSize);

	mov	rdi, QWORD PTR [rsi+88]
	mov	ebx, DWORD PTR [rsi+144]

; 611  :     ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection
	movaps	xmm7, XMMWORD PTR [rsp+368]
	movaps	xmm6, XMMWORD PTR [rsp+384]

; 612  :     if (serialState->nextJobID <= jobID) {

	cmp	DWORD PTR [rdi+344], ebx
	ja	SHORT $LN931@ZSTDMT_com

; 613  :         assert(ZSTD_isError(cSize)); (void)cSize;
; 614  :         DEBUGLOG(5, "Skipping past job %u because of error", jobID);
; 615  :         serialState->nextJobID = jobID + 1;

	lea	eax, DWORD PTR [rbx+1]

; 616  :         ZSTD_pthread_cond_broadcast(&serialState->cond);

	lea	rcx, QWORD PTR [rdi+40]
	mov	DWORD PTR [rdi+344], eax
	call	QWORD PTR __imp_WakeAllConditionVariable

; 617  : 
; 618  :         ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rdi+352]
	call	QWORD PTR __imp_EnterCriticalSection
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	mov	eax, DWORD PTR [rdi+400]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 620  :         ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);

	lea	rcx, QWORD PTR [rdi+392]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 719  :     size_t const endT = (size_t)(window->nextSrc - window->base);

	sub	eax, DWORD PTR [rdi+408]

; 720  :     U32 const end = (U32)endT;
; 721  : 
; 722  :     window->lowLimit = end;

	mov	DWORD PTR [rdi+428], eax

; 723  :     window->dictLimit = end;

	mov	DWORD PTR [rdi+424], eax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 620  :         ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);

	call	QWORD PTR __imp_WakeConditionVariable

; 621  :         ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);

	lea	rcx, QWORD PTR [rdi+352]
	call	QWORD PTR __imp_LeaveCriticalSection
$LN931@ZSTDMT_com:

; 622  :     }
; 623  :     ZSTD_pthread_mutex_unlock(&serialState->mutex);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection

; 290  :     buffer.start = seq.seq;

	mov	rax, QWORD PTR $T10[rbp-256]

; 312  :   ZSTDMT_releaseBuffer(seqPool, seqToBuffer(seq));

	lea	rdx, QWORD PTR $T2[rsp]

; 290  :     buffer.start = seq.seq;

	mov	QWORD PTR $T1[rsp], rax

; 291  :     buffer.capacity = seq.capacity * sizeof(rawSeq);

	mov	rax, QWORD PTR $T10[rbp-232]
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	mov	QWORD PTR $T1[rsp+8], rcx

; 312  :   ZSTDMT_releaseBuffer(seqPool, seqToBuffer(seq));

	movaps	xmm0, XMMWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR [rsi+80]
	movdqa	XMMWORD PTR $T2[rsp], xmm0
	call	ZSTDMT_releaseBuffer

; 759  :     if (job->prefix.size > 0)
; 760  :         DEBUGLOG(5, "Finished with prefix: %zx", (size_t)job->prefix.start);
; 761  :     DEBUGLOG(5, "Finished with source: %zx", (size_t)job->src.start);
; 762  :     /* release resources */
; 763  :     ZSTDMT_releaseSeq(job->seqPool, rawSeqStore);
; 764  :     ZSTDMT_releaseCCtx(job->cctxPool, cctx);

	mov	rbx, QWORD PTR [rsi+64]
	mov	rdi, QWORD PTR [rsp+480]

; 429  :     if (cctx==NULL) return;   /* compatibility with release on NULL */

	test	r14, r14
	je	SHORT $LN939@ZSTDMT_com

; 430  :     ZSTD_pthread_mutex_lock(&pool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 431  :     if (pool->availCCtx < pool->totalCCtx)

	movsxd	rax, DWORD PTR [rbx+44]
	cmp	eax, DWORD PTR [rbx+40]
	jge	SHORT $LN941@ZSTDMT_com

; 432  :         pool->cctx[pool->availCCtx++] = cctx;

	mov	QWORD PTR [rbx+rax*8+72], r14
	inc	DWORD PTR [rbx+44]
	jmp	SHORT $LN942@ZSTDMT_com
$LN941@ZSTDMT_com:

; 433  :     else {
; 434  :         /* pool overflow : should not happen, since totalCCtx==nbWorkers */
; 435  :         DEBUGLOG(4, "CCtx pool overflow : free cctx");
; 436  :         ZSTD_freeCCtx(cctx);

	mov	rcx, r14
	call	ZSTD_freeCCtx
$LN942@ZSTDMT_com:

; 437  :     }
; 438  :     ZSTD_pthread_mutex_unlock(&pool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN939@ZSTDMT_com:

; 765  :     /* report */
; 766  :     ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);

	lea	rcx, QWORD PTR [rsi+16]
	call	QWORD PTR __imp_EnterCriticalSection

; 767  :     if (ZSTD_isError(job->cSize)) assert(lastCBlockSize == 0);
; 768  :     job->cSize += lastCBlockSize;
; 769  :     job->consumed = job->src.size;  /* when job->consumed == job->src.size , compression job is presumed completed */

	mov	rax, QWORD PTR [rsi+136]

; 770  :     ZSTD_pthread_cond_signal(&job->job_cond);

	lea	rcx, QWORD PTR [rsi+56]
	add	QWORD PTR [rsi+8], r15
	mov	QWORD PTR [rsi], rax
	call	QWORD PTR __imp_WakeConditionVariable

; 771  :     ZSTD_pthread_mutex_unlock(&job->job_mutex);

	lea	rcx, QWORD PTR [rsi+16]

; 772  : }

	add	rsp, 416				; 000001a0H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	pop	rbp

; 771  :     ZSTD_pthread_mutex_unlock(&job->job_mutex);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
ZSTDMT_compressionJob ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
jobTable$ = 80
nbJobs$ = 88
cMem$ = 96
ZSTDMT_freeJobsTable PROC

; 839  :     U32 jobNb;
; 840  :     if (jobTable == NULL) return;

	test	rcx, rcx
	je	$LN16@ZSTDMT_fre
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 64					; 00000040H

; 838  : {

	mov	rbp, r8
	mov	rsi, rcx

; 841  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	test	edx, edx
	je	SHORT $LN3@ZSTDMT_fre
	mov	QWORD PTR [rsp+80], rbx
	lea	rbx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+88], rdi
	mov	edi, edx
	npad	3
$LL4@ZSTDMT_fre:

; 842  :         ZSTD_pthread_mutex_destroy(&jobTable[jobNb].job_mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_DeleteCriticalSection
	add	rbx, 336				; 00000150H
	sub	rdi, 1
	jne	SHORT $LL4@ZSTDMT_fre

; 841  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
$LN3@ZSTDMT_fre:

; 845  :     ZSTD_free(jobTable, cMem);

	movaps	xmm1, XMMWORD PTR [rbp]
	movsd	xmm0, QWORD PTR [rbp+16]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 845  :     ZSTD_free(jobTable, cMem);

	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN9@ZSTDMT_fre

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, rsi
	call	rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 846  : }

	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
$LN9@ZSTDMT_fre:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 846  : }

	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rsi
$LN16@ZSTDMT_fre:
	ret	0
ZSTDMT_freeJobsTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
nbJobsPtr$ = 96
cMem$ = 104
ZSTDMT_createJobsTable PROC

; 852  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	movsd	xmm0, QWORD PTR [rdx+16]
	mov	r14, rcx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	ecx, ecx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	movsd	QWORD PTR $T1[rsp+16], xmm0
	mov	ebx, 1
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR [r14]
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [rdx]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 853  :     U32 const nbJobsLog2 = ZSTD_highbit32(*nbJobsPtr) + 1;

	inc	ecx

; 854  :     U32 const nbJobs = 1 << nbJobsLog2;

	shl	ebx, cl

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	mov	edi, ebx
	imul	rbp, rdi, 336				; 00000150H
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rdx, rbp
	test	rax, rax
	je	SHORT $LN11@ZSTDMT_cre

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	mov	r8, rbp
	xor	edx, edx
	mov	rcx, rax
	mov	rsi, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN10@ZSTDMT_cre
$LN11@ZSTDMT_cre:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	ecx, 1
	call	QWORD PTR __imp_calloc
	mov	rsi, rax
$LN10@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 859  :     if (jobTable==NULL) return NULL;

	test	rsi, rsi
	jne	SHORT $LN5@ZSTDMT_cre
	xor	eax, eax
	jmp	SHORT $LN1@ZSTDMT_cre
$LN5@ZSTDMT_cre:

; 860  :     *nbJobsPtr = nbJobs;

	mov	DWORD PTR [r14], ebx

; 861  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	test	ebx, ebx
	je	SHORT $LN3@ZSTDMT_cre

; 860  :     *nbJobsPtr = nbJobs;

	lea	rbx, QWORD PTR [rsi+56]
$LL4@ZSTDMT_cre:

; 862  :         initError |= ZSTD_pthread_mutex_init(&jobTable[jobNb].job_mutex, NULL);

	lea	rcx, QWORD PTR [rbx-40]
	call	QWORD PTR __imp_InitializeCriticalSection

; 863  :         initError |= ZSTD_pthread_cond_init(&jobTable[jobNb].job_cond, NULL);

	mov	rcx, rbx
	call	QWORD PTR __imp_InitializeConditionVariable
	add	rbx, 336				; 00000150H
	sub	rdi, 1
	jne	SHORT $LL4@ZSTDMT_cre
$LN3@ZSTDMT_cre:

; 864  :     }
; 865  :     if (initError != 0) {
; 866  :         ZSTDMT_freeJobsTable(jobTable, nbJobs, cMem);
; 867  :         return NULL;
; 868  :     }
; 869  :     return jobTable;

	mov	rax, rsi
$LN1@ZSTDMT_cre:

; 870  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
ZSTDMT_createJobsTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
mtctx$ = 96
r$3 = 104
nbWorkers$ = 104
ZSTDMT_expandJobsTable PROC

; 872  : static size_t ZSTDMT_expandJobsTable (ZSTDMT_CCtx* mtctx, U32 nbWorkers) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 873  :     U32 nbJobs = nbWorkers + 2;
; 874  :     if (nbJobs > mtctx->jobIDMask+1) {  /* need more job capacity */

	mov	eax, DWORD PTR [rcx+732]
	lea	r14d, DWORD PTR [rdx+2]
	inc	eax
	mov	rsi, rcx
	cmp	r14d, eax
	jbe	$LN2@ZSTDMT_exp

; 875  :         ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);

	movups	xmm0, XMMWORD PTR [rcx+776]
	mov	rbp, QWORD PTR [rcx+8]
	movsd	xmm1, QWORD PTR [rcx+792]
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	QWORD PTR $T2[rsp+16], xmm1

; 840  :     if (jobTable == NULL) return;

	test	rbp, rbp
	je	SHORT $LN14@ZSTDMT_exp

; 841  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	test	eax, eax
	je	SHORT $LN7@ZSTDMT_exp
	lea	rbx, QWORD PTR [rbp+16]
	mov	edi, eax
$LL8@ZSTDMT_exp:

; 842  :         ZSTD_pthread_mutex_destroy(&jobTable[jobNb].job_mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_DeleteCriticalSection
	add	rbx, 336				; 00000150H
	sub	rdi, 1
	jne	SHORT $LL8@ZSTDMT_exp
$LN7@ZSTDMT_exp:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T2[rsp+8]
	test	rax, rax
	je	SHORT $LN13@ZSTDMT_exp

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rbp
	call	rax
	jmp	SHORT $LN14@ZSTDMT_exp
$LN13@ZSTDMT_exp:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN14@ZSTDMT_exp:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	movsd	xmm0, QWORD PTR [rsi+792]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, 0
	bsr	eax, r14d
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 854  :     U32 const nbJobs = 1 << nbJobsLog2;

	mov	r14d, 1

; 876  :         mtctx->jobIDMask = 0;

	mov	DWORD PTR [rsi+732], 0
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$3[rsp], 0

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [rsi+776]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 853  :     U32 const nbJobsLog2 = ZSTD_highbit32(*nbJobsPtr) + 1;

	inc	ecx

; 854  :     U32 const nbJobs = 1 << nbJobsLog2;

	shl	r14d, cl

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	mov	edi, r14d
	imul	rbx, rdi, 336				; 00000150H
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rdx, rbx
	test	rax, rax
	je	SHORT $LN26@ZSTDMT_exp

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	mov	rbp, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN25@ZSTDMT_exp
$LN26@ZSTDMT_exp:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	ecx, 1
	call	QWORD PTR __imp_calloc
	mov	rbp, rax
$LN25@ZSTDMT_exp:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 859  :     if (jobTable==NULL) return NULL;

	test	rbp, rbp
	jne	SHORT $LN20@ZSTDMT_exp
	mov	QWORD PTR [rsi+8], rbp

; 877  :         mtctx->jobs = ZSTDMT_createJobsTable(&nbJobs, mtctx->cMem);
; 878  :         if (mtctx->jobs==NULL) return ERROR(memory_allocation);

	lea	rax, QWORD PTR [rbp-64]
	jmp	SHORT $LN1@ZSTDMT_exp
$LN20@ZSTDMT_exp:

; 861  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	test	r14d, r14d
	je	SHORT $LN18@ZSTDMT_exp

; 860  :     *nbJobsPtr = nbJobs;

	lea	rbx, QWORD PTR [rbp+56]
	npad	5
$LL19@ZSTDMT_exp:

; 862  :         initError |= ZSTD_pthread_mutex_init(&jobTable[jobNb].job_mutex, NULL);

	lea	rcx, QWORD PTR [rbx-40]
	call	QWORD PTR __imp_InitializeCriticalSection

; 863  :         initError |= ZSTD_pthread_cond_init(&jobTable[jobNb].job_cond, NULL);

	mov	rcx, rbx
	call	QWORD PTR __imp_InitializeConditionVariable
	add	rbx, 336				; 00000150H
	sub	rdi, 1
	jne	SHORT $LL19@ZSTDMT_exp
$LN18@ZSTDMT_exp:

; 879  :         assert((nbJobs != 0) && ((nbJobs & (nbJobs - 1)) == 0));  /* ensure nbJobs is a power of 2 */
; 880  :         mtctx->jobIDMask = nbJobs - 1;

	lea	eax, DWORD PTR [r14-1]

; 869  :     return jobTable;

	mov	QWORD PTR [rsi+8], rbp

; 879  :         assert((nbJobs != 0) && ((nbJobs & (nbJobs - 1)) == 0));  /* ensure nbJobs is a power of 2 */
; 880  :         mtctx->jobIDMask = nbJobs - 1;

	mov	DWORD PTR [rsi+732], eax
$LN2@ZSTDMT_exp:

; 881  :     }
; 882  :     return 0;

	xor	eax, eax
$LN1@ZSTDMT_exp:

; 883  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
ZSTDMT_expandJobsTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 0
params$ = 32
nbWorkers$ = 40
ZSTDMT_CCtxParam_setNbWorkers PROC

; 889  : {

$LN553:
	sub	rsp, 24
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 330  :         bounds.lowerBound = 0;

	xor	r8d, r8d

; 331  : #ifdef ZSTD_MULTITHREAD
; 332  :         bounds.upperBound = ZSTDMT_NBWORKERS_MAX;

	mov	DWORD PTR $T1[rsp+12], 200		; 000000c8H

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	test	edx, edx

; 330  :         bounds.lowerBound = 0;

	mov	DWORD PTR $T1[rsp+8], r8d

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	rax, QWORD PTR $T1[rsp+8]
	cmovns	r8d, edx
	shr	rax, 32					; 00000020H

; 632  :         CCtxParams->nbWorkers = value;

	cmp	r8d, eax
	cmovle	eax, r8d
	mov	DWORD PTR [rcx+76], eax

; 633  :         return CCtxParams->nbWorkers;

	cdqe
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 891  : }

	add	rsp, 24
	ret	0
ZSTDMT_CCtxParam_setNbWorkers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
nbJobs$1$ = 128
nbWorkers$ = 128
cMem$ = 136
ZSTDMT_createCCtx_advanced_internal PROC

; 894  : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 72					; 00000048H

; 895  :     ZSTDMT_CCtx* mtctx;
; 896  :     U32 nbJobs = nbWorkers + 2;

	lea	ebx, DWORD PTR [rcx+2]
	mov	r14, rdx
	mov	DWORD PTR nbJobs$1$[rsp], ebx

; 897  :     int initError;
; 898  :     DEBUGLOG(3, "ZSTDMT_createCCtx_advanced (nbWorkers = %u)", nbWorkers);
; 899  : 
; 900  :     if (nbWorkers < 1) return NULL;

	cmp	ecx, 1
	jb	$LN602@ZSTDMT_cre

; 901  :     nbWorkers = MIN(nbWorkers , ZSTDMT_NBWORKERS_MAX);

	mov	r12d, 200				; 000000c8H
	cmp	ecx, r12d
	cmovb	r12d, ecx

; 902  :     if ((cMem.customAlloc!=NULL) ^ (cMem.customFree!=NULL))

	xor	esi, esi
	mov	ecx, esi
	mov	eax, esi
	cmp	QWORD PTR [rdx+8], rcx
	setne	cl
	cmp	QWORD PTR [rdx], rax
	setne	al
	cmp	ecx, eax
	jne	$LN602@ZSTDMT_cre
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [rdx]
	lea	r15d, QWORD PTR [rsi+1]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 906  :     mtctx = (ZSTDMT_CCtx*) ZSTD_calloc(sizeof(ZSTDMT_CCtx), cMem);

	movsd	xmm0, QWORD PTR [rdx+16]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	edx, 816				; 00000330H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 906  :     mtctx = (ZSTDMT_CCtx*) ZSTD_calloc(sizeof(ZSTDMT_CCtx), cMem);

	movsd	QWORD PTR $T7[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	test	rax, rax
	je	SHORT $LN8@ZSTDMT_cre

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T7[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	xor	edx, edx
	mov	r8d, 816				; 00000330H
	mov	rcx, rax
	mov	rdi, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN7@ZSTDMT_cre
$LN8@ZSTDMT_cre:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	rcx, r15
	call	QWORD PTR __imp_calloc
	mov	rdi, rax
$LN7@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 907  :     if (!mtctx) return NULL;

	test	rdi, rdi
	je	$LN602@ZSTDMT_cre

; 908  :     ZSTDMT_CCtxParam_setNbWorkers(&mtctx->params, nbWorkers);
; 909  :     mtctx->cMem = cMem;

	movaps	xmm0, XMMWORD PTR [r14]

; 911  :     mtctx->factory = POOL_create_advanced(nbWorkers, 0, cMem);

	lea	r8, QWORD PTR $T6[rsp]
	movsd	xmm1, QWORD PTR [r14+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	test	r12d, r12d

; 330  :         bounds.lowerBound = 0;

	mov	DWORD PTR $T3[rsp+8], esi

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	edx, esi
	cmovns	edx, r12d

; 332  :         bounds.upperBound = ZSTDMT_NBWORKERS_MAX;

	mov	DWORD PTR $T3[rsp+12], 200		; 000000c8H

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	rcx, QWORD PTR $T3[rsp+8]
	shr	rcx, 32					; 00000020H

; 632  :         CCtxParams->nbWorkers = value;

	cmp	edx, ecx

; 330  :         bounds.lowerBound = 0;

	mov	QWORD PTR [rsp+136], rbp
	mov	QWORD PTR [rsp+64], r13

; 632  :         CCtxParams->nbWorkers = value;

	cmovle	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 911  :     mtctx->factory = POOL_create_advanced(nbWorkers, 0, cMem);

	movaps	XMMWORD PTR $T6[rsp], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 632  :         CCtxParams->nbWorkers = value;

	mov	DWORD PTR [rdi+116], ecx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 911  :     mtctx->factory = POOL_create_advanced(nbWorkers, 0, cMem);

	xor	edx, edx
	movups	XMMWORD PTR [rdi+776], xmm0
	mov	ecx, r12d
	movsd	QWORD PTR [rdi+792], xmm1
	mov	DWORD PTR [rdi+748], r15d
	movsd	QWORD PTR $T6[rsp+16], xmm1
	call	POOL_create_advanced

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	movsd	xmm0, QWORD PTR [r14+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, esi
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 911  :     mtctx->factory = POOL_create_advanced(nbWorkers, 0, cMem);

	mov	QWORD PTR [rdi], rax

; 854  :     U32 const nbJobs = 1 << nbJobsLog2;

	mov	r13d, r15d
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, ebx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rax, QWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 853  :     U32 const nbJobsLog2 = ZSTD_highbit32(*nbJobsPtr) + 1;

	inc	ecx

; 854  :     U32 const nbJobs = 1 << nbJobsLog2;

	shl	r13d, cl

; 856  :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)

	mov	ebp, r13d
	imul	rbx, rbp, 336				; 00000150H
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 65   :     if (customMem.customAlloc) {

	mov	rdx, rbx
	test	rax, rax
	je	SHORT $LN570@ZSTDMT_cre

; 66   :         /* calloc implemented as malloc+memset;
; 67   :          * not as efficient as calloc, but next best guess for custom malloc */
; 68   :         void* const ptr = customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T2[rsp+16]
	call	rax

; 69   :         memset(ptr, 0, size);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	mov	r15, rax
	call	memset

; 70   :         return ptr;

	jmp	SHORT $LN569@ZSTDMT_cre
$LN570@ZSTDMT_cre:

; 71   :     }
; 72   :     return calloc(1, size);

	mov	rcx, r15
	call	QWORD PTR __imp_calloc
	mov	r15, rax
$LN569@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 859  :     if (jobTable==NULL) return NULL;

	test	r15, r15
	jne	SHORT $LN564@ZSTDMT_cre
	mov	r15, rsi
	jmp	SHORT $LN562@ZSTDMT_cre
$LN564@ZSTDMT_cre:

; 860  :     *nbJobsPtr = nbJobs;

	mov	DWORD PTR nbJobs$1$[rsp], r13d

; 861  :     for (jobNb=0; jobNb<nbJobs; jobNb++) {

	test	r13d, r13d
	je	SHORT $LN562@ZSTDMT_cre

; 860  :     *nbJobsPtr = nbJobs;

	lea	rbx, QWORD PTR [r15+56]
	npad	6
$LL563@ZSTDMT_cre:

; 862  :         initError |= ZSTD_pthread_mutex_init(&jobTable[jobNb].job_mutex, NULL);

	lea	rcx, QWORD PTR [rbx-40]
	call	QWORD PTR __imp_InitializeCriticalSection

; 863  :         initError |= ZSTD_pthread_cond_init(&jobTable[jobNb].job_cond, NULL);

	mov	rcx, rbx
	call	QWORD PTR __imp_InitializeConditionVariable
	add	rbx, 336				; 00000150H
	sub	rbp, 1
	jne	SHORT $LL563@ZSTDMT_cre
$LN562@ZSTDMT_cre:

; 912  :     mtctx->jobs = ZSTDMT_createJobsTable(&nbJobs, cMem);
; 913  :     assert(nbJobs > 0); assert((nbJobs & (nbJobs - 1)) == 0);  /* ensure nbJobs is a power of 2 */
; 914  :     mtctx->jobIDMask = nbJobs - 1;

	mov	eax, DWORD PTR nbJobs$1$[rsp]

; 915  :     mtctx->bufPool = ZSTDMT_createBufferPool(nbWorkers, cMem);

	lea	rdx, QWORD PTR $T5[rsp]
	movaps	xmm0, XMMWORD PTR [r14]
	dec	eax
	movsd	xmm1, QWORD PTR [r14+16]
	mov	ecx, r12d
	mov	DWORD PTR [rdi+732], eax
	mov	QWORD PTR [rdi+8], r15
	movaps	XMMWORD PTR $T5[rsp], xmm0
	movsd	QWORD PTR $T5[rsp+16], xmm1
	call	ZSTDMT_createBufferPool

; 916  :     mtctx->cctxPool = ZSTDMT_createCCtxPool(nbWorkers, cMem);

	movaps	xmm0, XMMWORD PTR [r14]
	lea	rdx, QWORD PTR $T4[rsp]
	movsd	xmm1, QWORD PTR [r14+16]
	mov	ecx, r12d
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movsd	QWORD PTR $T4[rsp+16], xmm1
	mov	QWORD PTR [rdi+16], rax
	call	ZSTDMT_createCCtxPool

; 322  :     ZSTDMT_seqPool* const seqPool = ZSTDMT_createBufferPool(nbWorkers, cMem);

	movaps	xmm0, XMMWORD PTR [r14]
	lea	rdx, QWORD PTR $T1[rsp]
	movsd	xmm1, QWORD PTR [r14+16]
	mov	ecx, r12d
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR $T1[rsp+16], xmm1

; 916  :     mtctx->cctxPool = ZSTDMT_createCCtxPool(nbWorkers, cMem);

	mov	QWORD PTR [rdi+24], rax

; 322  :     ZSTDMT_seqPool* const seqPool = ZSTDMT_createBufferPool(nbWorkers, cMem);

	call	ZSTDMT_createBufferPool
	mov	r13, QWORD PTR [rsp+64]
	mov	rbx, rax
	mov	rbp, QWORD PTR [rsp+136]

; 323  :     if (seqPool == NULL) return NULL;

	test	rax, rax
	jne	SHORT $LN584@ZSTDMT_cre
	mov	rbx, rsi
	jmp	SHORT $LN583@ZSTDMT_cre
$LN584@ZSTDMT_cre:

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 158  :     DEBUGLOG(4, "ZSTDMT_setBufferSize: bSize = %u", (U32)bSize);
; 159  :     bufPool->bufferSize = bSize;
; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rbx
	mov	QWORD PTR [rbx+40], rsi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN583@ZSTDMT_cre:

; 540  :     memset(serialState, 0, sizeof(*serialState));

	xor	edx, edx

; 917  :     mtctx->seqPool = ZSTDMT_createSeqPool(nbWorkers, cMem);

	mov	QWORD PTR [rdi+32], rbx

; 540  :     memset(serialState, 0, sizeof(*serialState));

	mov	r8d, 432				; 000001b0H
	lea	rcx, QWORD PTR [rdi+272]
	call	memset

; 541  :     initError |= ZSTD_pthread_mutex_init(&serialState->mutex, NULL);

	lea	rcx, QWORD PTR [rdi+272]
	call	QWORD PTR __imp_InitializeCriticalSection

; 542  :     initError |= ZSTD_pthread_cond_init(&serialState->cond, NULL);

	lea	rcx, QWORD PTR [rdi+312]
	call	QWORD PTR __imp_InitializeConditionVariable

; 543  :     initError |= ZSTD_pthread_mutex_init(&serialState->ldmWindowMutex, NULL);

	lea	rcx, QWORD PTR [rdi+624]
	call	QWORD PTR __imp_InitializeCriticalSection

; 544  :     initError |= ZSTD_pthread_cond_init(&serialState->ldmWindowCond, NULL);

	lea	rcx, QWORD PTR [rdi+664]
	call	QWORD PTR __imp_InitializeConditionVariable

; 918  :     initError = ZSTDMT_serialState_init(&mtctx->serial);
; 919  :     mtctx->roundBuff = kNullRoundBuff;

	movups	xmm0, XMMWORD PTR kNullRoundBuff

; 920  :     if (!mtctx->factory | !mtctx->jobs | !mtctx->bufPool | !mtctx->cctxPool | !mtctx->seqPool | initError) {

	mov	eax, esi
	mov	ecx, esi
	movsd	xmm1, QWORD PTR kNullRoundBuff+16
	cmp	QWORD PTR [rdi+32], rcx
	movups	XMMWORD PTR [rdi+248], xmm0
	sete	cl
	cmp	QWORD PTR [rdi+24], rax
	movsd	QWORD PTR [rdi+264], xmm1
	sete	al
	or	ecx, eax
	mov	eax, 1
	cmp	QWORD PTR [rdi+16], rsi
	cmove	ecx, eax
	cmp	QWORD PTR [rdi+8], rsi
	sete	sil
	or	ecx, esi
	cmp	QWORD PTR [rdi], 0
	cmove	ecx, eax
	test	ecx, ecx
	je	SHORT $LN5@ZSTDMT_cre

; 921  :         ZSTDMT_freeCCtx(mtctx);

	mov	rcx, rdi
	call	ZSTDMT_freeCCtx
$LN602@ZSTDMT_cre:

; 926  : }

	xor	eax, eax
	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@ZSTDMT_cre:

; 922  :         return NULL;
; 923  :     }
; 924  :     DEBUGLOG(3, "mt_cctx created, for %u threads", nbWorkers);
; 925  :     return mtctx;

	mov	rax, rdi

; 926  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ZSTDMT_createCCtx_advanced_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
mutex$1$ = 48
mutex$2$ = 64
$T2 = 80
mutex$3$ = 144
mtctx$ = 144
ZSTDMT_releaseAllJobResources PROC

; 948  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	rsi, rcx

; 949  :     unsigned jobID;
; 950  :     DEBUGLOG(3, "ZSTDMT_releaseAllJobResources");
; 951  :     for (jobID=0; jobID <= mtctx->jobIDMask; jobID++) {

	xor	r14d, r14d
	npad	2
$LL4@ZSTDMT_rel:

; 952  :         /* Copy the mutex/cond out */
; 953  :         ZSTD_pthread_mutex_t const mutex = mtctx->jobs[jobID].job_mutex;
; 954  :         ZSTD_pthread_cond_t const cond = mtctx->jobs[jobID].job_cond;
; 955  : 
; 956  :         DEBUGLOG(4, "job%02u: release dst address %08X", jobID, (U32)(size_t)mtctx->jobs[jobID].dstBuff.start);
; 957  :         ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[jobID].dstBuff);

	mov	rdi, QWORD PTR [rsi+16]
	mov	eax, r14d
	imul	r15, rax, 336				; 00000150H
	mov	rax, QWORD PTR [rsi+8]
	movups	xmm0, XMMWORD PTR [rax+r15+16]
	mov	rbx, QWORD PTR [rax+r15+56]
	movups	XMMWORD PTR mutex$1$[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rax+r15+32]
	movups	XMMWORD PTR mutex$2$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+r15+48]
	movsd	QWORD PTR mutex$3$[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rax+r15+96]

; 252  :     if (buf.start == NULL) return;   /* compatible with release on NULL */

	movq	rbp, xmm0

; 952  :         /* Copy the mutex/cond out */
; 953  :         ZSTD_pthread_mutex_t const mutex = mtctx->jobs[jobID].job_mutex;
; 954  :         ZSTD_pthread_cond_t const cond = mtctx->jobs[jobID].job_cond;
; 955  : 
; 956  :         DEBUGLOG(4, "job%02u: release dst address %08X", jobID, (U32)(size_t)mtctx->jobs[jobID].dstBuff.start);
; 957  :         ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[jobID].dstBuff);

	movaps	XMMWORD PTR $T1[rsp], xmm0

; 252  :     if (buf.start == NULL) return;   /* compatible with release on NULL */

	test	rbp, rbp
	je	SHORT $LN13@ZSTDMT_rel

; 253  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 254  :     if (bufPool->nbBuffers < bufPool->totalBuffers) {

	mov	eax, DWORD PTR [rdi+52]
	mov	rcx, rdi
	cmp	eax, DWORD PTR [rdi+48]
	jae	SHORT $LN8@ZSTDMT_rel

; 255  :         bufPool->bTable[bufPool->nbBuffers++] = buf;  /* stored for later use */

	movaps	xmm0, XMMWORD PTR $T1[rsp]
	add	rax, 5
	add	rax, rax
	movups	XMMWORD PTR [rdi+rax*8], xmm0
	inc	DWORD PTR [rdi+52]

; 256  :         DEBUGLOG(5, "ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u",
; 257  :                     (U32)buf.capacity, (U32)(bufPool->nbBuffers-1));
; 258  :         ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 259  :         return;

	jmp	SHORT $LN13@ZSTDMT_rel
$LN8@ZSTDMT_rel:

; 260  :     }
; 261  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movups	xmm1, XMMWORD PTR [rdi+56]
	movsd	xmm0, QWORD PTR [rdi+72]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movsd	QWORD PTR $T2[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN12@ZSTDMT_rel

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR $T2[rsp+16]
	mov	rdx, rbp
	call	rax
	jmp	SHORT $LN13@ZSTDMT_rel
$LN12@ZSTDMT_rel:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN13@ZSTDMT_rel:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 960  :         memset(&mtctx->jobs[jobID], 0, sizeof(mtctx->jobs[jobID]));

	mov	rcx, QWORD PTR [rsi+8]
	xor	edx, edx
	add	rcx, r15
	mov	r8d, 336				; 00000150H
	call	memset

; 961  :         mtctx->jobs[jobID].job_mutex = mutex;

	mov	rax, QWORD PTR [rsi+8]
	inc	r14d
	movups	xmm0, XMMWORD PTR mutex$1$[rsp]
	movups	xmm1, XMMWORD PTR mutex$2$[rsp]
	movups	XMMWORD PTR [rax+r15+16], xmm0
	movsd	xmm0, QWORD PTR mutex$3$[rsp]
	movups	XMMWORD PTR [rax+r15+32], xmm1
	movsd	QWORD PTR [rax+r15+48], xmm0

; 962  :         mtctx->jobs[jobID].job_cond = cond;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rax+r15+56], rbx
	cmp	r14d, DWORD PTR [rsi+732]
	jbe	$LL4@ZSTDMT_rel

; 963  :     }
; 964  :     mtctx->inBuff.buffer = g_nullBuffer;

	movaps	xmm0, XMMWORD PTR g_nullBuffer

; 965  :     mtctx->inBuff.filled = 0;
; 966  :     mtctx->allJobsCompleted = 1;
; 967  : }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	movups	XMMWORD PTR [rsi+224], xmm0
	mov	QWORD PTR [rsi+240], 0
	mov	DWORD PTR [rsi+748], 1
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
ZSTDMT_releaseAllJobResources ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
mtctx$ = 48
ZSTDMT_waitForAllJobsCompleted PROC

; 970  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 971  :     DEBUGLOG(4, "ZSTDMT_waitForAllJobsCompleted");
; 972  :     while (mtctx->doneJobID < mtctx->nextJobID) {

	mov	eax, DWORD PTR [rcx+736]
	mov	rbx, rcx
	cmp	eax, DWORD PTR [rcx+740]
	jae	$LN3@ZSTDMT_wai
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi
	npad	11
$LL2@ZSTDMT_wai:

; 973  :         unsigned const jobID = mtctx->doneJobID & mtctx->jobIDMask;

	mov	edi, DWORD PTR [rbx+732]

; 974  :         ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[jobID].job_mutex);

	mov	rcx, QWORD PTR [rbx+8]
	and	rdi, rax
	add	rcx, 16
	imul	rsi, rdi, 336				; 00000150H
	add	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 975  :         while (mtctx->jobs[jobID].consumed < mtctx->jobs[jobID].src.size) {

	mov	rdx, QWORD PTR [rbx+8]
	imul	rax, rdi, 336				; 00000150H
	mov	rcx, QWORD PTR [rax+rdx+136]
	cmp	QWORD PTR [rsi+rdx], rcx
	jae	SHORT $LN13@ZSTDMT_wai
	npad	6
$LL4@ZSTDMT_wai:

; 976  :             DEBUGLOG(4, "waiting for jobCompleted signal from job %u", mtctx->doneJobID);   /* we want to block when waiting for data to flush */
; 977  :             ZSTD_pthread_cond_wait(&mtctx->jobs[jobID].job_cond, &mtctx->jobs[jobID].job_mutex);

	mov	rax, QWORD PTR [rbx+8]
	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR [rax+56]
	add	rdx, rsi
	add	rcx, rsi
	call	QWORD PTR __imp_SleepConditionVariableCS
	mov	rdx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rdx+rsi+136]
	cmp	QWORD PTR [rdx+rsi], rax
	jb	SHORT $LL4@ZSTDMT_wai
$LN13@ZSTDMT_wai:

; 978  :         }
; 979  :         ZSTD_pthread_mutex_unlock(&mtctx->jobs[jobID].job_mutex);

	lea	rcx, QWORD PTR [rdx+16]
	add	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection

; 980  :         mtctx->doneJobID++;

	mov	eax, DWORD PTR [rbx+736]
	inc	eax
	mov	DWORD PTR [rbx+736], eax
	cmp	eax, DWORD PTR [rbx+740]
	jb	$LL2@ZSTDMT_wai

; 971  :     DEBUGLOG(4, "ZSTDMT_waitForAllJobsCompleted");
; 972  :     while (mtctx->doneJobID < mtctx->nextJobID) {

	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]
$LN3@ZSTDMT_wai:

; 981  :     }
; 982  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTDMT_waitForAllJobsCompleted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 8
params$ = 16
ZSTDMT_initJobCCtxParams PROC

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm0, XMMWORD PTR [rdx]

; 1062 :     /* Clear parameters related to multithreading */
; 1063 :     jobParams.forceWindow = 0;

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movaps	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movaps	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movaps	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	movaps	xmm0, XMMWORD PTR [rdx+64]
	movups	XMMWORD PTR [rcx+64], xmm0
	movaps	xmm1, XMMWORD PTR [rdx+80]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx+80], xmm1
	mov	DWORD PTR [rcx+48], eax

; 1064 :     jobParams.nbWorkers = 0;

	mov	DWORD PTR [rcx+76], eax

; 1065 :     jobParams.jobSize = 0;

	mov	QWORD PTR [rcx+80], rax

; 1066 :     jobParams.overlapLog = 0;

	mov	QWORD PTR [rcx+88], rax

; 1067 :     jobParams.rsyncable = 0;
; 1068 :     memset(&jobParams.ldmParams, 0, sizeof(ldmParams_t));
; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));
; 1070 :     return jobParams;

	mov	rax, rcx
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	movups	XMMWORD PTR [rcx+128], xmm0

; 1071 : }

	ret	0
ZSTDMT_initJobCCtxParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
cMem$1$ = 32
$T1 = 32
$T2 = 32
cMem$2$ = 80
mtctx$ = 80
nbWorkers$ = 88
ZSTDMT_resize PROC

; 1077 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	edi, edx
	mov	rbx, rcx

; 1078 :     if (POOL_resize(mtctx->factory, nbWorkers)) return ERROR(memory_allocation);

	mov	rcx, QWORD PTR [rcx]
	mov	edx, edx
	call	POOL_resize
	test	eax, eax
	jne	SHORT $LN573@ZSTDMT_res

; 1079 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbWorkers) , "");

	mov	edx, edi
	mov	rcx, rbx
	call	ZSTDMT_expandJobsTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1079 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbWorkers) , "");

	ja	SHORT $LN1@ZSTDMT_res

; 1080 :     mtctx->bufPool = ZSTDMT_expandBufferPool(mtctx->bufPool, nbWorkers);

	mov	rcx, QWORD PTR [rbx+16]
	mov	edx, edi
	call	ZSTDMT_expandBufferPool
	mov	QWORD PTR [rbx+16], rax

; 1081 :     if (mtctx->bufPool == NULL) return ERROR(memory_allocation);

	test	rax, rax
	je	SHORT $LN573@ZSTDMT_res

; 1082 :     mtctx->cctxPool = ZSTDMT_expandCCtxPool(mtctx->cctxPool, nbWorkers);

	mov	rcx, QWORD PTR [rbx+24]

; 385  :     if (srcPool==NULL) return NULL;

	test	rcx, rcx
	jne	SHORT $LN15@ZSTDMT_res
	mov	QWORD PTR [rbx+24], rcx
$LN573@ZSTDMT_res:

; 1085 :     if (mtctx->seqPool == NULL) return ERROR(memory_allocation);

	mov	rax, -64				; ffffffffffffffc0H
$LN1@ZSTDMT_res:

; 1088 : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN15@ZSTDMT_res:

; 386  :     if (nbWorkers <= srcPool->totalCCtx) return srcPool;   /* good enough */

	cmp	edi, DWORD PTR [rcx+40]
	jg	SHORT $LN16@ZSTDMT_res
	mov	QWORD PTR [rbx+24], rcx
	jmp	SHORT $LN9@ZSTDMT_res
$LN16@ZSTDMT_res:

; 387  :     /* need a larger cctx pool */
; 388  :     {   ZSTD_customMem const cMem = srcPool->cMem;

	movups	xmm0, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR cMem$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rcx+64]
	movsd	QWORD PTR cMem$2$[rsp], xmm0

; 389  :         ZSTDMT_freeCCtxPool(srcPool);

	call	ZSTDMT_freeCCtxPool

; 390  :         return ZSTDMT_createCCtxPool(nbWorkers, cMem);

	movups	xmm0, XMMWORD PTR cMem$1$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	ecx, edi
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movsd	xmm0, QWORD PTR cMem$2$[rsp]
	movsd	QWORD PTR $T2[rsp+16], xmm0
	call	ZSTDMT_createCCtxPool

; 1082 :     mtctx->cctxPool = ZSTDMT_expandCCtxPool(mtctx->cctxPool, nbWorkers);

	mov	QWORD PTR [rbx+24], rax

; 1083 :     if (mtctx->cctxPool == NULL) return ERROR(memory_allocation);

	test	rax, rax
	je	SHORT $LN573@ZSTDMT_res
$LN9@ZSTDMT_res:

; 335  :     return ZSTDMT_expandBufferPool(pool, nbWorkers);

	mov	rcx, QWORD PTR [rbx+32]
	mov	edx, edi
	call	ZSTDMT_expandBufferPool

; 1084 :     mtctx->seqPool = ZSTDMT_expandSeqPool(mtctx->seqPool, nbWorkers);

	mov	QWORD PTR [rbx+32], rax

; 1085 :     if (mtctx->seqPool == NULL) return ERROR(memory_allocation);

	test	rax, rax
	je	SHORT $LN573@ZSTDMT_res
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 330  :         bounds.lowerBound = 0;

	xor	ecx, ecx

; 331  : #ifdef ZSTD_MULTITHREAD
; 332  :         bounds.upperBound = ZSTDMT_NBWORKERS_MAX;

	mov	DWORD PTR $T1[rsp+12], 200		; 000000c8H

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	test	edi, edi

; 330  :         bounds.lowerBound = 0;

	mov	DWORD PTR $T1[rsp+8], ecx

; 435  :     if (*value > bounds.upperBound) *value = bounds.upperBound;

	mov	rax, QWORD PTR $T1[rsp+8]
	cmovns	ecx, edi
	shr	rax, 32					; 00000020H

; 632  :         CCtxParams->nbWorkers = value;

	cmp	ecx, eax
	cmovle	eax, ecx
	mov	DWORD PTR [rbx+116], eax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1087 :     return 0;

	xor	eax, eax

; 1088 : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ZSTDMT_resize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
params$ = 8
ZSTDMT_computeTargetJobLog PROC

; 1184 :     unsigned jobLog;
; 1185 :     if (params->ldmParams.enableLdm) {

	cmp	DWORD PTR [rcx+96], 0
	je	SHORT $LN2@ZSTDMT_com

; 1186 :         /* In Long Range Mode, the windowLog is typically oversized.
; 1187 :          * In which case, it's preferable to determine the jobSize
; 1188 :          * based on chainLog instead. */
; 1189 :         jobLog = MAX(21, params->cParams.chainLog + 4);

	mov	eax, DWORD PTR [rcx+8]
	add	eax, 4
	cmp	eax, 21
	jae	SHORT $LN8@ZSTDMT_com
	mov	eax, 21

; 1194 : }

	ret	0
$LN2@ZSTDMT_com:

; 1190 :     } else {
; 1191 :         jobLog = MAX(20, params->cParams.windowLog + 2);

	mov	eax, DWORD PTR [rcx+4]
	add	eax, 2
	cmp	eax, 20
	jae	SHORT $LN8@ZSTDMT_com
	mov	eax, 20

; 1194 : }

	ret	0
$LN8@ZSTDMT_com:

; 1192 :     }
; 1193 :     return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);

	cmp	eax, 30
	jb	SHORT $LN10@ZSTDMT_com
	mov	eax, 30
$LN10@ZSTDMT_com:

; 1194 : }

	ret	0
ZSTDMT_computeTargetJobLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
strat$ = 8
ZSTDMT_overlapLog_default PROC

; 1198 :     switch(strat)

	cmp	ecx, 5
	jl	SHORT $LN7@ZSTDMT_ove
	cmp	ecx, 6
	jle	SHORT $LN6@ZSTDMT_ove
	cmp	ecx, 8
	jle	SHORT $LN5@ZSTDMT_ove
	cmp	ecx, 9
	jne	SHORT $LN7@ZSTDMT_ove

; 1199 :     {
; 1200 :         case ZSTD_btultra2:
; 1201 :             return 9;

	mov	eax, ecx

; 1215 : }

	ret	0
$LN5@ZSTDMT_ove:

; 1202 :         case ZSTD_btultra:
; 1203 :         case ZSTD_btopt:
; 1204 :             return 8;

	mov	eax, 8

; 1215 : }

	ret	0
$LN6@ZSTDMT_ove:

; 1205 :         case ZSTD_btlazy2:
; 1206 :         case ZSTD_lazy2:
; 1207 :             return 7;

	mov	eax, 7

; 1215 : }

	ret	0
$LN7@ZSTDMT_ove:

; 1208 :         case ZSTD_lazy:
; 1209 :         case ZSTD_greedy:
; 1210 :         case ZSTD_dfast:
; 1211 :         case ZSTD_fast:
; 1212 :         default:;
; 1213 :     }
; 1214 :     return 6;

	mov	eax, 6

; 1215 : }

	ret	0
ZSTDMT_overlapLog_default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
ovlog$ = 8
strat$ = 16
ZSTDMT_overlapLog PROC

; 1219 :     assert(0 <= ovlog && ovlog <= 9);
; 1220 :     if (ovlog == 0) return ZSTDMT_overlapLog_default(strat);

	test	ecx, ecx
	jne	SHORT $LN2@ZSTDMT_ove

; 1198 :     switch(strat)

	cmp	edx, 5
	jl	SHORT $LN10@ZSTDMT_ove
	cmp	edx, 6
	jle	SHORT $LN9@ZSTDMT_ove
	cmp	edx, 8
	jle	SHORT $LN8@ZSTDMT_ove
	cmp	edx, 9
	jne	SHORT $LN10@ZSTDMT_ove

; 1199 :     {
; 1200 :         case ZSTD_btultra2:
; 1201 :             return 9;

	mov	eax, edx

; 1222 : }

	ret	0
$LN8@ZSTDMT_ove:

; 1204 :             return 8;

	mov	eax, 8

; 1222 : }

	ret	0
$LN9@ZSTDMT_ove:

; 1207 :             return 7;

	mov	eax, 7

; 1222 : }

	ret	0
$LN10@ZSTDMT_ove:

; 1214 :     return 6;

	mov	eax, 6

; 1222 : }

	ret	0
$LN2@ZSTDMT_ove:

; 1221 :     return ovlog;

	mov	eax, ecx

; 1222 : }

	ret	0
ZSTDMT_overlapLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
params$ = 8
ZSTDMT_computeOverlapSize PROC

; 1226 :     int const overlapRLog = 9 - ZSTDMT_overlapLog(params->overlapLog, params->cParams.strategy);

	mov	eax, DWORD PTR [rcx+88]
	mov	rdx, rcx

; 1220 :     if (ovlog == 0) return ZSTDMT_overlapLog_default(strat);

	mov	r8d, 9
	test	eax, eax
	jne	SHORT $LN10@ZSTDMT_com

; 1198 :     switch(strat)

	mov	eax, DWORD PTR [rcx+28]
	cmp	eax, 5
	jl	SHORT $LN19@ZSTDMT_com
	cmp	eax, 6
	jle	SHORT $LN18@ZSTDMT_com
	cmp	eax, 8
	jle	SHORT $LN17@ZSTDMT_com
	cmp	eax, r8d
	jne	SHORT $LN19@ZSTDMT_com

; 1199 :     {
; 1200 :         case ZSTD_btultra2:
; 1201 :             return 9;

	mov	eax, r8d
	jmp	SHORT $LN10@ZSTDMT_com
$LN17@ZSTDMT_com:

; 1202 :         case ZSTD_btultra:
; 1203 :         case ZSTD_btopt:
; 1204 :             return 8;

	mov	eax, 8
	jmp	SHORT $LN10@ZSTDMT_com
$LN18@ZSTDMT_com:

; 1205 :         case ZSTD_btlazy2:
; 1206 :         case ZSTD_lazy2:
; 1207 :             return 7;

	mov	eax, 7
	jmp	SHORT $LN10@ZSTDMT_com
$LN19@ZSTDMT_com:

; 1208 :         case ZSTD_lazy:
; 1209 :         case ZSTD_greedy:
; 1210 :         case ZSTD_dfast:
; 1211 :         case ZSTD_fast:
; 1212 :         default:;
; 1213 :     }
; 1214 :     return 6;

	mov	eax, 6
$LN10@ZSTDMT_com:

; 1226 :     int const overlapRLog = 9 - ZSTDMT_overlapLog(params->overlapLog, params->cParams.strategy);

	sub	r8d, eax

; 1227 :     int ovLog = (overlapRLog >= 8) ? 0 : (params->cParams.windowLog - overlapRLog);

	xor	r11d, r11d
	cmp	r8d, 8
	jl	SHORT $LN4@ZSTDMT_com
	mov	ecx, r11d
	jmp	SHORT $LN5@ZSTDMT_com
$LN4@ZSTDMT_com:
	mov	ecx, DWORD PTR [rcx+4]
	sub	ecx, r8d
$LN5@ZSTDMT_com:

; 1228 :     assert(0 <= overlapRLog && overlapRLog <= 8);
; 1229 :     if (params->ldmParams.enableLdm) {

	cmp	DWORD PTR [rdx+96], r11d
	je	SHORT $LN2@ZSTDMT_com

; 1189 :         jobLog = MAX(21, params->cParams.chainLog + 4);

	mov	r10d, DWORD PTR [rdx+8]
	mov	r9d, 21
	add	r10d, 4
	cmp	r10d, r9d
	jae	SHORT $LN25@ZSTDMT_com
	mov	eax, r9d
	jmp	SHORT $LN30@ZSTDMT_com
$LN25@ZSTDMT_com:
	mov	eax, r10d

; 1190 :     } else {
; 1191 :         jobLog = MAX(20, params->cParams.windowLog + 2);
; 1192 :     }
; 1193 :     return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);

	cmp	r10d, 30
	jb	SHORT $LN30@ZSTDMT_com
	mov	eax, 30
$LN30@ZSTDMT_com:

; 1230 :         /* In Long Range Mode, the windowLog is typically oversized.
; 1231 :          * In which case, it's preferable to determine the jobSize
; 1232 :          * based on chainLog instead.
; 1233 :          * Then, ovLog becomes a fraction of the jobSize, rather than windowSize */
; 1234 :         ovLog = MIN(params->cParams.windowLog, ZSTDMT_computeTargetJobLog(params) - 2)

	mov	ecx, DWORD PTR [rdx+4]
	add	eax, -2					; fffffffeH
	cmp	ecx, eax
	jb	SHORT $LN7@ZSTDMT_com

; 1189 :         jobLog = MAX(21, params->cParams.chainLog + 4);

	cmp	r10d, r9d
	jb	SHORT $LN40@ZSTDMT_com
	mov	r9d, r10d

; 1190 :     } else {
; 1191 :         jobLog = MAX(20, params->cParams.windowLog + 2);
; 1192 :     }
; 1193 :     return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);

	cmp	r10d, 30
	jb	SHORT $LN40@ZSTDMT_com
	mov	r9d, 30
$LN40@ZSTDMT_com:

; 1230 :         /* In Long Range Mode, the windowLog is typically oversized.
; 1231 :          * In which case, it's preferable to determine the jobSize
; 1232 :          * based on chainLog instead.
; 1233 :          * Then, ovLog becomes a fraction of the jobSize, rather than windowSize */
; 1234 :         ovLog = MIN(params->cParams.windowLog, ZSTDMT_computeTargetJobLog(params) - 2)

	lea	ecx, DWORD PTR [r9-2]
$LN7@ZSTDMT_com:
	sub	ecx, r8d
$LN2@ZSTDMT_com:

; 1235 :                 - overlapRLog;
; 1236 :     }
; 1237 :     assert(0 <= ovLog && ovLog <= ZSTD_WINDOWLOG_MAX);
; 1238 :     DEBUGLOG(4, "overlapLog : %i", params->overlapLog);
; 1239 :     DEBUGLOG(4, "overlap size : %i", 1 << ovLog);
; 1240 :     return (ovLog==0) ? 0 : (size_t)1 << ovLog;

	mov	edx, 1
	shl	rdx, cl
	test	ecx, ecx
	cmovne	r11, rdx
	mov	rax, r11

; 1241 : }

	ret	0
ZSTDMT_computeOverlapSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
params$ = 8
srcSize$ = 16
nbWorkers$ = 24
ZSTDMT_computeNbJobs PROC

; 1185 :     if (params->ldmParams.enableLdm) {

	cmp	DWORD PTR [rcx+96], 0

; 1245 : {

	mov	r11, rdx
	mov	r10d, r8d

; 1185 :     if (params->ldmParams.enableLdm) {

	je	SHORT $LN4@ZSTDMT_com

; 1186 :         /* In Long Range Mode, the windowLog is typically oversized.
; 1187 :          * In which case, it's preferable to determine the jobSize
; 1188 :          * based on chainLog instead. */
; 1189 :         jobLog = MAX(21, params->cParams.chainLog + 4);

	mov	ecx, DWORD PTR [rcx+8]
	add	ecx, 4
	cmp	ecx, 21
	jae	SHORT $LN10@ZSTDMT_com
	mov	ecx, 21
	jmp	SHORT $LN12@ZSTDMT_com
$LN4@ZSTDMT_com:

; 1190 :     } else {
; 1191 :         jobLog = MAX(20, params->cParams.windowLog + 2);

	mov	ecx, DWORD PTR [rcx+4]
	add	ecx, 2
	cmp	ecx, 20
	jae	SHORT $LN10@ZSTDMT_com
	mov	ecx, 20
	jmp	SHORT $LN12@ZSTDMT_com
$LN10@ZSTDMT_com:

; 1192 :     }
; 1193 :     return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);

	cmp	ecx, 30
	jb	SHORT $LN12@ZSTDMT_com
	mov	ecx, 30
$LN12@ZSTDMT_com:

; 1246 :     assert(nbWorkers>0);
; 1247 :     {   size_t const jobSizeTarget = (size_t)1 << ZSTDMT_computeTargetJobLog(params);
; 1248 :         size_t const jobMaxSize = jobSizeTarget << 2;
; 1249 :         size_t const passSizeMax = jobMaxSize * nbWorkers;
; 1250 :         unsigned const multiplier = (unsigned)(srcSize / passSizeMax) + 1;

	xor	edx, edx
	mov	r8d, 1
	shl	r8, cl
	mov	rax, r11
	lea	rcx, QWORD PTR [r8*4]
	imul	rcx, r10
	div	rcx

; 1251 :         unsigned const nbJobsLarge = multiplier * nbWorkers;
; 1252 :         unsigned const nbJobsMax = (unsigned)(srcSize / jobSizeTarget) + 1;

	xor	edx, edx
	lea	r9d, DWORD PTR [rax+1]
	mov	rax, r11
	div	r8
	mov	ecx, r9d
	inc	eax
	imul	ecx, r10d

; 1253 :         unsigned const nbJobsSmall = MIN(nbJobsMax, nbWorkers);

	cmp	eax, r10d
	cmovb	r10d, eax

; 1254 :         return (multiplier>1) ? nbJobsLarge : nbJobsSmall;

	cmp	r9d, 1
	cmova	r10d, ecx
	mov	eax, r10d

; 1255 : }   }

	ret	0
ZSTDMT_computeNbJobs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
jobID$1$ = 64
u$1$ = 64
$T1 = 72
tv1875 = 72
$T2 = 80
tv1876 = 80
nbJobs$1$ = 96
src$GSCopy$1$ = 104
frameStartPos$1$ = 112
dstBufferPos$1$ = 120
tv2228 = 128
dst$GSCopy$1$ = 136
params$GSCopy$1$ = 144
$T3 = 144
cdict$GSCopy$1$ = 160
dstCapacity$GSCopy$1$ = 168
overlapSize$1$ = 176
$T4 = 192
$T5 = 192
$T6 = 208
dstAsBuffer$7 = 352
$T8 = 368
$T9 = 368
$T10 = 400
$T11 = 400
$T12 = 544
mtctx$ = 640
dst$ = 648
dstCapacity$ = 656
src$ = 664
srcSize$ = 672
cdict$ = 680
params$ = 688
ZSTDMT_compress_advanced_internal PROC

; 1267 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-312]
	sub	rsp, 568				; 00000238H
	mov	r14, QWORD PTR params$[rbp-256]
	mov	rbx, rcx
	mov	rax, QWORD PTR cdict$[rbp-256]

; 1268 :     ZSTD_CCtx_params const jobParams = ZSTDMT_initJobCCtxParams(&params);
; 1269 :     size_t const overlapSize = ZSTDMT_computeOverlapSize(&params);

	mov	rcx, r14
	mov	QWORD PTR cdict$GSCopy$1$[rbp-256], rax
	mov	rdi, r8

; 1063 :     jobParams.forceWindow = 0;

	xor	eax, eax

; 1267 : {

	mov	QWORD PTR src$GSCopy$1$[rsp], r9

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm0, XMMWORD PTR [r14+48]

; 1267 : {

	mov	rsi, rdx

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm1, XMMWORD PTR [r14+64]
	movaps	xmm2, XMMWORD PTR [r14+32]
	movaps	xmm3, XMMWORD PTR [r14]
	movaps	xmm4, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR $T6[rbp-208], xmm0

; 1267 : {

	mov	QWORD PTR dstCapacity$GSCopy$1$[rbp-256], r8

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm0, XMMWORD PTR [r14+80]
	movups	XMMWORD PTR $T6[rbp-176], xmm0

; 1267 : {

	mov	QWORD PTR dst$GSCopy$1$[rbp-256], rdx

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm0, XMMWORD PTR [r14+112]
	movups	XMMWORD PTR $T6[rbp-192], xmm1

; 1267 : {

	mov	QWORD PTR params$GSCopy$1$[rbp-256], r14

; 1061 :     ZSTD_CCtx_params jobParams = *params;

	movaps	xmm1, XMMWORD PTR [r14+96]
	movups	XMMWORD PTR $T6[rbp-160], xmm1

; 1062 :     /* Clear parameters related to multithreading */
; 1063 :     jobParams.forceWindow = 0;

	mov	DWORD PTR $T6[rbp-208], eax
	movaps	xmm1, XMMWORD PTR [r14+128]
	movups	XMMWORD PTR $T6[rbp-144], xmm0

; 1064 :     jobParams.nbWorkers = 0;

	mov	DWORD PTR $T6[rbp-180], eax
	xorps	xmm0, xmm0

; 1065 :     jobParams.jobSize = 0;

	mov	QWORD PTR $T6[rbp-176], rax
	movups	XMMWORD PTR $T6[rbp-128], xmm1

; 1066 :     jobParams.overlapLog = 0;

	mov	DWORD PTR $T6[rbp-168], eax

; 1067 :     jobParams.rsyncable = 0;
; 1068 :     memset(&jobParams.ldmParams, 0, sizeof(ldmParams_t));
; 1069 :     memset(&jobParams.customMem, 0, sizeof(ZSTD_customMem));

	movups	XMMWORD PTR $T6[rbp-164], xmm0
	mov	DWORD PTR $T6[rbp-116], eax
	movups	XMMWORD PTR $T6[rbp-148], xmm0
	movups	XMMWORD PTR $T6[rbp-132], xmm0
	movups	XMMWORD PTR $T12[rbp-256], xmm3
	movups	XMMWORD PTR $T8[rbp-256], xmm4
	movups	XMMWORD PTR $T4[rbp-256], xmm2
	movups	XMMWORD PTR $T6[rbp-224], xmm2

; 1268 :     ZSTD_CCtx_params const jobParams = ZSTDMT_initJobCCtxParams(&params);
; 1269 :     size_t const overlapSize = ZSTDMT_computeOverlapSize(&params);

	call	ZSTDMT_computeOverlapSize

; 1185 :     if (params->ldmParams.enableLdm) {

	cmp	DWORD PTR [r14+96], 0

; 1270 :     unsigned const nbJobs = ZSTDMT_computeNbJobs(&params, srcSize, params.nbWorkers);

	mov	r10d, DWORD PTR [r14+76]
	mov	QWORD PTR overlapSize$1$[rbp-256], rax

; 1185 :     if (params->ldmParams.enableLdm) {

	je	SHORT $LN39@ZSTDMT_com

; 1186 :         /* In Long Range Mode, the windowLog is typically oversized.
; 1187 :          * In which case, it's preferable to determine the jobSize
; 1188 :          * based on chainLog instead. */
; 1189 :         jobLog = MAX(21, params->cParams.chainLog + 4);

	mov	ecx, DWORD PTR [r14+8]
	add	ecx, 4
	cmp	ecx, 21
	jae	SHORT $LN44@ZSTDMT_com
	mov	ecx, 21
	jmp	SHORT $LN47@ZSTDMT_com
$LN39@ZSTDMT_com:

; 1190 :     } else {
; 1191 :         jobLog = MAX(20, params->cParams.windowLog + 2);

	mov	ecx, DWORD PTR [r14+4]
	add	ecx, 2
	cmp	ecx, 20
	jae	SHORT $LN44@ZSTDMT_com
	mov	ecx, 20
	jmp	SHORT $LN47@ZSTDMT_com
$LN44@ZSTDMT_com:

; 1192 :     }
; 1193 :     return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);

	cmp	ecx, 30
	jb	SHORT $LN47@ZSTDMT_com
	mov	ecx, 30
$LN47@ZSTDMT_com:

; 1250 :         unsigned const multiplier = (unsigned)(srcSize / passSizeMax) + 1;

	mov	r12, QWORD PTR srcSize$[rbp-256]
	xor	edx, edx
	mov	r8d, 1
	mov	rax, r12
	shl	r8, cl

; 1251 :         unsigned const nbJobsLarge = multiplier * nbWorkers;
; 1252 :         unsigned const nbJobsMax = (unsigned)(srcSize / jobSizeTarget) + 1;
; 1253 :         unsigned const nbJobsSmall = MIN(nbJobsMax, nbWorkers);

	mov	r13d, r10d
	lea	rcx, QWORD PTR [r8*4]
	imul	rcx, r10
	div	rcx
	xor	edx, edx
	lea	r9d, DWORD PTR [rax+1]
	mov	rax, r12
	div	r8
	mov	ecx, r9d
	inc	eax
	imul	ecx, r10d
	cmp	eax, r10d
	cmovb	r13d, eax

; 1254 :         return (multiplier>1) ? nbJobsLarge : nbJobsSmall;

	cmp	r9d, 1
	cmova	r13d, ecx

; 1271 :     size_t const proposedJobSize = (srcSize + (nbJobs-1)) / nbJobs;

	xor	edx, edx
	mov	ecx, r13d

; 1254 :         return (multiplier>1) ? nbJobsLarge : nbJobsSmall;

	mov	DWORD PTR nbJobs$1$[rsp], r13d

; 1271 :     size_t const proposedJobSize = (srcSize + (nbJobs-1)) / nbJobs;

	lea	eax, DWORD PTR [r13-1]
	add	rax, r12
	div	rcx

; 1272 :     size_t const avgJobSize = (((proposedJobSize-1) & 0x1FFFF) < 0x7FFF) ? proposedJobSize + 0xFFFF : proposedJobSize;   /* avoid too small last block */

	lea	rcx, QWORD PTR [rax-1]

; 1273 :     const char* const srcStart = (const char*)src;

	lea	r15, QWORD PTR [rax+65535]
	and	ecx, 131071				; 0001ffffH
	cmp	rcx, 32767				; 00007fffH
	cmovae	r15, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	xor	r9d, r9d
	mov	eax, 131072				; 00020000H
	mov	ecx, r9d
	sub	rax, r12
	shr	rax, 11
	cmp	r12, 131072				; 00020000H
	cmovb	rcx, rax
	mov	rax, r12
	shr	rax, 8
	add	rax, rcx
	add	rax, r12
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1275 :     unsigned const compressWithinDst = (dstCapacity >= ZSTD_compressBound(srcSize)) ? nbJobs : (unsigned)(dstCapacity / ZSTD_compressBound(avgJobSize));  /* presumes avgJobSize >= 256 KB, which should be the case */

	cmp	rdi, rax
	jb	SHORT $LN30@ZSTDMT_com
	mov	rax, r15
	mov	DWORD PTR tv2228[rbp-256], r13d
	shr	rax, 8
	mov	QWORD PTR $T1[rsp], rax
	jmp	SHORT $LN31@ZSTDMT_com
$LN30@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	ecx, 131072				; 00020000H
	mov	rax, r9
	sub	rcx, r15
	mov	r8, r15
	shr	rcx, 11
	cmp	r15, 131072				; 00020000H
	cmovb	rax, rcx
	shr	r8, 8
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1275 :     unsigned const compressWithinDst = (dstCapacity >= ZSTD_compressBound(srcSize)) ? nbJobs : (unsigned)(dstCapacity / ZSTD_compressBound(avgJobSize));  /* presumes avgJobSize >= 256 KB, which should be the case */

	xor	edx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	QWORD PTR $T1[rsp], r8
	lea	rcx, QWORD PTR [rax+r8]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1275 :     unsigned const compressWithinDst = (dstCapacity >= ZSTD_compressBound(srcSize)) ? nbJobs : (unsigned)(dstCapacity / ZSTD_compressBound(avgJobSize));  /* presumes avgJobSize >= 256 KB, which should be the case */

	mov	rax, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	add	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1275 :     unsigned const compressWithinDst = (dstCapacity >= ZSTD_compressBound(srcSize)) ? nbJobs : (unsigned)(dstCapacity / ZSTD_compressBound(avgJobSize));  /* presumes avgJobSize >= 256 KB, which should be the case */

	div	rcx
	mov	QWORD PTR tv2228[rbp-256], rax
$LN31@ZSTDMT_com:

; 1276 :     size_t frameStartPos = 0, dstBufferPos = 0;
; 1277 :     assert(jobParams.nbWorkers == 0);
; 1278 :     assert(mtctx->cctxPool->totalCCtx == params.nbWorkers);
; 1279 : 
; 1280 :     params.jobSize = (U32)avgJobSize;
; 1281 :     DEBUGLOG(4, "ZSTDMT_compress_advanced_internal: nbJobs=%2u (rawSize=%u bytes; fixedSize=%u) ",
; 1282 :                 nbJobs, (U32)proposedJobSize, (U32)avgJobSize);
; 1283 : 
; 1284 :     if ((nbJobs==1) | (params.nbWorkers<=1)) {   /* fallback to single-thread mode : this is a blocking invocation anyway */

	cmp	r10d, 1
	mov	ecx, r15d
	mov	edx, r9d
	mov	QWORD PTR [r14+80], rcx
	setle	dl
	mov	QWORD PTR frameStartPos$1$[rsp], r9
	cmp	r13d, 1
	mov	QWORD PTR dstBufferPos$1$[rsp], r9
	mov	ecx, r9d
	sete	cl
	or	edx, ecx
	je	$LN13@ZSTDMT_com

; 1285 :         ZSTD_CCtx* const cctx = mtctx->cctxPool->cctx[0];

	mov	rax, QWORD PTR [rbx+24]

; 1286 :         DEBUGLOG(4, "ZSTDMT_compress_advanced_internal: fallback to single-thread mode");
; 1287 :         if (cdict) return ZSTD_compress_usingCDict_advanced(cctx, dst, dstCapacity, src, srcSize, cdict, jobParams.fParams);

	mov	rcx, QWORD PTR cdict$GSCopy$1$[rbp-256]
	mov	rbx, QWORD PTR [rax+72]
	test	rcx, rcx
	je	SHORT $LN68@ZSTDMT_com
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	movsd	xmm0, QWORD PTR $T6[rbp-224]
	lea	r8, QWORD PTR $T3[rbp-256]
	mov	eax, DWORD PTR $T6[rbp-216]
	mov	rdx, rcx
	mov	rcx, rbx
	movsd	QWORD PTR $T3[rbp-256], xmm0
	mov	r9, r12
	mov	DWORD PTR $T3[rbp-248], eax
	call	ZSTD_compressBegin_usingCDict_advanced
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3587 :     FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_advanced(cctx, cdict, fParams, srcSize), "");   /* will check if cdict != NULL */

	ja	$LN1@ZSTDMT_com
$LN280@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1378 : }

	mov	r9, QWORD PTR src$GSCopy$1$[rsp]
	mov	r8, rdi
	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], r12
	mov	rcx, rbx
	call	ZSTD_compressEnd
	jmp	$LN1@ZSTDMT_com
$LN68@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	movups	xmm0, XMMWORD PTR $T6[rbp-208]
	mov	r8, r12
	lea	rdx, QWORD PTR $T10[rbp-256]
	movups	xmm1, XMMWORD PTR $T6[rbp-192]
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], r9d
	movaps	XMMWORD PTR $T10[rbp-208], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-176]
	movaps	XMMWORD PTR $T10[rbp-192], xmm1
	movups	xmm1, XMMWORD PTR $T6[rbp-160]
	movaps	XMMWORD PTR $T10[rbp-176], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-144]
	movaps	XMMWORD PTR $T10[rbp-160], xmm1
	movups	xmm1, XMMWORD PTR $T6[rbp-128]
	movaps	XMMWORD PTR $T10[rbp-144], xmm0
	movaps	XMMWORD PTR $T10[rbp-128], xmm1
	movaps	XMMWORD PTR $T10[rbp-256], xmm3
	movaps	XMMWORD PTR $T10[rbp-240], xmm4
	movaps	XMMWORD PTR $T10[rbp-224], xmm2
	call	ZSTD_resetCCtx_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 3103 :     FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,

	ja	$LN1@ZSTDMT_com

; 3104 :                                      ZSTDcrp_makeClean, zbuff) , "");
; 3105 :     {   size_t const dictID = cdict ?
; 3106 :                 ZSTD_compress_insertDictionary(
; 3107 :                         cctx->blockState.prevCBlock, &cctx->blockState.matchState,
; 3108 :                         &cctx->ldmState, &cctx->workspace, &cctx->appliedParams, cdict->dictContent,
; 3109 :                         cdict->dictContentSize, dictContentType, dtlm,
; 3110 :                         cctx->entropyWorkspace)
; 3111 :               : ZSTD_compress_insertDictionary(
; 3112 :                         cctx->blockState.prevCBlock, &cctx->blockState.matchState,
; 3113 :                         &cctx->ldmState, &cctx->workspace, &cctx->appliedParams, dict, dictSize,
; 3114 :                         dictContentType, dtlm, cctx->entropyWorkspace);
; 3115 :         FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");
; 3116 :         assert(dictID <= UINT_MAX);
; 3117 :         cctx->dictID = (U32)dictID;

	mov	DWORD PTR [rbx+304], 0
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1288 :         return ZSTD_compress_advanced_internal(cctx, dst, dstCapacity, src, srcSize, NULL, 0, &jobParams);

	jmp	$LN280@ZSTDMT_com
$LN13@ZSTDMT_com:

; 1289 :     }
; 1290 : 
; 1291 :     assert(avgJobSize >= 256 KB);  /* condition for ZSTD_compressBound(A) + ZSTD_compressBound(B) <= ZSTD_compressBound(A+B), required to compress directly into Dst (no additional buffer) */
; 1292 :     ZSTDMT_setBufferSize(mtctx->bufPool, ZSTD_compressBound(avgJobSize) );

	mov	rdi, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	rsi, r9
	mov	eax, 131072				; 00020000H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	sub	rax, r15
	shr	rax, 11
	cmp	r15, 131072				; 00020000H
	cmovb	rsi, rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 157  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	call	QWORD PTR __imp_EnterCriticalSection
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	rax, QWORD PTR $T1[rsp]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	mov	rcx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	add	rax, rsi
	add	rax, r15
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 159  :     bufPool->bufferSize = bSize;

	mov	QWORD PTR [rdi+40], rax

; 160  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 1293 :     /* LDM doesn't even try to load the dictionary in single-ingestion mode */
; 1294 :     if (ZSTDMT_serialState_reset(&mtctx->serial, mtctx->seqPool, params, avgJobSize, NULL, 0, ZSTD_dct_auto))

	movaps	xmm0, XMMWORD PTR [r14]
	lea	r8, QWORD PTR $T11[rbp-256]
	movaps	xmm1, XMMWORD PTR [r14+16]
	xor	ecx, ecx
	mov	rdx, QWORD PTR [rbx+32]
	mov	r9, r15
	movaps	XMMWORD PTR $T11[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR [r14+32]
	movaps	XMMWORD PTR $T11[rbp-224], xmm0
	movaps	xmm0, XMMWORD PTR [r14+64]
	movaps	XMMWORD PTR $T11[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR [r14+48]
	mov	DWORD PTR [rsp+48], ecx
	movaps	XMMWORD PTR $T11[rbp-192], xmm0
	movaps	xmm0, XMMWORD PTR [r14+96]
	movaps	XMMWORD PTR $T11[rbp-208], xmm1
	movaps	xmm1, XMMWORD PTR [r14+80]
	mov	QWORD PTR [rsp+40], rcx
	movaps	XMMWORD PTR $T11[rbp-160], xmm0
	movaps	xmm0, XMMWORD PTR [r14+128]
	movaps	XMMWORD PTR $T11[rbp-176], xmm1
	movaps	xmm1, XMMWORD PTR [r14+112]
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR [rbx+272]
	movaps	XMMWORD PTR $T11[rbp-128], xmm0
	movaps	XMMWORD PTR $T11[rbp-144], xmm1
	call	ZSTDMT_serialState_reset
	test	eax, eax
	je	SHORT $LN4@ZSTDMT_com

; 1295 :         return ERROR(memory_allocation);

	mov	rax, -64				; ffffffffffffffc0H
	jmp	$LN1@ZSTDMT_com
$LN4@ZSTDMT_com:

; 1297 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbJobs) , "");  /* only expands if necessary */

	mov	edx, r13d
	mov	rcx, rbx
	call	ZSTDMT_expandJobsTable
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1297 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbJobs) , "");  /* only expands if necessary */

	ja	$LN1@ZSTDMT_com

; 1298 : 
; 1299 :     {   unsigned u;
; 1300 :         for (u=0; u<nbJobs; u++) {

	xor	r10d, r10d
	mov	DWORD PTR u$1$[rsp], r10d
	lea	rcx, QWORD PTR [r10-70]
	test	r13d, r13d
	je	$LN6@ZSTDMT_com
	xor	r8d, r8d
	mov	r14, r12
	mov	QWORD PTR tv1876[rsp], r8
	mov	r11d, r8d
	mov	QWORD PTR tv1875[rsp], r8
$LL7@ZSTDMT_com:

; 1301 :             size_t const jobSize = MIN(remainingSrcSize, avgJobSize);

	cmp	r14, r15
	mov	rsi, r15
	cmovb	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	cmp	rsi, 131072				; 00020000H
	jae	SHORT $LN252@ZSTDMT_com
	mov	eax, 131072				; 00020000H
	sub	rax, rsi
	shr	rax, 11
	jmp	SHORT $LN253@ZSTDMT_com
$LN252@ZSTDMT_com:
	xor	eax, eax
$LN253@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1307 :             mtctx->jobs[u].prefix.start = srcStart + frameStartPos - dictSize;

	mov	r9, QWORD PTR src$GSCopy$1$[rsp]
	xor	edx, edx

; 1315 :             mtctx->jobs[u].params = jobParams;

	movups	xmm0, XMMWORD PTR $T12[rbp-256]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	mov	rdi, rsi
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1307 :             mtctx->jobs[u].prefix.start = srcStart + frameStartPos - dictSize;

	mov	rcx, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	shr	rdi, 8
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1303 :             buffer_t const dstAsBuffer = { (char*)dst + dstBufferPos, dstBufferCapacity };

	mov	rax, QWORD PTR dst$GSCopy$1$[rbp-256]
	add	rax, QWORD PTR dstBufferPos$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 45   :     return ZSTD_COMPRESSBOUND(srcSize);

	add	rdi, rsi
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1303 :             buffer_t const dstAsBuffer = { (char*)dst + dstBufferPos, dstBufferCapacity };

	mov	QWORD PTR dstAsBuffer$7[rbp-256], rax

; 1304 :             buffer_t const dstBuffer = u < compressWithinDst ? dstAsBuffer : g_nullBuffer;
; 1305 :             size_t dictSize = u ? overlapSize : 0;

	test	r10d, r10d

; 1307 :             mtctx->jobs[u].prefix.start = srcStart + frameStartPos - dictSize;

	mov	rax, QWORD PTR [rbx+8]
	cmovne	rdx, QWORD PTR overlapSize$1$[rbp-256]
	sub	rcx, rdx
	mov	QWORD PTR dstAsBuffer$7[rbp-248], rdi
	add	rcx, r11
	mov	QWORD PTR [r8+rax+112], rcx

; 1308 :             mtctx->jobs[u].prefix.size = dictSize;
; 1309 :             mtctx->jobs[u].src.start = srcStart + frameStartPos;

	lea	rcx, QWORD PTR [r9+r11]
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r8+rax+120], rdx

; 1310 :             mtctx->jobs[u].src.size = jobSize; assert(jobSize > 0);  /* avoid job.src.size == 0 */
; 1311 :             mtctx->jobs[u].consumed = 0;

	xor	edx, edx
	mov	rax, QWORD PTR [rbx+8]

; 1312 :             mtctx->jobs[u].cSize = 0;
; 1313 :             mtctx->jobs[u].cdict = (u==0) ? cdict : NULL;

	test	r10d, r10d
	mov	QWORD PTR [r8+rax+128], rcx
	mov	ecx, edx
	mov	rax, QWORD PTR [rbx+8]
	cmove	rcx, QWORD PTR cdict$GSCopy$1$[rbp-256]
	cmp	r10d, DWORD PTR tv2228[rbp-256]
	mov	QWORD PTR [r8+rax+136], rsi
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r8+rax], rdx
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r8+rax+8], rdx
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r8+rax+304], rcx
	lea	rcx, QWORD PTR dstAsBuffer$7[rbp-256]

; 1314 :             mtctx->jobs[u].fullFrameSize = srcSize;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r8+rax+312], r12

; 1315 :             mtctx->jobs[u].params = jobParams;

	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [r8+rax+160], xmm0
	movups	xmm0, XMMWORD PTR $T8[rbp-256]
	movups	XMMWORD PTR [r8+rax+176], xmm0
	movups	xmm0, XMMWORD PTR $T4[rbp-256]
	movups	XMMWORD PTR [r8+rax+192], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-208]
	movups	XMMWORD PTR [r8+rax+208], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-192]
	movups	XMMWORD PTR [r8+rax+224], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-176]
	movups	XMMWORD PTR [r8+rax+240], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-160]
	movups	XMMWORD PTR [r8+rax+256], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-144]
	movups	XMMWORD PTR [r8+rax+272], xmm0
	movups	xmm0, XMMWORD PTR $T6[rbp-128]
	movups	XMMWORD PTR [r8+rax+288], xmm0
	lea	rax, OFFSET FLAT:g_nullBuffer
	cmovae	rcx, rax

; 1316 :             /* do not calculate checksum within sections, but write it in header for first section */
; 1317 :             mtctx->jobs[u].dstBuff = dstBuffer;

	mov	rax, QWORD PTR [rbx+8]

; 1318 :             mtctx->jobs[u].cctxPool = mtctx->cctxPool;
; 1319 :             mtctx->jobs[u].bufPool = mtctx->bufPool;
; 1320 :             mtctx->jobs[u].seqPool = mtctx->seqPool;
; 1321 :             mtctx->jobs[u].serial = &mtctx->serial;
; 1322 :             mtctx->jobs[u].jobID = u;
; 1323 :             mtctx->jobs[u].firstJob = (u==0);

	test	r10d, r10d
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8+rax+96], xmm0
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [r8+rcx+64], rax
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [r8+rcx+72], rax
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [r8+rcx+80], rax
	lea	rcx, QWORD PTR [rbx+272]
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r8+rax+88], rcx
	mov	ecx, edx
	mov	rax, QWORD PTR [rbx+8]
	sete	cl
	mov	DWORD PTR [r8+rax+144], r10d
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [r8+rax+148], ecx

; 1324 :             mtctx->jobs[u].lastJob = (u==nbJobs-1);

	mov	ecx, edx
	lea	eax, DWORD PTR [r13-1]
	cmp	r10d, eax

; 1325 : 
; 1326 :             DEBUGLOG(5, "ZSTDMT_compress_advanced_internal: posting job %u  (%u bytes)", u, (U32)jobSize);
; 1327 :             DEBUG_PRINTHEX(6, mtctx->jobs[u].prefix.start, 12);
; 1328 :             POOL_add(mtctx->factory, ZSTDMT_compressionJob, &mtctx->jobs[u]);

	lea	rdx, OFFSET FLAT:ZSTDMT_compressionJob
	mov	rax, QWORD PTR [rbx+8]
	sete	cl
	mov	DWORD PTR [r8+rax+152], ecx
	mov	r8, QWORD PTR tv1875[rsp]
	add	r8, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	POOL_add

; 1329 : 
; 1330 :             frameStartPos += jobSize;

	mov	r11, QWORD PTR frameStartPos$1$[rsp]

; 1331 :             dstBufferPos += dstBufferCapacity;
; 1332 :             remainingSrcSize -= jobSize;

	sub	r14, rsi
	mov	r10d, DWORD PTR u$1$[rsp]
	add	r11, rsi
	mov	r8, QWORD PTR tv1876[rsp]
	inc	r10d
	add	QWORD PTR dstBufferPos$1$[rsp], rdi
	add	r8, 336					; 00000150H
	add	QWORD PTR tv1875[rsp], 336		; 00000150H
	mov	QWORD PTR frameStartPos$1$[rsp], r11
	mov	DWORD PTR u$1$[rsp], r10d
	mov	QWORD PTR tv1876[rsp], r8
	cmp	r10d, r13d
	jb	$LL7@ZSTDMT_com

; 1353 :                         memmove((char*)dst + dstPos, mtctx->jobs[jobID].dstBuff.start, cSize);  /* may overlap when job compressed within dst */

	xor	edi, edi
	xor	r15d, r15d
	xor	r14d, r14d
	xor	r13d, r13d
	xor	esi, esi
	mov	DWORD PTR jobID$1$[rsp], esi
	npad	10
$LL10@ZSTDMT_com:

; 1339 :             DEBUGLOG(5, "waiting for job %u ", jobID);
; 1340 :             ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[jobID].job_mutex);

	mov	rcx, QWORD PTR [rbx+8]
	add	rcx, 16
	add	rcx, r15
	call	QWORD PTR __imp_EnterCriticalSection

; 1341 :             while (mtctx->jobs[jobID].consumed < mtctx->jobs[jobID].src.size) {

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx+rdi+136]
	cmp	QWORD PTR [rcx+rdi], rax
	jae	SHORT $LN12@ZSTDMT_com
	npad	13
$LL11@ZSTDMT_com:

; 1342 :                 DEBUGLOG(5, "waiting for jobCompleted signal from job %u", jobID);
; 1343 :                 ZSTD_pthread_cond_wait(&mtctx->jobs[jobID].job_cond, &mtctx->jobs[jobID].job_mutex);

	mov	rax, QWORD PTR [rbx+8]
	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR [rax+56]
	add	rdx, r15
	add	rcx, r15
	call	QWORD PTR __imp_SleepConditionVariableCS
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx+rdi+136]
	cmp	QWORD PTR [rcx+rdi], rax
	jb	SHORT $LL11@ZSTDMT_com
$LN12@ZSTDMT_com:

; 1344 :             }
; 1345 :             ZSTD_pthread_mutex_unlock(&mtctx->jobs[jobID].job_mutex);

	add	rcx, 16
	add	rcx, r15
	call	QWORD PTR __imp_LeaveCriticalSection

; 1346 :             DEBUGLOG(5, "ready to write job %u ", jobID);
; 1347 : 
; 1348 :             {   size_t const cSize = mtctx->jobs[jobID].cSize;

	mov	rcx, QWORD PTR [rbx+8]
	mov	r12, QWORD PTR [rcx+rdi+8]
	lea	rdx, QWORD PTR [rcx+rdi]

; 1349 :                 if (ZSTD_isError(cSize)) error = cSize;
; 1350 :                 if ((!error) && (dstPos + cSize > dstCapacity)) error = ERROR(dstSize_tooSmall);

	cmp	r12, -120				; ffffffffffffff88H
	mov	rax, r12
	cmovbe	rax, r14
	mov	r14, rax
	test	rax, rax
	jne	SHORT $LN19@ZSTDMT_com
	lea	rax, QWORD PTR [r12+r13]
	cmp	rax, QWORD PTR dstCapacity$GSCopy$1$[rbp-256]
	mov	rax, -70				; ffffffffffffffbaH
	cmova	r14, rax
$LN19@ZSTDMT_com:

; 1351 :                 if (jobID) {   /* note : job 0 is written directly at dst, which is correct position */

	test	esi, esi
	je	$LN263@ZSTDMT_com

; 1352 :                     if (!error)

	test	r14, r14
	jne	SHORT $LN278@ZSTDMT_com

; 1353 :                         memmove((char*)dst + dstPos, mtctx->jobs[jobID].dstBuff.start, cSize);  /* may overlap when job compressed within dst */

	mov	rcx, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	r8, r12
	mov	rdx, QWORD PTR [rdx+96]
	add	rcx, r13
	call	memmove
	mov	rcx, QWORD PTR [rbx+8]
$LN278@ZSTDMT_com:

; 1354 :                     if (jobID >= compressWithinDst) {  /* job compressed into its own buffer, which must be released */

	cmp	esi, DWORD PTR tv2228[rbp-256]
	jb	$LN263@ZSTDMT_com

; 1355 :                         DEBUGLOG(5, "releasing buffer %u>=%u", jobID, compressWithinDst);
; 1356 :                         ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[jobID].dstBuff);

	movups	xmm0, XMMWORD PTR [rcx+rdi+96]
	mov	rsi, QWORD PTR [rbx+16]

; 252  :     if (buf.start == NULL) return;   /* compatible with release on NULL */

	movq	rax, xmm0

; 1355 :                         DEBUGLOG(5, "releasing buffer %u>=%u", jobID, compressWithinDst);
; 1356 :                         ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[jobID].dstBuff);

	movaps	XMMWORD PTR $T5[rbp-256], xmm0

; 252  :     if (buf.start == NULL) return;   /* compatible with release on NULL */

	mov	QWORD PTR $T2[rsp], rax
	test	rax, rax
	je	SHORT $LN263@ZSTDMT_com

; 253  :     ZSTD_pthread_mutex_lock(&bufPool->poolMutex);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 254  :     if (bufPool->nbBuffers < bufPool->totalBuffers) {

	mov	eax, DWORD PTR [rsi+52]
	mov	rcx, rsi
	cmp	eax, DWORD PTR [rsi+48]
	jae	SHORT $LN258@ZSTDMT_com

; 255  :         bufPool->bTable[bufPool->nbBuffers++] = buf;  /* stored for later use */

	movaps	xmm0, XMMWORD PTR $T5[rbp-256]
	add	rax, 5
	add	rax, rax
	movups	XMMWORD PTR [rsi+rax*8], xmm0
	inc	DWORD PTR [rsi+52]

; 256  :         DEBUGLOG(5, "ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u",
; 257  :                     (U32)buf.capacity, (U32)(bufPool->nbBuffers-1));
; 258  :         ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 259  :         return;

	jmp	SHORT $LN263@ZSTDMT_com
$LN258@ZSTDMT_com:

; 260  :     }
; 261  :     ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);

	call	QWORD PTR __imp_LeaveCriticalSection

; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movups	xmm1, XMMWORD PTR [rsi+56]
	movsd	xmm0, QWORD PTR [rsi+72]
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	psrldq	xmm1, 8
	movq	rax, xmm1
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 264  :     ZSTD_free(buf.start, bufPool->cMem);

	movsd	QWORD PTR $T9[rbp-240], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 78   :         if (customMem.customFree)

	test	rax, rax
	je	SHORT $LN262@ZSTDMT_com

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR $T9[rbp-240]
	call	rax
	jmp	SHORT $LN263@ZSTDMT_com
$LN262@ZSTDMT_com:

; 80   :         else
; 81   :             free(ptr);

	mov	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_free
$LN263@ZSTDMT_com:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1358 :                 mtctx->jobs[jobID].dstBuff = g_nullBuffer;

	mov	rax, QWORD PTR [rbx+8]

; 1359 :                 mtctx->jobs[jobID].cSize = 0;
; 1360 :                 dstPos += cSize ;

	add	r13, r12
	mov	r12d, DWORD PTR jobID$1$[rsp]
	add	r15, 336				; 00000150H
	movaps	xmm0, XMMWORD PTR g_nullBuffer
	inc	r12d
	mov	DWORD PTR jobID$1$[rsp], r12d
	mov	esi, r12d
	movups	XMMWORD PTR [rax+rdi+96], xmm0
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax+rdi+8], 0
	add	rdi, 336				; 00000150H
	cmp	r12d, DWORD PTR nbJobs$1$[rsp]
	jb	$LL10@ZSTDMT_com

; 1337 :         unsigned jobID;
; 1338 :         for (jobID=0; jobID<nbJobs; jobID++) {

	mov	rcx, -70				; ffffffffffffffbaH
	jmp	SHORT $LN9@ZSTDMT_com
$LN6@ZSTDMT_com:

; 1333 :     }   }
; 1334 : 
; 1335 :     /* collect result */
; 1336 :     {   size_t error = 0, dstPos = 0;

	xor	r14d, r14d
	xor	r13d, r13d
$LN9@ZSTDMT_com:

; 1361 :             }
; 1362 :         }  /* for (jobID=0; jobID<nbJobs; jobID++) */
; 1363 : 
; 1364 :         DEBUGLOG(4, "checksumFlag : %u ", params.fParams.checksumFlag);
; 1365 :         if (params.fParams.checksumFlag) {

	mov	rax, QWORD PTR params$GSCopy$1$[rbp-256]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN25@ZSTDMT_com

; 1367 :             if (dstPos + 4 > dstCapacity) {

	lea	rdi, QWORD PTR [r13+4]
	cmp	rdi, QWORD PTR dstCapacity$GSCopy$1$[rbp-256]
	jbe	SHORT $LN24@ZSTDMT_com

; 1368 :                 error = ERROR(dstSize_tooSmall);

	mov	r14, rcx

; 1369 :             } else {

	jmp	SHORT $LN25@ZSTDMT_com
$LN24@ZSTDMT_com:

; 1366 :             U32 const checksum = (U32)XXH64_digest(&mtctx->serial.xxhState);

	lea	rcx, QWORD PTR [rbx+528]
	call	XXH64_digest

; 1370 :                 DEBUGLOG(4, "writing checksum : %08X \n", checksum);
; 1371 :                 MEM_writeLE32((char*)dst + dstPos, checksum);

	mov	rcx, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rcx+r13], eax

; 1372 :                 dstPos += 4;

	mov	r13, rdi
$LN25@ZSTDMT_com:

; 1373 :         }   }
; 1374 : 
; 1375 :         if (!error) DEBUGLOG(4, "compressed size : %u  ", (U32)dstPos);
; 1376 :         return error ? error : dstPos;

	test	r14, r14
	cmovne	r13, r14
	mov	rax, r13
$LN1@ZSTDMT_com:

; 1378 : }

	add	rsp, 568				; 00000238H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTDMT_compress_advanced_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
job$ = 64
ZSTDMT_writeLastEmptyBlock PROC

; 1587 : {

	push	rbx
	sub	rsp, 48					; 00000030H

; 1588 :     assert(job->lastJob == 1);
; 1589 :     assert(job->src.size == 0);   /* last job is empty -> will be simplified into a last empty block */
; 1590 :     assert(job->firstJob == 0);   /* cannot be first job, as it also needs to create frame header */
; 1591 :     assert(job->dstBuff.start == NULL);   /* invoked from streaming variant only (otherwise, dstBuff might be user's output) */
; 1592 :     job->dstBuff = ZSTDMT_getBuffer(job->bufPool);

	mov	rdx, QWORD PTR [rcx+72]
	mov	rbx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	ZSTDMT_getBuffer
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rbx+96], xmm0

; 1593 :     if (job->dstBuff.start == NULL) {

	mov	rax, QWORD PTR [rbx+96]
	test	rax, rax
	jne	SHORT $LN2@ZSTDMT_wri

; 1602 : }

	mov	QWORD PTR [rbx+8], -64			; ffffffffffffffc0H
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN2@ZSTDMT_wri:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2709 :     RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall,

	cmp	QWORD PTR [rbx+104], 3
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1598 :     job->src = kNullRange;

	movups	xmm0, XMMWORD PTR kNullRange
	movups	XMMWORD PTR [rbx+128], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2709 :     RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall,

	jae	SHORT $LN5@ZSTDMT_wri
	mov	rax, -70				; ffffffffffffffbaH
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1602 : }

	mov	QWORD PTR [rbx+8], rax
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN5@ZSTDMT_wri:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	ecx, 1
	mov	WORD PTR [rax], cx

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [rax+2], 0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2713 :         return ZSTD_blockHeaderSize;

	mov	eax, 3
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1602 : }

	mov	QWORD PTR [rbx+8], rax
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
ZSTDMT_writeLastEmptyBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\compress\zstd_compress.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\pool.c
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
mtctx$ = 80
srcSize$ = 88
endOp$ = 96
ZSTDMT_createCompressionJob PROC

; 1605 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 1606 :     unsigned const jobID = mtctx->nextJobID & mtctx->jobIDMask;

	mov	r9d, DWORD PTR [rcx+732]

; 1607 :     int const endFrame = (endOp == ZSTD_e_end);

	xor	esi, esi
	mov	r10d, DWORD PTR [rcx+740]
	mov	r11, rdx

; 1608 : 
; 1609 :     if (mtctx->nextJobID > mtctx->doneJobID + mtctx->jobIDMask) {

	mov	edx, DWORD PTR [rcx+736]
	mov	edi, r9d
	and	edi, r10d
	mov	r14d, esi
	cmp	r8d, 2
	mov	ebp, r8d
	mov	rbx, rcx
	sete	r14b
	add	edx, r9d
	cmp	r10d, edx
	ja	$LN41@ZSTDMT_cre

; 1610 :         DEBUGLOG(5, "ZSTDMT_createCompressionJob: will not create new job : table is full");
; 1611 :         assert((mtctx->nextJobID & mtctx->jobIDMask) == (mtctx->doneJobID & mtctx->jobIDMask));
; 1612 :         return 0;
; 1613 :     }
; 1614 : 
; 1615 :     if (!mtctx->jobReady) {

	mov	QWORD PTR [rsp+80], r15
	lea	r15d, QWORD PTR [rsi+1]
	cmp	DWORD PTR [rcx+200], esi
	jne	$LN7@ZSTDMT_cre

; 1616 :         BYTE const* src = (BYTE const*)mtctx->inBuff.buffer.start;

	mov	r8, QWORD PTR [rcx+224]

; 1617 :         DEBUGLOG(5, "ZSTDMT_createCompressionJob: preparing job %u to compress %u bytes with %u preload ",
; 1618 :                     mtctx->nextJobID, (U32)srcSize, (U32)mtctx->inBuff.prefix.size);
; 1619 :         mtctx->jobs[jobID].src.start = src;

	mov	eax, edi
	imul	rdx, rax, 336				; 00000150H
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+rax+128], r8

; 1620 :         mtctx->jobs[jobID].src.size = srcSize;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+rax+136], r11

; 1621 :         assert(mtctx->inBuff.filled >= srcSize);
; 1622 :         mtctx->jobs[jobID].prefix = mtctx->inBuff.prefix;

	mov	rax, QWORD PTR [rcx+8]
	movups	xmm0, XMMWORD PTR [rcx+208]
	movups	XMMWORD PTR [rdx+rax+112], xmm0

; 1623 :         mtctx->jobs[jobID].consumed = 0;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+rax], rsi

; 1624 :         mtctx->jobs[jobID].cSize = 0;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+rax+8], rsi

; 1625 :         mtctx->jobs[jobID].params = mtctx->params;

	movups	xmm0, XMMWORD PTR [rcx+40]
	mov	rax, QWORD PTR [rcx+8]
	movups	XMMWORD PTR [rdx+rax+160], xmm0
	movups	xmm1, XMMWORD PTR [rcx+56]
	movups	XMMWORD PTR [rdx+rax+176], xmm1
	movups	xmm0, XMMWORD PTR [rcx+72]
	movups	XMMWORD PTR [rdx+rax+192], xmm0
	movups	xmm1, XMMWORD PTR [rcx+88]
	movups	XMMWORD PTR [rdx+rax+208], xmm1
	movups	xmm0, XMMWORD PTR [rcx+104]
	movups	XMMWORD PTR [rdx+rax+224], xmm0
	movups	xmm1, XMMWORD PTR [rcx+120]
	movups	XMMWORD PTR [rdx+rax+240], xmm1
	movups	xmm0, XMMWORD PTR [rcx+136]
	movups	XMMWORD PTR [rdx+rax+256], xmm0
	movups	xmm1, XMMWORD PTR [rcx+152]
	movups	XMMWORD PTR [rdx+rax+272], xmm1
	movups	xmm0, XMMWORD PTR [rcx+168]
	movups	XMMWORD PTR [rdx+rax+288], xmm0

; 1626 :         mtctx->jobs[jobID].cdict = mtctx->nextJobID==0 ? mtctx->cdict : NULL;

	cmp	DWORD PTR [rcx+740], esi
	jne	SHORT $LN11@ZSTDMT_cre
	mov	rcx, QWORD PTR [rcx+808]
	jmp	SHORT $LN12@ZSTDMT_cre
$LN11@ZSTDMT_cre:
	mov	rcx, rsi
$LN12@ZSTDMT_cre:
	mov	rax, QWORD PTR [rbx+8]

; 1627 :         mtctx->jobs[jobID].fullFrameSize = mtctx->frameContentSize;
; 1628 :         mtctx->jobs[jobID].dstBuff = g_nullBuffer;

	movaps	xmm0, XMMWORD PTR g_nullBuffer
	mov	QWORD PTR [rdx+rax+304], rcx
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+752]
	mov	QWORD PTR [rdx+rcx+312], rax
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rdx+rax+96], xmm0

; 1629 :         mtctx->jobs[jobID].cctxPool = mtctx->cctxPool;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rdx+rcx+64], rax

; 1630 :         mtctx->jobs[jobID].bufPool = mtctx->bufPool;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rdx+rcx+72], rax

; 1631 :         mtctx->jobs[jobID].seqPool = mtctx->seqPool;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdx+rcx+80], rax

; 1632 :         mtctx->jobs[jobID].serial = &mtctx->serial;

	lea	rcx, QWORD PTR [rbx+272]
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdx+rax+88], rcx

; 1633 :         mtctx->jobs[jobID].jobID = mtctx->nextJobID;

	mov	rcx, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rbx+740]
	mov	DWORD PTR [rdx+rcx+144], eax

; 1634 :         mtctx->jobs[jobID].firstJob = (mtctx->nextJobID==0);

	mov	ecx, esi
	cmp	DWORD PTR [rbx+740], ecx
	mov	rax, QWORD PTR [rbx+8]
	sete	cl
	mov	DWORD PTR [rdx+rax+148], ecx

; 1635 :         mtctx->jobs[jobID].lastJob = endFrame;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rdx+rax+152], r14d

; 1636 :         mtctx->jobs[jobID].frameChecksumNeeded = mtctx->params.fParams.checksumFlag && endFrame && (mtctx->nextJobID>0);

	cmp	DWORD PTR [rbx+76], esi
	je	SHORT $LN13@ZSTDMT_cre
	cmp	ebp, 2
	jne	SHORT $LN13@ZSTDMT_cre
	mov	ecx, r15d
	cmp	DWORD PTR [rbx+740], esi
	ja	SHORT $LN14@ZSTDMT_cre
$LN13@ZSTDMT_cre:
	mov	ecx, esi
$LN14@ZSTDMT_cre:
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rdx+rax+328], ecx

; 1637 :         mtctx->jobs[jobID].dstFlushed = 0;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdx+rax+320], rsi

; 1638 : 
; 1639 :         /* Update the round buffer pos and clear the input buffer to be reset */
; 1640 :         mtctx->roundBuff.pos += srcSize;

	add	QWORD PTR [rbx+264], r11

; 1641 :         mtctx->inBuff.buffer = g_nullBuffer;
; 1642 :         mtctx->inBuff.filled = 0;

	mov	QWORD PTR [rbx+240], rsi
	movups	XMMWORD PTR [rbx+224], xmm0

; 1643 :         /* Set the prefix */
; 1644 :         if (!endFrame) {

	cmp	ebp, 2
	je	SHORT $LN4@ZSTDMT_cre

; 1645 :             size_t const newPrefixSize = MIN(srcSize, mtctx->targetPrefixSize);

	mov	rax, QWORD PTR [rbx+192]
	cmp	r11, rax
	cmovb	rax, r11

; 1646 :             mtctx->inBuff.prefix.start = src + srcSize - newPrefixSize;

	sub	r8, rax

; 1647 :             mtctx->inBuff.prefix.size = newPrefixSize;

	mov	QWORD PTR [rbx+216], rax
	add	r8, r11
	mov	QWORD PTR [rbx+208], r8

; 1648 :         } else {   /* endFrame==1 => no need for another input buffer */

	jmp	SHORT $LN6@ZSTDMT_cre
$LN4@ZSTDMT_cre:

; 1649 :             mtctx->inBuff.prefix = kNullRange;

	movups	xmm0, XMMWORD PTR kNullRange

; 1650 :             mtctx->frameEnded = endFrame;

	mov	DWORD PTR [rbx+744], r14d
	movups	XMMWORD PTR [rbx+208], xmm0

; 1651 :             if (mtctx->nextJobID == 0) {

	cmp	DWORD PTR [rbx+740], esi
	jne	SHORT $LN6@ZSTDMT_cre

; 1652 :                 /* single job exception : checksum is already calculated directly within worker thread */
; 1653 :                 mtctx->params.fParams.checksumFlag = 0;

	mov	DWORD PTR [rbx+76], esi
$LN6@ZSTDMT_cre:

; 1654 :         }   }
; 1655 : 
; 1656 :         if ( (srcSize == 0)
; 1657 :           && (mtctx->nextJobID>0)/*single job must also write frame header*/ ) {

	test	r11, r11
	jne	$LN7@ZSTDMT_cre
	cmp	DWORD PTR [rbx+740], esi
	jbe	SHORT $LN7@ZSTDMT_cre

; 1658 :             DEBUGLOG(5, "ZSTDMT_createCompressionJob: creating a last empty block to end frame");
; 1659 :             assert(endOp == ZSTD_e_end);  /* only possible case : need to end the frame with an empty last block */
; 1660 :             ZSTDMT_writeLastEmptyBlock(mtctx->jobs + jobID);

	mov	rdi, QWORD PTR [rbx+8]

; 1592 :     job->dstBuff = ZSTDMT_getBuffer(job->bufPool);

	lea	rcx, QWORD PTR $T1[rsp]

; 1658 :             DEBUGLOG(5, "ZSTDMT_createCompressionJob: creating a last empty block to end frame");
; 1659 :             assert(endOp == ZSTD_e_end);  /* only possible case : need to end the frame with an empty last block */
; 1660 :             ZSTDMT_writeLastEmptyBlock(mtctx->jobs + jobID);

	add	rdi, rdx

; 1592 :     job->dstBuff = ZSTDMT_getBuffer(job->bufPool);

	mov	rdx, QWORD PTR [rdi+72]
	call	ZSTDMT_getBuffer
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi+96], xmm0

; 1593 :     if (job->dstBuff.start == NULL) {

	mov	rax, QWORD PTR [rdi+96]
	test	rax, rax
	jne	SHORT $LN18@ZSTDMT_cre

; 1594 :       job->cSize = ERROR(memory_allocation);

	mov	rax, -64				; ffffffffffffffc0H

; 1661 :             mtctx->nextJobID++;

	mov	QWORD PTR [rdi+8], rax
	inc	DWORD PTR [rbx+740]

; 1662 :             return 0;

	jmp	$LN40@ZSTDMT_cre
$LN18@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2709 :     RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall,

	cmp	QWORD PTR [rdi+104], 3
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1598 :     job->src = kNullRange;

	movups	xmm0, XMMWORD PTR kNullRange
	movups	XMMWORD PTR [rdi+128], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2709 :     RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall,

	jae	SHORT $LN21@ZSTDMT_cre
	mov	rax, -70				; ffffffffffffffbaH
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1661 :             mtctx->nextJobID++;

	mov	QWORD PTR [rdi+8], rax
	inc	DWORD PTR [rbx+740]

; 1662 :             return 0;

	jmp	SHORT $LN40@ZSTDMT_cre
$LN21@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\common\mem.h

; 346  :     MEM_writeLE16(memPtr, (U16)val);

	mov	WORD PTR [rax], r15w

; 347  :     ((BYTE*)memPtr)[2] = (BYTE)(val>>16);

	mov	BYTE PTR [rax+2], sil
; File E:\dev\pyzstd\lib\compress\zstd_compress.c

; 2713 :         return ZSTD_blockHeaderSize;

	mov	eax, 3
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1661 :             mtctx->nextJobID++;

	mov	QWORD PTR [rdi+8], rax
	inc	DWORD PTR [rbx+740]

; 1662 :             return 0;

	jmp	SHORT $LN40@ZSTDMT_cre
$LN7@ZSTDMT_cre:

; 1672 :     if (POOL_tryAdd(mtctx->factory, ZSTDMT_compressionJob, &mtctx->jobs[jobID])) {

	mov	eax, edi
	mov	rdi, QWORD PTR [rbx]
	imul	r14, rax, 336				; 00000150H
; File E:\dev\pyzstd\lib\common\pool.c

; 282  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rdi+96]
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1672 :     if (POOL_tryAdd(mtctx->factory, ZSTDMT_compressionJob, &mtctx->jobs[jobID])) {

	add	r14, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\common\pool.c

; 282  :     ZSTD_pthread_mutex_lock(&ctx->queueMutex);

	call	QWORD PTR __imp_EnterCriticalSection

; 245  :     if (ctx->queueSize > 1) {

	mov	rcx, QWORD PTR [rdi+72]
	cmp	rcx, r15
	jbe	SHORT $LN30@ZSTDMT_cre

; 246  :         return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);

	mov	rax, QWORD PTR [rdi+64]
	xor	edx, edx
	inc	rax
	div	rcx

; 283  :     if (isQueueFull(ctx)) {

	cmp	QWORD PTR [rdi+56], rdx
	jne	SHORT $LN27@ZSTDMT_cre
$LN38@ZSTDMT_cre:

; 284  :         ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rdi+96]
	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1677 :         mtctx->jobReady = 1;

	mov	esi, r15d
$LN9@ZSTDMT_cre:

; 1678 :     }
; 1679 :     return 0;

	mov	DWORD PTR [rbx+200], esi
$LN40@ZSTDMT_cre:
	mov	r15, QWORD PTR [rsp+80]
$LN41@ZSTDMT_cre:

; 1680 : }

	mov	rbx, QWORD PTR [rsp+88]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN30@ZSTDMT_cre:
; File E:\dev\pyzstd\lib\common\pool.c

; 248  :         return (ctx->numThreadsBusy == ctx->threadLimit) ||

	mov	rax, QWORD PTR [rdi+40]
	cmp	QWORD PTR [rdi+80], rax
	je	SHORT $LN38@ZSTDMT_cre
	cmp	DWORD PTR [rdi+88], esi
	je	SHORT $LN38@ZSTDMT_cre
$LN27@ZSTDMT_cre:

; 258  :     if (ctx->shutdown) return;

	cmp	DWORD PTR [rdi+152], esi
	jne	SHORT $LN35@ZSTDMT_cre

; 259  : 
; 260  :     ctx->queueEmpty = 0;
; 261  :     ctx->queue[ctx->queueTail] = job;

	mov	rcx, QWORD PTR [rdi+64]
	lea	rdx, OFFSET FLAT:ZSTDMT_compressionJob
	mov	rax, QWORD PTR [rdi+48]
	add	rcx, rcx
	mov	DWORD PTR [rdi+88], esi
	mov	QWORD PTR [rax+rcx*8], rdx

; 262  :     ctx->queueTail = (ctx->queueTail + 1) % ctx->queueSize;

	xor	edx, edx
	mov	QWORD PTR [rax+rcx*8+8], r14

; 263  :     ZSTD_pthread_cond_signal(&ctx->queuePopCond);

	lea	rcx, QWORD PTR [rdi+144]
	mov	rax, QWORD PTR [rdi+64]
	inc	rax
	div	QWORD PTR [rdi+72]
	mov	QWORD PTR [rdi+64], rdx
	call	QWORD PTR __imp_WakeConditionVariable
$LN35@ZSTDMT_cre:

; 288  :     ZSTD_pthread_mutex_unlock(&ctx->queueMutex);

	lea	rcx, QWORD PTR [rdi+96]
	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1673 :         mtctx->nextJobID++;

	inc	DWORD PTR [rbx+740]

; 1674 :         mtctx->jobReady = 0;
; 1675 :     } else {

	jmp	$LN9@ZSTDMT_cre
ZSTDMT_createCompressionJob ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
mtctx$ = 112
output$ = 120
blockToFlush$ = 128
end$ = 136
ZSTDMT_flushProduced PROC

; 1690 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 56					; 00000038H
	mov	rbx, rcx
	mov	r13d, r9d

; 1691 :     unsigned const wJobID = mtctx->doneJobID & mtctx->jobIDMask;

	mov	ecx, DWORD PTR [rcx+732]
	mov	edi, r8d
	mov	eax, DWORD PTR [rbx+736]
	and	rcx, rax

; 1692 :     DEBUGLOG(5, "ZSTDMT_flushProduced (blocking:%u , job %u <= %u)",
; 1693 :                 blockToFlush, mtctx->doneJobID, mtctx->nextJobID);
; 1694 :     assert(output->size >= output->pos);
; 1695 : 
; 1696 :     ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[wJobID].job_mutex);

	imul	rsi, rcx, 336				; 00000150H
	mov	rcx, QWORD PTR [rbx+8]
	add	rcx, 16
	add	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 1697 :     if (  blockToFlush
; 1698 :       && (mtctx->doneJobID < mtctx->nextJobID) ) {

	test	edi, edi
	je	SHORT $LN28@ZSTDMT_flu
	mov	eax, DWORD PTR [rbx+740]
	cmp	DWORD PTR [rbx+736], eax
	jae	SHORT $LN28@ZSTDMT_flu

; 1699 :         assert(mtctx->jobs[wJobID].dstFlushed <= mtctx->jobs[wJobID].cSize);
; 1700 :         while (mtctx->jobs[wJobID].dstFlushed == mtctx->jobs[wJobID].cSize) {  /* nothing to flush */

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rsi+rcx+8]
	cmp	QWORD PTR [rcx+rsi+320], rax
	jne	SHORT $LN28@ZSTDMT_flu
	npad	4
$LL2@ZSTDMT_flu:

; 1701 :             if (mtctx->jobs[wJobID].consumed == mtctx->jobs[wJobID].src.size) {

	mov	rax, QWORD PTR [rsi+rcx+136]
	cmp	QWORD PTR [rsi+rcx], rax
	je	SHORT $LN28@ZSTDMT_flu

; 1702 :                 DEBUGLOG(5, "job %u is completely consumed (%u == %u) => don't wait for cond, there will be none",
; 1703 :                             mtctx->doneJobID, (U32)mtctx->jobs[wJobID].consumed, (U32)mtctx->jobs[wJobID].src.size);
; 1704 :                 break;
; 1705 :             }
; 1706 :             DEBUGLOG(5, "waiting for something to flush from job %u (currently flushed: %u bytes)",
; 1707 :                         mtctx->doneJobID, (U32)mtctx->jobs[wJobID].dstFlushed);
; 1708 :             ZSTD_pthread_cond_wait(&mtctx->jobs[wJobID].job_cond, &mtctx->jobs[wJobID].job_mutex);  /* block when nothing to flush but some to come */

	lea	rdx, QWORD PTR [rsi+16]
	mov	r8d, -1					; ffffffffH
	add	rdx, rcx
	add	rcx, 56					; 00000038H
	add	rcx, rsi
	call	QWORD PTR __imp_SleepConditionVariableCS
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx+rsi+8]
	cmp	QWORD PTR [rcx+rsi+320], rax
	je	SHORT $LL2@ZSTDMT_flu
$LN28@ZSTDMT_flu:

; 1709 :     }   }
; 1710 : 
; 1711 :     /* try to flush something */
; 1712 :     {   size_t cSize = mtctx->jobs[wJobID].cSize;                  /* shared */

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rsi+rax+8]

; 1713 :         size_t const srcConsumed = mtctx->jobs[wJobID].consumed;   /* shared */
; 1714 :         size_t const srcSize = mtctx->jobs[wJobID].src.size;       /* read-only, could be done after mutex lock, but no-declaration-after-statement */
; 1715 :         ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);

	lea	rcx, QWORD PTR [rax+16]
	mov	r12, QWORD PTR [rsi+rax]
	add	rcx, rsi
	mov	r14, QWORD PTR [rsi+rax+136]
	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rdi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1716 :         if (ZSTD_isError(cSize)) {

	jbe	SHORT $LN6@ZSTDMT_flu

; 1717 :             DEBUGLOG(5, "ZSTDMT_flushProduced: job %u : compression error detected : %s",
; 1718 :                         mtctx->doneJobID, ZSTD_getErrorName(cSize));
; 1719 :             ZSTDMT_waitForAllJobsCompleted(mtctx);

	mov	rcx, rbx
	call	ZSTDMT_waitForAllJobsCompleted

; 1720 :             ZSTDMT_releaseAllJobResources(mtctx);

	mov	rcx, rbx
	call	ZSTDMT_releaseAllJobResources

; 1721 :             return cSize;

	mov	rax, rdi

; 1773 : }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@ZSTDMT_flu:
	mov	QWORD PTR [rsp+112], rbp

; 1722 :         }
; 1723 :         /* add frame checksum if necessary (can only happen once) */
; 1724 :         assert(srcConsumed <= srcSize);
; 1725 :         if ( (srcConsumed == srcSize)   /* job completed -> worker no longer active */
; 1726 :           && mtctx->jobs[wJobID].frameChecksumNeeded ) {

	xor	ebp, ebp
	mov	QWORD PTR [rsp+48], r15
	cmp	r12, r14
	jne	SHORT $LN7@ZSTDMT_flu
	mov	r15, QWORD PTR [rbx+8]
	cmp	DWORD PTR [r15+rsi+328], ebp
	je	SHORT $LN7@ZSTDMT_flu

; 1727 :             U32 const checksum = (U32)XXH64_digest(&mtctx->serial.xxhState);

	lea	rcx, QWORD PTR [rbx+528]
	call	XXH64_digest

; 1728 :             DEBUGLOG(4, "ZSTDMT_flushProduced: writing checksum : %08X \n", checksum);
; 1729 :             MEM_writeLE32((char*)mtctx->jobs[wJobID].dstBuff.start + mtctx->jobs[wJobID].cSize, checksum);

	mov	rdx, QWORD PTR [r15+rsi+96]

; 1730 :             cSize += 4;

	add	rdi, 4
	mov	rcx, QWORD PTR [r15+rsi+8]
	mov	DWORD PTR [rdx+rcx], eax

; 1731 :             mtctx->jobs[wJobID].cSize += 4;  /* can write this shared value, as worker is no longer active */

	mov	rax, QWORD PTR [rbx+8]
	add	QWORD PTR [rsi+rax+8], 4

; 1732 :             mtctx->jobs[wJobID].frameChecksumNeeded = 0;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rsi+rax+328], ebp
$LN7@ZSTDMT_flu:

; 1733 :         }
; 1734 : 
; 1735 :         if (cSize > 0) {   /* compression is ongoing or completed */

	test	rdi, rdi
	je	$LN10@ZSTDMT_flu

; 1736 :             size_t const toFlush = MIN(cSize - mtctx->jobs[wJobID].dstFlushed, output->size - output->pos);

	mov	r9, QWORD PTR output$[rsp]
	mov	r15, rdi
	mov	rcx, QWORD PTR [rbx+8]
	mov	r13, QWORD PTR [r9+16]
	mov	rax, QWORD PTR [r9+8]
	lea	rdx, QWORD PTR [rsi+rcx]
	mov	r8, QWORD PTR [rdx+320]
	sub	rax, r13
	sub	r15, r8

; 1737 :             DEBUGLOG(5, "ZSTDMT_flushProduced: Flushing %u bytes from job %u (completion:%u/%u, generated:%u)",
; 1738 :                         (U32)toFlush, mtctx->doneJobID, (U32)srcConsumed, (U32)srcSize, (U32)cSize);
; 1739 :             assert(mtctx->doneJobID < mtctx->nextJobID);
; 1740 :             assert(cSize >= mtctx->jobs[wJobID].dstFlushed);
; 1741 :             assert(mtctx->jobs[wJobID].dstBuff.start != NULL);
; 1742 :             if (toFlush > 0) {

	cmp	r15, rax
	cmovae	r15, rax
	test	r15, r15
	je	SHORT $LN9@ZSTDMT_flu

; 1743 :                 memcpy((char*)output->dst + output->pos,

	mov	rdx, QWORD PTR [rdx+96]
	mov	rcx, QWORD PTR [r9]
	add	rdx, r8
	mov	r8, r15
	add	rcx, r13
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR output$[rsp]
$LN9@ZSTDMT_flu:

; 1744 :                     (const char*)mtctx->jobs[wJobID].dstBuff.start + mtctx->jobs[wJobID].dstFlushed,
; 1745 :                     toFlush);
; 1746 :             }
; 1747 :             output->pos += toFlush;
; 1748 :             mtctx->jobs[wJobID].dstFlushed += toFlush;  /* can write : this value is only used by mtctx */

	add	QWORD PTR [rsi+rcx+320], r15
	lea	rax, QWORD PTR [r15+r13]
	mov	QWORD PTR [r9+16], rax

; 1749 : 
; 1750 :             if ( (srcConsumed == srcSize)    /* job is completed */
; 1751 :               && (mtctx->jobs[wJobID].dstFlushed == cSize) ) {   /* output buffer fully flushed => free this job position */

	cmp	r12, r14
	jne	SHORT $LN30@ZSTDMT_flu
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rsi+rax+320], rdi
	jne	SHORT $LN30@ZSTDMT_flu

; 1752 :                 DEBUGLOG(5, "Job %u completed (%u bytes), moving to next one",
; 1753 :                         mtctx->doneJobID, (U32)mtctx->jobs[wJobID].dstFlushed);
; 1754 :                 ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[wJobID].dstBuff);

	movups	xmm0, XMMWORD PTR [rsi+rax+96]
	mov	rcx, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	ZSTDMT_releaseBuffer

; 1755 :                 DEBUGLOG(5, "dstBuffer released");
; 1756 :                 mtctx->jobs[wJobID].dstBuff = g_nullBuffer;

	mov	rax, QWORD PTR [rbx+8]
	movaps	xmm0, XMMWORD PTR g_nullBuffer
	movups	XMMWORD PTR [rsi+rax+96], xmm0

; 1757 :                 mtctx->jobs[wJobID].cSize = 0;   /* ensure this job slot is considered "not started" in future check */

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rsi+rax+8], rbp

; 1758 :                 mtctx->consumed += srcSize;

	add	QWORD PTR [rbx+760], r14

; 1759 :                 mtctx->produced += cSize;

	add	QWORD PTR [rbx+768], rdi

; 1760 :                 mtctx->doneJobID++;

	inc	DWORD PTR [rbx+736]
$LN30@ZSTDMT_flu:

; 1761 :         }   }
; 1762 : 
; 1763 :         /* return value : how many bytes left in buffer ; fake it to 1 when unknown but >0 */
; 1764 :         if (cSize > mtctx->jobs[wJobID].dstFlushed) return (cSize - mtctx->jobs[wJobID].dstFlushed);

	mov	r13d, DWORD PTR end$[rsp]
$LN10@ZSTDMT_flu:
	mov	rax, QWORD PTR [rbx+8]
	mov	r15, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR [rsi+rax+320]
	cmp	rdi, rcx
	jbe	SHORT $LN11@ZSTDMT_flu
	sub	rdi, rcx
	mov	rax, rdi
	jmp	SHORT $LN31@ZSTDMT_flu
$LN11@ZSTDMT_flu:

; 1765 :         if (srcSize > srcConsumed) return 1;   /* current job not completely compressed */

	cmp	r14, r12
	ja	SHORT $LN27@ZSTDMT_flu

; 1766 :     }
; 1767 :     if (mtctx->doneJobID < mtctx->nextJobID) return 1;   /* some more jobs ongoing */

	mov	eax, DWORD PTR [rbx+740]
	cmp	DWORD PTR [rbx+736], eax
	jb	SHORT $LN27@ZSTDMT_flu

; 1768 :     if (mtctx->jobReady) return 1;      /* one job is ready to push, just not yet in the list */

	cmp	DWORD PTR [rbx+200], ebp
	jne	SHORT $LN27@ZSTDMT_flu

; 1769 :     if (mtctx->inBuff.filled > 0) return 1;   /* input is not empty, and still needs to be converted into a job */

	cmp	QWORD PTR [rbx+240], rbp
	ja	SHORT $LN27@ZSTDMT_flu

; 1770 :     mtctx->allJobsCompleted = mtctx->frameEnded;   /* all jobs are entirely flushed => if this one is last one, frame is completed */

	mov	ecx, DWORD PTR [rbx+744]
	mov	DWORD PTR [rbx+748], ecx

; 1771 :     if (end == ZSTD_e_end) return !mtctx->frameEnded;  /* for ZSTD_e_end, question becomes : is frame completed ? instead of : are internal buffers fully flushed ? */

	cmp	r13d, 2
	jne	SHORT $LN16@ZSTDMT_flu
	test	ecx, ecx
	sete	bpl
	mov	rax, rbp
	jmp	SHORT $LN31@ZSTDMT_flu
$LN16@ZSTDMT_flu:

; 1772 :     return 0;   /* internal buffers fully flushed */

	xor	eax, eax
	jmp	SHORT $LN31@ZSTDMT_flu
$LN27@ZSTDMT_flu:

; 1769 :     if (mtctx->inBuff.filled > 0) return 1;   /* input is not empty, and still needs to be converted into a job */

	mov	eax, 1
$LN31@ZSTDMT_flu:
	mov	rbp, QWORD PTR [rsp+112]

; 1773 : }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ZSTDMT_flushProduced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 64
mtctx$ = 72
ZSTDMT_getInputDataInUse PROC

; 1781 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1782 :     unsigned const firstJobID = mtctx->doneJobID;
; 1783 :     unsigned const lastJobID = mtctx->nextJobID;

	mov	r15d, DWORD PTR [rdx+740]
	mov	rbp, rdx

; 1784 :     unsigned jobID;
; 1785 : 
; 1786 :     for (jobID = firstJobID; jobID < lastJobID; ++jobID) {

	mov	ebx, DWORD PTR [rdx+736]
	mov	r12, rcx
	cmp	ebx, r15d
	jae	SHORT $LN3@ZSTDMT_get
	mov	rcx, QWORD PTR [rdx+8]
	npad	6
$LL4@ZSTDMT_get:

; 1787 :         unsigned const wJobID = jobID & mtctx->jobIDMask;

	mov	r14d, DWORD PTR [rbp+732]

; 1788 :         size_t consumed;
; 1789 : 
; 1790 :         ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[wJobID].job_mutex);

	add	rcx, 16
	mov	eax, ebx
	and	r14, rax
	imul	rsi, r14, 336				; 00000150H
	add	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 1791 :         consumed = mtctx->jobs[wJobID].consumed;

	mov	rax, QWORD PTR [rbp+8]
	imul	rcx, r14, 336				; 00000150H
	mov	rdi, QWORD PTR [rcx+rax]

; 1792 :         ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);

	add	rax, 16
	add	rcx, rax
	call	QWORD PTR __imp_LeaveCriticalSection

; 1793 : 
; 1794 :         if (consumed < mtctx->jobs[wJobID].src.size) {

	mov	rcx, QWORD PTR [rbp+8]
	cmp	rdi, QWORD PTR [rsi+rcx+136]
	jb	SHORT $LN9@ZSTDMT_get

; 1784 :     unsigned jobID;
; 1785 : 
; 1786 :     for (jobID = firstJobID; jobID < lastJobID; ++jobID) {

	inc	ebx
	cmp	ebx, r15d
	jb	SHORT $LL4@ZSTDMT_get
$LN3@ZSTDMT_get:

; 1803 :         }
; 1804 :     }
; 1805 :     return kNullRange;

	movups	xmm0, XMMWORD PTR kNullRange
	movups	XMMWORD PTR [r12], xmm0
$LN13@ZSTDMT_get:

; 1806 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, r12
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN9@ZSTDMT_get:

; 1795 :             range_t range = mtctx->jobs[wJobID].prefix;

	imul	rdx, r14, 336				; 00000150H
	movups	xmm1, XMMWORD PTR [rdx+rcx+112]

; 1796 :             if (range.size == 0) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	movq	rax, xmm0
	test	rax, rax
	jne	SHORT $LN6@ZSTDMT_get

; 1797 :                 /* Empty prefix */
; 1798 :                 range = mtctx->jobs[wJobID].src;

	movups	xmm1, XMMWORD PTR [rdx+rcx+128]
$LN6@ZSTDMT_get:

; 1799 :             }
; 1800 :             /* Job source in multiple segments not supported yet */
; 1801 :             assert(range.start <= mtctx->jobs[wJobID].src.start);
; 1802 :             return range;

	movups	XMMWORD PTR [r12], xmm1
	jmp	SHORT $LN13@ZSTDMT_get
ZSTDMT_getInputDataInUse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
buffer$ = 8
range$ = 16
ZSTDMT_isOverlapped PROC

; 1813 :     BYTE const* const bufferStart = (BYTE const*)buffer.start;
; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;
; 1815 :     BYTE const* const rangeStart = (BYTE const*)range.start;
; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;

	mov	rax, QWORD PTR [rdx+8]
	mov	r8, QWORD PTR [rcx]
	mov	r9, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rdx]
	add	r9, r8

; 1817 : 
; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	test	rax, rax
	lea	rdx, QWORD PTR [rax+rcx]
	cmove	rdx, rcx
	test	rcx, rcx
	je	SHORT $LN3@ZSTDMT_isO
	test	r8, r8
	je	SHORT $LN3@ZSTDMT_isO

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	r8, r9
	je	SHORT $LN3@ZSTDMT_isO
	cmp	rcx, rdx
	je	SHORT $LN3@ZSTDMT_isO

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	r8, rdx
	jae	SHORT $LN3@ZSTDMT_isO
	cmp	rcx, r9
	jae	SHORT $LN3@ZSTDMT_isO
	mov	eax, 1

; 1825 : }

	ret	0
$LN3@ZSTDMT_isO:
	xor	eax, eax
	ret	0
ZSTDMT_isOverlapped ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
buffer$ = 8
window$ = 16
ZSTDMT_doesOverlapWindow PROC

; 1828 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 1829 :     range_t extDict;
; 1830 :     range_t prefix;
; 1831 : 
; 1832 :     DEBUGLOG(5, "ZSTDMT_doesOverlapWindow");
; 1833 :     extDict.start = window.dictBase + window.lowLimit;
; 1834 :     extDict.size = window.dictLimit - window.lowLimit;

	mov	r9d, DWORD PTR [rdx+24]
	mov	r8d, DWORD PTR [rdx+28]
	mov	eax, r9d
	mov	r11, QWORD PTR [rdx+16]
	sub	eax, r8d

; 1837 :     prefix.size = window.nextSrc - (window.base + window.dictLimit);

	mov	rbx, QWORD PTR [rdx]
	add	r11, r8

; 1838 :     DEBUGLOG(5, "extDict [0x%zx, 0x%zx)",
; 1839 :                 (size_t)extDict.start,
; 1840 :                 (size_t)extDict.start + extDict.size);
; 1841 :     DEBUGLOG(5, "prefix  [0x%zx, 0x%zx)",
; 1842 :                 (size_t)prefix.start,
; 1843 :                 (size_t)prefix.start + prefix.size);
; 1844 : 
; 1845 :     return ZSTDMT_isOverlapped(buffer, extDict)

	movaps	xmm1, XMMWORD PTR [rcx]
	sub	rbx, r9
	mov	r8d, eax

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	movdqa	xmm0, xmm1

; 1835 : 
; 1836 :     prefix.start = window.base + window.dictLimit;

	mov	rax, QWORD PTR [rdx+8]

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	movq	rcx, xmm1

; 1837 :     prefix.size = window.nextSrc - (window.base + window.dictLimit);

	sub	rbx, rax

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	psrldq	xmm0, 8
	movq	rdx, xmm0
	add	rdx, rcx

; 1835 : 
; 1836 :     prefix.start = window.base + window.dictLimit;

	lea	r10, QWORD PTR [r9+rax]

; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	test	r8, r8
	lea	rax, QWORD PTR [r8+r11]
	cmove	rax, r11
	test	r11, r11
	je	SHORT $LN7@ZSTDMT_doe
	test	rcx, rcx
	je	SHORT $LN7@ZSTDMT_doe

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	rcx, rdx
	je	SHORT $LN7@ZSTDMT_doe
	cmp	r11, rax
	je	SHORT $LN7@ZSTDMT_doe

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	rcx, rax
	jae	SHORT $LN7@ZSTDMT_doe
	cmp	r11, rdx
	jb	SHORT $LN3@ZSTDMT_doe
$LN7@ZSTDMT_doe:

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	movdqa	xmm0, xmm1

; 1815 :     BYTE const* const rangeStart = (BYTE const*)range.start;
; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;
; 1817 : 
; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	lea	rax, QWORD PTR [rbx+r10]
	psrldq	xmm0, 8
	movq	rcx, xmm1
	movq	rdx, xmm0
	add	rdx, rcx
	test	rbx, rbx
	cmove	rax, r10
	test	r10, r10
	je	SHORT $LN17@ZSTDMT_doe
	test	rcx, rcx
	je	SHORT $LN17@ZSTDMT_doe

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	rcx, rdx
	je	SHORT $LN17@ZSTDMT_doe
	cmp	r10, rax
	je	SHORT $LN17@ZSTDMT_doe

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	rcx, rax
	jae	SHORT $LN17@ZSTDMT_doe
	cmp	r10, rdx
	jae	SHORT $LN17@ZSTDMT_doe
$LN3@ZSTDMT_doe:

; 1838 :     DEBUGLOG(5, "extDict [0x%zx, 0x%zx)",
; 1839 :                 (size_t)extDict.start,
; 1840 :                 (size_t)extDict.start + extDict.size);
; 1841 :     DEBUGLOG(5, "prefix  [0x%zx, 0x%zx)",
; 1842 :                 (size_t)prefix.start,
; 1843 :                 (size_t)prefix.start + prefix.size);
; 1844 : 
; 1845 :     return ZSTDMT_isOverlapped(buffer, extDict)

	mov	eax, 1

; 1846 :         || ZSTDMT_isOverlapped(buffer, prefix);
; 1847 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN17@ZSTDMT_doe:
	mov	rbx, QWORD PTR [rsp+8]
	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
ZSTDMT_doesOverlapWindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
mtctx$ = 48
buffer$ = 56
ZSTDMT_waitForLdmComplete PROC

; 1850 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1851 :     if (mtctx->params.ldmParams.enableLdm) {

	cmp	DWORD PTR [rcx+136], 0
	mov	rsi, rdx
	mov	rbx, rcx
	je	$LN4@ZSTDMT_wai

; 1852 :         ZSTD_pthread_mutex_t* mutex = &mtctx->serial.ldmWindowMutex;
; 1853 :         DEBUGLOG(5, "ZSTDMT_waitForLdmComplete");
; 1854 :         DEBUGLOG(5, "source  [0x%zx, 0x%zx)",
; 1855 :                     (size_t)buffer.start,
; 1856 :                     (size_t)buffer.start + buffer.capacity);
; 1857 :         ZSTD_PTHREAD_MUTEX_LOCK(mutex);

	add	rcx, 624				; 00000270H
	mov	QWORD PTR [rsp+48], rdi
	call	QWORD PTR __imp_EnterCriticalSection
	npad	1
$LL2@ZSTDMT_wai:

; 1858 :         while (ZSTDMT_doesOverlapWindow(buffer, mtctx->serial.ldmWindow)) {

	movups	xmm1, XMMWORD PTR [rbx+688]
	movups	xmm2, XMMWORD PTR [rbx+672]

; 1833 :     extDict.start = window.dictBase + window.lowLimit;

	movdqa	xmm0, xmm1
	movq	r9, xmm1

; 1838 :     DEBUGLOG(5, "extDict [0x%zx, 0x%zx)",
; 1839 :                 (size_t)extDict.start,
; 1840 :                 (size_t)extDict.start + extDict.size);
; 1841 :     DEBUGLOG(5, "prefix  [0x%zx, 0x%zx)",
; 1842 :                 (size_t)prefix.start,
; 1843 :                 (size_t)prefix.start + prefix.size);
; 1844 : 
; 1845 :     return ZSTDMT_isOverlapped(buffer, extDict)

	movaps	xmm1, XMMWORD PTR [rsi]
	movq	r11, xmm2
	psrldq	xmm0, 8
	movq	rdx, xmm0
	movdqa	xmm0, xmm2
	mov	r8d, edx
	psrldq	xmm0, 8
	mov	ecx, edx
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	sub	r11, rcx
	add	r9, rax
	sub	r8d, eax
	movq	rax, xmm0

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	movdqa	xmm0, xmm1

; 1837 :     prefix.size = window.nextSrc - (window.base + window.dictLimit);

	sub	r11, rax

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	psrldq	xmm0, 8
	movq	r10, xmm0

; 1836 :     prefix.start = window.base + window.dictLimit;

	lea	rdx, QWORD PTR [rcx+rax]

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	movq	rcx, xmm1
	add	r10, rcx

; 1815 :     BYTE const* const rangeStart = (BYTE const*)range.start;
; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;
; 1817 : 
; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	lea	rax, QWORD PTR [r8+r9]
	test	r8, r8
	cmove	rax, r9
	test	r9, r9
	je	SHORT $LN12@ZSTDMT_wai
	test	rcx, rcx
	je	SHORT $LN12@ZSTDMT_wai

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	rcx, r10
	je	SHORT $LN12@ZSTDMT_wai
	cmp	r9, rax
	je	SHORT $LN12@ZSTDMT_wai

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	rcx, rax
	jae	SHORT $LN12@ZSTDMT_wai
	cmp	r9, r10
	jb	SHORT $LN8@ZSTDMT_wai
$LN12@ZSTDMT_wai:

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;

	movdqa	xmm0, xmm1

; 1815 :     BYTE const* const rangeStart = (BYTE const*)range.start;
; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;
; 1817 : 
; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	lea	rax, QWORD PTR [r11+rdx]
	psrldq	xmm0, 8
	movq	rcx, xmm1
	movq	r8, xmm0
	add	r8, rcx
	test	r11, r11
	cmove	rax, rdx
	test	rdx, rdx
	je	SHORT $LN22@ZSTDMT_wai
	test	rcx, rcx
	je	SHORT $LN22@ZSTDMT_wai

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	rcx, r8
	je	SHORT $LN22@ZSTDMT_wai
	cmp	rdx, rax
	je	SHORT $LN22@ZSTDMT_wai

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	rcx, rax
	jae	SHORT $LN22@ZSTDMT_wai
	cmp	rdx, r8
	jae	SHORT $LN22@ZSTDMT_wai
$LN8@ZSTDMT_wai:

; 1859 :             DEBUGLOG(5, "Waiting for LDM to finish...");
; 1860 :             ZSTD_pthread_cond_wait(&mtctx->serial.ldmWindowCond, mutex);

	lea	rcx, QWORD PTR [rbx+664]
	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR [rbx+624]
	call	QWORD PTR __imp_SleepConditionVariableCS

; 1861 :         }

	jmp	$LL2@ZSTDMT_wai
$LN22@ZSTDMT_wai:

; 1862 :         DEBUGLOG(6, "Done waiting for LDM to finish");
; 1863 :         ZSTD_pthread_mutex_unlock(mutex);

	lea	rcx, QWORD PTR [rbx+624]
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rdi, QWORD PTR [rsp+48]
$LN4@ZSTDMT_wai:

; 1864 :     }
; 1865 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
ZSTDMT_waitForLdmComplete ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
mtctx$ = 80
ZSTDMT_tryGetInputRange PROC

; 1873 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 1783 :     unsigned const lastJobID = mtctx->nextJobID;

	mov	r15d, DWORD PTR [rcx+740]

; 1873 : {

	mov	rsi, rcx

; 1786 :     for (jobID = firstJobID; jobID < lastJobID; ++jobID) {

	mov	ebp, DWORD PTR [rcx+736]
	cmp	ebp, r15d
	jae	SHORT $LN8@ZSTDMT_try
	mov	rcx, QWORD PTR [rcx+8]
	npad	15
$LL9@ZSTDMT_try:

; 1787 :         unsigned const wJobID = jobID & mtctx->jobIDMask;

	mov	r14d, DWORD PTR [rsi+732]

; 1788 :         size_t consumed;
; 1789 : 
; 1790 :         ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[wJobID].job_mutex);

	add	rcx, 16
	mov	eax, ebp
	and	r14, rax
	imul	rdi, r14, 336				; 00000150H
	add	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 1791 :         consumed = mtctx->jobs[wJobID].consumed;

	mov	rax, QWORD PTR [rsi+8]
	imul	rcx, r14, 336				; 00000150H
	mov	rbx, QWORD PTR [rcx+rax]

; 1792 :         ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);

	add	rax, 16
	add	rcx, rax
	call	QWORD PTR __imp_LeaveCriticalSection

; 1793 : 
; 1794 :         if (consumed < mtctx->jobs[wJobID].src.size) {

	mov	rcx, QWORD PTR [rsi+8]
	cmp	rbx, QWORD PTR [rdi+rcx+136]
	jb	$LN34@ZSTDMT_try

; 1784 :     unsigned jobID;
; 1785 : 
; 1786 :     for (jobID = firstJobID; jobID < lastJobID; ++jobID) {

	inc	ebp
	cmp	ebp, r15d
	jb	SHORT $LL9@ZSTDMT_try
$LN8@ZSTDMT_try:

; 1803 :         }
; 1804 :     }
; 1805 :     return kNullRange;

	movups	xmm0, XMMWORD PTR kNullRange
	movups	XMMWORD PTR $T3[rsp], xmm0
$LN6@ZSTDMT_try:

; 1874 :     range_t const inUse = ZSTDMT_getInputDataInUse(mtctx);
; 1875 :     size_t const spaceLeft = mtctx->roundBuff.capacity - mtctx->roundBuff.pos;

	mov	r14, QWORD PTR [rsi+264]
	mov	rax, QWORD PTR [rsi+256]

; 1876 :     size_t const target = mtctx->targetSectionSize;

	mov	rbp, QWORD PTR [rsi+184]
	sub	rax, r14

; 1877 :     buffer_t buffer;
; 1878 : 
; 1879 :     DEBUGLOG(5, "ZSTDMT_tryGetInputRange");
; 1880 :     assert(mtctx->inBuff.buffer.start == NULL);
; 1881 :     assert(mtctx->roundBuff.capacity >= target);
; 1882 : 
; 1883 :     if (spaceLeft < target) {

	mov	r15, QWORD PTR $T3[rsp+8]
	mov	rbx, QWORD PTR $T3[rsp]
	cmp	rax, rbp
	jae	SHORT $LN2@ZSTDMT_try

; 1884 :         /* ZSTD_invalidateRepCodes() doesn't work for extDict variants.
; 1885 :          * Simply copy the prefix to the beginning in that case.
; 1886 :          */
; 1887 :         BYTE* const start = (BYTE*)mtctx->roundBuff.buffer;

	mov	rdi, QWORD PTR [rsi+248]

; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;

	lea	rax, QWORD PTR [r15+rbx]

; 1888 :         size_t const prefixSize = mtctx->inBuff.prefix.size;

	mov	r14, QWORD PTR [rsi+216]

; 1813 :     BYTE const* const bufferStart = (BYTE const*)buffer.start;

	lea	rcx, QWORD PTR [r14+rdi]

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;
; 1815 :     BYTE const* const rangeStart = (BYTE const*)range.start;
; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;

	test	r15, r15
	jne	SHORT $LN20@ZSTDMT_try
	mov	rax, rbx
$LN20@ZSTDMT_try:

; 1817 : 
; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	test	rbx, rbx
	je	SHORT $LN3@ZSTDMT_try
	test	rdi, rdi
	je	SHORT $LN3@ZSTDMT_try

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	rdi, rcx
	je	SHORT $LN3@ZSTDMT_try
	cmp	rbx, rax
	je	SHORT $LN3@ZSTDMT_try

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	rdi, rax
	jae	SHORT $LN3@ZSTDMT_try
	cmp	rbx, rcx
	jb	SHORT $LN39@ZSTDMT_try
$LN3@ZSTDMT_try:

; 1889 : 
; 1890 :         buffer.start = start;
; 1891 :         buffer.capacity = prefixSize;
; 1892 :         if (ZSTDMT_isOverlapped(buffer, inUse)) {
; 1893 :             DEBUGLOG(5, "Waiting for buffer...");
; 1894 :             return 0;
; 1895 :         }
; 1896 :         ZSTDMT_waitForLdmComplete(mtctx, buffer);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T2[rsp], rdi
	mov	rcx, rsi
	mov	QWORD PTR $T2[rsp+8], r14
	call	ZSTDMT_waitForLdmComplete

; 1897 :         memmove(start, mtctx->inBuff.prefix.start, prefixSize);

	mov	rdx, QWORD PTR [rsi+208]
	mov	r8, r14
	mov	rcx, rdi
	call	memmove

; 1898 :         mtctx->inBuff.prefix.start = start;

	mov	QWORD PTR [rsi+208], rdi

; 1899 :         mtctx->roundBuff.pos = prefixSize;

	mov	QWORD PTR [rsi+264], r14
$LN2@ZSTDMT_try:

; 1900 :     }
; 1901 :     buffer.start = mtctx->roundBuff.buffer + mtctx->roundBuff.pos;

	mov	rdi, QWORD PTR [rsi+248]

; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;

	lea	rax, QWORD PTR [r15+rbx]

; 1900 :     }
; 1901 :     buffer.start = mtctx->roundBuff.buffer + mtctx->roundBuff.pos;

	add	rdi, r14

; 1813 :     BYTE const* const bufferStart = (BYTE const*)buffer.start;

	lea	rcx, QWORD PTR [rdi+rbp]

; 1814 :     BYTE const* const bufferEnd = bufferStart + buffer.capacity;
; 1815 :     BYTE const* const rangeStart = (BYTE const*)range.start;
; 1816 :     BYTE const* const rangeEnd = range.size != 0 ? rangeStart + range.size : rangeStart;

	test	r15, r15
	jne	SHORT $LN30@ZSTDMT_try
	mov	rax, rbx
$LN30@ZSTDMT_try:

; 1817 : 
; 1818 :     if (rangeStart == NULL || bufferStart == NULL)

	test	rbx, rbx
	je	SHORT $LN4@ZSTDMT_try
	test	rdi, rdi
	je	SHORT $LN4@ZSTDMT_try

; 1819 :         return 0;
; 1820 :     /* Empty ranges cannot overlap */
; 1821 :     if (bufferStart == bufferEnd || rangeStart == rangeEnd)

	cmp	rdi, rcx
	je	SHORT $LN4@ZSTDMT_try
	cmp	rbx, rax
	je	SHORT $LN4@ZSTDMT_try

; 1822 :         return 0;
; 1823 : 
; 1824 :     return bufferStart < rangeEnd && rangeStart < bufferEnd;

	cmp	rdi, rax
	jae	SHORT $LN4@ZSTDMT_try
	cmp	rbx, rcx
	jae	SHORT $LN4@ZSTDMT_try
$LN39@ZSTDMT_try:

; 1902 :     buffer.capacity = target;
; 1903 : 
; 1904 :     if (ZSTDMT_isOverlapped(buffer, inUse)) {
; 1905 :         DEBUGLOG(5, "Waiting for buffer...");
; 1906 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ZSTDMT_try
$LN34@ZSTDMT_try:

; 1795 :             range_t range = mtctx->jobs[wJobID].prefix;

	imul	rdx, r14, 336				; 00000150H
	movups	xmm1, XMMWORD PTR [rdx+rcx+112]

; 1796 :             if (range.size == 0) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	movq	rax, xmm0
	test	rax, rax
	jne	SHORT $LN11@ZSTDMT_try

; 1797 :                 /* Empty prefix */
; 1798 :                 range = mtctx->jobs[wJobID].src;

	movups	xmm1, XMMWORD PTR [rdx+rcx+128]
$LN11@ZSTDMT_try:

; 1799 :             }
; 1800 :             /* Job source in multiple segments not supported yet */
; 1801 :             assert(range.start <= mtctx->jobs[wJobID].src.start);
; 1802 :             return range;

	movdqa	XMMWORD PTR $T3[rsp], xmm1
	jmp	$LN6@ZSTDMT_try
$LN4@ZSTDMT_try:

; 1907 :     }
; 1908 :     assert(!ZSTDMT_isOverlapped(buffer, mtctx->inBuff.prefix));
; 1909 : 
; 1910 :     ZSTDMT_waitForLdmComplete(mtctx, buffer);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T1[rsp], rdi
	mov	rcx, rsi
	mov	QWORD PTR $T1[rsp+8], rbp
	call	ZSTDMT_waitForLdmComplete

; 1911 : 
; 1912 :     DEBUGLOG(5, "Using prefix range [%zx, %zx)",
; 1913 :                 (size_t)mtctx->inBuff.prefix.start,
; 1914 :                 (size_t)mtctx->inBuff.prefix.start + mtctx->inBuff.prefix.size);
; 1915 :     DEBUGLOG(5, "Using source range [%zx, %zx)",
; 1916 :                 (size_t)buffer.start,
; 1917 :                 (size_t)buffer.start + buffer.capacity);
; 1918 : 
; 1919 : 
; 1920 :     mtctx->inBuff.buffer = buffer;

	mov	QWORD PTR [rsi+224], rdi

; 1921 :     mtctx->inBuff.filled = 0;
; 1922 :     assert(mtctx->roundBuff.pos + buffer.capacity <= mtctx->roundBuff.capacity);
; 1923 :     return 1;

	mov	eax, 1
	mov	QWORD PTR [rsi+232], rbp
	mov	QWORD PTR [rsi+240], 0
$LN1@ZSTDMT_try:

; 1924 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
ZSTDMT_tryGetInputRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c
_TEXT	SEGMENT
$T1 = 64
hitMask$1$ = 72
mtctx$ = 72
input$ = 80
findSynchronizationPoint PROC

; 1939 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 16

; 1940 :     BYTE const* const istart = (BYTE const*)input.src + input.pos;

	mov	rdi, QWORD PTR [r8]
	mov	rbx, rcx
	add	rdi, QWORD PTR [r8+16]

; 1941 :     U64 const primePower = mtctx->rsync.primePower;
; 1942 :     U64 const hitMask = mtctx->rsync.hitMask;
; 1943 : 
; 1944 :     syncPoint_t syncPoint;
; 1945 :     U64 hash;
; 1946 :     BYTE const* prev;
; 1947 :     size_t pos;
; 1948 : 
; 1949 :     syncPoint.toLoad = MIN(input.size - input.pos, mtctx->targetSectionSize - mtctx->inBuff.filled);

	mov	r11, QWORD PTR [rdx+240]
	mov	rax, QWORD PTR [rdx+184]
	mov	rsi, QWORD PTR [r8+8]
	sub	rax, r11
	sub	rsi, QWORD PTR [r8+16]
	mov	r15, QWORD PTR [rdx+712]
	cmp	rsi, rax
	mov	r12, QWORD PTR [rdx+720]
	cmovae	rsi, rax
	mov	QWORD PTR hitMask$1$[rsp], r15

; 1950 :     syncPoint.flush = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx], rsi
	mov	DWORD PTR [rcx+8], eax

; 1951 :     if (!mtctx->params.rsyncable)

	cmp	DWORD PTR [rdx+132], eax
	je	$LN62@findSynchr

; 1952 :         /* Rsync is disabled. */
; 1953 :         return syncPoint;
; 1954 :     if (mtctx->inBuff.filled + syncPoint.toLoad < RSYNC_LENGTH)

	lea	rcx, QWORD PTR [r11+rsi]
	cmp	rcx, 32					; 00000020H
	jb	$LN62@findSynchr

; 1955 :         /* Not enough to compute the hash.
; 1956 :          * We will miss any synchronization points in this RSYNC_LENGTH byte
; 1957 :          * window. However, since it depends only in the internal buffers, if the
; 1958 :          * state is already synchronized, we will remain synchronized.
; 1959 :          * Additionally, the probability that we miss a synchronization point is
; 1960 :          * low: RSYNC_LENGTH / targetSectionSize.
; 1961 :          */
; 1962 :         return syncPoint;
; 1963 :     /* Initialize the loop variables. */
; 1964 :     if (mtctx->inBuff.filled >= RSYNC_LENGTH) {

	mov	QWORD PTR [rsp+80], rbp
	mov	r10, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	rbp, QWORD PTR [rdx+224]
	mov	QWORD PTR [rsp], r14
	cmp	r11, 32					; 00000020H
	jb	$LN7@findSynchr

; 1965 :         /* We have enough bytes buffered to initialize the hash.
; 1966 :          * Start scanning at the beginning of the input.
; 1967 :          */
; 1968 :         pos = 0;
; 1969 :         prev = (BYTE const*)mtctx->inBuff.buffer.start + mtctx->inBuff.filled - RSYNC_LENGTH;

	lea	r14, QWORD PTR [rbp-32]
	mov	QWORD PTR [rsp+8], r13
	add	r14, r11
	mov	r8d, eax
	mov	rbp, 6509340318410440265		; 5a55d28818fb7e49H
	lea	r11d, QWORD PTR [rax+8]
	mov	rbx, 1741079827716923664		; 18298ee0f0aa6110H
	mov	r13, -967543300940408261		; f292987e7aa35a3bH
	mov	r15, 6435661797146095825		; 5950104e9171f0d1H
	lea	r9, QWORD PTR [r14+2]
$LL45@findSynchr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	edx, BYTE PTR [r9-1]
	movzx	ecx, BYTE PTR [r9-2]
	lea	r9, QWORD PTR [r9+4]
	imul	rcx, r13
	imul	rdx, rbp
	imul	rax, r15
	add	rdx, rcx
	movzx	ecx, BYTE PTR [r9-4]
	imul	rcx, r10
	add	rdx, rcx
	movzx	ecx, BYTE PTR [r9-3]
	add	rcx, rdx
	add	rcx, rbx
	add	rax, rcx
	sub	r11, 1
	jne	SHORT $LL45@findSynchr
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1971 :     } else {

	mov	rbx, QWORD PTR $T1[rsp]
	mov	r15, QWORD PTR hitMask$1$[rsp]
	mov	r13, QWORD PTR [rsp+8]
	jmp	SHORT $LN8@findSynchr
$LN7@findSynchr:

; 1972 :         /* We don't have enough bytes buffered to initialize the hash, but
; 1973 :          * we know we have at least RSYNC_LENGTH bytes total.
; 1974 :          * Start scanning after the first RSYNC_LENGTH bytes less the bytes
; 1975 :          * already buffered.
; 1976 :          */
; 1977 :         pos = RSYNC_LENGTH - mtctx->inBuff.filled;

	mov	r8d, 32					; 00000020H

; 1978 :         prev = (BYTE const*)mtctx->inBuff.buffer.start - pos;

	mov	r14, rbp
	sub	r8, r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 677  :     return ZSTD_rollingHash_append(0, buf, size);

	mov	rdx, rax
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1978 :         prev = (BYTE const*)mtctx->inBuff.buffer.start - pos;

	sub	r14, r8
	mov	r9, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 665  :     for (pos = 0; pos < size; ++pos) {

	test	r11, r11
	je	SHORT $LN26@findSynchr
	npad	6
$LL47@findSynchr:

; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	ecx, BYTE PTR [r9+rbp]
	inc	r9
	imul	rdx, r10
	add	rdx, 10
	add	rdx, rcx
	cmp	r9, r11
	jb	SHORT $LL47@findSynchr
$LN26@findSynchr:

; 665  :     for (pos = 0; pos < size; ++pos) {

	test	r8, r8
	je	SHORT $LN31@findSynchr
	npad	3
$LL49@findSynchr:

; 667  :         hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;

	movzx	ecx, BYTE PTR [rax+rdi]
	inc	rax
	imul	rdx, r10
	add	rdx, 10
	add	rdx, rcx
	cmp	rax, r8
	jb	SHORT $LL49@findSynchr
$LN31@findSynchr:
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1980 :         hash = ZSTD_rollingHash_append(hash, istart, pos);

	mov	rax, rdx
$LN8@findSynchr:
	mov	rbp, QWORD PTR [rsp+80]

; 1981 :     }
; 1982 :     /* Starting with the hash of the previous RSYNC_LENGTH bytes, roll
; 1983 :      * through the input. If we hit a synchronization point, then cut the
; 1984 :      * job off, and tell the compressor to flush the job. Otherwise, load
; 1985 :      * all the bytes and continue as normal.
; 1986 :      * If we go too long without a synchronization point (targetSectionSize)
; 1987 :      * then a block will be emitted anyways, but this is okay, since if we
; 1988 :      * are already synchronized we will remain synchronized.
; 1989 :      */
; 1990 :     for (; pos < syncPoint.toLoad; ++pos) {

	cmp	r8, rsi
	jae	SHORT $LN60@findSynchr
$LL4@findSynchr:

; 1991 :         BYTE const toRemove = pos < RSYNC_LENGTH ? prev[pos] : istart[pos - RSYNC_LENGTH];

	cmp	r8, 32					; 00000020H
	jae	SHORT $LN13@findSynchr
	movzx	ecx, BYTE PTR [r14+r8]
	jmp	SHORT $LN14@findSynchr
$LN13@findSynchr:
	movzx	ecx, BYTE PTR [r8+rdi-32]
$LN14@findSynchr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 694  :     hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;

	movzx	ecx, cl
	add	rcx, 10

; 695  :     hash *= prime8bytes;
; 696  :     hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;

	imul	rcx, r12
	sub	rax, rcx
	movzx	ecx, BYTE PTR [r8+rdi]
	add	rcx, 10
	imul	rax, r10
	add	rax, rcx
; File E:\dev\pyzstd\lib\compress\zstdmt_compress.c

; 1994 :         if ((hash & hitMask) == hitMask) {

	mov	rcx, rax
	inc	r8
	and	rcx, r15
	cmp	rcx, r15
	je	SHORT $LN40@findSynchr

; 1981 :     }
; 1982 :     /* Starting with the hash of the previous RSYNC_LENGTH bytes, roll
; 1983 :      * through the input. If we hit a synchronization point, then cut the
; 1984 :      * job off, and tell the compressor to flush the job. Otherwise, load
; 1985 :      * all the bytes and continue as normal.
; 1986 :      * If we go too long without a synchronization point (targetSectionSize)
; 1987 :      * then a block will be emitted anyways, but this is okay, since if we
; 1988 :      * are already synchronized we will remain synchronized.
; 1989 :      */
; 1990 :     for (; pos < syncPoint.toLoad; ++pos) {

	cmp	r8, rsi
	jb	SHORT $LL4@findSynchr

; 1994 :         if ((hash & hitMask) == hitMask) {

	jmp	SHORT $LN60@findSynchr
$LN40@findSynchr:

; 1995 :             syncPoint.toLoad = pos + 1;

	mov	QWORD PTR [rbx], r8

; 1996 :             syncPoint.flush = 1;

	mov	DWORD PTR [rbx+8], 1
$LN60@findSynchr:
	mov	r14, QWORD PTR [rsp]
$LN62@findSynchr:

; 1997 :             break;
; 1998 :         }
; 1999 :     }
; 2000 :     return syncPoint;
; 2001 : }

	mov	rax, rbx
	add	rsp, 16
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
findSynchronizationPoint ENDP
_TEXT	ENDS
END
