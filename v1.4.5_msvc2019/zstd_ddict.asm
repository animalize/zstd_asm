; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ZSTD_createDDict
PUBLIC	ZSTD_freeDDict
PUBLIC	ZSTD_DDict_dictContent
PUBLIC	ZSTD_createDDict_advanced
PUBLIC	ZSTD_copyDDictParameters
PUBLIC	ZSTD_DDict_dictSize
pdata	SEGMENT
$pdata$ZSTD_createDDict DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$ZSTD_createDDict
$pdata$ZSTD_initDDict_internal DD imagerel ZSTD_initDDict_internal
	DD	imagerel ZSTD_initDDict_internal+247
	DD	imagerel $unwind$ZSTD_initDDict_internal
$pdata$ZSTD_loadEntropy_intoDDict DD imagerel ZSTD_loadEntropy_intoDDict
	DD	imagerel ZSTD_loadEntropy_intoDDict+95
	DD	imagerel $unwind$ZSTD_loadEntropy_intoDDict
$pdata$ZSTD_freeDDict DD imagerel $LN16
	DD	imagerel $LN16+132
	DD	imagerel $unwind$ZSTD_freeDDict
$pdata$ZSTD_createDDict_advanced DD imagerel $LN14
	DD	imagerel $LN14+190
	DD	imagerel $unwind$ZSTD_createDDict_advanced
xdata	SEGMENT
$unwind$ZSTD_createDDict DD 010401H
	DD	0a204H
$unwind$ZSTD_initDDict_internal DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$ZSTD_loadEntropy_intoDDict DD 020601H
	DD	030023206H
$unwind$ZSTD_freeDDict DD 020601H
	DD	03002b206H
$unwind$ZSTD_createDDict_advanced DD 081401H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
ddict$ = 8
ZSTD_DDict_dictSize PROC

; 54   :     assert(ddict != NULL);
; 55   :     return ddict->dictSize;

	mov	rax, QWORD PTR [rcx+16]

; 56   : }

	ret	0
ZSTD_DDict_dictSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
dctx$ = 8
ddict$ = 16
ZSTD_copyDDictParameters PROC

; 60   :     DEBUGLOG(4, "ZSTD_copyDDictParameters");
; 61   :     assert(dctx != NULL);
; 62   :     assert(ddict != NULL);
; 63   :     dctx->dictID = ddict->dictID;

	mov	eax, DWORD PTR [rdx+26688]
	mov	DWORD PTR [rcx+29032], eax

; 64   :     dctx->prefixStart = ddict->dictContent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+28752], rax

; 65   :     dctx->virtualStart = ddict->dictContent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+28760], rax

; 66   :     dctx->dictEnd = (const BYTE*)ddict->dictContent + ddict->dictSize;

	mov	r9, QWORD PTR [rdx+16]
	add	r9, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+28768], r9

; 67   :     dctx->previousDstEnd = dctx->dictEnd;

	mov	QWORD PTR [rcx+28744], r9

; 68   : #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
; 69   :     dctx->dictContentBeginForFuzzing = dctx->prefixStart;
; 70   :     dctx->dictContentEndForFuzzing = dctx->previousDstEnd;
; 71   : #endif
; 72   :     if (ddict->entropyPresent) {

	cmp	DWORD PTR [rdx+26692], 0
	je	SHORT $LN2@ZSTD_copyD

; 73   :         dctx->litEntropy = 1;

	mov	DWORD PTR [rcx+28840], 1

; 74   :         dctx->fseEntropy = 1;
; 75   :         dctx->LLTptr = ddict->entropy.LLTable;

	lea	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx], rax

; 76   :         dctx->MLTptr = ddict->entropy.MLTable;

	lea	rax, QWORD PTR [rdx+6184]
	mov	DWORD PTR [rcx+28844], 1
	mov	QWORD PTR [rcx+8], rax

; 77   :         dctx->OFTptr = ddict->entropy.OFTable;

	lea	rax, QWORD PTR [rdx+4128]
	mov	QWORD PTR [rcx+16], rax

; 78   :         dctx->HUFptr = ddict->entropy.hufTable;

	lea	rax, QWORD PTR [rdx+10288]
	mov	QWORD PTR [rcx+24], rax

; 79   :         dctx->entropy.rep[0] = ddict->entropy.rep[0];

	mov	eax, DWORD PTR [rdx+26676]
	mov	DWORD PTR [rcx+26684], eax

; 80   :         dctx->entropy.rep[1] = ddict->entropy.rep[1];

	mov	eax, DWORD PTR [rdx+26680]
	mov	DWORD PTR [rcx+26688], eax

; 81   :         dctx->entropy.rep[2] = ddict->entropy.rep[2];

	mov	eax, DWORD PTR [rdx+26684]
	mov	DWORD PTR [rcx+26692], eax

; 84   :         dctx->fseEntropy = 0;
; 85   :     }
; 86   : }

	ret	0
$LN2@ZSTD_copyD:

; 82   :     } else {
; 83   :         dctx->litEntropy = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+28840], rax

; 84   :         dctx->fseEntropy = 0;
; 85   :     }
; 86   : }

	ret	0
ZSTD_copyDDictParameters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
$T1 = 48
dict$ = 96
dictSize$ = 104
dictLoadMethod$dead$ = 112
dictContentType$dead$ = 120
customMem$ = 128
ZSTD_createDDict_advanced PROC

; 149  : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 150  :     if (!customMem.customAlloc ^ !customMem.customFree) return NULL;

	mov	rdi, QWORD PTR customMem$[rsp]
	xor	r8d, r8d
	mov	eax, r8d
	mov	rsi, rdx
	mov	rbp, rcx
	cmp	QWORD PTR [rdi+8], rax
	sete	al
	cmp	QWORD PTR [rdi], r8
	sete	r8b
	cmp	eax, r8d
	jne	SHORT $LN11@ZSTD_creat
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rdi]
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 152  :     {   ZSTD_DDict* const ddict = (ZSTD_DDict*) ZSTD_malloc(sizeof(ZSTD_DDict), customMem);

	movsd	xmm0, QWORD PTR [rdi+16]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN7@ZSTD_creat

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	edx, 26720				; 00006860H
	call	rax
	jmp	SHORT $LN12@ZSTD_creat
$LN7@ZSTD_creat:

; 60   :     return malloc(size);

	mov	ecx, 26720				; 00006860H
	call	QWORD PTR __imp_malloc
$LN12@ZSTD_creat:
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 153  :         if (ddict == NULL) return NULL;

	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN11@ZSTD_creat

; 154  :         ddict->cMem = customMem;

	movaps	xmm0, XMMWORD PTR [rdi]

; 155  :         {   size_t const initResult = ZSTD_initDDict_internal(ddict,

	mov	r8, rsi
	movsd	xmm1, QWORD PTR [rdi+16]
	mov	rdx, rbp
	movups	XMMWORD PTR [rax+26696], xmm0
	mov	rcx, rax
	movsd	QWORD PTR [rax+26712], xmm1
	call	ZSTD_initDDict_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 158  :             if (ZSTD_isError(initResult)) {

	jbe	SHORT $LN4@ZSTD_creat

; 159  :                 ZSTD_freeDDict(ddict);

	mov	rcx, rbx
	call	ZSTD_freeDDict
$LN11@ZSTD_creat:

; 163  :     }
; 164  : }

	xor	eax, eax
$LN1@ZSTD_creat:
	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN4@ZSTD_creat:

; 160  :                 return NULL;
; 161  :         }   }
; 162  :         return ddict;

	mov	rax, rbx
	jmp	SHORT $LN1@ZSTD_creat
ZSTD_createDDict_advanced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
ddict$ = 8
ZSTD_DDict_dictContent PROC

; 48   :     assert(ddict != NULL);
; 49   :     return ddict->dictContent;

	mov	rax, QWORD PTR [rcx+8]

; 50   : }

	ret	0
ZSTD_DDict_dictContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
$T1 = 32
cMem$2 = 64
ddict$ = 112
ZSTD_freeDDict PROC

; 213  : {

$LN16:
	push	rbx
	sub	rsp, 96					; 00000060H
	mov	rbx, rcx

; 214  :     if (ddict==NULL) return 0;   /* support free on NULL */

	test	rcx, rcx
	je	SHORT $LN14@ZSTD_freeD

; 215  :     {   ZSTD_customMem const cMem = ddict->cMem;

	movups	xmm0, XMMWORD PTR [rcx+26696]
	movsd	xmm1, QWORD PTR [rcx+26712]

; 216  :         ZSTD_free(ddict->dictBuffer, cMem);

	mov	rcx, QWORD PTR [rcx]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movsd	QWORD PTR cMem$2[rsp+16], xmm1
	movsd	QWORD PTR $T1[rsp+16], xmm1
	movups	XMMWORD PTR cMem$2[rsp], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 77   :     if (ptr!=NULL) {

	test	rcx, rcx
	je	SHORT $LN7@ZSTD_freeD

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR $T1[rsp+8]
	test	rax, rax
	je	SHORT $LN6@ZSTD_freeD

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rdx, rcx
	mov	rcx, QWORD PTR $T1[rsp+16]
	call	rax
	jmp	SHORT $LN7@ZSTD_freeD
$LN6@ZSTD_freeD:

; 81   :             free(ptr);

	call	QWORD PTR __imp_free
$LN7@ZSTD_freeD:

; 78   :         if (customMem.customFree)

	mov	rax, QWORD PTR cMem$2[rsp+8]
	test	rax, rax
	je	SHORT $LN11@ZSTD_freeD

; 79   :             customMem.customFree(customMem.opaque, ptr);

	mov	rcx, QWORD PTR cMem$2[rsp+16]
	mov	rdx, rbx
	call	rax
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 220  : }

	xor	eax, eax
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
$LN11@ZSTD_freeD:
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 81   :             free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN14@ZSTD_freeD:
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 220  : }

	xor	eax, eax
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
ZSTD_freeDDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
ddict$ = 48
dictContentType$dead$ = 56
ZSTD_loadEntropy_intoDDict PROC

; 92   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 93   :     ddict->dictID = 0;
; 94   :     ddict->entropyPresent = 0;
; 95   :     if (dictContentType == ZSTD_dct_rawContent) return 0;
; 96   : 
; 97   :     if (ddict->dictSize < 8) {

	mov	r8, QWORD PTR [rcx+16]
	xor	eax, eax
	mov	QWORD PTR [rcx+26688], rax
	mov	rbx, rcx
	cmp	r8, 8
	jb	SHORT $LN1@ZSTD_loadE

; 98   :         if (dictContentType == ZSTD_dct_fullDict)
; 99   :             return ERROR(dictionary_corrupted);   /* only accept specified dictionaries */
; 100  :         return 0;   /* pure content mode */
; 101  :     }
; 102  :     {   U32 const magic = MEM_readLE32(ddict->dictContent);

	mov	rdx, QWORD PTR [rcx+8]

; 103  :         if (magic != ZSTD_MAGIC_DICTIONARY) {

	cmp	DWORD PTR [rdx], -332356553		; ec30a437H
	jne	SHORT $LN1@ZSTD_loadE

; 104  :             if (dictContentType == ZSTD_dct_fullDict)
; 105  :                 return ERROR(dictionary_corrupted);   /* only accept specified dictionaries */
; 106  :             return 0;   /* pure content mode */
; 107  :         }
; 108  :     }
; 109  :     ddict->dictID = MEM_readLE32((const char*)ddict->dictContent + ZSTD_FRAMEIDSIZE);

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+26688], eax

; 112  :     RETURN_ERROR_IF(ZSTD_isError(ZSTD_loadDEntropy(

	add	rcx, 24
	call	ZSTD_loadDEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 112  :     RETURN_ERROR_IF(ZSTD_isError(ZSTD_loadDEntropy(

	jbe	SHORT $LN7@ZSTD_loadE
	mov	rax, -30

; 117  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@ZSTD_loadE:

; 113  :             &ddict->entropy, ddict->dictContent, ddict->dictSize)),
; 114  :         dictionary_corrupted, "");
; 115  :     ddict->entropyPresent = 1;

	mov	DWORD PTR [rbx+26692], 1

; 116  :     return 0;

	xor	eax, eax
$LN1@ZSTD_loadE:

; 117  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ZSTD_loadEntropy_intoDDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\zstd_common.c
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
$T1 = 32
ddict$ = 80
dict$ = 88
dictSize$ = 96
dictLoadMethod$dead$ = 104
dictContentType$dead$ = 112
ZSTD_initDDict_internal PROC

; 124  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 125  :     if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dict) || (!dictSize)) {

	xor	ebp, ebp
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN7@ZSTD_initD
	test	r8, r8
	je	SHORT $LN7@ZSTD_initD
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	mov	rax, QWORD PTR [rcx+26696]
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 130  :         void* const internalBuffer = ZSTD_malloc(dictSize, ddict->cMem);

	movsd	xmm0, QWORD PTR [rcx+26712]
	movsd	QWORD PTR $T1[rsp+16], xmm0
; File E:\dev\pyzstd\lib\common\zstd_common.c

; 58   :     if (customMem.customAlloc)

	test	rax, rax
	je	SHORT $LN14@ZSTD_initD

; 59   :         return customMem.customAlloc(customMem.opaque, size);

	mov	rcx, QWORD PTR $T1[rsp+16]
	mov	rdx, r8
	call	rax
	jmp	SHORT $LN13@ZSTD_initD
$LN14@ZSTD_initD:

; 60   :     return malloc(size);

	mov	rcx, rdi
	call	QWORD PTR __imp_malloc
$LN13@ZSTD_initD:
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 131  :         ddict->dictBuffer = internalBuffer;

	mov	QWORD PTR [rbx], rax

; 132  :         ddict->dictContent = internalBuffer;

	mov	QWORD PTR [rbx+8], rax

; 133  :         if (!internalBuffer) return ERROR(memory_allocation);

	test	rax, rax
	jne	SHORT $LN9@ZSTD_initD
	mov	rax, -64				; ffffffffffffffc0H
	jmp	SHORT $LN1@ZSTD_initD
$LN9@ZSTD_initD:

; 134  :         memcpy(internalBuffer, dict, dictSize);

	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	jmp	SHORT $LN8@ZSTD_initD
$LN7@ZSTD_initD:

; 126  :         ddict->dictBuffer = NULL;
; 127  :         ddict->dictContent = dict;
; 128  :         if (!dict) dictSize = 0;

	test	rsi, rsi
	mov	QWORD PTR [rcx], rbp
	mov	QWORD PTR [rcx+8], rsi
	cmove	rdi, rbp
$LN8@ZSTD_initD:

; 135  :     }
; 136  :     ddict->dictSize = dictSize;

	mov	QWORD PTR [rbx+16], rdi

; 137  :     ddict->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */

	mov	DWORD PTR [rbx+10288], 201326604	; 0c00000cH

; 93   :     ddict->dictID = 0;

	mov	QWORD PTR [rbx+26688], rbp

; 94   :     ddict->entropyPresent = 0;
; 95   :     if (dictContentType == ZSTD_dct_rawContent) return 0;
; 96   : 
; 97   :     if (ddict->dictSize < 8) {

	cmp	rdi, 8
	jb	SHORT $LN2@ZSTD_initD

; 98   :         if (dictContentType == ZSTD_dct_fullDict)
; 99   :             return ERROR(dictionary_corrupted);   /* only accept specified dictionaries */
; 100  :         return 0;   /* pure content mode */
; 101  :     }
; 102  :     {   U32 const magic = MEM_readLE32(ddict->dictContent);

	mov	rdx, QWORD PTR [rbx+8]

; 103  :         if (magic != ZSTD_MAGIC_DICTIONARY) {

	cmp	DWORD PTR [rdx], -332356553		; ec30a437H
	jne	SHORT $LN2@ZSTD_initD

; 104  :             if (dictContentType == ZSTD_dct_fullDict)
; 105  :                 return ERROR(dictionary_corrupted);   /* only accept specified dictionaries */
; 106  :             return 0;   /* pure content mode */
; 107  :         }
; 108  :     }
; 109  :     ddict->dictID = MEM_readLE32((const char*)ddict->dictContent + ZSTD_FRAMEIDSIZE);

	mov	eax, DWORD PTR [rdx+4]

; 112  :     RETURN_ERROR_IF(ZSTD_isError(ZSTD_loadDEntropy(

	lea	rcx, QWORD PTR [rbx+24]
	mov	r8, rdi
	mov	DWORD PTR [rbx+26688], eax
	call	ZSTD_loadDEntropy
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c

; 112  :     RETURN_ERROR_IF(ZSTD_isError(ZSTD_loadDEntropy(

	ja	SHORT $LN29@ZSTD_initD

; 113  :             &ddict->entropy, ddict->dictContent, ddict->dictSize)),
; 114  :         dictionary_corrupted, "");
; 115  :     ddict->entropyPresent = 1;

	mov	DWORD PTR [rbx+26692], 1
$LN2@ZSTD_initD:

; 141  : 
; 142  :     return 0;

	xor	eax, eax
$LN1@ZSTD_initD:

; 143  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN29@ZSTD_initD:

; 138  : 
; 139  :     /* parse dictionary content */
; 140  :     FORWARD_IF_ERROR( ZSTD_loadEntropy_intoDDict(ddict, dictContentType) , "");

	mov	rax, -30
	jmp	SHORT $LN1@ZSTD_initD
ZSTD_initDDict_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_ddict.c
_TEXT	SEGMENT
$T1 = 48
dict$ = 96
dictSize$ = 104
ZSTD_createDDict PROC

; 171  : {

$LN4:
	sub	rsp, 88					; 00000058H

; 172  :     ZSTD_customMem const allocator = { NULL, NULL, NULL };
; 173  :     return ZSTD_createDDict_advanced(dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto, allocator);

	xor	eax, eax
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], rax
	mov	QWORD PTR $T1[rsp+16], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_createDDict_advanced

; 174  : }

	add	rsp, 88					; 00000058H
	ret	0
ZSTD_createDDict ENDP
_TEXT	ENDS
END
