; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

refreshRate DD	096H
prime8bytes DQ	cf1bbcdcb7a56463H
prime6bytes DQ	0000cf1bbcdcbf9bH
FASTCOVER_defaultAccelParameters DD 064H
	DD	00H
	DD	064H
	DD	00H
	DD	032H
	DD	01H
	DD	022H
	DD	02H
	DD	019H
	DD	03H
	DD	014H
	DD	04H
	DD	011H
	DD	05H
	DD	0eH
	DD	06H
	DD	0dH
	DD	07H
	DD	0bH
	DD	08H
	DD	0aH
	DD	09H
PUBLIC	ZDICT_optimizeTrainFromBuffer_fastCover
	ALIGN	4

g_time	DD	01H DUP (?)
$SG4294962760 DB 01H DUP (?)
	ALIGN	4

$SG4294962782 DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$FASTCOVER_tryParameters DD imagerel FASTCOVER_tryParameters
	DD	imagerel FASTCOVER_tryParameters+820
	DD	imagerel $unwind$FASTCOVER_tryParameters
$pdata$FASTCOVER_buildDictionary DD imagerel FASTCOVER_buildDictionary
	DD	imagerel FASTCOVER_buildDictionary+689
	DD	imagerel $unwind$FASTCOVER_buildDictionary
$pdata$FASTCOVER_ctx_init DD imagerel FASTCOVER_ctx_init
	DD	imagerel FASTCOVER_ctx_init+1192
	DD	imagerel $unwind$FASTCOVER_ctx_init
$pdata$FASTCOVER_computeFrequency DD imagerel FASTCOVER_computeFrequency
	DD	imagerel FASTCOVER_computeFrequency+52
	DD	imagerel $unwind$FASTCOVER_computeFrequency
$pdata$2$FASTCOVER_computeFrequency DD imagerel FASTCOVER_computeFrequency+52
	DD	imagerel FASTCOVER_computeFrequency+227
	DD	imagerel $chain$2$FASTCOVER_computeFrequency
$pdata$3$FASTCOVER_computeFrequency DD imagerel FASTCOVER_computeFrequency+227
	DD	imagerel FASTCOVER_computeFrequency+235
	DD	imagerel $chain$3$FASTCOVER_computeFrequency
$pdata$FASTCOVER_ctx_destroy DD imagerel FASTCOVER_ctx_destroy
	DD	imagerel FASTCOVER_ctx_destroy+55
	DD	imagerel $unwind$FASTCOVER_ctx_destroy
$pdata$FASTCOVER_selectSegment DD imagerel FASTCOVER_selectSegment
	DD	imagerel FASTCOVER_selectSegment+564
	DD	imagerel $unwind$FASTCOVER_selectSegment
$pdata$ZDICT_optimizeTrainFromBuffer_fastCover DD imagerel $LN220
	DD	imagerel $LN220+546
	DD	imagerel $unwind$ZDICT_optimizeTrainFromBuffer_fastCover
$pdata$3$ZDICT_optimizeTrainFromBuffer_fastCover DD imagerel $LN220+546
	DD	imagerel $LN220+1844
	DD	imagerel $chain$3$ZDICT_optimizeTrainFromBuffer_fastCover
$pdata$4$ZDICT_optimizeTrainFromBuffer_fastCover DD imagerel $LN220+1844
	DD	imagerel $LN220+1905
	DD	imagerel $chain$4$ZDICT_optimizeTrainFromBuffer_fastCover
$pdata$5$ZDICT_optimizeTrainFromBuffer_fastCover DD imagerel $LN220+1905
	DD	imagerel $LN220+2400
	DD	imagerel $chain$5$ZDICT_optimizeTrainFromBuffer_fastCover
$pdata$6$ZDICT_optimizeTrainFromBuffer_fastCover DD imagerel $LN220+2400
	DD	imagerel $LN220+2513
	DD	imagerel $chain$6$ZDICT_optimizeTrainFromBuffer_fastCover
xdata	SEGMENT
$unwind$FASTCOVER_tryParameters DD 0d2401H
	DD	02b7424H
	DD	02a6424H
	DD	0293424H
	DD	0220124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
$unwind$FASTCOVER_buildDictionary DD 0b2101H
	DD	01a3421H
	DD	0120121H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
$unwind$FASTCOVER_ctx_init DD 0c2101H
	DD	0f6421H
	DD	0e5421H
	DD	0c3421H
	DD	0f01d5221H
	DD	0d019e01bH
	DD	07015c017H
$unwind$FASTCOVER_computeFrequency DD 050801H
	DD	0c006f008H
	DD	050037004H
	DD	03002H
$chain$2$FASTCOVER_computeFrequency DD 061821H
	DD	09e418H
	DD	08d410H
	DD	066405H
	DD	imagerel FASTCOVER_computeFrequency
	DD	imagerel FASTCOVER_computeFrequency+52
	DD	imagerel $unwind$FASTCOVER_computeFrequency
$chain$3$FASTCOVER_computeFrequency DD 021H
	DD	imagerel FASTCOVER_computeFrequency
	DD	imagerel FASTCOVER_computeFrequency+52
	DD	imagerel $unwind$FASTCOVER_computeFrequency
$unwind$FASTCOVER_ctx_destroy DD 020a01H
	DD	03006320aH
$unwind$FASTCOVER_selectSegment DD 0a1901H
	DD	0a3419H
	DD	0f0151219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$ZDICT_optimizeTrainFromBuffer_fastCover DD 011dc19H
	DD	01d88dcH
	DD	01e7828H
	DD	01f6824H
	DD	04a3420H
	DD	0400120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0190H
$chain$3$ZDICT_optimizeTrainFromBuffer_fastCover DD 061f21H
	DD	01ab81fH
	DD	01ba816H
	DD	01c9809H
	DD	imagerel $LN220
	DD	imagerel $LN220+546
	DD	imagerel $unwind$ZDICT_optimizeTrainFromBuffer_fastCover
$chain$4$ZDICT_optimizeTrainFromBuffer_fastCover DD 021H
	DD	imagerel $LN220
	DD	imagerel $LN220+546
	DD	imagerel $unwind$ZDICT_optimizeTrainFromBuffer_fastCover
$chain$5$ZDICT_optimizeTrainFromBuffer_fastCover DD 060021H
	DD	01ab800H
	DD	01ba800H
	DD	01c9800H
	DD	imagerel $LN220
	DD	imagerel $LN220+546
	DD	imagerel $unwind$ZDICT_optimizeTrainFromBuffer_fastCover
$chain$6$ZDICT_optimizeTrainFromBuffer_fastCover DD 021H
	DD	imagerel $LN220
	DD	imagerel $LN220+546
	DD	imagerel $unwind$ZDICT_optimizeTrainFromBuffer_fastCover
g_displayLevel DD 02H
	ORG $+3
$SG4294962759 DB 0dH, '%79s', 0dH, 00H
	ORG $+3
$SG4294962764 DB 'k=%u', 0aH, 00H
	ORG $+3
$SG4294962766 DB 'd=%u', 0aH, 00H
	ORG $+3
$SG4294962781 DB 0dH, '%79s', 0dH, 00H
	ORG $+6
$SG4294962761 DB 0dH, '%u%%       ', 00H
	ORG $+3
$SG4294962762 DB 'FASTCOVER parameters incorrect', 0aH, 00H
$SG4294962763 DB 'Failed to allocate parameters', 0aH, 00H
	ORG $+1
$SG4294962765 DB 'Failed to initialize context', 0aH, 00H
	ORG $+2
$SG4294962767 DB 'Trying %u different sets of parameters', 0aH, 00H
$SG4294962768 DB 'dictBufferCapacity must be at least %u', 0aH, 00H
$SG4294962769 DB 'FASTCOVER must have at least one input file', 0aH, 00H
	ORG $+3
$SG4294962770 DB 'Incorrect k', 0aH, 00H
	ORG $+3
$SG4294962771 DB 'Incorrect accel', 0aH, 00H
	ORG $+6
$SG4294962772 DB 'Incorrect splitPoint', 0aH, 00H
	ORG $+2
$SG4294962779 DB 'Failed to select dictionary', 0aH, 00H
	ORG $+3
$SG4294962780 DB 'Failed to allocate buffers: out of memory', 0aH, 00H
	ORG $+5
$SG4294962783 DB 0dH, '%u%%       ', 00H
	ORG $+3
$SG4294962784 DB 'Breaking content into %u epochs of size %u', 0aH, 00H
	ORG $+4
$SG4294962785 DB 'Computing frequencies', 0aH, 00H
	ORG $+1
$SG4294962786 DB 'Failed to allocate frequency table ', 0aH, 00H
	ORG $+3
$SG4294962787 DB 'Failed to allocate scratch buffers ', 0aH, 00H
	ORG $+3
$SG4294962788 DB 'Testing on %u samples of total size %u', 0aH, 00H
$SG4294962789 DB 'Training on %u samples of total size %u', 0aH, 00H
	ORG $+7
$SG4294962790 DB 'Total number of testing samples is %u and is invalid.', 0aH
	DB	00H
	ORG $+1
$SG4294962791 DB 'Total number of training samples is %u and is invalid', 0aH
	DB	00H
	ORG $+9
$SG4294962792 DB 'Total samples size is too large (%u MB), maximum size i'
	DB	's %u MB', 0aH, 00H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
d$1$ = 64
warned$1$ = 68
kMinK$1$ = 72
kMaxD$1$ = 76
kIterations$1$ = 80
kMaxK$1$ = 84
f$1$ = 88
accel$1$ = 92
kSteps$1$ = 96
kStepSize$1$ = 100
dictBufferCapacity$GSCopy$1$ = 104
$T1 = 112
coverParams$ = 112
samplesSizes$GSCopy$1$ = 160
samplesBuffer$1$ = 168
parameters$GSCopy$1$ = 176
dictBuffer$GSCopy$1$ = 184
$T2 = 192
ctx$3 = 192
best$ = 272
__$ArrayPad$ = 400
dictBuffer$ = 576
dictBufferCapacity$ = 584
samplesBuffer$ = 592
samplesSizes$ = 600
nbSamples$ = 608
parameters$ = 616
ZDICT_optimizeTrainFromBuffer_fastCover PROC

; 614  : {

$LN220:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-312]
	sub	rsp, 512				; 00000200H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, QWORD PTR parameters$[rbp-256]
	xorps	xmm6, xmm6
	mov	QWORD PTR samplesSizes$GSCopy$1$[rbp-256], r9
	mov	r15, rdx
	mov	QWORD PTR samplesBuffer$1$[rbp-256], r8
	mov	QWORD PTR dictBufferCapacity$GSCopy$1$[rsp], rdx

; 615  :     ZDICT_cover_params_t coverParams;
; 616  :     FASTCOVER_accel_t accelParams;
; 617  :     /* constants */
; 618  :     const unsigned nbThreads = parameters->nbThreads;
; 619  :     const double splitPoint =

	movsd	xmm7, QWORD PTR [rbx+24]
	comisd	xmm6, xmm7
	mov	r10d, DWORD PTR [rbx+16]
	mov	QWORD PTR dictBuffer$GSCopy$1$[rbp-256], rcx
	mov	QWORD PTR parameters$GSCopy$1$[rbp-256], rbx
	jb	SHORT $LN41@ZDICT_opti
	movsd	xmm7, QWORD PTR __real@3fe8000000000000
$LN41@ZDICT_opti:

; 620  :         parameters->splitPoint <= 0.0 ? DEFAULT_SPLITPOINT : parameters->splitPoint;
; 621  :     const unsigned kMinD = parameters->d == 0 ? 6 : parameters->d;

	mov	edi, DWORD PTR [rbx+4]
	mov	DWORD PTR d$1$[rsp], edi
	test	edi, edi
	jne	SHORT $LN43@ZDICT_opti
	mov	edi, 6
	mov	DWORD PTR d$1$[rsp], edi

; 622  :     const unsigned kMaxD = parameters->d == 0 ? 8 : parameters->d;

	lea	r11d, QWORD PTR [rdi+2]
	jmp	SHORT $LN214@ZDICT_opti
$LN43@ZDICT_opti:
	mov	r11d, edi
$LN214@ZDICT_opti:

; 623  :     const unsigned kMinK = parameters->k == 0 ? 50 : parameters->k;

	mov	r8d, DWORD PTR [rbx]
	mov	DWORD PTR kMaxD$1$[rsp], r11d
	mov	DWORD PTR kMinK$1$[rsp], r8d
	test	r8d, r8d
	jne	SHORT $LN47@ZDICT_opti
	mov	r8d, 50					; 00000032H

; 624  :     const unsigned kMaxK = parameters->k == 0 ? 2000 : parameters->k;

	mov	eax, 2000				; 000007d0H
	mov	DWORD PTR kMinK$1$[rsp], r8d
	jmp	SHORT $LN215@ZDICT_opti
$LN47@ZDICT_opti:
	mov	eax, r8d
$LN215@ZDICT_opti:

; 625  :     const unsigned kSteps = parameters->steps == 0 ? 40 : parameters->steps;

	mov	r9d, DWORD PTR [rbx+12]

; 626  :     const unsigned kStepSize = MAX((kMaxK - kMinK) / kSteps, 1);

	mov	esi, 1

; 627  :     const unsigned kIterations =
; 628  :         (1 + (kMaxD - kMinD) / 2) * (1 + (kMaxK - kMinK) / kStepSize);
; 629  :     const unsigned f = parameters->f == 0 ? DEFAULT_F : parameters->f;
; 630  :     const unsigned accel = parameters->accel == 0 ? DEFAULT_ACCEL : parameters->accel;
; 631  :     const unsigned shrinkDict = 0;
; 632  :     /* Local variables */
; 633  :     const int displayLevel = parameters->zParams.notificationLevel;

	mov	r14d, DWORD PTR [rbx+48]
	test	r9d, r9d
	mov	DWORD PTR kMaxK$1$[rsp], eax
	mov	ecx, 40					; 00000028H
	cmove	r9d, ecx
	movaps	XMMWORD PTR [rsp+464], xmm8
	mov	ecx, eax
	mov	DWORD PTR kSteps$1$[rsp], r9d
	sub	ecx, r8d
	xor	edx, edx
	mov	eax, ecx

; 634  :     unsigned iteration = 1;

	mov	r12d, esi
	div	r9d
	mov	r9d, esi
	cmp	eax, esi
	cmova	r9d, eax
	sub	r11d, edi
	xor	edx, edx
	shr	r11d, 1
	inc	r11d
	mov	DWORD PTR kStepSize$1$[rsp], r9d
	mov	eax, ecx
	mov	ecx, 20
	div	r9d
	inc	eax
	imul	r11d, eax
	mov	eax, DWORD PTR [rbx+8]
	test	eax, eax
	cmove	eax, ecx
	mov	DWORD PTR f$1$[rsp], eax
	mov	eax, DWORD PTR [rbx+32]
	test	eax, eax
	mov	DWORD PTR kIterations$1$[rsp], r11d
	cmove	eax, esi

; 635  :     unsigned d;
; 636  :     unsigned k;
; 637  :     COVER_best_t best;
; 638  :     POOL_ctx *pool = NULL;
; 639  :     int warned = 0;

	xor	esi, esi
	xor	r13d, r13d
	mov	DWORD PTR accel$1$[rsp], eax

; 640  :     /* Checks */
; 641  :     if (splitPoint <= 0 || splitPoint > 1) {

	comisd	xmm6, xmm7
	mov	DWORD PTR warned$1$[rsp], esi
	jae	$LN9@ZDICT_opti
	movsd	xmm8, QWORD PTR __real@3ff0000000000000
	comisd	xmm7, xmm8
	ja	$LN9@ZDICT_opti

; 644  :     }
; 645  :     if (accel == 0 || accel > FASTCOVER_MAX_ACCEL) {

	dec	eax
	cmp	eax, 9
	ja	$LN12@ZDICT_opti

; 647  :       return ERROR(parameter_outOfBound);
; 648  :     }
; 649  :     if (kMinK < kMaxD || kMaxK < kMinK) {

	cmp	r8d, DWORD PTR kMaxD$1$[rsp]
	jb	$LN15@ZDICT_opti

; 651  :       return ERROR(parameter_outOfBound);
; 652  :     }
; 653  :     if (nbSamples == 0) {

	cmp	DWORD PTR nbSamples$[rbp-256], esi
	jne	SHORT $LN17@ZDICT_opti

; 654  :       LOCALDISPLAYLEVEL(displayLevel, 1, "FASTCOVER must have at least one input file\n");

	cmp	r14d, r12d
	jl	SHORT $LN18@ZDICT_opti
	lea	ecx, QWORD PTR [rsi+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962769
	call	fprintf
	lea	ecx, QWORD PTR [rsi+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN18@ZDICT_opti:

; 655  :       return ERROR(srcSize_wrong);

	mov	rax, -72				; ffffffffffffffb8H
	jmp	$LN1@ZDICT_opti
$LN17@ZDICT_opti:

; 656  :     }
; 657  :     if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) {

	cmp	r15, 256				; 00000100H
	jae	SHORT $LN19@ZDICT_opti

; 658  :       LOCALDISPLAYLEVEL(displayLevel, 1, "dictBufferCapacity must be at least %u\n",

	cmp	r14d, r12d
	jl	SHORT $LN20@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, 256				; 00000100H
	lea	rdx, OFFSET FLAT:$SG4294962768
	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN20@ZDICT_opti:

; 659  :                    ZDICT_DICTSIZE_MIN);
; 660  :       return ERROR(dstSize_tooSmall);

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN1@ZDICT_opti
$LN19@ZDICT_opti:

; 661  :     }
; 662  :     if (nbThreads > 1) {

	cmp	r10d, r12d
	jbe	SHORT $LN22@ZDICT_opti

; 663  :       pool = POOL_create(nbThreads, 1);

	mov	rcx, r10
	call	POOL_create
	mov	r13, rax

; 664  :       if (!pool) {

	test	rax, rax
	jne	SHORT $LN22@ZDICT_opti

; 665  :         return ERROR(memory_allocation);

	lea	rax, QWORD PTR [r13-64]
	jmp	$LN1@ZDICT_opti
$LN22@ZDICT_opti:
	movaps	XMMWORD PTR [rsp+448], xmm9
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 836  :   (void)ZSTD_pthread_mutex_init(&best->mutex, NULL);

	lea	rcx, QWORD PTR best$[rbp-256]
	movaps	XMMWORD PTR [rsp+432], xmm10
	movaps	XMMWORD PTR [rsp+416], xmm11
	call	QWORD PTR __imp_InitializeCriticalSection

; 837  :   (void)ZSTD_pthread_cond_init(&best->cond, NULL);

	lea	rcx, QWORD PTR best$[rbp-216]
	call	QWORD PTR __imp_InitializeConditionVariable
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 671  :     FASTCOVER_convertToCoverParams(*parameters, &coverParams);

	movups	xmm1, XMMWORD PTR [rbx]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 838  :   best->liveJobs = 0;

	xor	ecx, ecx

; 840  :   best->dictSize = 0;
; 841  :   best->compressedSize = (size_t)-1;

	mov	QWORD PTR best$[rbp-136], -1
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 671  :     FASTCOVER_convertToCoverParams(*parameters, &coverParams);

	movups	xmm2, XMMWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 838  :   best->liveJobs = 0;

	mov	QWORD PTR best$[rbp-208], rcx
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 671  :     FASTCOVER_convertToCoverParams(*parameters, &coverParams);

	movups	xmm3, XMMWORD PTR [rbx+32]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 839  :   best->dict = NULL;

	mov	QWORD PTR best$[rbp-200], rcx
	xorps	xmm0, xmm0
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 512  :     coverParams->k = fastCoverParams.k;

	movd	DWORD PTR coverParams$[rsp], xmm1

; 513  :     coverParams->d = fastCoverParams.d;

	movq	rax, xmm1

; 671  :     FASTCOVER_convertToCoverParams(*parameters, &coverParams);

	movaps	XMMWORD PTR $T2[rbp-224], xmm3

; 513  :     coverParams->d = fastCoverParams.d;

	shr	rax, 32					; 00000020H
	mov	DWORD PTR coverParams$[rsp+4], eax
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 842  :   memset(&best->parameters, 0, sizeof(best->parameters));

	movups	XMMWORD PTR best$[rbp-184], xmm0
	mov	QWORD PTR best$[rbp-192], rcx
	movups	XMMWORD PTR best$[rbp-168], xmm0
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 670  :     memset(&coverParams, 0 , sizeof(coverParams));

	mov	DWORD PTR coverParams$[rbp-228], ecx
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 842  :   memset(&best->parameters, 0, sizeof(best->parameters));

	movups	XMMWORD PTR best$[rbp-152], xmm0
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 670  :     memset(&coverParams, 0 , sizeof(coverParams));

	mov	DWORD PTR coverParams$[rbp-212], ecx

; 671  :     FASTCOVER_convertToCoverParams(*parameters, &coverParams);

	movsd	xmm0, QWORD PTR [rbx+48]

; 672  :     accelParams = FASTCOVER_defaultAccelParameters[accel];

	mov	ebx, DWORD PTR accel$1$[rsp]
	movsd	QWORD PTR $T2[rbp-208], xmm0

; 517  :     coverParams->zParams = fastCoverParams.zParams;

	movsd	xmm0, QWORD PTR $T2[rbp-212]
	psrldq	xmm1, 8
	movq	rax, xmm1
	movd	DWORD PTR coverParams$[rsp+12], xmm2
	shr	rax, 32					; 00000020H
	mov	DWORD PTR coverParams$[rsp+8], eax

; 673  :     /* Turn down global display level to clean up display at level 2 and below */
; 674  :     g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;
; 675  :     /* Loop through d first because each new value needs a new context */
; 676  :     LOCALDISPLAYLEVEL(displayLevel, 2, "Trying %u different sets of parameters\n",

	test	r14d, r14d

; 517  :     coverParams->zParams = fastCoverParams.zParams;

	mov	eax, DWORD PTR $T2[rbp-204]
	mov	DWORD PTR coverParams$[rbp-216], eax

; 672  :     accelParams = FASTCOVER_defaultAccelParameters[accel];

	lea	rax, OFFSET FLAT:FASTCOVER_defaultAccelParameters
	mov	rbx, QWORD PTR [rax+rbx*8]

; 673  :     /* Turn down global display level to clean up display at level 2 and below */
; 674  :     g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;
; 675  :     /* Loop through d first because each new value needs a new context */
; 676  :     LOCALDISPLAYLEVEL(displayLevel, 2, "Trying %u different sets of parameters\n",

	lea	eax, DWORD PTR [r14-1]
	cmovne	ecx, eax

; 516  :     coverParams->splitPoint = fastCoverParams.splitPoint;

	unpckhpd xmm2, xmm2

; 518  :     coverParams->shrinkDict = fastCoverParams.shrinkDict;

	psrldq	xmm3, 4

; 673  :     /* Turn down global display level to clean up display at level 2 and below */
; 674  :     g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;
; 675  :     /* Loop through d first because each new value needs a new context */
; 676  :     LOCALDISPLAYLEVEL(displayLevel, 2, "Trying %u different sets of parameters\n",

	mov	DWORD PTR g_displayLevel, ecx

; 516  :     coverParams->splitPoint = fastCoverParams.splitPoint;

	movsd	QWORD PTR coverParams$[rbp-240], xmm2

; 517  :     coverParams->zParams = fastCoverParams.zParams;

	movsd	QWORD PTR coverParams$[rbp-224], xmm0

; 518  :     coverParams->shrinkDict = fastCoverParams.shrinkDict;

	movd	DWORD PTR coverParams$[rbp-232], xmm3

; 673  :     /* Turn down global display level to clean up display at level 2 and below */
; 674  :     g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;
; 675  :     /* Loop through d first because each new value needs a new context */
; 676  :     LOCALDISPLAYLEVEL(displayLevel, 2, "Trying %u different sets of parameters\n",

	cmp	r14d, 2
	jl	SHORT $LN23@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, DWORD PTR kIterations$1$[rsp]
	lea	rdx, OFFSET FLAT:$SG4294962767
	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
	jmp	SHORT $LN204@ZDICT_opti
$LN23@ZDICT_opti:

; 677  :                       kIterations);
; 678  :     for (d = kMinD; d <= kMaxD; d += 2) {

	mov	DWORD PTR d$1$[rsp], edi
$LN204@ZDICT_opti:
	movups	xmm9, XMMWORD PTR coverParams$[rbp-224]
	movups	xmm10, XMMWORD PTR coverParams$[rbp-240]
	movups	xmm11, XMMWORD PTR coverParams$[rsp]
$LL197@ZDICT_opti:

; 679  :       /* Initialize the context for this value of d */
; 680  :       FASTCOVER_ctx_t ctx;
; 681  :       LOCALDISPLAYLEVEL(displayLevel, 3, "d=%u\n", d);

	cmp	r14d, 3
	jl	SHORT $LN24@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294962766
	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN24@ZDICT_opti:

; 682  :       {
; 683  :         size_t const initVal = FASTCOVER_ctx_init(&ctx, samplesBuffer, samplesSizes, nbSamples, d, splitPoint, f, accelParams);

	mov	eax, DWORD PTR f$1$[rsp]
	lea	rcx, QWORD PTR ctx$3[rbp-256]
	mov	r9d, DWORD PTR nbSamples$[rbp-256]
	mov	r8, QWORD PTR samplesSizes$GSCopy$1$[rbp-256]
	mov	rdx, QWORD PTR samplesBuffer$1$[rbp-256]
	mov	QWORD PTR [rsp+56], rbx
	mov	DWORD PTR [rsp+48], eax
	movsd	QWORD PTR [rsp+40], xmm7
	mov	DWORD PTR [rsp+32], edi
	call	FASTCOVER_ctx_init
	mov	rdi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 684  :         if (ZSTD_isError(initVal)) {

	ja	$LN143@ZDICT_opti

; 689  :         }
; 690  :       }
; 691  :       if (!warned) {

	test	esi, esi
	jne	SHORT $LN27@ZDICT_opti

; 692  :         COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.nbDmers, displayLevel);

	mov	rdx, QWORD PTR ctx$3[rbp-208]
	mov	r8d, r14d
	mov	rcx, r15
	call	COVER_warnOnSmallCorpus

; 693  :         warned = 1;

	mov	DWORD PTR warned$1$[rsp], 1
$LN27@ZDICT_opti:

; 694  :       }
; 695  :       /* Loop through k reusing the same context */
; 696  :       for (k = kMinK; k <= kMaxK; k += kStepSize) {

	mov	esi, DWORD PTR kMinK$1$[rsp]
	imul	r15d, r12d, 100				; 00000064H
	npad	6
$LL7@ZDICT_opti:

; 697  :         /* Prepare the arguments */
; 698  :         FASTCOVER_tryParameters_data_t *data = (FASTCOVER_tryParameters_data_t *)malloc(

	mov	ecx, 72					; 00000048H
	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 699  :             sizeof(FASTCOVER_tryParameters_data_t));
; 700  :         LOCALDISPLAYLEVEL(displayLevel, 3, "k=%u\n", k);

	cmp	r14d, 3
	jl	SHORT $LN28@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG4294962764
	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN28@ZDICT_opti:

; 701  :         if (!data) {

	test	rdi, rdi
	je	$LN142@ZDICT_opti

; 711  :         data->parameters = coverParams;
; 712  :         data->parameters.k = k;
; 713  :         data->parameters.d = d;
; 714  :         data->parameters.splitPoint = splitPoint;
; 715  :         data->parameters.steps = kSteps;
; 716  :         data->parameters.shrinkDict = shrinkDict;
; 717  :         data->parameters.zParams.notificationLevel = g_displayLevel;

	mov	r8d, DWORD PTR g_displayLevel
	lea	rax, QWORD PTR ctx$3[rbp-256]
	mov	r9, QWORD PTR dictBufferCapacity$GSCopy$1$[rsp]
	movups	XMMWORD PTR [rdi+24], xmm11
	mov	QWORD PTR [rdi], rax
	lea	rax, QWORD PTR best$[rbp-256]
	movups	XMMWORD PTR [rdi+40], xmm10
	mov	QWORD PTR [rdi+8], rax
	mov	eax, DWORD PTR d$1$[rsp]
	movups	XMMWORD PTR [rdi+56], xmm9
	mov	DWORD PTR [rdi+28], eax
	mov	eax, DWORD PTR kSteps$1$[rsp]
	mov	DWORD PTR [rdi+32], eax
	movsd	QWORD PTR [rdi+40], xmm7
	mov	DWORD PTR [rdi+24], esi
	mov	DWORD PTR [rdi+48], 0
	mov	DWORD PTR [rdi+60], r8d

; 224  :   if (parameters.d == 0 || parameters.k == 0) {

	mov	rdx, QWORD PTR [rdi+24]

; 718  :         /* Check the parameters */
; 719  :         if (!FASTCOVER_checkParameters(data->parameters, dictBufferCapacity,

	movups	xmm0, XMMWORD PTR [rdi+40]

; 224  :   if (parameters.d == 0 || parameters.k == 0) {

	mov	rcx, rdx

; 707  :         }
; 708  :         data->ctx = &ctx;
; 709  :         data->best = &best;
; 710  :         data->dictBufferCapacity = dictBufferCapacity;

	mov	QWORD PTR [rdi+16], r9

; 224  :   if (parameters.d == 0 || parameters.k == 0) {

	shr	rcx, 32					; 00000020H

; 718  :         /* Check the parameters */
; 719  :         if (!FASTCOVER_checkParameters(data->parameters, dictBufferCapacity,

	movaps	XMMWORD PTR $T1[rbp-240], xmm0

; 224  :   if (parameters.d == 0 || parameters.k == 0) {

	test	ecx, ecx
	je	$LN91@ZDICT_opti
	test	edx, edx
	je	$LN91@ZDICT_opti

; 225  :     return 0;
; 226  :   }
; 227  :   /* d has to be 6 or 8 */
; 228  :   if (parameters.d != 6 && parameters.d != 8) {

	cmp	ecx, 6
	je	SHORT $LN92@ZDICT_opti
	cmp	ecx, 8
	jne	$LN91@ZDICT_opti
$LN92@ZDICT_opti:

; 229  :     return 0;
; 230  :   }
; 231  :   /* k <= maxDictSize */
; 232  :   if (parameters.k > maxDictSize) {

	mov	eax, edx
	cmp	rax, r9
	ja	$LN91@ZDICT_opti

; 233  :     return 0;
; 234  :   }
; 235  :   /* d <= k */
; 236  :   if (parameters.d > parameters.k) {

	cmp	ecx, edx
	ja	$LN91@ZDICT_opti

; 237  :     return 0;
; 238  :   }
; 239  :   /* 0 < f <= FASTCOVER_MAX_F*/
; 240  :   if (f > FASTCOVER_MAX_F || f == 0) {

	mov	eax, DWORD PTR ctx$3[rbp-188]
	dec	eax
	cmp	eax, 30
	ja	$LN91@ZDICT_opti

; 241  :     return 0;
; 242  :   }
; 243  :   /* 0 < splitPoint <= 1 */
; 244  :   if (parameters.splitPoint <= 0 || parameters.splitPoint > 1) {

	movsd	xmm0, QWORD PTR $T1[rbp-240]
	comisd	xmm6, xmm0
	jae	$LN91@ZDICT_opti
	comisd	xmm0, xmm8
	ja	$LN91@ZDICT_opti
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 882  :   ZSTD_pthread_mutex_lock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_EnterCriticalSection

; 883  :   ++best->liveJobs;

	inc	QWORD PTR best$[rbp-208]

; 884  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 727  :         if (pool) {

	test	r13, r13
	je	SHORT $LN33@ZDICT_opti

; 728  :           POOL_add(pool, &FASTCOVER_tryParameters, data);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:FASTCOVER_tryParameters
	mov	rcx, r13
	call	POOL_add

; 729  :         } else {

	jmp	SHORT $LN34@ZDICT_opti
$LN33@ZDICT_opti:

; 730  :           FASTCOVER_tryParameters(data);

	mov	rcx, rdi
	call	FASTCOVER_tryParameters
$LN34@ZDICT_opti:

; 731  :         }
; 732  :         /* Print status */
; 733  :         LOCALDISPLAYUPDATE(displayLevel, 2, "\r%u%%       ",

	cmp	r14d, 2
	jl	SHORT $LN36@ZDICT_opti
	call	QWORD PTR __imp_clock
	sub	eax, DWORD PTR g_time
	cmp	eax, 150				; 00000096H
	jg	SHORT $LN37@ZDICT_opti
	cmp	r14d, 4
	jl	SHORT $LN36@ZDICT_opti
$LN37@ZDICT_opti:
	call	QWORD PTR __imp_clock
	mov	DWORD PTR g_time, eax
	xor	edx, edx
	mov	eax, r15d
	mov	ecx, 2
	div	DWORD PTR kIterations$1$[rsp]
	mov	edi, eax
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294962761
	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN36@ZDICT_opti:

; 734  :                            (unsigned)((iteration * 100) / kIterations));
; 735  :         ++iteration;

	inc	r12d
	add	r15d, 100				; 00000064H
	jmp	SHORT $LN5@ZDICT_opti
$LN91@ZDICT_opti:

; 720  :                                        data->ctx->f, accel)) {
; 721  :           DISPLAYLEVEL(1, "FASTCOVER parameters incorrect\n");

	cmp	r8d, 1
	jl	SHORT $LN32@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962762
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN32@ZDICT_opti:

; 722  :           free(data);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN5@ZDICT_opti:

; 694  :       }
; 695  :       /* Loop through k reusing the same context */
; 696  :       for (k = kMinK; k <= kMaxK; k += kStepSize) {

	add	esi, DWORD PTR kStepSize$1$[rsp]
	mov	edi, DWORD PTR warned$1$[rsp]
	cmp	esi, DWORD PTR kMaxK$1$[rsp]
	jbe	$LL7@ZDICT_opti
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR best$[rbp-208], 0
	mov	esi, edi
	mov	DWORD PTR warned$1$[rsp], edi
	je	SHORT $LN107@ZDICT_opti
	mov	DWORD PTR warned$1$[rsp], edi
	npad	4
$LL106@ZDICT_opti:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR best$[rbp-256]
	lea	rcx, QWORD PTR best$[rbp-216]
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR best$[rbp-208], 0
	jne	SHORT $LL106@ZDICT_opti
$LN107@ZDICT_opti:

; 855  :   }
; 856  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_LeaveCriticalSection
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 263  :     free(ctx->freqs);

	mov	rcx, QWORD PTR ctx$3[rbp-200]
	call	QWORD PTR __imp_free

; 264  :     ctx->freqs = NULL;
; 265  : 
; 266  :     free(ctx->offsets);

	mov	rcx, QWORD PTR ctx$3[rbp-248]
	mov	QWORD PTR ctx$3[rbp-200], 0
	call	QWORD PTR __imp_free

; 677  :                       kIterations);
; 678  :     for (d = kMinD; d <= kMaxD; d += 2) {

	mov	edi, DWORD PTR d$1$[rsp]
	mov	r15, QWORD PTR dictBufferCapacity$GSCopy$1$[rsp]
	add	edi, 2
	mov	DWORD PTR d$1$[rsp], edi
	cmp	edi, DWORD PTR kMaxD$1$[rsp]
	jbe	$LL197@ZDICT_opti

; 736  :       }
; 737  :       COVER_best_wait(&best);
; 738  :       FASTCOVER_ctx_destroy(&ctx);
; 739  :     }
; 740  :     LOCALDISPLAYLEVEL(displayLevel, 2, "\r%79s\r", "");

	cmp	r14d, 2
	jl	SHORT $LN38@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r8, OFFSET FLAT:$SG4294962760
	lea	rdx, OFFSET FLAT:$SG4294962759
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN38@ZDICT_opti:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rbx, QWORD PTR best$[rbp-136]
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 743  :       const size_t dictSize = best.dictSize;

	mov	rdi, QWORD PTR best$[rbp-192]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rbx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 744  :       if (ZSTD_isError(best.compressedSize)) {

	jbe	$LN39@ZDICT_opti
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR best$[rbp-208], 0
	je	SHORT $LN121@ZDICT_opti
	npad	4
$LL120@ZDICT_opti:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR best$[rbp-256]
	lea	rcx, QWORD PTR best$[rbp-216]
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR best$[rbp-208], 0
	jne	SHORT $LL120@ZDICT_opti
$LN121@ZDICT_opti:

; 855  :   }
; 856  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_LeaveCriticalSection

; 867  :   if (best->dict) {

	mov	rcx, QWORD PTR best$[rbp-200]
	test	rcx, rcx
	je	SHORT $LN117@ZDICT_opti

; 868  :     free(best->dict);

	call	QWORD PTR __imp_free
$LN117@ZDICT_opti:

; 869  :   }
; 870  :   ZSTD_pthread_mutex_destroy(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_DeleteCriticalSection
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 747  :         POOL_free(pool);

	mov	rcx, r13
	call	POOL_free

; 748  :         return compressedSize;

	mov	rax, rbx
$LN213@ZDICT_opti:
	movaps	xmm10, XMMWORD PTR [rsp+432]
	movaps	xmm9, XMMWORD PTR [rsp+448]
	movaps	xmm11, XMMWORD PTR [rsp+416]
$LN1@ZDICT_opti:
	movaps	xmm8, XMMWORD PTR [rsp+464]

; 755  :     }
; 756  : 
; 757  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+512]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN39@ZDICT_opti:

; 527  :     fastCoverParams->k = coverParams.k;

	mov	rdx, QWORD PTR parameters$GSCopy$1$[rbp-256]

; 749  :       }
; 750  :       FASTCOVER_convertToFastCoverParams(best.parameters, parameters, f, accel);
; 751  :       memcpy(dictBuffer, best.dict, dictSize);

	mov	r8, rdi

; 534  :     fastCoverParams->zParams = coverParams.zParams;

	movups	xmm1, XMMWORD PTR best$[rbp-152]
	mov	rax, QWORD PTR best$[rbp-184]
	movsd	xmm0, QWORD PTR best$[rbp-168]

; 749  :       }
; 750  :       FASTCOVER_convertToFastCoverParams(best.parameters, parameters, f, accel);
; 751  :       memcpy(dictBuffer, best.dict, dictSize);

	mov	rcx, QWORD PTR dictBuffer$GSCopy$1$[rbp-256]

; 527  :     fastCoverParams->k = coverParams.k;

	mov	DWORD PTR [rdx], eax

; 528  :     fastCoverParams->d = coverParams.d;

	shr	rax, 32					; 00000020H
	mov	DWORD PTR [rdx+4], eax

; 529  :     fastCoverParams->steps = coverParams.steps;

	mov	rax, QWORD PTR best$[rbp-176]
	mov	DWORD PTR [rdx+12], eax

; 530  :     fastCoverParams->nbThreads = coverParams.nbThreads;

	shr	rax, 32					; 00000020H
	mov	DWORD PTR [rdx+16], eax

; 531  :     fastCoverParams->splitPoint = coverParams.splitPoint;
; 532  :     fastCoverParams->f = f;

	mov	eax, DWORD PTR f$1$[rsp]
	mov	DWORD PTR [rdx+8], eax

; 533  :     fastCoverParams->accel = accel;

	mov	eax, DWORD PTR accel$1$[rsp]

; 534  :     fastCoverParams->zParams = coverParams.zParams;

	movsd	QWORD PTR [rdx+44], xmm1
	mov	DWORD PTR [rdx+32], eax

; 535  :     fastCoverParams->shrinkDict = coverParams.shrinkDict;

	mov	eax, DWORD PTR best$[rbp-160]
	psrldq	xmm1, 8
	mov	DWORD PTR [rdx+36], eax
	movsd	QWORD PTR [rdx+24], xmm0
	movd	DWORD PTR [rdx+52], xmm1

; 749  :       }
; 750  :       FASTCOVER_convertToFastCoverParams(best.parameters, parameters, f, accel);
; 751  :       memcpy(dictBuffer, best.dict, dictSize);

	mov	rdx, QWORD PTR best$[rbp-200]
	call	memcpy
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR best$[rbp-208], 0
	je	$LN74@ZDICT_opti
	npad	10
$LL131@ZDICT_opti:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR best$[rbp-256]
	lea	rcx, QWORD PTR best$[rbp-216]
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR best$[rbp-208], 0
	jne	SHORT $LL131@ZDICT_opti
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 754  :       return dictSize;

	jmp	$LN74@ZDICT_opti
$LN142@ZDICT_opti:

; 702  :           LOCALDISPLAYLEVEL(displayLevel, 1, "Failed to allocate parameters\n");

	cmp	r14d, 1
	jl	SHORT $LN30@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962763
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN30@ZDICT_opti:
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR best$[rbp-208], 0
	je	SHORT $LN83@ZDICT_opti
	npad	11
$LL82@ZDICT_opti:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR best$[rbp-256]
	lea	rcx, QWORD PTR best$[rbp-216]
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR best$[rbp-208], 0
	jne	SHORT $LL82@ZDICT_opti
$LN83@ZDICT_opti:

; 855  :   }
; 856  :   ZSTD_pthread_mutex_unlock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_LeaveCriticalSection

; 867  :   if (best->dict) {

	mov	rcx, QWORD PTR best$[rbp-200]
	test	rcx, rcx
	je	SHORT $LN79@ZDICT_opti

; 868  :     free(best->dict);

	call	QWORD PTR __imp_free
$LN79@ZDICT_opti:

; 869  :   }
; 870  :   ZSTD_pthread_mutex_destroy(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_DeleteCriticalSection
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 263  :     free(ctx->freqs);

	mov	rcx, QWORD PTR ctx$3[rbp-200]
	call	QWORD PTR __imp_free

; 264  :     ctx->freqs = NULL;
; 265  : 
; 266  :     free(ctx->offsets);

	mov	rcx, QWORD PTR ctx$3[rbp-248]
	xor	ebx, ebx
	mov	QWORD PTR ctx$3[rbp-200], rbx
	call	QWORD PTR __imp_free

; 703  :           COVER_best_destroy(&best);
; 704  :           FASTCOVER_ctx_destroy(&ctx);
; 705  :           POOL_free(pool);

	mov	rcx, r13

; 267  :     ctx->offsets = NULL;

	mov	QWORD PTR ctx$3[rbp-248], rbx

; 703  :           COVER_best_destroy(&best);
; 704  :           FASTCOVER_ctx_destroy(&ctx);
; 705  :           POOL_free(pool);

	call	POOL_free

; 706  :           return ERROR(memory_allocation);

	lea	rax, QWORD PTR [rbx-64]
	jmp	$LN213@ZDICT_opti
$LN143@ZDICT_opti:

; 685  :           LOCALDISPLAYLEVEL(displayLevel, 1, "Failed to initialize context\n");

	cmp	r14d, 1
	jl	SHORT $LN26@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962765
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN26@ZDICT_opti:
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 852  :   ZSTD_pthread_mutex_lock(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_EnterCriticalSection

; 853  :   while (best->liveJobs != 0) {

	cmp	QWORD PTR best$[rbp-208], 0
	je	SHORT $LN74@ZDICT_opti
$LL73@ZDICT_opti:

; 854  :     ZSTD_pthread_cond_wait(&best->cond, &best->mutex);

	mov	r8d, -1					; ffffffffH
	lea	rdx, QWORD PTR best$[rbp-256]
	lea	rcx, QWORD PTR best$[rbp-216]
	call	QWORD PTR __imp_SleepConditionVariableCS
	cmp	QWORD PTR best$[rbp-208], 0
	jne	SHORT $LL73@ZDICT_opti
$LN74@ZDICT_opti:

; 868  :     free(best->dict);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rcx, QWORD PTR best$[rbp-200]
	test	rcx, rcx
	je	SHORT $LN70@ZDICT_opti
	call	QWORD PTR __imp_free
$LN70@ZDICT_opti:

; 869  :   }
; 870  :   ZSTD_pthread_mutex_destroy(&best->mutex);

	lea	rcx, QWORD PTR best$[rbp-256]
	call	QWORD PTR __imp_DeleteCriticalSection
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 687  :           POOL_free(pool);

	mov	rcx, r13
	call	POOL_free

; 688  :           return initVal;

	mov	rax, rdi
	jmp	$LN213@ZDICT_opti
$LN15@ZDICT_opti:

; 650  :       LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect k\n");

	cmp	r14d, r12d
	jl	SHORT $LN10@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962770
	jmp	SHORT $LN216@ZDICT_opti
$LN12@ZDICT_opti:

; 646  :       LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect accel\n");

	cmp	r14d, r12d
	jl	SHORT $LN10@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962771
	jmp	SHORT $LN216@ZDICT_opti
$LN9@ZDICT_opti:

; 642  :       LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect splitPoint\n");

	cmp	r14d, r12d
	jl	SHORT $LN10@ZDICT_opti
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962772
$LN216@ZDICT_opti:

; 643  :       return ERROR(parameter_outOfBound);

	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN10@ZDICT_opti:
	mov	rax, -42				; ffffffffffffffd6H
	jmp	$LN1@ZDICT_opti
ZDICT_optimizeTrainFromBuffer_fastCover ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash6 PROC

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash6Ptr PROC

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 73   : static size_t ZSTD_hash6Ptr(const void* p, U32 h) { return ZSTD_hash6(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash6Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash8 PROC

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash8Ptr PROC

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 77   : static size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash8Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
p$ = 8
h$ = 16
d$ = 24
FASTCOVER_hashPtrToIndex PROC

; 83   : static size_t FASTCOVER_hashPtrToIndex(const void* p, U32 h, unsigned d) {

	mov	r9, QWORD PTR [rcx]
	mov	eax, 1
	mov	ecx, edx
	mov	r10d, 64				; 00000040H
	shl	eax, cl
	sub	r10d, edx
	dec	eax

; 84   :   if (d == 6) {

	mov	ecx, r10d
	movsxd	rdx, eax

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 84   :   if (d == 6) {

	cmp	r8d, 6
	je	SHORT $LN12@FASTCOVER_

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
$LN12@FASTCOVER_:

; 85   :     return ZSTD_hash6Ptr(p, h) & ((1 << h) - 1);
; 86   :   }
; 87   :   return ZSTD_hash8Ptr(p, h) & ((1 << h) - 1);
; 88   : }

	imul	rax, r9
	shr	rax, cl
	and	rax, rdx
	ret	0
FASTCOVER_hashPtrToIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
activeSegment$ = 0
$T1 = 80
ctx$ = 88
freqs$ = 96
f$1$ = 104
begin$ = 104
tv793 = 112
end$ = 112
parameters$ = 120
segmentFreqs$ = 128
FASTCOVER_selectSegment PROC

; 150  :                                               U16* segmentFreqs) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 16

; 151  :   /* Constants */
; 152  :   const U32 k = parameters.k;
; 153  :   const U32 d = parameters.d;

	mov	rax, QWORD PTR parameters$[rsp]
	mov	rdi, rcx

; 154  :   const U32 f = ctx->f;
; 155  :   const U32 dmersInK = k - d + 1;
; 156  : 
; 157  :   /* Try each segment (activeSegment) and save the best (bestSegment) */
; 158  :   COVER_segment_t bestSegment = {0, 0, 0};
; 159  :   COVER_segment_t activeSegment;
; 160  : 
; 161  :   /* Reset the activeDmers in the segment */
; 162  :   /* The activeSegment starts at the beginning of the epoch. */
; 163  :   activeSegment.begin = begin;
; 164  :   activeSegment.end = begin;
; 165  :   activeSegment.score = 0;

	mov	r14d, DWORD PTR end$[rsp]
	mov	r15, r8
	mov	ecx, DWORD PTR [rdx+68]
	mov	rsi, rdx
	mov	DWORD PTR f$1$[rsp], ecx
	mov	r11d, r9d
	mov	ebp, DWORD PTR [rax+4]
	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r10d, DWORD PTR [rax]
	mov	r13, -3523014627327384477		; cf1bbcdcb7a56463H
	xor	eax, eax
	mov	DWORD PTR activeSegment$[rsp], r9d
	mov	QWORD PTR [rdi], rax
	mov	r8d, eax
	mov	DWORD PTR [rdi+8], eax
	sub	r10d, ebp
	mov	eax, 1
	lea	r12d, QWORD PTR [rax+63]
	cmp	r9d, r14d

; 166  : 
; 167  :   /* Slide the activeSegment through the whole epoch.
; 168  :    * Save the best segment in bestSegment.
; 169  :    */
; 170  :   while (activeSegment.end < end) {

	jae	$LN66@FASTCOVER_
	shl	eax, cl

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	ebx, r12d
	movsxd	r13, eax
	sub	ebx, ecx
	lea	eax, DWORD PTR [r10+2]
	dec	r13
	mov	r10, QWORD PTR segmentFreqs$[rsp]
	mov	r12d, eax
$LL2@FASTCOVER_:

; 171  :     /* Get hash value of current dmer */
; 172  :     const size_t idx = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.end, f, d);

	mov	rax, QWORD PTR [rsi]
	mov	ecx, r11d
	mov	rdx, QWORD PTR [rcx+rax]

; 84   :   if (d == 6) {

	mov	ecx, ebx

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 84   :   if (d == 6) {

	cmp	ebp, 6
	je	SHORT $LN72@FASTCOVER_

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
$LN72@FASTCOVER_:

; 173  : 
; 174  :     /* Add frequency of this index to score if this is the first occurrence of index in active segment */
; 175  :     if (segmentFreqs[idx] == 0) {

	imul	rdx, rax
	mov	rax, r13
	shr	rdx, cl
	and	rax, rdx
	movzx	ecx, WORD PTR [r10+rax*2]
	test	cx, cx
	jne	SHORT $LN9@FASTCOVER_

; 176  :       activeSegment.score += freqs[idx];

	add	r8d, DWORD PTR [r15+rax*4]
$LN9@FASTCOVER_:

; 177  :     }
; 178  :     /* Increment end of segment and segmentFreqs*/
; 179  :     activeSegment.end += 1;

	inc	r11d

; 180  :     segmentFreqs[idx] += 1;

	inc	cx
	mov	WORD PTR [r10+rax*2], cx
	mov	eax, r11d
	sub	eax, r9d
	mov	DWORD PTR activeSegment$[rsp+4], r11d

; 181  :     /* If the window is now too large, drop the first position */
; 182  :     if (activeSegment.end - activeSegment.begin == dmersInK + 1) {

	cmp	eax, r12d
	jne	SHORT $LN10@FASTCOVER_

; 183  :       /* Get hash value of the dmer to be eliminated from active segment */
; 184  :       const size_t delIndex = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.begin, f, d);

	mov	rax, QWORD PTR [rsi]
	mov	ecx, r9d
	mov	rdx, QWORD PTR [rcx+rax]

; 84   :   if (d == 6) {

	mov	ecx, ebx

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 84   :   if (d == 6) {

	cmp	ebp, 6
	je	SHORT $LN73@FASTCOVER_

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
$LN73@FASTCOVER_:

; 185  :       segmentFreqs[delIndex] -= 1;

	imul	rdx, rax
	mov	rax, r13
	shr	rdx, cl
	mov	ecx, 65535				; 0000ffffH
	and	rax, rdx
	add	WORD PTR [r10+rax*2], cx

; 186  :       /* Subtract frequency of this index from score if this is the last occurrence of this index in active segment */
; 187  :       if (segmentFreqs[delIndex] == 0) {

	jne	SHORT $LN11@FASTCOVER_

; 188  :         activeSegment.score -= freqs[delIndex];

	sub	r8d, DWORD PTR [r15+rax*4]
$LN11@FASTCOVER_:

; 189  :       }
; 190  :       /* Increment start of segment */
; 191  :       activeSegment.begin += 1;

	inc	r9d
	mov	DWORD PTR activeSegment$[rsp], r9d
$LN10@FASTCOVER_:

; 192  :     }
; 193  : 
; 194  :     /* If this segment is the best so far save it */
; 195  :     if (activeSegment.score > bestSegment.score) {

	cmp	r8d, DWORD PTR [rdi+8]
	jbe	SHORT $LN12@FASTCOVER_

; 196  :       bestSegment = activeSegment;

	movsd	xmm0, QWORD PTR activeSegment$[rsp]
	movsd	QWORD PTR [rdi], xmm0
	mov	DWORD PTR [rdi+8], r8d
$LN12@FASTCOVER_:

; 166  : 
; 167  :   /* Slide the activeSegment through the whole epoch.
; 168  :    * Save the best segment in bestSegment.
; 169  :    */
; 170  :   while (activeSegment.end < end) {

	cmp	r11d, r14d
	jb	$LL2@FASTCOVER_

; 197  :     }
; 198  :   }
; 199  : 
; 200  :   /* Zero out rest of segmentFreqs array */
; 201  :   while (activeSegment.begin < end) {

	mov	r12d, 64				; 00000040H
	cmp	r9d, r14d
	jae	SHORT $LN71@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	sub	r14d, r9d
	mov	r8d, r9d
	mov	r9d, r14d
	mov	r15, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r12, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r11d, 65535				; 0000ffffH
	npad	2
$LL4@FASTCOVER_:

; 202  :     const size_t delIndex = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.begin, f, d);

	mov	rax, QWORD PTR [rsi]

; 84   :   if (d == 6) {

	mov	ecx, ebx

; 202  :     const size_t delIndex = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.begin, f, d);

	mov	rdx, QWORD PTR [r8+rax]

; 84   :   if (d == 6) {

	cmp	ebp, 6
	jne	SHORT $LN37@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rdx, r15

; 85   :     return ZSTD_hash6Ptr(p, h) & ((1 << h) - 1);

	jmp	SHORT $LN74@FASTCOVER_
$LN37@FASTCOVER_:

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	imul	rdx, r12
$LN74@FASTCOVER_:

; 203  :     segmentFreqs[delIndex] -= 1;

	shr	rdx, cl
	mov	rax, r13
	and	rax, rdx

; 204  :     activeSegment.begin += 1;

	inc	r8
	add	WORD PTR [r10+rax*2], r11w
	sub	r9, 1
	jne	SHORT $LL4@FASTCOVER_
	mov	r15, QWORD PTR freqs$[rsp]
	lea	r12d, QWORD PTR [r9+64]
$LN71@FASTCOVER_:

; 205  :   }
; 206  : 
; 207  :   {
; 208  :     /*  Zero the frequency of hash value of each dmer covered by the chosen segment. */
; 209  :     U32 pos;
; 210  :     for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {

	mov	ecx, DWORD PTR f$1$[rsp]
	mov	r13, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	eax, 1
$LN66@FASTCOVER_:
	mov	edx, DWORD PTR [rdi]
	mov	r9d, DWORD PTR [rdi+4]
	cmp	edx, r9d
	je	SHORT $LN70@FASTCOVER_
	shl	eax, cl

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	sub	r12d, ecx
	movsxd	r8, eax
	dec	r8
	xor	r10d, r10d
	npad	2
$LL8@FASTCOVER_:

; 211  :       const size_t i = FASTCOVER_hashPtrToIndex(ctx->samples + pos, f, d);

	mov	rax, QWORD PTR [rsi]
	mov	ecx, edx
	mov	rax, QWORD PTR [rcx+rax]

; 84   :   if (d == 6) {

	mov	ecx, r12d
	cmp	ebp, 6
	jne	SHORT $LN48@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, rbx

; 85   :     return ZSTD_hash6Ptr(p, h) & ((1 << h) - 1);

	jmp	SHORT $LN75@FASTCOVER_
$LN48@FASTCOVER_:

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	imul	rax, r13
$LN75@FASTCOVER_:

; 212  :       freqs[i] = 0;

	shr	rax, cl
	inc	edx
	and	rax, r8
	mov	DWORD PTR [r15+rax*4], r10d
	cmp	edx, r9d
	jne	SHORT $LL8@FASTCOVER_
$LN70@FASTCOVER_:

; 213  :     }
; 214  :   }
; 215  : 
; 216  :   return bestSegment;
; 217  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rdi
	add	rsp, 16
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
FASTCOVER_selectSegment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
parameters$ = 8
maxDictSize$ = 16
f$ = 24
accel$ = 32
FASTCOVER_checkParameters PROC

; 223  :   /* k, d, and f are required parameters */
; 224  :   if (parameters.d == 0 || parameters.k == 0) {

	mov	r11d, DWORD PTR [rcx+4]
	test	r11d, r11d
	je	SHORT $LN3@FASTCOVER_
	mov	r10d, DWORD PTR [rcx]
	test	r10d, r10d
	je	SHORT $LN3@FASTCOVER_

; 226  :   }
; 227  :   /* d has to be 6 or 8 */
; 228  :   if (parameters.d != 6 && parameters.d != 8) {

	lea	eax, DWORD PTR [r11-6]
	test	eax, -3					; fffffffdH
	jne	SHORT $LN3@FASTCOVER_

; 229  :     return 0;
; 230  :   }
; 231  :   /* k <= maxDictSize */
; 232  :   if (parameters.k > maxDictSize) {

	cmp	r10, rdx
	ja	SHORT $LN3@FASTCOVER_

; 233  :     return 0;
; 234  :   }
; 235  :   /* d <= k */
; 236  :   if (parameters.d > parameters.k) {

	cmp	r11d, r10d
	ja	SHORT $LN3@FASTCOVER_

; 237  :     return 0;
; 238  :   }
; 239  :   /* 0 < f <= FASTCOVER_MAX_F*/
; 240  :   if (f > FASTCOVER_MAX_F || f == 0) {

	lea	eax, DWORD PTR [r8-1]
	cmp	eax, 30
	ja	SHORT $LN3@FASTCOVER_

; 241  :     return 0;
; 242  :   }
; 243  :   /* 0 < splitPoint <= 1 */
; 244  :   if (parameters.splitPoint <= 0 || parameters.splitPoint > 1) {

	movsd	xmm1, QWORD PTR [rcx+16]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	jae	SHORT $LN3@FASTCOVER_
	comisd	xmm1, QWORD PTR __real@3ff0000000000000
	ja	SHORT $LN3@FASTCOVER_

; 245  :     return 0;
; 246  :   }
; 247  :   /* 0 < accel <= 10 */
; 248  :   if (accel > 10 || accel == 0) {

	lea	eax, DWORD PTR [r9-1]
	cmp	eax, 9
	ja	SHORT $LN3@FASTCOVER_

; 249  :     return 0;
; 250  :   }
; 251  :   return 1;

	mov	eax, 1

; 252  : }

	ret	0
$LN3@FASTCOVER_:

; 225  :     return 0;

	xor	eax, eax

; 252  : }

	ret	0
FASTCOVER_checkParameters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
ctx$ = 48
FASTCOVER_ctx_destroy PROC

; 261  :     if (!ctx) return;

	test	rcx, rcx
	je	SHORT $LN4@FASTCOVER_
	push	rbx
	sub	rsp, 32					; 00000020H

; 260  : {

	mov	rbx, rcx

; 262  : 
; 263  :     free(ctx->freqs);

	mov	rcx, QWORD PTR [rcx+56]
	call	QWORD PTR __imp_free

; 264  :     ctx->freqs = NULL;
; 265  : 
; 266  :     free(ctx->offsets);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx+56], 0
	call	QWORD PTR __imp_free

; 267  :     ctx->offsets = NULL;

	mov	QWORD PTR [rbx+8], 0

; 268  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN4@FASTCOVER_:
	ret	0
FASTCOVER_ctx_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
freqs$ = 48
f$1$ = 56
ctx$ = 56
FASTCOVER_computeFrequency PROC

; 276  : {

	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r15

; 277  :     const unsigned f = ctx->f;
; 278  :     const unsigned d = ctx->d;

	mov	edi, DWORD PTR [rdx+64]

; 279  :     const unsigned skip = ctx->accelParams.skip;
; 280  :     const unsigned readLength = MAX(d, 8);

	mov	eax, 8
	mov	r15d, DWORD PTR [rdx+68]
	cmp	edi, eax
	mov	r12d, DWORD PTR [rdx+76]
	mov	r8, rdx
	cmova	eax, edi
	mov	DWORD PTR f$1$[rsp], r15d

; 281  :     size_t i;
; 282  :     assert(ctx->nbTrainSamples >= 5);
; 283  :     assert(ctx->nbTrainSamples <= ctx->nbSamples);
; 284  :     for (i = 0; i < ctx->nbTrainSamples; i++) {

	xor	ebx, ebx
	mov	rbp, rcx
	cmp	QWORD PTR [rdx+32], rbx
	jbe	$LN3@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	QWORD PTR [rsp+48], rsi
	mov	r9d, 64					; 00000040H
	mov	QWORD PTR [rsp+64], r13
	sub	r9d, r15d
	mov	QWORD PTR [rsp+72], r14
	mov	r13, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r14d, eax
	npad	7
$LL4@FASTCOVER_:

; 285  :         size_t start = ctx->offsets[i];  /* start of current dmer */

	mov	rax, QWORD PTR [r8+8]

; 286  :         size_t const currSampleEnd = ctx->offsets[i+1];

	mov	r11, QWORD PTR [rax+rbx*8+8]
	mov	rdx, QWORD PTR [rax+rbx*8]

; 287  :         while (start + readLength <= currSampleEnd) {

	lea	rax, QWORD PTR [r14+rdx]
	cmp	rax, r11
	ja	SHORT $LN2@FASTCOVER_
	mov	ecx, r15d
	mov	eax, 1
	shl	eax, cl
	mov	r15, -3523014627327384477		; cf1bbcdcb7a56463H
	movsxd	r10, eax
	npad	3
$LL5@FASTCOVER_:

; 288  :             const size_t dmerIndex = FASTCOVER_hashPtrToIndex(ctx->samples + start, f, d);

	mov	rax, QWORD PTR [r8]

; 84   :   if (d == 6) {

	mov	ecx, r9d

; 288  :             const size_t dmerIndex = FASTCOVER_hashPtrToIndex(ctx->samples + start, f, d);

	mov	rax, QWORD PTR [rdx+rax]

; 84   :   if (d == 6) {

	cmp	edi, 6
	jne	SHORT $LN9@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, r13

; 85   :     return ZSTD_hash6Ptr(p, h) & ((1 << h) - 1);

	jmp	SHORT $LN28@FASTCOVER_
$LN9@FASTCOVER_:

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	imul	rax, r15
$LN28@FASTCOVER_:

; 289  :             freqs[dmerIndex]++;

	shr	rax, cl

; 290  :             start = start + skip + 1;

	inc	rdx
	add	rdx, r12
	lea	rcx, QWORD PTR [r10-1]
	and	rcx, rax
	lea	rax, QWORD PTR [r14+rdx]
	inc	DWORD PTR [rbp+rcx*4]
	cmp	rax, r11
	jbe	SHORT $LL5@FASTCOVER_
	mov	r15d, DWORD PTR f$1$[rsp]
$LN2@FASTCOVER_:

; 281  :     size_t i;
; 282  :     assert(ctx->nbTrainSamples >= 5);
; 283  :     assert(ctx->nbTrainSamples <= ctx->nbSamples);
; 284  :     for (i = 0; i < ctx->nbTrainSamples; i++) {

	inc	rbx
	cmp	rbx, QWORD PTR [r8+32]
	jb	SHORT $LL4@FASTCOVER_
	mov	r14, QWORD PTR [rsp+72]
	mov	r13, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+48]
$LN3@FASTCOVER_:

; 291  :         }
; 292  :     }
; 293  : }

	pop	r15
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
FASTCOVER_computeFrequency ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
testSamplesSize$1$ = 32
ctx$ = 96
skip$1$ = 104
samplesBuffer$ = 104
samplesSizes$ = 112
nbSamples$ = 120
f$1$ = 128
d$ = 128
trainingSamplesSize$1$ = 136
splitPoint$ = 136
f$ = 144
accelParams$ = 152
FASTCOVER_ctx_init PROC

; 309  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+16], rdx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	esi, r9d

; 310  :     const BYTE* const samples = (const BYTE*)samplesBuffer;
; 311  :     const size_t totalSamplesSize = COVER_sum(samplesSizes, nbSamples);

	mov	rcx, r8
	mov	edx, r9d
	mov	r12, r8
	call	COVER_sum

; 312  :     /* Split samples into testing and training sets */
; 313  :     const unsigned nbTrainSamples = splitPoint < 1.0 ? (unsigned)((double)nbSamples * splitPoint) : nbSamples;

	movsd	xmm4, QWORD PTR __real@3ff0000000000000
	mov	r14, rax
	movsd	xmm3, QWORD PTR splitPoint$[rsp]
	comisd	xmm4, xmm3
	jbe	SHORT $LN20@FASTCOVER_
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rsi
	mulsd	xmm0, xmm3
	cvttsd2si rdi, xmm0
	jmp	SHORT $LN21@FASTCOVER_
$LN20@FASTCOVER_:
	mov	edi, esi
$LN21@FASTCOVER_:

; 314  :     const unsigned nbTestSamples = splitPoint < 1.0 ? nbSamples - nbTrainSamples : nbSamples;
; 315  :     const size_t trainingSamplesSize = splitPoint < 1.0 ? COVER_sum(samplesSizes, nbTrainSamples) : totalSamplesSize;

	mov	ebp, esi
	sub	ebp, edi
	comisd	xmm4, xmm3
	cmovbe	ebp, esi
	jbe	SHORT $LN24@FASTCOVER_
	mov	edx, edi
	mov	rcx, r12
	call	COVER_sum
	mov	QWORD PTR trainingSamplesSize$1$[rsp], rax
	jmp	SHORT $LN25@FASTCOVER_
$LN24@FASTCOVER_:
	mov	QWORD PTR trainingSamplesSize$1$[rsp], r14
$LN25@FASTCOVER_:

; 316  :     const size_t testSamplesSize = splitPoint < 1.0 ? COVER_sum(samplesSizes + nbTrainSamples, nbTestSamples) : totalSamplesSize;

	comisd	xmm4, xmm3
	jbe	SHORT $LN26@FASTCOVER_
	mov	eax, edi
	mov	edx, ebp
	lea	rcx, QWORD PTR [r12+rax*8]
	call	COVER_sum
	mov	QWORD PTR testSamplesSize$1$[rsp], rax
	jmp	SHORT $LN27@FASTCOVER_
$LN26@FASTCOVER_:
	mov	QWORD PTR testSamplesSize$1$[rsp], r14
$LN27@FASTCOVER_:

; 317  : 
; 318  :     /* Checks */
; 319  :     if (totalSamplesSize < MAX(d, sizeof(U64)) ||

	mov	r15d, DWORD PTR d$[rsp]
	mov	r13d, 8
	mov	eax, r15d
	cmp	r15d, r13d
	ja	SHORT $LN29@FASTCOVER_
	mov	eax, r13d
$LN29@FASTCOVER_:
	cmp	r14, rax
	jb	$LN6@FASTCOVER_
	mov	eax, -1					; ffffffffH
	cmp	r14, rax
	jae	$LN6@FASTCOVER_

; 324  :     }
; 325  : 
; 326  :     /* Check if there are at least 5 training samples */
; 327  :     if (nbTrainSamples < 5) {

	cmp	edi, 5
	jae	SHORT $LN8@FASTCOVER_

; 328  :         DISPLAYLEVEL(1, "Total number of training samples is %u and is invalid\n", nbTrainSamples);

	cmp	DWORD PTR g_displayLevel, 1
	jl	$LN7@FASTCOVER_
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294962791
	mov	rcx, rax
	call	fprintf
	jmp	$LN72@FASTCOVER_
$LN8@FASTCOVER_:

; 329  :         return ERROR(srcSize_wrong);
; 330  :     }
; 331  : 
; 332  :     /* Check if there's testing sample */
; 333  :     if (nbTestSamples < 1) {

	cmp	ebp, 1
	jae	SHORT $LN10@FASTCOVER_

; 334  :         DISPLAYLEVEL(1, "Total number of testing samples is %u and is invalid.\n", nbTestSamples);

	cmp	DWORD PTR g_displayLevel, 1
	jl	$LN7@FASTCOVER_
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, ebp
	lea	rdx, OFFSET FLAT:$SG4294962790
	mov	rcx, rax
	call	fprintf
	jmp	$LN72@FASTCOVER_
$LN10@FASTCOVER_:

; 335  :         return ERROR(srcSize_wrong);
; 336  :     }
; 337  : 
; 338  :     /* Zero the context */
; 339  :     memset(ctx, 0, sizeof(*ctx));
; 340  :     DISPLAYLEVEL(2, "Training on %u samples of total size %u\n", nbTrainSamples,

	cmp	DWORD PTR g_displayLevel, 2
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
	movups	XMMWORD PTR [rbx+32], xmm0
	movups	XMMWORD PTR [rbx+48], xmm0
	movups	XMMWORD PTR [rbx+64], xmm0
	jl	SHORT $LN71@FASTCOVER_
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r14, QWORD PTR trainingSamplesSize$1$[rsp]
	lea	rdx, OFFSET FLAT:$SG4294962789
	mov	rcx, rax
	mov	r9d, r14d
	mov	r8d, edi
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 341  :                     (unsigned)trainingSamplesSize);
; 342  :     DISPLAYLEVEL(2, "Testing on %u samples of total size %u\n", nbTestSamples,

	cmp	DWORD PTR g_displayLevel, 2
	jl	SHORT $LN13@FASTCOVER_
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR testSamplesSize$1$[rsp]
	lea	rdx, OFFSET FLAT:$SG4294962788
	mov	rcx, rax
	mov	r8d, ebp
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
	jmp	SHORT $LN13@FASTCOVER_
$LN71@FASTCOVER_:

; 335  :         return ERROR(srcSize_wrong);
; 336  :     }
; 337  : 
; 338  :     /* Zero the context */
; 339  :     memset(ctx, 0, sizeof(*ctx));
; 340  :     DISPLAYLEVEL(2, "Training on %u samples of total size %u\n", nbTrainSamples,

	mov	r14, QWORD PTR trainingSamplesSize$1$[rsp]
$LN13@FASTCOVER_:

; 343  :                     (unsigned)testSamplesSize);
; 344  : 
; 345  :     ctx->samples = samples;

	mov	rax, QWORD PTR samplesBuffer$[rsp]
	mov	QWORD PTR [rbx], rax

; 346  :     ctx->samplesSizes = samplesSizes;
; 347  :     ctx->nbSamples = nbSamples;
; 348  :     ctx->nbTrainSamples = nbTrainSamples;

	mov	eax, edi
	mov	QWORD PTR [rbx+32], rax

; 349  :     ctx->nbTestSamples = nbTestSamples;

	mov	eax, ebp
	mov	QWORD PTR [rbx+40], rax

; 350  :     ctx->nbDmers = trainingSamplesSize - MAX(d, sizeof(U64)) + 1;

	mov	rax, r15
	mov	QWORD PTR [rbx+16], r12
	mov	QWORD PTR [rbx+24], rsi
	cmp	r15d, r13d
	ja	SHORT $LN31@FASTCOVER_
	mov	rax, r13
$LN31@FASTCOVER_:

; 351  :     ctx->d = d;
; 352  :     ctx->f = f;

	mov	ebp, DWORD PTR f$[rsp]

; 353  :     ctx->accelParams = accelParams;
; 354  : 
; 355  :     /* The offsets of each file */
; 356  :     ctx->offsets = (size_t*)calloc((nbSamples + 1), sizeof(size_t));

	lea	ecx, DWORD PTR [rsi+1]
	sub	r14, rax
	mov	DWORD PTR [rbx+64], r15d
	mov	rax, QWORD PTR accelParams$[rsp]
	inc	r14
	mov	rdx, r13
	mov	QWORD PTR [rbx+48], r14
	mov	DWORD PTR [rbx+68], ebp
	mov	QWORD PTR [rbx+72], rax
	call	QWORD PTR __imp_calloc
	mov	QWORD PTR [rbx+8], rax

; 357  :     if (ctx->offsets == NULL) {

	test	rax, rax
	jne	SHORT $LN14@FASTCOVER_

; 358  :         DISPLAYLEVEL(1, "Failed to allocate scratch buffers \n");

	cmp	DWORD PTR g_displayLevel, 1
	jl	SHORT $LN15@FASTCOVER_
	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962787
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN15@FASTCOVER_:

; 263  :     free(ctx->freqs);

	mov	rcx, QWORD PTR [rbx+56]
	call	QWORD PTR __imp_free

; 264  :     ctx->freqs = NULL;

	xor	edi, edi
$LN74@FASTCOVER_:

; 384  : }

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx+56], rdi
	call	QWORD PTR __imp_free
	mov	rax, -64				; ffffffffffffffc0H
	mov	QWORD PTR [rbx+8], rdi
	jmp	$LN1@FASTCOVER_
$LN14@FASTCOVER_:

; 359  :         FASTCOVER_ctx_destroy(ctx);
; 360  :         return ERROR(memory_allocation);
; 361  :     }
; 362  : 
; 363  :     /* Fill offsets from the samplesSizes */
; 364  :     {   U32 i;
; 365  :         ctx->offsets[0] = 0;

	xor	edi, edi
	mov	r10d, 1
	mov	QWORD PTR [rax], rdi

; 366  :         assert(nbSamples >= 5);
; 367  :         for (i = 1; i <= nbSamples; ++i) {

	cmp	esi, r10d
	jb	SHORT $LN3@FASTCOVER_
	npad	9
$LL62@FASTCOVER_:

; 368  :             ctx->offsets[i] = ctx->offsets[i - 1] + samplesSizes[i - 1];

	mov	r9, QWORD PTR [rbx+8]
	lea	eax, DWORD PTR [r10-1]
	mov	rdx, QWORD PTR [r12+rax*8]
	add	rdx, QWORD PTR [r9+rax*8]
	mov	eax, r10d
	inc	r10d
	mov	QWORD PTR [r9+rax*8], rdx
	cmp	r10d, esi
	jbe	SHORT $LL62@FASTCOVER_
$LN3@FASTCOVER_:

; 369  :         }
; 370  :     }
; 371  : 
; 372  :     /* Initialize frequency array of size 2^f */
; 373  :     ctx->freqs = (U32*)calloc(((U64)1 << f), sizeof(U32));

	mov	ecx, ebp
	mov	eax, 1
	shl	rax, cl
	mov	edx, 4
	mov	rcx, rax
	call	QWORD PTR __imp_calloc
	mov	QWORD PTR [rbx+56], rax
	mov	r9, rax

; 374  :     if (ctx->freqs == NULL) {

	test	rax, rax
	jne	SHORT $LN16@FASTCOVER_

; 375  :         DISPLAYLEVEL(1, "Failed to allocate frequency table \n");

	cmp	DWORD PTR g_displayLevel, 1
	jl	SHORT $LN17@FASTCOVER_
	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962786
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN17@FASTCOVER_:

; 263  :     free(ctx->freqs);

	mov	rcx, QWORD PTR [rbx+56]
	call	QWORD PTR __imp_free

; 376  :         FASTCOVER_ctx_destroy(ctx);
; 377  :         return ERROR(memory_allocation);

	jmp	$LN74@FASTCOVER_
$LN16@FASTCOVER_:

; 378  :     }
; 379  : 
; 380  :     DISPLAYLEVEL(2, "Computing frequencies\n");

	cmp	DWORD PTR g_displayLevel, 2
	jl	SHORT $LN18@FASTCOVER_
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294962785
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
	mov	r9, QWORD PTR [rbx+56]
$LN18@FASTCOVER_:

; 278  :     const unsigned d = ctx->d;

	mov	r14d, DWORD PTR [rbx+64]

; 279  :     const unsigned skip = ctx->accelParams.skip;
; 280  :     const unsigned readLength = MAX(d, 8);

	cmp	r14d, r13d
	mov	r12d, DWORD PTR [rbx+68]
	mov	edx, DWORD PTR [rbx+76]
	cmova	r13d, r14d
	mov	DWORD PTR f$1$[rsp], r12d
	mov	DWORD PTR skip$1$[rsp], edx

; 281  :     size_t i;
; 282  :     assert(ctx->nbTrainSamples >= 5);
; 283  :     assert(ctx->nbTrainSamples <= ctx->nbSamples);
; 284  :     for (i = 0; i < ctx->nbTrainSamples; i++) {

	cmp	QWORD PTR [rbx+32], rdi
	jbe	$LN40@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r10d, 64				; 00000040H
	mov	r15d, r13d
	sub	r10d, r12d
	mov	r13, -3523014627193847808		; cf1bbcdcbf9b0000H
$LL41@FASTCOVER_:

; 285  :         size_t start = ctx->offsets[i];  /* start of current dmer */

	mov	rax, QWORD PTR [rbx+8]

; 286  :         size_t const currSampleEnd = ctx->offsets[i+1];

	mov	rsi, QWORD PTR [rax+rdi*8+8]
	mov	r8, QWORD PTR [rax+rdi*8]

; 287  :         while (start + readLength <= currSampleEnd) {

	lea	rax, QWORD PTR [r15+r8]
	cmp	rax, rsi
	ja	SHORT $LN39@FASTCOVER_
	mov	ecx, r12d
	mov	ebp, edx
	mov	eax, 1
	mov	r12, -3523014627327384477		; cf1bbcdcb7a56463H
	shl	eax, cl
	movsxd	r11, eax
	npad	1
$LL42@FASTCOVER_:

; 288  :             const size_t dmerIndex = FASTCOVER_hashPtrToIndex(ctx->samples + start, f, d);

	mov	rax, QWORD PTR [rbx]

; 84   :   if (d == 6) {

	mov	ecx, r10d

; 288  :             const size_t dmerIndex = FASTCOVER_hashPtrToIndex(ctx->samples + start, f, d);

	mov	rdx, QWORD PTR [r8+rax]

; 84   :   if (d == 6) {

	cmp	r14d, 6
	jne	SHORT $LN46@FASTCOVER_

; 72   : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rdx, r13

; 85   :     return ZSTD_hash6Ptr(p, h) & ((1 << h) - 1);

	jmp	SHORT $LN73@FASTCOVER_
$LN46@FASTCOVER_:

; 76   : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	imul	rdx, r12
$LN73@FASTCOVER_:

; 289  :             freqs[dmerIndex]++;

	shr	rdx, cl
	lea	rax, QWORD PTR [r11-1]
	and	rax, rdx

; 290  :             start = start + skip + 1;

	inc	r8
	add	r8, rbp
	inc	DWORD PTR [r9+rax*4]
	lea	rax, QWORD PTR [r15+r8]
	cmp	rax, rsi
	jbe	SHORT $LL42@FASTCOVER_
	mov	r12d, DWORD PTR f$1$[rsp]
	mov	edx, DWORD PTR skip$1$[rsp]
$LN39@FASTCOVER_:

; 281  :     size_t i;
; 282  :     assert(ctx->nbTrainSamples >= 5);
; 283  :     assert(ctx->nbTrainSamples <= ctx->nbSamples);
; 284  :     for (i = 0; i < ctx->nbTrainSamples; i++) {

	inc	rdi
	cmp	rdi, QWORD PTR [rbx+32]
	jb	SHORT $LL41@FASTCOVER_
$LN40@FASTCOVER_:

; 381  :     FASTCOVER_computeFrequency(ctx->freqs, ctx);
; 382  : 
; 383  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FASTCOVER_
$LN6@FASTCOVER_:

; 320  :         totalSamplesSize >= (size_t)FASTCOVER_MAX_SAMPLES_SIZE) {
; 321  :         DISPLAYLEVEL(1, "Total samples size is too large (%u MB), maximum size is %u MB\n",

	cmp	DWORD PTR g_displayLevel, 1
	jl	SHORT $LN7@FASTCOVER_
	mov	ecx, 2
	shr	r14, 20
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 4095				; 00000fffH
	lea	rdx, OFFSET FLAT:$SG4294962792
	mov	rcx, rax
	mov	r8d, r14d
	call	fprintf
$LN72@FASTCOVER_:

; 322  :                     (unsigned)(totalSamplesSize >> 20), (FASTCOVER_MAX_SAMPLES_SIZE >> 20));
; 323  :         return ERROR(srcSize_wrong);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN7@FASTCOVER_:
	mov	rax, -72				; ffffffffffffffb8H
$LN1@FASTCOVER_:

; 384  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
FASTCOVER_ctx_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
segment$1 = 64
$T2 = 80
$T3 = 96
ctx$ = 208
freqs$ = 216
dictBuffer$ = 224
dictBufferCapacity$ = 232
epochs$4 = 240
parameters$ = 240
$T5 = 240
segmentFreqs$ = 248
FASTCOVER_buildDictionary PROC

; 396  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H

; 400  :   const COVER_epoch_info_t epochs = COVER_computeEpochs(

	mov	r12, QWORD PTR parameters$[rsp]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	xor	edx, edx
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 400  :   const COVER_epoch_info_t epochs = COVER_computeEpochs(

	mov	ebx, DWORD PTR [rcx+48]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	mov	eax, r9d
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 396  : {

	mov	r15, r9
	mov	r13, rcx

; 397  :   BYTE *const dict = (BYTE *)dictBuffer;
; 398  :   size_t tail = dictBufferCapacity;

	mov	rsi, r9

; 400  :   const COVER_epoch_info_t epochs = COVER_computeEpochs(

	mov	r10d, DWORD PTR [r12]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 651  :   epochs.num = MAX(1, maxDictSize / k / passes);

	div	r10d
	lea	r11d, DWORD PTR [r10+r10*4]
	mov	r8d, eax
	add	r11d, r11d
	mov	eax, 1
	cmp	r8d, eax
	cmovb	r8d, eax

; 652  :   epochs.size = nbDmers / epochs.num;

	xor	edx, edx
	mov	eax, ebx
	mov	DWORD PTR epochs$4[rsp], r8d
	div	r8d
	mov	DWORD PTR epochs$4[rsp+4], eax
	cmp	eax, r11d

; 653  :   if (epochs.size >= minEpochSize) {

	jb	SHORT $LN17@FASTCOVER_

; 654  :       assert(epochs.size * epochs.num <= nbDmers);
; 655  :       return epochs;

	mov	rbx, QWORD PTR epochs$4[rsp]
	jmp	SHORT $LN29@FASTCOVER_
$LN17@FASTCOVER_:

; 656  :   }
; 657  :   epochs.size = MIN(minEpochSize, nbDmers);

	mov	ecx, ebx
	cmp	r11d, ebx
	mov	eax, ebx
	cmovb	ecx, r11d
	xor	edx, edx
	div	ecx

; 658  :   epochs.num = nbDmers / epochs.size;

	shl	rcx, 32					; 00000020H
	mov	ebx, eax
	or	rbx, rcx
$LN29@FASTCOVER_:
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 405  :   DISPLAYLEVEL(2, "Breaking content into %u epochs of size %u\n",

	mov	edi, DWORD PTR g_displayLevel
	xor	ebp, ebp
	mov	QWORD PTR $T5[rsp], rbx
	cmp	edi, 2
	jl	SHORT $LN5@FASTCOVER_
	mov	rdi, rbx
	lea	ecx, QWORD PTR [rbp+2]
	shr	rdi, 32					; 00000020H
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, edi
	lea	rdx, OFFSET FLAT:$SG4294962784
	mov	rcx, rax
	mov	r8d, ebx
	call	fprintf
	lea	ecx, QWORD PTR [rbp+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
	mov	edi, DWORD PTR g_displayLevel
$LN5@FASTCOVER_:

; 406  :                 (U32)epochs.num, (U32)epochs.size);
; 407  :   /* Loop through the epochs until there are no more segments or the dictionary
; 408  :    * is full.
; 409  :    */
; 410  :   for (epoch = 0; tail > 0; epoch = (epoch + 1) % epochs.num) {

	xor	r14d, r14d
	test	r15, r15
	je	$LN28@FASTCOVER_
	npad	14
$LL4@FASTCOVER_:

; 411  :     const U32 epochBegin = (U32)(epoch * epochs.size);

	mov	eax, DWORD PTR $T5[rsp+4]
	mov	r9d, r14d

; 412  :     const U32 epochEnd = epochBegin + epochs.size;
; 413  :     size_t segmentSize;
; 414  :     /* Select a segment */
; 415  :     COVER_segment_t segment = FASTCOVER_selectSegment(

	movaps	xmm0, XMMWORD PTR [r12]
	mov	rdx, r13
	mov	rcx, QWORD PTR segmentFreqs$[rsp]
	movaps	xmm1, XMMWORD PTR [r12+16]
	mov	r8, QWORD PTR freqs$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR $T2[rsp]
	imul	r9d, eax
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movaps	xmm0, XMMWORD PTR [r12+32]
	movaps	XMMWORD PTR $T3[rsp+16], xmm1
	movaps	XMMWORD PTR $T3[rsp+32], xmm0
	add	eax, r9d
	mov	DWORD PTR [rsp+32], eax
	call	FASTCOVER_selectSegment

; 416  :         ctx, freqs, epochBegin, epochEnd, parameters, segmentFreqs);
; 417  : 
; 418  :     /* If the segment covers no dmers, then we are out of content.
; 419  :      * There may be new content in other epochs, for continue for some time.
; 420  :      */
; 421  :     if (segment.score == 0) {

	cmp	DWORD PTR [rax+8], 0
	movsd	xmm1, QWORD PTR [rax]
	movsd	QWORD PTR segment$1[rsp], xmm1
	jne	SHORT $LN6@FASTCOVER_

; 422  :       if (++zeroScoreRun >= maxZeroScoreRun) {

	inc	rbp
	cmp	rbp, 10
	jae	$LN28@FASTCOVER_

; 423  :           break;
; 424  :       }
; 425  :       continue;

	jmp	$LN2@FASTCOVER_
$LN6@FASTCOVER_:

; 426  :     }
; 427  :     zeroScoreRun = 0;
; 428  : 
; 429  :     /* Trim the segment if necessary and if it is too small then we are done */
; 430  :     segmentSize = MIN(segment.end - segment.begin + parameters.d - 1, tail);

	mov	ecx, DWORD PTR [r12+4]
	xor	ebp, ebp
	mov	rax, QWORD PTR segment$1[rsp]
	mov	edx, DWORD PTR segment$1[rsp]
	shr	rax, 32					; 00000020H
	lea	r8d, DWORD PTR [rcx-1]
	sub	eax, edx
	add	r8d, eax

; 431  :     if (segmentSize < parameters.d) {

	cmp	r8, rsi
	cmovae	r8, rsi
	cmp	r8, rcx
	jb	$LN28@FASTCOVER_

; 432  :       break;
; 433  :     }
; 434  : 
; 435  :     /* We fill the dictionary from the back to allow the best segments to be
; 436  :      * referenced with the smallest offsets.
; 437  :      */
; 438  :     tail -= segmentSize;
; 439  :     memcpy(dict + tail, ctx->samples + segment.begin, segmentSize);

	mov	rcx, QWORD PTR dictBuffer$[rsp]
	sub	rsi, r8
	add	rdx, QWORD PTR [r13]
	add	rcx, rsi
	call	memcpy

; 440  :     DISPLAYUPDATE(

	cmp	edi, 2
	jl	SHORT $LN2@FASTCOVER_
	call	QWORD PTR __imp_clock
	sub	eax, DWORD PTR g_time
	cmp	eax, 150				; 00000096H
	jg	SHORT $LN11@FASTCOVER_
	mov	edi, DWORD PTR g_displayLevel
	cmp	edi, 4
	jl	SHORT $LN2@FASTCOVER_
$LN11@FASTCOVER_:
	call	QWORD PTR __imp_clock
	mov	DWORD PTR g_time, eax
	xor	edx, edx
	mov	rax, r15
	mov	ecx, 2
	sub	rax, rsi
	imul	rax, rax, 100				; 00000064H
	div	r15
	mov	rdi, rax
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294962783
	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
	mov	edi, DWORD PTR g_displayLevel
$LN2@FASTCOVER_:

; 406  :                 (U32)epochs.num, (U32)epochs.size);
; 407  :   /* Loop through the epochs until there are no more segments or the dictionary
; 408  :    * is full.
; 409  :    */
; 410  :   for (epoch = 0; tail > 0; epoch = (epoch + 1) % epochs.num) {

	lea	rax, QWORD PTR [r14+1]
	mov	ecx, ebx
	xor	edx, edx
	div	rcx
	mov	r14, rdx
	test	rsi, rsi
	jne	$LL4@FASTCOVER_
$LN28@FASTCOVER_:

; 441  :         2, "\r%u%%       ",
; 442  :         (unsigned)(((dictBufferCapacity - tail) * 100) / dictBufferCapacity));
; 443  :   }
; 444  :   DISPLAYLEVEL(2, "\r%79s\r", "");

	cmp	edi, 2
	jl	SHORT $LN27@FASTCOVER_
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r8, OFFSET FLAT:$SG4294962782
	lea	rdx, OFFSET FLAT:$SG4294962781
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$LN27@FASTCOVER_:

; 445  :   return tail;
; 446  : }

	mov	rbx, QWORD PTR [rsp+208]
	mov	rax, rsi
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
FASTCOVER_buildDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
; File E:\dev\pyzstd\lib\dictBuilder\cover.c
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
selection$ = 96
$T1 = 128
$T2 = 128
$T3 = 128
parameters$1$ = 176
parameters$2$ = 192
parameters$3$ = 208
$T4 = 224
$T5 = 224
segmentFreqs$1$ = 320
opaque$ = 320
FASTCOVER_tryParameters PROC

; 465  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-16]
	sub	rsp, 272				; 00000110H

; 466  :   /* Save parameters as local variables */
; 467  :   FASTCOVER_tryParameters_data_t *const data = (FASTCOVER_tryParameters_data_t *)opaque;
; 468  :   const FASTCOVER_ctx_t *const ctx = data->ctx;
; 469  :   const ZDICT_cover_params_t parameters = data->parameters;

	movups	xmm0, XMMWORD PTR [rcx+24]
	mov	rsi, QWORD PTR [rcx]
	mov	rdi, rcx

; 470  :   size_t dictBufferCapacity = data->dictBufferCapacity;

	mov	r13, QWORD PTR [rcx+16]

; 471  :   size_t totalCompressedSize = ERROR(GENERIC);
; 472  :   /* Initialize array to keep track of frequency of dmer within activeSegment */
; 473  :   U16* segmentFreqs = (U16 *)calloc(((U64)1 << ctx->f), sizeof(U16));

	mov	r14d, 1
	movups	XMMWORD PTR parameters$1$[rbp-256], xmm0
	mov	eax, r14d
	movups	xmm0, XMMWORD PTR [rcx+40]
	lea	edx, QWORD PTR [r14+1]
	movups	XMMWORD PTR parameters$2$[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rcx+56]
	mov	ecx, DWORD PTR [rsi+68]
	shl	rax, cl
	mov	rcx, rax
	movups	XMMWORD PTR parameters$3$[rbp-256], xmm0
	call	QWORD PTR __imp_calloc

; 474  :   /* Allocate space for hash table, dict, and freqs */
; 475  :   BYTE *const dict = (BYTE * const)malloc(dictBufferCapacity);

	mov	rcx, r13
	mov	QWORD PTR segmentFreqs$1$[rbp-256], rax
	mov	r15, rax
	call	QWORD PTR __imp_malloc

; 477  :   U32 *freqs = (U32*) malloc(((U64)1 << ctx->f) * sizeof(U32));

	mov	ecx, DWORD PTR [rsi+68]
	mov	edx, r14d
	shl	rdx, cl
	mov	rbx, rax
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	xor	eax, eax
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 477  :   U32 *freqs = (U32*) malloc(((U64)1 << ctx->f) * sizeof(U32));

	shl	rdx, 2
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	mov	QWORD PTR $T3[rbp-256], rax
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 477  :   U32 *freqs = (U32*) malloc(((U64)1 << ctx->f) * sizeof(U32));

	mov	rcx, rdx
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	mov	QWORD PTR $T3[rbp-248], rax
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 476  :   COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));

	movups	xmm0, XMMWORD PTR $T3[rbp-256]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 937  :     COVER_dictSelection_t selection = { NULL, 0, error };

	mov	QWORD PTR $T3[rbp-240], -1
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 476  :   COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));

	movsd	xmm1, QWORD PTR $T3[rbp-240]
	movups	XMMWORD PTR selection$[rsp], xmm0
	movsd	QWORD PTR selection$[rsp+16], xmm1

; 477  :   U32 *freqs = (U32*) malloc(((U64)1 << ctx->f) * sizeof(U32));

	call	QWORD PTR __imp_malloc
	mov	r12, rax

; 478  :   if (!segmentFreqs || !dict || !freqs) {

	test	r15, r15
	je	$LN3@FASTCOVER_
	test	rbx, rbx
	je	$LN3@FASTCOVER_
	test	rax, rax
	je	$LN3@FASTCOVER_

; 480  :     goto _cleanup;
; 481  :   }
; 482  :   /* Copy the frequencies because we need to modify them */
; 483  :   memcpy(freqs, ctx->freqs, ((U64)1 << ctx->f) * sizeof(U32));

	mov	ecx, DWORD PTR [rsi+68]
	mov	rdx, QWORD PTR [rsi+56]
	shl	r14, cl
	mov	rcx, rax
	shl	r14, 2
	mov	r8, r14
	call	memcpy

; 484  :   /* Build the dictionary */
; 485  :   { const size_t tail = FASTCOVER_buildDictionary(ctx, freqs, dict, dictBufferCapacity,

	movups	xmm0, XMMWORD PTR parameters$1$[rbp-256]
	lea	rax, QWORD PTR $T4[rbp-256]
	mov	QWORD PTR [rsp+40], r15
	movups	xmm1, XMMWORD PTR parameters$2$[rbp-256]
	mov	r9, r13
	mov	r8, rbx
	movaps	XMMWORD PTR $T4[rbp-256], xmm0
	mov	rdx, r12
	movups	xmm0, XMMWORD PTR parameters$3$[rbp-256]
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T4[rbp-240], xmm1
	movaps	XMMWORD PTR $T4[rbp-224], xmm0
	call	FASTCOVER_buildDictionary

; 486  :                                                     parameters, segmentFreqs);
; 487  : 
; 488  :     const unsigned nbFinalizeSamples = (unsigned)(ctx->nbTrainSamples * ctx->accelParams.finalize / 100);

	mov	r10, QWORD PTR [rsi+32]
	mov	rcx, rax

; 489  :     selection = COVER_selectDict(dict + tail, dictBufferCapacity - tail,

	movups	xmm0, XMMWORD PTR parameters$1$[rbp-256]
	mov	r11d, DWORD PTR [rsi+72]
	sub	r13, rcx
	mov	r9, QWORD PTR [rsi]
	mov	rax, 5165088340638674453		; 47ae147ae147ae15H
	imul	r11, r10
	movaps	XMMWORD PTR $T2[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR parameters$2$[rbp-256]
	movaps	XMMWORD PTR $T2[rbp-240], xmm0
	mov	r8, r13
	movups	xmm0, XMMWORD PTR parameters$3$[rbp-256]
	mul	r11
	movaps	XMMWORD PTR $T2[rbp-224], xmm0
	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsp+72], rax
	sub	r11, rdx
	shr	r11, 1
	lea	rax, QWORD PTR $T2[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	add	r11, rdx
	mov	rax, QWORD PTR [rsi+24]
	lea	rdx, QWORD PTR [rcx+rbx]
	mov	QWORD PTR [rsp+56], rax
	lea	rcx, QWORD PTR $T5[rbp-256]
	mov	rax, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsp+48], r10
	shr	r11, 6
	mov	DWORD PTR [rsp+40], r11d
	mov	QWORD PTR [rsp+32], rax
	call	COVER_selectDict
	movups	xmm0, XMMWORD PTR [rax]
	movsd	xmm1, QWORD PTR [rax+16]

; 490  :          ctx->samples, ctx->samplesSizes, nbFinalizeSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,
; 491  :          totalCompressedSize);
; 492  : 
; 493  :     if (COVER_dictSelectionIsError(selection)) {

	movsd	QWORD PTR $T1[rbp-240], xmm1
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	QWORD PTR $T1[rbp-240], -120		; ffffffffffffff88H
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 489  :     selection = COVER_selectDict(dict + tail, dictBufferCapacity - tail,

	movups	XMMWORD PTR selection$[rsp], xmm0

; 490  :          ctx->samples, ctx->samplesSizes, nbFinalizeSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,
; 491  :          totalCompressedSize);
; 492  : 
; 493  :     if (COVER_dictSelectionIsError(selection)) {

	movaps	XMMWORD PTR $T1[rbp-256], xmm0
	movsd	QWORD PTR selection$[rsp+16], xmm1
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 942  :   return (ZSTD_isError(selection.totalCompressedSize) || !selection.dictContent);

	ja	SHORT $LN12@FASTCOVER_
	cmp	QWORD PTR $T1[rbp-256], 0
	jne	SHORT $_cleanup$31
$LN12@FASTCOVER_:
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 494  :       DISPLAYLEVEL(1, "Failed to select dictionary\n");

	cmp	DWORD PTR g_displayLevel, 1
	jl	SHORT $_cleanup$31
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962779

; 495  :       goto _cleanup;

	jmp	SHORT $LN29@FASTCOVER_
$LN3@FASTCOVER_:

; 479  :     DISPLAYLEVEL(1, "Failed to allocate buffers: out of memory\n");

	cmp	DWORD PTR g_displayLevel, r14d
	jl	SHORT $_cleanup$31
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294962780
$LN29@FASTCOVER_:

; 496  :     }
; 497  :   }
; 498  : _cleanup:
; 499  :   free(dict);

	mov	rcx, rax
	call	fprintf
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush
$_cleanup$31:
	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 500  :   COVER_best_finish(data->best, parameters, selection);

	mov	rbx, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 897  :   if (!best) {

	mov	r14, QWORD PTR selection$[rsp]
	test	rbx, rbx
	je	$LN16@FASTCOVER_

; 898  :     return;
; 899  :   }
; 900  :   {
; 901  :     size_t liveJobs;
; 902  :     ZSTD_pthread_mutex_lock(&best->mutex);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 903  :     --best->liveJobs;

	dec	QWORD PTR [rbx+48]

; 904  :     liveJobs = best->liveJobs;
; 905  :     /* If the new dictionary is better */
; 906  :     if (compressedSize < best->compressedSize) {

	mov	r15, QWORD PTR selection$[rsp+16]
	mov	r13, QWORD PTR [rbx+48]
	cmp	r15, QWORD PTR [rbx+120]
	jae	SHORT $LN23@FASTCOVER_

; 907  :       /* Allocate space if necessary */
; 908  :       if (!best->dict || best->dictSize < dictSize) {

	mov	rax, QWORD PTR [rbx+56]
	mov	rsi, QWORD PTR selection$[rsp+8]
	test	rax, rax
	je	SHORT $LN21@FASTCOVER_
	cmp	QWORD PTR [rbx+64], rsi
	jae	SHORT $LN22@FASTCOVER_

; 909  :         if (best->dict) {
; 910  :           free(best->dict);

	mov	rcx, rax
	call	QWORD PTR __imp_free
$LN21@FASTCOVER_:

; 911  :         }
; 912  :         best->dict = malloc(dictSize);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+56], rax

; 913  :         if (!best->dict) {

	test	rax, rax
	jne	SHORT $LN22@FASTCOVER_

; 914  :           best->compressedSize = ERROR(GENERIC);
; 915  :           best->dictSize = 0;
; 916  :           ZSTD_pthread_cond_signal(&best->cond);

	lea	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+120], -1
	mov	QWORD PTR [rbx+64], rax
	call	QWORD PTR __imp_WakeConditionVariable

; 917  :           ZSTD_pthread_mutex_unlock(&best->mutex);
; 918  :           return;

	jmp	SHORT $LN24@FASTCOVER_
$LN22@FASTCOVER_:

; 919  :         }
; 920  :       }
; 921  :       /* Save the dictionary, parameters, and size */
; 922  :       if (dict) {

	test	r14, r14
	je	SHORT $LN23@FASTCOVER_

; 923  :         memcpy(best->dict, dict, dictSize);

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rax
	call	memcpy

; 924  :         best->dictSize = dictSize;
; 925  :         best->parameters = parameters;

	movups	xmm0, XMMWORD PTR parameters$1$[rbp-256]
	mov	QWORD PTR [rbx+64], rsi

; 926  :         best->compressedSize = compressedSize;

	mov	QWORD PTR [rbx+120], r15
	movups	XMMWORD PTR [rbx+72], xmm0
	movups	xmm0, XMMWORD PTR parameters$2$[rbp-256]
	movups	XMMWORD PTR [rbx+88], xmm0
	movups	xmm0, XMMWORD PTR parameters$3$[rbp-256]
	movups	XMMWORD PTR [rbx+104], xmm0
$LN23@FASTCOVER_:

; 927  :       }
; 928  :     }
; 929  :     if (liveJobs == 0) {

	test	r13, r13
	jne	SHORT $LN24@FASTCOVER_

; 930  :       ZSTD_pthread_cond_broadcast(&best->cond);

	lea	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_WakeAllConditionVariable
$LN24@FASTCOVER_:
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 501  :   free(data);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	r15, QWORD PTR segmentFreqs$1$[rbp-256]
$LN16@FASTCOVER_:
	mov	rcx, rdi
	call	QWORD PTR __imp_free

; 502  :   free(segmentFreqs);

	mov	rcx, r15
	call	QWORD PTR __imp_free
; File E:\dev\pyzstd\lib\dictBuilder\cover.c

; 946  :   free(selection.dictContent);

	mov	rcx, r14
	call	QWORD PTR __imp_free
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c

; 504  :   free(freqs);

	mov	rcx, r12

; 505  : }

	lea	r11, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp

; 504  :   free(freqs);

	rex_jmp	QWORD PTR __imp_free
FASTCOVER_tryParameters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
fastCoverParams$ = 8
coverParams$ = 16
FASTCOVER_convertToCoverParams PROC

; 512  :     coverParams->k = fastCoverParams.k;

	mov	eax, DWORD PTR [rcx]

; 513  :     coverParams->d = fastCoverParams.d;
; 514  :     coverParams->steps = fastCoverParams.steps;
; 515  :     coverParams->nbThreads = fastCoverParams.nbThreads;
; 516  :     coverParams->splitPoint = fastCoverParams.splitPoint;
; 517  :     coverParams->zParams = fastCoverParams.zParams;

	movsd	xmm0, QWORD PTR [rcx+44]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdx+8], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR [rdx+12], eax
	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rdx+16], rax
	mov	eax, DWORD PTR [rcx+52]
	movsd	QWORD PTR [rdx+32], xmm0
	mov	DWORD PTR [rdx+40], eax

; 518  :     coverParams->shrinkDict = fastCoverParams.shrinkDict;

	mov	eax, DWORD PTR [rcx+36]
	mov	DWORD PTR [rdx+24], eax

; 519  : }

	ret	0
FASTCOVER_convertToCoverParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\dictBuilder\fastcover.c
_TEXT	SEGMENT
coverParams$ = 8
fastCoverParams$ = 16
f$ = 24
accel$ = 32
FASTCOVER_convertToFastCoverParams PROC

; 527  :     fastCoverParams->k = coverParams.k;

	mov	eax, DWORD PTR [rcx]

; 528  :     fastCoverParams->d = coverParams.d;
; 529  :     fastCoverParams->steps = coverParams.steps;
; 530  :     fastCoverParams->nbThreads = coverParams.nbThreads;
; 531  :     fastCoverParams->splitPoint = coverParams.splitPoint;
; 532  :     fastCoverParams->f = f;
; 533  :     fastCoverParams->accel = accel;
; 534  :     fastCoverParams->zParams = coverParams.zParams;

	movsd	xmm0, QWORD PTR [rcx+32]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+12], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdx+16], eax
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx+24], rax
	mov	eax, DWORD PTR [rcx+40]
	movsd	QWORD PTR [rdx+44], xmm0
	mov	DWORD PTR [rdx+52], eax

; 535  :     fastCoverParams->shrinkDict = coverParams.shrinkDict;

	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rdx+36], eax
	mov	DWORD PTR [rdx+8], r8d
	mov	DWORD PTR [rdx+32], r9d

; 536  : }

	ret	0
FASTCOVER_convertToFastCoverParams ENDP
_TEXT	ENDS
END
