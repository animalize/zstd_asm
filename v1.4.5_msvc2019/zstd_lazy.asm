; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

prime4bytes DD	09e3779b1H
prime8bytes DQ	cf1bbcdcb7a56463H
prime5bytes DQ	000000cf1bbcdcbbH
prime7bytes DQ	00cf1bbcdcbfa563H
prime6bytes DQ	0000cf1bbcdcbf9bH
PUBLIC	ZSTD_compressBlock_btlazy2_extDict
PUBLIC	ZSTD_compressBlock_lazy_extDict
PUBLIC	ZSTD_compressBlock_lazy2_extDict
PUBLIC	ZSTD_compressBlock_lazy2_dictMatchState
PUBLIC	ZSTD_compressBlock_greedy_extDict
PUBLIC	ZSTD_compressBlock_greedy
PUBLIC	ZSTD_insertAndFindFirstIndex
PUBLIC	ZSTD_compressBlock_lazy_dictMatchState
PUBLIC	ZSTD_compressBlock_btlazy2_dictMatchState
PUBLIC	ZSTD_compressBlock_lazy2
PUBLIC	ZSTD_compressBlock_btlazy2
PUBLIC	ZSTD_compressBlock_greedy_dictMatchState
PUBLIC	ZSTD_compressBlock_lazy
pdata	SEGMENT
$pdata$ZSTD_compressBlock_lazy_extDict_generic DD imagerel ZSTD_compressBlock_lazy_extDict_generic
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic+230
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_extDict_generic
$pdata$0$ZSTD_compressBlock_lazy_extDict_generic DD imagerel ZSTD_compressBlock_lazy_extDict_generic+230
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic+2390
	DD	imagerel $chain$0$ZSTD_compressBlock_lazy_extDict_generic
$pdata$1$ZSTD_compressBlock_lazy_extDict_generic DD imagerel ZSTD_compressBlock_lazy_extDict_generic+2390
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic+2421
	DD	imagerel $chain$1$ZSTD_compressBlock_lazy_extDict_generic
$pdata$ZSTD_compressBlock_lazy_generic DD imagerel ZSTD_compressBlock_lazy_generic
	DD	imagerel ZSTD_compressBlock_lazy_generic+3759
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_generic
$pdata$ZSTD_HcFindBestMatch_extDict_selectMLS DD imagerel ZSTD_HcFindBestMatch_extDict_selectMLS
	DD	imagerel ZSTD_HcFindBestMatch_extDict_selectMLS+2220
	DD	imagerel $unwind$ZSTD_HcFindBestMatch_extDict_selectMLS
$pdata$ZSTD_HcFindBestMatch_dictMatchState_selectMLS DD imagerel ZSTD_HcFindBestMatch_dictMatchState_selectMLS
	DD	imagerel ZSTD_HcFindBestMatch_dictMatchState_selectMLS+2924
	DD	imagerel $unwind$ZSTD_HcFindBestMatch_dictMatchState_selectMLS
$pdata$ZSTD_HcFindBestMatch_selectMLS DD imagerel ZSTD_HcFindBestMatch_selectMLS
	DD	imagerel ZSTD_HcFindBestMatch_selectMLS+1767
	DD	imagerel $unwind$ZSTD_HcFindBestMatch_selectMLS
$pdata$ZSTD_HcFindBestMatch_generic DD imagerel ZSTD_HcFindBestMatch_generic
	DD	imagerel ZSTD_HcFindBestMatch_generic+1108
	DD	imagerel $unwind$ZSTD_HcFindBestMatch_generic
$pdata$ZSTD_insertAndFindFirstIndex_internal DD imagerel ZSTD_insertAndFindFirstIndex_internal
	DD	imagerel ZSTD_insertAndFindFirstIndex_internal+466
	DD	imagerel $unwind$ZSTD_insertAndFindFirstIndex_internal
$pdata$ZSTD_BtFindBestMatch_extDict_selectMLS DD imagerel ZSTD_BtFindBestMatch_extDict_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+112
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_extDict_selectMLS
$pdata$1$ZSTD_BtFindBestMatch_extDict_selectMLS DD imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+112
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+161
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_extDict_selectMLS
$pdata$2$ZSTD_BtFindBestMatch_extDict_selectMLS DD imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+161
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+251
	DD	imagerel $chain$2$ZSTD_BtFindBestMatch_extDict_selectMLS
$pdata$3$ZSTD_BtFindBestMatch_extDict_selectMLS DD imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+251
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+311
	DD	imagerel $chain$3$ZSTD_BtFindBestMatch_extDict_selectMLS
$pdata$4$ZSTD_BtFindBestMatch_extDict_selectMLS DD imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+311
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+395
	DD	imagerel $chain$4$ZSTD_BtFindBestMatch_extDict_selectMLS
$pdata$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+112
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$pdata$1$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+112
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+161
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$pdata$2$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+161
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+251
	DD	imagerel $chain$2$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$pdata$3$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+251
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+311
	DD	imagerel $chain$3$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$pdata$4$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+311
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+395
	DD	imagerel $chain$4$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$pdata$ZSTD_BtFindBestMatch_selectMLS DD imagerel ZSTD_BtFindBestMatch_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+110
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_selectMLS
$pdata$1$ZSTD_BtFindBestMatch_selectMLS DD imagerel ZSTD_BtFindBestMatch_selectMLS+110
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+159
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_selectMLS
$pdata$2$ZSTD_BtFindBestMatch_selectMLS DD imagerel ZSTD_BtFindBestMatch_selectMLS+159
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+251
	DD	imagerel $chain$2$ZSTD_BtFindBestMatch_selectMLS
$pdata$3$ZSTD_BtFindBestMatch_selectMLS DD imagerel ZSTD_BtFindBestMatch_selectMLS+251
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+309
	DD	imagerel $chain$3$ZSTD_BtFindBestMatch_selectMLS
$pdata$4$ZSTD_BtFindBestMatch_selectMLS DD imagerel ZSTD_BtFindBestMatch_selectMLS+309
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+391
	DD	imagerel $chain$4$ZSTD_BtFindBestMatch_selectMLS
$pdata$ZSTD_BtFindBestMatch DD imagerel ZSTD_BtFindBestMatch
	DD	imagerel ZSTD_BtFindBestMatch+49
	DD	imagerel $unwind$ZSTD_BtFindBestMatch
$pdata$0$ZSTD_BtFindBestMatch DD imagerel ZSTD_BtFindBestMatch+49
	DD	imagerel ZSTD_BtFindBestMatch+100
	DD	imagerel $chain$0$ZSTD_BtFindBestMatch
$pdata$1$ZSTD_BtFindBestMatch DD imagerel ZSTD_BtFindBestMatch+100
	DD	imagerel ZSTD_BtFindBestMatch+122
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch
$pdata$ZSTD_DUBT_findBestMatch DD imagerel ZSTD_DUBT_findBestMatch
	DD	imagerel ZSTD_DUBT_findBestMatch+1417
	DD	imagerel $unwind$ZSTD_DUBT_findBestMatch
$pdata$ZSTD_DUBT_findBetterDictMatch DD imagerel ZSTD_DUBT_findBetterDictMatch
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+245
	DD	imagerel $unwind$ZSTD_DUBT_findBetterDictMatch
$pdata$2$ZSTD_DUBT_findBetterDictMatch DD imagerel ZSTD_DUBT_findBetterDictMatch+245
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+592
	DD	imagerel $chain$2$ZSTD_DUBT_findBetterDictMatch
$pdata$4$ZSTD_DUBT_findBetterDictMatch DD imagerel ZSTD_DUBT_findBetterDictMatch+592
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+696
	DD	imagerel $chain$4$ZSTD_DUBT_findBetterDictMatch
$pdata$5$ZSTD_DUBT_findBetterDictMatch DD imagerel ZSTD_DUBT_findBetterDictMatch+696
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+719
	DD	imagerel $chain$5$ZSTD_DUBT_findBetterDictMatch
$pdata$ZSTD_insertDUBT1 DD imagerel ZSTD_insertDUBT1
	DD	imagerel ZSTD_insertDUBT1+904
	DD	imagerel $unwind$ZSTD_insertDUBT1
$pdata$ZSTD_updateDUBT DD imagerel ZSTD_updateDUBT
	DD	imagerel ZSTD_updateDUBT+73
	DD	imagerel $unwind$ZSTD_updateDUBT
$pdata$2$ZSTD_updateDUBT DD imagerel ZSTD_updateDUBT+73
	DD	imagerel ZSTD_updateDUBT+295
	DD	imagerel $chain$2$ZSTD_updateDUBT
$pdata$3$ZSTD_updateDUBT DD imagerel ZSTD_updateDUBT+295
	DD	imagerel ZSTD_updateDUBT+307
	DD	imagerel $chain$3$ZSTD_updateDUBT
$pdata$ZSTD_count_2segments DD imagerel ZSTD_count_2segments
	DD	imagerel ZSTD_count_2segments+106
	DD	imagerel $unwind$ZSTD_count_2segments
$pdata$ZSTD_storeSeq DD imagerel ZSTD_storeSeq
	DD	imagerel ZSTD_storeSeq+271
	DD	imagerel $unwind$ZSTD_storeSeq
$pdata$ZSTD_compressBlock_btlazy2_extDict DD imagerel $LN255
	DD	imagerel $LN255+177
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_extDict
$pdata$1$ZSTD_compressBlock_btlazy2_extDict DD imagerel $LN255+177
	DD	imagerel $LN255+2291
	DD	imagerel $chain$1$ZSTD_compressBlock_btlazy2_extDict
$pdata$2$ZSTD_compressBlock_btlazy2_extDict DD imagerel $LN255+2291
	DD	imagerel $LN255+2319
	DD	imagerel $chain$2$ZSTD_compressBlock_btlazy2_extDict
$pdata$ZSTD_compressBlock_lazy_extDict DD imagerel $LN256
	DD	imagerel $LN256+1826
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_extDict
$pdata$ZSTD_compressBlock_lazy2_extDict DD imagerel $LN255
	DD	imagerel $LN255+177
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_extDict
$pdata$1$ZSTD_compressBlock_lazy2_extDict DD imagerel $LN255+177
	DD	imagerel $LN255+2291
	DD	imagerel $chain$1$ZSTD_compressBlock_lazy2_extDict
$pdata$2$ZSTD_compressBlock_lazy2_extDict DD imagerel $LN255+2291
	DD	imagerel $LN255+2319
	DD	imagerel $chain$2$ZSTD_compressBlock_lazy2_extDict
$pdata$ZSTD_compressBlock_lazy2_dictMatchState DD imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_dictMatchState
$pdata$0$ZSTD_compressBlock_lazy2_dictMatchState DD imagerel $LN389+201
	DD	imagerel $LN389+516
	DD	imagerel $chain$0$ZSTD_compressBlock_lazy2_dictMatchState
$pdata$1$ZSTD_compressBlock_lazy2_dictMatchState DD imagerel $LN389+516
	DD	imagerel $LN389+547
	DD	imagerel $chain$1$ZSTD_compressBlock_lazy2_dictMatchState
$pdata$2$ZSTD_compressBlock_lazy2_dictMatchState DD imagerel $LN389+547
	DD	imagerel $LN389+2000
	DD	imagerel $chain$2$ZSTD_compressBlock_lazy2_dictMatchState
$pdata$ZSTD_compressBlock_greedy_extDict DD imagerel $LN240
	DD	imagerel $LN240+173
	DD	imagerel $unwind$ZSTD_compressBlock_greedy_extDict
$pdata$0$ZSTD_compressBlock_greedy_extDict DD imagerel $LN240+173
	DD	imagerel $LN240+1222
	DD	imagerel $chain$0$ZSTD_compressBlock_greedy_extDict
$pdata$1$ZSTD_compressBlock_greedy_extDict DD imagerel $LN240+1222
	DD	imagerel $LN240+1251
	DD	imagerel $chain$1$ZSTD_compressBlock_greedy_extDict
$pdata$2$ZSTD_compressBlock_greedy_extDict DD imagerel $LN240+1251
	DD	imagerel $LN240+1274
	DD	imagerel $chain$2$ZSTD_compressBlock_greedy_extDict
$pdata$ZSTD_compressBlock_greedy DD imagerel $LN376
	DD	imagerel $LN376+973
	DD	imagerel $unwind$ZSTD_compressBlock_greedy
$pdata$ZSTD_compressBlock_lazy_dictMatchState DD imagerel $LN389
	DD	imagerel $LN389+199
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_dictMatchState
$pdata$0$ZSTD_compressBlock_lazy_dictMatchState DD imagerel $LN389+199
	DD	imagerel $LN389+1620
	DD	imagerel $chain$0$ZSTD_compressBlock_lazy_dictMatchState
$pdata$1$ZSTD_compressBlock_lazy_dictMatchState DD imagerel $LN389+1620
	DD	imagerel $LN389+1651
	DD	imagerel $chain$1$ZSTD_compressBlock_lazy_dictMatchState
$pdata$ZSTD_compressBlock_btlazy2_dictMatchState DD imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_dictMatchState
$pdata$0$ZSTD_compressBlock_btlazy2_dictMatchState DD imagerel $LN389+201
	DD	imagerel $LN389+516
	DD	imagerel $chain$0$ZSTD_compressBlock_btlazy2_dictMatchState
$pdata$1$ZSTD_compressBlock_btlazy2_dictMatchState DD imagerel $LN389+516
	DD	imagerel $LN389+547
	DD	imagerel $chain$1$ZSTD_compressBlock_btlazy2_dictMatchState
$pdata$2$ZSTD_compressBlock_btlazy2_dictMatchState DD imagerel $LN389+547
	DD	imagerel $LN389+2000
	DD	imagerel $chain$2$ZSTD_compressBlock_btlazy2_dictMatchState
$pdata$ZSTD_compressBlock_lazy2 DD imagerel $LN382
	DD	imagerel $LN382+1575
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2
$pdata$ZSTD_compressBlock_btlazy2 DD imagerel $LN382
	DD	imagerel $LN382+1575
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2
$pdata$ZSTD_compressBlock_greedy_dictMatchState DD imagerel $LN377
	DD	imagerel $LN377+1228
	DD	imagerel $unwind$ZSTD_compressBlock_greedy_dictMatchState
$pdata$ZSTD_compressBlock_lazy DD imagerel $LN382
	DD	imagerel $LN382+1318
	DD	imagerel $unwind$ZSTD_compressBlock_lazy
xdata	SEGMENT
$unwind$ZSTD_compressBlock_lazy_extDict_generic DD 092501H
	DD	0160125H
	DD	0e01cf01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
$chain$0$ZSTD_compressBlock_lazy_extDict_generic DD 020821H
	DD	015d408H
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic+230
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_extDict_generic
$chain$1$ZSTD_compressBlock_lazy_extDict_generic DD 021H
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic
	DD	imagerel ZSTD_compressBlock_lazy_extDict_generic+230
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_extDict_generic
$unwind$ZSTD_compressBlock_lazy_generic DD 0a2c01H
	DD	017012cH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$ZSTD_HcFindBestMatch_extDict_selectMLS DD 091f01H
	DD	0f01bc21fH
	DD	0d017e019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
$unwind$ZSTD_HcFindBestMatch_dictMatchState_selectMLS DD 092401H
	DD	0f020c224H
	DD	0d01ce01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
$unwind$ZSTD_HcFindBestMatch_selectMLS DD 091f01H
	DD	0f01b821fH
	DD	0d017e019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
$unwind$ZSTD_HcFindBestMatch_generic DD 0a1e01H
	DD	016341eH
	DD	0f01ab21eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_insertAndFindFirstIndex_internal DD 091a01H
	DD	09341aH
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
$unwind$ZSTD_BtFindBestMatch_extDict_selectMLS DD 060c01H
	DD	0d340cH
	DD	07008520cH
	DD	050066007H
$chain$1$ZSTD_BtFindBestMatch_extDict_selectMLS DD 041721H
	DD	0cf417H
	DD	0ac405H
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+112
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_extDict_selectMLS
$chain$2$ZSTD_BtFindBestMatch_extDict_selectMLS DD 020521H
	DD	0be405H
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+112
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+161
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_extDict_selectMLS
$chain$3$ZSTD_BtFindBestMatch_extDict_selectMLS DD 021H
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+112
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+161
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_extDict_selectMLS
$chain$4$ZSTD_BtFindBestMatch_extDict_selectMLS DD 021H
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_extDict_selectMLS+112
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_extDict_selectMLS
$unwind$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD 060c01H
	DD	0d340cH
	DD	07008520cH
	DD	050066007H
$chain$1$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD 041721H
	DD	0cf417H
	DD	0ac405H
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+112
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$chain$2$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD 020521H
	DD	0be405H
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+112
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+161
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$chain$3$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD 021H
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+112
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+161
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$chain$4$ZSTD_BtFindBestMatch_dictMatchState_selectMLS DD 021H
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_dictMatchState_selectMLS+112
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_dictMatchState_selectMLS
$unwind$ZSTD_BtFindBestMatch_selectMLS DD 060c01H
	DD	0d340cH
	DD	07008520cH
	DD	050066007H
$chain$1$ZSTD_BtFindBestMatch_selectMLS DD 041721H
	DD	0cf417H
	DD	0ac405H
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+110
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_selectMLS
$chain$2$ZSTD_BtFindBestMatch_selectMLS DD 020521H
	DD	0be405H
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+110
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+159
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_selectMLS
$chain$3$ZSTD_BtFindBestMatch_selectMLS DD 021H
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+110
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+159
	DD	imagerel $chain$1$ZSTD_BtFindBestMatch_selectMLS
$chain$4$ZSTD_BtFindBestMatch_selectMLS DD 021H
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS
	DD	imagerel ZSTD_BtFindBestMatch_selectMLS+110
	DD	imagerel $unwind$ZSTD_BtFindBestMatch_selectMLS
$unwind$ZSTD_BtFindBestMatch DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0e0115215H
$chain$0$ZSTD_BtFindBestMatch DD 020521H
	DD	083405H
	DD	imagerel ZSTD_BtFindBestMatch
	DD	imagerel ZSTD_BtFindBestMatch+49
	DD	imagerel $unwind$ZSTD_BtFindBestMatch
$chain$1$ZSTD_BtFindBestMatch DD 021H
	DD	imagerel ZSTD_BtFindBestMatch
	DD	imagerel ZSTD_BtFindBestMatch+49
	DD	imagerel $unwind$ZSTD_BtFindBestMatch
$unwind$ZSTD_DUBT_findBestMatch DD 0b2601H
	DD	0223426H
	DD	0180126H
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	05015H
$unwind$ZSTD_DUBT_findBetterDictMatch DD 071d01H
	DD	012011dH
	DD	0c014e016H
	DD	060117012H
	DD	03010H
$chain$2$ZSTD_DUBT_findBetterDictMatch DD 061d21H
	DD	0ff41dH
	DD	010d418H
	DD	0115408H
	DD	imagerel ZSTD_DUBT_findBetterDictMatch
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+245
	DD	imagerel $unwind$ZSTD_DUBT_findBetterDictMatch
$chain$4$ZSTD_DUBT_findBetterDictMatch DD 060021H
	DD	0ff400H
	DD	010d400H
	DD	0115400H
	DD	imagerel ZSTD_DUBT_findBetterDictMatch
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+245
	DD	imagerel $unwind$ZSTD_DUBT_findBetterDictMatch
$chain$5$ZSTD_DUBT_findBetterDictMatch DD 021H
	DD	imagerel ZSTD_DUBT_findBetterDictMatch
	DD	imagerel ZSTD_DUBT_findBetterDictMatch+245
	DD	imagerel $unwind$ZSTD_DUBT_findBetterDictMatch
$unwind$ZSTD_insertDUBT1 DD 0a1b01H
	DD	01a341bH
	DD	0f014f21bH
	DD	0d010e012H
	DD	0700cc00eH
	DD	0500a600bH
$unwind$ZSTD_updateDUBT DD 050c01H
	DD	0e00af00cH
	DD	060077008H
	DD	03006H
$chain$2$ZSTD_updateDUBT DD 061d21H
	DD	09d41dH
	DD	08c410H
	DD	075405H
	DD	imagerel ZSTD_updateDUBT
	DD	imagerel ZSTD_updateDUBT+73
	DD	imagerel $unwind$ZSTD_updateDUBT
$chain$3$ZSTD_updateDUBT DD 021H
	DD	imagerel ZSTD_updateDUBT
	DD	imagerel ZSTD_updateDUBT+73
	DD	imagerel $unwind$ZSTD_updateDUBT
$unwind$ZSTD_count_2segments DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$ZSTD_storeSeq DD 020501H
	DD	013405H
$unwind$ZSTD_compressBlock_btlazy2_extDict DD 082301H
	DD	0170123H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
$chain$1$ZSTD_compressBlock_btlazy2_extDict DD 041021H
	DD	015f410H
	DD	016e408H
	DD	imagerel $LN255
	DD	imagerel $LN255+177
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_extDict
$chain$2$ZSTD_compressBlock_btlazy2_extDict DD 021H
	DD	imagerel $LN255
	DD	imagerel $LN255+177
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_extDict
$unwind$ZSTD_compressBlock_lazy_extDict DD 0a2701H
	DD	0130127H
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
$unwind$ZSTD_compressBlock_lazy2_extDict DD 082301H
	DD	0170123H
	DD	0c01ad01cH
	DD	060177018H
	DD	030155016H
$chain$1$ZSTD_compressBlock_lazy2_extDict DD 041021H
	DD	015f410H
	DD	016e408H
	DD	imagerel $LN255
	DD	imagerel $LN255+177
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_extDict
$chain$2$ZSTD_compressBlock_lazy2_extDict DD 021H
	DD	imagerel $LN255
	DD	imagerel $LN255+177
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_extDict
$unwind$ZSTD_compressBlock_lazy2_dictMatchState DD 092501H
	DD	0140125H
	DD	0e01cf01eH
	DD	07018d01aH
	DD	050166017H
	DD	03015H
$chain$0$ZSTD_compressBlock_lazy2_dictMatchState DD 020821H
	DD	013c408H
	DD	imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_dictMatchState
$chain$1$ZSTD_compressBlock_lazy2_dictMatchState DD 021H
	DD	imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_dictMatchState
$chain$2$ZSTD_compressBlock_lazy2_dictMatchState DD 020021H
	DD	013c400H
	DD	imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_lazy2_dictMatchState
$unwind$ZSTD_compressBlock_greedy_extDict DD 081901H
	DD	0f015b219H
	DD	0d011e013H
	DD	0600dc00fH
	DD	0300b500cH
$chain$0$ZSTD_compressBlock_greedy_extDict DD 020821H
	DD	0157408H
	DD	imagerel $LN240
	DD	imagerel $LN240+173
	DD	imagerel $unwind$ZSTD_compressBlock_greedy_extDict
$chain$1$ZSTD_compressBlock_greedy_extDict DD 021H
	DD	imagerel $LN240
	DD	imagerel $LN240+173
	DD	imagerel $unwind$ZSTD_compressBlock_greedy_extDict
$chain$2$ZSTD_compressBlock_greedy_extDict DD 020021H
	DD	0157400H
	DD	imagerel $LN240
	DD	imagerel $LN240+173
	DD	imagerel $unwind$ZSTD_compressBlock_greedy_extDict
$unwind$ZSTD_compressBlock_greedy DD 0a1e01H
	DD	011341eH
	DD	0f01a721eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_compressBlock_lazy_dictMatchState DD 092501H
	DD	0120125H
	DD	0e01cf01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
$chain$0$ZSTD_compressBlock_lazy_dictMatchState DD 020821H
	DD	011d408H
	DD	imagerel $LN389
	DD	imagerel $LN389+199
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_dictMatchState
$chain$1$ZSTD_compressBlock_lazy_dictMatchState DD 021H
	DD	imagerel $LN389
	DD	imagerel $LN389+199
	DD	imagerel $unwind$ZSTD_compressBlock_lazy_dictMatchState
$unwind$ZSTD_compressBlock_btlazy2_dictMatchState DD 092501H
	DD	0140125H
	DD	0e01cf01eH
	DD	07018d01aH
	DD	050166017H
	DD	03015H
$chain$0$ZSTD_compressBlock_btlazy2_dictMatchState DD 020821H
	DD	013c408H
	DD	imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_dictMatchState
$chain$1$ZSTD_compressBlock_btlazy2_dictMatchState DD 021H
	DD	imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_dictMatchState
$chain$2$ZSTD_compressBlock_btlazy2_dictMatchState DD 020021H
	DD	013c400H
	DD	imagerel $LN389
	DD	imagerel $LN389+201
	DD	imagerel $unwind$ZSTD_compressBlock_btlazy2_dictMatchState
$unwind$ZSTD_compressBlock_lazy2 DD 092401H
	DD	0f020e224H
	DD	0d01ce01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
$unwind$ZSTD_compressBlock_btlazy2 DD 092401H
	DD	0f020e224H
	DD	0d01ce01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
$unwind$ZSTD_compressBlock_greedy_dictMatchState DD 0a1e01H
	DD	017341eH
	DD	0f01ad21eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_compressBlock_lazy DD 092401H
	DD	0f020c224H
	DD	0d01ce01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
tv2134 = 32
r$1 = 32
r$2 = 32
r$3 = 32
offset_2$1$ = 36
tv2307 = 40
iend$1$ = 48
offsetFound$4 = 56
offset2$5 = 64
tv2135 = 72
prefixLowest$1$ = 80
ilimit$1$ = 88
ms$ = 176
seqStore$ = 184
rep$ = 192
src$ = 200
offset_1$1$ = 208
srcSize$ = 208
ZSTD_compressBlock_lazy PROC

; 888  : {

$LN382:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 104				; 00000068H

; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;

	mov	r10d, DWORD PTR [rcx+24]

; 888  : {

	mov	r15, rcx

; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [r8]

; 888  : {

	mov	r14, r9

; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;

	mov	r11d, DWORD PTR [r8+4]

; 888  : {

	mov	rsi, rdx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	r13, QWORD PTR srcSize$[rsp]

; 668  :     ip += (dictAndPrefixLength == 0);

	xor	r8d, r8d
	add	r13, r9
	mov	eax, r8d
	mov	r9, QWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [rcx+184]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	QWORD PTR iend$1$[rsp], r13

; 636  :     const BYTE* const ilimit = iend - 8;

	lea	rbp, QWORD PTR [r13-8]

; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;

	lea	rdx, QWORD PTR [r9+r10]
	mov	QWORD PTR ilimit$1$[rsp], rbp

; 668  :     ip += (dictAndPrefixLength == 0);

	cmp	r14d, edx
	mov	QWORD PTR prefixLowest$1$[rsp], rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 668  :     ip += (dictAndPrefixLength == 0);

	sete	al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	edx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 668  :     ip += (dictAndPrefixLength == 0);

	lea	rbx, QWORD PTR [rax+r14]

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);

	mov	r8d, ebx
	sub	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, r8d
	sub	eax, r10d
	sub	ecx, edx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 690  :     while (ip < ilimit) {

	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, r10d
	cmp	DWORD PTR [r15+32], 0

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	xor	r10d, r10d
	sub	r8d, ecx
	mov	r12d, r10d
	cmp	r11d, r8d

; 690  :     while (ip < ilimit) {

	mov	r9d, r10d
	cmovbe	r12d, r11d
	cmovbe	r11d, r10d
	cmp	edi, r8d
	cmovbe	eax, r11d
	cmovbe	r9d, edi
	mov	DWORD PTR tv2307[rsp], eax
	cmp	rbx, rbp
	jae	$LN5@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	DWORD PTR offset_2$1$[rsp], r12d
	mov	DWORD PTR offset_1$1$[rsp], r9d
	npad	7
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {

	mov	eax, r9d
	lea	r15, QWORD PTR [rbx+1]
	mov	r8d, r10d
	mov	QWORD PTR tv2135[rsp], rax
	mov	ecx, r10d
	mov	rdx, rbx
	sub	rdx, rax
	mov	rdi, r10
	mov	eax, DWORD PTR [r15]
	test	r9d, r9d
	mov	rbp, r10
	setne	r8b
	cmp	DWORD PTR [rdx+1], eax
	mov	DWORD PTR tv2134[rsp], r8d
	sete	cl
	test	ecx, r8d
	je	SHORT $LN24@ZSTD_compr

; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;

	add	rdx, 5
	lea	rcx, QWORD PTR [rbx+5]
	mov	r8, r13
	call	ZSTD_count
	lea	rdi, QWORD PTR [rax+4]
$LN24@ZSTD_compr:

; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$4[rsp]
	mov	r8, r13
	mov	QWORD PTR offsetFound$4[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_selectMLS

; 718  :             if (ml2 > matchLength)

	cmp	rax, rdi
	jbe	SHORT $LN25@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	rbp, QWORD PTR offsetFound$4[rsp]
	mov	rdi, rax
	mov	r15, rbx
$LN25@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rdi, 4
	jae	SHORT $LN354@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rax, rbx
	inc	rbx
	sub	rax, r14
	sar	rax, 8
	add	rbx, rax

; 724  :             continue;

	xor	r10d, r10d
	jmp	$LN15@ZSTD_compr
$LN354@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [r13-8]
	xor	r10d, r10d
	cmp	rbx, rax
	jae	$LN33@ZSTD_compr
	mov	esi, DWORD PTR tv2134[rsp]
	mov	r12, QWORD PTR tv2135[rsp]
	mov	r14, QWORD PTR ms$[rsp]
	npad	4
$LL6@ZSTD_compr:

; 730  :             ip ++;

	inc	rbx

; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	test	rbp, rbp
	je	SHORT $LN29@ZSTD_compr
	mov	ecx, r10d
	mov	rdx, rbx
	sub	rdx, r12
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	sete	cl
	test	ecx, esi
	je	SHORT $LN29@ZSTD_compr

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r13
	call	ZSTD_count
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
	mov	DWORD PTR r$1[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rax+4]

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [rbp+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [rdi+rdi*2]
	sub	ecx, eax
	inc	ecx

; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN29@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN29@ZSTD_compr

; 737  :                     matchLength = mlRep, offset = 0, start = ip;

	mov	rdi, rdx
	mov	ebp, r8d
	mov	r15, rbx
$LN29@ZSTD_compr:

; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;
; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 748  :                     int const gain2 = (int)(mlRep * 3);
; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 751  :                         matchLength = mlRep, offset = 0, start = ip;
; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;
; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	lea	r9, QWORD PTR offset2$5[rsp]
	mov	QWORD PTR offset2$5[rsp], 999999999	; 3b9ac9ffH
	mov	r8, r13
	mov	rdx, rbx
	mov	rcx, r14
	call	ZSTD_HcFindBestMatch_selectMLS

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$5[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$3[rsp], r10d
	mov	DWORD PTR r$2[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [rbp+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	ecx, DWORD PTR [rdi*4+4]
	sub	ecx, eax

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN376@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN376@ZSTD_compr

; 759  :                     matchLength = ml2, offset = offset2, start = ip;

	lea	rax, QWORD PTR [r13-8]
	mov	rdi, r8
	mov	rbp, r9
	mov	r15, rbx
	cmp	rbx, rax
	jb	$LL6@ZSTD_compr
$LN376@ZSTD_compr:
	mov	rsi, QWORD PTR seqStore$[rsp]
	mov	r14, QWORD PTR src$[rsp]
	mov	r12d, DWORD PTR offset_2$1$[rsp]
$LN33@ZSTD_compr:

; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {
; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 769  :                     int const gain2 = (int)(mlRep * 4);
; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 772  :                         matchLength = mlRep, offset = 0, start = ip;
; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;
; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 783  :                         int const gain2 = (int)(mlRep * 4);
; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))
; 786  :                             matchLength = mlRep, offset = 0, start = ip;
; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;
; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);
; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {
; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	rbp, rbp
	je	SHORT $_storeSequence$383

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	mov	ecx, r10d
	mov	eax, r10d
	mov	rdx, r15
	sub	rdx, rbp
	add	rdx, 2
	cmp	r15, r14
	seta	cl
	cmp	rdx, r8
	seta	al
	test	ecx, eax
	je	SHORT $LN377@ZSTD_compr
	npad	3
$LL8@ZSTD_compr:
	movzx	eax, BYTE PTR [rdx-1]
	cmp	BYTE PTR [rdx+rbp-3], al
	jne	SHORT $LN377@ZSTD_compr

; 810  :                     { start--; matchLength++; }

	dec	r15
	dec	rdx
	inc	rdi
	mov	ecx, r10d
	cmp	rdx, r8
	mov	eax, r10d
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL8@ZSTD_compr
$LN377@ZSTD_compr:

; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));
; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;
; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;
; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */
; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	r12d, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [rbp-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	DWORD PTR offset_2$1$[rsp], r12d
$_storeSequence$383:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [rdi-3]
	mov	rbx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r13, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	sub	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r13
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r14, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	5
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r13
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
	lea	rdx, QWORD PTR [rdi-3]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rsi+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rbp+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN368@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN368@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r14, QWORD PTR [r15+rdi]
	cmp	r14, QWORD PTR ilimit$1$[rsp]

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	ecx, r10d
	mov	eax, r10d
	mov	QWORD PTR src$[rsp], r14
	setbe	cl
	mov	rbx, r14
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN379@ZSTD_compr
	mov	r15, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r14
	npad	4
$LL14@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	eax, r12d
	mov	rdx, rbx
	sub	rdx, rax
	mov	ebp, r12d
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	jne	$LN378@ZSTD_compr

; 853  :                 /* store sequence */
; 854  :                 matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r15
	call	ZSTD_count

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	r12d, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	DWORD PTR offset_1$1$[rsp], ebp
	lea	rdi, QWORD PTR [rax+4]

; 856  :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rbp, QWORD PTR [rdi-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r13
	ja	SHORT $LN310@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN311@ZSTD_compr
$LN310@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r13
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN311@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	xor	r10d, r10d
	mov	WORD PTR [rax+4], r10w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbp, 65535				; 0000ffffH
	jbe	SHORT $LN369@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN369@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 857  :                 ip += matchLength;

	lea	r14, QWORD PTR [rdi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 858  :                 anchor = ip;

	lea	rax, QWORD PTR [r15-8]
	cmp	r14, rax
	mov	ecx, r10d
	mov	eax, r10d
	mov	rbx, r14
	setbe	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	jne	$LL14@ZSTD_compr
$LN378@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], r12d

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	r13, r15
	mov	QWORD PTR src$[rsp], r14
	jmp	SHORT $LN15@ZSTD_compr
$LN379@ZSTD_compr:
	mov	r13, QWORD PTR iend$1$[rsp]
$LN15@ZSTD_compr:

; 690  :     while (ip < ilimit) {

	mov	r9d, DWORD PTR offset_1$1$[rsp]
	lea	rax, QWORD PTR [r13-8]
	cmp	rbx, rax
	jb	$LL4@ZSTD_compr
	mov	eax, DWORD PTR tv2307[rsp]
$LN5@ZSTD_compr:

; 859  :                 continue;   /* faster when present ... (?) */
; 860  :     }   }   }
; 861  : 
; 862  :     /* Save reps for next block */
; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	rdx, QWORD PTR rep$[rsp]
	test	r9d, r9d
	mov	ecx, eax
	cmovne	ecx, r9d

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	test	r12d, r12d
	cmovne	eax, r12d
	mov	DWORD PTR [rdx], ecx

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	r13, r14
	mov	DWORD PTR [rdx+4], eax

; 889  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_noDict);

	mov	rax, r13

; 890  : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_lazy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
iend$1$ = 32
offset_2$1$ = 40
dictIndexDelta$1$ = 44
prefixLowest$1$ = 48
base$1$ = 56
dictBase$1$ = 64
dictEnd$1$ = 72
offsetFound$1 = 80
dictLowest$1$ = 88
ilimit$1$ = 96
ms$ = 176
seqStore$ = 184
rep$ = 192
prefixLowestIndex$1$ = 200
src$ = 200
offset_1$1$ = 208
srcSize$ = 208
ZSTD_compressBlock_greedy_dictMatchState PROC

; 923  : {

$LN377:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	r10, QWORD PTR srcSize$[rsp]

; 923  : {

	mov	rbp, r8

; 635  :     const BYTE* const iend = istart + srcSize;

	add	r10, r9

; 923  : {

	mov	r8, rcx
	mov	r15, r9

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	QWORD PTR iend$1$[rsp], r10

; 923  : {

	mov	rbx, rdx

; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;

	mov	r13d, DWORD PTR [rbp]

; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR [r8+176]
	lea	rcx, QWORD PTR [r10-8]
	mov	rsi, QWORD PTR [r8+8]
	mov	edx, DWORD PTR [r8+24]
	mov	r12d, DWORD PTR [rbp+4]

; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?

	mov	r11, QWORD PTR [rax+8]

; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [rax+24]

; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?

	mov	r8d, r11d
	mov	rax, QWORD PTR [rax]
	lea	r9, QWORD PTR [rsi+rdx]
	sub	r8d, eax
	mov	QWORD PTR dictEnd$1$[rsp], rax
	add	rdi, r11
	mov	QWORD PTR prefixLowest$1$[rsp], r9
	add	r8d, edx
	mov	QWORD PTR dictLowest$1$[rsp], rdi

; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	mov	eax, r15d
	mov	QWORD PTR ilimit$1$[rsp], rcx
	sub	eax, edi
	mov	QWORD PTR base$1$[rsp], rsi
	sub	eax, r9d
	mov	DWORD PTR prefixLowestIndex$1$[rsp], edx
	mov	r9, QWORD PTR dictEnd$1$[rsp]
	mov	edi, 0
	add	eax, r9d
	mov	DWORD PTR offset_1$1$[rsp], r13d
	mov	eax, edi
	mov	DWORD PTR offset_2$1$[rsp], r12d
	sete	al
	mov	QWORD PTR dictBase$1$[rsp], r11
	mov	DWORD PTR dictIndexDelta$1$[rsp], r8d
	lea	r14, QWORD PTR [rax+r15]
	cmp	r14, rcx

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	npad	3
$LL4@ZSTD_compr:

; 691  :         size_t matchLength=0;
; 692  :         size_t offset=0;
; 693  :         const BYTE* start=ip+1;
; 694  : 
; 695  :         /* check repCode */
; 696  :         if (dictMode == ZSTD_dictMatchState) {
; 697  :             const U32 repIndex = (U32)(ip - base) + 1 - offset_1;

	mov	ecx, r14d
	lea	rbp, QWORD PTR [r14+1]
	sub	ecx, esi
	mov	r13, rdi
	sub	ecx, DWORD PTR offset_1$1$[rsp]
	inc	ecx

; 698  :             const BYTE* repMatch = (dictMode == ZSTD_dictMatchState

	cmp	ecx, edx
	jae	SHORT $LN60@ZSTD_compr
	mov	edi, ecx
	sub	edi, r8d
	add	rdi, r11
	jmp	SHORT $LN61@ZSTD_compr
$LN60@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rsi
$LN61@ZSTD_compr:

; 699  :                                 && repIndex < prefixLowestIndex) ?
; 700  :                                    dictBase + (repIndex - dictIndexDelta) :
; 701  :                                    base + repIndex;
; 702  :             if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, edx
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	SHORT $LN22@ZSTD_compr
	mov	eax, DWORD PTR [rbp]
	cmp	DWORD PTR [rdi], eax
	jne	SHORT $LN22@ZSTD_compr

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, edx

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r12, QWORD PTR [r14+5]
	mov	rsi, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r10
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r10
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN83@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r12]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN83@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 706  :                 if (depth==0) goto _storeSequence;

	mov	r12d, DWORD PTR offset_2$1$[rsp]
	lea	rdi, QWORD PTR [r14+4]
	jmp	$_storeSequence$378
$LN22@ZSTD_compr:

; 707  :             }
; 708  :         }
; 709  :         if ( dictMode == ZSTD_noDict
; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {
; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;
; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$1[rsp]
	mov	r8, r10
	mov	QWORD PTR offsetFound$1[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, r14
	call	ZSTD_HcFindBestMatch_dictMatchState_selectMLS
	mov	rdi, rax

; 718  :             if (ml2 > matchLength)

	test	rax, rax
	je	$LN370@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r13, QWORD PTR offsetFound$1[rsp]
	mov	rbp, r14

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rax, 4
	jb	$LN370@ZSTD_compr

; 724  :             continue;
; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {
; 730  :             ip ++;
; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 734  :                 int const gain2 = (int)(mlRep * 3);
; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))
; 737  :                     matchLength = mlRep, offset = 0, start = ip;
; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;
; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 748  :                     int const gain2 = (int)(mlRep * 3);
; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 751  :                         matchLength = mlRep, offset = 0, start = ip;
; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;
; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);
; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {
; 759  :                     matchLength = ml2, offset = offset2, start = ip;
; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {
; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 769  :                     int const gain2 = (int)(mlRep * 4);
; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 772  :                         matchLength = mlRep, offset = 0, start = ip;
; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;
; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 783  :                         int const gain2 = (int)(mlRep * 4);
; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))
; 786  :                             matchLength = mlRep, offset = 0, start = ip;
; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;
; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);
; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {
; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	r13, r13
	je	SHORT $_storeSequence$378

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */
; 810  :                     { start--; matchLength++; }
; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));
; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;

	mov	r9d, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	edx, r14d
	sub	edx, esi
	sub	edx, r13d
	add	edx, 2
	mov	r8d, edx
	cmp	edx, r9d
	jae	SHORT $LN66@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	mov	rcx, QWORD PTR dictBase$1$[rsp]
	sub	rcx, rax
	add	rcx, r8
	jmp	SHORT $LN67@ZSTD_compr
$LN66@ZSTD_compr:
	lea	rcx, QWORD PTR [rsi+rdx]
$LN67@ZSTD_compr:

; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	cmp	edx, r9d
	cmovb	r8, QWORD PTR dictLowest$1$[rsp]
	cmp	r14, r15

; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	jbe	SHORT $LN371@ZSTD_compr
	npad	1
$LL10@ZSTD_compr:
	cmp	rcx, r8
	jbe	SHORT $LN371@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [rbp-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN371@ZSTD_compr
	dec	rcx
	inc	rdi
	mov	rbp, rdx
	cmp	rdx, r15
	ja	SHORT $LL10@ZSTD_compr
$LN371@ZSTD_compr:

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	r12d, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [r13-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	DWORD PTR offset_2$1$[rsp], r12d
$_storeSequence$378:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	r14, QWORD PTR [rdi-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	mov	rsi, rbp
	sub	rsi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rdx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rsi+r15]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rdx
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rsi, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r15, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rsi
	npad	9
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r15]

; 289  :             COPY16(op, ip);

	lea	r15, QWORD PTR [r15+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	rdx, r15
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR iend$1$[rsp]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], rsi

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], si

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r13+1]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r14, 65535				; 0000ffffH
	jbe	SHORT $LN364@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN364@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r14w
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r15, QWORD PTR [rdi+rbp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	rdx, QWORD PTR [r9-8]
	mov	r14, r15
	cmp	r15, rdx

; 829  :             while (ip <= ilimit) {

	ja	$LN372@ZSTD_compr
	npad	8
$LL12@ZSTD_compr:

; 830  :                 U32 const current2 = (U32)(ip-base);
; 831  :                 U32 const repIndex = current2 - offset_2;

	mov	rsi, QWORD PTR base$1$[rsp]
	mov	ecx, r14d

; 832  :                 const BYTE* repMatch = dictMode == ZSTD_dictMatchState

	mov	edx, DWORD PTR prefixLowestIndex$1$[rsp]
	sub	ecx, esi
	sub	ecx, r12d
	mov	r13d, r12d
	mov	edi, ecx
	cmp	ecx, edx
	jae	SHORT $LN68@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rdi, rax
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN69@ZSTD_compr
$LN68@ZSTD_compr:
	add	rdi, rsi
$LN69@ZSTD_compr:

; 833  :                     && repIndex < prefixLowestIndex ?
; 834  :                         dictBase - dictIndexDelta + repIndex :
; 835  :                         base + repIndex;
; 836  :                 if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
; 837  :                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, edx
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN374@ZSTD_compr
	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR [rdi], eax
	jne	$LN374@ZSTD_compr

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, edx

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	lea	r12, QWORD PTR [r14+4]
	mov	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r9
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r9
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN248@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r12+rbp]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	rbp, rax
$LN248@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	r12d, DWORD PTR offset_1$1$[rsp]
	add	rbp, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	r9, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], r12d
	mov	DWORD PTR offset_1$1$[rsp], r13d

; 841  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rdx, QWORD PTR [r9-32]
	cmp	r15, rdx
	ja	SHORT $LN254@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN255@ZSTD_compr
$LN254@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	r8, r15
	mov	rdx, r15
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR iend$1$[rsp]
$LN255@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN365@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN365@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 842  :                     ip += matchLength;

	add	r14, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 829  :             while (ip <= ilimit) {

	lea	rdx, QWORD PTR [r9-8]

; 842  :                     ip += matchLength;

	mov	r15, r14
	cmp	r14, rdx
	jbe	$LL12@ZSTD_compr

; 829  :             while (ip <= ilimit) {

	mov	edx, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	rsi, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN45@ZSTD_compr
$LN370@ZSTD_compr:

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rcx, r14
	inc	r14
	sub	rcx, r15
	sar	rcx, 8
	add	r14, rcx

; 829  :             while (ip <= ilimit) {

	jmp	SHORT $LN375@ZSTD_compr
$LN372@ZSTD_compr:
	mov	rsi, QWORD PTR base$1$[rsp]
$LN375@ZSTD_compr:

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	mov	edx, DWORD PTR prefixLowestIndex$1$[rsp]
$LN374@ZSTD_compr:
	mov	r13d, DWORD PTR offset_1$1$[rsp]
$LN45@ZSTD_compr:
	mov	edi, 0
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r8d, DWORD PTR dictIndexDelta$1$[rsp]
	mov	r11, QWORD PTR dictBase$1$[rsp]
	mov	r9, QWORD PTR dictEnd$1$[rsp]
	cmp	r14, QWORD PTR ilimit$1$[rsp]
	jb	$LL4@ZSTD_compr
	mov	rbp, QWORD PTR rep$[rsp]
$LN5@ZSTD_compr:

; 925  : }

	mov	rbx, QWORD PTR [rsp+184]

; 867  :     return (size_t)(iend - anchor);

	sub	r10, r15

; 924  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_dictMatchState);

	mov	rax, r10

; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	DWORD PTR [rbp], r13d

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	mov	DWORD PTR [rbp+4], r12d

; 925  : }

	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressBlock_greedy_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
tv2277 = 32
tv2275 = 32
r$1 = 32
r$2 = 32
r$3 = 32
offset_2$1$ = 36
iend$1$ = 40
tv2278 = 48
r$4 = 48
r$5 = 48
r$6 = 48
tv2480 = 56
offsetFound$7 = 64
offset2$8 = 72
offset2$9 = 80
prefixLowest$1$ = 88
ilimit$1$ = 96
ms$ = 192
seqStore$ = 200
rep$ = 208
src$ = 216
offset_1$1$ = 224
srcSize$ = 224
ZSTD_compressBlock_btlazy2 PROC

; 874  : {

$LN382:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 120				; 00000078H

; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;

	mov	r10d, DWORD PTR [rcx+24]

; 874  : {

	mov	r15, rcx

; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [r8]

; 874  : {

	mov	r14, r9

; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;

	mov	r11d, DWORD PTR [r8+4]

; 874  : {

	mov	rsi, rdx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	r12, QWORD PTR srcSize$[rsp]

; 668  :     ip += (dictAndPrefixLength == 0);

	xor	r8d, r8d
	add	r12, r9
	mov	eax, r8d
	mov	r9, QWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	QWORD PTR iend$1$[rsp], r12

; 636  :     const BYTE* const ilimit = iend - 8;

	lea	rbp, QWORD PTR [r12-8]

; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;

	lea	rcx, QWORD PTR [r9+r10]
	mov	QWORD PTR ilimit$1$[rsp], rbp

; 668  :     ip += (dictAndPrefixLength == 0);

	cmp	r14d, ecx
	mov	QWORD PTR prefixLowest$1$[rsp], rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r15+184]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 668  :     ip += (dictAndPrefixLength == 0);

	sete	al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	edx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 668  :     ip += (dictAndPrefixLength == 0);

	lea	rbx, QWORD PTR [rax+r14]

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);

	mov	r8d, ebx
	sub	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, r8d
	sub	eax, r10d
	sub	ecx, edx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 690  :     while (ip < ilimit) {

	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, r10d
	cmp	DWORD PTR [r15+32], 0

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	xor	r10d, r10d
	sub	r8d, ecx
	mov	r13d, r10d
	cmp	r11d, r8d

; 690  :     while (ip < ilimit) {

	mov	r9d, r10d
	cmovbe	r13d, r11d
	cmovbe	r11d, r10d
	cmp	edi, r8d
	cmovbe	eax, r11d
	cmovbe	r9d, edi
	mov	DWORD PTR tv2480[rsp], eax
	cmp	rbx, rbp
	jae	$LN5@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	DWORD PTR offset_2$1$[rsp], r13d
	mov	DWORD PTR offset_1$1$[rsp], r9d
	npad	5
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {

	mov	eax, r9d
	lea	r15, QWORD PTR [rbx+1]
	mov	r8d, r10d
	mov	QWORD PTR tv2278[rsp], rax
	mov	ecx, r10d
	mov	rdx, rbx
	sub	rdx, rax
	mov	rdi, r10
	mov	eax, DWORD PTR [r15]
	test	r9d, r9d
	mov	rbp, r10
	setne	r8b
	cmp	DWORD PTR [rdx+1], eax
	mov	DWORD PTR tv2277[rsp], r8d
	sete	cl
	test	ecx, r8d
	je	SHORT $LN24@ZSTD_compr

; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;

	add	rdx, 5
	lea	rcx, QWORD PTR [rbx+5]
	mov	r8, r12
	call	ZSTD_count
	lea	rdi, QWORD PTR [rax+4]
$LN24@ZSTD_compr:

; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$7[rsp]
	mov	r8, r12
	mov	QWORD PTR offsetFound$7[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_selectMLS

; 718  :             if (ml2 > matchLength)

	cmp	rax, rdi
	jbe	SHORT $LN25@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	rbp, QWORD PTR offsetFound$7[rsp]
	mov	rdi, rax
	mov	r15, rbx
$LN25@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rdi, 4
	jae	SHORT $LN354@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rax, rbx
	inc	rbx
	sub	rax, r14
	sar	rax, 8
	add	rbx, rax

; 724  :             continue;

	xor	r10d, r10d
	jmp	$LN15@ZSTD_compr
$LN354@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [r12-8]
	cmp	rbx, rax
	jae	$LN40@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	r13d, DWORD PTR tv2277[rsp]
	mov	r14, QWORD PTR tv2278[rsp]
$LL6@ZSTD_compr:

; 730  :             ip ++;

	inc	rbx

; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	test	rbp, rbp
	je	SHORT $LN29@ZSTD_compr
	xor	r12d, r12d
	mov	rdx, rbx
	sub	rdx, r14
	mov	ecx, r12d
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	sete	cl
	test	ecx, r13d
	je	SHORT $LN29@ZSTD_compr

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, rsi
	call	ZSTD_count
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$1[rsp], r12d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rax+4]

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [rbp+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r12d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [rdi+rdi*2]
	sub	ecx, eax
	inc	ecx

; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN29@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN29@ZSTD_compr

; 737  :                     matchLength = mlRep, offset = 0, start = ip;

	mov	rdi, rdx
	mov	ebp, r12d
	mov	r15, rbx
$LN29@ZSTD_compr:

; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;
; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 748  :                     int const gain2 = (int)(mlRep * 3);
; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 751  :                         matchLength = mlRep, offset = 0, start = ip;
; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;
; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$8[rsp]
	mov	r8, rsi
	mov	QWORD PTR offset2$8[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_selectMLS

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$8[rsp]

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r12d, DWORD PTR [rdi*4]
	mov	rdx, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$3[rsp], r10d
	mov	DWORD PTR r$2[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	r8d, DWORD PTR [rdx*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	r8d, eax

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [rbp+1]
	mov	DWORD PTR tv2275[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	mov	eax, r12d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	eax, 4

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	rdx, 4
	jb	SHORT $LN33@ZSTD_compr
	cmp	r8d, eax
	jle	SHORT $LN33@ZSTD_compr

; 759  :                     matchLength = ml2, offset = offset2, start = ip;

	mov	rdi, rdx

; 760  :                     continue;   /* search a better one */

	jmp	$LN380@ZSTD_compr
$LN33@ZSTD_compr:

; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {

	lea	rax, QWORD PTR [rsi-8]
	cmp	rbx, rax
	jae	$LN376@ZSTD_compr

; 765  :                 ip ++;

	inc	rbx

; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	test	rbp, rbp
	je	SHORT $LN36@ZSTD_compr
	mov	ecx, r10d
	mov	rdx, rbx
	sub	rdx, r14
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	sete	cl
	test	ecx, r13d
	je	SHORT $LN36@ZSTD_compr

; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, rsi
	call	ZSTD_count
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r8d
	mov	DWORD PTR r$4[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rax+4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2275[rsp]
	cmovne	ecx, eax
	sub	r12d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r12d

; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN36@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r12d
	jle	SHORT $LN36@ZSTD_compr

; 772  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	rdi, rdx
	mov	ebp, r8d
	mov	r15, rbx
$LN36@ZSTD_compr:

; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;
; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 783  :                         int const gain2 = (int)(mlRep * 4);
; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))
; 786  :                             matchLength = mlRep, offset = 0, start = ip;
; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;
; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$9[rsp]
	mov	r8, rsi
	mov	QWORD PTR offset2$9[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_selectMLS

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$9[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$5[rsp], r10d
	mov	DWORD PTR r$6[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [rbp+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [rdi*4]
	sub	ecx, eax
	add	ecx, 7

; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN376@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN376@ZSTD_compr

; 794  :                         matchLength = ml2, offset = offset2, start = ip;

	mov	rdi, r8
$LN380@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [rsi-8]
	mov	r15, rbx
	mov	rbp, r9
	cmp	rbx, rax
	jb	$LL6@ZSTD_compr
$LN376@ZSTD_compr:
	mov	rsi, QWORD PTR seqStore$[rsp]
	mov	r14, QWORD PTR src$[rsp]
	mov	r13d, DWORD PTR offset_2$1$[rsp]
	mov	r12, QWORD PTR iend$1$[rsp]
$LN40@ZSTD_compr:

; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	rbp, rbp
	je	SHORT $_storeSequence$383

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	xor	r9d, r9d
	mov	ecx, r9d
	mov	eax, r9d
	mov	rdx, r15
	sub	rdx, rbp
	add	rdx, 2
	cmp	rdx, r8
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	je	SHORT $LN377@ZSTD_compr
	npad	7
$LL8@ZSTD_compr:
	movzx	eax, BYTE PTR [rdx-1]
	cmp	BYTE PTR [rdx+rbp-3], al
	jne	SHORT $LN377@ZSTD_compr

; 810  :                     { start--; matchLength++; }

	dec	r15
	dec	rdx
	inc	rdi
	mov	ecx, r9d
	cmp	rdx, r8
	mov	eax, r9d
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL8@ZSTD_compr
$LN377@ZSTD_compr:

; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));
; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;
; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;
; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */
; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	r13d, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [rbp-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	DWORD PTR offset_2$1$[rsp], r13d
$_storeSequence$383:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [rdi-3]
	mov	rbx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	sub	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r14, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	5
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
	lea	rdx, QWORD PTR [rdi-3]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rsi+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rbp+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN368@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN368@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r14, QWORD PTR [r15+rdi]
	cmp	r14, QWORD PTR ilimit$1$[rsp]

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	ecx, r10d
	mov	eax, r10d
	mov	QWORD PTR src$[rsp], r14
	setbe	cl
	mov	rbx, r14
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	$LN379@ZSTD_compr
	mov	r15, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r14
	npad	4
$LL14@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	eax, r13d
	mov	rdx, rbx
	sub	rdx, rax
	mov	ebp, r13d
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	jne	$LN378@ZSTD_compr

; 853  :                 /* store sequence */
; 854  :                 matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r15
	call	ZSTD_count

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	r13d, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	DWORD PTR offset_1$1$[rsp], ebp
	lea	rdi, QWORD PTR [rax+4]

; 856  :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rbp, QWORD PTR [rdi-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LN310@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN311@ZSTD_compr
$LN310@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN311@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	xor	r10d, r10d
	mov	WORD PTR [rax+4], r10w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbp, 65535				; 0000ffffH
	jbe	SHORT $LN369@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN369@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 857  :                 ip += matchLength;

	lea	r14, QWORD PTR [rdi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 858  :                 anchor = ip;

	lea	rax, QWORD PTR [r15-8]
	cmp	r14, rax
	mov	ecx, r10d
	mov	eax, r10d
	mov	rbx, r14
	setbe	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	jne	$LL14@ZSTD_compr
$LN378@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], r13d

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	r12, r15
	mov	QWORD PTR src$[rsp], r14
	jmp	SHORT $LN15@ZSTD_compr
$LN379@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
$LN15@ZSTD_compr:

; 690  :     while (ip < ilimit) {

	mov	r9d, DWORD PTR offset_1$1$[rsp]
	lea	rax, QWORD PTR [r12-8]
	cmp	rbx, rax
	jb	$LL4@ZSTD_compr
	mov	eax, DWORD PTR tv2480[rsp]
$LN5@ZSTD_compr:

; 859  :                 continue;   /* faster when present ... (?) */
; 860  :     }   }   }
; 861  : 
; 862  :     /* Save reps for next block */
; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	rdx, QWORD PTR rep$[rsp]
	test	r9d, r9d
	mov	ecx, eax
	cmovne	ecx, r9d

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	test	r13d, r13d
	cmovne	eax, r13d
	mov	DWORD PTR [rdx], ecx

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	r12, r14
	mov	DWORD PTR [rdx+4], eax

; 875  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_noDict);

	mov	rax, r12

; 876  : }

	add	rsp, 120				; 00000078H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_btlazy2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
tv2277 = 32
tv2275 = 32
r$1 = 32
r$2 = 32
r$3 = 32
offset_2$1$ = 36
iend$1$ = 40
tv2278 = 48
r$4 = 48
r$5 = 48
r$6 = 48
tv2480 = 56
offsetFound$7 = 64
offset2$8 = 72
offset2$9 = 80
prefixLowest$1$ = 88
ilimit$1$ = 96
ms$ = 192
seqStore$ = 200
rep$ = 208
src$ = 216
offset_1$1$ = 224
srcSize$ = 224
ZSTD_compressBlock_lazy2 PROC

; 881  : {

$LN382:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 120				; 00000078H

; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;

	mov	r10d, DWORD PTR [rcx+24]

; 881  : {

	mov	r15, rcx

; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [r8]

; 881  : {

	mov	r14, r9

; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;

	mov	r11d, DWORD PTR [r8+4]

; 881  : {

	mov	rsi, rdx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	r12, QWORD PTR srcSize$[rsp]

; 668  :     ip += (dictAndPrefixLength == 0);

	xor	r8d, r8d
	add	r12, r9
	mov	eax, r8d
	mov	r9, QWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	QWORD PTR iend$1$[rsp], r12

; 636  :     const BYTE* const ilimit = iend - 8;

	lea	rbp, QWORD PTR [r12-8]

; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;

	lea	rcx, QWORD PTR [r9+r10]
	mov	QWORD PTR ilimit$1$[rsp], rbp

; 668  :     ip += (dictAndPrefixLength == 0);

	cmp	r14d, ecx
	mov	QWORD PTR prefixLowest$1$[rsp], rcx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r15+184]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 668  :     ip += (dictAndPrefixLength == 0);

	sete	al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	edx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 668  :     ip += (dictAndPrefixLength == 0);

	lea	rbx, QWORD PTR [rax+r14]

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);

	mov	r8d, ebx
	sub	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, r8d
	sub	eax, r10d
	sub	ecx, edx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 690  :     while (ip < ilimit) {

	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, r10d
	cmp	DWORD PTR [r15+32], 0

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	xor	r10d, r10d
	sub	r8d, ecx
	mov	r13d, r10d
	cmp	r11d, r8d

; 690  :     while (ip < ilimit) {

	mov	r9d, r10d
	cmovbe	r13d, r11d
	cmovbe	r11d, r10d
	cmp	edi, r8d
	cmovbe	eax, r11d
	cmovbe	r9d, edi
	mov	DWORD PTR tv2480[rsp], eax
	cmp	rbx, rbp
	jae	$LN5@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	DWORD PTR offset_2$1$[rsp], r13d
	mov	DWORD PTR offset_1$1$[rsp], r9d
	npad	5
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {

	mov	eax, r9d
	lea	r15, QWORD PTR [rbx+1]
	mov	r8d, r10d
	mov	QWORD PTR tv2278[rsp], rax
	mov	ecx, r10d
	mov	rdx, rbx
	sub	rdx, rax
	mov	rdi, r10
	mov	eax, DWORD PTR [r15]
	test	r9d, r9d
	mov	rbp, r10
	setne	r8b
	cmp	DWORD PTR [rdx+1], eax
	mov	DWORD PTR tv2277[rsp], r8d
	sete	cl
	test	ecx, r8d
	je	SHORT $LN24@ZSTD_compr

; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;

	add	rdx, 5
	lea	rcx, QWORD PTR [rbx+5]
	mov	r8, r12
	call	ZSTD_count
	lea	rdi, QWORD PTR [rax+4]
$LN24@ZSTD_compr:

; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$7[rsp]
	mov	r8, r12
	mov	QWORD PTR offsetFound$7[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_selectMLS

; 718  :             if (ml2 > matchLength)

	cmp	rax, rdi
	jbe	SHORT $LN25@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	rbp, QWORD PTR offsetFound$7[rsp]
	mov	rdi, rax
	mov	r15, rbx
$LN25@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rdi, 4
	jae	SHORT $LN354@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rax, rbx
	inc	rbx
	sub	rax, r14
	sar	rax, 8
	add	rbx, rax

; 724  :             continue;

	xor	r10d, r10d
	jmp	$LN15@ZSTD_compr
$LN354@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [r12-8]
	cmp	rbx, rax
	jae	$LN40@ZSTD_compr
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	r13d, DWORD PTR tv2277[rsp]
	mov	r14, QWORD PTR tv2278[rsp]
$LL6@ZSTD_compr:

; 730  :             ip ++;

	inc	rbx

; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	test	rbp, rbp
	je	SHORT $LN29@ZSTD_compr
	xor	r12d, r12d
	mov	rdx, rbx
	sub	rdx, r14
	mov	ecx, r12d
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	sete	cl
	test	ecx, r13d
	je	SHORT $LN29@ZSTD_compr

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, rsi
	call	ZSTD_count
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$1[rsp], r12d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rax+4]

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [rbp+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r12d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [rdi+rdi*2]
	sub	ecx, eax
	inc	ecx

; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN29@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN29@ZSTD_compr

; 737  :                     matchLength = mlRep, offset = 0, start = ip;

	mov	rdi, rdx
	mov	ebp, r12d
	mov	r15, rbx
$LN29@ZSTD_compr:

; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;
; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 748  :                     int const gain2 = (int)(mlRep * 3);
; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 751  :                         matchLength = mlRep, offset = 0, start = ip;
; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;
; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$8[rsp]
	mov	r8, rsi
	mov	QWORD PTR offset2$8[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_selectMLS

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$8[rsp]

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r12d, DWORD PTR [rdi*4]
	mov	rdx, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$3[rsp], r10d
	mov	DWORD PTR r$2[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	r8d, DWORD PTR [rdx*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	r8d, eax

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [rbp+1]
	mov	DWORD PTR tv2275[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	mov	eax, r12d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	eax, 4

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	rdx, 4
	jb	SHORT $LN33@ZSTD_compr
	cmp	r8d, eax
	jle	SHORT $LN33@ZSTD_compr

; 759  :                     matchLength = ml2, offset = offset2, start = ip;

	mov	rdi, rdx

; 760  :                     continue;   /* search a better one */

	jmp	$LN380@ZSTD_compr
$LN33@ZSTD_compr:

; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {

	lea	rax, QWORD PTR [rsi-8]
	cmp	rbx, rax
	jae	$LN376@ZSTD_compr

; 765  :                 ip ++;

	inc	rbx

; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	test	rbp, rbp
	je	SHORT $LN36@ZSTD_compr
	mov	ecx, r10d
	mov	rdx, rbx
	sub	rdx, r14
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	sete	cl
	test	ecx, r13d
	je	SHORT $LN36@ZSTD_compr

; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, rsi
	call	ZSTD_count
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r8d
	mov	DWORD PTR r$4[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rax+4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2275[rsp]
	cmovne	ecx, eax
	sub	r12d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r12d

; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN36@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r12d
	jle	SHORT $LN36@ZSTD_compr

; 772  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	rdi, rdx
	mov	ebp, r8d
	mov	r15, rbx
$LN36@ZSTD_compr:

; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;
; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 783  :                         int const gain2 = (int)(mlRep * 4);
; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))
; 786  :                             matchLength = mlRep, offset = 0, start = ip;
; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;
; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$9[rsp]
	mov	r8, rsi
	mov	QWORD PTR offset2$9[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_selectMLS

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$9[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$5[rsp], r10d
	mov	DWORD PTR r$6[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [rbp+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [rdi*4]
	sub	ecx, eax
	add	ecx, 7

; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN376@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN376@ZSTD_compr

; 794  :                         matchLength = ml2, offset = offset2, start = ip;

	mov	rdi, r8
$LN380@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [rsi-8]
	mov	r15, rbx
	mov	rbp, r9
	cmp	rbx, rax
	jb	$LL6@ZSTD_compr
$LN376@ZSTD_compr:
	mov	rsi, QWORD PTR seqStore$[rsp]
	mov	r14, QWORD PTR src$[rsp]
	mov	r13d, DWORD PTR offset_2$1$[rsp]
	mov	r12, QWORD PTR iend$1$[rsp]
$LN40@ZSTD_compr:

; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	rbp, rbp
	je	SHORT $_storeSequence$383

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	xor	r9d, r9d
	mov	ecx, r9d
	mov	eax, r9d
	mov	rdx, r15
	sub	rdx, rbp
	add	rdx, 2
	cmp	rdx, r8
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	je	SHORT $LN377@ZSTD_compr
	npad	7
$LL8@ZSTD_compr:
	movzx	eax, BYTE PTR [rdx-1]
	cmp	BYTE PTR [rdx+rbp-3], al
	jne	SHORT $LN377@ZSTD_compr

; 810  :                     { start--; matchLength++; }

	dec	r15
	dec	rdx
	inc	rdi
	mov	ecx, r9d
	cmp	rdx, r8
	mov	eax, r9d
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL8@ZSTD_compr
$LN377@ZSTD_compr:

; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));
; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;
; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;
; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */
; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	r13d, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [rbp-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	DWORD PTR offset_2$1$[rsp], r13d
$_storeSequence$383:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [rdi-3]
	mov	rbx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	sub	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r14, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	5
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
	lea	rdx, QWORD PTR [rdi-3]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rsi+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rbp+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN368@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN368@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r14, QWORD PTR [r15+rdi]
	cmp	r14, QWORD PTR ilimit$1$[rsp]

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	ecx, r10d
	mov	eax, r10d
	mov	QWORD PTR src$[rsp], r14
	setbe	cl
	mov	rbx, r14
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	$LN379@ZSTD_compr
	mov	r15, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r14
	npad	4
$LL14@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	eax, r13d
	mov	rdx, rbx
	sub	rdx, rax
	mov	ebp, r13d
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rbx], eax
	jne	$LN378@ZSTD_compr

; 853  :                 /* store sequence */
; 854  :                 matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;

	add	rdx, 4
	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r15
	call	ZSTD_count

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	r13d, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	DWORD PTR offset_1$1$[rsp], ebp
	lea	rdi, QWORD PTR [rax+4]

; 856  :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rbp, QWORD PTR [rdi-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LN310@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN311@ZSTD_compr
$LN310@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN311@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	xor	r10d, r10d
	mov	WORD PTR [rax+4], r10w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbp, 65535				; 0000ffffH
	jbe	SHORT $LN369@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN369@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 857  :                 ip += matchLength;

	lea	r14, QWORD PTR [rdi+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 858  :                 anchor = ip;

	lea	rax, QWORD PTR [r15-8]
	cmp	r14, rax
	mov	ecx, r10d
	mov	eax, r10d
	mov	rbx, r14
	setbe	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	jne	$LL14@ZSTD_compr
$LN378@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], r13d

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	r12, r15
	mov	QWORD PTR src$[rsp], r14
	jmp	SHORT $LN15@ZSTD_compr
$LN379@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
$LN15@ZSTD_compr:

; 690  :     while (ip < ilimit) {

	mov	r9d, DWORD PTR offset_1$1$[rsp]
	lea	rax, QWORD PTR [r12-8]
	cmp	rbx, rax
	jb	$LL4@ZSTD_compr
	mov	eax, DWORD PTR tv2480[rsp]
$LN5@ZSTD_compr:

; 859  :                 continue;   /* faster when present ... (?) */
; 860  :     }   }   }
; 861  : 
; 862  :     /* Save reps for next block */
; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	rdx, QWORD PTR rep$[rsp]
	test	r9d, r9d
	mov	ecx, eax
	cmovne	ecx, r9d

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	test	r13d, r13d
	cmovne	eax, r13d
	mov	DWORD PTR [rdx], ecx

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	r12, r14
	mov	DWORD PTR [rdx+4], eax

; 882  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_noDict);

	mov	rax, r12

; 883  : }

	add	rsp, 120				; 00000078H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_lazy2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
iend$1$ = 32
offset_1$1$ = 40
offset_2$1$ = 44
dictIndexDelta$1$ = 48
tv2467 = 52
r$1 = 52
r$2 = 52
r$3 = 52
offset$1$ = 56
prefixLowest$1$ = 72
base$1$ = 80
dictBase$1$ = 88
dictEnd$1$ = 96
offsetFound$4 = 104
ilimit$1$ = 112
offset2$5 = 120
offset2$6 = 128
dictLowest$1$ = 136
ms$ = 224
seqStore$ = 232
rep$ = 240
src$ = 248
prefixLowestIndex$1$ = 256
srcSize$ = 256
ZSTD_compressBlock_btlazy2_dictMatchState PROC

; 902  : {

$LN389:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	mov	r10, rcx
	mov	r14, r8
	mov	r13, r9
	mov	r15, rdx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	rdx, QWORD PTR srcSize$[rsp]
	add	rdx, r9

; 636  :     const BYTE* const ilimit = iend - 8;
; 637  :     const BYTE* const base = ms->window.base;
; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;
; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;
; 640  : 
; 641  :     typedef size_t (*searchMax_f)(
; 642  :                         ZSTD_matchState_t* ms,
; 643  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?
; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR [r10+176]
	mov	r8, QWORD PTR [r10+8]
	mov	esi, DWORD PTR [r10+24]
	mov	r9d, DWORD PTR [r14]
	lea	rcx, QWORD PTR [rdx-8]

; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?

	mov	r11, QWORD PTR [rax+8]

; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [rax+24]

; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?

	mov	r10d, r11d
	mov	rax, QWORD PTR [rax]
	lea	rbx, QWORD PTR [r8+rsi]
	mov	ebp, DWORD PTR [r14+4]
	sub	r10d, eax
	add	rdi, r11
	mov	QWORD PTR dictEnd$1$[rsp], rax

; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	sub	eax, edi
	mov	QWORD PTR dictLowest$1$[rsp], rdi
	sub	eax, ebx
	mov	QWORD PTR prefixLowest$1$[rsp], rbx
	add	r10d, esi
	mov	QWORD PTR iend$1$[rsp], rdx
	add	eax, r13d
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	edi, 0
	mov	QWORD PTR base$1$[rsp], r8
	mov	eax, edi
	mov	DWORD PTR prefixLowestIndex$1$[rsp], esi
	sete	al
	mov	DWORD PTR offset_1$1$[rsp], r9d
	mov	DWORD PTR offset_2$1$[rsp], ebp
	mov	QWORD PTR dictBase$1$[rsp], r11
	mov	DWORD PTR dictIndexDelta$1$[rsp], r10d
	lea	rbx, QWORD PTR [rax+r13]
	cmp	rbx, rcx

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	QWORD PTR [rsp+152], r12
$LL4@ZSTD_compr:

; 691  :         size_t matchLength=0;
; 692  :         size_t offset=0;
; 693  :         const BYTE* start=ip+1;
; 694  : 
; 695  :         /* check repCode */
; 696  :         if (dictMode == ZSTD_dictMatchState) {
; 697  :             const U32 repIndex = (U32)(ip - base) + 1 - offset_1;

	mov	ecx, ebx
	mov	QWORD PTR offset$1$[rsp], rdi
	sub	ecx, r8d
	lea	r12, QWORD PTR [rbx+1]
	sub	ecx, r9d
	mov	rbp, rdi
	inc	ecx
	mov	r14, rdi

; 698  :             const BYTE* repMatch = (dictMode == ZSTD_dictMatchState

	cmp	ecx, esi
	jae	SHORT $LN60@ZSTD_compr
	mov	edi, ecx
	sub	edi, r10d
	add	rdi, r11
	jmp	SHORT $LN61@ZSTD_compr
$LN60@ZSTD_compr:
	mov	edi, ecx
	add	rdi, r8
$LN61@ZSTD_compr:

; 699  :                                 && repIndex < prefixLowestIndex) ?
; 700  :                                    dictBase + (repIndex - dictIndexDelta) :
; 701  :                                    base + repIndex;
; 702  :             if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	SHORT $LN22@ZSTD_compr
	mov	eax, DWORD PTR [r12]
	cmp	DWORD PTR [rdi], eax
	jne	SHORT $LN22@ZSTD_compr

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	rsi, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdx
	lea	rcx, QWORD PTR [rbx+5]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, rdx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+5]
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN83@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rbp+5]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	add	rcx, rbx
	call	ZSTD_count
	add	rbp, rax
$LN83@ZSTD_compr:
	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rbp, 4
	mov	rdx, QWORD PTR iend$1$[rsp]
$LN22@ZSTD_compr:

; 706  :                 if (depth==0) goto _storeSequence;
; 707  :             }
; 708  :         }
; 709  :         if ( dictMode == ZSTD_noDict
; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {
; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;
; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$4[rsp]
	mov	r8, rdx
	mov	QWORD PTR offsetFound$4[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_dictMatchState_selectMLS

; 718  :             if (ml2 > matchLength)

	cmp	rax, rbp
	jbe	SHORT $LN25@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r14, QWORD PTR offsetFound$4[rsp]
	mov	rbp, rax
	mov	QWORD PTR offset$1$[rsp], r14
	mov	r12, rbx
$LN25@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rbp, 4
	jae	SHORT $LN354@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */
; 724  :             continue;

	mov	rdx, QWORD PTR ilimit$1$[rsp]
	mov	rax, rbx
	sub	rax, r13
	inc	rbx
	sar	rax, 8
	add	rbx, rax
$LN384@ZSTD_compr:

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	mov	ebp, DWORD PTR offset_2$1$[rsp]
$LN45@ZSTD_compr:
	mov	r8, QWORD PTR base$1$[rsp]
	cmp	rbx, rdx
	mov	rdx, QWORD PTR iend$1$[rsp]
	mov	edi, 0
	mov	r9d, DWORD PTR offset_1$1$[rsp]
	mov	r10d, DWORD PTR dictIndexDelta$1$[rsp]
	mov	r11, QWORD PTR dictBase$1$[rsp]
	jb	$LL4@ZSTD_compr
	mov	r14, QWORD PTR rep$[rsp]
	mov	r12, QWORD PTR [rsp+152]
$LN5@ZSTD_compr:

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	rdx, r13
	mov	DWORD PTR [r14], r9d

; 903  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_dictMatchState);

	mov	rax, rdx

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	mov	DWORD PTR [r14+4], ebp

; 904  : }

	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN354@ZSTD_compr:

; 729  :         while (ip<ilimit) {

	cmp	rbx, QWORD PTR ilimit$1$[rsp]
	jae	$LN40@ZSTD_compr
	mov	r14, QWORD PTR iend$1$[rsp]
	npad	13
$LL6@ZSTD_compr:

; 730  :             ip ++;
; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 734  :                 int const gain2 = (int)(mlRep * 3);
; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))
; 737  :                     matchLength = mlRep, offset = 0, start = ip;
; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	rax, QWORD PTR base$1$[rsp]
	inc	rbx
	mov	ecx, ebx
	sub	ecx, eax
	sub	ecx, DWORD PTR offset_1$1$[rsp]

; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, esi
	jae	SHORT $LN62@ZSTD_compr
	mov	edi, ecx
	sub	edi, DWORD PTR dictIndexDelta$1$[rsp]
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN63@ZSTD_compr
$LN62@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rax
$LN63@ZSTD_compr:

; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN378@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN378@ZSTD_compr

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r13, QWORD PTR [rbx+4]
	mov	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r13
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r14
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN160@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r13]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN160@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	mov	r15, QWORD PTR offset$1$[rsp]
	lea	rdx, QWORD PTR [r14+4]

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edi, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	r14, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$3[rsp], edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [rbp*2]
	add	ecx, ebp
	sub	ecx, eax
	inc	ecx

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN32@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN32@ZSTD_compr

; 751  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	rbp, rdx
	mov	QWORD PTR offset$1$[rsp], rdi
	mov	r15d, edi
	mov	r12, rbx
	jmp	SHORT $LN32@ZSTD_compr
$LN378@ZSTD_compr:

; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;

	mov	r15, QWORD PTR offset$1$[rsp]
	xor	edi, edi
$LN32@ZSTD_compr:

; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$5[rsp]
	mov	r8, r14
	mov	QWORD PTR offset2$5[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_dictMatchState_selectMLS

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$5[rsp]

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r13d, DWORD PTR [rbp*4]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$2[rsp], edi
	mov	DWORD PTR r$1[rsp], edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [r15+1]
	mov	DWORD PTR tv2467[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	mov	eax, r13d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	eax, 4

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN33@ZSTD_compr
	cmp	edx, eax
	jg	$LN387@ZSTD_compr
$LN33@ZSTD_compr:

; 759  :                     matchLength = ml2, offset = offset2, start = ip;
; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {

	lea	rax, QWORD PTR [r14-8]
	cmp	rbx, rax
	jae	$LN375@ZSTD_compr

; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 769  :                     int const gain2 = (int)(mlRep * 4);
; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 772  :                         matchLength = mlRep, offset = 0, start = ip;
; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	rax, QWORD PTR base$1$[rsp]
	inc	rbx
	mov	ecx, ebx
	sub	ecx, eax
	sub	ecx, DWORD PTR offset_1$1$[rsp]

; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, esi
	jae	SHORT $LN64@ZSTD_compr
	mov	edi, ecx
	sub	edi, DWORD PTR dictIndexDelta$1$[rsp]
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN65@ZSTD_compr
$LN64@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rax
$LN65@ZSTD_compr:

; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN386@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN386@ZSTD_compr

; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r14
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN210@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+4]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	add	rcx, rbx
	call	ZSTD_count
	add	r14, rax
$LN210@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
	lea	rdx, QWORD PTR [r14+4]
	mov	r14, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edi, edi

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2467[rsp]
	mov	ecx, edi
	cmovne	ecx, eax
	sub	r13d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r13d

; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN39@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r13d
	jle	SHORT $LN39@ZSTD_compr

; 786  :                             matchLength = mlRep, offset = 0, start = ip;

	mov	rbp, rdx
	mov	QWORD PTR offset$1$[rsp], rdi
	mov	r15d, edi
	mov	r12, rbx
	jmp	SHORT $LN39@ZSTD_compr
$LN386@ZSTD_compr:

; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;

	xor	edi, edi
$LN39@ZSTD_compr:

; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$6[rsp]
	mov	r8, r14
	mov	QWORD PTR offset2$6[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_dictMatchState_selectMLS

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$6[rsp]
	mov	r8, rax
	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [rbp*4]
	sub	ecx, eax
	add	ecx, 7

; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN375@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN375@ZSTD_compr
$LN387@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [r14-8]
	mov	QWORD PTR offset$1$[rsp], r9
	mov	r12, rbx
	mov	rbp, r8
	cmp	rbx, rax
	jb	$LL6@ZSTD_compr
$LN375@ZSTD_compr:
	mov	r15, QWORD PTR seqStore$[rsp]
	mov	r13, QWORD PTR src$[rsp]
	mov	r14, QWORD PTR offset$1$[rsp]
$LN40@ZSTD_compr:

; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	r14, r14
	je	SHORT $_storeSequence$390

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */
; 810  :                     { start--; matchLength++; }
; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	rax, QWORD PTR base$1$[rsp]
	mov	edx, r12d
	sub	edx, r14d
	sub	edx, eax
	add	edx, 2
	mov	ecx, edx

; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;

	cmp	edx, esi
	jae	SHORT $LN66@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rcx, rax
	add	rcx, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN67@ZSTD_compr
$LN66@ZSTD_compr:
	add	rcx, rax
$LN67@ZSTD_compr:

; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	cmp	edx, esi
	cmovb	r8, QWORD PTR dictLowest$1$[rsp]

; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	r12, r13
	jbe	SHORT $LN376@ZSTD_compr
$LL10@ZSTD_compr:
	cmp	rcx, r8
	jbe	SHORT $LN376@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [r12-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN376@ZSTD_compr
	dec	rcx
	inc	rbp
	mov	r12, rdx
	cmp	rdx, r13
	ja	SHORT $LL10@ZSTD_compr
$LN376@ZSTD_compr:

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], eax
	lea	eax, DWORD PTR [r14-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
$_storeSequence$390:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	mov	rbx, r12
	sub	rbx, r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rdx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r13]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rdx
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	lea	rcx, QWORD PTR [r13+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rdx, rax
	npad	10
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	rdx, r13
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR iend$1$[rsp]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r15+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [r15+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 1
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN368@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN368@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r13, QWORD PTR [r12+rbp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r15+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	rdx, QWORD PTR [r9-8]
	mov	QWORD PTR src$[rsp], r13
	mov	rbx, r13
	cmp	r13, rdx

; 829  :             while (ip <= ilimit) {

	ja	$LN384@ZSTD_compr
	mov	ebp, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r13
	npad	2
$LL12@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 831  :                 U32 const repIndex = current2 - offset_2;

	mov	rax, QWORD PTR base$1$[rsp]
	mov	ecx, ebx
	sub	ecx, eax
	mov	r12d, ebp
	sub	ecx, ebp
	mov	edi, ecx

; 832  :                 const BYTE* repMatch = dictMode == ZSTD_dictMatchState

	cmp	ecx, esi
	jae	SHORT $LN68@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rdi, rax
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN69@ZSTD_compr
$LN68@ZSTD_compr:
	add	rdi, rax
$LN69@ZSTD_compr:

; 833  :                     && repIndex < prefixLowestIndex ?
; 834  :                         dictBase - dictIndexDelta + repIndex :
; 835  :                         base + repIndex;
; 836  :                 if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
; 837  :                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN377@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN377@ZSTD_compr

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	lea	rbp, QWORD PTR [rbx+4]
	mov	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r9
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r9
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN248@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+rbp]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN248@ZSTD_compr:

; 456  :     if (litEnd <= litLimit_w) {

	mov	r9, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	r14, 4

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	ebp, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_1$1$[rsp], r12d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rdx, QWORD PTR [r9-32]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 841  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r13, rdx
	ja	SHORT $LN254@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN255@ZSTD_compr
$LN254@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	r8, r13
	mov	rdx, r13
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR iend$1$[rsp]
$LN255@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [r15+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN369@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN369@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 829  :             while (ip <= ilimit) {

	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
	lea	rdx, QWORD PTR [r9-8]

; 842  :                     ip += matchLength;

	add	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r15+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 842  :                     ip += matchLength;

	mov	r13, rbx
	cmp	rbx, rdx
	jbe	$LL12@ZSTD_compr
$LN377@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], ebp
	mov	QWORD PTR src$[rsp], r13

; 829  :             while (ip <= ilimit) {

	jmp	$LN45@ZSTD_compr
ZSTD_compressBlock_btlazy2_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
iend$1$ = 32
prefixLowestIndex$1$ = 40
offset_2$1$ = 44
offset$1$ = 48
dictIndexDelta$1$ = 56
base$1$ = 64
prefixLowest$1$ = 72
dictBase$1$ = 80
dictEnd$1$ = 88
offsetFound$1 = 96
offset2$2 = 104
ilimit$1$ = 112
dictLowest$1$ = 120
ms$ = 208
seqStore$ = 216
rep$ = 224
src$ = 232
offset_1$1$ = 240
srcSize$ = 240
ZSTD_compressBlock_lazy_dictMatchState PROC

; 916  : {

$LN389:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H

; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;

	mov	r12d, DWORD PTR [r8]

; 916  : {

	mov	r10, rcx
	mov	r15, r9
	mov	rbp, rdx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	r9, QWORD PTR srcSize$[rsp]

; 916  : {

	mov	r14, r8

; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;

	mov	r8d, DWORD PTR [r8+4]
	add	r9, r15

; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR [r10+176]
	mov	rsi, QWORD PTR [r10+8]
	mov	edx, DWORD PTR [r10+24]
	lea	rcx, QWORD PTR [r9-8]
	mov	QWORD PTR iend$1$[rsp], r9

; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?

	mov	r11, QWORD PTR [rax+8]

; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [rax+24]

; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?

	mov	r10d, r11d
	mov	rax, QWORD PTR [rax]
	lea	rbx, QWORD PTR [rsi+rdx]
	sub	r10d, eax
	mov	QWORD PTR dictEnd$1$[rsp], rax
	add	rdi, r11
	mov	QWORD PTR prefixLowest$1$[rsp], rbx

; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	sub	eax, edi
	mov	QWORD PTR dictLowest$1$[rsp], rdi
	sub	eax, ebx
	mov	QWORD PTR ilimit$1$[rsp], rcx
	add	r10d, edx
	mov	QWORD PTR base$1$[rsp], rsi
	add	eax, r15d
	mov	DWORD PTR prefixLowestIndex$1$[rsp], edx
	mov	edi, 0
	mov	DWORD PTR offset_1$1$[rsp], r12d
	mov	eax, edi
	mov	DWORD PTR offset_2$1$[rsp], r8d
	sete	al
	mov	QWORD PTR dictBase$1$[rsp], r11
	mov	DWORD PTR dictIndexDelta$1$[rsp], r10d
	lea	rbx, QWORD PTR [rax+r15]
	cmp	rbx, rcx

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	QWORD PTR [rsp+136], r13
	npad	1
$LL4@ZSTD_compr:

; 691  :         size_t matchLength=0;
; 692  :         size_t offset=0;
; 693  :         const BYTE* start=ip+1;
; 694  : 
; 695  :         /* check repCode */
; 696  :         if (dictMode == ZSTD_dictMatchState) {
; 697  :             const U32 repIndex = (U32)(ip - base) + 1 - offset_1;

	mov	ecx, ebx
	mov	QWORD PTR offset$1$[rsp], rdi
	sub	ecx, esi
	lea	r13, QWORD PTR [rbx+1]
	sub	ecx, r12d
	mov	r14, rdi
	inc	ecx

; 698  :             const BYTE* repMatch = (dictMode == ZSTD_dictMatchState

	cmp	ecx, edx
	jae	SHORT $LN60@ZSTD_compr
	mov	edi, ecx
	sub	edi, r10d
	add	rdi, r11
	jmp	SHORT $LN61@ZSTD_compr
$LN60@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rsi
$LN61@ZSTD_compr:

; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, edx
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	SHORT $LN385@ZSTD_compr
	mov	eax, DWORD PTR [r13]
	cmp	DWORD PTR [rdi], eax
	jne	SHORT $LN385@ZSTD_compr

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, edx

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r12, QWORD PTR [rbx+5]
	mov	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r9
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r9
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	mov	rdi, QWORD PTR iend$1$[rsp]
	cmp	rax, rsi
	jne	SHORT $LN83@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	lea	rcx, QWORD PTR [r14+r12]
	mov	r8, rdi
	call	ZSTD_count
	add	r14, rax
$LN83@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	rsi, QWORD PTR base$1$[rsp]

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	r14, 4
	mov	r12d, DWORD PTR offset_1$1$[rsp]
	jmp	SHORT $LN22@ZSTD_compr
$LN385@ZSTD_compr:

; 706  :                 if (depth==0) goto _storeSequence;
; 707  :             }
; 708  :         }
; 709  :         if ( dictMode == ZSTD_noDict
; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {
; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;
; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;

	mov	rdi, QWORD PTR iend$1$[rsp]
$LN22@ZSTD_compr:

; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$1[rsp]
	mov	r8, rdi
	mov	QWORD PTR offsetFound$1[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_dictMatchState_selectMLS

; 718  :             if (ml2 > matchLength)

	cmp	rax, r14
	jbe	SHORT $LN382@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r9, QWORD PTR offsetFound$1[rsp]
	mov	r14, rax
	mov	QWORD PTR offset$1$[rsp], r9
	mov	r13, rbx
	jmp	SHORT $LN25@ZSTD_compr
$LN382@ZSTD_compr:

; 718  :             if (ml2 > matchLength)

	mov	r9, QWORD PTR offset$1$[rsp]
$LN25@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	r14, 4
	jae	SHORT $LN354@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */
; 724  :             continue;

	mov	rdx, QWORD PTR ilimit$1$[rsp]
	mov	rax, rbx
	sub	rax, r15
	inc	rbx
	sar	rax, 8
	add	rbx, rax
	jmp	$LN45@ZSTD_compr
$LN354@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [rdi-8]
	cmp	rbx, rax
	jae	$LN33@ZSTD_compr
	mov	ebp, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	r15, QWORD PTR iend$1$[rsp]
	npad	5
$LL6@ZSTD_compr:

; 730  :             ip ++;

	inc	rbx

; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 734  :                 int const gain2 = (int)(mlRep * 3);
; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))
; 737  :                     matchLength = mlRep, offset = 0, start = ip;
; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	ecx, ebx
	sub	ecx, esi
	sub	ecx, r12d

; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, ebp
	jae	SHORT $LN62@ZSTD_compr
	mov	edi, ecx
	sub	edi, DWORD PTR dictIndexDelta$1$[rsp]
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN63@ZSTD_compr
$LN62@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rsi
$LN63@ZSTD_compr:

; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, ebp
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN378@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN378@ZSTD_compr

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, ebp
	mov	rsi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r15
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r12, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN160@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r12
	mov	r8, r15
	call	ZSTD_count
	add	r12, rax
$LN160@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	mov	rdi, QWORD PTR offset$1$[rsp]
	lea	rdx, QWORD PTR [r12+4]

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	rsi, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	r12d, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [rdi+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r14+r14*2]
	sub	ecx, eax
	inc	ecx

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN32@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN32@ZSTD_compr

; 751  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	r14, rdx
	mov	QWORD PTR offset$1$[rsp], r8
	mov	edi, r8d
	mov	r13, rbx
	jmp	SHORT $LN32@ZSTD_compr
$LN378@ZSTD_compr:

; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;

	mov	rdi, QWORD PTR offset$1$[rsp]
$LN32@ZSTD_compr:

; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$2[rsp]
	mov	r8, r15
	mov	QWORD PTR offset2$2[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_dictMatchState_selectMLS

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$2[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [rdi+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	ecx, DWORD PTR [r14*4+4]
	sub	ecx, eax

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN381@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN381@ZSTD_compr

; 759  :                     matchLength = ml2, offset = offset2, start = ip;

	lea	rax, QWORD PTR [r15-8]
	mov	QWORD PTR offset$1$[rsp], r9
	mov	r14, r8
	mov	r13, rbx
	cmp	rbx, rax
	jb	$LL6@ZSTD_compr

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	jmp	SHORT $LN375@ZSTD_compr
$LN381@ZSTD_compr:
	mov	r9, QWORD PTR offset$1$[rsp]
$LN375@ZSTD_compr:
	mov	rbp, QWORD PTR seqStore$[rsp]
	mov	r15, QWORD PTR src$[rsp]
$LN33@ZSTD_compr:

; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {
; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 769  :                     int const gain2 = (int)(mlRep * 4);
; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 772  :                         matchLength = mlRep, offset = 0, start = ip;
; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;
; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 783  :                         int const gain2 = (int)(mlRep * 4);
; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))
; 786  :                             matchLength = mlRep, offset = 0, start = ip;
; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;
; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);
; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {
; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	mov	r12d, DWORD PTR prefixLowestIndex$1$[rsp]
	test	r9, r9
	je	SHORT $_storeSequence$390

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */
; 810  :                     { start--; matchLength++; }
; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	edx, r13d
	sub	edx, r9d
	sub	edx, esi
	add	edx, 2
	mov	ecx, edx

; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;

	cmp	edx, r12d
	jae	SHORT $LN66@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rcx, rax
	add	rcx, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN67@ZSTD_compr
$LN66@ZSTD_compr:
	add	rcx, rsi
$LN67@ZSTD_compr:

; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	cmp	edx, r12d
	cmovb	r8, QWORD PTR dictLowest$1$[rsp]

; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	r13, r15
	jbe	SHORT $LN376@ZSTD_compr
	npad	4
$LL10@ZSTD_compr:
	cmp	rcx, r8
	jbe	SHORT $LN376@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [r13-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN376@ZSTD_compr
	dec	rcx
	inc	r14
	mov	r13, rdx
	cmp	rdx, r15
	ja	SHORT $LL10@ZSTD_compr
$LN376@ZSTD_compr:

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [r9-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	DWORD PTR offset_2$1$[rsp], r8d
$_storeSequence$390:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r10, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	mov	rbx, r13
	sub	rbx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rdx, QWORD PTR [r10-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r15]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rdx
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r15, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	9
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r15]

; 289  :             COPY16(op, ip);

	lea	r15, QWORD PTR [r15+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	rdx, r15
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR offset$1$[rsp]
	mov	r10, QWORD PTR iend$1$[rsp]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbp+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r9+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN368@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN368@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r15, QWORD PTR [r14+r13]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	rdx, QWORD PTR [r10-8]
	mov	QWORD PTR src$[rsp], r15
	mov	rbx, r15
	cmp	r15, rdx

; 829  :             while (ip <= ilimit) {

	ja	$LN45@ZSTD_compr
	mov	r8d, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r15
$LL12@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 831  :                 U32 const repIndex = current2 - offset_2;

	mov	ecx, ebx
	mov	r13d, r8d
	sub	ecx, esi
	sub	ecx, r8d
	mov	edi, ecx

; 832  :                 const BYTE* repMatch = dictMode == ZSTD_dictMatchState

	cmp	ecx, r12d
	jae	SHORT $LN68@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rdi, rax
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN69@ZSTD_compr
$LN68@ZSTD_compr:
	add	rdi, rsi
$LN69@ZSTD_compr:

; 833  :                     && repIndex < prefixLowestIndex ?
; 834  :                         dictBase - dictIndexDelta + repIndex :
; 835  :                         base + repIndex;
; 836  :                 if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
; 837  :                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, r12d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN377@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN377@ZSTD_compr

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, r12d
	mov	rsi, r10

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	lea	r12, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r10
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r10
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN248@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r12]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN248@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	r10, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], r8d
	mov	DWORD PTR offset_1$1$[rsp], r13d

; 841  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rdx, QWORD PTR [r10-32]
	cmp	r15, rdx
	ja	SHORT $LN254@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN255@ZSTD_compr
$LN254@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	r8, r15
	mov	rdx, r15
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r8d, DWORD PTR offset_2$1$[rsp]
$LN255@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN369@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN369@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 829  :             while (ip <= ilimit) {

	mov	r12d, DWORD PTR prefixLowestIndex$1$[rsp]
	lea	rdx, QWORD PTR [r10-8]
	mov	rsi, QWORD PTR base$1$[rsp]

; 842  :                     ip += matchLength;

	add	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 842  :                     ip += matchLength;

	mov	r15, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 829  :             while (ip <= ilimit) {

	cmp	rbx, rdx
	jbe	$LL12@ZSTD_compr
$LN377@ZSTD_compr:
	mov	QWORD PTR src$[rsp], r15
$LN45@ZSTD_compr:

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	mov	r9, QWORD PTR iend$1$[rsp]
	cmp	rbx, rdx
	mov	edx, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	edi, 0
	mov	r12d, DWORD PTR offset_1$1$[rsp]
	mov	r10d, DWORD PTR dictIndexDelta$1$[rsp]
	mov	r11, QWORD PTR dictBase$1$[rsp]
	jb	$LL4@ZSTD_compr
	mov	r8d, DWORD PTR offset_2$1$[rsp]
	mov	r14, QWORD PTR rep$[rsp]
	mov	r13, QWORD PTR [rsp+136]
$LN5@ZSTD_compr:

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	r9, r15
	mov	DWORD PTR [r14], r12d

; 917  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_dictMatchState);

	mov	rax, r9

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	mov	DWORD PTR [r14+4], r8d

; 918  : }

	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_lazy_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 8
ip$ = 16
ZSTD_insertAndFindFirstIndex PROC

; 474  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 475  :     return ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, ms->cParams.minMatch);

	mov	r9d, DWORD PTR [rcx+200]
	mov	r8, rdx
	lea	rdx, QWORD PTR [rcx+184]
	jmp	ZSTD_insertAndFindFirstIndex_internal
ZSTD_insertAndFindFirstIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
offsetFound$1 = 32
offset$1$ = 40
ilimit$1$ = 48
prefixLowest$1$ = 56
ms$ = 128
seqStore$ = 136
rep$ = 144
iend$1$ = 152
src$ = 152
tv2175 = 160
srcSize$ = 160
ZSTD_compressBlock_greedy PROC

; 895  : {

$LN376:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?

	mov	r11d, DWORD PTR [r8]

; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;
; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?
; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?
; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?
; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	xor	ebp, ebp
	mov	r10d, DWORD PTR [r8+4]

; 895  : {

	mov	r15, rcx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	r12, QWORD PTR srcSize$[rsp]

; 895  : {

	mov	rdi, r9

; 635  :     const BYTE* const iend = istart + srcSize;

	add	r12, r9

; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;
; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?
; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?
; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?
; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	mov	eax, ebp
	mov	r9d, DWORD PTR [rcx+24]

; 895  : {

	mov	rbx, rdx

; 637  :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [rcx+184]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 636  :     const BYTE* const ilimit = iend - 8;

	lea	r14, QWORD PTR [r12-8]
	mov	QWORD PTR iend$1$[rsp], r12
	mov	QWORD PTR ilimit$1$[rsp], r14

; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;
; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;

	lea	rsi, QWORD PTR [rdx+r9]

; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;
; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?
; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?
; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?
; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	cmp	edi, esi
	mov	QWORD PTR prefixLowest$1$[rsp], rsi
	sete	al
	lea	rsi, QWORD PTR [rax+rdi]

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);

	mov	r8d, esi
	sub	r8d, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
	shl	edx, cl

; 992  :     U32    const lowestValid = ms->window.dictLimit;
; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, r9d

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, r8d
	sub	ecx, edx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 690  :     while (ip < ilimit) {

	mov	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, r9d
	cmp	DWORD PTR [r15+32], ebp

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, r9d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	xor	r9d, r9d
	sub	r8d, ecx

; 690  :     while (ip < ilimit) {

	mov	r13d, r9d
	cmp	r10d, r8d
	cmovbe	ebp, r10d
	cmovbe	r10d, r9d
	cmp	r11d, r8d
	cmovbe	eax, r10d
	cmovbe	r13d, r11d
	mov	DWORD PTR tv2175[rsp], eax
	cmp	rsi, r14
	jae	$LN5@ZSTD_compr
	npad	9
$LL4@ZSTD_compr:

; 691  :         size_t matchLength=0;
; 692  :         size_t offset=0;
; 693  :         const BYTE* start=ip+1;
; 694  : 
; 695  :         /* check repCode */
; 696  :         if (dictMode == ZSTD_dictMatchState) {
; 697  :             const U32 repIndex = (U32)(ip - base) + 1 - offset_1;
; 698  :             const BYTE* repMatch = (dictMode == ZSTD_dictMatchState
; 699  :                                 && repIndex < prefixLowestIndex) ?
; 700  :                                    dictBase + (repIndex - dictIndexDelta) :
; 701  :                                    base + repIndex;
; 702  :             if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {
; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 706  :                 if (depth==0) goto _storeSequence;
; 707  :             }
; 708  :         }
; 709  :         if ( dictMode == ZSTD_noDict
; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {

	mov	eax, r13d
	lea	r14, QWORD PTR [rsi+1]
	mov	ecx, r9d
	mov	QWORD PTR offset$1$[rsp], r9
	mov	rdx, rsi
	mov	r8, r12
	sub	rdx, rax
	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR [rdx+1], eax
	mov	eax, r9d
	sete	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	SHORT $LN24@ZSTD_compr

; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;

	add	rdx, 5
	lea	rcx, QWORD PTR [rsi+5]
	call	ZSTD_count
	lea	r15, QWORD PTR [rax+4]

; 712  :             if (depth==0) goto _storeSequence;

	jmp	$_storeSequence$377
$LN24@ZSTD_compr:

; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	lea	r9, QWORD PTR offsetFound$1[rsp]
	mov	QWORD PTR offsetFound$1[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rsi
	mov	rcx, r15
	call	ZSTD_HcFindBestMatch_selectMLS
	mov	r15, rax

; 718  :             if (ml2 > matchLength)

	test	rax, rax
	je	$LN370@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r8, QWORD PTR offsetFound$1[rsp]
	mov	r14, rsi
	mov	QWORD PTR offset$1$[rsp], r8

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rax, 4
	jb	$LN370@ZSTD_compr

; 724  :             continue;
; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {
; 730  :             ip ++;
; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 734  :                 int const gain2 = (int)(mlRep * 3);
; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))
; 737  :                     matchLength = mlRep, offset = 0, start = ip;
; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;
; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 748  :                     int const gain2 = (int)(mlRep * 3);
; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 751  :                         matchLength = mlRep, offset = 0, start = ip;
; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;
; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);
; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {
; 759  :                     matchLength = ml2, offset = offset2, start = ip;
; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {
; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 769  :                     int const gain2 = (int)(mlRep * 4);
; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 772  :                         matchLength = mlRep, offset = 0, start = ip;
; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;
; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?
; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
; 783  :                         int const gain2 = (int)(mlRep * 4);
; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))
; 786  :                             matchLength = mlRep, offset = 0, start = ip;
; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;
; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);
; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {
; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	r8, r8
	je	SHORT $_storeSequence$377

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */

	mov	r9, QWORD PTR prefixLowest$1$[rsp]
	xor	ebp, ebp
	mov	ecx, ebp
	mov	eax, ebp
	mov	rdx, rsi
	sub	rdx, r8
	add	rdx, 2
	cmp	rdx, r9
	seta	cl
	cmp	rsi, rdi
	seta	al
	test	ecx, eax
	je	SHORT $LN372@ZSTD_compr
	npad	6
$LL8@ZSTD_compr:
	movzx	eax, BYTE PTR [rdx-1]
	cmp	BYTE PTR [r8+rdx-3], al
	jne	SHORT $LN372@ZSTD_compr

; 810  :                     { start--; matchLength++; }

	dec	r14
	dec	rdx
	inc	r15
	mov	ecx, ebp
	cmp	rdx, r9
	mov	eax, ebp
	seta	cl
	cmp	r14, rdi
	seta	al
	test	ecx, eax
	jne	SHORT $LL8@ZSTD_compr
$LN372@ZSTD_compr:

; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));
; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;
; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;
; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */
; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	ebp, r13d
	lea	r13d, DWORD PTR [r8-2]
$_storeSequence$377:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [r15-3]
	mov	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	sub	rsi, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rsi+rdi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rsi, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	rdi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rsi
	npad	7
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]

; 289  :             COPY16(op, ip);

	lea	rdi, QWORD PTR [rdi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	rdx, rdi
	call	ZSTD_safecopyLiterals
	lea	rdx, QWORD PTR [r15-3]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], rsi

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], si

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rcx, QWORD PTR offset$1$[rsp]
	mov	rax, QWORD PTR [rbx+8]
	inc	ecx
	mov	DWORD PTR [rax], ecx

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN371@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [rbx+8]
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
	mov	DWORD PTR [rbx+72], 2
$LN371@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	rdi, QWORD PTR [r14+r15]

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	xor	r9d, r9d
	mov	rsi, rdi
	mov	ecx, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], dx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	eax, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	cmp	rdi, QWORD PTR ilimit$1$[rsp]

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	setbe	cl
	test	ebp, ebp
	setne	al
	test	ecx, eax
	je	$LN374@ZSTD_compr
	npad	6
$LL14@ZSTD_compr:
	mov	eax, ebp
	mov	rdx, rsi
	sub	rdx, rax
	mov	r15d, ebp
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rsi], eax
	jne	$LN374@ZSTD_compr

; 853  :                 /* store sequence */
; 854  :                 matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	add	rdx, 4
	call	ZSTD_count
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	ebp, r13d
	mov	r13d, r15d
	lea	r14, QWORD PTR [rax+4]

; 856  :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	r15, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdi, r12
	ja	SHORT $LN310@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN311@ZSTD_compr
$LN310@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, rdi
	mov	rdx, rdi
	call	ZSTD_safecopyLiterals
$LN311@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	r9d, r9d
	mov	WORD PTR [rax+4], r9w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r15, 65535				; 0000ffffH
	jbe	SHORT $LN365@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN365@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r15w
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 857  :                 ip += matchLength;

	lea	rdi, QWORD PTR [r14+rsi]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	ecx, r9d

; 858  :                 anchor = ip;

	cmp	rdi, QWORD PTR ilimit$1$[rsp]
	mov	eax, r9d
	mov	rsi, rdi
	setbe	cl
	test	ebp, ebp
	setne	al
	test	ecx, eax
	jne	$LL14@ZSTD_compr
$LN374@ZSTD_compr:

; 690  :     while (ip < ilimit) {

	mov	r12, QWORD PTR iend$1$[rsp]
$LN15@ZSTD_compr:
	mov	r15, QWORD PTR ms$[rsp]
	lea	rax, QWORD PTR [r12-8]
	cmp	rsi, rax
	jb	$LL4@ZSTD_compr
	mov	eax, DWORD PTR tv2175[rsp]
$LN5@ZSTD_compr:

; 859  :                 continue;   /* faster when present ... (?) */
; 860  :     }   }   }
; 861  : 
; 862  :     /* Save reps for next block */
; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	rdx, QWORD PTR rep$[rsp]
	test	r13d, r13d

; 897  : }

	mov	rbx, QWORD PTR [rsp+136]

; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	ecx, eax
	cmovne	ecx, r13d

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	test	ebp, ebp
	cmovne	eax, ebp
	mov	DWORD PTR [rdx], ecx

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	r12, rdi
	mov	DWORD PTR [rdx+4], eax

; 896  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_noDict);

	mov	rax, r12

; 897  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN370@ZSTD_compr:

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rax, rsi
	inc	rsi
	sub	rax, rdi
	sar	rax, 8
	add	rsi, rax

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	xor	r9d, r9d
	jmp	SHORT $LN15@ZSTD_compr
ZSTD_compressBlock_greedy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
offset_2$1$ = 32
tv1786 = 36
base$1$ = 40
tv1666 = 48
offset$1$ = 48
dictBase$1$ = 56
prefixStart$1$ = 64
offsetFound$1 = 72
dictEnd$1$ = 80
dictStart$1$ = 88
ms$ = 160
seqStore$ = 168
rep$ = 176
dictLimit$1$ = 184
src$ = 184
offset_1$1$ = 192
srcSize$ = 192
ZSTD_compressBlock_greedy_extDict PROC

; 1112 : {

$LN240:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H

; 938  :     const BYTE* const iend = istart + srcSize;

	mov	r13, QWORD PTR srcSize$[rsp]

; 1112 : {

	mov	r11, rcx
	mov	r14, r9

; 958  :     ip += (ip == prefixStart);

	xor	r15d, r15d

; 1112 : {

	mov	r9, r8

; 938  :     const BYTE* const iend = istart + srcSize;

	add	r13, r14

; 1112 : {

	mov	rbx, rdx

; 943  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rdx, QWORD PTR [r11+16]
	mov	r10d, DWORD PTR [r11+24]
	mov	r12, QWORD PTR [r11+8]
	lea	rcx, QWORD PTR [r13-8]

; 944  :     const BYTE* const dictEnd  = dictBase + dictLimit;
; 945  :     const BYTE* const dictStart  = dictBase + ms->window.lowLimit;
; 946  :     const U32 windowLog = ms->cParams.windowLog;
; 947  : 
; 948  :     typedef size_t (*searchMax_f)(
; 949  :                         ZSTD_matchState_t* ms,
; 950  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 951  :     searchMax_f searchMax = searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_extDict_selectMLS : ZSTD_HcFindBestMatch_extDict_selectMLS;
; 952  : 
; 953  :     U32 offset_1 = rep[0], offset_2 = rep[1];

	mov	esi, DWORD PTR [r9+4]
	mov	QWORD PTR dictBase$1$[rsp], rdx
	lea	rax, QWORD PTR [rdx+r10]
	mov	QWORD PTR base$1$[rsp], r12
	mov	QWORD PTR dictEnd$1$[rsp], rax
	lea	r8, QWORD PTR [r10+r12]
	mov	eax, DWORD PTR [r11+28]
	add	rax, rdx
	mov	DWORD PTR dictLimit$1$[rsp], r10d
	mov	edx, DWORD PTR [r9]
	cmp	r14, r8
	mov	QWORD PTR dictStart$1$[rsp], rax

; 954  : 
; 955  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic");
; 956  : 
; 957  :     /* init */
; 958  :     ip += (ip == prefixStart);

	mov	eax, r15d
	sete	al
	mov	QWORD PTR prefixStart$1$[rsp], r8
	mov	DWORD PTR offset_1$1$[rsp], edx
	mov	DWORD PTR offset_2$1$[rsp], esi
	lea	rbp, QWORD PTR [rax+r14]
	cmp	rbp, rcx

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	ecx, DWORD PTR [r11+184]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR tv1786[rsp], eax
	mov	QWORD PTR [rsp+168], rdi
	npad	11
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [r11+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 971  :         U32 current = (U32)(ip-base);

	mov	r9d, ebp
	sub	r9d, r12d
	mov	QWORD PTR offset$1$[rsp], r15

; 976  :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	rdi, r12
	lea	r15, QWORD PTR [rbp+1]
	lea	r8d, DWORD PTR [r9+1]
	sub	r9d, edx
	inc	r9d
	cmp	r9d, r10d

; 977  :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	sub	r8d, DWORD PTR tv1786[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	cmp	eax, DWORD PTR tv1786[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r11+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 978  :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))   /* intentional overflow */

	xor	eax, eax
	cmp	r9d, r8d
	mov	edx, eax
	mov	ecx, r10d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN14@ZSTD_compr

; 979  :             if (MEM_read32(ip+1) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r15], eax
	jne	SHORT $LN14@ZSTD_compr

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r10d

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbp+5]
	mov	rsi, r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN46@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r12+rbp]
	mov	r8, r13
	call	ZSTD_count
	add	rbp, rax
$LN46@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 983  :                 if (depth==0) goto _storeSequence;

	mov	r12, QWORD PTR offset$1$[rsp]
	lea	rdi, QWORD PTR [rbp+4]
	jmp	$_storeSequence$241
$LN14@ZSTD_compr:

; 984  :         }   }
; 985  : 
; 986  :         /* first search (depth 0) */
; 987  :         {   size_t offsetFound = 999999999;
; 988  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	lea	r9, QWORD PTR offsetFound$1[rsp]
	mov	QWORD PTR offsetFound$1[rsp], 999999999	; 3b9ac9ffH
	mov	r8, r13
	mov	rdx, rbp
	mov	rcx, r11
	call	ZSTD_HcFindBestMatch_extDict_selectMLS
	mov	rdi, rax

; 989  :             if (ml2 > matchLength)

	test	rax, rax
	je	$LN234@ZSTD_compr

; 990  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r12, QWORD PTR offsetFound$1[rsp]
	mov	r15, rbp

; 991  :         }
; 992  : 
; 993  :          if (matchLength < 4) {

	cmp	rax, 4
	jb	$LN237@ZSTD_compr

; 995  :             continue;
; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)
; 1000 :         while (ip<ilimit) {
; 1001 :             ip ++;
; 1002 :             current++;
; 1003 :             /* check repCode */
; 1004 :             if (offset) {
; 1005 :                 const U32 windowLow = ZSTD_getLowestMatchIndex(ms, current, windowLog);
; 1006 :                 const U32 repIndex = (U32)(current - offset_1);
; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
; 1008 :                 const BYTE* const repMatch = repBase + repIndex;
; 1009 :                 if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */
; 1010 :                 if (MEM_read32(ip) == MEM_read32(repMatch)) {
; 1011 :                     /* repcode detected */
; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;
; 1014 :                     int const gain2 = (int)(repLength * 3);
; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))
; 1017 :                         matchLength = repLength, offset = 0, start = ip;
; 1018 :             }   }
; 1019 : 
; 1020 :             /* search match, depth 1 */
; 1021 :             {   size_t offset2=999999999;
; 1022 :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);
; 1025 :                 if ((ml2 >= 4) && (gain2 > gain1)) {
; 1026 :                     matchLength = ml2, offset = offset2, start = ip;
; 1027 :                     continue;   /* search a better one */
; 1028 :             }   }
; 1029 : 
; 1030 :             /* let's find an even better one */
; 1031 :             if ((depth==2) && (ip<ilimit)) {
; 1032 :                 ip ++;
; 1033 :                 current++;
; 1034 :                 /* check repCode */
; 1035 :                 if (offset) {
; 1036 :                     const U32 windowLow = ZSTD_getLowestMatchIndex(ms, current, windowLog);
; 1037 :                     const U32 repIndex = (U32)(current - offset_1);
; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
; 1039 :                     const BYTE* const repMatch = repBase + repIndex;
; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */
; 1041 :                     if (MEM_read32(ip) == MEM_read32(repMatch)) {
; 1042 :                         /* repcode detected */
; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;
; 1045 :                         int const gain2 = (int)(repLength * 4);
; 1046 :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))
; 1048 :                             matchLength = repLength, offset = 0, start = ip;
; 1049 :                 }   }
; 1050 : 
; 1051 :                 /* search match, depth 2 */
; 1052 :                 {   size_t offset2=999999999;
; 1053 :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);
; 1056 :                     if ((ml2 >= 4) && (gain2 > gain1)) {
; 1057 :                         matchLength = ml2, offset = offset2, start = ip;
; 1058 :                         continue;
; 1059 :             }   }   }
; 1060 :             break;  /* nothing found : store previous solution */
; 1061 :         }
; 1062 : 
; 1063 :         /* catch up */
; 1064 :         if (offset) {

	test	r12, r12
	je	SHORT $_storeSequence$241

; 1065 :             U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	r9, QWORD PTR base$1$[rsp]
	mov	eax, ebp

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	edx, DWORD PTR dictLimit$1$[rsp]
	sub	eax, r9d
	mov	r8, QWORD PTR prefixStart$1$[rsp]
	sub	eax, r12d
	add	eax, 2
	cmp	eax, edx
	cmovb	r8, QWORD PTR dictStart$1$[rsp]
	cmp	rbp, r14

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	jbe	SHORT $LN235@ZSTD_compr

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	rcx, QWORD PTR dictBase$1$[rsp]
	cmp	eax, edx
	cmovae	rcx, r9
	sub	rbp, rax
	sub	rbp, rcx
	lea	rdx, QWORD PTR [rax+rcx]
	npad	7
$LL8@ZSTD_compr:

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	rdx, r8
	jbe	SHORT $LN235@ZSTD_compr
	movzx	eax, BYTE PTR [rdx-1]
	cmp	BYTE PTR [rdx+rbp-1], al
	jne	SHORT $LN235@ZSTD_compr
	dec	r15
	dec	rdx
	inc	rdi
	cmp	r15, r14
	ja	SHORT $LL8@ZSTD_compr
$LN235@ZSTD_compr:

; 1069 :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	esi, DWORD PTR offset_1$1$[rsp]
	lea	eax, DWORD PTR [r12-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	DWORD PTR offset_2$1$[rsp], esi
$_storeSequence$241:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
	lea	r10, QWORD PTR [r13-32]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1074 :         {   size_t const litLength = start - anchor;

	mov	rsi, r15

; 1075 :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rbp, QWORD PTR [rdi-3]
	sub	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rsi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r10
	ja	SHORT $LN90@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rsi, 16
	jbe	SHORT $LN91@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rsi
	npad	1
$LL104@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL104@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN91@ZSTD_compr
$LN90@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r10
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN91@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], rsi

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN93@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN93@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], si

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r12+1]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbp, 65535				; 0000ffffH
	jbe	SHORT $LN228@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN228@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	mov	esi, DWORD PTR offset_2$1$[rsp]
	lea	r14, QWORD PTR [r15+rdi]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	r10, QWORD PTR [r13-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	mov	rbp, r14
	cmp	r14, r10

; 1080 :         while (ip <= ilimit) {

	ja	$LN236@ZSTD_compr
	npad	9
$LL10@ZSTD_compr:

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	mov	r12, QWORD PTR base$1$[rsp]
	mov	r8d, ebp

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r10d, DWORD PTR dictLimit$1$[rsp]
	sub	r8d, r12d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r11, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	mov	r9d, r8d
	sub	r9d, esi
	mov	DWORD PTR tv1666[rsp], esi

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r9d, r10d

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	mov	rdi, r12
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [r11+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r8d, DWORD PTR tv1786[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	cmp	eax, DWORD PTR tv1786[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r11+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1086 :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	r15d, r15d
	cmp	r9d, r8d
	mov	edx, r15d
	mov	eax, r15d
	mov	ecx, r10d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN31@ZSTD_compr

; 1087 :             if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbp], eax
	jne	$LN31@ZSTD_compr

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r10d

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbp+4]
	mov	rsi, r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN139@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+r12]
	mov	r8, r13
	call	ZSTD_count
	add	r15, rax
$LN139@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	esi, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	r10, QWORD PTR [r13-32]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	eax, DWORD PTR tv1666[rsp]
	add	r15, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	DWORD PTR offset_2$1$[rsp], esi
	mov	DWORD PTR offset_1$1$[rsp], eax

; 1092 :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r15-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r10
	ja	SHORT $LN174@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN175@ZSTD_compr
$LN174@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r10
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN175@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN229@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN229@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1093 :                 ip += matchLength;

	add	rbp, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	lea	r10, QWORD PTR [r13-8]

; 1093 :                 ip += matchLength;

	mov	r14, rbp
	cmp	rbp, r10
	jbe	$LL10@ZSTD_compr
$LN236@ZSTD_compr:

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	mov	r12, QWORD PTR base$1$[rsp]
$LN238@ZSTD_compr:
	mov	r10d, DWORD PTR dictLimit$1$[rsp]
	xor	r15d, r15d
	mov	r11, QWORD PTR ms$[rsp]
$LN31@ZSTD_compr:
	mov	edx, DWORD PTR offset_1$1$[rsp]
	lea	rax, QWORD PTR [r13-8]
	cmp	rbp, rax
	jb	$LL4@ZSTD_compr
	mov	r9, QWORD PTR rep$[rsp]
	mov	rdi, QWORD PTR [rsp+168]
$LN5@ZSTD_compr:

; 1103 : 
; 1104 :     /* Return the last literals size */
; 1105 :     return (size_t)(iend - anchor);

	sub	r13, r14
	mov	DWORD PTR [r9], edx

; 1113 :     return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0);

	mov	rax, r13

; 1102 :     rep[1] = offset_2;

	mov	DWORD PTR [r9+4], esi

; 1114 : }

	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN237@ZSTD_compr:

; 993  :          if (matchLength < 4) {

	mov	r12, QWORD PTR base$1$[rsp]
$LN234@ZSTD_compr:

; 994  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rcx, rbp
	inc	rbp
	sub	rcx, r14
	sar	rcx, 8
	add	rbp, rcx

; 1080 :         while (ip <= ilimit) {

	jmp	SHORT $LN238@ZSTD_compr
ZSTD_compressBlock_greedy_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
iend$1$ = 32
offset_1$1$ = 40
offset_2$1$ = 44
dictIndexDelta$1$ = 48
tv2467 = 52
r$1 = 52
r$2 = 52
r$3 = 52
offset$1$ = 56
prefixLowest$1$ = 72
base$1$ = 80
dictBase$1$ = 88
dictEnd$1$ = 96
offsetFound$4 = 104
ilimit$1$ = 112
offset2$5 = 120
offset2$6 = 128
dictLowest$1$ = 136
ms$ = 224
seqStore$ = 232
rep$ = 240
src$ = 248
prefixLowestIndex$1$ = 256
srcSize$ = 256
ZSTD_compressBlock_lazy2_dictMatchState PROC

; 909  : {

$LN389:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	mov	r10, rcx
	mov	r14, r8
	mov	r13, r9
	mov	r15, rdx

; 635  :     const BYTE* const iend = istart + srcSize;

	mov	rdx, QWORD PTR srcSize$[rsp]
	add	rdx, r9

; 636  :     const BYTE* const ilimit = iend - 8;
; 637  :     const BYTE* const base = ms->window.base;
; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;
; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;
; 640  : 
; 641  :     typedef size_t (*searchMax_f)(
; 642  :                         ZSTD_matchState_t* ms,
; 643  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?
; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR [r10+176]
	mov	r8, QWORD PTR [r10+8]
	mov	esi, DWORD PTR [r10+24]
	mov	r9d, DWORD PTR [r14]
	lea	rcx, QWORD PTR [rdx-8]

; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?

	mov	r11, QWORD PTR [rax+8]

; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [rax+24]

; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?
; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?

	mov	r10d, r11d
	mov	rax, QWORD PTR [rax]
	lea	rbx, QWORD PTR [r8+rsi]
	mov	ebp, DWORD PTR [r14+4]
	sub	r10d, eax
	add	rdi, r11
	mov	QWORD PTR dictEnd$1$[rsp], rax

; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	sub	eax, edi
	mov	QWORD PTR dictLowest$1$[rsp], rdi
	sub	eax, ebx
	mov	QWORD PTR prefixLowest$1$[rsp], rbx
	add	r10d, esi
	mov	QWORD PTR iend$1$[rsp], rdx
	add	eax, r13d
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	edi, 0
	mov	QWORD PTR base$1$[rsp], r8
	mov	eax, edi
	mov	DWORD PTR prefixLowestIndex$1$[rsp], esi
	sete	al
	mov	DWORD PTR offset_1$1$[rsp], r9d
	mov	DWORD PTR offset_2$1$[rsp], ebp
	mov	QWORD PTR dictBase$1$[rsp], r11
	mov	DWORD PTR dictIndexDelta$1$[rsp], r10d
	lea	rbx, QWORD PTR [rax+r13]
	cmp	rbx, rcx

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	QWORD PTR [rsp+152], r12
$LL4@ZSTD_compr:

; 691  :         size_t matchLength=0;
; 692  :         size_t offset=0;
; 693  :         const BYTE* start=ip+1;
; 694  : 
; 695  :         /* check repCode */
; 696  :         if (dictMode == ZSTD_dictMatchState) {
; 697  :             const U32 repIndex = (U32)(ip - base) + 1 - offset_1;

	mov	ecx, ebx
	mov	QWORD PTR offset$1$[rsp], rdi
	sub	ecx, r8d
	lea	r12, QWORD PTR [rbx+1]
	sub	ecx, r9d
	mov	rbp, rdi
	inc	ecx
	mov	r14, rdi

; 698  :             const BYTE* repMatch = (dictMode == ZSTD_dictMatchState

	cmp	ecx, esi
	jae	SHORT $LN60@ZSTD_compr
	mov	edi, ecx
	sub	edi, r10d
	add	rdi, r11
	jmp	SHORT $LN61@ZSTD_compr
$LN60@ZSTD_compr:
	mov	edi, ecx
	add	rdi, r8
$LN61@ZSTD_compr:

; 699  :                                 && repIndex < prefixLowestIndex) ?
; 700  :                                    dictBase + (repIndex - dictIndexDelta) :
; 701  :                                    base + repIndex;
; 702  :             if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	SHORT $LN22@ZSTD_compr
	mov	eax, DWORD PTR [r12]
	cmp	DWORD PTR [rdi], eax
	jne	SHORT $LN22@ZSTD_compr

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	rsi, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdx
	lea	rcx, QWORD PTR [rbx+5]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, rdx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+5]
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN83@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rbp+5]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	add	rcx, rbx
	call	ZSTD_count
	add	rbp, rax
$LN83@ZSTD_compr:
	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rbp, 4
	mov	rdx, QWORD PTR iend$1$[rsp]
$LN22@ZSTD_compr:

; 706  :                 if (depth==0) goto _storeSequence;
; 707  :             }
; 708  :         }
; 709  :         if ( dictMode == ZSTD_noDict
; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {
; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;
; 712  :             if (depth==0) goto _storeSequence;
; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$4[rsp]
	mov	r8, rdx
	mov	QWORD PTR offsetFound$4[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_dictMatchState_selectMLS

; 718  :             if (ml2 > matchLength)

	cmp	rax, rbp
	jbe	SHORT $LN25@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r14, QWORD PTR offsetFound$4[rsp]
	mov	rbp, rax
	mov	QWORD PTR offset$1$[rsp], r14
	mov	r12, rbx
$LN25@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	rbp, 4
	jae	SHORT $LN354@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */
; 724  :             continue;

	mov	rdx, QWORD PTR ilimit$1$[rsp]
	mov	rax, rbx
	sub	rax, r13
	inc	rbx
	sar	rax, 8
	add	rbx, rax
$LN384@ZSTD_compr:

; 669  :     if (dictMode == ZSTD_noDict) {
; 670  :         U32 const current = (U32)(ip - base);
; 671  :         U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);
; 672  :         U32 const maxRep = current - windowLow;
; 673  :         if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;
; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;
; 675  :     }
; 676  :     if (dictMode == ZSTD_dictMatchState) {
; 677  :         /* dictMatchState repCode checks don't currently handle repCode == 0
; 678  :          * disabling. */
; 679  :         assert(offset_1 <= dictAndPrefixLength);
; 680  :         assert(offset_2 <= dictAndPrefixLength);
; 681  :     }
; 682  : 
; 683  :     /* Match Loop */
; 684  : #if defined(__GNUC__) && defined(__x86_64__)
; 685  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 686  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 687  :      */
; 688  :     __asm__(".p2align 5");
; 689  : #endif
; 690  :     while (ip < ilimit) {

	mov	ebp, DWORD PTR offset_2$1$[rsp]
$LN45@ZSTD_compr:
	mov	r8, QWORD PTR base$1$[rsp]
	cmp	rbx, rdx
	mov	rdx, QWORD PTR iend$1$[rsp]
	mov	edi, 0
	mov	r9d, DWORD PTR offset_1$1$[rsp]
	mov	r10d, DWORD PTR dictIndexDelta$1$[rsp]
	mov	r11, QWORD PTR dictBase$1$[rsp]
	jb	$LL4@ZSTD_compr
	mov	r14, QWORD PTR rep$[rsp]
	mov	r12, QWORD PTR [rsp+152]
$LN5@ZSTD_compr:

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	rdx, r13
	mov	DWORD PTR [r14], r9d

; 910  :     return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_dictMatchState);

	mov	rax, rdx

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	mov	DWORD PTR [r14+4], ebp

; 911  : }

	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN354@ZSTD_compr:

; 729  :         while (ip<ilimit) {

	cmp	rbx, QWORD PTR ilimit$1$[rsp]
	jae	$LN40@ZSTD_compr
	mov	r14, QWORD PTR iend$1$[rsp]
	npad	13
$LL6@ZSTD_compr:

; 730  :             ip ++;
; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 734  :                 int const gain2 = (int)(mlRep * 3);
; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);
; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))
; 737  :                     matchLength = mlRep, offset = 0, start = ip;
; 738  :             }
; 739  :             if (dictMode == ZSTD_dictMatchState) {
; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	rax, QWORD PTR base$1$[rsp]
	inc	rbx
	mov	ecx, ebx
	sub	ecx, eax
	sub	ecx, DWORD PTR offset_1$1$[rsp]

; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, esi
	jae	SHORT $LN62@ZSTD_compr
	mov	edi, ecx
	sub	edi, DWORD PTR dictIndexDelta$1$[rsp]
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN63@ZSTD_compr
$LN62@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rax
$LN63@ZSTD_compr:

; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN378@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN378@ZSTD_compr

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r13, QWORD PTR [rbx+4]
	mov	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r13
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r14
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN160@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r13]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN160@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	mov	r15, QWORD PTR offset$1$[rsp]
	lea	rdx, QWORD PTR [r14+4]

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edi, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	r14, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$3[rsp], edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [rbp*2]
	add	ecx, ebp
	sub	ecx, eax
	inc	ecx

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN32@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN32@ZSTD_compr

; 751  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	rbp, rdx
	mov	QWORD PTR offset$1$[rsp], rdi
	mov	r15d, edi
	mov	r12, rbx
	jmp	SHORT $LN32@ZSTD_compr
$LN378@ZSTD_compr:

; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;

	mov	r15, QWORD PTR offset$1$[rsp]
	xor	edi, edi
$LN32@ZSTD_compr:

; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$5[rsp]
	mov	r8, r14
	mov	QWORD PTR offset2$5[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_dictMatchState_selectMLS

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$5[rsp]

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r13d, DWORD PTR [rbp*4]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$2[rsp], edi
	mov	DWORD PTR r$1[rsp], edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [r15+1]
	mov	DWORD PTR tv2467[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	mov	eax, r13d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	eax, 4

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN33@ZSTD_compr
	cmp	edx, eax
	jg	$LN387@ZSTD_compr
$LN33@ZSTD_compr:

; 759  :                     matchLength = ml2, offset = offset2, start = ip;
; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {

	lea	rax, QWORD PTR [r14-8]
	cmp	rbx, rax
	jae	$LN375@ZSTD_compr

; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
; 769  :                     int const gain2 = (int)(mlRep * 4);
; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))
; 772  :                         matchLength = mlRep, offset = 0, start = ip;
; 773  :                 }
; 774  :                 if (dictMode == ZSTD_dictMatchState) {
; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	rax, QWORD PTR base$1$[rsp]
	inc	rbx
	mov	ecx, ebx
	sub	ecx, eax
	sub	ecx, DWORD PTR offset_1$1$[rsp]

; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, esi
	jae	SHORT $LN64@ZSTD_compr
	mov	edi, ecx
	sub	edi, DWORD PTR dictIndexDelta$1$[rsp]
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN65@ZSTD_compr
$LN64@ZSTD_compr:
	mov	edi, ecx
	add	rdi, rax
$LN65@ZSTD_compr:

; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN386@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN386@ZSTD_compr

; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]
	mov	rsi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r14
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN210@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+4]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	add	rcx, rbx
	call	ZSTD_count
	add	r14, rax
$LN210@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
	lea	rdx, QWORD PTR [r14+4]
	mov	r14, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	edi, edi

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2467[rsp]
	mov	ecx, edi
	cmovne	ecx, eax
	sub	r13d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r13d

; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN39@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r13d
	jle	SHORT $LN39@ZSTD_compr

; 786  :                             matchLength = mlRep, offset = 0, start = ip;

	mov	rbp, rdx
	mov	QWORD PTR offset$1$[rsp], rdi
	mov	r15d, edi
	mov	r12, rbx
	jmp	SHORT $LN39@ZSTD_compr
$LN386@ZSTD_compr:

; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;

	xor	edi, edi
$LN39@ZSTD_compr:

; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$6[rsp]
	mov	r8, r14
	mov	QWORD PTR offset2$6[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_dictMatchState_selectMLS

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$6[rsp]
	mov	r8, rax
	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [rbp*4]
	sub	ecx, eax
	add	ecx, 7

; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN375@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN375@ZSTD_compr
$LN387@ZSTD_compr:

; 725  :         }
; 726  : 
; 727  :         /* let's try to find a better solution */
; 728  :         if (depth>=1)
; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [r14-8]
	mov	QWORD PTR offset$1$[rsp], r9
	mov	r12, rbx
	mov	rbp, r8
	cmp	rbx, rax
	jb	$LL6@ZSTD_compr
$LN375@ZSTD_compr:
	mov	r15, QWORD PTR seqStore$[rsp]
	mov	r13, QWORD PTR src$[rsp]
	mov	r14, QWORD PTR offset$1$[rsp]
$LN40@ZSTD_compr:

; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	r14, r14
	je	SHORT $_storeSequence$390

; 807  :             if (dictMode == ZSTD_noDict) {
; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */
; 810  :                     { start--; matchLength++; }
; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {
; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	rax, QWORD PTR base$1$[rsp]
	mov	edx, r12d
	sub	edx, r14d
	sub	edx, eax
	add	edx, 2
	mov	ecx, edx

; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;

	cmp	edx, esi
	jae	SHORT $LN66@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rcx, rax
	add	rcx, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN67@ZSTD_compr
$LN66@ZSTD_compr:
	add	rcx, rax
$LN67@ZSTD_compr:

; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;

	mov	r8, QWORD PTR prefixLowest$1$[rsp]
	cmp	edx, esi
	cmovb	r8, QWORD PTR dictLowest$1$[rsp]

; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	r12, r13
	jbe	SHORT $LN376@ZSTD_compr
$LL10@ZSTD_compr:
	cmp	rcx, r8
	jbe	SHORT $LN376@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [r12-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN376@ZSTD_compr
	dec	rcx
	inc	rbp
	mov	r12, rdx
	cmp	rdx, r13
	ja	SHORT $LL10@ZSTD_compr
$LN376@ZSTD_compr:

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], eax
	lea	eax, DWORD PTR [r14-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
$_storeSequence$390:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r9, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	mov	rbx, r12
	sub	rbx, r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rdx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r13]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rdx
	ja	SHORT $LN222@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN223@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	lea	rcx, QWORD PTR [r13+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rdx, rax
	npad	10
$LL236@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL236@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN223@ZSTD_compr
$LN222@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	rdx, r13
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR iend$1$[rsp]
$LN223@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r15+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [r15+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN225@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 1
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN225@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN368@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN368@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	r13, QWORD PTR [r12+rbp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r15+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	rdx, QWORD PTR [r9-8]
	mov	QWORD PTR src$[rsp], r13
	mov	rbx, r13
	cmp	r13, rdx

; 829  :             while (ip <= ilimit) {

	ja	$LN384@ZSTD_compr
	mov	ebp, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r13
	npad	2
$LL12@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 831  :                 U32 const repIndex = current2 - offset_2;

	mov	rax, QWORD PTR base$1$[rsp]
	mov	ecx, ebx
	sub	ecx, eax
	mov	r12d, ebp
	sub	ecx, ebp
	mov	edi, ecx

; 832  :                 const BYTE* repMatch = dictMode == ZSTD_dictMatchState

	cmp	ecx, esi
	jae	SHORT $LN68@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rdi, rax
	add	rdi, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN69@ZSTD_compr
$LN68@ZSTD_compr:
	add	rdi, rax
$LN69@ZSTD_compr:

; 833  :                     && repIndex < prefixLowestIndex ?
; 834  :                         dictBase - dictIndexDelta + repIndex :
; 835  :                         base + repIndex;
; 836  :                 if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
; 837  :                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, esi
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN377@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN377@ZSTD_compr

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, DWORD PTR prefixLowestIndex$1$[rsp]

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	lea	rbp, QWORD PTR [rbx+4]
	mov	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r9
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r9
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN248@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+rbp]
	mov	rdx, QWORD PTR prefixLowest$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN248@ZSTD_compr:

; 456  :     if (litEnd <= litLimit_w) {

	mov	r9, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	r14, 4

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	ebp, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_1$1$[rsp], r12d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rdx, QWORD PTR [r9-32]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 841  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r13, rdx
	ja	SHORT $LN254@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN255@ZSTD_compr
$LN254@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rdx
	mov	r8, r13
	mov	rdx, r13
	call	ZSTD_safecopyLiterals
	mov	r9, QWORD PTR iend$1$[rsp]
$LN255@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [r15+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN369@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN369@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 829  :             while (ip <= ilimit) {

	mov	esi, DWORD PTR prefixLowestIndex$1$[rsp]
	lea	rdx, QWORD PTR [r9-8]

; 842  :                     ip += matchLength;

	add	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r15+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 842  :                     ip += matchLength;

	mov	r13, rbx
	cmp	rbx, rdx
	jbe	$LL12@ZSTD_compr
$LN377@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], ebp
	mov	QWORD PTR src$[rsp], r13

; 829  :             while (ip <= ilimit) {

	jmp	$LN45@ZSTD_compr
ZSTD_compressBlock_lazy2_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
offset_1$1$ = 32
tv2006 = 36
dictLimit$1$ = 40
tv2256 = 44
offset_2$1$ = 48
iend$1$ = 56
gain1$1$ = 64
r$1 = 64
base$1$ = 72
dictBase$1$ = 80
prefixStart$1$ = 88
dictEnd$1$ = 96
tv2019 = 104
r$2 = 112
offset2$3 = 112
ilimit$1$ = 120
offsetFound$4 = 128
offset2$5 = 136
dictStart$1$ = 144
ms$ = 240
seqStore$ = 248
rep$ = 256
src$ = 264
litLimit_w$1$ = 272
current$1$ = 272
r$6 = 272
r$7 = 272
r$8 = 272
r$9 = 272
srcSize$ = 272
ZSTD_compressBlock_lazy2_extDict PROC

; 1128 : {

$LN255:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 184				; 000000b8H

; 938  :     const BYTE* const iend = istart + srcSize;

	mov	r10, QWORD PTR srcSize$[rsp]

; 1128 : {

	mov	rsi, r8

; 938  :     const BYTE* const iend = istart + srcSize;

	add	r10, r9

; 1128 : {

	mov	r12, r9

; 958  :     ip += (ip == prefixStart);

	xor	r13d, r13d
	mov	QWORD PTR iend$1$[rsp], r10

; 1128 : {

	mov	rbp, rdx
	mov	rdx, rcx

; 953  :     U32 offset_1 = rep[0], offset_2 = rep[1];

	mov	edi, DWORD PTR [rsi]
	lea	rcx, QWORD PTR [r10-8]
	mov	DWORD PTR offset_1$1$[rsp], edi
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	r8, QWORD PTR [rdx+8]
	mov	r11d, DWORD PTR [rdx+24]
	mov	QWORD PTR base$1$[rsp], r8
	mov	DWORD PTR dictLimit$1$[rsp], r11d
	lea	r9, QWORD PTR [r11+r8]
	mov	r8, QWORD PTR [rdx+16]
	mov	QWORD PTR dictBase$1$[rsp], r8
	mov	QWORD PTR prefixStart$1$[rsp], r9
	lea	rax, QWORD PTR [r8+r11]
	mov	QWORD PTR dictEnd$1$[rsp], rax
	mov	eax, DWORD PTR [rdx+28]
	add	rax, r8
	mov	r8d, DWORD PTR [rsi+4]
	mov	QWORD PTR dictStart$1$[rsp], rax
	cmp	r12, r9

; 954  : 
; 955  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic");
; 956  : 
; 957  :     /* init */
; 958  :     ip += (ip == prefixStart);

	mov	eax, r13d
	mov	DWORD PTR offset_2$1$[rsp], r8d
	sete	al
	lea	rbx, QWORD PTR [rax+r12]
	cmp	rbx, rcx

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	ecx, DWORD PTR [rdx+184]
	mov	QWORD PTR [rsp+176], r14
	mov	QWORD PTR [rsp+168], r15
	mov	r15d, 1
	shl	r15d, cl
	mov	DWORD PTR tv2256[rsp], r15d
	npad	1
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 971  :         U32 current = (U32)(ip-base);

	mov	esi, ebx
	mov	rax, QWORD PTR base$1$[rsp]
	mov	r14, r13
	sub	esi, eax
	mov	r12, r13

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	mov	r9d, esi
	mov	DWORD PTR current$1$[rsp], esi
	sub	r9d, edi
	lea	r13, QWORD PTR [rbx+1]
	inc	r9d

; 976  :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	rdi, rax
	cmp	r9d, r11d

; 977  :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	lea	r8d, DWORD PTR [rsi+1]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	sub	r8d, r15d
	cmp	eax, r15d
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 978  :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))   /* intentional overflow */

	xor	r15d, r15d
	cmp	r9d, r8d
	mov	edx, r15d
	mov	eax, r15d
	mov	ecx, r11d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN14@ZSTD_compr

; 979  :             if (MEM_read32(ip+1) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r13], eax
	jne	SHORT $LN14@ZSTD_compr

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r11d

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r15, QWORD PTR [rbx+5]
	mov	rsi, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r10
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r10
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN46@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r15]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN46@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r14, 4
	mov	esi, DWORD PTR current$1$[rsp]
$LN14@ZSTD_compr:

; 983  :                 if (depth==0) goto _storeSequence;
; 984  :         }   }
; 985  : 
; 986  :         /* first search (depth 0) */
; 987  :         {   size_t offsetFound = 999999999;
; 988  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$4[rsp]
	mov	r8, r10
	mov	QWORD PTR offsetFound$4[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_extDict_selectMLS

; 989  :             if (ml2 > matchLength)

	cmp	rax, r14
	jbe	SHORT $LN15@ZSTD_compr

; 990  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r12, QWORD PTR offsetFound$4[rsp]
	mov	r14, rax
	mov	r13, rbx
$LN15@ZSTD_compr:

; 991  :         }
; 992  : 
; 993  :          if (matchLength < 4) {

	cmp	r14, 4
	jae	SHORT $LN218@ZSTD_compr

; 994  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	r12, QWORD PTR src$[rsp]
	mov	rax, rbx

; 995  :             continue;

	mov	r10, QWORD PTR ilimit$1$[rsp]
	sub	rax, r12
	sar	rax, 8
	inc	rbx
	add	rbx, rax
	jmp	$LN31@ZSTD_compr
$LN218@ZSTD_compr:

; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)
; 1000 :         while (ip<ilimit) {

	mov	rdi, QWORD PTR ilimit$1$[rsp]
	cmp	rbx, rdi
	jae	$LN28@ZSTD_compr
	mov	r11d, DWORD PTR tv2256[rsp]
	mov	r15d, esi
	mov	rbp, QWORD PTR iend$1$[rsp]
	sub	r15d, r11d
	jmp	SHORT $LN6@ZSTD_compr
$LL252@ZSTD_compr:
	mov	r11d, DWORD PTR tv2256[rsp]
$LN6@ZSTD_compr:

; 1001 :             ip ++;
; 1002 :             current++;

	inc	esi
	inc	r15d
	inc	rbx
	mov	DWORD PTR current$1$[rsp], esi
	mov	DWORD PTR tv2006[rsp], r15d

; 1003 :             /* check repCode */
; 1004 :             if (offset) {

	test	r12, r12
	je	$LN21@ZSTD_compr

; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r9d, DWORD PTR dictLimit$1$[rsp]
	mov	r8d, esi
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r10, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r8d, r9d
	mov	rdi, QWORD PTR base$1$[rsp]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	sub	ecx, r11d

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r10+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, esi
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1006 :                 const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, r11d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r10+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1009 :                 if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r8d, ecx
	mov	edx, eax
	mov	ecx, r9d
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN251@ZSTD_compr

; 1010 :                 if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN251@ZSTD_compr

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	mov	rsi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, rbp
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN59@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r15
	mov	r8, rbp
	call	ZSTD_count
	add	r15, rax
$LN59@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR current$1$[rsp]
	lea	eax, DWORD PTR [r12+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r15+4]

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	r15d, DWORD PTR tv2006[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	mov	DWORD PTR r$1[rsp], r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r14+r14*2]
	sub	ecx, eax
	inc	ecx

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN251@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	lea	rdi, QWORD PTR [rbp-8]
	cmp	eax, ecx
	jle	SHORT $LN21@ZSTD_compr

; 1017 :                         matchLength = repLength, offset = 0, start = ip;

	mov	r14, rdx
	mov	r12d, r8d
	mov	r13, rbx
	jmp	SHORT $LN21@ZSTD_compr
$LN251@ZSTD_compr:

; 1018 :             }   }
; 1019 : 
; 1020 :             /* search match, depth 1 */
; 1021 :             {   size_t offset2=999999999;

	lea	rdi, QWORD PTR [rbp-8]
$LN21@ZSTD_compr:

; 1022 :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$5[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$5[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_extDict_selectMLS

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r10, QWORD PTR offset2$5[rsp]

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	edx, DWORD PTR [r14*4]
	mov	r9, rax
	mov	DWORD PTR gain1$1$[rsp], edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r11d, r11d
	mov	DWORD PTR r$9[rsp], r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r10+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$8[rsp], r11d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	r8d, DWORD PTR [r9*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	r8d, eax

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [r12+1]
	mov	DWORD PTR tv2019[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	sub	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	edx, 4

; 1025 :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r9, 4
	jb	SHORT $LN22@ZSTD_compr
	cmp	r8d, edx
	jle	SHORT $LN22@ZSTD_compr

; 1026 :                     matchLength = ml2, offset = offset2, start = ip;

	mov	r14, r9
	mov	r12, r10

; 1027 :                     continue;   /* search a better one */

	jmp	$LN253@ZSTD_compr
$LN22@ZSTD_compr:

; 1028 :             }   }
; 1029 : 
; 1030 :             /* let's find an even better one */
; 1031 :             if ((depth==2) && (ip<ilimit)) {

	cmp	rbx, rdi
	jae	$LN239@ZSTD_compr

; 1032 :                 ip ++;
; 1033 :                 current++;

	inc	esi
	inc	r15d
	inc	rbx
	mov	DWORD PTR current$1$[rsp], esi
	mov	DWORD PTR tv2006[rsp], r15d

; 1034 :                 /* check repCode */
; 1035 :                 if (offset) {

	test	r12, r12
	je	$LN27@ZSTD_compr

; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r9d, DWORD PTR dictLimit$1$[rsp]
	mov	r8d, esi
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r10, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r8d, r9d
	mov	rdi, QWORD PTR base$1$[rsp]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]

; 1039 :                     const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r10+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1039 :                     const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, esi
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1037 :                     const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, DWORD PTR tv2256[rsp]

; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	eax, r11d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r10+32], r11d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	edx, r11d
	cmp	r8d, ecx
	mov	ecx, r9d
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN249@ZSTD_compr

; 1041 :                     if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN249@ZSTD_compr

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	mov	rsi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, rbp
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN78@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r15
	mov	r8, rbp
	call	ZSTD_count
	add	r15, rax
$LN78@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	r8d, DWORD PTR gain1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r15+4]

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r9d, r9d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2019[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	mov	r15d, DWORD PTR tv2006[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r9d
	mov	DWORD PTR r$2[rsp], r9d
	cmovne	ecx, eax
	sub	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1046 :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r8d

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN249@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	lea	rdi, QWORD PTR [rbp-8]
	cmp	eax, r8d
	jle	SHORT $LN27@ZSTD_compr

; 1048 :                             matchLength = repLength, offset = 0, start = ip;

	mov	r14, rdx
	mov	r12d, r9d
	mov	r13, rbx
	jmp	SHORT $LN27@ZSTD_compr
$LN249@ZSTD_compr:

; 1049 :                 }   }
; 1050 : 
; 1051 :                 /* search match, depth 2 */
; 1052 :                 {   size_t offset2=999999999;

	lea	rdi, QWORD PTR [rbp-8]
$LN27@ZSTD_compr:

; 1053 :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$3[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$3[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_extDict_selectMLS

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$3[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$7[rsp], r10d
	mov	DWORD PTR r$6[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [r12+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [r14*4]
	sub	ecx, eax
	add	ecx, 7

; 1056 :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN239@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN239@ZSTD_compr

; 1057 :                         matchLength = ml2, offset = offset2, start = ip;

	mov	r14, r8
	mov	r12, r9
$LN253@ZSTD_compr:

; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)
; 1000 :         while (ip<ilimit) {

	mov	r13, rbx
	cmp	rbx, rdi
	jb	$LL252@ZSTD_compr
$LN239@ZSTD_compr:
	mov	rbp, QWORD PTR seqStore$[rsp]
$LN28@ZSTD_compr:

; 1058 :                         continue;
; 1059 :             }   }   }
; 1060 :             break;  /* nothing found : store previous solution */
; 1061 :         }
; 1062 : 
; 1063 :         /* catch up */
; 1064 :         if (offset) {

	mov	r15d, DWORD PTR dictLimit$1$[rsp]
	mov	r10, QWORD PTR src$[rsp]
	test	r12, r12
	je	SHORT $_storeSequence$256

; 1065 :             U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	rdx, QWORD PTR base$1$[rsp]
	mov	eax, r13d

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	r8, QWORD PTR prefixStart$1$[rsp]
	sub	eax, edx
	sub	eax, r12d
	add	eax, 2
	cmp	eax, r15d
	cmovb	r8, QWORD PTR dictStart$1$[rsp]

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	r13, r10
	jbe	SHORT $LN240@ZSTD_compr

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	rcx, QWORD PTR dictBase$1$[rsp]
	cmp	eax, r15d
	cmovae	rcx, rdx
	add	rcx, rax
	npad	7
$LL8@ZSTD_compr:

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	rcx, r8
	jbe	SHORT $LN240@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [r13-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN240@ZSTD_compr
	dec	rcx
	inc	r14
	mov	r13, rdx
	cmp	rdx, r10
	ja	SHORT $LL8@ZSTD_compr
$LN240@ZSTD_compr:

; 1069 :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], eax
	lea	eax, DWORD PTR [r12-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
$_storeSequence$256:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r11, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1075 :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1074 :         {   size_t const litLength = start - anchor;

	mov	rbx, r13
	sub	rbx, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rsi, QWORD PTR [r11-32]
	mov	QWORD PTR litLimit_w$1$[rsp], rsi

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r10]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rsi
	ja	SHORT $LN90@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN91@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	lea	rcx, QWORD PTR [r10+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rdx, rax
	npad	8
$LL104@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL104@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN91@ZSTD_compr
$LN90@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rsi
	mov	rdx, r10
	call	ZSTD_safecopyLiterals
	mov	r11, QWORD PTR iend$1$[rsp]
$LN91@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbp+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN93@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN93@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r12+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN232@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN232@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	r12, QWORD PTR [r14+r13]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	r10, QWORD PTR [r11-8]
	mov	QWORD PTR src$[rsp], r12
	mov	rbx, r12
	cmp	r12, r10

; 1080 :         while (ip <= ilimit) {

	ja	$LN31@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	jmp	SHORT $LN10@ZSTD_compr
	npad	5
$LL243@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN10@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	rdx, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	mov	r8d, ebx
	mov	rdi, QWORD PTR base$1$[rsp]
	mov	r13d, DWORD PTR offset_2$1$[rsp]
	sub	r8d, edi

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	mov	r9d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r9d, r13d

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r9d, r15d

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r8d, DWORD PTR tv2256[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	cmp	eax, DWORD PTR tv2256[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1086 :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r9d, r8d
	mov	edx, eax
	mov	ecx, r15d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN241@ZSTD_compr

; 1087 :             if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN241@ZSTD_compr

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r15d
	mov	rsi, r11

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r15, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r11
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r11
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN139@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r15]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN139@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	eax, DWORD PTR offset_1$1$[rsp]
	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	rsi, QWORD PTR litLimit_w$1$[rsp]
	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	DWORD PTR offset_2$1$[rsp], eax
	mov	DWORD PTR offset_1$1$[rsp], r13d

; 1092 :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r12, rsi
	ja	SHORT $LN174@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN175@ZSTD_compr
$LN174@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rsi
	mov	r8, r12
	mov	rdx, r12
	call	ZSTD_safecopyLiterals
$LN175@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	r15d, r15d
	mov	WORD PTR [rax+4], r15w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN233@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN233@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	mov	r10, QWORD PTR ilimit$1$[rsp]

; 1093 :                 ip += matchLength;

	add	rbx, r14
	mov	r15d, DWORD PTR dictLimit$1$[rsp]
	mov	r12, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	cmp	rbx, r10
	jbe	$LL243@ZSTD_compr
$LN241@ZSTD_compr:
	mov	QWORD PTR src$[rsp], r12
$LN31@ZSTD_compr:

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	cmp	rbx, r10
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r13d, 0
	mov	rdx, QWORD PTR ms$[rsp]
	mov	edi, DWORD PTR offset_1$1$[rsp]
	mov	r15d, DWORD PTR tv2256[rsp]
	jb	$LL4@ZSTD_compr
	mov	r8d, DWORD PTR offset_2$1$[rsp]
	mov	rsi, QWORD PTR rep$[rsp]
	mov	r15, QWORD PTR [rsp+168]
	mov	r14, QWORD PTR [rsp+176]
$LN5@ZSTD_compr:

; 1103 : 
; 1104 :     /* Return the last literals size */
; 1105 :     return (size_t)(iend - anchor);

	sub	r10, r12
	mov	DWORD PTR [rsi], edi

; 1129 :     return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2);

	mov	rax, r10

; 1102 :     rep[1] = offset_2;

	mov	DWORD PTR [rsi+4], r8d

; 1130 : }

	add	rsp, 184				; 000000b8H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_lazy2_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
litLimit_w$1$ = 32
offset$1$ = 32
dictLimit$1$ = 40
current$1$ = 44
offset_2$1$ = 48
iend$1$ = 56
tv1989 = 64
base$1$ = 72
dictBase$1$ = 80
prefixStart$1$ = 88
windowLog$1$ = 96
dictEnd$1$ = 104
offsetFound$1 = 112
offset2$2 = 120
ilimit$1$ = 128
dictStart$1$ = 136
ms$ = 224
seqStore$ = 232
rep$ = 240
src$ = 248
offset_1$1$ = 256
srcSize$ = 256
ZSTD_compressBlock_lazy_extDict PROC

; 1120 : {

$LN256:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 152				; 00000098H
	mov	r11, rcx
	mov	r14, r9

; 938  :     const BYTE* const iend = istart + srcSize;

	mov	r9, QWORD PTR srcSize$[rsp]

; 1120 : {

	mov	rdi, r8

; 938  :     const BYTE* const iend = istart + srcSize;

	add	r9, r14

; 954  : 
; 955  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic");
; 956  : 
; 957  :     /* init */
; 958  :     ip += (ip == prefixStart);

	xor	r13d, r13d

; 1120 : {

	mov	rbp, rdx

; 938  :     const BYTE* const iend = istart + srcSize;

	mov	QWORD PTR iend$1$[rsp], r9

; 939  :     const BYTE* const ilimit = iend - 8;
; 940  :     const BYTE* const base = ms->window.base;
; 941  :     const U32 dictLimit = ms->window.dictLimit;
; 942  :     const BYTE* const prefixStart = base + dictLimit;
; 943  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	rdx, QWORD PTR [r11+16]
	mov	r12d, DWORD PTR [r11+24]
	mov	r10, QWORD PTR [r11+8]
	lea	rcx, QWORD PTR [r9-8]

; 944  :     const BYTE* const dictEnd  = dictBase + dictLimit;
; 945  :     const BYTE* const dictStart  = dictBase + ms->window.lowLimit;
; 946  :     const U32 windowLog = ms->cParams.windowLog;

	mov	r15d, DWORD PTR [r11+184]

; 947  : 
; 948  :     typedef size_t (*searchMax_f)(
; 949  :                         ZSTD_matchState_t* ms,
; 950  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 951  :     searchMax_f searchMax = searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_extDict_selectMLS : ZSTD_HcFindBestMatch_extDict_selectMLS;
; 952  : 
; 953  :     U32 offset_1 = rep[0], offset_2 = rep[1];

	mov	esi, DWORD PTR [rdi+4]
	lea	rax, QWORD PTR [rdx+r12]
	mov	QWORD PTR dictBase$1$[rsp], rdx
	mov	QWORD PTR dictEnd$1$[rsp], rax
	lea	r8, QWORD PTR [r12+r10]
	mov	eax, DWORD PTR [r11+28]
	add	rax, rdx
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	edx, DWORD PTR [rdi]
	cmp	r14, r8
	mov	QWORD PTR dictStart$1$[rsp], rax

; 954  : 
; 955  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic");
; 956  : 
; 957  :     /* init */
; 958  :     ip += (ip == prefixStart);

	mov	eax, r13d
	sete	al
	mov	QWORD PTR base$1$[rsp], r10
	mov	DWORD PTR dictLimit$1$[rsp], r12d
	mov	QWORD PTR prefixStart$1$[rsp], r8
	mov	DWORD PTR windowLog$1$[rsp], r15d
	lea	rbx, QWORD PTR [rax+r14]
	mov	DWORD PTR offset_1$1$[rsp], edx
	mov	DWORD PTR offset_2$1$[rsp], esi
	cmp	rbx, rcx

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	ecx, r15d
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR tv1989[rsp], eax
	npad	2
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [r11+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 971  :         U32 current = (U32)(ip-base);

	mov	esi, ebx

; 976  :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	rdi, QWORD PTR base$1$[rsp]
	sub	esi, r10d
	mov	r10d, esi
	mov	QWORD PTR offset$1$[rsp], r13
	sub	r10d, edx
	mov	DWORD PTR current$1$[rsp], esi
	inc	r10d
	mov	r15, r13
	cmp	r10d, r12d

; 977  :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r10d
	lea	r8d, DWORD PTR [rsi+1]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	lea	r13, QWORD PTR [rbx+1]
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	sub	r8d, DWORD PTR tv1989[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	cmp	eax, DWORD PTR tv1989[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r11+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 978  :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))   /* intentional overflow */

	xor	eax, eax
	cmp	r10d, r8d
	mov	edx, eax
	mov	ecx, r12d
	seta	dl
	sub	ecx, r10d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN250@ZSTD_compr

; 979  :             if (MEM_read32(ip+1) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r13], eax
	jne	SHORT $LN250@ZSTD_compr

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r10d, r12d
	mov	rsi, r9

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbx+5]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r9
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r9
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	mov	rdi, QWORD PTR iend$1$[rsp]
	cmp	rax, rsi
	jne	SHORT $LN46@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+r12]
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN46@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 978  :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))   /* intentional overflow */

	mov	esi, DWORD PTR current$1$[rsp]

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r15, 4
	mov	r12d, DWORD PTR dictLimit$1$[rsp]
	mov	r11, QWORD PTR ms$[rsp]
	jmp	SHORT $LN14@ZSTD_compr
$LN250@ZSTD_compr:

; 983  :                 if (depth==0) goto _storeSequence;
; 984  :         }   }
; 985  : 
; 986  :         /* first search (depth 0) */
; 987  :         {   size_t offsetFound = 999999999;

	mov	rdi, QWORD PTR iend$1$[rsp]
$LN14@ZSTD_compr:

; 988  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	lea	r9, QWORD PTR offsetFound$1[rsp]
	mov	QWORD PTR offsetFound$1[rsp], 999999999	; 3b9ac9ffH
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, r11
	call	ZSTD_HcFindBestMatch_extDict_selectMLS

; 989  :             if (ml2 > matchLength)

	cmp	rax, r15
	jbe	SHORT $LN248@ZSTD_compr

; 990  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r15, rax
	mov	r13, rbx
	mov	rax, QWORD PTR offsetFound$1[rsp]
	mov	QWORD PTR offset$1$[rsp], rax
	jmp	SHORT $LN15@ZSTD_compr
$LN248@ZSTD_compr:

; 989  :             if (ml2 > matchLength)

	mov	rax, QWORD PTR offset$1$[rsp]
$LN15@ZSTD_compr:

; 991  :         }
; 992  : 
; 993  :          if (matchLength < 4) {

	cmp	r15, 4
	jae	SHORT $LN218@ZSTD_compr

; 994  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rax, rbx
	inc	rbx
	sub	rax, r14
	sar	rax, 8
	add	rbx, rax
$LN254@ZSTD_compr:

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	mov	esi, DWORD PTR offset_2$1$[rsp]
$LN31@ZSTD_compr:
	mov	r13d, 0
	mov	r9, QWORD PTR iend$1$[rsp]
	mov	r12d, DWORD PTR dictLimit$1$[rsp]
	mov	edx, DWORD PTR offset_1$1$[rsp]
	mov	r11, QWORD PTR ms$[rsp]
	mov	r10, QWORD PTR base$1$[rsp]
	cmp	rbx, QWORD PTR ilimit$1$[rsp]
	jb	$LL4@ZSTD_compr
	mov	rdi, QWORD PTR rep$[rsp]
$LN5@ZSTD_compr:

; 1103 : 
; 1104 :     /* Return the last literals size */
; 1105 :     return (size_t)(iend - anchor);

	sub	r9, r14
	mov	DWORD PTR [rdi], edx

; 1121 :     return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1);

	mov	rax, r9

; 1102 :     rep[1] = offset_2;

	mov	DWORD PTR [rdi+4], esi

; 1122 : }

	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN218@ZSTD_compr:

; 1000 :         while (ip<ilimit) {

	lea	rcx, QWORD PTR [rdi-8]
	cmp	rbx, rcx
	jae	$LN22@ZSTD_compr
	mov	ecx, DWORD PTR windowLog$1$[rsp]
	mov	r14d, 1
	mov	rbp, QWORD PTR iend$1$[rsp]
	rol	r14d, cl
	xor	r10d, r10d
	npad	8
$LL6@ZSTD_compr:

; 1001 :             ip ++;
; 1002 :             current++;

	inc	esi
	inc	rbx
	mov	DWORD PTR current$1$[rsp], esi

; 1003 :             /* check repCode */
; 1004 :             if (offset) {

	test	rax, rax
	je	$LN243@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r9, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1006 :                 const U32 repIndex = (U32)(current - offset_1);

	mov	r8d, esi
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, esi

; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	rdi, QWORD PTR base$1$[rsp]
	cmp	r8d, r12d

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	sub	ecx, r14d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r9+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, esi
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1006 :                 const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, r14d

; 1009 :                 if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	eax, r10d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r9+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1009 :                 if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	edx, r10d
	cmp	r8d, ecx
	mov	ecx, r12d
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN243@ZSTD_compr

; 1010 :                 if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN243@ZSTD_compr

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, r12d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	mov	rsi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, rbp
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r12, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN59@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r12
	mov	r8, rbp
	call	ZSTD_count
	add	r12, rax
$LN59@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	mov	rdi, QWORD PTR offset$1$[rsp]
	lea	rdx, QWORD PTR [r12+4]

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [rdi+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r15+r15*2]
	sub	ecx, eax
	inc	ecx

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN21@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN21@ZSTD_compr

; 1017 :                         matchLength = repLength, offset = 0, start = ip;

	mov	r15, rdx
	mov	QWORD PTR offset$1$[rsp], r8
	mov	edi, r8d
	mov	r13, rbx
	jmp	SHORT $LN21@ZSTD_compr
$LN243@ZSTD_compr:

; 1018 :             }   }
; 1019 : 
; 1020 :             /* search match, depth 1 */
; 1021 :             {   size_t offset2=999999999;

	mov	rdi, QWORD PTR offset$1$[rsp]
$LN21@ZSTD_compr:

; 1022 :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$2[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$2[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_HcFindBestMatch_extDict_selectMLS

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$2[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [rdi+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	ecx, DWORD PTR [r15*4+4]
	sub	ecx, eax

; 1025 :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN247@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN247@ZSTD_compr

; 995  :             continue;
; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)
; 1000 :         while (ip<ilimit) {

	mov	r12d, DWORD PTR dictLimit$1$[rsp]
	lea	rcx, QWORD PTR [rbp-8]

; 1026 :                     matchLength = ml2, offset = offset2, start = ip;

	mov	rax, r9
	mov	r15, r8
	mov	QWORD PTR offset$1$[rsp], rax
	mov	r13, rbx
	cmp	rbx, rcx
	jb	$LL6@ZSTD_compr

; 1025 :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	jmp	SHORT $LN239@ZSTD_compr
$LN247@ZSTD_compr:
	mov	rax, QWORD PTR offset$1$[rsp]
$LN239@ZSTD_compr:
	mov	rbp, QWORD PTR seqStore$[rsp]
	mov	r14, QWORD PTR src$[rsp]
$LN22@ZSTD_compr:

; 1027 :                     continue;   /* search a better one */
; 1028 :             }   }
; 1029 : 
; 1030 :             /* let's find an even better one */
; 1031 :             if ((depth==2) && (ip<ilimit)) {
; 1032 :                 ip ++;
; 1033 :                 current++;
; 1034 :                 /* check repCode */
; 1035 :                 if (offset) {
; 1036 :                     const U32 windowLow = ZSTD_getLowestMatchIndex(ms, current, windowLog);
; 1037 :                     const U32 repIndex = (U32)(current - offset_1);
; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
; 1039 :                     const BYTE* const repMatch = repBase + repIndex;
; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */
; 1041 :                     if (MEM_read32(ip) == MEM_read32(repMatch)) {
; 1042 :                         /* repcode detected */
; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;
; 1045 :                         int const gain2 = (int)(repLength * 4);
; 1046 :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);
; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))
; 1048 :                             matchLength = repLength, offset = 0, start = ip;
; 1049 :                 }   }
; 1050 : 
; 1051 :                 /* search match, depth 2 */
; 1052 :                 {   size_t offset2=999999999;
; 1053 :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);
; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */
; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);
; 1056 :                     if ((ml2 >= 4) && (gain2 > gain1)) {
; 1057 :                         matchLength = ml2, offset = offset2, start = ip;
; 1058 :                         continue;
; 1059 :             }   }   }
; 1060 :             break;  /* nothing found : store previous solution */
; 1061 :         }
; 1062 : 
; 1063 :         /* catch up */
; 1064 :         if (offset) {

	mov	rdi, QWORD PTR offset$1$[rsp]
	mov	r12d, DWORD PTR dictLimit$1$[rsp]
	test	rax, rax
	je	SHORT $_storeSequence$257

; 1065 :             U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	rdx, QWORD PTR base$1$[rsp]
	mov	eax, r13d

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	r8, QWORD PTR prefixStart$1$[rsp]
	sub	eax, edx
	sub	eax, edi
	add	eax, 2
	cmp	eax, r12d
	cmovb	r8, QWORD PTR dictStart$1$[rsp]

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	r13, r14
	jbe	SHORT $LN240@ZSTD_compr

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	rcx, QWORD PTR dictBase$1$[rsp]
	cmp	eax, r12d
	cmovae	rcx, rdx
	add	rcx, rax
$LL8@ZSTD_compr:

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	rcx, r8
	jbe	SHORT $LN240@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [r13-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN240@ZSTD_compr
	dec	rcx
	inc	r15
	mov	r13, rdx
	cmp	rdx, r14
	ja	SHORT $LL8@ZSTD_compr
$LN240@ZSTD_compr:

; 1069 :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], eax
	lea	eax, DWORD PTR [rdi-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
$_storeSequence$257:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r10, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1075 :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rsi, QWORD PTR [r15-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1074 :         {   size_t const litLength = start - anchor;

	mov	rbx, r13
	sub	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	r11, QWORD PTR [r10-32]
	mov	QWORD PTR litLimit_w$1$[rsp], r11

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r11
	ja	SHORT $LN90@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN91@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r14, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	1
$LL104@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL104@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN91@ZSTD_compr
$LN90@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r11
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
	mov	r10, QWORD PTR iend$1$[rsp]
$LN91@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbp+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN93@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN93@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rdi+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN232@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN232@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	r14, QWORD PTR [r15+r13]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], si

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	rax, QWORD PTR [r10-8]
	mov	QWORD PTR src$[rsp], r14
	mov	rbx, r14
	cmp	r14, rax

; 1080 :         while (ip <= ilimit) {

	ja	$LN254@ZSTD_compr
	mov	esi, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	jmp	SHORT $LN10@ZSTD_compr
	npad	2
$LL251@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
$LN10@ZSTD_compr:

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	mov	rax, QWORD PTR base$1$[rsp]
	mov	r8d, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	rdx, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	sub	r8d, eax

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	rdi, rax
	mov	r9d, r8d
	sub	r9d, esi
	mov	r13d, esi
	cmp	r9d, r12d

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmovb	rdi, QWORD PTR dictBase$1$[rsp]

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r8d, DWORD PTR tv1989[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	cmp	eax, DWORD PTR tv1989[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1086 :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r9d, r8d
	mov	edx, eax
	mov	ecx, r12d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN241@ZSTD_compr

; 1087 :             if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN241@ZSTD_compr

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r12d
	mov	rsi, r10

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r10
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r10
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN139@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r15+r12]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r15, rax
$LN139@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	esi, DWORD PTR offset_1$1$[rsp]
	add	r15, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	r11, QWORD PTR litLimit_w$1$[rsp]
	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	DWORD PTR offset_2$1$[rsp], esi
	mov	DWORD PTR offset_1$1$[rsp], r13d

; 1092 :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r15-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r11
	ja	SHORT $LN174@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN175@ZSTD_compr
$LN174@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r11
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN175@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN233@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN233@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	mov	r12d, DWORD PTR dictLimit$1$[rsp]

; 1093 :                 ip += matchLength;

	add	rbx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1093 :                 ip += matchLength;

	mov	r14, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	cmp	rbx, QWORD PTR ilimit$1$[rsp]
	jbe	$LL251@ZSTD_compr
$LN241@ZSTD_compr:
	mov	QWORD PTR src$[rsp], r14
	jmp	$LN31@ZSTD_compr
ZSTD_compressBlock_lazy_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
offset_1$1$ = 32
tv2006 = 36
dictLimit$1$ = 40
tv2256 = 44
offset_2$1$ = 48
iend$1$ = 56
gain1$1$ = 64
r$1 = 64
base$1$ = 72
dictBase$1$ = 80
prefixStart$1$ = 88
dictEnd$1$ = 96
tv2019 = 104
r$2 = 112
offset2$3 = 112
ilimit$1$ = 120
offsetFound$4 = 128
offset2$5 = 136
dictStart$1$ = 144
ms$ = 240
seqStore$ = 248
rep$ = 256
src$ = 264
litLimit_w$1$ = 272
current$1$ = 272
r$6 = 272
r$7 = 272
r$8 = 272
r$9 = 272
srcSize$ = 272
ZSTD_compressBlock_btlazy2_extDict PROC

; 1136 : {

$LN255:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 184				; 000000b8H

; 938  :     const BYTE* const iend = istart + srcSize;

	mov	r10, QWORD PTR srcSize$[rsp]

; 1136 : {

	mov	rsi, r8

; 938  :     const BYTE* const iend = istart + srcSize;

	add	r10, r9

; 1136 : {

	mov	r12, r9

; 958  :     ip += (ip == prefixStart);

	xor	r13d, r13d
	mov	QWORD PTR iend$1$[rsp], r10

; 1136 : {

	mov	rbp, rdx
	mov	rdx, rcx

; 953  :     U32 offset_1 = rep[0], offset_2 = rep[1];

	mov	edi, DWORD PTR [rsi]
	lea	rcx, QWORD PTR [r10-8]
	mov	DWORD PTR offset_1$1$[rsp], edi
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	r8, QWORD PTR [rdx+8]
	mov	r11d, DWORD PTR [rdx+24]
	mov	QWORD PTR base$1$[rsp], r8
	mov	DWORD PTR dictLimit$1$[rsp], r11d
	lea	r9, QWORD PTR [r11+r8]
	mov	r8, QWORD PTR [rdx+16]
	mov	QWORD PTR dictBase$1$[rsp], r8
	mov	QWORD PTR prefixStart$1$[rsp], r9
	lea	rax, QWORD PTR [r8+r11]
	mov	QWORD PTR dictEnd$1$[rsp], rax
	mov	eax, DWORD PTR [rdx+28]
	add	rax, r8
	mov	r8d, DWORD PTR [rsi+4]
	mov	QWORD PTR dictStart$1$[rsp], rax
	cmp	r12, r9

; 954  : 
; 955  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic");
; 956  : 
; 957  :     /* init */
; 958  :     ip += (ip == prefixStart);

	mov	eax, r13d
	mov	DWORD PTR offset_2$1$[rsp], r8d
	sete	al
	lea	rbx, QWORD PTR [rax+r12]
	cmp	rbx, rcx

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	jae	$LN5@ZSTD_compr
	mov	ecx, DWORD PTR [rdx+184]
	mov	QWORD PTR [rsp+176], r14
	mov	QWORD PTR [rsp+168], r15
	mov	r15d, 1
	shl	r15d, cl
	mov	DWORD PTR tv2256[rsp], r15d
	npad	1
$LL4@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 971  :         U32 current = (U32)(ip-base);

	mov	esi, ebx
	mov	rax, QWORD PTR base$1$[rsp]
	mov	r14, r13
	sub	esi, eax
	mov	r12, r13

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	mov	r9d, esi
	mov	DWORD PTR current$1$[rsp], esi
	sub	r9d, edi
	lea	r13, QWORD PTR [rbx+1]
	inc	r9d

; 976  :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	rdi, rax
	cmp	r9d, r11d

; 977  :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	lea	r8d, DWORD PTR [rsi+1]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	sub	r8d, r15d
	cmp	eax, r15d
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 978  :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))   /* intentional overflow */

	xor	r15d, r15d
	cmp	r9d, r8d
	mov	edx, r15d
	mov	eax, r15d
	mov	ecx, r11d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN14@ZSTD_compr

; 979  :             if (MEM_read32(ip+1) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r13], eax
	jne	SHORT $LN14@ZSTD_compr

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r11d

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r15, QWORD PTR [rbx+5]
	mov	rsi, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r10
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r10
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN46@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r15]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN46@ZSTD_compr:
	mov	r10, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r14, 4
	mov	esi, DWORD PTR current$1$[rsp]
$LN14@ZSTD_compr:

; 983  :                 if (depth==0) goto _storeSequence;
; 984  :         }   }
; 985  : 
; 986  :         /* first search (depth 0) */
; 987  :         {   size_t offsetFound = 999999999;
; 988  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$4[rsp]
	mov	r8, r10
	mov	QWORD PTR offsetFound$4[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_extDict_selectMLS

; 989  :             if (ml2 > matchLength)

	cmp	rax, r14
	jbe	SHORT $LN15@ZSTD_compr

; 990  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r12, QWORD PTR offsetFound$4[rsp]
	mov	r14, rax
	mov	r13, rbx
$LN15@ZSTD_compr:

; 991  :         }
; 992  : 
; 993  :          if (matchLength < 4) {

	cmp	r14, 4
	jae	SHORT $LN218@ZSTD_compr

; 994  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	r12, QWORD PTR src$[rsp]
	mov	rax, rbx

; 995  :             continue;

	mov	r10, QWORD PTR ilimit$1$[rsp]
	sub	rax, r12
	sar	rax, 8
	inc	rbx
	add	rbx, rax
	jmp	$LN31@ZSTD_compr
$LN218@ZSTD_compr:

; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)
; 1000 :         while (ip<ilimit) {

	mov	rdi, QWORD PTR ilimit$1$[rsp]
	cmp	rbx, rdi
	jae	$LN28@ZSTD_compr
	mov	r11d, DWORD PTR tv2256[rsp]
	mov	r15d, esi
	mov	rbp, QWORD PTR iend$1$[rsp]
	sub	r15d, r11d
	jmp	SHORT $LN6@ZSTD_compr
$LL252@ZSTD_compr:
	mov	r11d, DWORD PTR tv2256[rsp]
$LN6@ZSTD_compr:

; 1001 :             ip ++;
; 1002 :             current++;

	inc	esi
	inc	r15d
	inc	rbx
	mov	DWORD PTR current$1$[rsp], esi
	mov	DWORD PTR tv2006[rsp], r15d

; 1003 :             /* check repCode */
; 1004 :             if (offset) {

	test	r12, r12
	je	$LN21@ZSTD_compr

; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r9d, DWORD PTR dictLimit$1$[rsp]
	mov	r8d, esi
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r10, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r8d, r9d
	mov	rdi, QWORD PTR base$1$[rsp]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	sub	ecx, r11d

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r10+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, esi
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1006 :                 const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, r11d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r10+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1009 :                 if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r8d, ecx
	mov	edx, eax
	mov	ecx, r9d
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN251@ZSTD_compr

; 1010 :                 if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN251@ZSTD_compr

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	mov	rsi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, rbp
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN59@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r15
	mov	r8, rbp
	call	ZSTD_count
	add	r15, rax
$LN59@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR current$1$[rsp]
	lea	eax, DWORD PTR [r12+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r15+4]

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	r15d, DWORD PTR tv2006[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	mov	DWORD PTR r$1[rsp], r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r14+r14*2]
	sub	ecx, eax
	inc	ecx

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN251@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	lea	rdi, QWORD PTR [rbp-8]
	cmp	eax, ecx
	jle	SHORT $LN21@ZSTD_compr

; 1017 :                         matchLength = repLength, offset = 0, start = ip;

	mov	r14, rdx
	mov	r12d, r8d
	mov	r13, rbx
	jmp	SHORT $LN21@ZSTD_compr
$LN251@ZSTD_compr:

; 1018 :             }   }
; 1019 : 
; 1020 :             /* search match, depth 1 */
; 1021 :             {   size_t offset2=999999999;

	lea	rdi, QWORD PTR [rbp-8]
$LN21@ZSTD_compr:

; 1022 :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$5[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$5[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_extDict_selectMLS

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r10, QWORD PTR offset2$5[rsp]

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	edx, DWORD PTR [r14*4]
	mov	r9, rax
	mov	DWORD PTR gain1$1$[rsp], edx
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r11d, r11d
	mov	DWORD PTR r$9[rsp], r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r10+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$8[rsp], r11d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	r8d, DWORD PTR [r9*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	r8d, eax

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [r12+1]
	mov	DWORD PTR tv2019[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	sub	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	edx, 4

; 1025 :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r9, 4
	jb	SHORT $LN22@ZSTD_compr
	cmp	r8d, edx
	jle	SHORT $LN22@ZSTD_compr

; 1026 :                     matchLength = ml2, offset = offset2, start = ip;

	mov	r14, r9
	mov	r12, r10

; 1027 :                     continue;   /* search a better one */

	jmp	$LN253@ZSTD_compr
$LN22@ZSTD_compr:

; 1028 :             }   }
; 1029 : 
; 1030 :             /* let's find an even better one */
; 1031 :             if ((depth==2) && (ip<ilimit)) {

	cmp	rbx, rdi
	jae	$LN239@ZSTD_compr

; 1032 :                 ip ++;
; 1033 :                 current++;

	inc	esi
	inc	r15d
	inc	rbx
	mov	DWORD PTR current$1$[rsp], esi
	mov	DWORD PTR tv2006[rsp], r15d

; 1034 :                 /* check repCode */
; 1035 :                 if (offset) {

	test	r12, r12
	je	$LN27@ZSTD_compr

; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r9d, DWORD PTR dictLimit$1$[rsp]
	mov	r8d, esi
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r10, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r8d, r9d
	mov	rdi, QWORD PTR base$1$[rsp]
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]

; 1039 :                     const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r10+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1039 :                     const BYTE* const repMatch = repBase + repIndex;

	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, esi
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1037 :                     const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, DWORD PTR tv2256[rsp]

; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	eax, r11d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r10+32], r11d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	edx, r11d
	cmp	r8d, ecx
	mov	ecx, r9d
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN249@ZSTD_compr

; 1041 :                     if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN249@ZSTD_compr

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	mov	rsi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, rbp
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN78@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r15
	mov	r8, rbp
	call	ZSTD_count
	add	r15, rax
$LN78@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	r8d, DWORD PTR gain1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r15+4]

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	mov	esi, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r9d, r9d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2019[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	mov	r15d, DWORD PTR tv2006[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r9d
	mov	DWORD PTR r$2[rsp], r9d
	cmovne	ecx, eax
	sub	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1046 :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r8d

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN249@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	lea	rdi, QWORD PTR [rbp-8]
	cmp	eax, r8d
	jle	SHORT $LN27@ZSTD_compr

; 1048 :                             matchLength = repLength, offset = 0, start = ip;

	mov	r14, rdx
	mov	r12d, r9d
	mov	r13, rbx
	jmp	SHORT $LN27@ZSTD_compr
$LN249@ZSTD_compr:

; 1049 :                 }   }
; 1050 : 
; 1051 :                 /* search match, depth 2 */
; 1052 :                 {   size_t offset2=999999999;

	lea	rdi, QWORD PTR [rbp-8]
$LN27@ZSTD_compr:

; 1053 :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$3[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$3[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	ZSTD_BtFindBestMatch_extDict_selectMLS

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$3[rsp]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$7[rsp], r10d
	mov	DWORD PTR r$6[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [r12+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [r14*4]
	sub	ecx, eax
	add	ecx, 7

; 1056 :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN239@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN239@ZSTD_compr

; 1057 :                         matchLength = ml2, offset = offset2, start = ip;

	mov	r14, r8
	mov	r12, r9
$LN253@ZSTD_compr:

; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)
; 1000 :         while (ip<ilimit) {

	mov	r13, rbx
	cmp	rbx, rdi
	jb	$LL252@ZSTD_compr
$LN239@ZSTD_compr:
	mov	rbp, QWORD PTR seqStore$[rsp]
$LN28@ZSTD_compr:

; 1058 :                         continue;
; 1059 :             }   }   }
; 1060 :             break;  /* nothing found : store previous solution */
; 1061 :         }
; 1062 : 
; 1063 :         /* catch up */
; 1064 :         if (offset) {

	mov	r15d, DWORD PTR dictLimit$1$[rsp]
	mov	r10, QWORD PTR src$[rsp]
	test	r12, r12
	je	SHORT $_storeSequence$256

; 1065 :             U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	rdx, QWORD PTR base$1$[rsp]
	mov	eax, r13d

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	r8, QWORD PTR prefixStart$1$[rsp]
	sub	eax, edx
	sub	eax, r12d
	add	eax, 2
	cmp	eax, r15d
	cmovb	r8, QWORD PTR dictStart$1$[rsp]

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	r13, r10
	jbe	SHORT $LN240@ZSTD_compr

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	rcx, QWORD PTR dictBase$1$[rsp]
	cmp	eax, r15d
	cmovae	rcx, rdx
	add	rcx, rax
	npad	7
$LL8@ZSTD_compr:

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	rcx, r8
	jbe	SHORT $LN240@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [r13-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN240@ZSTD_compr
	dec	rcx
	inc	r14
	mov	r13, rdx
	cmp	rdx, r10
	ja	SHORT $LL8@ZSTD_compr
$LN240@ZSTD_compr:

; 1069 :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], eax
	lea	eax, DWORD PTR [r12-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
$_storeSequence$256:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r11, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1075 :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1074 :         {   size_t const litLength = start - anchor;

	mov	rbx, r13
	sub	rbx, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rsi, QWORD PTR [r11-32]
	mov	QWORD PTR litLimit_w$1$[rsp], rsi

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rbx+r10]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rsi
	ja	SHORT $LN90@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rbx, 16
	jbe	SHORT $LN91@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rbx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	lea	rcx, QWORD PTR [r10+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rdx, rax
	npad	8
$LL104@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL104@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN91@ZSTD_compr
$LN90@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rsi
	mov	rdx, r10
	call	ZSTD_safecopyLiterals
	mov	r11, QWORD PTR iend$1$[rsp]
$LN91@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], rbx

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbp+8]
	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN93@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN93@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], bx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r12+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN232@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN232@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	r12, QWORD PTR [r14+r13]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	r10, QWORD PTR [r11-8]
	mov	QWORD PTR src$[rsp], r12
	mov	rbx, r12
	cmp	r12, r10

; 1080 :         while (ip <= ilimit) {

	ja	$LN31@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	jmp	SHORT $LN10@ZSTD_compr
	npad	5
$LL243@ZSTD_compr:
	mov	r11, QWORD PTR iend$1$[rsp]
$LN10@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	rdx, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	mov	r8d, ebx
	mov	rdi, QWORD PTR base$1$[rsp]
	mov	r13d, DWORD PTR offset_2$1$[rsp]
	sub	r8d, edi

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	mov	r9d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r9d, r13d

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r9d, r15d

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	cmovb	rdi, QWORD PTR dictBase$1$[rsp]
	add	rdi, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r8d, DWORD PTR tv2256[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	cmp	eax, DWORD PTR tv2256[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1086 :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r9d, r8d
	mov	edx, eax
	mov	ecx, r15d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN241@ZSTD_compr

; 1087 :             if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN241@ZSTD_compr

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r15d
	mov	rsi, r11

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r15, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r11
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	add	rcx, rsi
	cmp	rcx, r11
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	jne	SHORT $LN139@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r15]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN139@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	eax, DWORD PTR offset_1$1$[rsp]
	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	rsi, QWORD PTR litLimit_w$1$[rsp]
	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	DWORD PTR offset_2$1$[rsp], eax
	mov	DWORD PTR offset_1$1$[rsp], r13d

; 1092 :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdi, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r12, rsi
	ja	SHORT $LN174@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN175@ZSTD_compr
$LN174@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, rsi
	mov	r8, r12
	mov	rdx, r12
	call	ZSTD_safecopyLiterals
$LN175@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	r15d, r15d
	mov	WORD PTR [rax+4], r15w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN233@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN233@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	mov	r10, QWORD PTR ilimit$1$[rsp]

; 1093 :                 ip += matchLength;

	add	rbx, r14
	mov	r15d, DWORD PTR dictLimit$1$[rsp]
	mov	r12, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	cmp	rbx, r10
	jbe	$LL243@ZSTD_compr
$LN241@ZSTD_compr:
	mov	QWORD PTR src$[rsp], r12
$LN31@ZSTD_compr:

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	mov	r11d, DWORD PTR dictLimit$1$[rsp]
	cmp	rbx, r10
	mov	r10, QWORD PTR iend$1$[rsp]
	mov	r13d, 0
	mov	rdx, QWORD PTR ms$[rsp]
	mov	edi, DWORD PTR offset_1$1$[rsp]
	mov	r15d, DWORD PTR tv2256[rsp]
	jb	$LL4@ZSTD_compr
	mov	r8d, DWORD PTR offset_2$1$[rsp]
	mov	rsi, QWORD PTR rep$[rsp]
	mov	r15, QWORD PTR [rsp+168]
	mov	r14, QWORD PTR [rsp+176]
$LN5@ZSTD_compr:

; 1103 : 
; 1104 :     /* Return the last literals size */
; 1105 :     return (size_t)(iend - anchor);

	sub	r10, r12
	mov	DWORD PTR [rsi], edi

; 1137 :     return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2);

	mov	rax, r10

; 1102 :     rep[1] = offset_2;

	mov	DWORD PTR [rsi+4], r8d

; 1138 : }

	add	rsp, 184				; 000000b8H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_btlazy2_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_64bits PROC

; 184  : MEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }

	mov	eax, 1
	ret	0
MEM_64bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readST PROC

; 254  :     size_t val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 255  : }

	ret	0
MEM_readST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy8 PROC

; 231  : #ifdef __aarch64__
; 232  :     vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));
; 233  : #else
; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 235  : #endif
; 236  : }

	ret	0
ZSTD_copy8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy16 PROC

; 240  : #ifdef __aarch64__
; 241  :     vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));
; 242  : #else
; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 244  : #endif
; 245  : }

	ret	0
ZSTD_copy16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
length$ = 24
ovtype$dead$ = 32
ZSTD_wildcopy PROC

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;
; 268  :     const BYTE* ip = (const BYTE*)src;
; 269  :     BYTE* op = (BYTE*)dst;
; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [rcx+r8]
	sub	rdx, rcx
	npad	9
$LL7@ZSTD_wildc:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {
; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)
; 278  :         } while (op < oend);
; 279  :     } else {
; 280  :         assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);
; 281  :         /* Separate out the first COPY16() call because the copy length is
; 282  :          * almost certain to be short, so the branches have different
; 283  :          * probabilities. Since it is almost certain to be short, only do
; 284  :          * one COPY16() in the first call. Then, do two calls per loop since
; 285  :          * at that point it is more likely to have a high trip count.
; 286  :          */
; 287  : #ifndef __aarch64__
; 288  :         do {
; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL7@ZSTD_wildc

; 292  : #else
; 293  :         COPY16(op, ip);
; 294  :         if (op >= oend) return;
; 295  :         do {
; 296  :             COPY16(op, ip);
; 297  :             COPY16(op, ip);
; 298  :         }
; 299  :         while (op < oend);
; 300  : #endif
; 301  :     }
; 302  : }

	ret	0
ZSTD_wildcopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
val$ = 8
ZSTD_highbit32 PROC

; 394  :     assert(val != 0);
; 395  :     {
; 396  : #   if defined(_MSC_VER)   /* Visual */
; 397  :         unsigned long r=0;

	xor	eax, eax

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 399  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* GCC Intrinsic */
; 400  :         return __builtin_clz (val) ^ 31;
; 401  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 402  :         return 31 - __CLZ(val);
; 403  : #   else   /* Software version */
; 404  :         static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
; 405  :         U32 v = val;
; 406  :         v |= v >> 1;
; 407  :         v |= v >> 2;
; 408  :         v |= v >> 4;
; 409  :         v |= v >> 8;
; 410  :         v |= v >> 16;
; 411  :         return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];
; 412  : #   endif
; 413  :     }
; 414  : }

	ret	0
ZSTD_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
op$ = 8
ip$ = 16
iend$ = 24
ilimit_w$ = 32
ZSTD_safecopyLiterals PROC

; 423  :     assert(iend > ilimit_w);
; 424  :     if (ip <= ilimit_w) {

	cmp	rdx, r9
	ja	SHORT $LN19@ZSTD_safec
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r10, rcx
	sub	r10, rdx
	add	r10, r9
	sub	rdx, rcx
	npad	15
$LL12@ZSTD_safec:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL12@ZSTD_safec
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	mov	rdx, r9
$LN19@ZSTD_safec:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdx, r8
	jae	SHORT $LN3@ZSTD_safec
	npad	5
$LL21@ZSTD_safec:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	cmp	rdx, r8
	jb	SHORT $LL21@ZSTD_safec
$LN3@ZSTD_safec:

; 430  : }

	ret	0
ZSTD_safecopyLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
seqStorePtr$ = 8
litLength$ = 16
literals$ = 24
litLimit$ = 32
offCode$ = 40
mlBase$ = 48
ZSTD_storeSeq PROC

; 440  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	r10, rcx

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rcx, QWORD PTR [rdx+r8]
	mov	r11, rdx
	mov	r9, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	rcx, rbx
	ja	SHORT $LN2@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r9], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	SHORT $LN24@ZSTD_store

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rdx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r8, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	3
$LL16@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]

; 289  :             COPY16(op, ip);

	lea	r8, QWORD PTR [r8+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL16@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN24@ZSTD_store
$LN2@ZSTD_store:

; 424  :     if (ip <= ilimit_w) {

	cmp	r8, rbx
	ja	SHORT $LN41@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, r9
	sub	rdx, r8
	add	rdx, rbx
	sub	r8, r9
	npad	9
$LL33@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+r9]
	movups	XMMWORD PTR [r9], xmm0

; 289  :             COPY16(op, ip);

	add	r9, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	r9, rdx
	jb	SHORT $LL33@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	r9, rdx
	mov	r8, rbx
$LN41@ZSTD_store:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r8, rcx
	jae	SHORT $LN24@ZSTD_store
	sub	r9, r8
$LL43@ZSTD_store:
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r9+r8], al
	inc	r8
	cmp	r8, rcx
	jb	SHORT $LL43@ZSTD_store
$LN24@ZSTD_store:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);
; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], r11
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r11, 65535				; 0000ffffH
	jbe	SHORT $LN48@ZSTD_store

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN48@ZSTD_store:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;
; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;
; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	mov	rdx, QWORD PTR mlBase$[rsp]
	mov	WORD PTR [rcx+4], r11w
	mov	ecx, DWORD PTR offCode$[rsp]
	mov	rax, QWORD PTR [r10+8]
	inc	ecx
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r10+8]
	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN53@ZSTD_store

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 2
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN53@ZSTD_store:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;
; 488  : 
; 489  :     seqStorePtr->sequences++;
; 490  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	WORD PTR [rcx+6], dx
	add	QWORD PTR [r10+8], 8
	ret	0
ZSTD_storeSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
val$ = 8
r$1 = 16
ZSTD_NbCommonBytes PROC

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN9@ZSTD_NbCom
	shr	eax, 3

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
$LN9@ZSTD_NbCom:

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
ZSTD_NbCommonBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
r$1 = 8
r$2 = 8
pIn$ = 8
pMatch$ = 16
pInLimit$ = 24
ZSTD_count PROC

; 563  :     const BYTE* const pStart = pIn;
; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r9, QWORD PTR [r8-7]
	mov	r10, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN5@ZSTD_count

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN20@ZSTD_count
	shr	eax, 3

; 580  : }

	ret	0
$LN20@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 580  : }

	ret	0
$LN5@ZSTD_count:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count
$LL2@ZSTD_count:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN6@ZSTD_count
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r9
	jb	SHORT $LL2@ZSTD_count
$LN3@ZSTD_count:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r8-3]
	cmp	rcx, rax
	jae	SHORT $LN7@ZSTD_count
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN7@ZSTD_count
	add	rcx, 4
	add	rdx, 4
$LN7@ZSTD_count:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r8-1]
	cmp	rcx, rax
	jae	SHORT $LN8@ZSTD_count
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN8@ZSTD_count
	add	rcx, 2
	add	rdx, 2
$LN8@ZSTD_count:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r8
	jae	SHORT $LN9@ZSTD_count
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN9@ZSTD_count
	inc	rcx
$LN9@ZSTD_count:

; 579  :     return (size_t)(pIn - pStart);

	sub	rcx, r10
	mov	rax, rcx

; 580  : }

	ret	0
$LN6@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN36@ZSTD_count
	shr	edx, 3

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
$LN36@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
ZSTD_count ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ip$ = 48
match$ = 56
iEnd$ = 64
mEnd$ = 72
iStart$ = 80
ZSTD_count_2segments PROC

; 589  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r10, rcx
	mov	rsi, r8
	sub	r10, rdx
	mov	rbx, r9
	add	r10, r9
	mov	r11, rdx
	cmp	r10, r8
	mov	rbp, rcx
	cmovb	r8, r10

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	call	ZSTD_count
	mov	rdi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	jne	SHORT $LN1@ZSTD_count

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR iStart$[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	mov	r8, rsi
	call	ZSTD_count
	add	rax, rdi
$LN1@ZSTD_count:

; 599  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_count_2segments ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash4 PROC

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, ecx, -1640531535			; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	eax, cl
	ret	0
ZSTD_hash4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ptr$ = 8
h$ = 16
ZSTD_hash4Ptr PROC

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	rax, cl

; 611  : static size_t ZSTD_hash4Ptr(const void* ptr, U32 h) { return ZSTD_hash4(MEM_read32(ptr), h); }

	ret	0
ZSTD_hash4Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash5 PROC

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash5 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash5Ptr PROC

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 615  : static size_t ZSTD_hash5Ptr(const void* p, U32 h) { return ZSTD_hash5(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash5Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash6 PROC

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash6Ptr PROC

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 619  : static size_t ZSTD_hash6Ptr(const void* p, U32 h) { return ZSTD_hash6(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash6Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash7 PROC

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash7 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash7Ptr PROC

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 623  : static size_t ZSTD_hash7Ptr(const void* p, U32 h) { return ZSTD_hash7(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash7Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash8 PROC

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash8Ptr PROC

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 627  : static size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash8Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
hBits$ = 16
mls$ = 24
ZSTD_hashPtr PROC

; 631  :     switch(mls)

	sub	r8d, 5
	je	SHORT $LN5@ZSTD_hashP
	sub	r8d, 1
	je	SHORT $LN6@ZSTD_hashP
	sub	r8d, 1
	je	SHORT $LN7@ZSTD_hashP
	cmp	r8d, 1
	je	SHORT $LN8@ZSTD_hashP

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN8@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN7@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN6@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN5@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hashPtr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 8
current$ = 16
windowLog$ = 24
ZSTD_getLowestMatchIndex PROC

; 977  : {

	mov	rax, rcx

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r8d
	mov	r8d, 1
	shl	r8d, cl

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r9d, DWORD PTR [rax+28]

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;
; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, DWORD PTR [rax+32]
	mov	eax, edx
	sub	edx, r8d
	sub	eax, r9d
	cmp	eax, r8d
	cmovbe	edx, r9d
	test	ecx, ecx

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	edx, r9d

; 983  :     return matchLowest;

	mov	eax, edx

; 984  : }

	ret	0
ZSTD_getLowestMatchIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 8
current$ = 16
windowLog$ = 24
ZSTD_getLowestPrefixIndex PROC

; 990  : {

	mov	rax, rcx

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r8d
	mov	r8d, 1
	shl	r8d, cl

; 992  :     U32    const lowestValid = ms->window.dictLimit;

	mov	r9d, DWORD PTR [rax+24]

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;
; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, DWORD PTR [rax+32]
	mov	eax, edx
	sub	edx, r8d
	sub	eax, r9d
	cmp	eax, r8d
	cmovbe	edx, r9d
	test	ecx, ecx

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	edx, r9d

; 996  :     return matchLowest;

	mov	eax, edx

; 997  : }

	ret	0
ZSTD_getLowestPrefixIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 48
ip$ = 56
iend$dead$ = 64
mls$ = 72
ZSTD_updateDUBT PROC

; 23   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15

; 24   :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 25   :     U32* const hashTable = ms->hashTable;

	mov	r14, QWORD PTR [rcx+48]
	mov	rbx, rcx

; 26   :     U32  const hashLog = cParams->hashLog;

	mov	r8d, DWORD PTR [rcx+192]
	mov	r11, rdx

; 27   : 
; 28   :     U32* const bt = ms->chainTable;

	mov	r15, QWORD PTR [rcx+64]

; 29   :     U32  const btLog  = cParams->chainLog - 1;
; 30   :     U32  const btMask = (1 << btLog) - 1;

	mov	esi, 1
	mov	ecx, DWORD PTR [rcx+188]
	mov	edi, r9d

; 31   : 
; 32   :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [rbx+8]
	dec	ecx

; 33   :     U32 const target = (U32)(ip - base);
; 34   :     U32 idx = ms->nextToUpdate;

	mov	r10d, DWORD PTR [rbx+36]
	sub	r11d, edx
	shl	esi, cl
	dec	esi

; 35   : 
; 36   :     if (idx != target)
; 37   :         DEBUGLOG(7, "ZSTD_updateDUBT, from %u to %u (dictLimit:%u)",
; 38   :                     idx, target, ms->window.dictLimit);
; 39   :     assert(ip + 8 <= iend);   /* condition for ZSTD_hashPtr */
; 40   :     (void)iend;
; 41   : 
; 42   :     assert(idx >= ms->window.dictLimit);   /* condition for valid base+idx */
; 43   :     for ( ; idx < target ; idx++) {

	cmp	r10d, r11d
	jae	$LN40@ZSTD_updat
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+56], rbp

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r9d, 64					; 00000040H

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+64], r12
	mov	ebp, 32					; 00000020H
	sub	ebp, r8d
	mov	QWORD PTR [rsp+72], r13

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	sub	r9d, r8d

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	lea	r8, QWORD PTR [rdx+r10]
	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	mov	r12, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r13, -3523014627193167104		; cf1bbcdcbfa56300H
$LL4@ZSTD_updat:

; 627  : static size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h); }
; 628  : 
; 629  : MEM_STATIC size_t ZSTD_hashPtr(const void* p, U32 hBits, U32 mls)
; 630  : {
; 631  :     switch(mls)

	mov	eax, edi
	sub	eax, 5
	je	SHORT $LN11@ZSTD_updat
	sub	eax, 1
	je	SHORT $LN12@ZSTD_updat
	sub	eax, 1
	je	SHORT $LN13@ZSTD_updat
	cmp	eax, 1
	je	SHORT $LN14@ZSTD_updat

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [r8], -1640531535	; 9e3779b1H
	mov	rcx, rbp

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN41@ZSTD_updat
$LN14@ZSTD_updat:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, r12

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN42@ZSTD_updat
$LN13@ZSTD_updat:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, r13

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN42@ZSTD_updat
$LN12@ZSTD_updat:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, rbx

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN42@ZSTD_updat
$LN11@ZSTD_updat:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, rcx
$LN42@ZSTD_updat:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 45   :         U32    const matchIndex = hashTable[h];

	mov	ecx, r9d
$LN41@ZSTD_updat:
	shr	rax, cl
	inc	r8
	mov	edx, DWORD PTR [r14+rax*4]
	lea	rcx, QWORD PTR [r14+rax*4]

; 46   : 
; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	mov	eax, r10d

; 48   :         U32*   const sortMarkPtr  = nextCandidatePtr + 1;
; 49   : 
; 50   :         DEBUGLOG(8, "ZSTD_updateDUBT: insert %u", idx);
; 51   :         hashTable[h] = idx;   /* Update Hash Table */

	mov	DWORD PTR [rcx], r10d
	and	eax, esi
	inc	r10d
	add	eax, eax
	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H

; 52   :         *nextCandidatePtr = matchIndex;   /* update BT like a chain */

	mov	DWORD PTR [r15+rax*4], edx

; 53   :         *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;

	mov	DWORD PTR [r15+rax*4+4], 1
	cmp	r10d, r11d
	jb	SHORT $LL4@ZSTD_updat

; 54   :     }
; 55   :     ms->nextToUpdate = target;

	mov	rbx, QWORD PTR ms$[rsp]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
$LN40@ZSTD_updat:

; 56   : }

	mov	DWORD PTR [rbx+36], r11d
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ZSTD_updateDUBT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
largerPtr$1$ = 32
btMask$1$ = 40
tv748 = 44
tv741 = 48
smallerPtr$1$ = 56
dictEnd$1$ = 64
dictBase$1$ = 72
base$1$ = 80
commonLengthLarger$1$ = 88
commonLengthSmaller$1$ = 96
tv750 = 104
bt$1$ = 112
prefixStart$1$ = 120
dictLimit$1$ = 192
ms$ = 192
current$ = 200
inputEnd$ = 208
r$1 = 216
r$2 = 216
dummy32$ = 216
nbCompares$ = 216
btLow$ = 224
dictMode$ = 232
ZSTD_insertDUBT1 PROC

; 68   : {

	mov	QWORD PTR [rsp+24], rbx
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H

; 69   :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 70   :     U32* const bt = ms->chainTable;

	mov	rax, QWORD PTR [rcx+64]
	mov	r10, rcx

; 71   :     U32  const btLog  = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [rcx+188]

; 72   :     U32  const btMask = (1 << btLog) - 1;

	mov	r11d, 1
	mov	edi, edx
	dec	ecx
	mov	QWORD PTR bt$1$[rsp], rax
	mov	r12d, r11d

; 73   :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 74   :     const BYTE* const base = ms->window.base;
; 75   :     const BYTE* const dictBase = ms->window.dictBase;
; 76   :     const U32 dictLimit = ms->window.dictLimit;

	mov	esi, DWORD PTR [r10+24]
	mov	r14d, r9d
	mov	rdx, QWORD PTR [r10+8]
	xor	r9d, r9d
	mov	rbx, QWORD PTR [r10+16]
	mov	r13, r8
	shl	r12d, cl
	xor	r8d, r8d
	dec	r12d
	mov	QWORD PTR commonLengthSmaller$1$[rsp], r8

; 77   :     const BYTE* const ip = (current>=dictLimit) ? base + current : dictBase + current;
; 78   :     const BYTE* const iend = (current>=dictLimit) ? inputEnd : dictBase + dictLimit;

	cmp	edi, esi
	mov	DWORD PTR btMask$1$[rsp], r12d
	mov	rax, rdx
	mov	QWORD PTR commonLengthLarger$1$[rsp], r9
	cmovb	rax, rbx
	mov	QWORD PTR base$1$[rsp], rdx
	add	rax, rdi
	mov	QWORD PTR dictBase$1$[rsp], rbx
	mov	DWORD PTR dictLimit$1$[rsp], esi
	mov	r15d, esi
	mov	QWORD PTR tv741[rsp], rax
	mov	QWORD PTR tv750[rsp], rsi
	cmp	edi, esi
	jae	SHORT $LN17@ZSTD_inser
	lea	r13, QWORD PTR [rsi+rbx]
$LN17@ZSTD_inser:

; 79   :     const BYTE* const dictEnd = dictBase + dictLimit;
; 80   :     const BYTE* const prefixStart = base + dictLimit;
; 81   :     const BYTE* match;
; 82   :     U32* smallerPtr = bt + 2*(current&btMask);
; 83   :     U32* largerPtr  = smallerPtr + 1;
; 84   :     U32 matchIndex = *smallerPtr;   /* this candidate is unsorted : next sorted candidate is reached through *smallerPtr, while *largerPtr contains previous unsorted candidate (which is already saved and can be overwritten) */
; 85   :     U32 dummy32;   /* to be nullified at the end */
; 86   :     U32 const windowValid = ms->window.lowLimit;
; 87   :     U32 const maxDistance = 1U << cParams->windowLog;

	mov	ecx, DWORD PTR [r10+184]
	lea	rax, QWORD PTR [rsi+rbx]
	mov	rbx, QWORD PTR bt$1$[rsp]
	mov	QWORD PTR dictEnd$1$[rsp], rax
	lea	rax, QWORD PTR [rsi+rdx]
	mov	QWORD PTR prefixStart$1$[rsp], rax
	mov	eax, r12d
	and	eax, edi
	shl	r11d, cl
	add	eax, eax

; 88   :     U32 const windowLow = (current - windowValid > maxDistance) ? current - maxDistance : windowValid;
; 89   : 
; 90   : 
; 91   :     DEBUGLOG(8, "ZSTD_insertDUBT1(%u) (dictLimit=%u, lowLimit=%u)",
; 92   :                 current, dictLimit, windowLow);
; 93   :     assert(current >= btLow);
; 94   :     assert(ip < iend);   /* condition for ZSTD_count */
; 95   : 
; 96   :     while (nbCompares-- && (matchIndex > windowLow)) {

	mov	ecx, edi
	mov	ebp, DWORD PTR [rbx+rax*4]
	lea	rsi, QWORD PTR [rbx+rax*4]
	sub	ecx, r11d
	mov	QWORD PTR smallerPtr$1$[rsp], rsi
	lea	rax, QWORD PTR [rsi+4]
	mov	QWORD PTR largerPtr$1$[rsp], rax
	mov	eax, edi
	sub	eax, DWORD PTR [r10+28]
	cmp	eax, r11d
	cmovbe	ecx, DWORD PTR [r10+28]
	mov	DWORD PTR tv748[rsp], ecx
	test	r14d, r14d
	je	$LN88@ZSTD_inser
	mov	r10d, DWORD PTR btLow$[rsp]
	npad	2
$LL2@ZSTD_inser:
	dec	r14d
	mov	DWORD PTR nbCompares$[rsp], r14d
	cmp	ebp, ecx
	jbe	$LN88@ZSTD_inser

; 97   :         U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, ebp
	and	eax, r12d
	add	eax, eax

; 98   :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	cmp	r8, r9
	lea	r12, QWORD PTR [rbx+rax*4]
	mov	rbx, r9
	cmovb	rbx, r8

; 99   :         assert(matchIndex < current);
; 100  :         /* note : all candidates are now supposed sorted,
; 101  :          * but it's still possible to have nextPtr[1] == ZSTD_DUBT_UNSORTED_MARK
; 102  :          * when a real index has the same value as ZSTD_DUBT_UNSORTED_MARK */
; 103  : 
; 104  :         if ( (dictMode != ZSTD_extDict)
; 105  :           || (matchIndex+matchLength >= dictLimit)  /* both in current segment*/
; 106  :           || (current < dictLimit) /* both in extDict */) {

	cmp	DWORD PTR dictMode$[rsp], 1
	jne	$LN20@ZSTD_inser
	mov	edi, ebp
	lea	rax, QWORD PTR [rdi+rbx]
	cmp	rax, r15
	jae	$LN20@ZSTD_inser
	mov	eax, DWORD PTR dictLimit$1$[rsp]
	cmp	DWORD PTR current$[rsp], eax
	jb	$LN82@ZSTD_inser

; 114  :         } else {
; 115  :             match = dictBase + matchIndex;

	mov	r15, QWORD PTR dictBase$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r13
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 116  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	mov	r14, QWORD PTR tv741[rsp]
	add	r15, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 116  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	add	r14, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 116  :             matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r15+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, r13
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN65@ZSTD_inser

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r14]
	mov	r8, r13
	call	ZSTD_count
	add	rsi, rax
$LN65@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 117  :             if (matchIndex+matchLength >= dictLimit)

	mov	r14d, DWORD PTR nbCompares$[rsp]
	add	rbx, rsi
	mov	rsi, QWORD PTR smallerPtr$1$[rsp]
	mov	r10d, DWORD PTR btLow$[rsp]
	lea	rax, QWORD PTR [rdi+rbx]
	cmp	rax, QWORD PTR tv750[rsp]
	jb	$LN7@ZSTD_inser

; 118  :                 match = base + matchIndex;   /* preparation for next read of match[matchLength] */

	mov	r15, QWORD PTR base$1$[rsp]
	add	r15, rdi
	jmp	$LN7@ZSTD_inser
$LN82@ZSTD_inser:

; 107  :             const BYTE* const mBase = ( (dictMode != ZSTD_extDict)

	mov	rax, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN21@ZSTD_inser
$LN20@ZSTD_inser:
	mov	rax, QWORD PTR base$1$[rsp]
$LN21@ZSTD_inser:

; 112  :             match = mBase + matchIndex;

	mov	r15d, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [r13-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 112  :             match = mBase + matchIndex;

	add	r15, rax

; 113  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	mov	rax, QWORD PTR tv741[rsp]
	add	rax, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r9, rax
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 113  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	lea	rdx, QWORD PTR [r15+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN24@ZSTD_inser

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN26@ZSTD_inser

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN41@ZSTD_inser
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN22@ZSTD_inser
$LN41@ZSTD_inser:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN22@ZSTD_inser
$LN26@ZSTD_inser:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN24@ZSTD_inser
$LL23@ZSTD_inser:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN27@ZSTD_inser
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL23@ZSTD_inser
$LN24@ZSTD_inser:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r13-3]
	cmp	rax, rcx
	jae	SHORT $LN28@ZSTD_inser
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN28@ZSTD_inser
	add	rax, 4
	add	rdx, 4
$LN28@ZSTD_inser:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r13-1]
	cmp	rax, rcx
	jae	SHORT $LN29@ZSTD_inser
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN29@ZSTD_inser
	add	rax, 2
	add	rdx, 2
$LN29@ZSTD_inser:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r13
	jae	SHORT $LN30@ZSTD_inser
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN30@ZSTD_inser
	inc	rax
$LN30@ZSTD_inser:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r9
$LN22@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 113  :             matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	add	rbx, rcx
$LN7@ZSTD_inser:

; 119  :         }
; 120  : 
; 121  :         DEBUGLOG(8, "ZSTD_insertDUBT1: comparing %u with %u : found %u common bytes ",
; 122  :                     current, matchIndex, (U32)matchLength);
; 123  : 
; 124  :         if (ip+matchLength == iend) {   /* equal : no way to know if inf or sup */

	mov	rax, QWORD PTR tv741[rsp]
	add	rax, rbx
	cmp	rax, r13
	je	$LN88@ZSTD_inser

; 125  :             break;   /* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */
; 126  :         }
; 127  : 
; 128  :         if (match[matchLength] < ip[matchLength]) {  /* necessarily within buffer */

	movzx	eax, BYTE PTR [rax]
	cmp	BYTE PTR [r15+rbx], al
	jae	SHORT $LN9@ZSTD_inser

; 129  :             /* match is smaller than current */
; 130  :             *smallerPtr = matchIndex;             /* update smaller idx */

	mov	DWORD PTR [rsi], ebp

; 131  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	r8, rbx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 132  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	cmp	ebp, r10d
	jbe	$LN73@ZSTD_inser

; 133  :             DEBUGLOG(8, "ZSTD_insertDUBT1: %u (>btLow=%u) is smaller : next => %u",
; 134  :                         matchIndex, btLow, nextPtr[1]);
; 135  :             smallerPtr = nextPtr+1;               /* new "candidate" => larger than match, which was smaller than target */
; 136  :             matchIndex = nextPtr[1];              /* new matchIndex, larger than previous and closer to current */

	mov	ebp, DWORD PTR [r12+4]
	lea	rsi, QWORD PTR [r12+4]

; 137  :         } else {

	mov	r9, QWORD PTR commonLengthLarger$1$[rsp]
	mov	QWORD PTR smallerPtr$1$[rsp], rsi
	jmp	SHORT $LN10@ZSTD_inser
$LN27@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN57@ZSTD_inser
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	SHORT $LN22@ZSTD_inser
$LN57@ZSTD_inser:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	SHORT $LN22@ZSTD_inser
$LN9@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 139  :             *largerPtr = matchIndex;

	mov	rax, QWORD PTR largerPtr$1$[rsp]

; 140  :             commonLengthLarger = matchLength;

	mov	r9, rbx
	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx
	mov	DWORD PTR [rax], ebp

; 141  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	cmp	ebp, r10d
	jbe	SHORT $LN74@ZSTD_inser

; 142  :             DEBUGLOG(8, "ZSTD_insertDUBT1: %u (>btLow=%u) is larger => %u",
; 143  :                         matchIndex, btLow, nextPtr[0]);
; 144  :             largerPtr = nextPtr;
; 145  :             matchIndex = nextPtr[0];

	mov	ebp, DWORD PTR [r12]
	mov	r8, QWORD PTR commonLengthSmaller$1$[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], r12
$LN10@ZSTD_inser:

; 88   :     U32 const windowLow = (current - windowValid > maxDistance) ? current - maxDistance : windowValid;
; 89   : 
; 90   : 
; 91   :     DEBUGLOG(8, "ZSTD_insertDUBT1(%u) (dictLimit=%u, lowLimit=%u)",
; 92   :                 current, dictLimit, windowLow);
; 93   :     assert(current >= btLow);
; 94   :     assert(ip < iend);   /* condition for ZSTD_count */
; 95   : 
; 96   :     while (nbCompares-- && (matchIndex > windowLow)) {

	test	r14d, r14d
	je	SHORT $LN88@ZSTD_inser
	mov	r15, QWORD PTR tv750[rsp]
	mov	r12d, DWORD PTR btMask$1$[rsp]
	mov	ecx, DWORD PTR tv748[rsp]
	mov	rbx, QWORD PTR bt$1$[rsp]
	jmp	$LL2@ZSTD_inser
$LN73@ZSTD_inser:

; 132  :             if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	lea	rsi, QWORD PTR dummy32$[rsp]
$LN88@ZSTD_inser:

; 146  :     }   }
; 147  : 
; 148  :     *smallerPtr = *largerPtr = 0;

	mov	rax, QWORD PTR largerPtr$1$[rsp]
$LN76@ZSTD_inser:

; 149  : }

	mov	rbx, QWORD PTR [rsp+208]
	xor	ecx, ecx
	mov	DWORD PTR [rax], ecx
	mov	DWORD PTR [rsi], ecx
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN74@ZSTD_inser:

; 141  :             if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop searching */

	lea	rax, QWORD PTR dummy32$[rsp]
	jmp	SHORT $LN76@ZSTD_inser
ZSTD_insertDUBT1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
current$1$ = 32
tv613 = 36
dictLowLimit$1$ = 40
btMask$1$ = 44
dictEnd$1$ = 48
commonLengthLarger$1$ = 56
commonLengthSmaller$1$ = 64
prefixStart$1$ = 72
base$1$ = 80
dictBase$1$ = 88
dictBt$1$ = 96
dictHighLimit$1$ = 192
ms$ = 192
ip$ = 200
iend$ = 208
offsetPtr$ = 216
nextPtr$1$ = 224
bestLength$ = 224
nbCompares$ = 232
mls$ = 240
dictIndexDelta$1$ = 248
dictMode$dead$ = 248
ZSTD_DUBT_findBetterDictMatch PROC

; 161  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 144				; 00000090H

; 162  :     const ZSTD_matchState_t * const dms = ms->dictMatchState;

	mov	rbx, QWORD PTR [rcx+176]
	mov	r9, rdx
	mov	r14, r8
	mov	r11, rcx

; 163  :     const ZSTD_compressionParameters* const dmsCParams = &dms->cParams;
; 164  :     const U32 * const dictHashTable = dms->hashTable;
; 165  :     U32         const hashLog = dmsCParams->hashLog;
; 166  :     size_t      const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	r8d, DWORD PTR mls$[rsp]
	mov	rcx, r9
	mov	edx, DWORD PTR [rbx+192]
	call	ZSTD_hashPtr

; 167  :     U32               dictMatchIndex = dictHashTable[h];
; 168  : 
; 169  :     const BYTE* const base = ms->window.base;
; 170  :     const BYTE* const prefixStart = base + ms->window.dictLimit;
; 171  :     U32         const current = (U32)(ip-base);
; 172  :     const BYTE* const dictBase = dms->window.base;
; 173  :     const BYTE* const dictEnd = dms->window.nextSrc;
; 174  :     U32         const dictHighLimit = (U32)(dms->window.nextSrc - dms->window.base);
; 175  :     U32         const dictLowLimit = dms->window.lowLimit;

	mov	r8d, DWORD PTR [rbx+28]
	mov	r10, QWORD PTR [rbx+48]
	mov	ecx, DWORD PTR [r11+24]
	mov	rdi, QWORD PTR [rbx+8]

; 176  :     U32         const dictIndexDelta = ms->window.lowLimit - dictHighLimit;
; 177  : 
; 178  :     U32*        const dictBt = dms->chainTable;
; 179  :     U32         const btLog  = dmsCParams->chainLog - 1;
; 180  :     U32         const btMask = (1 << btLog) - 1;
; 181  :     U32         const btLow = (btMask >= dictHighLimit - dictLowLimit) ? dictLowLimit : dictHighLimit - btMask;
; 182  : 
; 183  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 184  : 
; 185  :     (void)dictMode;
; 186  :     assert(dictMode == ZSTD_dictMatchState);
; 187  : 
; 188  :     while (nbCompares-- && (dictMatchIndex > dictLowLimit)) {

	mov	r12d, DWORD PTR nbCompares$[rsp]
	mov	esi, DWORD PTR [r10+rax*4]
	mov	rax, QWORD PTR [r11+8]
	mov	r10d, DWORD PTR [r11+28]
	add	rcx, rax
	mov	r11, QWORD PTR [rbx+64]
	mov	QWORD PTR prefixStart$1$[rsp], rcx
	mov	ecx, r9d
	sub	ecx, eax
	mov	QWORD PTR base$1$[rsp], rax
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR current$1$[rsp], ecx
	mov	edx, eax
	mov	ecx, DWORD PTR [rbx+188]
	sub	edx, edi
	sub	r10d, edx
	mov	DWORD PTR dictHighLimit$1$[rsp], edx
	dec	ecx
	mov	DWORD PTR dictIndexDelta$1$[rsp], r10d
	mov	QWORD PTR dictEnd$1$[rsp], rax
	mov	r10d, 1
	shl	r10d, cl
	mov	eax, edx
	mov	ecx, edx
	mov	QWORD PTR dictBase$1$[rsp], rdi
	dec	r10d
	mov	DWORD PTR dictLowLimit$1$[rsp], r8d
	sub	eax, r10d
	mov	QWORD PTR dictBt$1$[rsp], r11
	sub	ecx, r8d
	mov	DWORD PTR btMask$1$[rsp], r10d
	cmp	r10d, ecx
	mov	edx, r8d
	cmovb	edx, eax
	xor	ecx, ecx
	mov	DWORD PTR tv613[rsp], edx
	xor	edx, edx
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	QWORD PTR commonLengthLarger$1$[rsp], rdx
	test	r12d, r12d
	je	$LN33@ZSTD_DUBT_
	mov	QWORD PTR [rsp+136], rbp
	mov	rbp, QWORD PTR bestLength$[rsp]
	mov	QWORD PTR [rsp+128], r13
	mov	QWORD PTR [rsp+120], r15
$LL2@ZSTD_DUBT_:
	dec	r12d
	cmp	esi, r8d
	jbe	$LN36@ZSTD_DUBT_

; 189  :         U32* const nextPtr = dictBt + 2*(dictMatchIndex & btMask);

	mov	eax, r10d

; 191  :         const BYTE* match = dictBase + dictMatchIndex;

	mov	r15d, esi
	and	eax, esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 189  :         U32* const nextPtr = dictBt + 2*(dictMatchIndex & btMask);

	add	eax, eax

; 190  :         size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	cmp	rcx, rdx
	lea	rax, QWORD PTR [r11+rax*4]
	mov	r11, rdx
	cmovb	r11, rcx
	mov	QWORD PTR nextPtr$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 191  :         const BYTE* match = dictBase + dictMatchIndex;

	add	rdi, r15

; 192  :         matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	lea	r13, QWORD PTR [r11+r9]
	lea	rbx, QWORD PTR [rdi+r11]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r13
	sub	rax, rbx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rbx
	add	rcx, rax
	cmp	rcx, r14
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+rbx]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN16@ZSTD_DUBT_

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$[rsp]
	lea	rcx, QWORD PTR [rax+r13]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN16@ZSTD_DUBT_:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 193  :         if (dictMatchIndex+matchLength >= dictHighLimit)

	mov	eax, DWORD PTR dictHighLimit$1$[rsp]
	add	r11, r14
	lea	rcx, QWORD PTR [r15+r11]
	cmp	rcx, rax
	jb	SHORT $LN38@ZSTD_DUBT_

; 194  :             match = base + dictMatchIndex + dictIndexDelta;   /* to prepare for next usage of match[matchLength] */

	mov	r10d, DWORD PTR dictIndexDelta$1$[rsp]
	lea	rdi, QWORD PTR [r15+r10]
	add	rdi, QWORD PTR base$1$[rsp]
	jmp	SHORT $LN4@ZSTD_DUBT_
$LN38@ZSTD_DUBT_:

; 193  :         if (dictMatchIndex+matchLength >= dictHighLimit)

	mov	r10d, DWORD PTR dictIndexDelta$1$[rsp]
$LN4@ZSTD_DUBT_:

; 195  : 
; 196  :         if (matchLength > bestLength) {

	cmp	r11, rbp
	jbe	$LN37@ZSTD_DUBT_
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	r8d, DWORD PTR current$1$[rsp]
	xor	ebx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 198  :             if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {

	mov	r15, QWORD PTR offsetPtr$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	sub	r8d, r10d
	sub	r8d, esi
	mov	edx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 198  :             if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {

	lea	eax, DWORD PTR [r8+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 198  :             if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {

	mov	eax, DWORD PTR [r15]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 198  :             if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, ebx
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 198  :             if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {

	sub	edx, eax
	mov	eax, r11d
	sub	eax, ebp
	shl	eax, 2
	cmp	eax, edx
	jle	SHORT $LN6@ZSTD_DUBT_

; 199  :                 DEBUGLOG(9, "ZSTD_DUBT_findBetterDictMatch(%u) : found better match length %u -> %u and offsetCode %u -> %u (dictMatchIndex %u, matchIndex %u)",
; 200  :                     current, (U32)bestLength, (U32)matchLength, (U32)*offsetPtr, ZSTD_REP_MOVE + current - matchIndex, dictMatchIndex, matchIndex);
; 201  :                 bestLength = matchLength, *offsetPtr = ZSTD_REP_MOVE + current - matchIndex;

	lea	ecx, DWORD PTR [r8+2]
	mov	rbp, r11
	mov	QWORD PTR [r15], rcx
$LN6@ZSTD_DUBT_:

; 202  :             }
; 203  :             if (ip+matchLength == iend) {   /* reached end of input : ip[matchLength] is not valid, no way to know if it's larger or smaller than match */

	mov	r9, QWORD PTR ip$[rsp]
	mov	r14, QWORD PTR iend$[rsp]
	lea	rax, QWORD PTR [r11+r9]
	cmp	rax, r14
	jne	SHORT $LN7@ZSTD_DUBT_
$LN36@ZSTD_DUBT_:
	mov	r13, QWORD PTR [rsp+128]

; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (bestLength >= MINMATCH) {
; 221  :         U32 const mIndex = current - ((U32)*offsetPtr - ZSTD_REP_MOVE); (void)mIndex;
; 222  :         DEBUGLOG(8, "ZSTD_DUBT_findBetterDictMatch(%u) : found match of length %u and offsetCode %u (pos %u)",
; 223  :                     current, (U32)bestLength, (U32)*offsetPtr, mIndex);
; 224  :     }
; 225  :     return bestLength;

	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+136]
	mov	r15, QWORD PTR [rsp+120]

; 226  : 
; 227  : }

	add	rsp, 144				; 00000090H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN37@ZSTD_DUBT_:

; 195  : 
; 196  :         if (matchLength > bestLength) {

	mov	r9, QWORD PTR ip$[rsp]
	mov	r14, QWORD PTR iend$[rsp]
$LN7@ZSTD_DUBT_:

; 209  :             if (dictMatchIndex <= btLow) { break; }   /* beyond tree size, stop the search */

	cmp	esi, DWORD PTR tv613[rsp]
	jbe	SHORT $LN36@ZSTD_DUBT_

; 204  :                 break;   /* drop, to guarantee consistency (miss a little bit of compression) */
; 205  :             }
; 206  :         }
; 207  : 
; 208  :         if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [r11+r9]
	cmp	BYTE PTR [rdi+r11], al
	mov	rax, QWORD PTR nextPtr$1$[rsp]
	jae	SHORT $LN8@ZSTD_DUBT_

; 210  :             commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
; 211  :             dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	esi, DWORD PTR [rax+4]
	mov	rcx, r11

; 212  :         } else {

	mov	rdx, QWORD PTR commonLengthLarger$1$[rsp]
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	jmp	SHORT $LN9@ZSTD_DUBT_
$LN8@ZSTD_DUBT_:

; 213  :             /* match is larger than current */
; 214  :             if (dictMatchIndex <= btLow) { break; }   /* beyond tree size, stop the search */
; 215  :             commonLengthLarger = matchLength;
; 216  :             dictMatchIndex = nextPtr[0];

	mov	esi, DWORD PTR [rax]
	mov	rdx, r11
	mov	rcx, QWORD PTR commonLengthSmaller$1$[rsp]
	mov	QWORD PTR commonLengthLarger$1$[rsp], rdx
$LN9@ZSTD_DUBT_:

; 176  :     U32         const dictIndexDelta = ms->window.lowLimit - dictHighLimit;
; 177  : 
; 178  :     U32*        const dictBt = dms->chainTable;
; 179  :     U32         const btLog  = dmsCParams->chainLog - 1;
; 180  :     U32         const btMask = (1 << btLog) - 1;
; 181  :     U32         const btLow = (btMask >= dictHighLimit - dictLowLimit) ? dictLowLimit : dictHighLimit - btMask;
; 182  : 
; 183  :     size_t commonLengthSmaller=0, commonLengthLarger=0;
; 184  : 
; 185  :     (void)dictMode;
; 186  :     assert(dictMode == ZSTD_dictMatchState);
; 187  : 
; 188  :     while (nbCompares-- && (dictMatchIndex > dictLowLimit)) {

	test	r12d, r12d
	je	SHORT $LN36@ZSTD_DUBT_
	mov	r8d, DWORD PTR dictLowLimit$1$[rsp]
	mov	r10d, DWORD PTR btMask$1$[rsp]
	mov	rdi, QWORD PTR dictBase$1$[rsp]
	mov	r11, QWORD PTR dictBt$1$[rsp]
	jmp	$LL2@ZSTD_DUBT_
$LN33@ZSTD_DUBT_:

; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (bestLength >= MINMATCH) {
; 221  :         U32 const mIndex = current - ((U32)*offsetPtr - ZSTD_REP_MOVE); (void)mIndex;
; 222  :         DEBUGLOG(8, "ZSTD_DUBT_findBetterDictMatch(%u) : found match of length %u and offsetCode %u (pos %u)",
; 223  :                     current, (U32)bestLength, (U32)*offsetPtr, mIndex);
; 224  :     }
; 225  :     return bestLength;

	mov	rax, QWORD PTR bestLength$[rsp]

; 226  : 
; 227  : }

	add	rsp, 144				; 00000090H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
ZSTD_DUBT_findBetterDictMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
matchEndIdx$1$ = 64
nextPtr$1$ = 72
r$1 = 72
r$2 = 72
r$3 = 72
r$4 = 72
current$1$ = 80
tv1135 = 84
tv1059 = 88
tv1053 = 88
windowLow$1$ = 96
btMask$1$ = 100
tv1159 = 104
base$1$ = 112
smallerPtr$1$ = 120
largerPtr$1$ = 128
bt$1$ = 136
dictEnd$1$ = 144
bestLength$1$ = 152
commonLengthLarger$1$ = 160
commonLengthSmaller$1$ = 168
dictBase$1$ = 176
prefixStart$1$ = 184
ms$ = 256
dummy32$5 = 264
ip$ = 264
iend$ = 272
offsetPtr$ = 280
mls$ = 288
dictMode$ = 296
ZSTD_DUBT_findBestMatch PROC

; 236  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 192				; 000000c0H

; 237  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 238  :     U32*   const hashTable = ms->hashTable;

	mov	r10, QWORD PTR [rcx+48]
	mov	rbp, rdx

; 239  :     U32    const hashLog = cParams->hashLog;
; 240  :     size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);

	mov	edx, DWORD PTR [rcx+192]
	mov	r15, r8
	mov	r8d, DWORD PTR mls$[rsp]
	mov	r9, rcx
	mov	rcx, rbp
	call	ZSTD_hashPtr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r9+184]
	mov	r13d, 1
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 247  :     U32*   const bt = ms->chainTable;

	mov	rbx, QWORD PTR [r9+64]
	mov	r8d, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, r13d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 247  :     U32*   const bt = ms->chainTable;

	mov	QWORD PTR bt$1$[rsp], rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	shl	edx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 241  :     U32          matchIndex  = hashTable[h];

	lea	r14, QWORD PTR [r10+rax*4]

; 243  :     const BYTE* const base = ms->window.base;

	mov	rax, QWORD PTR [r9+8]

; 249  :     U32    const btMask = (1 << btLog) - 1;

	mov	r12d, r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [r9+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 244  :     U32    const current = (U32)(ip-base);

	sub	r8d, eax
	mov	r10d, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r11d, r8d
	sub	r11d, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 243  :     const BYTE* const base = ms->window.base;

	mov	QWORD PTR base$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 244  :     U32    const current = (U32)(ip-base);

	mov	DWORD PTR current$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 241  :     U32          matchIndex  = hashTable[h];

	mov	QWORD PTR tv1059[rsp], r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 251  :     U32    const unsortLimit = MAX(btLow, windowLow);

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r11d, ecx
	cmp	DWORD PTR [r9+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r11d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 248  :     U32    const btLog  = cParams->chainLog - 1;

	mov	ecx, DWORD PTR [r9+188]
	dec	ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR windowLow$1$[rsp], r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 249  :     U32    const btMask = (1 << btLog) - 1;

	shl	r12d, cl

; 251  :     U32    const unsortLimit = MAX(btLow, windowLow);

	mov	esi, r11d
	dec	r12d
	xor	ecx, ecx
	sub	eax, r12d
	mov	DWORD PTR btMask$1$[rsp], r12d
	cmp	r12d, r8d
	cmovb	ecx, eax

; 252  : 
; 253  :     U32*         nextCandidate = bt + 2*(matchIndex&btMask);

	mov	eax, r12d
	cmp	ecx, r11d
	mov	DWORD PTR tv1135[rsp], ecx
	cmova	esi, ecx

; 254  :     U32*         unsortedMark = bt + 2*(matchIndex&btMask) + 1;
; 255  :     U32          nbCompares = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r9+196]
	and	eax, r10d
	shl	r13d, cl
	add	eax, eax

; 256  :     U32          nbCandidates = nbCompares;
; 257  :     U32          previousCandidate = 0;

	xor	edx, edx
	mov	edi, r13d
	lea	r8, QWORD PTR [rbx+rax*4]

; 258  : 
; 259  :     DEBUGLOG(7, "ZSTD_DUBT_findBestMatch (%u) ", current);
; 260  :     assert(ip <= iend-8);   /* required for h calculation */
; 261  : 
; 262  :     /* reach end of unsorted candidates list */
; 263  :     while ( (matchIndex > unsortLimit)
; 264  :          && (*unsortedMark == ZSTD_DUBT_UNSORTED_MARK)
; 265  :          && (nbCandidates > 1) ) {

	cmp	r10d, esi
	jbe	SHORT $LN8@ZSTD_DUBT_
	npad	4
$LL2@ZSTD_DUBT_:
	mov	eax, DWORD PTR [r8+4]
	cmp	eax, 1
	jne	SHORT $LN8@ZSTD_DUBT_
	cmp	edi, eax
	jbe	SHORT $LN3@ZSTD_DUBT_

; 266  :         DEBUGLOG(8, "ZSTD_DUBT_findBestMatch: candidate %u is unsorted",
; 267  :                     matchIndex);
; 268  :         *unsortedMark = previousCandidate;  /* the unsortedMark becomes a reversed chain, to move up back to original position */

	mov	DWORD PTR [r8+4], edx

; 269  :         previousCandidate = matchIndex;
; 270  :         matchIndex = *nextCandidate;
; 271  :         nextCandidate = bt + 2*(matchIndex&btMask);

	mov	eax, r12d
	mov	edx, r10d

; 272  :         unsortedMark = bt + 2*(matchIndex&btMask) + 1;
; 273  :         nbCandidates --;

	dec	edi
	mov	r10d, DWORD PTR [r8]
	and	eax, r10d
	add	eax, eax
	lea	r8, QWORD PTR [rbx+rax*4]
	cmp	r10d, esi
	ja	SHORT $LL2@ZSTD_DUBT_

; 274  :     }
; 275  : 
; 276  :     /* nullify last candidate if it's still unsorted
; 277  :      * simplification, detrimental to compression ratio, beneficial for speed */
; 278  :     if ( (matchIndex > unsortLimit)
; 279  :       && (*unsortedMark==ZSTD_DUBT_UNSORTED_MARK) ) {

	jmp	SHORT $LN8@ZSTD_DUBT_
$LN3@ZSTD_DUBT_:
	cmp	r10d, esi
	jbe	SHORT $LN8@ZSTD_DUBT_
	cmp	eax, 1
	jne	SHORT $LN8@ZSTD_DUBT_

; 280  :         DEBUGLOG(7, "ZSTD_DUBT_findBestMatch: nullify last unsorted candidate %u",
; 281  :                     matchIndex);
; 282  :         *nextCandidate = *unsortedMark = 0;

	xor	eax, eax
	mov	QWORD PTR [r8], rax
$LN8@ZSTD_DUBT_:

; 283  :     }
; 284  : 
; 285  :     /* batch sort stacked candidates */
; 286  :     matchIndex = previousCandidate;
; 287  :     while (matchIndex) {  /* will end on matchIndex == 0 */

	test	edx, edx
	je	SHORT $LN5@ZSTD_DUBT_
	mov	ebp, DWORD PTR dictMode$[rsp]
	mov	r14, QWORD PTR ms$[rsp]
	npad	2
$LL4@ZSTD_DUBT_:

; 288  :         U32* const nextCandidateIdxPtr = bt + 2*(matchIndex&btMask) + 1;

	mov	eax, r12d

; 289  :         U32 const nextCandidateIdx = *nextCandidateIdxPtr;
; 290  :         ZSTD_insertDUBT1(ms, matchIndex, iend,

	mov	DWORD PTR [rsp+40], ebp
	and	eax, edx
	mov	DWORD PTR [rsp+32], esi
	add	eax, eax
	mov	r9d, edi
	mov	r8, r15
	mov	rcx, r14
	mov	ebx, DWORD PTR [rbx+rax*4+4]
	call	ZSTD_insertDUBT1

; 291  :                          nbCandidates, unsortLimit, dictMode);
; 292  :         matchIndex = nextCandidateIdx;
; 293  :         nbCandidates++;

	inc	edi
	mov	edx, ebx
	test	ebx, ebx
	mov	rbx, QWORD PTR bt$1$[rsp]
	jne	SHORT $LL4@ZSTD_DUBT_
	mov	r14, QWORD PTR tv1059[rsp]
	mov	rbp, QWORD PTR ip$[rsp]
	mov	r9, QWORD PTR ms$[rsp]
$LN5@ZSTD_DUBT_:

; 294  :     }
; 295  : 
; 296  :     /* find longest match */
; 297  :     {   size_t commonLengthSmaller = 0, commonLengthLarger = 0;
; 298  :         const BYTE* const dictBase = ms->window.dictBase;
; 299  :         const U32 dictLimit = ms->window.dictLimit;
; 300  :         const BYTE* const dictEnd = dictBase + dictLimit;

	mov	r8d, DWORD PTR [r9+24]
	xor	ecx, ecx
	mov	rax, QWORD PTR [r9+16]
	xor	edx, edx

; 301  :         const BYTE* const prefixStart = base + dictLimit;
; 302  :         U32* smallerPtr = bt + 2*(current&btMask);

	mov	r10d, DWORD PTR current$1$[rsp]

; 303  :         U32* largerPtr  = bt + 2*(current&btMask) + 1;
; 304  :         U32 matchEndIdx = current + 8 + 1;
; 305  :         U32 dummy32;   /* to be nullified at the end */
; 306  :         size_t bestLength = 0;

	xor	r9d, r9d

; 307  : 
; 308  :         matchIndex  = hashTable[h];

	mov	edi, DWORD PTR [r14]
	mov	QWORD PTR dictBase$1$[rsp], rax
	add	rax, r8
	mov	QWORD PTR dictEnd$1$[rsp], rax
	mov	rax, QWORD PTR base$1$[rsp]
	add	rax, r8
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rcx
	mov	QWORD PTR prefixStart$1$[rsp], rax
	mov	eax, r12d
	and	eax, r10d
	mov	QWORD PTR commonLengthLarger$1$[rsp], rdx
	add	eax, eax
	mov	QWORD PTR tv1053[rsp], r8
	mov	QWORD PTR bestLength$1$[rsp], r9

; 309  :         hashTable[h] = current;   /* Update Hash Table */

	mov	DWORD PTR [r14], r10d
	lea	r11, QWORD PTR [rbx+rax*4]
	mov	QWORD PTR smallerPtr$1$[rsp], r11
	lea	rsi, QWORD PTR [r11+4]
	mov	QWORD PTR largerPtr$1$[rsp], rsi
	lea	eax, DWORD PTR [r10+9]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax

; 310  : 
; 311  :         while (nbCompares-- && (matchIndex > windowLow)) {

	test	r13d, r13d
	je	$LN93@ZSTD_DUBT_
	npad	2
$LL6@ZSTD_DUBT_:
	dec	r13d
	mov	DWORD PTR tv1159[rsp], r13d
	cmp	edi, DWORD PTR windowLow$1$[rsp]
	jbe	$LN105@ZSTD_DUBT_

; 312  :             U32* const nextPtr = bt + 2*(matchIndex & btMask);

	mov	eax, r12d
	and	eax, edi
	add	eax, eax

; 313  :             size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */

	cmp	rcx, rdx
	lea	r10, QWORD PTR [rbx+rax*4]
	mov	rbx, rdx
	cmovb	rbx, rcx
	mov	QWORD PTR nextPtr$1$[rsp], r10

; 314  :             const BYTE* match;
; 315  : 
; 316  :             if ((dictMode != ZSTD_extDict) || (matchIndex+matchLength >= dictLimit)) {

	cmp	DWORD PTR dictMode$[rsp], 1
	jne	$LN11@ZSTD_DUBT_
	mov	r14d, edi
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, r8
	jae	$LN11@ZSTD_DUBT_

; 320  :                 match = dictBase + matchIndex;

	mov	r12, QWORD PTR dictBase$1$[rsp]

; 321  :                 matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	add	rbp, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 320  :                 match = dictBase + matchIndex;

	add	r12, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, rbp
	mov	r8, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 321  :                 matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);

	lea	r11, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rax
	cmp	rcx, r15
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN74@ZSTD_DUBT_

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	mov	r8, r15
	call	ZSTD_count
	add	rsi, rax
$LN74@ZSTD_DUBT_:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 322  :                 if (matchIndex+matchLength >= dictLimit)

	mov	r10, QWORD PTR nextPtr$1$[rsp]
	add	rbx, rsi
	mov	r11, QWORD PTR smallerPtr$1$[rsp]
	mov	rbp, QWORD PTR ip$[rsp]
	mov	rsi, QWORD PTR largerPtr$1$[rsp]
	lea	rax, QWORD PTR [r14+rbx]
	cmp	rax, QWORD PTR tv1053[rsp]
	jb	$LN12@ZSTD_DUBT_

; 323  :                     match = base + matchIndex;   /* to prepare for next usage of match[matchLength] */

	mov	r12, QWORD PTR base$1$[rsp]
	add	r12, r14
	jmp	$LN12@ZSTD_DUBT_
$LN11@ZSTD_DUBT_:

; 318  :                 matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	lea	rax, QWORD PTR [rbx+rbp]
	mov	r12d, edi
	add	r12, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [r15-7]
	mov	r9, rax
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 318  :                 matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	lea	rdx, QWORD PTR [r12+rbx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN33@ZSTD_DUBT_

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN35@ZSTD_DUBT_

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$4[rsp], 0
	je	SHORT $LN50@ZSTD_DUBT_
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN31@ZSTD_DUBT_
$LN50@ZSTD_DUBT_:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN31@ZSTD_DUBT_
$LN35@ZSTD_DUBT_:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN33@ZSTD_DUBT_
	npad	1
$LL32@ZSTD_DUBT_:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN36@ZSTD_DUBT_
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL32@ZSTD_DUBT_
$LN33@ZSTD_DUBT_:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r15-3]
	cmp	rax, rcx
	jae	SHORT $LN37@ZSTD_DUBT_
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN37@ZSTD_DUBT_
	add	rax, 4
	add	rdx, 4
$LN37@ZSTD_DUBT_:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r15-1]
	cmp	rax, rcx
	jae	SHORT $LN38@ZSTD_DUBT_
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN38@ZSTD_DUBT_
	add	rax, 2
	add	rdx, 2
$LN38@ZSTD_DUBT_:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r15
	jae	SHORT $LN39@ZSTD_DUBT_
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN39@ZSTD_DUBT_
	inc	rax
$LN39@ZSTD_DUBT_:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r9
$LN31@ZSTD_DUBT_:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 318  :                 matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);

	add	rbx, rcx
$LN12@ZSTD_DUBT_:

; 324  :             }
; 325  : 
; 326  :             if (matchLength > bestLength) {

	mov	r9, QWORD PTR bestLength$1$[rsp]
	cmp	rbx, r9
	jbe	SHORT $LN16@ZSTD_DUBT_

; 327  :                 if (matchLength > matchEndIdx - matchIndex)

	mov	eax, DWORD PTR matchEndIdx$1$[rsp]
	sub	eax, edi
	cmp	rbx, rax
	jbe	SHORT $LN14@ZSTD_DUBT_

; 328  :                     matchEndIdx = matchIndex + (U32)matchLength;

	lea	eax, DWORD PTR [rbx+rdi]
	mov	DWORD PTR matchEndIdx$1$[rsp], eax
$LN14@ZSTD_DUBT_:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	r8d, DWORD PTR current$1$[rsp]
	mov	edx, 0
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 329  :                 if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )

	mov	r14, QWORD PTR offsetPtr$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	sub	r8d, edi
	mov	DWORD PTR r$2[rsp], 0

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$1[rsp], 0
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 329  :                 if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )

	lea	eax, DWORD PTR [r8+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 329  :                 if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )

	mov	eax, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	edx, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 329  :                 if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )

	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, 0
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 329  :                 if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )

	sub	edx, eax
	mov	eax, ebx
	sub	eax, r9d
	shl	eax, 2
	cmp	eax, edx
	jle	SHORT $LN15@ZSTD_DUBT_

; 330  :                     bestLength = matchLength, *offsetPtr = ZSTD_REP_MOVE + current - matchIndex;

	lea	ecx, DWORD PTR [r8+2]
	mov	QWORD PTR bestLength$1$[rsp], rbx
	mov	QWORD PTR [r14], rcx
	mov	r9, rbx
$LN15@ZSTD_DUBT_:

; 331  :                 if (ip+matchLength == iend) {   /* equal : no way to know if inf or sup */

	lea	rax, QWORD PTR [rbx+rbp]
	cmp	rax, r15
	je	$LN87@ZSTD_DUBT_
$LN16@ZSTD_DUBT_:

; 338  :                 }
; 339  :             }
; 340  : 
; 341  :             if (match[matchLength] < ip[matchLength]) {

	movzx	eax, BYTE PTR [rbx+rbp]
	cmp	BYTE PTR [r12+rbx], al
	jae	SHORT $LN18@ZSTD_DUBT_

; 342  :                 /* match is smaller than current */
; 343  :                 *smallerPtr = matchIndex;             /* update smaller idx */
; 344  :                 commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */

	mov	rcx, rbx
	mov	DWORD PTR [r11], edi
	mov	QWORD PTR commonLengthSmaller$1$[rsp], rbx

; 345  :                 if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv1135[rsp]
	jbe	$LN88@ZSTD_DUBT_

; 346  :                 smallerPtr = nextPtr+1;               /* new "smaller" => larger of match */
; 347  :                 matchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */

	mov	edi, DWORD PTR [r10+4]
	lea	r11, QWORD PTR [r10+4]

; 348  :             } else {

	mov	rdx, QWORD PTR commonLengthLarger$1$[rsp]
	mov	QWORD PTR smallerPtr$1$[rsp], r11
	jmp	SHORT $LN19@ZSTD_DUBT_
$LN36@ZSTD_DUBT_:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$3[rsp], 0
	je	SHORT $LN66@ZSTD_DUBT_
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	$LN31@ZSTD_DUBT_
$LN66@ZSTD_DUBT_:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	$LN31@ZSTD_DUBT_
$LN18@ZSTD_DUBT_:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 351  :                 commonLengthLarger = matchLength;

	mov	rdx, rbx
	mov	DWORD PTR [rsi], edi
	mov	QWORD PTR commonLengthLarger$1$[rsp], rbx

; 352  :                 if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	cmp	edi, DWORD PTR tv1135[rsp]
	jbe	SHORT $LN89@ZSTD_DUBT_

; 353  :                 largerPtr = nextPtr;
; 354  :                 matchIndex = nextPtr[0];

	mov	edi, DWORD PTR [r10]
	mov	rsi, r10
	mov	rcx, QWORD PTR commonLengthSmaller$1$[rsp]
	mov	QWORD PTR largerPtr$1$[rsp], r10
$LN19@ZSTD_DUBT_:

; 310  : 
; 311  :         while (nbCompares-- && (matchIndex > windowLow)) {

	test	r13d, r13d
	je	SHORT $LN93@ZSTD_DUBT_
	mov	r12d, DWORD PTR btMask$1$[rsp]
	mov	rbx, QWORD PTR bt$1$[rsp]
	mov	r8, QWORD PTR tv1053[rsp]
	jmp	$LL6@ZSTD_DUBT_
$LN87@ZSTD_DUBT_:

; 332  :                     if (dictMode == ZSTD_dictMatchState) {
; 333  :                         nbCompares = 0; /* in addition to avoiding checking any
; 334  :                                          * further in this loop, make sure we
; 335  :                                          * skip checking in the dictionary. */
; 336  :                     }
; 337  :                     break;   /* drop, to guarantee consistency (miss a little bit of compression) */

	mov	eax, DWORD PTR dictMode$[rsp]
	xor	r13d, r13d
	cmp	eax, 2
	cmovne	r13d, DWORD PTR tv1159[rsp]
	jmp	SHORT $LN7@ZSTD_DUBT_
$LN88@ZSTD_DUBT_:

; 345  :                 if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	r11, QWORD PTR dummy32$5[rsp]
	jmp	SHORT $LN105@ZSTD_DUBT_
$LN89@ZSTD_DUBT_:

; 352  :                 if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */

	lea	rsi, QWORD PTR dummy32$5[rsp]
	jmp	SHORT $LN105@ZSTD_DUBT_
$LN93@ZSTD_DUBT_:

; 310  : 
; 311  :         while (nbCompares-- && (matchIndex > windowLow)) {

	dec	r13d
$LN105@ZSTD_DUBT_:

; 355  :         }   }
; 356  : 
; 357  :         *smallerPtr = *largerPtr = 0;

	mov	eax, DWORD PTR dictMode$[rsp]
$LN7@ZSTD_DUBT_:

; 358  : 
; 359  :         if (dictMode == ZSTD_dictMatchState && nbCompares) {

	mov	rbx, QWORD PTR ms$[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rsi], ecx
	mov	DWORD PTR [r11], ecx
	cmp	eax, 2
	jne	SHORT $LN22@ZSTD_DUBT_
	test	r13d, r13d
	je	SHORT $LN22@ZSTD_DUBT_

; 360  :             bestLength = ZSTD_DUBT_findBetterDictMatch(

	mov	eax, DWORD PTR mls$[rsp]
	mov	r8, r15
	mov	DWORD PTR [rsp+48], eax
	mov	rdx, rbp
	mov	DWORD PTR [rsp+40], r13d
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], r9
	mov	r9, QWORD PTR offsetPtr$[rsp]
	call	ZSTD_DUBT_findBetterDictMatch
	mov	r9, rax
$LN22@ZSTD_DUBT_:

; 361  :                     ms, ip, iend,
; 362  :                     offsetPtr, bestLength, nbCompares,
; 363  :                     mls, dictMode);
; 364  :         }
; 365  : 
; 366  :         assert(matchEndIdx > current+8); /* ensure nextToUpdate is increased */
; 367  :         ms->nextToUpdate = matchEndIdx - 8;   /* skip repetitive patterns */

	mov	ecx, DWORD PTR matchEndIdx$1$[rsp]

; 368  :         if (bestLength >= MINMATCH) {
; 369  :             U32 const mIndex = current - ((U32)*offsetPtr - ZSTD_REP_MOVE); (void)mIndex;
; 370  :             DEBUGLOG(8, "ZSTD_DUBT_findBestMatch(%u) : found match of length %u and offsetCode %u (pos %u)",
; 371  :                         current, (U32)bestLength, (U32)*offsetPtr, mIndex);
; 372  :         }
; 373  :         return bestLength;

	mov	rax, r9
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [rbx+36], ecx

; 374  :     }
; 375  : }

	mov	rbx, QWORD PTR [rsp+272]
	add	rsp, 192				; 000000c0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_DUBT_findBestMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 64
ip$ = 72
iLimit$ = 80
offsetPtr$ = 88
mls$ = 96
dictMode$ = 104
ZSTD_BtFindBestMatch PROC

; 385  : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 386  :     DEBUGLOG(7, "ZSTD_BtFindBestMatch");
; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	eax, DWORD PTR [rcx+36]
	mov	rbp, r9
	add	rax, QWORD PTR [rcx+8]
	mov	r14, r8
	mov	rsi, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	jae	SHORT $LN2@ZSTD_BtFin
	xor	eax, eax
	jmp	SHORT $LN1@ZSTD_BtFin
$LN2@ZSTD_BtFin:
	mov	QWORD PTR [rsp+64], rbx

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	ebx, DWORD PTR mls$[rsp]
	mov	r9d, ebx
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	eax, DWORD PTR dictMode$[rsp]
	mov	r9, rbp
	mov	DWORD PTR [rsp+40], eax
	mov	r8, r14
	mov	rdx, rsi
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, rdi
	call	ZSTD_DUBT_findBestMatch
	mov	rbx, QWORD PTR [rsp+64]
$LN1@ZSTD_BtFin:

; 390  : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
ZSTD_BtFindBestMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 80
ip$ = 88
iLimit$ = 96
offsetPtr$ = 104
ZSTD_BtFindBestMatch_selectMLS PROC

; 397  : {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 398  :     switch(ms->cParams.minMatch)

	mov	eax, DWORD PTR [rcx+200]
	mov	rsi, r9
	mov	rbp, r8
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	eax, 5
	je	$LN5@ZSTD_BtFin
	mov	r10d, DWORD PTR [rcx+36]
	add	eax, -6					; fffffffaH
	mov	rdx, QWORD PTR [rcx+8]
	cmp	eax, 1
	lea	rax, QWORD PTR [rdx+r10]
	ja	SHORT $LN4@ZSTD_BtFin

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	cmp	rdi, rax
	jb	$LN57@ZSTD_BtFin

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	r9d, 6
	mov	rdx, rdi
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	xor	eax, eax
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 6

; 399  :     {
; 400  :     default : /* includes case 3 */
; 401  :     case 4 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 4, ZSTD_noDict);
; 402  :     case 5 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 5, ZSTD_noDict);
; 403  :     case 7 :
; 404  :     case 6 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 6, ZSTD_noDict);

	jmp	$LN56@ZSTD_BtFin
$LN4@ZSTD_BtFin:

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	cmp	rdi, rax
	jb	$LN57@ZSTD_BtFin
	mov	QWORD PTR [rsp+80], r12

; 30   :     U32  const btMask = (1 << btLog) - 1;

	mov	r11d, 1
	mov	r12, QWORD PTR [rcx+64]

; 31   : 
; 32   :     const BYTE* const base = ms->window.base;
; 33   :     U32 const target = (U32)(ip - base);

	mov	r8d, edi
	mov	QWORD PTR [rsp+96], r15
	sub	r8d, edx
	mov	r15, QWORD PTR [rcx+48]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	shl	r11d, cl
	dec	r11d

; 43   :     for ( ; idx < target ; idx++) {

	cmp	r10d, r8d
	jae	SHORT $LN13@ZSTD_BtFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+88], r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 26   :     U32  const hashLog = cParams->hashLog;

	lea	r9, QWORD PTR [rdx+r10]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r14d, 32				; 00000020H
	sub	r14d, DWORD PTR [rbx+192]
	npad	11
$LL14@ZSTD_BtFin:
	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 43   :     for ( ; idx < target ; idx++) {

	lea	r9, QWORD PTR [r9+1]

; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	and	eax, r11d
	add	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 45   :         U32    const matchIndex = hashTable[h];

	mov	ecx, DWORD PTR [r15+rdx*4]

; 48   :         U32*   const sortMarkPtr  = nextCandidatePtr + 1;
; 49   : 
; 50   :         DEBUGLOG(8, "ZSTD_updateDUBT: insert %u", idx);
; 51   :         hashTable[h] = idx;   /* Update Hash Table */

	mov	DWORD PTR [r15+rdx*4], r10d
	inc	r10d

; 52   :         *nextCandidatePtr = matchIndex;   /* update BT like a chain */

	mov	DWORD PTR [r12+rax*4], ecx

; 53   :         *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;

	mov	DWORD PTR [r12+rax*4+4], 1
	cmp	r10d, r8d
	jb	SHORT $LL14@ZSTD_BtFin

; 43   :     for ( ; idx < target ; idx++) {

	mov	r14, QWORD PTR [rsp+88]
$LN13@ZSTD_BtFin:

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	xor	eax, eax

; 55   :     ms->nextToUpdate = target;

	mov	DWORD PTR [rbx+36], r8d

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	DWORD PTR [rsp+40], eax
	mov	r9, rsi
	mov	r8, rbp
	mov	DWORD PTR [rsp+32], 4
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_DUBT_findBestMatch
	mov	r15, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+80]

; 405  :     }
; 406  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN5@ZSTD_BtFin:

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	eax, DWORD PTR [rcx+36]
	add	rax, QWORD PTR [rcx+8]
	cmp	rdi, rax
	jae	SHORT $LN47@ZSTD_BtFin
$LN57@ZSTD_BtFin:

; 405  :     }
; 406  : }

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN47@ZSTD_BtFin:

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	r9d, 5
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	xor	eax, eax
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 5
$LN56@ZSTD_BtFin:

; 405  :     }
; 406  : }

	mov	r9, rsi
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_DUBT_findBestMatch
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_BtFindBestMatch_selectMLS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 80
ip$ = 88
iLimit$ = 96
offsetPtr$ = 104
ZSTD_BtFindBestMatch_dictMatchState_selectMLS PROC

; 413  : {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 414  :     switch(ms->cParams.minMatch)

	mov	eax, DWORD PTR [rcx+200]
	mov	rsi, r9
	mov	rbp, r8
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	eax, 5
	je	$LN5@ZSTD_BtFin
	mov	r10d, DWORD PTR [rcx+36]
	add	eax, -6					; fffffffaH
	mov	rdx, QWORD PTR [rcx+8]
	cmp	eax, 1
	lea	rax, QWORD PTR [rdx+r10]
	ja	SHORT $LN4@ZSTD_BtFin

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	cmp	rdi, rax
	jb	$LN57@ZSTD_BtFin

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	r9d, 6
	mov	rdx, rdi
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	DWORD PTR [rsp+40], 2
	mov	DWORD PTR [rsp+32], 6

; 415  :     {
; 416  :     default : /* includes case 3 */
; 417  :     case 4 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 4, ZSTD_dictMatchState);
; 418  :     case 5 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 5, ZSTD_dictMatchState);
; 419  :     case 7 :
; 420  :     case 6 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 6, ZSTD_dictMatchState);

	jmp	$LN56@ZSTD_BtFin
$LN4@ZSTD_BtFin:

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	cmp	rdi, rax
	jb	$LN57@ZSTD_BtFin
	mov	QWORD PTR [rsp+80], r12

; 30   :     U32  const btMask = (1 << btLog) - 1;

	mov	r11d, 1
	mov	r12, QWORD PTR [rcx+64]

; 31   : 
; 32   :     const BYTE* const base = ms->window.base;
; 33   :     U32 const target = (U32)(ip - base);

	mov	r8d, edi
	mov	QWORD PTR [rsp+96], r15
	sub	r8d, edx
	mov	r15, QWORD PTR [rcx+48]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	shl	r11d, cl
	dec	r11d

; 43   :     for ( ; idx < target ; idx++) {

	cmp	r10d, r8d
	jae	SHORT $LN13@ZSTD_BtFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+88], r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 26   :     U32  const hashLog = cParams->hashLog;

	lea	r9, QWORD PTR [rdx+r10]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r14d, 32				; 00000020H
	sub	r14d, DWORD PTR [rbx+192]
	npad	9
$LL14@ZSTD_BtFin:
	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 43   :     for ( ; idx < target ; idx++) {

	lea	r9, QWORD PTR [r9+1]

; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	and	eax, r11d
	add	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 45   :         U32    const matchIndex = hashTable[h];

	mov	ecx, DWORD PTR [r15+rdx*4]

; 48   :         U32*   const sortMarkPtr  = nextCandidatePtr + 1;
; 49   : 
; 50   :         DEBUGLOG(8, "ZSTD_updateDUBT: insert %u", idx);
; 51   :         hashTable[h] = idx;   /* Update Hash Table */

	mov	DWORD PTR [r15+rdx*4], r10d
	inc	r10d

; 52   :         *nextCandidatePtr = matchIndex;   /* update BT like a chain */

	mov	DWORD PTR [r12+rax*4], ecx

; 53   :         *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;

	mov	DWORD PTR [r12+rax*4+4], 1
	cmp	r10d, r8d
	jb	SHORT $LL14@ZSTD_BtFin

; 43   :     for ( ; idx < target ; idx++) {

	mov	r14, QWORD PTR [rsp+88]
$LN13@ZSTD_BtFin:

; 54   :     }
; 55   :     ms->nextToUpdate = target;

	mov	DWORD PTR [rbx+36], r8d

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	r9, rsi
	mov	r8, rbp
	mov	DWORD PTR [rsp+40], 2
	mov	rdx, rdi
	mov	DWORD PTR [rsp+32], 4
	mov	rcx, rbx
	call	ZSTD_DUBT_findBestMatch
	mov	r15, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+80]

; 421  :     }
; 422  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN5@ZSTD_BtFin:

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	eax, DWORD PTR [rcx+36]
	add	rax, QWORD PTR [rcx+8]
	cmp	rdi, rax
	jae	SHORT $LN47@ZSTD_BtFin
$LN57@ZSTD_BtFin:

; 421  :     }
; 422  : }

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN47@ZSTD_BtFin:

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	r9d, 5
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	DWORD PTR [rsp+40], 2
	mov	DWORD PTR [rsp+32], 5
$LN56@ZSTD_BtFin:

; 421  :     }
; 422  : }

	mov	r9, rsi
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_DUBT_findBestMatch
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_BtFindBestMatch_dictMatchState_selectMLS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 80
ip$ = 88
iLimit$ = 96
offsetPtr$ = 104
ZSTD_BtFindBestMatch_extDict_selectMLS PROC

; 429  : {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 430  :     switch(ms->cParams.minMatch)

	mov	eax, DWORD PTR [rcx+200]
	mov	rsi, r9
	mov	rbp, r8
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	eax, 5
	je	$LN5@ZSTD_BtFin
	mov	r10d, DWORD PTR [rcx+36]
	add	eax, -6					; fffffffaH
	mov	rdx, QWORD PTR [rcx+8]
	cmp	eax, 1
	lea	rax, QWORD PTR [rdx+r10]
	ja	SHORT $LN4@ZSTD_BtFin

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	cmp	rdi, rax
	jb	$LN57@ZSTD_BtFin

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	r9d, 6
	mov	rdx, rdi
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	DWORD PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], 6

; 431  :     {
; 432  :     default : /* includes case 3 */
; 433  :     case 4 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 4, ZSTD_extDict);
; 434  :     case 5 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 5, ZSTD_extDict);
; 435  :     case 7 :
; 436  :     case 6 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 6, ZSTD_extDict);

	jmp	$LN56@ZSTD_BtFin
$LN4@ZSTD_BtFin:

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	cmp	rdi, rax
	jb	$LN57@ZSTD_BtFin
	mov	QWORD PTR [rsp+80], r12

; 30   :     U32  const btMask = (1 << btLog) - 1;

	mov	r11d, 1
	mov	r12, QWORD PTR [rcx+64]

; 31   : 
; 32   :     const BYTE* const base = ms->window.base;
; 33   :     U32 const target = (U32)(ip - base);

	mov	r8d, edi
	mov	QWORD PTR [rsp+96], r15
	sub	r8d, edx
	mov	r15, QWORD PTR [rcx+48]
	mov	ecx, DWORD PTR [rcx+188]
	dec	ecx
	shl	r11d, cl
	dec	r11d

; 43   :     for ( ; idx < target ; idx++) {

	cmp	r10d, r8d
	jae	SHORT $LN13@ZSTD_BtFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+88], r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 26   :     U32  const hashLog = cParams->hashLog;

	lea	r9, QWORD PTR [rdx+r10]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r14d, 32				; 00000020H
	sub	r14d, DWORD PTR [rbx+192]
	npad	9
$LL14@ZSTD_BtFin:
	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 43   :     for ( ; idx < target ; idx++) {

	lea	r9, QWORD PTR [r9+1]

; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 47   :         U32*   const nextCandidatePtr = bt + 2*(idx&btMask);

	and	eax, r11d
	add	eax, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 45   :         U32    const matchIndex = hashTable[h];

	mov	ecx, DWORD PTR [r15+rdx*4]

; 48   :         U32*   const sortMarkPtr  = nextCandidatePtr + 1;
; 49   : 
; 50   :         DEBUGLOG(8, "ZSTD_updateDUBT: insert %u", idx);
; 51   :         hashTable[h] = idx;   /* Update Hash Table */

	mov	DWORD PTR [r15+rdx*4], r10d
	inc	r10d

; 52   :         *nextCandidatePtr = matchIndex;   /* update BT like a chain */

	mov	DWORD PTR [r12+rax*4], ecx

; 53   :         *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;

	mov	DWORD PTR [r12+rax*4+4], 1
	cmp	r10d, r8d
	jb	SHORT $LL14@ZSTD_BtFin

; 43   :     for ( ; idx < target ; idx++) {

	mov	r14, QWORD PTR [rsp+88]
$LN13@ZSTD_BtFin:

; 54   :     }
; 55   :     ms->nextToUpdate = target;

	mov	DWORD PTR [rbx+36], r8d

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	r9, rsi
	mov	r8, rbp
	mov	DWORD PTR [rsp+40], 1
	mov	rdx, rdi
	mov	DWORD PTR [rsp+32], 4
	mov	rcx, rbx
	call	ZSTD_DUBT_findBestMatch
	mov	r15, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+80]

; 437  :     }
; 438  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN5@ZSTD_BtFin:

; 387  :     if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */

	mov	eax, DWORD PTR [rcx+36]
	add	rax, QWORD PTR [rcx+8]
	cmp	rdi, rax
	jae	SHORT $LN47@ZSTD_BtFin
$LN57@ZSTD_BtFin:

; 437  :     }
; 438  : }

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN47@ZSTD_BtFin:

; 388  :     ZSTD_updateDUBT(ms, ip, iLimit, mls);

	mov	r9d, 5
	call	ZSTD_updateDUBT

; 389  :     return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);

	mov	DWORD PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], 5
$LN56@ZSTD_BtFin:

; 437  :     }
; 438  : }

	mov	r9, rsi
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rbx
	call	ZSTD_DUBT_findBestMatch
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_BtFindBestMatch_extDict_selectMLS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
ms$ = 64
cParams$ = 72
ip$ = 80
hashLog$1$ = 88
mls$ = 88
ZSTD_insertAndFindFirstIndex_internal PROC

; 453  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 454  :     U32* const hashTable  = ms->hashTable;

	mov	rdi, QWORD PTR [rcx+48]
	mov	rax, rcx

; 455  :     const U32 hashLog = cParams->hashLog;
; 456  :     U32* const chainTable = ms->chainTable;

	mov	r13, QWORD PTR [rcx+64]

; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;
; 458  :     const BYTE* const base = ms->window.base;
; 459  :     const U32 target = (U32)(ip - base);

	mov	ebp, r8d
	mov	ecx, DWORD PTR [rdx+4]
	mov	r15d, 1
	mov	esi, DWORD PTR [rdx+8]
	mov	r10d, r9d
	mov	rdx, QWORD PTR [rax+8]
	mov	r14, r8

; 460  :     U32 idx = ms->nextToUpdate;

	mov	ebx, DWORD PTR [rax+36]
	sub	ebp, edx
	shl	r15d, cl

; 461  : 
; 462  :     while(idx < target) { /* catch up */

	mov	r9d, 64					; 00000040H
	dec	r15d
	mov	DWORD PTR hashLog$1$[rsp], esi
	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	mov	r12, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r11, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	cmp	ebx, ebp
	jae	$LN3@ZSTD_inser
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r11d, r9d

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	lea	r8, QWORD PTR [rdx+rbx]

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r12d, 32				; 00000020H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	r14, rcx

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	sub	r12d, esi

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	r9, -3523014627193167104		; cf1bbcdcbfa56300H

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	sub	r11d, esi

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	rsi, -3523014627193847808		; cf1bbcdcbf9b0000H
	npad	3
$LL2@ZSTD_inser:

; 631  :     switch(mls)

	mov	eax, r10d
	sub	eax, 5
	je	SHORT $LN9@ZSTD_inser
	sub	eax, 1
	je	SHORT $LN10@ZSTD_inser
	sub	eax, 1
	je	SHORT $LN11@ZSTD_inser
	cmp	eax, 1
	je	SHORT $LN12@ZSTD_inser

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [r8], -1640531535	; 9e3779b1H
	mov	rcx, r12

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN67@ZSTD_inser
$LN12@ZSTD_inser:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, rcx

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN68@ZSTD_inser
$LN11@ZSTD_inser:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, r9

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN68@ZSTD_inser
$LN10@ZSTD_inser:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, rsi

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN68@ZSTD_inser
$LN9@ZSTD_inser:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r8]
	imul	rax, r14
$LN68@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	mov	ecx, r11d
$LN67@ZSTD_inser:
	shr	rax, cl

; 465  :         hashTable[h] = idx;
; 466  :         idx++;

	inc	r8
	lea	rdx, QWORD PTR [rdi+rax*4]
	mov	ecx, r15d
	mov	eax, ebx
	and	rcx, rax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r13+rcx*4], eax
	mov	DWORD PTR [rdx], ebx
	inc	ebx
	cmp	ebx, ebp
	jb	SHORT $LL2@ZSTD_inser
	mov	esi, DWORD PTR hashLog$1$[rsp]
	mov	r9d, 64					; 00000040H
	mov	r14, QWORD PTR ip$[rsp]
	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	mov	rax, QWORD PTR ms$[rsp]
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r11, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r12, -3523014627327384477		; cf1bbcdcb7a56463H
$LN3@ZSTD_inser:

; 467  :     }
; 468  : 
; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [rax+36], ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	r10d, 5
	je	SHORT $LN38@ZSTD_inser
	sub	r10d, 1
	je	SHORT $LN39@ZSTD_inser
	sub	r10d, 1
	je	SHORT $LN40@ZSTD_inser
	cmp	r10d, 1
	je	SHORT $LN41@ZSTD_inser

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [r14], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, esi

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN69@ZSTD_inser
$LN41@ZSTD_inser:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
	sub	r9d, esi
	imul	rax, r12

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN70@ZSTD_inser
$LN40@ZSTD_inser:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
	sub	r9d, esi
	imul	rax, r11

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN70@ZSTD_inser
$LN39@ZSTD_inser:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
	sub	r9d, esi
	imul	rax, r8

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN70@ZSTD_inser
$LN38@ZSTD_inser:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
	sub	r9d, esi
	imul	rax, rcx
$LN70@ZSTD_inser:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 471  : }

	mov	ecx, r9d
$LN69@ZSTD_inser:
	mov	rbx, QWORD PTR [rsp+72]
	shr	rax, cl
	mov	eax, DWORD PTR [rdi+rax*4]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_insertAndFindFirstIndex_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
dmsIndexDelta$1$ = 32
current$1$ = 36
dmsChainTable$1$ = 40
tv902 = 40
dmsBase$1$ = 48
r$1 = 48
r$2 = 48
tv895 = 56
prefixStart$1$ = 64
dictBase$1$ = 72
base$1$ = 80
chainTable$1$ = 88
tv894 = 160
ms$ = 160
dmsChainSize$1$ = 168
lowLimit$1$ = 168
ip$ = 168
iLimit$ = 176
offsetPtr$ = 184
mls$ = 192
dmsLowestIndex$1$ = 200
dictMode$ = 200
ZSTD_HcFindBestMatch_generic PROC

; 486  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H

; 487  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 488  :     U32* const chainTable = ms->chainTable;

	mov	rax, QWORD PTR [rcx+64]
	mov	rbp, rcx

; 489  :     const U32 chainSize = (1 << cParams->chainLog);

	mov	ecx, DWORD PTR [rcx+188]
	mov	rdi, rdx
	mov	rbx, r8
	mov	QWORD PTR chainTable$1$[rsp], rax
	mov	r9d, 1

; 490  :     const U32 chainMask = chainSize-1;
; 491  :     const BYTE* const base = ms->window.base;
; 492  :     const BYTE* const dictBase = ms->window.dictBase;
; 493  :     const U32 dictLimit = ms->window.dictLimit;
; 494  :     const BYTE* const prefixStart = base + dictLimit;
; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 496  :     const U32 current = (U32)(ip-base);

	mov	r14d, edi
	mov	rdx, QWORD PTR [rbp+8]
	mov	r10d, r9d
	mov	r8, QWORD PTR [rbp+16]
	sub	r14d, edx
	mov	esi, DWORD PTR [rbp+24]

; 497  :     const U32 maxDistance = 1U << cParams->windowLog;
; 498  :     const U32 lowestValid = ms->window.lowLimit;
; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;
; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);
; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	r12d, r9d
	shl	r10d, cl

; 504  :     size_t ml=4-1;

	lea	r15d, QWORD PTR [r9+2]
	mov	QWORD PTR dictBase$1$[rsp], r8
	mov	QWORD PTR base$1$[rsp], rdx
	lea	rcx, QWORD PTR [rsi+rdx]
	mov	DWORD PTR dmsIndexDelta$1$[rsp], esi
	lea	r13, QWORD PTR [rsi+r8]
	mov	QWORD PTR prefixStart$1$[rsp], rcx
	mov	ecx, DWORD PTR [rbp+184]
	lea	eax, DWORD PTR [r10-1]
	mov	DWORD PTR tv902[rsp], eax
	mov	edx, r9d

; 505  : 
; 506  :     /* HC4 match finder */
; 507  :     U32 matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls);

	mov	r9d, DWORD PTR mls$[rsp]
	mov	eax, r14d
	shl	edx, cl
	mov	r8d, r14d
	mov	ecx, DWORD PTR [rbp+28]
	sub	r8d, edx
	sub	eax, ecx
	mov	DWORD PTR current$1$[rsp], r14d
	cmp	eax, edx
	mov	eax, r14d
	cmovbe	r8d, ecx
	cmp	DWORD PTR [rbp+32], 0
	cmovne	r8d, ecx
	mov	ecx, DWORD PTR [rbp+196]
	xor	edx, edx
	mov	DWORD PTR lowLimit$1$[rsp], r8d
	sub	eax, r10d
	mov	r8, rdi
	cmp	r14d, r10d
	cmovbe	eax, edx
	shl	r12d, cl
	mov	rcx, rbp
	mov	DWORD PTR tv895[rsp], eax
	lea	rdx, QWORD PTR [rbp+184]
	call	ZSTD_insertAndFindFirstIndex_internal

; 508  : 
; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	edx, DWORD PTR lowLimit$1$[rsp]
	xor	r10d, r10d
	mov	r9d, DWORD PTR dictMode$[rsp]
	cmp	eax, edx
	mov	ecx, r10d
	mov	ebp, eax
	seta	cl
	mov	eax, r10d
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN102@ZSTD_HcFin
$LL4@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {

	cmp	r9d, 1
	jne	SHORT $LN10@ZSTD_HcFin
	cmp	ebp, esi
	jae	SHORT $LN10@ZSTD_HcFin

; 516  :         } else {
; 517  :             const BYTE* const match = dictBase + matchIndex;
; 518  :             assert(match+4 <= dictEnd);
; 519  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rdi]
	mov	r11d, ebp
	add	r11, QWORD PTR dictBase$1$[rsp]
	cmp	DWORD PTR [r11], eax
	jne	$LN14@ZSTD_HcFin

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	add	r11, 4
	lea	r14, QWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r14
	mov	r8, rbx
	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, r13
	cmp	rcx, rbx
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, r13
	jne	SHORT $LN71@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rsi+r14]
	mov	r8, rbx
	call	ZSTD_count
	add	rsi, rax
$LN71@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	mov	r14d, DWORD PTR current$1$[rsp]
	lea	rcx, QWORD PTR [rsi+4]
	mov	esi, DWORD PTR dmsIndexDelta$1$[rsp]
	xor	r10d, r10d
	mov	r9d, DWORD PTR dictMode$[rsp]
	jmp	$LN28@ZSTD_HcFin
$LN10@ZSTD_HcFin:

; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r15+rdi]
	mov	edx, ebp
	add	rdx, QWORD PTR base$1$[rsp]
	cmp	BYTE PTR [rdx+r15], al
	jne	$LN106@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rbx-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rax, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rdi, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN30@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rdi]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN32@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$2[rsp], r10d
	je	SHORT $LN47@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN28@ZSTD_HcFin
$LN47@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, r10d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN28@ZSTD_HcFin
$LN32@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN30@ZSTD_HcFin
$LL29@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN33@ZSTD_HcFin
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL29@ZSTD_HcFin
$LN30@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [rbx-3]
	cmp	rax, rcx
	jae	SHORT $LN34@ZSTD_HcFin
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN34@ZSTD_HcFin
	add	rax, 4
	add	rdx, 4
$LN34@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [rbx-1]
	cmp	rax, rcx
	jae	SHORT $LN35@ZSTD_HcFin
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN35@ZSTD_HcFin
	add	rax, 2
	add	rdx, 2
$LN35@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, rbx
	jae	SHORT $LN36@ZSTD_HcFin
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN36@ZSTD_HcFin
	inc	rax
$LN36@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, rdi
$LN28@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rcx, r15
	jbe	SHORT $LN106@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r14d
	sub	eax, ebp
	mov	r15, rcx
	add	eax, 2
	mov	QWORD PTR [rdx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rcx+rdi]
	cmp	rax, rbx
	je	SHORT $LN102@ZSTD_HcFin
$LN106@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	mov	edx, DWORD PTR lowLimit$1$[rsp]
$LN14@ZSTD_HcFin:
	cmp	ebp, DWORD PTR tv895[rsp]
	jbe	SHORT $LN102@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	ecx, DWORD PTR tv902[rsp]
	mov	eax, ebp
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	ebp, DWORD PTR [rax+rcx*4]
	cmp	ebp, edx
	mov	ecx, r10d
	mov	eax, r10d
	seta	cl
	add	r12d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL4@ZSTD_HcFin
$LN102@ZSTD_HcFin:

; 532  :     }
; 533  : 
; 534  :     if (dictMode == ZSTD_dictMatchState) {

	cmp	r9d, 2
	jne	$LN98@ZSTD_HcFin

; 535  :         const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	r9, QWORD PTR ms$[rsp]

; 536  :         const U32* const dmsChainTable = dms->chainTable;
; 537  :         const U32 dmsChainSize         = (1 << dms->cParams.chainLog);

	mov	edx, 1

; 538  :         const U32 dmsChainMask         = dmsChainSize - 1;
; 539  :         const U32 dmsLowestIndex       = dms->window.dictLimit;
; 540  :         const BYTE* const dmsBase      = dms->window.base;
; 541  :         const BYTE* const dmsEnd       = dms->window.nextSrc;
; 542  :         const U32 dmsSize              = (U32)(dmsEnd - dmsBase);
; 543  :         const U32 dmsIndexDelta        = dictLimit - dmsSize;
; 544  :         const U32 dmsMinChain = dmsSize > dmsChainSize ? dmsSize - dmsChainSize : 0;
; 545  : 
; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	r8d, DWORD PTR mls$[rsp]
	mov	r9, QWORD PTR [r9+176]
	mov	ecx, DWORD PTR [r9+188]
	mov	r10, QWORD PTR [r9+8]
	mov	r13, QWORD PTR [r9]
	mov	r14, QWORD PTR [r9+64]
	mov	eax, r13d
	mov	ebp, DWORD PTR [r9+24]
	sub	eax, r10d
	shl	edx, cl
	sub	esi, eax
	mov	ecx, eax
	mov	DWORD PTR dmsChainSize$1$[rsp], edx
	sub	ecx, edx
	mov	QWORD PTR dmsChainTable$1$[rsp], r14
	cmp	eax, edx
	mov	DWORD PTR dmsLowestIndex$1$[rsp], ebp
	mov	edx, 0
	mov	QWORD PTR dmsBase$1$[rsp], r10
	cmovbe	ecx, edx
	mov	DWORD PTR dmsIndexDelta$1$[rsp], esi
	mov	edx, DWORD PTR [r9+192]
	mov	DWORD PTR tv894[rsp], ecx
	mov	rcx, rdi
	call	ZSTD_hashPtr
	mov	rdx, rax
	mov	rax, QWORD PTR [r9+48]
	mov	esi, DWORD PTR [rax+rdx*4]

; 547  : 
; 548  :         for ( ; (matchIndex>dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {

	xor	edx, edx
	cmp	esi, ebp
	mov	ecx, edx
	mov	eax, edx
	seta	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN98@ZSTD_HcFin
$LL7@ZSTD_HcFin:

; 549  :             size_t currentMl=0;
; 550  :             const BYTE* const match = dmsBase + matchIndex;
; 551  :             assert(match+4 <= dmsEnd);
; 552  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rdi]
	mov	r11d, esi
	add	r11, r10
	cmp	DWORD PTR [r11], eax
	jne	$LN19@ZSTD_HcFin

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r11, 4
	lea	rbp, QWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, rbp
	mov	r8, rbx
	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, r13
	cmp	rcx, rbx
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, r13
	jne	SHORT $LN76@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r14+rbp]
	mov	r8, rbx
	call	ZSTD_count
	add	r14, rax
$LN76@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r14, 4

; 554  : 
; 555  :             /* save best solution */
; 556  :             if (currentMl > ml) {

	cmp	r14, r15
	jbe	SHORT $LN104@ZSTD_HcFin

; 557  :                 ml = currentMl;
; 558  :                 *offsetPtr = current - (matchIndex + dmsIndexDelta) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r15, r14
	sub	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	rcx, QWORD PTR offsetPtr$[rsp]
	sub	eax, esi
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 559  :                 if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [r14+rdi]
	cmp	rax, rbx
	je	SHORT $LN98@ZSTD_HcFin
$LN104@ZSTD_HcFin:

; 560  :             }
; 561  : 
; 562  :             if (matchIndex <= dmsMinChain) break;

	mov	r14, QWORD PTR dmsChainTable$1$[rsp]
	xor	edx, edx
	mov	ebp, DWORD PTR dmsLowestIndex$1$[rsp]
	mov	r10, QWORD PTR dmsBase$1$[rsp]
$LN19@ZSTD_HcFin:
	cmp	esi, DWORD PTR tv894[rsp]
	jbe	SHORT $LN98@ZSTD_HcFin

; 563  :             matchIndex = dmsChainTable[matchIndex & dmsChainMask];

	mov	ecx, DWORD PTR dmsChainSize$1$[rsp]
	dec	ecx
	mov	eax, esi
	and	rcx, rax
	mov	eax, edx
	mov	esi, DWORD PTR [r14+rcx*4]
	cmp	esi, ebp
	mov	ecx, edx
	seta	cl
	add	r12d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL7@ZSTD_HcFin
$LN98@ZSTD_HcFin:

; 568  : }

	mov	rbx, QWORD PTR [rsp+176]
	mov	rax, r15
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN33@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$1[rsp], r10d
	je	SHORT $LN63@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rdi
	add	rcx, rax
	jmp	$LN28@ZSTD_HcFin
$LN63@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r10d

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rdi
	add	rcx, rax
	jmp	$LN28@ZSTD_HcFin
ZSTD_HcFindBestMatch_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
hashLog$1$ = 32
lowLimit$1$ = 36
tv2369 = 36
tv2358 = 40
tv2356 = 40
tv2380 = 44
lowLimit$1$ = 44
chainTable$1$ = 48
chainTable$1$ = 48
base$1$ = 56
base$1$ = 56
base$1$ = 56
target$1$ = 144
tv2364 = 144
hashLog$1$ = 144
ms$ = 144
ip$ = 152
iLimit$ = 160
offsetPtr$ = 168
ZSTD_HcFindBestMatch_selectMLS PROC

; 575  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 72					; 00000048H

; 576  :     switch(ms->cParams.minMatch)

	mov	eax, DWORD PTR [rcx+200]
	lea	r11, QWORD PTR [rcx+184]
	mov	ebp, 1
	mov	rsi, r8
	mov	rdi, rdx
	mov	r10, rcx
	mov	r8d, ebp
	mov	edx, ebp
	lea	r14d, QWORD PTR [rbp+2]
	cmp	eax, 5
	je	$LN5@ZSTD_HcFin
	mov	rcx, QWORD PTR [rcx+64]
	add	eax, -6					; fffffffaH
	mov	r15, QWORD PTR [r10+48]
	mov	QWORD PTR chainTable$1$[rsp], rcx
	mov	ecx, DWORD PTR [r11+4]
	shl	r8d, cl
	mov	ecx, DWORD PTR [r11]
	shl	edx, cl
	mov	ecx, DWORD PTR [r10+28]
	cmp	eax, ebp
	lea	eax, DWORD PTR [r8-1]
	ja	$LN4@ZSTD_HcFin

; 490  :     const U32 chainMask = chainSize-1;

	mov	DWORD PTR tv2380[rsp], eax

; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;

	lea	r13d, DWORD PTR [r8-1]

; 491  :     const BYTE* const base = ms->window.base;

	mov	rax, QWORD PTR [r10+8]

; 462  :     while(idx < target) { /* catch up */

	lea	r12d, QWORD PTR [r14+61]

; 491  :     const BYTE* const base = ms->window.base;

	mov	QWORD PTR base$1$[rsp], rax

; 492  :     const BYTE* const dictBase = ms->window.dictBase;
; 493  :     const U32 dictLimit = ms->window.dictLimit;
; 494  :     const BYTE* const prefixStart = base + dictLimit;
; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 496  :     const U32 current = (U32)(ip-base);

	mov	r9d, edi
	sub	r9d, eax

; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r9d
	mov	DWORD PTR target$1$[rsp], r9d
	sub	eax, ecx

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	ebx, r9d
	sub	ebx, edx
	cmp	eax, edx

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r9d
	cmovbe	ebx, ecx
	cmp	DWORD PTR [r10+32], 0
	cmovne	ebx, ecx
	mov	ecx, DWORD PTR [r11+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], ebx
	xor	ebx, ebx
	cmp	r9d, r8d
	mov	r8d, DWORD PTR [r10+36]
	cmovbe	eax, ebx
	shl	ebp, cl
	mov	DWORD PTR tv2358[rsp], eax

; 462  :     while(idx < target) { /* catch up */

	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	eax, DWORD PTR [r11+8]
	mov	DWORD PTR hashLog$1$[rsp], eax
	cmp	r8d, r9d
	jae	SHORT $LN317@ZSTD_HcFin
	mov	esi, DWORD PTR target$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r11d, r12d
	mov	rdi, QWORD PTR chainTable$1$[rsp]
	sub	r11d, eax
	mov	r9d, r8d
	mov	r14, rcx
	add	r9, QWORD PTR base$1$[rsp]
	npad	10
$LL316@ZSTD_HcFin:
	mov	rax, QWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 466  :         idx++;

	lea	r9, QWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, r14
	mov	ecx, r11d
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	lea	rdx, QWORD PTR [r15+rax*4]
	mov	ecx, r8d
	mov	eax, r13d
	and	rcx, rax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+rcx*4], eax

; 465  :         hashTable[h] = idx;

	mov	DWORD PTR [rdx], r8d

; 466  :         idx++;

	inc	r8d
	cmp	r8d, esi
	jb	SHORT $LL316@ZSTD_HcFin
	mov	rdi, QWORD PTR ip$[rsp]
	mov	r14d, 3
	mov	rsi, QWORD PTR iLimit$[rsp]
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r9d, DWORD PTR target$1$[rsp]
$LN317@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	sub	r12d, DWORD PTR hashLog$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r10+36], r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rdi]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	r10d, DWORD PTR lowLimit$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, rcx
	movzx	ecx, r12b
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, ebx

; 470  :     return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];

	mov	r9d, DWORD PTR [r15+rax*4]

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	r9d, r10d
	mov	eax, ebx
	seta	cl
	test	ebp, ebp
	setne	al
	test	ecx, eax
	je	$LN499@ZSTD_HcFin
	mov	r11d, DWORD PTR tv2358[rsp]
	mov	r15d, DWORD PTR tv2380[rsp]
	npad	9
$LL291@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rdi]
	mov	edx, r9d
	add	rdx, QWORD PTR base$1$[rsp]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN301@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rcx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rdi, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN379@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdi]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN381@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN396@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	SHORT $LN377@ZSTD_HcFin
$LN396@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebx

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, ebx
	jmp	SHORT $LN377@ZSTD_HcFin
$LN381@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN379@ZSTD_HcFin
	npad	5
$LL378@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN382@ZSTD_HcFin
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL378@ZSTD_HcFin
$LN379@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN383@ZSTD_HcFin
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN383@ZSTD_HcFin
	add	rcx, 4
	add	rdx, 4
$LN383@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN384@ZSTD_HcFin
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN384@ZSTD_HcFin
	add	rcx, 2
	add	rdx, 2
$LN384@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN385@ZSTD_HcFin
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN385@ZSTD_HcFin
	inc	rcx
$LN385@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rdx, rcx
	sub	rdx, rdi
$LN377@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rdx, r14
	jbe	SHORT $LN301@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR target$1$[rsp]
	mov	r14, rdx
	mov	rcx, QWORD PTR offsetPtr$[rsp]
	sub	eax, r9d
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rdx+rdi]
	cmp	rax, rsi
	je	$LN499@ZSTD_HcFin
$LN301@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	r9d, r11d
	jbe	$LN499@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	eax, r9d
	mov	rcx, r15
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	r9d, DWORD PTR [rax+rcx*4]
	cmp	r9d, r10d
	mov	ecx, ebx
	mov	eax, ebx
	seta	cl
	add	ebp, -1					; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL291@ZSTD_HcFin

; 580  :     case 5 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 5, ZSTD_noDict);
; 581  :     case 7 :
; 582  :     case 6 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 6, ZSTD_noDict);

	jmp	$LN499@ZSTD_HcFin
$LN382@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN412@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rdi
	add	rdx, rcx
	jmp	SHORT $LN377@ZSTD_HcFin
$LN412@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebx

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rdi
	add	rdx, rcx
	jmp	SHORT $LN377@ZSTD_HcFin
$LN4@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 490  :     const U32 chainMask = chainSize-1;

	mov	DWORD PTR tv2369[rsp], eax

; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;

	lea	r12d, DWORD PTR [r8-1]

; 491  :     const BYTE* const base = ms->window.base;

	mov	rax, QWORD PTR [r10+8]

; 492  :     const BYTE* const dictBase = ms->window.dictBase;
; 493  :     const U32 dictLimit = ms->window.dictLimit;
; 494  :     const BYTE* const prefixStart = base + dictLimit;
; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 496  :     const U32 current = (U32)(ip-base);

	mov	r13d, edi
	sub	r13d, eax
	mov	QWORD PTR base$1$[rsp], rax

; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r13d

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	r9d, r13d
	sub	eax, ecx
	sub	r9d, edx
	cmp	eax, edx

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r13d
	cmovbe	r9d, ecx
	cmp	DWORD PTR [r10+32], 0
	cmovne	r9d, ecx
	mov	ecx, DWORD PTR [r11+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], r9d
	xor	ebx, ebx
	cmp	r13d, r8d
	mov	r8d, DWORD PTR [r10+36]
	cmovbe	eax, ebx
	shl	ebp, cl

; 455  :     const U32 hashLog = cParams->hashLog;

	mov	ecx, DWORD PTR [r11+8]

; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	DWORD PTR tv2356[rsp], eax

; 455  :     const U32 hashLog = cParams->hashLog;

	mov	DWORD PTR hashLog$1$[rsp], ecx

; 458  :     const BYTE* const base = ms->window.base;
; 459  :     const U32 target = (U32)(ip - base);
; 460  :     U32 idx = ms->nextToUpdate;
; 461  : 
; 462  :     while(idx < target) { /* catch up */

	cmp	r8d, r13d
	jae	SHORT $LN37@ZSTD_HcFin
	mov	rsi, QWORD PTR chainTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r11d, 32				; 00000020H
	sub	r11d, ecx

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	r9d, r8d
	add	r9, QWORD PTR base$1$[rsp]
	npad	10
$LL36@ZSTD_HcFin:

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 466  :         idx++;

	lea	r9, QWORD PTR [r9+1]
	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, r11
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	mov	ecx, r12d
	and	rcx, rax
	mov	eax, DWORD PTR [r15+rdx*4]
	mov	DWORD PTR [rsi+rcx*4], eax

; 465  :         hashTable[h] = idx;

	mov	DWORD PTR [r15+rdx*4], r8d

; 466  :         idx++;

	inc	r8d
	cmp	r8d, r13d
	jb	SHORT $LL36@ZSTD_HcFin
	mov	rsi, QWORD PTR iLimit$[rsp]
$LN37@ZSTD_HcFin:

; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r10+36], r13d

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	eax, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rdi], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR hashLog$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	r10d, DWORD PTR lowLimit$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, ebx

; 470  :     return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];

	mov	r9d, DWORD PTR [r15+rdx*4]

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	r9d, r10d
	seta	cl
	test	ebp, ebp
	setne	al
	test	ecx, eax
	je	$LN499@ZSTD_HcFin
	mov	r11d, DWORD PTR tv2356[rsp]
	mov	r15d, DWORD PTR tv2369[rsp]
	npad	8
$LL11@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rdi]
	mov	edx, r9d
	add	rdx, QWORD PTR base$1$[rsp]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN21@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rcx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rdi, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN99@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rdi]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN101@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN116@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	SHORT $LN97@ZSTD_HcFin
$LN116@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebx

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, ebx
	jmp	SHORT $LN97@ZSTD_HcFin
$LN101@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN99@ZSTD_HcFin
	npad	5
$LL98@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN102@ZSTD_HcFin
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL98@ZSTD_HcFin
$LN99@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN103@ZSTD_HcFin
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN103@ZSTD_HcFin
	add	rcx, 4
	add	rdx, 4
$LN103@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN104@ZSTD_HcFin
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN104@ZSTD_HcFin
	add	rcx, 2
	add	rdx, 2
$LN104@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN105@ZSTD_HcFin
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN105@ZSTD_HcFin
	inc	rcx
$LN105@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rdx, rcx
	sub	rdx, rdi
$LN97@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rdx, r14
	jbe	SHORT $LN21@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r13d
	sub	eax, r9d
	mov	r14, rdx
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rdx+rdi]
	cmp	rax, rsi
	je	$LN499@ZSTD_HcFin
$LN21@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	r9d, r11d
	jbe	$LN499@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	eax, r9d
	mov	rcx, r15
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	r9d, DWORD PTR [rax+rcx*4]
	cmp	r9d, r10d
	mov	ecx, ebx
	mov	eax, ebx
	seta	cl
	add	ebp, -1					; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL11@ZSTD_HcFin

; 577  :     {
; 578  :     default : /* includes case 3 */
; 579  :     case 4 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 4, ZSTD_noDict);

	jmp	$LN499@ZSTD_HcFin
$LN102@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN132@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rdi
	add	rdx, rcx
	jmp	SHORT $LN97@ZSTD_HcFin
$LN132@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebx

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rdi
	add	rdx, rcx
	jmp	SHORT $LN97@ZSTD_HcFin
$LN5@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 488  :     U32* const chainTable = ms->chainTable;

	mov	rax, QWORD PTR [rcx+64]

; 492  :     const BYTE* const dictBase = ms->window.dictBase;
; 493  :     const U32 dictLimit = ms->window.dictLimit;
; 494  :     const BYTE* const prefixStart = base + dictLimit;
; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 496  :     const U32 current = (U32)(ip-base);

	mov	r13d, edi
	mov	ecx, DWORD PTR [r11+4]
	shl	r8d, cl

; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	ecx, DWORD PTR [r11]
	shl	edx, cl

; 498  :     const U32 lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [r10+28]
	mov	QWORD PTR chainTable$1$[rsp], rax
	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR tv2364[rsp], eax
	mov	rax, QWORD PTR [r10+8]
	sub	r13d, eax
	mov	QWORD PTR base$1$[rsp], rax

; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r13d

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	r15d, r13d
	sub	r15d, edx
	sub	eax, ecx
	cmp	eax, edx

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	r12d, r13d

; 504  :     size_t ml=4-1;
; 505  : 
; 506  :     /* HC4 match finder */
; 507  :     U32 matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls);

	mov	rdx, r11
	cmovbe	r15d, ecx
	cmp	DWORD PTR [r10+32], 0
	cmovne	r15d, ecx
	mov	ecx, DWORD PTR [r11+12]
	sub	r12d, r8d
	xor	ebx, ebx
	cmp	r13d, r8d
	mov	r8, rdi
	cmovbe	r12d, ebx
	shl	ebp, cl
	mov	rcx, r10
	lea	r9d, QWORD PTR [rbx+5]
	call	ZSTD_insertAndFindFirstIndex_internal

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	eax, r15d
	mov	ecx, ebx
	mov	r9d, eax
	mov	eax, ebx
	seta	cl
	test	ebp, ebp
	setne	al
	test	ecx, eax
	je	$LN499@ZSTD_HcFin
	mov	r10, QWORD PTR base$1$[rsp]
	mov	r11, QWORD PTR chainTable$1$[rsp]
	npad	14
$LL182@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rdi]
	mov	edx, r9d
	add	rdx, r10
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN192@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rax, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rdi, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN208@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rdi]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN210@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	je	SHORT $LN225@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN206@ZSTD_HcFin
$LN225@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebx

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, ebx
	jmp	SHORT $LN206@ZSTD_HcFin
$LN210@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN208@ZSTD_HcFin
	npad	7
$LL207@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN211@ZSTD_HcFin
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL207@ZSTD_HcFin
$LN208@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [rsi-3]
	cmp	rax, rcx
	jae	SHORT $LN212@ZSTD_HcFin
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN212@ZSTD_HcFin
	add	rax, 4
	add	rdx, 4
$LN212@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [rsi-1]
	cmp	rax, rcx
	jae	SHORT $LN213@ZSTD_HcFin
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN213@ZSTD_HcFin
	add	rax, 2
	add	rdx, 2
$LN213@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, rsi
	jae	SHORT $LN214@ZSTD_HcFin
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN214@ZSTD_HcFin
	inc	rax
$LN214@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, rdi
$LN206@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rcx, r14
	jbe	SHORT $LN192@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r13d
	sub	eax, r9d
	mov	r14, rcx
	add	eax, 2
	mov	QWORD PTR [rdx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rcx+rdi]
	cmp	rax, rsi
	je	SHORT $LN499@ZSTD_HcFin
$LN192@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	r9d, r12d
	jbe	SHORT $LN499@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	ecx, DWORD PTR tv2364[rsp]
	mov	edx, ebx
	mov	eax, r9d
	and	rcx, rax
	mov	r9d, DWORD PTR [r11+rcx*4]
	cmp	r9d, r15d
	mov	ecx, ebx
	seta	dl
	add	ebp, -1					; ffffffffH
	setne	cl
	test	edx, ecx
	jne	$LL182@ZSTD_HcFin
$LN499@ZSTD_HcFin:

; 584  : }

	mov	rax, r14
	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN211@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	je	SHORT $LN241@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rdi
	add	rcx, rax
	jmp	SHORT $LN206@ZSTD_HcFin
$LN241@ZSTD_HcFin:
	mov	ecx, ebx

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebx

; 574  :             return (size_t)(pIn - pStart);

	sub	rcx, rdi
	add	rcx, rax
	jmp	$LN206@ZSTD_HcFin
ZSTD_HcFindBestMatch_selectMLS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
dmsIndexDelta$1$ = 32
dmsIndexDelta$1$ = 32
dmsIndexDelta$1$ = 32
dmsLowestIndex$1$ = 36
lowLimit$1$ = 36
dmsLowestIndex$1$ = 36
dmsLowestIndex$1$ = 36
target$1$ = 40
current$1$ = 40
tv2739 = 40
lowLimit$1$ = 40
r$1 = 40
r$2 = 40
base$1$ = 48
dmsEnd$1$ = 48
dmsEnd$1$ = 48
chainTable$1$ = 48
base$1$ = 48
dmsEnd$1$ = 48
dmsChainTable$1$ = 56
dmsChainTable$1$ = 56
tv2770 = 56
tv2741 = 56
tv2740 = 56
r$3 = 56
r$4 = 56
dmsBase$1$ = 64
dmsBase$1$ = 64
chainTable$1$ = 64
dmsBase$1$ = 64
dmsChainTable$1$ = 72
target$1$ = 72
tv2752 = 72
tv2737 = 72
r$5 = 72
r$6 = 72
prefixStart$1$ = 80
tv2758 = 80
tv2742 = 80
prefixStart$1$ = 88
base$1$ = 88
prefixStart$1$ = 88
dmsChainSize$1$ = 176
ms$ = 176
ip$ = 184
iLimit$ = 192
offsetPtr$ = 200
ZSTD_HcFindBestMatch_dictMatchState_selectMLS PROC

; 591  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 104				; 00000068H

; 592  :     switch(ms->cParams.minMatch)

	mov	eax, DWORD PTR [rcx+200]
	lea	r10, QWORD PTR [rcx+184]
	mov	rsi, r8
	mov	rbx, rdx
	mov	r11, rcx
	cmp	eax, 5
	je	$LN5@ZSTD_HcFin
	mov	rcx, QWORD PTR [rcx+64]
	mov	ebp, 1
	mov	QWORD PTR chainTable$1$[rsp], rcx
	add	eax, -6					; fffffffaH
	mov	ecx, DWORD PTR [r10+4]
	mov	r8d, ebp
	shl	r8d, cl
	mov	edx, ebp
	mov	ecx, DWORD PTR [r11+24]
	lea	r14d, QWORD PTR [rbp+2]
	cmp	eax, ebp
	mov	DWORD PTR dmsIndexDelta$1$[rsp], ecx
	lea	eax, DWORD PTR [r8-1]
	ja	$LN4@ZSTD_HcFin

; 455  :     const U32 hashLog = cParams->hashLog;

	mov	r15d, DWORD PTR [r10+8]

; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	r13d, ebp
	mov	DWORD PTR tv2770[rsp], eax

; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;

	lea	ebp, DWORD PTR [r8-1]

; 491  :     const BYTE* const base = ms->window.base;

	mov	rax, QWORD PTR [r11+8]

; 492  :     const BYTE* const dictBase = ms->window.dictBase;
; 493  :     const U32 dictLimit = ms->window.dictLimit;
; 494  :     const BYTE* const prefixStart = base + dictLimit;
; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 496  :     const U32 current = (U32)(ip-base);

	mov	r12d, ebx
	add	rcx, rax
	mov	QWORD PTR base$1$[rsp], rax
	sub	r12d, eax
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	ecx, DWORD PTR [r10]

; 498  :     const U32 lowestValid = ms->window.lowLimit;
; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r12d
	shl	edx, cl

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	r9d, r12d
	mov	ecx, DWORD PTR [r11+28]
	sub	r9d, edx
	sub	eax, ecx
	mov	DWORD PTR target$1$[rsp], r12d
	cmp	eax, edx

; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r12d
	cmovbe	r9d, ecx
	cmp	DWORD PTR [r11+32], 0

; 454  :     U32* const hashTable  = ms->hashTable;

	mov	r11, QWORD PTR [r11+48]

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;

	cmovne	r9d, ecx

; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r10+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], r9d
	xor	edi, edi
	cmp	r12d, r8d
	cmovbe	eax, edi
	shl	r13d, cl
	mov	DWORD PTR tv2742[rsp], eax

; 462  :     while(idx < target) { /* catch up */

	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H

; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	rax, QWORD PTR ms$[rsp]
	mov	r8d, DWORD PTR [rax+36]

; 462  :     while(idx < target) { /* catch up */

	cmp	r8d, r12d
	jae	SHORT $LN317@ZSTD_HcFin
	mov	rsi, QWORD PTR chainTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r10d, 64				; 00000040H
	sub	r10d, r15d
	mov	r9d, r8d
	add	r9, QWORD PTR base$1$[rsp]
	mov	rbx, rcx
	npad	4
$LL316@ZSTD_HcFin:
	mov	rax, QWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 466  :         idx++;

	lea	r9, QWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, rbx
	mov	ecx, r10d
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	lea	rdx, QWORD PTR [r11+rax*4]
	mov	ecx, r8d
	mov	eax, ebp
	and	rcx, rax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rsi+rcx*4], eax

; 465  :         hashTable[h] = idx;

	mov	DWORD PTR [rdx], r8d

; 466  :         idx++;

	inc	r8d
	cmp	r8d, r12d
	jb	SHORT $LL316@ZSTD_HcFin
	mov	rbx, QWORD PTR ip$[rsp]
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	rsi, QWORD PTR iLimit$[rsp]
	mov	rax, QWORD PTR ms$[rsp]
$LN317@ZSTD_HcFin:

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	r10d, DWORD PTR lowLimit$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	ebp, 64					; 00000040H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [rax+36], r12d

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	imul	rdx, rcx
	mov	ecx, ebp
	sub	ecx, r15d
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, edi

; 470  :     return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];

	mov	r9d, DWORD PTR [r11+rdx*4]

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	r9d, r10d
	seta	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	$LN515@ZSTD_HcFin
	mov	r11d, DWORD PTR tv2742[rsp]
	mov	r15d, DWORD PTR tv2770[rsp]
$LL291@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rbx]
	mov	edx, r9d
	add	rdx, QWORD PTR base$1$[rsp]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN301@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rbx, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN379@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rbx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN381@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$6[rsp], edi
	je	SHORT $LN396@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	SHORT $LN377@ZSTD_HcFin
$LN396@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, edi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	SHORT $LN377@ZSTD_HcFin
$LN381@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN379@ZSTD_HcFin
$LL378@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN382@ZSTD_HcFin
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL378@ZSTD_HcFin
$LN379@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN383@ZSTD_HcFin
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN383@ZSTD_HcFin
	add	rcx, 4
	add	rdx, 4
$LN383@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN384@ZSTD_HcFin
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN384@ZSTD_HcFin
	add	rcx, 2
	add	rdx, 2
$LN384@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN385@ZSTD_HcFin
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN385@ZSTD_HcFin
	inc	rcx
$LN385@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rdx, rcx
	sub	rdx, rbx
$LN377@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rdx, r14
	jbe	SHORT $LN301@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r12d
	sub	eax, r9d
	mov	r14, rdx
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rdx+rbx]
	cmp	rax, rsi
	je	SHORT $LN515@ZSTD_HcFin
$LN301@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	r9d, r11d
	jbe	SHORT $LN515@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	eax, r9d
	mov	rcx, r15
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	r9d, DWORD PTR [rax+rcx*4]
	cmp	r9d, r10d
	mov	ecx, edi
	mov	eax, edi
	seta	cl
	add	r13d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL291@ZSTD_HcFin
$LN515@ZSTD_HcFin:

; 532  :     }
; 533  : 
; 534  :     if (dictMode == ZSTD_dictMatchState) {
; 535  :         const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR ms$[rsp]

; 536  :         const U32* const dmsChainTable = dms->chainTable;
; 537  :         const U32 dmsChainSize         = (1 << dms->cParams.chainLog);

	mov	edx, 1
	mov	r8, QWORD PTR [rax+176]

; 541  :         const BYTE* const dmsEnd       = dms->window.nextSrc;

	mov	r9, QWORD PTR [r8]
	mov	r10, QWORD PTR [r8+8]

; 542  :         const U32 dmsSize              = (U32)(dmsEnd - dmsBase);

	mov	eax, r9d
	mov	ecx, DWORD PTR [r8+188]
	sub	eax, r10d

; 543  :         const U32 dmsIndexDelta        = dictLimit - dmsSize;

	sub	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	r15d, DWORD PTR [r8+24]
	mov	r12, QWORD PTR [r8+64]
	shl	edx, cl

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	ecx, eax
	sub	ecx, edx
	mov	DWORD PTR dmsChainSize$1$[rsp], edx
	cmp	eax, edx
	mov	QWORD PTR dmsChainTable$1$[rsp], r12
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	cmovbe	ecx, edi
	mov	DWORD PTR dmsLowestIndex$1$[rsp], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	sub	ebp, DWORD PTR [r8+192]
	imul	rdx, rax
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	rax, QWORD PTR [r8+48]
	mov	DWORD PTR tv2741[rsp], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	movzx	ecx, bpl
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 548  :         for ( ; (matchIndex>dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, edi
	mov	QWORD PTR dmsBase$1$[rsp], r10
	mov	QWORD PTR dmsEnd$1$[rsp], r9
	mov	ebp, DWORD PTR [rax+rdx*4]
	cmp	ebp, r15d
	mov	eax, edi
	seta	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	$LN520@ZSTD_HcFin
$LL294@ZSTD_HcFin:

; 549  :             size_t currentMl=0;
; 550  :             const BYTE* const match = dmsBase + matchIndex;
; 551  :             assert(match+4 <= dmsEnd);
; 552  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rbx]
	mov	r11d, ebp
	add	r11, r10
	cmp	DWORD PTR [r11], eax
	jne	$LN306@ZSTD_HcFin

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r11, 4
	lea	r12, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
	mov	r8, rsi
	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, r9
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	mov	r15, rax
	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, r9
	jne	SHORT $LN454@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r12]
	mov	r8, rsi
	call	ZSTD_count
	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	add	r15, rax
$LN454@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r15, 4

; 554  : 
; 555  :             /* save best solution */
; 556  :             if (currentMl > ml) {

	cmp	r15, r14
	jbe	SHORT $LN523@ZSTD_HcFin

; 557  :                 ml = currentMl;
; 558  :                 *offsetPtr = current - (matchIndex + dmsIndexDelta) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR target$1$[rsp]
	mov	r14, r15
	sub	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	rcx, QWORD PTR offsetPtr$[rsp]
	sub	eax, ebp
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 559  :                 if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [r15+rbx]
	cmp	rax, rsi
	je	$LN520@ZSTD_HcFin
$LN523@ZSTD_HcFin:

; 560  :             }
; 561  : 
; 562  :             if (matchIndex <= dmsMinChain) break;

	mov	r12, QWORD PTR dmsChainTable$1$[rsp]
	mov	r15d, DWORD PTR dmsLowestIndex$1$[rsp]
	mov	r10, QWORD PTR dmsBase$1$[rsp]
$LN306@ZSTD_HcFin:
	cmp	ebp, DWORD PTR tv2741[rsp]
	jbe	$LN520@ZSTD_HcFin

; 563  :             matchIndex = dmsChainTable[matchIndex & dmsChainMask];

	mov	ecx, DWORD PTR dmsChainSize$1$[rsp]
	dec	ecx
	mov	eax, ebp
	and	rcx, rax
	mov	eax, edi
	mov	ebp, DWORD PTR [r12+rcx*4]
	cmp	ebp, r15d
	mov	ecx, edi
	seta	cl
	add	r13d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL294@ZSTD_HcFin

; 596  :     case 5 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 5, ZSTD_dictMatchState);
; 597  :     case 7 :
; 598  :     case 6 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 6, ZSTD_dictMatchState);

	jmp	$LN520@ZSTD_HcFin
$LN382@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$5[rsp], edi
	je	SHORT $LN412@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	$LN377@ZSTD_HcFin
$LN412@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, edi

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	$LN377@ZSTD_HcFin
$LN4@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 455  :     const U32 hashLog = cParams->hashLog;

	mov	r13d, DWORD PTR [r10+8]

; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	r12d, ebp
	mov	DWORD PTR tv2758[rsp], eax

; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;

	lea	ebp, DWORD PTR [r8-1]

; 491  :     const BYTE* const base = ms->window.base;

	mov	rax, QWORD PTR [r11+8]

; 492  :     const BYTE* const dictBase = ms->window.dictBase;
; 493  :     const U32 dictLimit = ms->window.dictLimit;
; 494  :     const BYTE* const prefixStart = base + dictLimit;
; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;
; 496  :     const U32 current = (U32)(ip-base);

	mov	r15d, ebx
	add	rcx, rax
	mov	QWORD PTR base$1$[rsp], rax
	sub	r15d, eax
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	ecx, DWORD PTR [r10]

; 498  :     const U32 lowestValid = ms->window.lowLimit;
; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r15d
	shl	edx, cl

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	r9d, r15d
	mov	ecx, DWORD PTR [r11+28]
	sub	r9d, edx
	sub	eax, ecx
	mov	DWORD PTR target$1$[rsp], r15d
	cmp	eax, edx

; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r15d
	cmovbe	r9d, ecx
	cmp	DWORD PTR [r11+32], 0

; 454  :     U32* const hashTable  = ms->hashTable;

	mov	r11, QWORD PTR [r11+48]

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;

	cmovne	r9d, ecx

; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	ecx, DWORD PTR [r10+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], r9d
	xor	edi, edi
	cmp	r15d, r8d
	cmovbe	eax, edi
	shl	r12d, cl
	mov	DWORD PTR tv2740[rsp], eax
	mov	rax, QWORD PTR ms$[rsp]
	mov	r8d, DWORD PTR [rax+36]

; 462  :     while(idx < target) { /* catch up */

	cmp	r8d, r15d
	jae	SHORT $LN37@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	r9, QWORD PTR base$1$[rsp]

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r10d, 32				; 00000020H
	mov	rsi, QWORD PTR chainTable$1$[rsp]
	sub	r10d, r13d

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	add	r9, r8
	npad	9
$LL36@ZSTD_HcFin:

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 466  :         idx++;

	lea	r9, QWORD PTR [r9+1]
	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, r10
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	mov	ecx, ebp
	and	rcx, rax
	mov	eax, DWORD PTR [r11+rdx*4]
	mov	DWORD PTR [rsi+rcx*4], eax

; 465  :         hashTable[h] = idx;

	mov	DWORD PTR [r11+rdx*4], r8d

; 466  :         idx++;

	inc	r8d
	cmp	r8d, r15d
	jb	SHORT $LL36@ZSTD_HcFin
	mov	rsi, QWORD PTR iLimit$[rsp]
	mov	rax, QWORD PTR ms$[rsp]
$LN37@ZSTD_HcFin:

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	r10d, DWORD PTR lowLimit$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	sub	ecx, r13d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [rax+36], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rbx], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, edi

; 470  :     return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];

	mov	r9d, DWORD PTR [r11+rdx*4]

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	r9d, r10d
	seta	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN517@ZSTD_HcFin
	mov	r11d, DWORD PTR tv2740[rsp]
	mov	ebp, DWORD PTR tv2758[rsp]
	npad	5
$LL11@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rbx]
	mov	edx, r9d
	add	rdx, QWORD PTR base$1$[rsp]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN21@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rbx, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN99@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rbx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN101@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], edi
	je	SHORT $LN116@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	SHORT $LN97@ZSTD_HcFin
$LN116@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, edi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	SHORT $LN97@ZSTD_HcFin
$LN101@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN99@ZSTD_HcFin
	npad	1
$LL98@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN102@ZSTD_HcFin
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL98@ZSTD_HcFin
$LN99@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN103@ZSTD_HcFin
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN103@ZSTD_HcFin
	add	rcx, 4
	add	rdx, 4
$LN103@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN104@ZSTD_HcFin
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN104@ZSTD_HcFin
	add	rcx, 2
	add	rdx, 2
$LN104@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN105@ZSTD_HcFin
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN105@ZSTD_HcFin
	inc	rcx
$LN105@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rdx, rcx
	sub	rdx, rbx
$LN97@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rdx, r14
	jbe	SHORT $LN21@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r15d
	sub	eax, r9d
	mov	r14, rdx
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rdx+rbx]
	cmp	rax, rsi
	je	SHORT $LN517@ZSTD_HcFin
$LN21@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	r9d, r11d
	jbe	SHORT $LN517@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	eax, r9d
	mov	rcx, rbp
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	r9d, DWORD PTR [rax+rcx*4]
	cmp	r9d, r10d
	mov	ecx, edi
	mov	eax, edi
	seta	cl
	add	r12d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL11@ZSTD_HcFin
$LN517@ZSTD_HcFin:

; 532  :     }
; 533  : 
; 534  :     if (dictMode == ZSTD_dictMatchState) {
; 535  :         const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR ms$[rsp]

; 536  :         const U32* const dmsChainTable = dms->chainTable;
; 537  :         const U32 dmsChainSize         = (1 << dms->cParams.chainLog);

	mov	edx, 1
	mov	r8, QWORD PTR [rax+176]

; 541  :         const BYTE* const dmsEnd       = dms->window.nextSrc;

	mov	r9, QWORD PTR [r8]
	mov	r10, QWORD PTR [r8+8]

; 542  :         const U32 dmsSize              = (U32)(dmsEnd - dmsBase);

	mov	eax, r9d
	mov	ecx, DWORD PTR [r8+188]
	sub	eax, r10d

; 543  :         const U32 dmsIndexDelta        = dictLimit - dmsSize;

	sub	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	r15d, DWORD PTR [r8+24]
	mov	r13, QWORD PTR [r8+64]
	shl	edx, cl

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	ecx, eax
	sub	ecx, edx
	mov	DWORD PTR dmsChainSize$1$[rsp], edx
	cmp	eax, edx
	mov	QWORD PTR dmsChainTable$1$[rsp], r13
	mov	rax, QWORD PTR [r8+48]
	cmovbe	ecx, edi
	mov	DWORD PTR dmsLowestIndex$1$[rsp], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rbx], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	DWORD PTR tv2739[rsp], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR [r8+192]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 540  :         const BYTE* const dmsBase      = dms->window.base;

	mov	QWORD PTR dmsBase$1$[rsp], r10

; 541  :         const BYTE* const dmsEnd       = dms->window.nextSrc;

	mov	QWORD PTR dmsEnd$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 548  :         for ( ; (matchIndex>dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, edi
	mov	ebp, DWORD PTR [rax+rdx*4]
	cmp	ebp, r15d
	mov	eax, edi
	seta	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN520@ZSTD_HcFin
$LL14@ZSTD_HcFin:

; 549  :             size_t currentMl=0;
; 550  :             const BYTE* const match = dmsBase + matchIndex;
; 551  :             assert(match+4 <= dmsEnd);
; 552  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rbx]
	mov	r11d, ebp
	add	r11, r10
	cmp	DWORD PTR [r11], eax
	jne	$LN26@ZSTD_HcFin

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r11, 4
	lea	r13, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r13
	mov	r8, rsi
	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, r9
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	mov	r15, rax
	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, r9
	jne	SHORT $LN174@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r13]
	mov	r8, rsi
	call	ZSTD_count
	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	add	r15, rax
$LN174@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r15, 4

; 554  : 
; 555  :             /* save best solution */
; 556  :             if (currentMl > ml) {

	cmp	r15, r14
	jbe	SHORT $LN521@ZSTD_HcFin

; 557  :                 ml = currentMl;
; 558  :                 *offsetPtr = current - (matchIndex + dmsIndexDelta) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR target$1$[rsp]
	mov	r14, r15
	sub	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	rcx, QWORD PTR offsetPtr$[rsp]
	sub	eax, ebp
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 559  :                 if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [r15+rbx]
	cmp	rax, rsi
	je	$LN520@ZSTD_HcFin
$LN521@ZSTD_HcFin:

; 560  :             }
; 561  : 
; 562  :             if (matchIndex <= dmsMinChain) break;

	mov	r13, QWORD PTR dmsChainTable$1$[rsp]
	mov	r15d, DWORD PTR dmsLowestIndex$1$[rsp]
	mov	r10, QWORD PTR dmsBase$1$[rsp]
$LN26@ZSTD_HcFin:
	cmp	ebp, DWORD PTR tv2739[rsp]
	jbe	$LN520@ZSTD_HcFin

; 563  :             matchIndex = dmsChainTable[matchIndex & dmsChainMask];

	mov	ecx, DWORD PTR dmsChainSize$1$[rsp]
	dec	ecx
	mov	eax, ebp
	and	rcx, rax
	mov	eax, edi
	mov	ebp, DWORD PTR [r13+rcx*4]
	cmp	ebp, r15d
	mov	ecx, edi
	seta	cl
	add	r12d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL14@ZSTD_HcFin

; 593  :     {
; 594  :     default : /* includes case 3 */
; 595  :     case 4 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 4, ZSTD_dictMatchState);

	jmp	$LN520@ZSTD_HcFin
$LN102@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], edi
	je	SHORT $LN132@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	$LN97@ZSTD_HcFin
$LN132@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, edi

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	$LN97@ZSTD_HcFin
$LN5@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 488  :     U32* const chainTable = ms->chainTable;

	mov	rax, QWORD PTR [rcx+64]

; 489  :     const U32 chainSize = (1 << cParams->chainLog);

	mov	r9d, 1
	mov	ecx, DWORD PTR [r10+4]
	mov	r8d, r9d
	shl	r8d, cl

; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	edx, r9d
	mov	ecx, DWORD PTR [r11+24]

; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	r12d, r9d
	mov	DWORD PTR dmsIndexDelta$1$[rsp], ecx

; 504  :     size_t ml=4-1;

	lea	r14d, QWORD PTR [r9+2]
	mov	QWORD PTR chainTable$1$[rsp], rax
	mov	ebp, ebx
	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR tv2752[rsp], eax
	mov	rax, QWORD PTR [r11+8]
	add	rcx, rax
	mov	QWORD PTR base$1$[rsp], rax
	sub	ebp, eax
	mov	QWORD PTR prefixStart$1$[rsp], rcx
	mov	ecx, DWORD PTR [r10]
	mov	eax, ebp
	shl	edx, cl
	mov	r15d, ebp
	mov	ecx, DWORD PTR [r11+28]
	sub	r15d, edx
	sub	eax, ecx
	mov	DWORD PTR current$1$[rsp], ebp
	cmp	eax, edx
	mov	r13d, ebp

; 505  : 
; 506  :     /* HC4 match finder */
; 507  :     U32 matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls);

	mov	rdx, r10
	cmovbe	r15d, ecx
	cmp	DWORD PTR [r11+32], 0
	cmovne	r15d, ecx
	mov	ecx, DWORD PTR [r10+12]
	sub	r13d, r8d
	xor	edi, edi
	cmp	ebp, r8d
	mov	r8, rbx
	cmovbe	r13d, edi
	shl	r12d, cl
	mov	rcx, r11
	lea	r9d, QWORD PTR [rdi+5]
	call	ZSTD_insertAndFindFirstIndex_internal

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	eax, r15d
	mov	edx, edi
	mov	ecx, edi
	mov	r9d, eax
	seta	dl
	test	r12d, r12d
	setne	cl
	test	edx, ecx
	je	$LN519@ZSTD_HcFin
	mov	r10, QWORD PTR base$1$[rsp]
	mov	r11, QWORD PTR chainTable$1$[rsp]
$LL182@ZSTD_HcFin:

; 510  :         size_t currentMl=0;
; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
; 512  :             const BYTE* const match = base + matchIndex;
; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rbx]
	mov	edx, r9d
	add	rdx, r10
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN192@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rax, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rbx, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN208@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rbx]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN210@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$4[rsp], edi
	je	SHORT $LN225@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	$LN206@ZSTD_HcFin
$LN225@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, edi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN206@ZSTD_HcFin
$LN210@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN208@ZSTD_HcFin
$LL207@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN211@ZSTD_HcFin
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL207@ZSTD_HcFin
$LN208@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [rsi-3]
	cmp	rax, rcx
	jae	SHORT $LN212@ZSTD_HcFin
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN212@ZSTD_HcFin
	add	rax, 4
	add	rdx, 4
$LN212@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [rsi-1]
	cmp	rax, rcx
	jae	SHORT $LN213@ZSTD_HcFin
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN213@ZSTD_HcFin
	add	rax, 2
	add	rdx, 2
$LN213@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, rsi
	jae	SHORT $LN214@ZSTD_HcFin
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN214@ZSTD_HcFin
	inc	rax
$LN214@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, rbx
$LN206@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 524  :         if (currentMl > ml) {

	cmp	rcx, r14
	jbe	SHORT $LN192@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rdx, QWORD PTR offsetPtr$[rsp]
	mov	eax, ebp
	sub	eax, r9d
	mov	r14, rcx
	add	eax, 2
	mov	QWORD PTR [rdx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rcx+rbx]
	cmp	rax, rsi
	je	SHORT $LN519@ZSTD_HcFin
$LN192@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	r9d, r13d
	jbe	SHORT $LN519@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	eax, DWORD PTR tv2752[rsp]
	mov	ecx, r9d
	and	rcx, rax
	mov	eax, edi
	mov	r9d, DWORD PTR [r11+rcx*4]
	cmp	r9d, r15d
	mov	ecx, edi
	seta	cl
	add	r12d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL182@ZSTD_HcFin
$LN519@ZSTD_HcFin:

; 532  :     }
; 533  : 
; 534  :     if (dictMode == ZSTD_dictMatchState) {
; 535  :         const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR ms$[rsp]

; 536  :         const U32* const dmsChainTable = dms->chainTable;
; 537  :         const U32 dmsChainSize         = (1 << dms->cParams.chainLog);

	mov	edx, 1
	mov	r8, QWORD PTR [rax+176]
	mov	ecx, DWORD PTR [r8+188]

; 541  :         const BYTE* const dmsEnd       = dms->window.nextSrc;

	mov	r9, QWORD PTR [r8]
	mov	r10, QWORD PTR [r8+8]

; 542  :         const U32 dmsSize              = (U32)(dmsEnd - dmsBase);

	mov	eax, r9d
	mov	r15d, DWORD PTR [r8+24]
	sub	eax, r10d

; 543  :         const U32 dmsIndexDelta        = dictLimit - dmsSize;

	sub	DWORD PTR dmsIndexDelta$1$[rsp], eax
	mov	r13, QWORD PTR [r8+64]
	shl	edx, cl

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	ecx, eax
	sub	ecx, edx
	mov	DWORD PTR dmsChainSize$1$[rsp], edx
	cmp	eax, edx
	mov	QWORD PTR dmsChainTable$1$[rsp], r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	mov	eax, 64					; 00000040H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	cmovbe	ecx, edi
	mov	DWORD PTR dmsLowestIndex$1$[rsp], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	sub	eax, DWORD PTR [r8+192]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	DWORD PTR tv2737[rsp], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rdx, rcx
	movzx	ecx, al
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 540  :         const BYTE* const dmsBase      = dms->window.base;

	mov	QWORD PTR dmsBase$1$[rsp], r10

; 546  :         matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];

	mov	rax, QWORD PTR [r8+48]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 548  :         for ( ; (matchIndex>dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, edi
	mov	QWORD PTR dmsEnd$1$[rsp], r9
	mov	ebp, DWORD PTR [rax+rdx*4]
	cmp	ebp, r15d
	mov	eax, edi
	seta	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN520@ZSTD_HcFin
	npad	1
$LL185@ZSTD_HcFin:

; 549  :             size_t currentMl=0;
; 550  :             const BYTE* const match = dmsBase + matchIndex;
; 551  :             assert(match+4 <= dmsEnd);
; 552  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rbx]
	mov	r11d, ebp
	add	r11, r10
	cmp	DWORD PTR [r11], eax
	jne	$LN197@ZSTD_HcFin

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r11, 4
	lea	r13, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r13
	mov	r8, rsi
	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, r9
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	mov	r15, rax
	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, r9
	jne	SHORT $LN283@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r13]
	mov	r8, rsi
	call	ZSTD_count
	mov	r9, QWORD PTR dmsEnd$1$[rsp]
	add	r15, rax
$LN283@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 553  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;

	add	r15, 4

; 554  : 
; 555  :             /* save best solution */
; 556  :             if (currentMl > ml) {

	cmp	r15, r14
	jbe	SHORT $LN522@ZSTD_HcFin

; 557  :                 ml = currentMl;
; 558  :                 *offsetPtr = current - (matchIndex + dmsIndexDelta) + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r14, r15
	sub	eax, DWORD PTR dmsIndexDelta$1$[rsp]
	mov	rcx, QWORD PTR offsetPtr$[rsp]
	sub	eax, ebp
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 559  :                 if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [r15+rbx]
	cmp	rax, rsi
	je	SHORT $LN520@ZSTD_HcFin
$LN522@ZSTD_HcFin:

; 560  :             }
; 561  : 
; 562  :             if (matchIndex <= dmsMinChain) break;

	mov	r13, QWORD PTR dmsChainTable$1$[rsp]
	mov	r15d, DWORD PTR dmsLowestIndex$1$[rsp]
	mov	r10, QWORD PTR dmsBase$1$[rsp]
$LN197@ZSTD_HcFin:
	cmp	ebp, DWORD PTR tv2737[rsp]
	jbe	SHORT $LN520@ZSTD_HcFin

; 563  :             matchIndex = dmsChainTable[matchIndex & dmsChainMask];

	mov	ecx, DWORD PTR dmsChainSize$1$[rsp]
	mov	edx, edi
	dec	ecx
	mov	eax, ebp
	and	rcx, rax
	mov	ebp, DWORD PTR [r13+rcx*4]
	cmp	ebp, r15d
	mov	ecx, edi
	seta	dl
	add	r12d, -1				; ffffffffH
	setne	cl
	test	edx, ecx
	jne	$LL185@ZSTD_HcFin
$LN520@ZSTD_HcFin:

; 600  : }

	mov	rax, r14
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN211@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$3[rsp], edi
	je	SHORT $LN241@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rbx
	add	rcx, rax
	jmp	$LN206@ZSTD_HcFin
$LN241@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, edi

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rbx
	add	rcx, rax
	jmp	$LN206@ZSTD_HcFin
ZSTD_HcFindBestMatch_dictMatchState_selectMLS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
target$1$ = 32
target$1$ = 32
hashLog$1$ = 36
tv2534 = 36
dictLimit$1$ = 40
tv2541 = 40
tv2521 = 40
current$1$ = 44
tv2523 = 44
tv2522 = 44
lowLimit$1$ = 48
tv2554 = 48
dictLimit$1$ = 48
dictEnd$1$ = 56
dictEnd$1$ = 56
base$1$ = 56
base$1$ = 64
prefixStart$1$ = 64
dictEnd$1$ = 64
chainTable$1$ = 72
chainTable$1$ = 72
dictBase$1$ = 80
dictBase$1$ = 80
prefixStart$1$ = 80
prefixStart$1$ = 88
base$1$ = 88
dictBase$1$ = 88
lowLimit$1$ = 176
dictLimit$1$ = 176
lowLimit$1$ = 176
ms$ = 176
ip$ = 184
iLimit$ = 192
offsetPtr$ = 200
ZSTD_HcFindBestMatch_extDict_selectMLS PROC

; 607  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 104				; 00000068H

; 608  :     switch(ms->cParams.minMatch)

	mov	eax, DWORD PTR [rcx+200]
	lea	r11, QWORD PTR [rcx+184]
	mov	r13d, 1
	mov	rdi, r8
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx+16]
	mov	r8d, r13d
	mov	r10, rcx
	cmp	eax, 5
	je	$LN5@ZSTD_HcFin
	mov	rcx, QWORD PTR [rcx+64]
	add	eax, -6					; fffffffaH
	mov	QWORD PTR chainTable$1$[rsp], rcx
	mov	ecx, DWORD PTR [r11+4]
	shl	r8d, cl
	mov	rcx, QWORD PTR [r10+8]
	cmp	eax, r13d
	lea	eax, DWORD PTR [r8-1]
	ja	$LN4@ZSTD_HcFin

; 454  :     U32* const hashTable  = ms->hashTable;

	mov	r15, QWORD PTR [r10+48]

; 456  :     U32* const chainTable = ms->chainTable;
; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;

	lea	r12d, DWORD PTR [r8-1]

; 490  :     const U32 chainMask = chainSize-1;

	mov	DWORD PTR tv2554[rsp], eax

; 493  :     const U32 dictLimit = ms->window.dictLimit;

	mov	eax, DWORD PTR [r10+24]
	mov	DWORD PTR dictLimit$1$[rsp], eax
	mov	QWORD PTR dictBase$1$[rsp], rdx
	mov	QWORD PTR base$1$[rsp], rcx

; 494  :     const BYTE* const prefixStart = base + dictLimit;

	lea	r9, QWORD PTR [rax+rcx]

; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;

	add	rax, rdx
	mov	QWORD PTR dictEnd$1$[rsp], rax

; 496  :     const U32 current = (U32)(ip-base);
; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	edx, r13d
	mov	QWORD PTR prefixStart$1$[rsp], r9
	mov	r9d, ebx
	sub	r9d, ecx
	mov	ecx, DWORD PTR [r11]
	shl	edx, cl

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	esi, r9d
	mov	ecx, DWORD PTR [r10+28]
	sub	esi, edx
	mov	eax, r9d
	mov	DWORD PTR target$1$[rsp], r9d
	sub	eax, ecx
	cmp	eax, edx
	mov	edx, esi

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r9d
	cmovbe	edx, ecx
	cmp	DWORD PTR [r10+32], 0
	cmovne	edx, ecx
	mov	ecx, DWORD PTR [r11+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], edx
	xor	esi, esi
	cmp	r9d, r8d
	mov	r8d, DWORD PTR [r10+36]
	cmovbe	eax, esi
	shl	r13d, cl
	mov	DWORD PTR tv2523[rsp], eax

; 504  :     size_t ml=4-1;

	lea	r14d, QWORD PTR [rsi+3]

; 455  :     const U32 hashLog = cParams->hashLog;

	mov	eax, DWORD PTR [r11+8]

; 458  :     const BYTE* const base = ms->window.base;
; 459  :     const U32 target = (U32)(ip - base);
; 460  :     U32 idx = ms->nextToUpdate;
; 461  : 
; 462  :     while(idx < target) { /* catch up */

	lea	ebp, QWORD PTR [rsi+64]
	mov	DWORD PTR hashLog$1$[rsp], eax
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	cmp	r8d, r9d
	jae	SHORT $LN317@ZSTD_HcFin
	mov	edi, DWORD PTR target$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r11d, ebp
	mov	rbx, QWORD PTR chainTable$1$[rsp]
	sub	r11d, eax
	mov	r9d, r8d
	mov	r14, rcx
	add	r9, QWORD PTR base$1$[rsp]
	npad	6
$LL316@ZSTD_HcFin:
	mov	rax, QWORD PTR [r9]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 466  :         idx++;

	lea	r9, QWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, r14
	mov	ecx, r11d
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	lea	rdx, QWORD PTR [r15+rax*4]
	mov	ecx, r8d
	mov	eax, r12d
	and	rcx, rax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rbx+rcx*4], eax

; 465  :         hashTable[h] = idx;

	mov	DWORD PTR [rdx], r8d

; 466  :         idx++;

	inc	r8d
	cmp	r8d, edi
	jb	SHORT $LL316@ZSTD_HcFin
	mov	rbx, QWORD PTR ip$[rsp]
	mov	r14d, 3
	mov	rdi, QWORD PTR iLimit$[rsp]
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r9d, DWORD PTR target$1$[rsp]
	mov	edx, DWORD PTR lowLimit$1$[rsp]
$LN317@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	sub	ebp, DWORD PTR hashLog$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r10+36], r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rbx]
	imul	rax, rcx
	movzx	ecx, bpl
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, esi

; 470  :     return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];

	mov	ebp, DWORD PTR [r15+rax*4]

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	ebp, edx
	mov	eax, esi
	seta	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	$LN499@ZSTD_HcFin
	npad	5
$LL291@ZSTD_HcFin:

; 510  :         size_t currentMl=0;

	mov	eax, ebp

; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {

	cmp	ebp, DWORD PTR dictLimit$1$[rsp]
	jb	$LN295@ZSTD_HcFin

; 512  :             const BYTE* const match = base + matchIndex;

	mov	rdx, QWORD PTR base$1$[rsp]
	add	rdx, rax

; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rbx]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN503@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rbx, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN379@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rbx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN381@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN396@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	$LN299@ZSTD_HcFin
$LN396@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, esi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	$LN299@ZSTD_HcFin
$LN381@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN379@ZSTD_HcFin
	npad	3
$LL378@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN382@ZSTD_HcFin
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL378@ZSTD_HcFin
$LN379@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN383@ZSTD_HcFin
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN383@ZSTD_HcFin
	add	rcx, 4
	add	rdx, 4
$LN383@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN384@ZSTD_HcFin
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN384@ZSTD_HcFin
	add	rcx, 2
	add	rdx, 2
$LN384@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN385@ZSTD_HcFin
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN385@ZSTD_HcFin
	inc	rcx
$LN385@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rdx, rcx
	sub	rdx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 516  :         } else {

	jmp	$LN299@ZSTD_HcFin
$LN382@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN412@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	SHORT $LN299@ZSTD_HcFin
$LN412@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, esi

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	SHORT $LN299@ZSTD_HcFin
$LN295@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 517  :             const BYTE* const match = dictBase + matchIndex;

	mov	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, rax

; 518  :             assert(match+4 <= dictEnd);
; 519  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [r11], eax
	jne	$LN301@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbx+4]
	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r12
	sub	rax, r11
	mov	r8, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN420@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r12]
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN420@ZSTD_HcFin:
	mov	r9d, DWORD PTR target$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r15+4]
$LN299@ZSTD_HcFin:

; 521  :         }
; 522  : 
; 523  :         /* save best solution */
; 524  :         if (currentMl > ml) {

	cmp	rdx, r14
	jbe	SHORT $LN503@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r9d
	sub	eax, ebp
	mov	r14, rdx
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rdx+rbx]
	cmp	rax, rdi
	je	$LN499@ZSTD_HcFin
$LN503@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	mov	edx, DWORD PTR lowLimit$1$[rsp]
$LN301@ZSTD_HcFin:
	cmp	ebp, DWORD PTR tv2523[rsp]
	jbe	$LN499@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	ecx, DWORD PTR tv2554[rsp]
	mov	eax, ebp
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	ebp, DWORD PTR [rax+rcx*4]
	cmp	ebp, edx
	mov	ecx, esi
	mov	eax, esi
	seta	cl
	add	r13d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL291@ZSTD_HcFin

; 612  :     case 5 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 5, ZSTD_extDict);
; 613  :     case 7 :
; 614  :     case 6 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 6, ZSTD_extDict);

	jmp	$LN499@ZSTD_HcFin
$LN4@ZSTD_HcFin:

; 454  :     U32* const hashTable  = ms->hashTable;

	mov	r15, QWORD PTR [r10+48]

; 456  :     U32* const chainTable = ms->chainTable;
; 457  :     const U32 chainMask = (1 << cParams->chainLog) - 1;

	lea	ebp, DWORD PTR [r8-1]
	mov	r12d, DWORD PTR [r11+8]

; 490  :     const U32 chainMask = chainSize-1;

	mov	DWORD PTR tv2541[rsp], eax

; 493  :     const U32 dictLimit = ms->window.dictLimit;

	mov	eax, DWORD PTR [r10+24]
	mov	DWORD PTR dictLimit$1$[rsp], eax
	mov	QWORD PTR base$1$[rsp], rcx
	mov	QWORD PTR dictBase$1$[rsp], rdx

; 494  :     const BYTE* const prefixStart = base + dictLimit;

	lea	r9, QWORD PTR [rax+rcx]

; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;

	add	rax, rdx
	mov	QWORD PTR dictEnd$1$[rsp], rax

; 496  :     const U32 current = (U32)(ip-base);
; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	edx, r13d
	mov	QWORD PTR prefixStart$1$[rsp], r9
	mov	r9d, ebx
	sub	r9d, ecx
	mov	ecx, DWORD PTR [r11]
	shl	edx, cl

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	esi, r9d
	mov	ecx, DWORD PTR [r10+28]
	sub	esi, edx
	mov	eax, r9d
	mov	DWORD PTR target$1$[rsp], r9d
	sub	eax, ecx
	cmp	eax, edx

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r9d
	cmovbe	esi, ecx
	cmp	DWORD PTR [r10+32], 0
	cmovne	esi, ecx
	mov	ecx, DWORD PTR [r11+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], esi
	xor	esi, esi
	cmp	r9d, r8d
	mov	r8d, DWORD PTR [r10+36]
	cmovbe	eax, esi
	shl	r13d, cl
	mov	DWORD PTR tv2522[rsp], eax

; 504  :     size_t ml=4-1;

	lea	r14d, QWORD PTR [rsi+3]

; 462  :     while(idx < target) { /* catch up */

	cmp	r8d, r9d
	jae	SHORT $LN37@ZSTD_HcFin
	mov	edi, DWORD PTR target$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r11d, 32				; 00000020H
	mov	rbx, QWORD PTR chainTable$1$[rsp]
	sub	r11d, r12d

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	r9d, r8d
	add	r9, QWORD PTR base$1$[rsp]
$LL36@ZSTD_HcFin:

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r9], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 466  :         idx++;

	lea	r9, QWORD PTR [r9+1]
	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, r11
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 464  :         NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];

	mov	ecx, ebp
	and	rcx, rax
	mov	eax, DWORD PTR [r15+rdx*4]
	mov	DWORD PTR [rbx+rcx*4], eax

; 465  :         hashTable[h] = idx;

	mov	DWORD PTR [r15+rdx*4], r8d

; 466  :         idx++;

	inc	r8d
	cmp	r8d, edi
	jb	SHORT $LL36@ZSTD_HcFin
	mov	rbx, QWORD PTR ip$[rsp]
	mov	rdi, QWORD PTR iLimit$[rsp]
	mov	r9d, DWORD PTR target$1$[rsp]
$LN37@ZSTD_HcFin:

; 469  :     ms->nextToUpdate = target;

	mov	DWORD PTR [r10+36], r9d

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	eax, esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rbx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, r12d
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	ecx, esi

; 470  :     return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];

	mov	ebp, DWORD PTR [r15+rdx*4]

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	mov	edx, DWORD PTR lowLimit$1$[rsp]
	cmp	ebp, edx
	seta	cl
	test	r13d, r13d
	setne	al
	test	ecx, eax
	je	$LN499@ZSTD_HcFin
	npad	6
$LL11@ZSTD_HcFin:

; 510  :         size_t currentMl=0;

	mov	eax, ebp

; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {

	cmp	ebp, DWORD PTR dictLimit$1$[rsp]
	jb	$LN15@ZSTD_HcFin

; 512  :             const BYTE* const match = base + matchIndex;

	mov	rdx, QWORD PTR base$1$[rsp]
	add	rdx, rax

; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rbx]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN501@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rbx, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN99@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rbx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN101@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN116@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	$LN19@ZSTD_HcFin
$LN116@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, esi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	edx, eax
	jmp	$LN19@ZSTD_HcFin
$LN101@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN99@ZSTD_HcFin
	npad	3
$LL98@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN102@ZSTD_HcFin
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL98@ZSTD_HcFin
$LN99@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rdi-3]
	cmp	rcx, rax
	jae	SHORT $LN103@ZSTD_HcFin
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN103@ZSTD_HcFin
	add	rcx, 4
	add	rdx, 4
$LN103@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rdi-1]
	cmp	rcx, rax
	jae	SHORT $LN104@ZSTD_HcFin
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN104@ZSTD_HcFin
	add	rcx, 2
	add	rdx, 2
$LN104@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rdi
	jae	SHORT $LN105@ZSTD_HcFin
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN105@ZSTD_HcFin
	inc	rcx
$LN105@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rdx, rcx
	sub	rdx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 516  :         } else {

	jmp	$LN19@ZSTD_HcFin
$LN102@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN132@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	SHORT $LN19@ZSTD_HcFin
$LN132@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, esi

; 574  :             return (size_t)(pIn - pStart);

	sub	rdx, rbx
	add	rdx, rcx
	jmp	SHORT $LN19@ZSTD_HcFin
$LN15@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 517  :             const BYTE* const match = dictBase + matchIndex;

	mov	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, rax

; 518  :             assert(match+4 <= dictEnd);
; 519  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [r11], eax
	jne	$LN21@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbx+4]
	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r12
	sub	rax, r11
	mov	r8, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN140@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r12]
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN140@ZSTD_HcFin:
	mov	r9d, DWORD PTR target$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r15+4]
$LN19@ZSTD_HcFin:

; 521  :         }
; 522  : 
; 523  :         /* save best solution */
; 524  :         if (currentMl > ml) {

	cmp	rdx, r14
	jbe	SHORT $LN501@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	rcx, QWORD PTR offsetPtr$[rsp]
	mov	eax, r9d
	sub	eax, ebp
	mov	r14, rdx
	add	eax, 2
	mov	QWORD PTR [rcx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rdx+rbx]
	cmp	rax, rdi
	je	$LN499@ZSTD_HcFin
$LN501@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	mov	edx, DWORD PTR lowLimit$1$[rsp]
$LN21@ZSTD_HcFin:
	cmp	ebp, DWORD PTR tv2522[rsp]
	jbe	$LN499@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	ecx, DWORD PTR tv2541[rsp]
	mov	eax, ebp
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	ebp, DWORD PTR [rax+rcx*4]
	cmp	ebp, edx
	mov	ecx, esi
	mov	eax, esi
	seta	cl
	add	r13d, -1				; ffffffffH
	setne	al
	test	ecx, eax
	jne	$LL11@ZSTD_HcFin

; 609  :     {
; 610  :     default : /* includes case 3 */
; 611  :     case 4 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 4, ZSTD_extDict);

	jmp	$LN499@ZSTD_HcFin
$LN5@ZSTD_HcFin:

; 488  :     U32* const chainTable = ms->chainTable;

	mov	rax, QWORD PTR [rcx+64]

; 489  :     const U32 chainSize = (1 << cParams->chainLog);

	mov	ecx, DWORD PTR [r11+4]
	shl	r8d, cl

; 491  :     const BYTE* const base = ms->window.base;

	mov	rcx, QWORD PTR [r10+8]
	mov	QWORD PTR chainTable$1$[rsp], rax
	mov	QWORD PTR base$1$[rsp], rcx
	lea	eax, DWORD PTR [r8-1]

; 492  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	QWORD PTR dictBase$1$[rsp], rdx
	mov	DWORD PTR tv2534[rsp], eax

; 493  :     const U32 dictLimit = ms->window.dictLimit;

	mov	eax, DWORD PTR [r10+24]
	mov	DWORD PTR dictLimit$1$[rsp], eax

; 494  :     const BYTE* const prefixStart = base + dictLimit;

	lea	r9, QWORD PTR [rcx+rax]

; 495  :     const BYTE* const dictEnd = dictBase + dictLimit;

	lea	r15, QWORD PTR [rdx+rax]
	mov	QWORD PTR prefixStart$1$[rsp], r9

; 496  :     const U32 current = (U32)(ip-base);
; 497  :     const U32 maxDistance = 1U << cParams->windowLog;

	mov	edx, r13d
	mov	QWORD PTR dictEnd$1$[rsp], r15
	mov	r9d, ebx
	sub	r9d, ecx
	mov	ecx, DWORD PTR [r11]
	shl	edx, cl

; 498  :     const U32 lowestValid = ms->window.lowLimit;
; 499  :     const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r9d
	mov	ecx, DWORD PTR [r10+28]

; 500  :     const U32 isDictionary = (ms->loadedDictEnd != 0);

	mov	r12d, r9d
	sub	eax, ecx
	mov	DWORD PTR current$1$[rsp], r9d
	sub	r12d, edx
	cmp	eax, edx

; 501  :     const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
; 502  :     const U32 minChain = current > chainSize ? current - chainSize : 0;
; 503  :     U32 nbAttempts = 1U << cParams->searchLog;

	mov	eax, r9d

; 505  : 
; 506  :     /* HC4 match finder */
; 507  :     U32 matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls);

	mov	rdx, r11
	cmovbe	r12d, ecx
	cmp	DWORD PTR [r10+32], 0
	cmovne	r12d, ecx
	mov	ecx, DWORD PTR [r11+12]
	sub	eax, r8d
	mov	DWORD PTR lowLimit$1$[rsp], r12d
	xor	esi, esi
	cmp	r9d, r8d
	mov	r8, rbx
	cmovbe	eax, esi
	shl	r13d, cl
	mov	rcx, r10
	mov	DWORD PTR tv2521[rsp], eax
	lea	r9d, QWORD PTR [rsi+5]
	lea	r14d, QWORD PTR [rsi+3]
	call	ZSTD_insertAndFindFirstIndex_internal

; 509  :     for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {

	cmp	eax, r12d
	mov	edx, esi
	mov	ecx, esi
	mov	ebp, eax
	seta	dl
	test	r13d, r13d
	setne	cl
	test	edx, ecx
	je	$LN499@ZSTD_HcFin
	npad	4
$LL182@ZSTD_HcFin:

; 510  :         size_t currentMl=0;

	mov	eax, ebp

; 511  :         if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {

	cmp	ebp, DWORD PTR dictLimit$1$[rsp]
	jb	$LN186@ZSTD_HcFin

; 512  :             const BYTE* const match = base + matchIndex;

	mov	rdx, QWORD PTR base$1$[rsp]
	add	rdx, rax

; 513  :             assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
; 514  :             if (match[ml] == ip[ml])   /* potentially better */

	movzx	eax, BYTE PTR [r14+rbx]
	cmp	BYTE PTR [rdx+r14], al
	jne	$LN192@ZSTD_HcFin
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rdi-7]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 515  :                 currentMl = ZSTD_count(ip, match, iLimit);

	mov	rax, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	cmp	rbx, r8

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	jae	SHORT $LN208@ZSTD_HcFin

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rbx]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN210@ZSTD_HcFin

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	je	SHORT $LN225@ZSTD_HcFin
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	$LN190@ZSTD_HcFin
$LN225@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, esi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	$LN190@ZSTD_HcFin
$LN210@ZSTD_HcFin:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN208@ZSTD_HcFin
$LL207@ZSTD_HcFin:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN211@ZSTD_HcFin
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL207@ZSTD_HcFin
$LN208@ZSTD_HcFin:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [rdi-3]
	cmp	rax, rcx
	jae	SHORT $LN212@ZSTD_HcFin
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN212@ZSTD_HcFin
	add	rax, 4
	add	rdx, 4
$LN212@ZSTD_HcFin:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [rdi-1]
	cmp	rax, rcx
	jae	SHORT $LN213@ZSTD_HcFin
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN213@ZSTD_HcFin
	add	rax, 2
	add	rdx, 2
$LN213@ZSTD_HcFin:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, rdi
	jae	SHORT $LN214@ZSTD_HcFin
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN214@ZSTD_HcFin
	inc	rax
$LN214@ZSTD_HcFin:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 516  :         } else {

	jmp	$LN190@ZSTD_HcFin
$LN211@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	je	SHORT $LN241@ZSTD_HcFin
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rbx
	add	rcx, rax
	jmp	SHORT $LN190@ZSTD_HcFin
$LN241@ZSTD_HcFin:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, esi

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, rbx
	add	rcx, rax
	jmp	SHORT $LN190@ZSTD_HcFin
$LN186@ZSTD_HcFin:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 517  :             const BYTE* const match = dictBase + matchIndex;

	mov	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, rax

; 518  :             assert(match+4 <= dictEnd);
; 519  :             if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */

	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [r11], eax
	jne	SHORT $LN192@ZSTD_HcFin

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	add	r11, 4
	lea	r12, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
	mov	r8, rdi
	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, r15
	cmp	rcx, rdi
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN249@ZSTD_HcFin

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r12]
	mov	r8, rdi
	call	ZSTD_count
	add	r15, rax
$LN249@ZSTD_HcFin:
	mov	r12d, DWORD PTR lowLimit$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 520  :                 currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;

	lea	rcx, QWORD PTR [r15+4]
	mov	r15, QWORD PTR dictEnd$1$[rsp]
$LN190@ZSTD_HcFin:

; 521  :         }
; 522  : 
; 523  :         /* save best solution */
; 524  :         if (currentMl > ml) {

	cmp	rcx, r14
	jbe	SHORT $LN192@ZSTD_HcFin

; 525  :             ml = currentMl;
; 526  :             *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;

	mov	eax, DWORD PTR current$1$[rsp]
	mov	r14, rcx
	mov	rdx, QWORD PTR offsetPtr$[rsp]
	sub	eax, ebp
	add	eax, 2
	mov	QWORD PTR [rdx], rax

; 527  :             if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */

	lea	rax, QWORD PTR [rcx+rbx]
	cmp	rax, rdi
	je	SHORT $LN499@ZSTD_HcFin
$LN192@ZSTD_HcFin:

; 528  :         }
; 529  : 
; 530  :         if (matchIndex <= minChain) break;

	cmp	ebp, DWORD PTR tv2521[rsp]
	jbe	SHORT $LN499@ZSTD_HcFin

; 531  :         matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);

	mov	eax, DWORD PTR tv2534[rsp]
	mov	edx, esi
	mov	ecx, ebp
	and	rcx, rax
	mov	rax, QWORD PTR chainTable$1$[rsp]
	mov	ebp, DWORD PTR [rax+rcx*4]
	cmp	ebp, r12d
	mov	ecx, esi
	seta	dl
	add	r13d, -1				; ffffffffH
	setne	cl
	test	edx, ecx
	jne	$LL182@ZSTD_HcFin
$LN499@ZSTD_HcFin:

; 615  :     }
; 616  : }

	mov	rax, r14
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_HcFindBestMatch_extDict_selectMLS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
lowestValid$1$ = 32
offset_2$1$ = 40
base$1$ = 48
iend$1$ = 56
dictIndexDelta$1$ = 64
offset$1$ = 72
start$1$ = 80
savedOffset$1$ = 88
dictBase$1$ = 96
prefixLowest$1$ = 104
dictEnd$1$ = 112
searchMax$1$ = 120
offsetFound$1 = 128
offset2$2 = 136
offset2$3 = 144
dictLowest$1$ = 152
tv3411 = 160
ms$ = 256
seqStore$ = 264
rep$ = 272
r$4 = 280
r$5 = 280
src$ = 280
offset_1$1$ = 288
srcSize$ = 288
searchMethod$ = 296
depth$ = 304
dictMode$ = 312
ZSTD_compressBlock_lazy_generic PROC

; 631  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-7]
	sub	rsp, 184				; 000000b8H

; 632  :     const BYTE* const istart = (const BYTE*)src;
; 633  :     const BYTE* ip = istart;
; 634  :     const BYTE* anchor = istart;
; 635  :     const BYTE* const iend = istart + srcSize;
; 636  :     const BYTE* const ilimit = iend - 8;
; 637  :     const BYTE* const base = ms->window.base;
; 638  :     const U32 prefixLowestIndex = ms->window.dictLimit;

	mov	r10d, DWORD PTR [rcx+24]
	mov	r14, r9
	mov	rsi, QWORD PTR srcSize$[rbp-177]
	mov	r9, r8
	add	rsi, r14
	mov	DWORD PTR lowestValid$1$[rsp], r10d
	mov	r11, rdx
	mov	QWORD PTR iend$1$[rbp-177], rsi
	mov	rdx, QWORD PTR [rcx+8]
	mov	r13, rcx

; 639  :     const BYTE* const prefixLowest = base + prefixLowestIndex;

	mov	r12d, DWORD PTR [r9]
	lea	rax, QWORD PTR [r9+4]

; 640  : 
; 641  :     typedef size_t (*searchMax_f)(
; 642  :                         ZSTD_matchState_t* ms,
; 643  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?

	mov	ecx, DWORD PTR dictMode$[rbp-177]
	lea	r15, QWORD PTR [rsi-8]
	mov	r9d, DWORD PTR [rax]
	xor	ebx, ebx
	mov	QWORD PTR tv3411[rbp-177], rax
	lea	r8, QWORD PTR [rdx+r10]
	mov	QWORD PTR prefixLowest$1$[rbp-177], r8
	mov	QWORD PTR base$1$[rsp], rdx
	mov	DWORD PTR offset_1$1$[rbp-177], r12d
	cmp	ecx, 2
	jne	SHORT $LN46@ZSTD_compr
	mov	rax, QWORD PTR [r13+176]

; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;
; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?

	mov	rbx, QWORD PTR [rax+8]

; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?

	mov	edi, DWORD PTR [rax+24]

; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?

	mov	r13d, ebx
	mov	rax, QWORD PTR [rax]
	add	rdi, rbx
	sub	r13d, eax
	mov	QWORD PTR dictBase$1$[rbp-177], rbx
	add	r13d, r10d
	mov	QWORD PTR dictLowest$1$[rbp-177], rdi
	cmp	DWORD PTR searchMethod$[rbp-177], 1
	lea	rbx, OFFSET FLAT:ZSTD_BtFindBestMatch_dictMatchState_selectMLS
	mov	DWORD PTR dictIndexDelta$1$[rbp-177], r13d
	lea	r13, OFFSET FLAT:ZSTD_HcFindBestMatch_dictMatchState_selectMLS
	cmove	r13, rbx
	mov	QWORD PTR dictEnd$1$[rbp-177], rax
	mov	QWORD PTR searchMax$1$[rbp-177], r13
	mov	r13, QWORD PTR ms$[rbp-177]
	jmp	SHORT $LN500@ZSTD_compr
$LN46@ZSTD_compr:

; 640  : 
; 641  :     typedef size_t (*searchMax_f)(
; 642  :                         ZSTD_matchState_t* ms,
; 643  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 644  :     searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?

	cmp	DWORD PTR searchMethod$[rbp-177], 1
	lea	rsi, OFFSET FLAT:ZSTD_BtFindBestMatch_selectMLS

; 645  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS
; 646  :                                          : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :
; 647  :         (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS
; 648  :                                          : ZSTD_HcFindBestMatch_selectMLS);
; 649  :     U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;
; 650  : 
; 651  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;
; 652  :     const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?
; 653  :                                      dms->window.dictLimit : 0;
; 654  :     const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?

	mov	QWORD PTR dictBase$1$[rbp-177], rbx

; 655  :                                      dms->window.base : NULL;
; 656  :     const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?

	mov	rdi, rbx
	mov	QWORD PTR dictLowest$1$[rbp-177], rbx

; 657  :                                      dictBase + dictLowestIndex : NULL;
; 658  :     const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?

	mov	QWORD PTR dictEnd$1$[rbp-177], rbx

; 659  :                                      dms->window.nextSrc : NULL;
; 660  :     const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?

	mov	DWORD PTR dictIndexDelta$1$[rbp-177], ebx
	mov	QWORD PTR tv3411[rbp-177], rax
	mov	eax, ebx
	lea	rbx, OFFSET FLAT:ZSTD_HcFindBestMatch_selectMLS
	mov	DWORD PTR offset_1$1$[rbp-177], r12d
	cmove	rbx, rsi
	mov	rsi, QWORD PTR iend$1$[rbp-177]
	mov	QWORD PTR searchMax$1$[rbp-177], rbx
$LN500@ZSTD_compr:

; 661  :                                      prefixLowestIndex - (U32)(dictEnd - dictBase) :
; 662  :                                      0;
; 663  :     const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
; 664  : 
; 665  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u)", (U32)dictMode);
; 666  : 
; 667  :     /* init */
; 668  :     ip += (dictAndPrefixLength == 0);

	sub	eax, r8d
	mov	ebx, r9d
	sub	eax, edi
	mov	DWORD PTR offset_2$1$[rsp], ebx
	add	eax, r14d
	mov	eax, 0
	sete	al
	lea	rdi, QWORD PTR [rax+r14]
	xor	eax, eax
	mov	DWORD PTR savedOffset$1$[rbp-177], eax

; 669  :     if (dictMode == ZSTD_noDict) {

	test	ecx, ecx
	jne	SHORT $LN16@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r13+184]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 670  :         U32 const current = (U32)(ip - base);

	mov	r8d, edi
	sub	r8d, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	edx, 1
	shl	edx, cl

; 992  :     U32    const lowestValid = ms->window.dictLimit;
; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, r10d

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, r8d
	sub	ecx, edx
	cmp	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	mov	rdx, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, r10d
	cmp	DWORD PTR [r13+32], 0
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	mov	r13d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 672  :         U32 const maxRep = current - windowLow;

	sub	r8d, ecx

; 674  :         if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;

	mov	ecx, 0
	cmp	ebx, r8d
	mov	eax, ecx
	cmovbe	eax, r9d
	cmovbe	r13d, ecx
	mov	DWORD PTR savedOffset$1$[rbp-177], r13d
	mov	ebx, eax
	mov	DWORD PTR offset_2$1$[rsp], eax
	cmp	r12d, r8d
	jbe	SHORT $LN499@ZSTD_compr
	mov	DWORD PTR savedOffset$1$[rbp-177], r12d
	mov	r12d, ecx
	mov	DWORD PTR offset_1$1$[rbp-177], ecx
	mov	DWORD PTR offset_2$1$[rsp], eax
$LN499@ZSTD_compr:

; 690  :     while (ip < ilimit) {

	mov	ecx, DWORD PTR dictMode$[rbp-177]
$LN16@ZSTD_compr:
	cmp	rdi, r15
	jae	$LN3@ZSTD_compr
	xor	r15d, r15d
	npad	11
$LL2@ZSTD_compr:

; 691  :         size_t matchLength=0;
; 692  :         size_t offset=0;

	mov	QWORD PTR offset$1$[rbp-177], r15

; 693  :         const BYTE* start=ip+1;

	lea	rbx, QWORD PTR [rdi+1]
	mov	QWORD PTR start$1$[rbp-177], rbx
	mov	r13, r15

; 694  : 
; 695  :         /* check repCode */
; 696  :         if (dictMode == ZSTD_dictMatchState) {

	cmp	ecx, 2
	jne	$LN20@ZSTD_compr

; 697  :             const U32 repIndex = (U32)(ip - base) + 1 - offset_1;

	mov	ecx, edi
	sub	ecx, edx
	sub	ecx, r12d
	inc	ecx

; 698  :             const BYTE* repMatch = (dictMode == ZSTD_dictMatchState

	cmp	ecx, r10d
	jae	SHORT $LN58@ZSTD_compr
	mov	r11d, ecx
	sub	r11d, DWORD PTR dictIndexDelta$1$[rbp-177]
	add	r11, QWORD PTR dictBase$1$[rbp-177]
	jmp	SHORT $LN59@ZSTD_compr
$LN58@ZSTD_compr:
	mov	r11d, ecx
	add	r11, rdx
$LN59@ZSTD_compr:

; 699  :                                 && repIndex < prefixLowestIndex) ?
; 700  :                                    dictBase + (repIndex - dictIndexDelta) :
; 701  :                                    base + repIndex;
; 702  :             if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 703  :                 && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN22@ZSTD_compr
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [r11], eax
	jne	$LN22@ZSTD_compr

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, r10d

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r14, QWORD PTR [rdi+5]
	mov	rbx, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 704  :                 const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rbp-177]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rsi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 705  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rbx
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rbx
	jne	SHORT $LN77@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rbp-177]
	lea	rcx, QWORD PTR [rsi+r14]
	mov	rdx, QWORD PTR prefixLowest$1$[rbp-177]
	call	ZSTD_count
	add	rsi, rax
$LN77@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 706  :                 if (depth==0) goto _storeSequence;

	cmp	DWORD PTR depth$[rbp-177], 0
	lea	r13, QWORD PTR [rsi+4]
	mov	rsi, QWORD PTR iend$1$[rbp-177]
	mov	rbx, QWORD PTR start$1$[rbp-177]
	mov	r14, QWORD PTR src$[rbp-177]
	je	$LN503@ZSTD_compr

; 707  :             }
; 708  :         }
; 709  :         if ( dictMode == ZSTD_noDict
; 710  :           && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {

	jmp	$LN22@ZSTD_compr
$LN20@ZSTD_compr:
	test	ecx, ecx
	jne	$LN22@ZSTD_compr
	xor	r10d, r10d
	mov	eax, r12d
	mov	ecx, r10d
	mov	rdx, rdi
	sub	rdx, rax
	mov	eax, DWORD PTR [rbx]
	cmp	DWORD PTR [rdx+1], eax
	mov	eax, r10d
	sete	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN22@ZSTD_compr

; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;

	lea	rcx, QWORD PTR [rdi+5]
	add	rdx, 5
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
	mov	r9, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN84@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN86@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN101@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN82@ZSTD_compr
$LN101@ZSTD_compr:
	mov	eax, r10d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN82@ZSTD_compr
$LN86@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN84@ZSTD_compr
	npad	4
$LL83@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN87@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL83@ZSTD_compr
$LN84@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN88@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN88@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN88@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN89@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN89@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN89@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN90@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN90@ZSTD_compr
	inc	rcx
$LN90@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
$LN82@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 711  :             matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;

	lea	r13, QWORD PTR [rax+4]

; 712  :             if (depth==0) goto _storeSequence;

	cmp	DWORD PTR depth$[rbp-177], r10d
	je	$_storeSequence$507
$LN22@ZSTD_compr:

; 713  :         }
; 714  : 
; 715  :         /* first search (depth 0) */
; 716  :         {   size_t offsetFound = 999999999;
; 717  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rbp-177]
	lea	r9, QWORD PTR offsetFound$1[rbp-177]
	mov	r8, rsi
	mov	QWORD PTR offsetFound$1[rbp-177], 999999999 ; 3b9ac9ffH
	mov	rdx, rdi
	call	QWORD PTR searchMax$1$[rbp-177]

; 718  :             if (ml2 > matchLength)

	cmp	rax, r13
	jbe	SHORT $LN23@ZSTD_compr

; 719  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r15, QWORD PTR offsetFound$1[rbp-177]
	mov	rbx, rdi
	mov	QWORD PTR start$1$[rbp-177], rbx
	mov	r13, rax
	mov	QWORD PTR offset$1$[rbp-177], r15
$LN23@ZSTD_compr:

; 720  :         }
; 721  : 
; 722  :         if (matchLength < 4) {

	cmp	r13, 4
	jae	SHORT $LN24@ZSTD_compr

; 723  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */
; 724  :             continue;

	mov	r11, QWORD PTR seqStore$[rbp-177]
	lea	r13, QWORD PTR [rsi-8]
	mov	ebx, DWORD PTR offset_2$1$[rsp]
	mov	rax, rdi
	sub	rax, r14
	inc	rdi
	sar	rax, 8
	add	rdi, rax
	xor	r15d, r15d
	jmp	$LN501@ZSTD_compr
$LN87@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN117@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	SHORT $LN82@ZSTD_compr
$LN117@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r10d

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	$LN82@ZSTD_compr
$LN24@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 728  :         if (depth>=1)

	cmp	DWORD PTR depth$[rbp-177], 1
	jb	$LN38@ZSTD_compr

; 729  :         while (ip<ilimit) {

	lea	rax, QWORD PTR [rsi-8]
	cmp	rdi, rax
	jae	$LN38@ZSTD_compr
$LL4@ZSTD_compr:

; 730  :             ip ++;
; 731  :             if ( (dictMode == ZSTD_noDict)
; 732  :               && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	mov	eax, DWORD PTR dictMode$[rbp-177]
	inc	rdi
	test	eax, eax
	jne	$LN27@ZSTD_compr
	test	r15, r15
	je	$LN497@ZSTD_compr
	xor	r10d, r10d
	mov	eax, r12d
	mov	ecx, r10d
	mov	rdx, rdi
	sub	rdx, rax
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rdi], eax
	mov	eax, r10d
	sete	cl
	test	r12d, r12d
	setne	al
	test	ecx, eax
	je	$LN497@ZSTD_compr

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rax, QWORD PTR [rdi+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
	mov	r9, rax

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN127@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN129@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	je	SHORT $LN144@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN125@ZSTD_compr
$LN144@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, r10d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN125@ZSTD_compr
$LN129@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r8
	jae	SHORT $LN127@ZSTD_compr
	npad	2
$LL126@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN130@ZSTD_compr
	add	rax, 8
	add	rdx, 8
	cmp	rax, r8
	jb	SHORT $LL126@ZSTD_compr
$LN127@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [rsi-3]
	cmp	rax, rcx
	jae	SHORT $LN131@ZSTD_compr
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN131@ZSTD_compr
	add	rax, 4
	add	rdx, 4
$LN131@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [rsi-1]
	cmp	rax, rcx
	jae	SHORT $LN132@ZSTD_compr
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN132@ZSTD_compr
	add	rax, 2
	add	rdx, 2
$LN132@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, rsi
	jae	SHORT $LN133@ZSTD_compr
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN133@ZSTD_compr
	inc	rax
$LN133@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r9
$LN125@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 733  :                 size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rcx+4]

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 735  :                 int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r13*2]
	add	ecx, r13d
	sub	ecx, eax
	inc	ecx

; 736  :                 if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	$LN497@ZSTD_compr
	mov	r14d, DWORD PTR lowestValid$1$[rsp]
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	rbx, QWORD PTR base$1$[rsp]
	cmp	eax, ecx
	jle	$LN30@ZSTD_compr

; 737  :                     matchLength = mlRep, offset = 0, start = ip;

	mov	r13, rdx
	mov	QWORD PTR offset$1$[rbp-177], r10
	mov	QWORD PTR start$1$[rbp-177], rdi

; 739  :             if (dictMode == ZSTD_dictMatchState) {

	jmp	$LN30@ZSTD_compr
$LN130@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	je	SHORT $LN160@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	SHORT $LN125@ZSTD_compr
$LN160@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r10d

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r9
	add	rcx, rax
	jmp	SHORT $LN125@ZSTD_compr
$LN27@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 739  :             if (dictMode == ZSTD_dictMatchState) {

	mov	rbx, QWORD PTR base$1$[rsp]
	mov	r14d, DWORD PTR lowestValid$1$[rsp]
	cmp	eax, 2
	jne	$LN30@ZSTD_compr

; 740  :                 const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	ecx, edi
	sub	ecx, ebx
	sub	ecx, r12d

; 741  :                 const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, r14d
	jae	SHORT $LN60@ZSTD_compr
	mov	r11d, ecx
	sub	r11d, DWORD PTR dictIndexDelta$1$[rbp-177]
	add	r11, QWORD PTR dictBase$1$[rbp-177]
	jmp	SHORT $LN61@ZSTD_compr
$LN60@ZSTD_compr:
	mov	r11d, ecx
	add	r11, rbx
$LN61@ZSTD_compr:

; 742  :                                dictBase + (repIndex - dictIndexDelta) :
; 743  :                                base + repIndex;
; 744  :                 if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 745  :                     && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, r14d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN30@ZSTD_compr
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r11], eax
	jne	$LN30@ZSTD_compr

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, r14d
	mov	rbx, rsi

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r14, QWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rsi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 746  :                     const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rbp-177]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rbx
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rbx
	jne	SHORT $LN170@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rbp-177]
	lea	rcx, QWORD PTR [rsi+r14]
	mov	rdx, QWORD PTR prefixLowest$1$[rbp-177]
	call	ZSTD_count
	add	rsi, rax
$LN170@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	eax, DWORD PTR [r15+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 747  :                     size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	rdx, QWORD PTR [rsi+4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	mov	rsi, QWORD PTR iend$1$[rbp-177]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 749  :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r13*2]
	add	ecx, r13d
	sub	ecx, eax
	inc	ecx

; 750  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN497@ZSTD_compr
	mov	r14d, DWORD PTR lowestValid$1$[rsp]
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	rbx, QWORD PTR base$1$[rsp]
	cmp	eax, ecx
	jle	SHORT $LN30@ZSTD_compr

; 751  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	r13, rdx
	mov	QWORD PTR offset$1$[rbp-177], r8
	mov	QWORD PTR start$1$[rbp-177], rdi
	jmp	SHORT $LN30@ZSTD_compr
$LN497@ZSTD_compr:

; 752  :                 }
; 753  :             }
; 754  :             {   size_t offset2=999999999;

	mov	rbx, QWORD PTR base$1$[rsp]
	mov	r14d, DWORD PTR lowestValid$1$[rsp]
$LN30@ZSTD_compr:

; 755  :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rbp-177]
	lea	r9, QWORD PTR offset2$2[rbp-177]
	mov	r8, rsi
	mov	QWORD PTR offset2$2[rbp-177], 999999999	; 3b9ac9ffH
	mov	rdx, rdi
	call	QWORD PTR searchMax$1$[rbp-177]

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$2[rbp-177]

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r15d, DWORD PTR [r13*4]
	mov	r10, QWORD PTR offset$1$[rbp-177]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r11d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r12d, DWORD PTR [r10+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, r11d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 756  :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, r12d
	cmovne	ecx, eax
	mov	eax, r15d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 757  :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	eax, 4

; 758  :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN31@ZSTD_compr
	cmp	edx, eax
	jg	$LN502@ZSTD_compr
$LN31@ZSTD_compr:

; 759  :                     matchLength = ml2, offset = offset2, start = ip;
; 760  :                     continue;   /* search a better one */
; 761  :             }   }
; 762  : 
; 763  :             /* let's find an even better one */
; 764  :             if ((depth==2) && (ip<ilimit)) {

	cmp	DWORD PTR depth$[rbp-177], 2
	jne	$LN479@ZSTD_compr
	lea	rax, QWORD PTR [rsi-8]
	cmp	rdi, rax
	jae	$LN479@ZSTD_compr

; 765  :                 ip ++;
; 766  :                 if ( (dictMode == ZSTD_noDict)
; 767  :                   && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {

	mov	eax, DWORD PTR dictMode$[rbp-177]
	inc	rdi
	test	eax, eax
	jne	$LN34@ZSTD_compr
	test	r10, r10
	je	$LN37@ZSTD_compr
	mov	r8d, DWORD PTR offset_1$1$[rbp-177]
	mov	ecx, r11d
	mov	rdx, rdi
	sub	rdx, r8
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rdi], eax
	mov	eax, r11d
	sete	cl
	test	r8d, r8d
	setne	al
	test	ecx, eax
	je	$LN37@ZSTD_compr

; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rcx, QWORD PTR [rdi+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
	mov	r9, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN183@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN185@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN200@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN181@ZSTD_compr
$LN200@ZSTD_compr:
	mov	eax, r11d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN181@ZSTD_compr
$LN185@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN183@ZSTD_compr
	npad	8
$LL182@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN186@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL182@ZSTD_compr
$LN183@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN187@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN187@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN187@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN188@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN188@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN188@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN189@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN189@ZSTD_compr
	inc	rcx
$LN189@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
$LN181@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 768  :                     size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;

	lea	rdx, QWORD PTR [rax+4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r11d
	bsr	eax, r12d
	cmovne	ecx, eax
	sub	r15d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 770  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r15d

; 771  :                     if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	$LN37@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r15d
	jle	$LN37@ZSTD_compr

; 772  :                         matchLength = mlRep, offset = 0, start = ip;

	mov	QWORD PTR offset$1$[rbp-177], r11

; 774  :                 if (dictMode == ZSTD_dictMatchState) {

	jmp	$LN505@ZSTD_compr
$LN186@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN216@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	SHORT $LN181@ZSTD_compr
$LN216@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r11d

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	SHORT $LN181@ZSTD_compr
$LN34@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 774  :                 if (dictMode == ZSTD_dictMatchState) {

	cmp	eax, 2
	jne	$LN37@ZSTD_compr

; 775  :                     const U32 repIndex = (U32)(ip - base) - offset_1;

	mov	ecx, edi
	sub	ecx, ebx
	sub	ecx, DWORD PTR offset_1$1$[rbp-177]

; 776  :                     const BYTE* repMatch = repIndex < prefixLowestIndex ?

	cmp	ecx, r14d
	jae	SHORT $LN62@ZSTD_compr
	mov	r11d, ecx
	sub	r11d, DWORD PTR dictIndexDelta$1$[rbp-177]
	add	r11, QWORD PTR dictBase$1$[rbp-177]
	jmp	SHORT $LN63@ZSTD_compr
$LN62@ZSTD_compr:
	mov	r11d, ecx
	add	r11, rbx
$LN63@ZSTD_compr:

; 777  :                                    dictBase + (repIndex - dictIndexDelta) :
; 778  :                                    base + repIndex;
; 779  :                     if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
; 780  :                         && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, r14d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN37@ZSTD_compr
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r11], eax
	jne	$LN37@ZSTD_compr

; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, r14d
	mov	rbx, rsi

; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	r14, QWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rsi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 781  :                         const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rbp-177]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rbx
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rbx
	jne	SHORT $LN226@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rbp-177]
	lea	rcx, QWORD PTR [rsi+r14]
	mov	rdx, QWORD PTR prefixLowest$1$[rbp-177]
	call	ZSTD_count
	add	rsi, rax
$LN226@ZSTD_compr:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 782  :                         size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;

	lea	rdx, QWORD PTR [rsi+4]

; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))

	mov	rsi, QWORD PTR iend$1$[rbp-177]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	mov	ecx, r8d
	bsr	eax, r12d
	cmovne	ecx, eax
	sub	r15d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 784  :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r15d

; 785  :                         if ((mlRep >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN37@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r15d
	jle	SHORT $LN37@ZSTD_compr

; 786  :                             matchLength = mlRep, offset = 0, start = ip;

	mov	QWORD PTR offset$1$[rbp-177], r8
$LN505@ZSTD_compr:

; 787  :                     }
; 788  :                 }
; 789  :                 {   size_t offset2=999999999;

	mov	QWORD PTR start$1$[rbp-177], rdi
	mov	r13, rdx
$LN37@ZSTD_compr:

; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rbp-177]
	lea	r9, QWORD PTR offset2$3[rbp-177]
	mov	r8, rsi
	mov	QWORD PTR offset2$3[rbp-177], 999999999	; 3b9ac9ffH
	mov	rdx, rdi
	call	QWORD PTR searchMax$1$[rbp-177]

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$3[rbp-177]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 790  :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	r8, rax

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 791  :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	mov	rax, QWORD PTR offset$1$[rbp-177]
	inc	eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 792  :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [r13*4]
	sub	ecx, eax
	add	ecx, 7

; 793  :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN479@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN479@ZSTD_compr
$LN502@ZSTD_compr:

; 729  :         while (ip<ilimit) {

	mov	r12d, DWORD PTR offset_1$1$[rbp-177]
	lea	rax, QWORD PTR [rsi-8]
	mov	QWORD PTR start$1$[rbp-177], rdi
	mov	r15, r9
	mov	QWORD PTR offset$1$[rbp-177], r9
	mov	r13, r8
	cmp	rdi, rax
	jb	$LL4@ZSTD_compr
$LN479@ZSTD_compr:
	mov	rbx, QWORD PTR start$1$[rbp-177]
	mov	r15, QWORD PTR offset$1$[rbp-177]
	mov	r12d, DWORD PTR offset_1$1$[rbp-177]
$LN38@ZSTD_compr:

; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	test	r15, r15
	je	$LN487@ZSTD_compr

; 807  :             if (dictMode == ZSTD_noDict) {

	mov	eax, DWORD PTR dictMode$[rbp-177]
	test	eax, eax
	jne	SHORT $LN7@ZSTD_compr

; 808  :                 while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))
; 809  :                      && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )  /* only search for offset within prefix */

	mov	r8, QWORD PTR prefixLowest$1$[rbp-177]
	xor	r9d, r9d
	mov	r14, QWORD PTR src$[rbp-177]
	mov	ecx, r9d
	mov	eax, r9d
	mov	rdx, rbx
	sub	rdx, r15
	add	rdx, 2
	cmp	rdx, r8
	seta	cl
	cmp	rbx, r14
	seta	al
	test	ecx, eax
	je	$LN9@ZSTD_compr
	npad	3
$LL6@ZSTD_compr:
	movzx	eax, BYTE PTR [rdx-1]
	cmp	BYTE PTR [r15+rdx-3], al
	jne	$LN9@ZSTD_compr

; 810  :                     { start--; matchLength++; }

	dec	rbx
	dec	rdx
	inc	r13
	mov	ecx, r9d
	cmp	rdx, r8
	mov	eax, r9d
	seta	cl
	cmp	rbx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL6@ZSTD_compr

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	lea	eax, DWORD PTR [r15-2]
	mov	DWORD PTR offset_2$1$[rsp], r12d
	mov	DWORD PTR offset_1$1$[rbp-177], eax
	jmp	$LN503@ZSTD_compr
$LN7@ZSTD_compr:

; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {

	cmp	eax, 2
	jne	SHORT $LN488@ZSTD_compr

; 813  :                 U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	rax, QWORD PTR base$1$[rsp]
	mov	edx, ebx

; 814  :                 const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;

	mov	r9d, DWORD PTR lowestValid$1$[rsp]
	sub	edx, r15d
	sub	edx, eax
	add	edx, 2
	mov	ecx, edx
	cmp	edx, r9d
	jae	SHORT $LN64@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rbp-177]
	sub	rcx, rax
	add	rcx, QWORD PTR dictBase$1$[rbp-177]
	jmp	SHORT $LN65@ZSTD_compr
$LN64@ZSTD_compr:
	add	rcx, rax
$LN65@ZSTD_compr:

; 815  :                 const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;

	mov	r8, QWORD PTR prefixLowest$1$[rbp-177]
	cmp	edx, r9d

; 816  :                 while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	mov	r14, QWORD PTR src$[rbp-177]
	cmovb	r8, QWORD PTR dictLowest$1$[rbp-177]
	cmp	rbx, r14
	jbe	SHORT $LN9@ZSTD_compr
$LL8@ZSTD_compr:
	cmp	rcx, r8
	jbe	SHORT $LN9@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [rbx-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN9@ZSTD_compr
	dec	rcx
	inc	r13
	mov	rbx, rdx
	cmp	rdx, r14
	ja	SHORT $LL8@ZSTD_compr

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	lea	eax, DWORD PTR [r15-2]
	mov	DWORD PTR offset_2$1$[rsp], r12d
	mov	DWORD PTR offset_1$1$[rbp-177], eax
	jmp	SHORT $LN503@ZSTD_compr
$LN488@ZSTD_compr:

; 811  :             }
; 812  :             if (dictMode == ZSTD_dictMatchState) {

	mov	r14, QWORD PTR src$[rbp-177]
$LN9@ZSTD_compr:

; 817  :             }
; 818  :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	lea	eax, DWORD PTR [r15-2]
	mov	DWORD PTR offset_2$1$[rsp], r12d
	mov	DWORD PTR offset_1$1$[rbp-177], eax
	jmp	SHORT $LN503@ZSTD_compr
$LN487@ZSTD_compr:

; 794  :                         matchLength = ml2, offset = offset2, start = ip;
; 795  :                         continue;
; 796  :             }   }   }
; 797  :             break;  /* nothing found : store previous solution */
; 798  :         }
; 799  : 
; 800  :         /* NOTE:
; 801  :          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.
; 802  :          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which
; 803  :          * overflows the pointer, which is undefined behavior.
; 804  :          */
; 805  :         /* catch up */
; 806  :         if (offset) {

	mov	r14, QWORD PTR src$[rbp-177]
$LN503@ZSTD_compr:

; 822  :         {   size_t const litLength = start - anchor;

	mov	r11, QWORD PTR seqStore$[rbp-177]
$_storeSequence$507:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r11+24]
	lea	r12, QWORD PTR [rsi-32]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 822  :         {   size_t const litLength = start - anchor;

	mov	r9, rbx

; 823  :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	r10, QWORD PTR [r13-3]
	sub	r9, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rdx, QWORD PTR [r9+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdx, r12
	ja	SHORT $LN238@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r9, 16
	jbe	SHORT $LN260@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r11+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [r9-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	lea	rcx, QWORD PTR [r14+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rdx, rax
	npad	11
$LL252@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rdx
	jb	SHORT $LL252@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN260@ZSTD_compr
$LN238@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	r14, r12
	ja	SHORT $LN410@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r8, rcx
	sub	r8, r14
	add	r8, r12
	sub	r14, rcx
	npad	10
$LL269@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r8
	jb	SHORT $LL269@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r8
	mov	r14, r12
$LN410@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r14, rdx
	jae	SHORT $LN260@ZSTD_compr
	sub	rcx, r14
	npad	1
$LL430@ZSTD_compr:
	movzx	eax, BYTE PTR [r14]
	mov	BYTE PTR [rcx+r14], al
	inc	r14
	cmp	r14, rdx
	jb	SHORT $LL430@ZSTD_compr
$LN260@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r11+24], r9
	mov	rcx, QWORD PTR [r11+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r9, 65535				; 0000ffffH
	jbe	SHORT $LN453@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r11+72], 1
	sub	rax, QWORD PTR [r11]
	sar	rax, 3
	mov	DWORD PTR [r11+76], eax
$LN453@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r9w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r15+1]
	mov	rax, QWORD PTR [r11+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r11+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r10, 65535				; 0000ffffH
	jbe	SHORT $LN454@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r11+72], 2
	sub	rax, QWORD PTR [r11]
	sar	rax, 3
	mov	DWORD PTR [r11+76], eax
$LN454@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 824  :             anchor = ip = start + matchLength;

	lea	rdi, QWORD PTR [rbx+r13]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r10w

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r11+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 828  :         if (dictMode == ZSTD_dictMatchState) {

	lea	r13, QWORD PTR [rsi-8]
	mov	ecx, DWORD PTR dictMode$[rbp-177]
	mov	r14, rdi
	mov	ebx, DWORD PTR offset_2$1$[rsp]
	mov	QWORD PTR src$[rbp-177], rdi
	cmp	ecx, 2
	jne	$LN43@ZSTD_compr

; 829  :             while (ip <= ilimit) {

	mov	QWORD PTR src$[rbp-177], rdi
	cmp	rdi, r13
	ja	$LN491@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rbp-177], rdi
	npad	10
$LL10@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 831  :                 U32 const repIndex = current2 - offset_2;

	mov	rdx, QWORD PTR base$1$[rsp]
	mov	ecx, edi

; 832  :                 const BYTE* repMatch = dictMode == ZSTD_dictMatchState

	mov	r10d, DWORD PTR lowestValid$1$[rsp]
	sub	ecx, edx
	sub	ecx, ebx
	mov	r15d, ebx
	mov	r11d, ecx
	cmp	ecx, r10d
	jae	SHORT $LN66@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rbp-177]
	sub	r11, rax
	add	r11, QWORD PTR dictBase$1$[rbp-177]
	jmp	SHORT $LN67@ZSTD_compr
$LN66@ZSTD_compr:
	add	r11, rdx
$LN67@ZSTD_compr:

; 833  :                     && repIndex < prefixLowestIndex ?
; 834  :                         dictBase - dictIndexDelta + repIndex :
; 835  :                         base + repIndex;
; 836  :                 if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
; 837  :                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN489@ZSTD_compr
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r11], eax
	jne	$LN489@ZSTD_compr

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmp	ecx, r10d

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	lea	r14, QWORD PTR [rdi+4]
	mov	rbx, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 838  :                     const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rbp-177]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rsi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 839  :                     matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rbx
	cmp	rcx, rsi
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	rsi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rbx
	jne	SHORT $LN275@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rbp-177]
	lea	rcx, QWORD PTR [rsi+r14]
	mov	rdx, QWORD PTR prefixLowest$1$[rbp-177]
	call	ZSTD_count
	add	rsi, rax
$LN275@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	ebx, DWORD PTR offset_1$1$[rbp-177]
	add	rsi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	r11, QWORD PTR seqStore$[rbp-177]

; 456  :     if (litEnd <= litLimit_w) {

	mov	rcx, QWORD PTR src$[rbp-177]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 840  :                     offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], ebx
	mov	DWORD PTR offset_1$1$[rbp-177], r15d

; 841  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [rsi-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [r11+24]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rcx, r12
	ja	SHORT $LL312@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rax], xmm0
	npad	1
$LL312@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [r11+8]
	xor	r15d, r15d
	mov	WORD PTR [rax+4], r15w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [r11+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [r11+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN455@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r11+72], 2
	sub	rax, QWORD PTR [r11]
	sar	rax, 3
	mov	DWORD PTR [r11+76], eax
$LN455@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 842  :                     ip += matchLength;

	add	rdi, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r11+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 842  :                     ip += matchLength;

	mov	r14, rdi
	mov	rsi, QWORD PTR iend$1$[rbp-177]
	mov	QWORD PTR src$[rbp-177], rdi
	cmp	rdi, r13
	jbe	$LL10@ZSTD_compr
$LN493@ZSTD_compr:

; 690  :     while (ip < ilimit) {

	mov	r12d, DWORD PTR offset_1$1$[rbp-177]
$LN501@ZSTD_compr:
	mov	rdx, QWORD PTR base$1$[rsp]
	mov	r10d, DWORD PTR lowestValid$1$[rsp]
$LN504@ZSTD_compr:
	mov	ecx, DWORD PTR dictMode$[rbp-177]
$LN13@ZSTD_compr:
	cmp	rdi, r13
	jb	$LL2@ZSTD_compr
$LN3@ZSTD_compr:

; 859  :                 continue;   /* faster when present ... (?) */
; 860  :     }   }   }
; 861  : 
; 862  :     /* Save reps for next block */
; 863  :     rep[0] = offset_1 ? offset_1 : savedOffset;

	mov	eax, DWORD PTR savedOffset$1$[rbp-177]
	test	r12d, r12d
	mov	rdx, QWORD PTR rep$[rbp-177]
	mov	ecx, eax
	cmovne	ecx, r12d

; 864  :     rep[1] = offset_2 ? offset_2 : savedOffset;

	test	ebx, ebx
	cmovne	eax, ebx

; 865  : 
; 866  :     /* Return the last literals size */
; 867  :     return (size_t)(iend - anchor);

	sub	rsi, r14
	mov	DWORD PTR [rdx], ecx
	mov	rcx, QWORD PTR tv3411[rbp-177]
	mov	DWORD PTR [rcx], eax
	mov	rax, rsi

; 868  : }

	add	rsp, 184				; 000000b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN43@ZSTD_compr:

; 843  :                     anchor = ip;
; 844  :                     continue;
; 845  :                 }
; 846  :                 break;
; 847  :             }
; 848  :         }
; 849  : 
; 850  :         if (dictMode == ZSTD_noDict) {

	xor	r15d, r15d
	test	ecx, ecx
	jne	$LN492@ZSTD_compr

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	cmp	rdi, r13
	mov	ecx, r15d
	mov	eax, r15d
	setbe	cl
	test	ebx, ebx
	setne	al
	test	ecx, eax
	je	SHORT $LN493@ZSTD_compr
	npad	3
$LL12@ZSTD_compr:
	mov	eax, ebx
	mov	rdx, rdi
	sub	rdx, rax
	mov	r10d, ebx
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rdi], eax
	jne	$LN481@ZSTD_compr

; 853  :                 /* store sequence */
; 854  :                 matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;

	lea	rcx, QWORD PTR [rdi+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r8, QWORD PTR [rsi-7]
	mov	r9, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN320@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN322@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$5[rbp-177], r15d
	je	SHORT $LN337@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN318@ZSTD_compr
$LN337@ZSTD_compr:
	mov	eax, r15d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN318@ZSTD_compr
$LN322@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r8
	jae	SHORT $LN320@ZSTD_compr
$LL319@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN323@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r8
	jb	SHORT $LL319@ZSTD_compr
$LN320@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [rsi-3]
	cmp	rcx, rax
	jae	SHORT $LN324@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN324@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN324@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [rsi-1]
	cmp	rcx, rax
	jae	SHORT $LN325@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN325@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN325@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, rsi
	jae	SHORT $LN326@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN326@ZSTD_compr
	inc	rcx
$LN326@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r9
$LN318@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 855  :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset; /* swap repcodes */

	mov	ebx, DWORD PTR offset_1$1$[rbp-177]
	lea	r8, QWORD PTR [rax+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [r11+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 856  :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [r8-3]
	mov	DWORD PTR offset_1$1$[rbp-177], r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LL393@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rax], xmm0
	npad	1
$LL393@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [r11+8]
	mov	WORD PTR [rax+4], r15w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [r11+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [r11+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN456@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r11+72], 2
	sub	rax, QWORD PTR [r11]
	sar	rax, 3
	mov	DWORD PTR [r11+76], eax
$LN456@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 857  :                 ip += matchLength;

	lea	r14, QWORD PTR [r8+rdi]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r11+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 852  :                  && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {

	mov	ecx, r15d

; 858  :                 anchor = ip;

	cmp	r14, r13
	mov	eax, r15d
	mov	rdi, r14
	setbe	cl
	test	ebx, ebx
	setne	al
	test	ecx, eax
	jne	$LL12@ZSTD_compr
$LN481@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], ebx
	mov	QWORD PTR src$[rbp-177], r14

; 833  :                     && repIndex < prefixLowestIndex ?
; 834  :                         dictBase - dictIndexDelta + repIndex :
; 835  :                         base + repIndex;
; 836  :                 if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
; 837  :                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {

	jmp	$LN493@ZSTD_compr
$LN323@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$4[rbp-177], r15d
	je	SHORT $LN353@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	$LN318@ZSTD_compr
$LN353@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r15d

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r9
	add	rax, rcx
	jmp	$LN318@ZSTD_compr
$LN489@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 690  :     while (ip < ilimit) {

	mov	r11, QWORD PTR seqStore$[rbp-177]
	xor	r15d, r15d
	mov	r12d, DWORD PTR offset_1$1$[rbp-177]
	jmp	$LN504@ZSTD_compr
$LN491@ZSTD_compr:

; 829  :             while (ip <= ilimit) {

	mov	r12d, DWORD PTR offset_1$1$[rbp-177]
	xor	r15d, r15d
	mov	r10d, DWORD PTR lowestValid$1$[rsp]
	mov	rdx, QWORD PTR base$1$[rsp]
	jmp	$LN13@ZSTD_compr
$LN492@ZSTD_compr:

; 843  :                     anchor = ip;
; 844  :                     continue;
; 845  :                 }
; 846  :                 break;
; 847  :             }
; 848  :         }
; 849  : 
; 850  :         if (dictMode == ZSTD_noDict) {

	mov	r12d, DWORD PTR offset_1$1$[rbp-177]
	mov	r10d, DWORD PTR lowestValid$1$[rsp]
	mov	rdx, QWORD PTR base$1$[rsp]
	jmp	$LN13@ZSTD_compr
ZSTD_compressBlock_lazy_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c
_TEXT	SEGMENT
tv2210 = 32
tv2477 = 36
offset_2$1$ = 40
litLimit_w$1$ = 48
start$1$ = 48
dictLimit$1$ = 56
iend$1$ = 64
base$1$ = 72
tv2225 = 80
r$1 = 80
dictBase$1$ = 88
prefixStart$1$ = 96
dictEnd$1$ = 104
r$2 = 112
offset2$3 = 112
searchMax$1$ = 120
offsetFound$4 = 128
offset2$5 = 136
ilimit$1$ = 144
dictStart$1$ = 152
ms$ = 240
seqStore$ = 248
rep$ = 256
src$ = 264
offset_1$1$ = 272
srcSize$ = 272
current$1$ = 280
r$6 = 280
r$7 = 280
r$8 = 280
r$9 = 280
searchMethod$ = 280
depth$ = 288
ZSTD_compressBlock_lazy_extDict_generic PROC

; 934  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H

; 935  :     const BYTE* const istart = (const BYTE*)src;
; 936  :     const BYTE* ip = istart;
; 937  :     const BYTE* anchor = istart;
; 938  :     const BYTE* const iend = istart + srcSize;

	mov	r12, QWORD PTR srcSize$[rsp]
	mov	rsi, r9
	add	r12, r9
	mov	rdi, r8
	mov	rbp, rdx
	mov	QWORD PTR iend$1$[rsp], r12
	mov	rdx, rcx

; 939  :     const BYTE* const ilimit = iend - 8;
; 940  :     const BYTE* const base = ms->window.base;
; 941  :     const U32 dictLimit = ms->window.dictLimit;
; 942  :     const BYTE* const prefixStart = base + dictLimit;
; 943  :     const BYTE* const dictBase = ms->window.dictBase;
; 944  :     const BYTE* const dictEnd  = dictBase + dictLimit;
; 945  :     const BYTE* const dictStart  = dictBase + ms->window.lowLimit;
; 946  :     const U32 windowLog = ms->cParams.windowLog;
; 947  : 
; 948  :     typedef size_t (*searchMax_f)(
; 949  :                         ZSTD_matchState_t* ms,
; 950  :                         const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);
; 951  :     searchMax_f searchMax = searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_extDict_selectMLS : ZSTD_HcFindBestMatch_extDict_selectMLS;
; 952  : 
; 953  :     U32 offset_1 = rep[0], offset_2 = rep[1];

	mov	r15d, DWORD PTR [rdi+4]
	lea	rcx, QWORD PTR [r12-8]
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	r11, QWORD PTR [rdx+16]
	mov	r10d, DWORD PTR [rdx+24]
	mov	r9, QWORD PTR [rdx+8]
	mov	QWORD PTR dictBase$1$[rsp], r11
	mov	QWORD PTR base$1$[rsp], r9
	lea	rax, QWORD PTR [r11+r10]
	mov	DWORD PTR dictLimit$1$[rsp], r10d
	mov	QWORD PTR dictEnd$1$[rsp], rax
	lea	r8, QWORD PTR [r10+r9]
	mov	eax, DWORD PTR [rdx+28]
	add	rax, r11
	mov	QWORD PTR prefixStart$1$[rsp], r8
	cmp	DWORD PTR searchMethod$[rsp], 1
	lea	r11, OFFSET FLAT:ZSTD_BtFindBestMatch_extDict_selectMLS
	mov	QWORD PTR dictStart$1$[rsp], rax
	lea	rax, OFFSET FLAT:ZSTD_HcFindBestMatch_extDict_selectMLS
	cmove	rax, r11
	mov	DWORD PTR offset_2$1$[rsp], r15d
	mov	r11d, DWORD PTR [rdi]

; 954  : 
; 955  :     DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic");
; 956  : 
; 957  :     /* init */
; 958  :     ip += (ip == prefixStart);

	xor	r14d, r14d
	cmp	rsi, r8
	mov	QWORD PTR searchMax$1$[rsp], rax
	mov	eax, r14d
	mov	DWORD PTR offset_1$1$[rsp], r11d
	sete	al
	lea	rbx, QWORD PTR [rax+rsi]
	cmp	rbx, rcx

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	jae	$LN3@ZSTD_compr
	mov	ecx, DWORD PTR [rdx+184]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR tv2477[rsp], eax
	mov	QWORD PTR [rsp+168], r13
	npad	2
$LL2@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 970  :         const BYTE* start=ip+1;

	lea	rdi, QWORD PTR [rbx+1]
	mov	r15, r14
	mov	QWORD PTR start$1$[rsp], rdi
	mov	r13, r14

; 971  :         U32 current = (U32)(ip-base);

	mov	r14d, ebx
	sub	r14d, r9d

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	mov	r9d, r14d
	mov	DWORD PTR current$1$[rsp], r14d
	sub	r9d, r11d

; 976  :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r11, QWORD PTR base$1$[rsp]
	inc	r9d
	cmp	r9d, r10d

; 977  :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	lea	r8d, DWORD PTR [r14+1]
	cmovb	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	sub	r8d, DWORD PTR tv2477[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 975  :             const U32 repIndex = (U32)(current+1 - offset_1);

	cmp	eax, DWORD PTR tv2477[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 978  :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))   /* intentional overflow */

	xor	eax, eax
	cmp	r9d, r8d
	mov	edx, eax
	mov	ecx, r10d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	SHORT $LN12@ZSTD_compr

; 979  :             if (MEM_read32(ip+1) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [r11]
	cmp	DWORD PTR [rdi], eax
	jne	SHORT $LN12@ZSTD_compr

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r10d

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r14, QWORD PTR [rbx+5]
	mov	rdi, r12
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 981  :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rdi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rdi
	cmp	rcx, r12
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count
	mov	r15, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rdi
	jne	SHORT $LN40@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+r14]
	mov	r8, r12
	call	ZSTD_count
	add	r15, rax
$LN40@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 982  :                 matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r15, 4

; 983  :                 if (depth==0) goto _storeSequence;

	cmp	DWORD PTR depth$[rsp], 0
	je	$_storeSequence$214
	mov	rdi, QWORD PTR start$1$[rsp]
	mov	r14d, DWORD PTR current$1$[rsp]
$LN12@ZSTD_compr:

; 984  :         }   }
; 985  : 
; 986  :         /* first search (depth 0) */
; 987  :         {   size_t offsetFound = 999999999;
; 988  :             size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offsetFound$4[rsp]
	mov	r8, r12
	mov	QWORD PTR offsetFound$4[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	QWORD PTR searchMax$1$[rsp]

; 989  :             if (ml2 > matchLength)

	cmp	rax, r15
	jbe	SHORT $LN13@ZSTD_compr

; 990  :                 matchLength = ml2, start = ip, offset=offsetFound;

	mov	r13, QWORD PTR offsetFound$4[rsp]
	mov	r15, rax
	mov	rdi, rbx
	mov	QWORD PTR start$1$[rsp], rbx
$LN13@ZSTD_compr:

; 991  :         }
; 992  : 
; 993  :          if (matchLength < 4) {

	cmp	r15, 4
	jae	SHORT $LN14@ZSTD_compr

; 994  :             ip += ((ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */

	mov	rax, rbx

; 995  :             continue;

	lea	rdi, QWORD PTR [r12-8]
	sub	rax, rsi
	inc	rbx
	sar	rax, 8
	add	rbx, rax
	jmp	$LN211@ZSTD_compr
$LN14@ZSTD_compr:

; 996  :         }
; 997  : 
; 998  :         /* let's try to find a better solution */
; 999  :         if (depth>=1)

	cmp	DWORD PTR depth$[rsp], 1
	jb	$LN26@ZSTD_compr

; 1000 :         while (ip<ilimit) {

	cmp	rbx, QWORD PTR ilimit$1$[rsp]
	jae	$LN26@ZSTD_compr
	mov	r10d, DWORD PTR tv2477[rsp]
	mov	edi, r14d
	mov	rbp, QWORD PTR iend$1$[rsp]
	sub	edi, r10d
	mov	esi, DWORD PTR dictLimit$1$[rsp]
	jmp	SHORT $LN4@ZSTD_compr
	npad	2
$LL210@ZSTD_compr:
	mov	r10d, DWORD PTR tv2477[rsp]
$LN4@ZSTD_compr:

; 1001 :             ip ++;
; 1002 :             current++;

	inc	r14d
	inc	edi
	inc	rbx
	mov	DWORD PTR current$1$[rsp], r14d
	mov	DWORD PTR tv2210[rsp], edi

; 1003 :             /* check repCode */
; 1004 :             if (offset) {

	test	r13, r13
	je	$LN19@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r9, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1006 :                 const U32 repIndex = (U32)(current - offset_1);

	mov	r8d, r14d
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, edi

; 1007 :                 const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r11, QWORD PTR base$1$[rsp]
	cmp	r8d, esi

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
	cmovb	r11, QWORD PTR dictBase$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r9+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1008 :                 const BYTE* const repMatch = repBase + repIndex;

	add	r11, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r14d
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1006 :                 const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, r10d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r9+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1009 :                 if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r8d, ecx
	mov	edx, eax
	mov	ecx, esi
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN19@ZSTD_compr

; 1010 :                 if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [r11]
	cmp	DWORD PTR [rbx], eax
	jne	$LN19@ZSTD_compr

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, esi

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [rbx+4]
	mov	rdi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1012 :                     const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rdi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rdi
	cmp	rcx, rbp
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rdi
	jne	SHORT $LN49@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r14+r12]
	mov	r8, rbp
	call	ZSTD_count
	add	r14, rax
$LN49@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	edi, DWORD PTR tv2210[rsp]
	lea	eax, DWORD PTR [r13+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1013 :                     size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	rdx, QWORD PTR [r14+4]

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	mov	r14d, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r8d
	mov	DWORD PTR r$1[rsp], r8d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1015 :                     int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);

	lea	ecx, DWORD PTR [r15+r15*2]
	sub	ecx, eax
	inc	ecx

; 1016 :                     if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN19@ZSTD_compr
	lea	eax, DWORD PTR [rdx+rdx*2]
	cmp	eax, ecx
	jle	SHORT $LN19@ZSTD_compr

; 1017 :                         matchLength = repLength, offset = 0, start = ip;

	mov	r15, rdx
	mov	QWORD PTR start$1$[rsp], rbx
	mov	r13d, r8d
$LN19@ZSTD_compr:

; 1018 :             }   }
; 1019 : 
; 1020 :             /* search match, depth 1 */
; 1021 :             {   size_t offset2=999999999;
; 1022 :                 size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$5[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$5[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	QWORD PTR searchMax$1$[rsp]

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$5[rsp]

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	r12d, DWORD PTR [r15*4]
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
	mov	DWORD PTR r$9[rsp], r10d
	mov	DWORD PTR r$8[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
	mov	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1023 :                 int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR tv2225[rsp], eax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, eax
	cmovne	ecx, eax
	mov	eax, r12d
	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1024 :                 int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);

	add	eax, 4

; 1025 :                 if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN20@ZSTD_compr
	cmp	edx, eax
	jg	$LN212@ZSTD_compr
$LN20@ZSTD_compr:

; 1026 :                     matchLength = ml2, offset = offset2, start = ip;
; 1027 :                     continue;   /* search a better one */
; 1028 :             }   }
; 1029 : 
; 1030 :             /* let's find an even better one */
; 1031 :             if ((depth==2) && (ip<ilimit)) {

	cmp	DWORD PTR depth$[rsp], 2
	jne	$LN201@ZSTD_compr
	lea	rax, QWORD PTR [rbp-8]
	cmp	rbx, rax
	jae	$LN201@ZSTD_compr

; 1032 :                 ip ++;
; 1033 :                 current++;

	inc	r14d
	inc	edi
	inc	rbx
	mov	DWORD PTR current$1$[rsp], r14d
	mov	DWORD PTR tv2210[rsp], edi

; 1034 :                 /* check repCode */
; 1035 :                 if (offset) {

	test	r13, r13
	je	$LN25@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r9, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1037 :                     const U32 repIndex = (U32)(current - offset_1);

	mov	r8d, r14d
	sub	r8d, DWORD PTR offset_1$1$[rsp]
	mov	ecx, edi

; 1038 :                     const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r11, QWORD PTR base$1$[rsp]
	cmp	r8d, esi

; 1039 :                     const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
	cmovb	r11, QWORD PTR dictBase$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	edx, DWORD PTR [r9+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1039 :                     const BYTE* const repMatch = repBase + repIndex;

	add	r11, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r14d
	sub	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1037 :                     const U32 repIndex = (U32)(current - offset_1);

	cmp	eax, DWORD PTR tv2477[rsp]

; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	eax, r10d
	cmovbe	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [r9+32], r10d

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1040 :                     if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	mov	edx, r10d
	cmp	r8d, ecx
	mov	ecx, esi
	seta	dl
	sub	ecx, r8d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN25@ZSTD_compr

; 1041 :                     if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [r11]
	cmp	DWORD PTR [rbx], eax
	jne	$LN25@ZSTD_compr

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r8d, esi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	lea	rcx, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	mov	rdi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1043 :                         const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rdi, QWORD PTR dictEnd$1$[rsp]

; 1044 :                         size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rdi
	cmp	rcx, rbp
	cmovb	r8, rcx
	lea	rcx, QWORD PTR [rbx+4]
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rdi
	jne	SHORT $LN64@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	add	rcx, r14
	mov	r8, rbp
	call	ZSTD_count
	add	r14, rax
$LN64@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	mov	edi, DWORD PTR tv2210[rsp]
	lea	rdx, QWORD PTR [r14+4]
	mov	r14d, DWORD PTR current$1$[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r8d, r8d

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	eax, DWORD PTR tv2225[rsp]
	mov	ecx, r8d
	mov	DWORD PTR r$2[rsp], r8d
	cmovne	ecx, eax
	sub	r12d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1046 :                         int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);

	inc	r12d

; 1047 :                         if ((repLength >= 4) && (gain2 > gain1))

	cmp	rdx, 4
	jb	SHORT $LN25@ZSTD_compr
	lea	eax, DWORD PTR [rdx*4]
	cmp	eax, r12d
	jle	SHORT $LN25@ZSTD_compr

; 1048 :                             matchLength = repLength, offset = 0, start = ip;

	mov	r15, rdx
	mov	QWORD PTR start$1$[rsp], rbx
	mov	r13d, r8d
$LN25@ZSTD_compr:

; 1053 :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	rcx, QWORD PTR ms$[rsp]
	lea	r9, QWORD PTR offset2$3[rsp]
	mov	r8, rbp
	mov	QWORD PTR offset2$3[rsp], 999999999	; 3b9ac9ffH
	mov	rdx, rbx
	call	QWORD PTR searchMax$1$[rsp]

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	mov	r9, QWORD PTR offset2$3[rsp]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1053 :                     size_t const ml2 = searchMax(ms, ip, iend, &offset2);

	mov	r8, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 397  :         unsigned long r=0;

	mov	DWORD PTR r$7[rsp], r10d
	mov	DWORD PTR r$6[rsp], r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	lea	edx, DWORD PTR [r8*4]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1054 :                     int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));   /* raw approx */

	sub	edx, eax

; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	eax, DWORD PTR [r13+1]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 398  :         return _BitScanReverse(&r, val) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, r10d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1055 :                     int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);

	lea	ecx, DWORD PTR [r15*4]
	sub	ecx, eax
	add	ecx, 7

; 1056 :                     if ((ml2 >= 4) && (gain2 > gain1)) {

	cmp	r8, 4
	jb	SHORT $LN201@ZSTD_compr
	cmp	edx, ecx
	jle	SHORT $LN201@ZSTD_compr
$LN212@ZSTD_compr:

; 1000 :         while (ip<ilimit) {

	lea	rax, QWORD PTR [rbp-8]
	mov	QWORD PTR start$1$[rsp], rbx
	mov	r13, r9
	mov	r15, r8
	cmp	rbx, rax
	jb	$LL210@ZSTD_compr
$LN201@ZSTD_compr:
	mov	rsi, QWORD PTR src$[rsp]
	mov	rbp, QWORD PTR seqStore$[rsp]
	mov	rdi, QWORD PTR start$1$[rsp]
$LN26@ZSTD_compr:

; 1057 :                         matchLength = ml2, offset = offset2, start = ip;
; 1058 :                         continue;
; 1059 :             }   }   }
; 1060 :             break;  /* nothing found : store previous solution */
; 1061 :         }
; 1062 : 
; 1063 :         /* catch up */
; 1064 :         if (offset) {

	test	r13, r13
	je	SHORT $_storeSequence$214

; 1065 :             U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));

	mov	r9, QWORD PTR base$1$[rsp]
	mov	eax, edi

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	edx, DWORD PTR dictLimit$1$[rsp]
	sub	eax, r13d
	mov	r8, QWORD PTR prefixStart$1$[rsp]
	sub	eax, r9d
	add	eax, 2
	cmp	eax, edx
	cmovb	r8, QWORD PTR dictStart$1$[rsp]

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	rdi, rsi
	jbe	SHORT $LN202@ZSTD_compr

; 1066 :             const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
; 1067 :             const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;

	mov	rcx, QWORD PTR dictBase$1$[rsp]
	cmp	eax, edx
	cmovae	rcx, r9
	add	rcx, rax
$LL6@ZSTD_compr:

; 1068 :             while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */

	cmp	rcx, r8
	jbe	SHORT $LN202@ZSTD_compr
	movzx	eax, BYTE PTR [rcx-1]
	lea	rdx, QWORD PTR [rdi-1]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN202@ZSTD_compr
	dec	rcx
	mov	QWORD PTR start$1$[rsp], rdx
	inc	r15
	mov	rdi, rdx
	cmp	rdx, rsi
	ja	SHORT $LL6@ZSTD_compr
$LN202@ZSTD_compr:

; 1069 :             offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);

	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], eax
	lea	eax, DWORD PTR [r13-2]
	mov	DWORD PTR offset_1$1$[rsp], eax
$_storeSequence$214:

; 1074 :         {   size_t const litLength = start - anchor;

	mov	rdx, QWORD PTR start$1$[rsp]

; 1075 :             ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);

	lea	r11, QWORD PTR [r15-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r14, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1074 :         {   size_t const litLength = start - anchor;

	mov	r10, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1074 :         {   size_t const litLength = start - anchor;

	sub	r10, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbx, QWORD PTR [r14-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r10+rsi]
	mov	QWORD PTR litLimit_w$1$[rsp], rbx

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rbx
	ja	SHORT $LN76@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r10, 16
	jbe	SHORT $LN98@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [r10-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	rsi, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	6
$LL90@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]

; 289  :             COPY16(op, ip);

	lea	rsi, QWORD PTR [rsi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL90@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN98@ZSTD_compr
$LN76@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rsi, rbx
	ja	SHORT $LN167@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r9, rcx
	sub	r9, rsi
	add	r9, rbx
	sub	rsi, rcx
	npad	10
$LL107@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r9
	jb	SHORT $LL107@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r9
	mov	rsi, rbx
$LN167@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rsi, r8
	jae	SHORT $LN98@ZSTD_compr
	sub	rcx, rsi
	npad	2
$LL176@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR [rcx+rsi], al
	inc	rsi
	cmp	rsi, r8
	jb	SHORT $LL176@ZSTD_compr
$LN98@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], r10

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	mov	rcx, QWORD PTR [rbp+8]
	cmp	r10, 65535				; 0000ffffH
	jbe	SHORT $LN79@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN79@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r10w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r13+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r11, 65535				; 0000ffffH
	jbe	SHORT $LN190@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN190@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	rsi, QWORD PTR [rdx+r15]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r11w

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1076 :             anchor = ip = start + matchLength;

	lea	rdi, QWORD PTR [r14-8]
	mov	QWORD PTR src$[rsp], rsi
	mov	rbx, rsi
	cmp	rsi, rdi

; 1080 :         while (ip <= ilimit) {

	ja	$LN208@ZSTD_compr
	mov	r13, QWORD PTR litLimit_w$1$[rsp]
	mov	r15d, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	QWORD PTR src$[rsp], rsi
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	jmp	SHORT $LN8@ZSTD_compr
	npad	1
$LL209@ZSTD_compr:
	mov	r14, QWORD PTR iend$1$[rsp]
$LN8@ZSTD_compr:

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	mov	rax, QWORD PTR base$1$[rsp]
	mov	r8d, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	rdx, QWORD PTR ms$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1081 :             const U32 repCurrent = (U32)(ip-base);

	sub	r8d, eax

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	mov	r10d, DWORD PTR dictLimit$1$[rsp]
	mov	r11, rax
	mov	r9d, r8d
	mov	r12d, r15d
	sub	r9d, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [rdx+28]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1084 :             const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;

	cmp	r9d, r10d

; 1085 :             const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r9d
	cmovb	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	sub	r8d, DWORD PTR tv2477[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1083 :             const U32 repIndex = repCurrent - offset_2;

	cmp	eax, DWORD PTR tv2477[rsp]
	cmovbe	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	DWORD PTR [rdx+32], 0

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1086 :             if (((U32)((dictLimit-1) - repIndex) >= 3) & (repIndex > windowLow))  /* intentional overflow */

	xor	eax, eax
	cmp	r9d, r8d
	mov	edx, eax
	mov	ecx, r10d
	seta	dl
	sub	ecx, r9d
	dec	ecx
	cmp	ecx, 3
	setae	al
	test	edx, eax
	je	$LN203@ZSTD_compr

; 1087 :             if (MEM_read32(ip) == MEM_read32(repMatch)) {

	mov	eax, DWORD PTR [r11]
	cmp	DWORD PTR [rbx], eax
	jne	$LN203@ZSTD_compr

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmp	r9d, r10d

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	lea	r15, QWORD PTR [rbx+4]
	mov	rdi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1089 :                 const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;

	cmovb	rdi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1090 :                 matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rdi
	cmp	rcx, r14
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rdi
	jne	SHORT $LN117@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+r15]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN117@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	r15d, DWORD PTR offset_1$1$[rsp]
	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1091 :                 offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;   /* swap offset history */

	mov	DWORD PTR offset_2$1$[rsp], r15d
	mov	DWORD PTR offset_1$1$[rsp], r12d

; 1092 :                 ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);

	lea	rdx, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rsi, r13
	ja	SHORT $LL154@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rax], xmm0
	npad	1
$LL154@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN191@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN191@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	mov	rdi, QWORD PTR ilimit$1$[rsp]

; 1093 :                 ip += matchLength;

	add	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1093 :                 ip += matchLength;

	mov	rsi, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_lazy.c

; 1080 :         while (ip <= ilimit) {

	cmp	rbx, rdi
	jbe	$LL209@ZSTD_compr
$LN203@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
	mov	QWORD PTR src$[rsp], rsi
	jmp	SHORT $LN29@ZSTD_compr
$LN208@ZSTD_compr:
	mov	r12, r14
$LN211@ZSTD_compr:

; 959  : 
; 960  :     /* Match Loop */
; 961  : #if defined(__GNUC__) && defined(__x86_64__)
; 962  :     /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
; 963  :      * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
; 964  :      */
; 965  :     __asm__(".p2align 5");
; 966  : #endif
; 967  :     while (ip < ilimit) {

	mov	r15d, DWORD PTR offset_2$1$[rsp]
$LN29@ZSTD_compr:
	mov	r10d, DWORD PTR dictLimit$1$[rsp]
	mov	r14d, 0
	mov	rdx, QWORD PTR ms$[rsp]
	mov	r11d, DWORD PTR offset_1$1$[rsp]
	mov	r9, QWORD PTR base$1$[rsp]
	cmp	rbx, rdi
	jb	$LL2@ZSTD_compr
	mov	rdi, QWORD PTR rep$[rsp]
	mov	r13, QWORD PTR [rsp+168]
$LN3@ZSTD_compr:

; 1094 :                 anchor = ip;
; 1095 :                 continue;   /* faster when present ... (?) */
; 1096 :             }
; 1097 :             break;
; 1098 :     }   }
; 1099 : 
; 1100 :     /* Save reps for next block */
; 1101 :     rep[0] = offset_1;
; 1102 :     rep[1] = offset_2;
; 1103 : 
; 1104 :     /* Return the last literals size */
; 1105 :     return (size_t)(iend - anchor);

	sub	r12, rsi
	mov	DWORD PTR [rdi], r11d
	mov	rax, r12
	mov	DWORD PTR [rdi+4], r15d

; 1106 : }

	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_compressBlock_lazy_extDict_generic ENDP
_TEXT	ENDS
END
