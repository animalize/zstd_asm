; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__report_rangecheckfailure:PROC
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
PUBLIC	HUF_buildCTable
PUBLIC	HUF_getNbBits
PUBLIC	HUF_estimateCompressedSize
PUBLIC	HUF_buildCTable_wksp
PUBLIC	HUF_writeCTable
PUBLIC	HUF_validateCTable
PUBLIC	HUF_compress1X_usingCTable
PUBLIC	HUF_optimalTableLog
PUBLIC	HUF_compress4X_usingCTable
PUBLIC	HUF_compress4X_repeat
PUBLIC	HUF_compress1X_repeat
PUBLIC	HUF_readCTable
pdata	SEGMENT
$pdata$HUF_compress_internal DD imagerel HUF_compress_internal
	DD	imagerel HUF_compress_internal+859
	DD	imagerel $unwind$HUF_compress_internal
$pdata$HUF_compressCTable_internal DD imagerel HUF_compressCTable_internal
	DD	imagerel HUF_compressCTable_internal+139
	DD	imagerel $unwind$HUF_compressCTable_internal
$pdata$HUF_compress4X_usingCTable_internal DD imagerel HUF_compress4X_usingCTable_internal
	DD	imagerel HUF_compress4X_usingCTable_internal+303
	DD	imagerel $unwind$HUF_compress4X_usingCTable_internal
$pdata$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal
	DD	imagerel HUF_compress1X_usingCTable_internal+28
	DD	imagerel $unwind$HUF_compress1X_usingCTable_internal
$pdata$2$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal+28
	DD	imagerel HUF_compress1X_usingCTable_internal+68
	DD	imagerel $chain$2$HUF_compress1X_usingCTable_internal
$pdata$3$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal+68
	DD	imagerel HUF_compress1X_usingCTable_internal+246
	DD	imagerel $chain$3$HUF_compress1X_usingCTable_internal
$pdata$6$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal+246
	DD	imagerel HUF_compress1X_usingCTable_internal+478
	DD	imagerel $chain$6$HUF_compress1X_usingCTable_internal
$pdata$7$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal+478
	DD	imagerel HUF_compress1X_usingCTable_internal+517
	DD	imagerel $chain$7$HUF_compress1X_usingCTable_internal
$pdata$8$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal+517
	DD	imagerel HUF_compress1X_usingCTable_internal+545
	DD	imagerel $chain$8$HUF_compress1X_usingCTable_internal
$pdata$9$HUF_compress1X_usingCTable_internal DD imagerel HUF_compress1X_usingCTable_internal+545
	DD	imagerel HUF_compress1X_usingCTable_internal+551
	DD	imagerel $chain$9$HUF_compress1X_usingCTable_internal
$pdata$HUF_compress1X_usingCTable_internal_body DD imagerel HUF_compress1X_usingCTable_internal_body
	DD	imagerel HUF_compress1X_usingCTable_internal_body+65
	DD	imagerel $unwind$HUF_compress1X_usingCTable_internal_body
$pdata$1$HUF_compress1X_usingCTable_internal_body DD imagerel HUF_compress1X_usingCTable_internal_body+65
	DD	imagerel HUF_compress1X_usingCTable_internal_body+235
	DD	imagerel $chain$1$HUF_compress1X_usingCTable_internal_body
$pdata$3$HUF_compress1X_usingCTable_internal_body DD imagerel HUF_compress1X_usingCTable_internal_body+235
	DD	imagerel HUF_compress1X_usingCTable_internal_body+472
	DD	imagerel $chain$3$HUF_compress1X_usingCTable_internal_body
$pdata$4$HUF_compress1X_usingCTable_internal_body DD imagerel HUF_compress1X_usingCTable_internal_body+472
	DD	imagerel HUF_compress1X_usingCTable_internal_body+519
	DD	imagerel $chain$4$HUF_compress1X_usingCTable_internal_body
$pdata$5$HUF_compress1X_usingCTable_internal_body DD imagerel HUF_compress1X_usingCTable_internal_body+519
	DD	imagerel HUF_compress1X_usingCTable_internal_body+559
	DD	imagerel $chain$5$HUF_compress1X_usingCTable_internal_body
$pdata$HUF_buildCTable DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$HUF_buildCTable
$pdata$HUF_sort DD imagerel HUF_sort
	DD	imagerel HUF_sort+291
	DD	imagerel $unwind$HUF_sort
$pdata$HUF_setMaxHeight DD imagerel HUF_setMaxHeight
	DD	imagerel HUF_setMaxHeight+66
	DD	imagerel $unwind$HUF_setMaxHeight
$pdata$4$HUF_setMaxHeight DD imagerel HUF_setMaxHeight+66
	DD	imagerel HUF_setMaxHeight+224
	DD	imagerel $chain$4$HUF_setMaxHeight
$pdata$5$HUF_setMaxHeight DD imagerel HUF_setMaxHeight+224
	DD	imagerel HUF_setMaxHeight+289
	DD	imagerel $chain$5$HUF_setMaxHeight
$pdata$6$HUF_setMaxHeight DD imagerel HUF_setMaxHeight+289
	DD	imagerel HUF_setMaxHeight+569
	DD	imagerel $chain$6$HUF_setMaxHeight
$pdata$7$HUF_setMaxHeight DD imagerel HUF_setMaxHeight+569
	DD	imagerel HUF_setMaxHeight+675
	DD	imagerel $chain$7$HUF_setMaxHeight
$pdata$HUF_compressWeights DD imagerel HUF_compressWeights
	DD	imagerel HUF_compressWeights+227
	DD	imagerel $unwind$HUF_compressWeights
$pdata$1$HUF_compressWeights DD imagerel HUF_compressWeights+227
	DD	imagerel HUF_compressWeights+1299
	DD	imagerel $chain$1$HUF_compressWeights
$pdata$2$HUF_compressWeights DD imagerel HUF_compressWeights+1299
	DD	imagerel HUF_compressWeights+1473
	DD	imagerel $chain$2$HUF_compressWeights
$pdata$HUF_estimateCompressedSize DD imagerel $LN17
	DD	imagerel $LN17+34
	DD	imagerel $unwind$HUF_estimateCompressedSize
$pdata$0$HUF_estimateCompressedSize DD imagerel $LN17+34
	DD	imagerel $LN17+44
	DD	imagerel $chain$0$HUF_estimateCompressedSize
$pdata$3$HUF_estimateCompressedSize DD imagerel $LN17+44
	DD	imagerel $LN17+149
	DD	imagerel $chain$3$HUF_estimateCompressedSize
$pdata$4$HUF_estimateCompressedSize DD imagerel $LN17+149
	DD	imagerel $LN17+183
	DD	imagerel $chain$4$HUF_estimateCompressedSize
$pdata$5$HUF_estimateCompressedSize DD imagerel $LN17+183
	DD	imagerel $LN17+196
	DD	imagerel $chain$5$HUF_estimateCompressedSize
$pdata$HUF_buildCTable_wksp DD imagerel $LN117
	DD	imagerel $LN117+138
	DD	imagerel $unwind$HUF_buildCTable_wksp
$pdata$0$HUF_buildCTable_wksp DD imagerel $LN117+138
	DD	imagerel $LN117+154
	DD	imagerel $chain$0$HUF_buildCTable_wksp
$pdata$1$HUF_buildCTable_wksp DD imagerel $LN117+154
	DD	imagerel $LN117+759
	DD	imagerel $chain$1$HUF_buildCTable_wksp
$pdata$2$HUF_buildCTable_wksp DD imagerel $LN117+759
	DD	imagerel $LN117+936
	DD	imagerel $chain$2$HUF_buildCTable_wksp
$pdata$3$HUF_buildCTable_wksp DD imagerel $LN117+936
	DD	imagerel $LN117+1152
	DD	imagerel $chain$3$HUF_buildCTable_wksp
$pdata$HUF_writeCTable DD imagerel $LN38
	DD	imagerel $LN38+75
	DD	imagerel $unwind$HUF_writeCTable
$pdata$0$HUF_writeCTable DD imagerel $LN38+75
	DD	imagerel $LN38+262
	DD	imagerel $chain$0$HUF_writeCTable
$pdata$1$HUF_writeCTable DD imagerel $LN38+262
	DD	imagerel $LN38+289
	DD	imagerel $chain$1$HUF_writeCTable
$pdata$2$HUF_writeCTable DD imagerel $LN38+289
	DD	imagerel $LN38+418
	DD	imagerel $chain$2$HUF_writeCTable
$pdata$HUF_validateCTable DD imagerel $LN18
	DD	imagerel $LN18+85
	DD	imagerel $unwind$HUF_validateCTable
$pdata$HUF_compress1X_usingCTable DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$HUF_compress1X_usingCTable
$pdata$HUF_compress4X_usingCTable DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$HUF_compress4X_usingCTable
$pdata$HUF_compress4X_repeat DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$HUF_compress4X_repeat
$pdata$HUF_compress1X_repeat DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$HUF_compress1X_repeat
$pdata$HUF_readCTable DD imagerel $LN50
	DD	imagerel $LN50+129
	DD	imagerel $unwind$HUF_readCTable
$pdata$0$HUF_readCTable DD imagerel $LN50+129
	DD	imagerel $LN50+162
	DD	imagerel $chain$0$HUF_readCTable
$pdata$1$HUF_readCTable DD imagerel $LN50+162
	DD	imagerel $LN50+193
	DD	imagerel $chain$1$HUF_readCTable
$pdata$2$HUF_readCTable DD imagerel $LN50+193
	DD	imagerel $LN50+554
	DD	imagerel $chain$2$HUF_readCTable
xdata	SEGMENT
$unwind$HUF_compress_internal DD 0d5a01H
	DD	0ae45aH
	DD	0bc455H
	DD	0c7450H
	DD	014344bH
	DD	0f00bc20fH
	DD	06007d009H
	DD	05006H
$unwind$HUF_compressCTable_internal DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
$unwind$HUF_compress4X_usingCTable_internal DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$HUF_compress1X_usingCTable_internal DD 020a01H
	DD	03006520aH
$chain$2$HUF_compress1X_usingCTable_internal DD 061821H
	DD	01e418H
	DD	02d40cH
	DD	0a5405H
	DD	imagerel HUF_compress1X_usingCTable_internal
	DD	imagerel HUF_compress1X_usingCTable_internal+28
	DD	imagerel $unwind$HUF_compress1X_usingCTable_internal
$chain$3$HUF_compress1X_usingCTable_internal DD 020421H
	DD	0f404H
	DD	imagerel HUF_compress1X_usingCTable_internal+28
	DD	imagerel HUF_compress1X_usingCTable_internal+68
	DD	imagerel $chain$2$HUF_compress1X_usingCTable_internal
$chain$6$HUF_compress1X_usingCTable_internal DD 061221H
	DD	03c412H
	DD	04740dH
	DD	056405H
	DD	imagerel HUF_compress1X_usingCTable_internal+68
	DD	imagerel HUF_compress1X_usingCTable_internal+246
	DD	imagerel $chain$3$HUF_compress1X_usingCTable_internal
$chain$7$HUF_compress1X_usingCTable_internal DD 021H
	DD	imagerel HUF_compress1X_usingCTable_internal+68
	DD	imagerel HUF_compress1X_usingCTable_internal+246
	DD	imagerel $chain$3$HUF_compress1X_usingCTable_internal
$chain$8$HUF_compress1X_usingCTable_internal DD 021H
	DD	imagerel HUF_compress1X_usingCTable_internal+28
	DD	imagerel HUF_compress1X_usingCTable_internal+68
	DD	imagerel $chain$2$HUF_compress1X_usingCTable_internal
$chain$9$HUF_compress1X_usingCTable_internal DD 021H
	DD	imagerel HUF_compress1X_usingCTable_internal
	DD	imagerel HUF_compress1X_usingCTable_internal+28
	DD	imagerel $unwind$HUF_compress1X_usingCTable_internal
$unwind$HUF_compress1X_usingCTable_internal_body DD 050f01H
	DD	0f00b220fH
	DD	06007e009H
	DD	03006H
$chain$1$HUF_compress1X_usingCTable_internal_body DD 041721H
	DD	01c417H
	DD	027405H
	DD	imagerel HUF_compress1X_usingCTable_internal_body
	DD	imagerel HUF_compress1X_usingCTable_internal_body+65
	DD	imagerel $unwind$HUF_compress1X_usingCTable_internal_body
$chain$3$HUF_compress1X_usingCTable_internal_body DD 040921H
	DD	0d409H
	DD	0b5405H
	DD	imagerel HUF_compress1X_usingCTable_internal_body+65
	DD	imagerel HUF_compress1X_usingCTable_internal_body+235
	DD	imagerel $chain$1$HUF_compress1X_usingCTable_internal_body
$chain$4$HUF_compress1X_usingCTable_internal_body DD 021H
	DD	imagerel HUF_compress1X_usingCTable_internal_body+65
	DD	imagerel HUF_compress1X_usingCTable_internal_body+235
	DD	imagerel $chain$1$HUF_compress1X_usingCTable_internal_body
$chain$5$HUF_compress1X_usingCTable_internal_body DD 021H
	DD	imagerel HUF_compress1X_usingCTable_internal_body
	DD	imagerel HUF_compress1X_usingCTable_internal_body+65
	DD	imagerel $unwind$HUF_compress1X_usingCTable_internal_body
$unwind$HUF_buildCTable DD 021f19H
	DD	0229010dH
	DD	imagerel __GSHandlerCheck
	DD	01130H
$unwind$HUF_sort DD 081201H
	DD	095412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
$unwind$HUF_setMaxHeight DD 021519H
	DD	03002d206H
	DD	imagerel __GSHandlerCheck
	DD	040H
$chain$4$HUF_setMaxHeight DD 0a2f21H
	DD	0af42fH
	DD	0be423H
	DD	0c741aH
	DD	0d6410H
	DD	0135408H
	DD	imagerel HUF_setMaxHeight
	DD	imagerel HUF_setMaxHeight+66
	DD	imagerel $unwind$HUF_setMaxHeight
$chain$5$HUF_setMaxHeight DD 060021H
	DD	0af400H
	DD	0be400H
	DD	0c7400H
	DD	imagerel HUF_setMaxHeight
	DD	imagerel HUF_setMaxHeight+66
	DD	imagerel $unwind$HUF_setMaxHeight
$chain$6$HUF_setMaxHeight DD 040021H
	DD	0af400H
	DD	0c7400H
	DD	imagerel HUF_setMaxHeight
	DD	imagerel HUF_setMaxHeight+66
	DD	imagerel $unwind$HUF_setMaxHeight
$chain$7$HUF_setMaxHeight DD 020021H
	DD	0c7400H
	DD	imagerel HUF_setMaxHeight
	DD	imagerel HUF_setMaxHeight+66
	DD	imagerel $unwind$HUF_setMaxHeight
$unwind$HUF_compressWeights DD 082319H
	DD	0390111H
	DD	0d008f00aH
	DD	07004c006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$chain$1$HUF_compressWeights DD 041621H
	DD	037e416H
	DD	0385408H
	DD	imagerel HUF_compressWeights
	DD	imagerel HUF_compressWeights+227
	DD	imagerel $unwind$HUF_compressWeights
$chain$2$HUF_compressWeights DD 021H
	DD	imagerel HUF_compressWeights
	DD	imagerel HUF_compressWeights+227
	DD	imagerel $unwind$HUF_compressWeights
$unwind$HUF_estimateCompressedSize DD 030601H
	DD	0e004f006H
	DD	03002H
$chain$0$HUF_estimateCompressedSize DD 020521H
	DD	045405H
	DD	imagerel $LN17
	DD	imagerel $LN17+34
	DD	imagerel $unwind$HUF_estimateCompressedSize
$chain$3$HUF_estimateCompressedSize DD 061921H
	DD	07c419H
	DD	06740eH
	DD	056405H
	DD	imagerel $LN17+34
	DD	imagerel $LN17+44
	DD	imagerel $chain$0$HUF_estimateCompressedSize
$chain$4$HUF_estimateCompressedSize DD 021H
	DD	imagerel $LN17+34
	DD	imagerel $LN17+44
	DD	imagerel $chain$0$HUF_estimateCompressedSize
$chain$5$HUF_estimateCompressedSize DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+34
	DD	imagerel $unwind$HUF_estimateCompressedSize
$unwind$HUF_buildCTable_wksp DD 082119H
	DD	0130112H
	DD	0e009f00bH
	DD	0c005d007H
	DD	030027003H
	DD	imagerel __GSHandlerCheck
	DD	078H
$chain$0$HUF_buildCTable_wksp DD 020821H
	DD	0125408H
	DD	imagerel $LN117
	DD	imagerel $LN117+138
	DD	imagerel $unwind$HUF_buildCTable_wksp
$chain$1$HUF_buildCTable_wksp DD 020821H
	DD	0116408H
	DD	imagerel $LN117+138
	DD	imagerel $LN117+154
	DD	imagerel $chain$0$HUF_buildCTable_wksp
$chain$2$HUF_buildCTable_wksp DD 021H
	DD	imagerel $LN117+138
	DD	imagerel $LN117+154
	DD	imagerel $chain$0$HUF_buildCTable_wksp
$chain$3$HUF_buildCTable_wksp DD 021H
	DD	imagerel $LN117
	DD	imagerel $LN117+138
	DD	imagerel $unwind$HUF_buildCTable_wksp
$unwind$HUF_writeCTable DD 051d19H
	DD	028010bH
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$chain$0$HUF_writeCTable DD 020821H
	DD	02e7408H
	DD	imagerel $LN38
	DD	imagerel $LN38+75
	DD	imagerel $unwind$HUF_writeCTable
$chain$1$HUF_writeCTable DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+75
	DD	imagerel $unwind$HUF_writeCTable
$chain$2$HUF_writeCTable DD 020021H
	DD	02e7400H
	DD	imagerel $LN38
	DD	imagerel $LN38+75
	DD	imagerel $unwind$HUF_writeCTable
$unwind$HUF_validateCTable DD 020501H
	DD	013405H
$unwind$HUF_compress1X_usingCTable DD 010401H
	DD	06204H
$unwind$HUF_compress4X_usingCTable DD 010401H
	DD	06204H
$unwind$HUF_compress4X_repeat DD 010401H
	DD	0e204H
$unwind$HUF_compress1X_repeat DD 010401H
	DD	0e204H
$unwind$HUF_readCTable DD 072119H
	DD	03c010fH
	DD	0e006f008H
	DD	050037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$chain$0$HUF_readCTable DD 020821H
	DD	0456408H
	DD	imagerel $LN50
	DD	imagerel $LN50+129
	DD	imagerel $unwind$HUF_readCTable
$chain$1$HUF_readCTable DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+129
	DD	imagerel $unwind$HUF_readCTable
$chain$2$HUF_readCTable DD 020021H
	DD	0456400H
	DD	imagerel $LN50
	DD	imagerel $LN50+129
	DD	imagerel $unwind$HUF_readCTable
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
tableLog$ = 64
nbSymbols$ = 68
rankVal$ = 80
nbPerRank$1 = 144
valPerRank$2 = 176
huffWeight$ = 208
__$ArrayPad$ = 464
CTable$ = 528
maxSymbolValuePtr$ = 536
src$ = 544
srcSize$ = 552
hasZeroWeights$ = 560
HUF_readCTable PROC

; 151  : {

$LN50:
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 480				; 000001e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, QWORD PTR hasZeroWeights$[rsp]

; 158  :     CHECK_V_F(readSize, HUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX+1, rankVal, &nbSymbols, &tableLog, src, srcSize));

	lea	rax, QWORD PTR tableLog$[rsp]
	mov	QWORD PTR [rsp+48], r9
	mov	rdi, rcx
	mov	QWORD PTR [rsp+40], r8
	lea	r9, QWORD PTR nbSymbols$[rsp]
	xor	ebx, ebx
	mov	QWORD PTR [rsp+32], rax
	lea	r8, QWORD PTR rankVal$[rsp]
	mov	DWORD PTR tableLog$[rsp], ebx
	lea	rcx, QWORD PTR huffWeight$[rsp]
	mov	DWORD PTR nbSymbols$[rsp], ebx
	mov	r15, rdx
	call	HUF_readStats
	mov	rbp, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 158  :     CHECK_V_F(readSize, HUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX+1, rankVal, &nbSymbols, &tableLog, src, srcSize));

	ja	SHORT $LN1@HUF_readCT

; 159  : 
; 160  :     /* check result */
; 161  :     if (tableLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);

	mov	r9d, DWORD PTR tableLog$[rsp]
	cmp	r9d, 12
	jbe	SHORT $LN18@HUF_readCT
	lea	rax, QWORD PTR [rbx-44]
	jmp	SHORT $LN1@HUF_readCT
$LN18@HUF_readCT:

; 162  :     if (nbSymbols > *maxSymbolValuePtr+1) return ERROR(maxSymbolValue_tooSmall);

	mov	eax, DWORD PTR [r15]
	mov	QWORD PTR [rsp+552], rsi
	inc	eax
	mov	esi, DWORD PTR nbSymbols$[rsp]
	cmp	esi, eax
	jbe	SHORT $LN19@HUF_readCT
	mov	rax, -48				; ffffffffffffffd0H
$LN47@HUF_readCT:
	mov	rsi, QWORD PTR [rsp+552]
$LN1@HUF_readCT:

; 198  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 480				; 000001e0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN19@HUF_readCT:

; 163  : 
; 164  :     /* Prepare base value per rank */
; 165  :     {   U32 n, nextRankStart = 0;

	mov	r10d, 1
	mov	r11d, ebx

; 166  :         for (n=1; n<=tableLog; n++) {

	cmp	r9d, r10d
	jb	SHORT $LN3@HUF_readCT
	npad	1
$LL35@HUF_readCT:

; 167  :             U32 current = nextRankStart;
; 168  :             nextRankStart += (rankVal[n] << (n-1));

	mov	eax, r10d
	lea	ecx, DWORD PTR [r10-1]
	mov	r8d, r11d
	lea	rdx, QWORD PTR rankVal$[rsp]
	lea	rdx, QWORD PTR [rdx+rax*4]
	inc	r10d
	mov	eax, DWORD PTR [rdx]
	shl	eax, cl
	add	r11d, eax

; 169  :             rankVal[n] = current;

	mov	DWORD PTR [rdx], r8d
	cmp	r10d, r9d
	jbe	SHORT $LL35@HUF_readCT
$LN3@HUF_readCT:

; 170  :     }   }
; 171  : 
; 172  :     /* fill nbBits */
; 173  :     *hasZeroWeights = 0;

	mov	DWORD PTR [r14], ebx

; 174  :     {   U32 n; for (n=0; n<nbSymbols; n++) {

	test	esi, esi
	je	SHORT $LN6@HUF_readCT

; 170  :     }   }
; 171  : 
; 172  :     /* fill nbBits */
; 173  :     *hasZeroWeights = 0;

	lea	r8, QWORD PTR huffWeight$[rsp]
	mov	r11, rsi
	lea	r10, QWORD PTR [rdi+2]
	npad	5
$LL7@HUF_readCT:

; 175  :             const U32 w = huffWeight[n];

	movzx	edx, BYTE PTR [r8]
	lea	r10, QWORD PTR [r10+4]

; 176  :             *hasZeroWeights |= (w == 0);

	test	dl, dl
	lea	r8, QWORD PTR [r8+1]
	mov	eax, ebx

; 177  :             CTable[n].nbBits = (BYTE)(tableLog + 1 - w) & -(w != 0);

	mov	ecx, ebx
	sete	al
	or	DWORD PTR [r14], eax
	movzx	eax, r9b
	sub	al, dl
	inc	al
	test	dl, dl
	movzx	eax, al
	cmovne	ecx, eax
	mov	BYTE PTR [r10-4], cl
	sub	r11, 1
	jne	SHORT $LL7@HUF_readCT
$LN6@HUF_readCT:

; 178  :     }   }
; 179  : 
; 180  :     /* fill val */
; 181  :     {   U16 nbPerRank[HUF_TABLELOG_MAX+2]  = {0};  /* support w=0=>n=tableLog+1 */

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR nbPerRank$1[rsp+16], rax
	mov	DWORD PTR nbPerRank$1[rsp+24], eax

; 182  :         U16 valPerRank[HUF_TABLELOG_MAX+2] = {0};

	mov	QWORD PTR valPerRank$2[rsp+16], rax
	mov	DWORD PTR valPerRank$2[rsp+24], eax
	movups	XMMWORD PTR nbPerRank$1[rsp], xmm0
	movups	XMMWORD PTR valPerRank$2[rsp], xmm0

; 183  :         { U32 n; for (n=0; n<nbSymbols; n++) nbPerRank[CTable[n].nbBits]++; }

	test	esi, esi
	je	SHORT $LN9@HUF_readCT

; 178  :     }   }
; 179  : 
; 180  :     /* fill val */
; 181  :     {   U16 nbPerRank[HUF_TABLELOG_MAX+2]  = {0};  /* support w=0=>n=tableLog+1 */

	lea	rcx, QWORD PTR [rdi+2]
	mov	rdx, rsi
$LL10@HUF_readCT:

; 183  :         { U32 n; for (n=0; n<nbSymbols; n++) nbPerRank[CTable[n].nbBits]++; }

	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+4]
	inc	WORD PTR nbPerRank$1[rsp+rax*2]
	sub	rdx, 1
	jne	SHORT $LL10@HUF_readCT
$LN9@HUF_readCT:

; 184  :         /* determine stating value per rank */
; 185  :         valPerRank[tableLog+1] = 0;   /* for w==0 */

	lea	ecx, DWORD PTR [r9+1]
	add	rcx, rcx
	cmp	rcx, 28
	jae	$LN21@HUF_readCT
	mov	WORD PTR valPerRank$2[rsp+rcx], bx

; 186  :         {   U16 min = 0;
; 187  :             U32 n; for (n=tableLog; n>0; n--) {  /* start at n=tablelog <-> w=1 */

	test	r9d, r9d
	je	SHORT $LN12@HUF_readCT
	lea	rcx, QWORD PTR [r9+r9]
	npad	9
$LL13@HUF_readCT:

; 188  :                 valPerRank[n] = min;     /* get starting value within each rank */

	mov	WORD PTR valPerRank$2[rsp+rcx], bx

; 189  :                 min += nbPerRank[n];

	add	bx, WORD PTR nbPerRank$1[rsp+rcx]
	lea	rcx, QWORD PTR [rcx-2]

; 190  :                 min >>= 1;

	shr	bx, 1
	add	r9d, -1					; ffffffffH
	jne	SHORT $LL13@HUF_readCT
$LN12@HUF_readCT:

; 191  :         }   }
; 192  :         /* assign value within rank, symbol order */
; 193  :         { U32 n; for (n=0; n<nbSymbols; n++) CTable[n].val = valPerRank[CTable[n].nbBits]++; }

	test	esi, esi
	je	SHORT $LN15@HUF_readCT
	mov	rdx, rsi
	npad	12
$LL16@HUF_readCT:
	movzx	eax, BYTE PTR [rdi+2]
	lea	rcx, QWORD PTR valPerRank$2[rsp]
	lea	rcx, QWORD PTR [rcx+rax*2]
	movzx	eax, WORD PTR [rcx]
	mov	WORD PTR [rdi], ax
	lea	rdi, QWORD PTR [rdi+4]
	inc	ax
	mov	WORD PTR [rcx], ax
	sub	rdx, 1
	jne	SHORT $LL16@HUF_readCT
$LN15@HUF_readCT:

; 194  :     }
; 195  : 
; 196  :     *maxSymbolValuePtr = nbSymbols - 1;

	lea	eax, DWORD PTR [rsi-1]
	mov	DWORD PTR [r15], eax

; 197  :     return readSize;

	mov	rax, rbp
	jmp	$LN47@HUF_readCT
$LN21@HUF_readCT:

; 184  :         /* determine stating value per rank */
; 185  :         valPerRank[tableLog+1] = 0;   /* for w==0 */

	call	__report_rangecheckfailure
	int	3
$LN48@HUF_readCT:
HUF_readCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 128
dstSize$ = 136
src$ = 144
srcSize$ = 152
maxSymbolValue$dead$ = 160
huffLog$dead$ = 168
workSpace$ = 176
wkspSize$dead$ = 184
hufTable$ = 192
repeat$ = 200
preferRepeat$ = 208
bmi2$dead$ = 216
HUF_compress1X_repeat PROC

; 743  : {

$LN4:
	sub	rsp, 120				; 00000078H

; 744  :     return HUF_compress_internal(dst, dstSize, src, srcSize,

	mov	eax, DWORD PTR preferRepeat$[rsp]
	mov	DWORD PTR [rsp+88], eax
	mov	rax, QWORD PTR repeat$[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR hufTable$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR workSpace$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 0
	call	HUF_compress_internal

; 745  :                                  maxSymbolValue, huffLog, HUF_singleStream,
; 746  :                                  workSpace, wkspSize, hufTable,
; 747  :                                  repeat, preferRepeat, bmi2);
; 748  : }

	add	rsp, 120				; 00000078H
	ret	0
HUF_compress1X_repeat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 128
dstSize$ = 136
src$ = 144
srcSize$ = 152
maxSymbolValue$dead$ = 160
huffLog$dead$ = 168
workSpace$ = 176
wkspSize$dead$ = 184
hufTable$ = 192
repeat$ = 200
preferRepeat$ = 208
bmi2$dead$ = 216
HUF_compress4X_repeat PROC

; 780  : {

$LN4:
	sub	rsp, 120				; 00000078H

; 781  :     return HUF_compress_internal(dst, dstSize, src, srcSize,

	mov	eax, DWORD PTR preferRepeat$[rsp]
	mov	DWORD PTR [rsp+88], eax
	mov	rax, QWORD PTR repeat$[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR hufTable$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR workSpace$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 1
	call	HUF_compress_internal

; 782  :                                  maxSymbolValue, huffLog, HUF_fourStreams,
; 783  :                                  workSpace, wkspSize,
; 784  :                                  hufTable, repeat, preferRepeat, bmi2);
; 785  : }

	add	rsp, 120				; 00000078H
	ret	0
HUF_compress4X_repeat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 64
dstSize$ = 72
src$ = 80
srcSize$ = 88
CTable$ = 96
HUF_compress4X_usingCTable PROC

; 606  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 607  :     return HUF_compress4X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, /* bmi2 */ 0);

	mov	rax, QWORD PTR CTable$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	HUF_compress4X_usingCTable_internal

; 608  : }

	add	rsp, 56					; 00000038H
	ret	0
HUF_compress4X_usingCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
maxTableLog$dead$ = 8
srcSize$ = 16
maxSymbolValue$ = 24
HUF_optimalTableLog PROC
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	xor	r10d, r10d
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 327  :     U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;

	lea	eax, DWORD PTR [rdx-1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	r9d, r10d
	cmovne	r9d, ecx
	mov	ecx, r10d
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 327  :     U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;

	dec	r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 318  :     U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;

	inc	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	cmovne	r10d, eax
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	mov	eax, 11

; 319  :     U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;

	add	r10d, 2

; 320  :     U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;

	cmp	ecx, r10d
	cmovb	r10d, ecx

; 332  :     if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */

	cmp	r9d, eax
	cmovb	eax, r9d

; 333  :     if (minBits > tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */

	cmp	r10d, eax
	cmova	eax, r10d

; 334  :     if (tableLog < FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;

	cmp	eax, 5
	jae	SHORT $LN7@HUF_optima
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 50   :     return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 1);

	mov	eax, 5

; 51   : }

	ret	0
$LN7@HUF_optima:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 335  :     if (tableLog > FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;

	mov	ecx, 12
	cmp	eax, ecx
	cmova	eax, ecx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 51   : }

	ret	0
HUF_optimalTableLog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 64
dstSize$ = 72
src$ = 80
srcSize$ = 88
CTable$ = 96
HUF_compress1X_usingCTable PROC

; 547  : {

$LN4:
	sub	rsp, 56					; 00000038H

; 548  :     return HUF_compress1X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, /* bmi2 */ 0);

	mov	rax, QWORD PTR CTable$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	HUF_compress1X_usingCTable_internal

; 549  : }

	add	rsp, 56					; 00000038H
	ret	0
HUF_compress1X_usingCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
CTable$ = 8
count$ = 16
maxSymbolValue$ = 24
HUF_validateCTable PROC

; 432  : int HUF_validateCTable(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx

; 433  :   int bad = 0;

	xor	r9d, r9d
	mov	rbx, rcx
	mov	r10d, r9d

; 434  :   int s;
; 435  :   for (s = 0; s <= (int)maxSymbolValue; ++s) {

	test	r8d, r8d
	js	SHORT $LN3@HUF_valida
	sub	rbx, rdx
	lea	r11d, DWORD PTR [r8+1]
	npad	6
$LL8@HUF_valida:

; 436  :     bad |= (count[s] != 0) & (CTable[s].nbBits == 0);

	mov	r8d, r9d
	mov	ecx, r9d
	cmp	BYTE PTR [rbx+rdx+2], r8b
	lea	rdx, QWORD PTR [rdx+4]
	sete	r8b
	cmp	DWORD PTR [rdx-4], ecx
	setne	cl
	and	r8d, ecx
	or	r10d, r8d
	sub	r11, 1
	jne	SHORT $LL8@HUF_valida
$LN3@HUF_valida:

; 437  :   }
; 438  :   return !bad;
; 439  : }

	mov	rbx, QWORD PTR [rsp+8]
	test	r10d, r10d
	sete	r9b
	mov	eax, r9d
	ret	0
HUF_validateCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
bitsToWeight$ = 32
huffWeight$ = 48
__$ArrayPad$ = 304
dst$ = 352
maxDstSize$ = 360
CTable$ = 368
maxSymbolValue$ = 376
huffLog$ = 384
HUF_writeCTable PROC

; 116  : {

$LN38:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 320				; 00000140H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebx, r9d
	mov	r10, r8
	mov	rbp, rdx
	mov	rsi, rcx

; 117  :     BYTE bitsToWeight[HUF_TABLELOG_MAX + 1];   /* precomputed conversion table */
; 118  :     BYTE huffWeight[HUF_SYMBOLVALUE_MAX];
; 119  :     BYTE* op = (BYTE*)dst;
; 120  :     U32 n;
; 121  : 
; 122  :      /* check conditions */
; 123  :     if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);

	cmp	r9d, 255				; 000000ffH
	jbe	SHORT $LN11@HUF_writeC
	mov	rax, -46				; ffffffffffffffd2H
	jmp	$LN1@HUF_writeC
$LN11@HUF_writeC:

; 127  :     for (n=1; n<huffLog+1; n++)

	mov	r8d, DWORD PTR huffLog$[rsp]
	mov	ecx, 1
	mov	QWORD PTR [rsp+368], rdi
	mov	BYTE PTR bitsToWeight$[rsp], 0
	lea	r9d, DWORD PTR [r8+1]
	cmp	r9d, ecx
	jbe	SHORT $LN3@HUF_writeC

; 124  : 
; 125  :     /* convert to weight */
; 126  :     bitsToWeight[0] = 0;

	lea	rdx, QWORD PTR bitsToWeight$[rsp+1]
	npad	10
$LL4@HUF_writeC:

; 128  :         bitsToWeight[n] = (BYTE)(huffLog + 1 - n);

	movzx	eax, r8b
	lea	rdx, QWORD PTR [rdx+1]
	sub	al, cl
	inc	ecx
	inc	al
	mov	BYTE PTR [rdx-1], al
	cmp	ecx, r9d
	jb	SHORT $LL4@HUF_writeC
$LN3@HUF_writeC:

; 129  :     for (n=0; n<maxSymbolValue; n++)

	test	ebx, ebx
	je	SHORT $LN6@HUF_writeC
	lea	rdx, QWORD PTR huffWeight$[rsp]
	mov	r9, rbx
	lea	r8, QWORD PTR [r10+2]
	npad	10
$LL7@HUF_writeC:

; 130  :         huffWeight[n] = bitsToWeight[CTable[n].nbBits];

	movzx	eax, BYTE PTR [r8]
	lea	rdx, QWORD PTR [rdx+1]
	lea	r8, QWORD PTR [r8+4]
	movzx	ecx, BYTE PTR bitsToWeight$[rsp+rax]
	mov	BYTE PTR [rdx-1], cl
	sub	r9, 1
	jne	SHORT $LL7@HUF_writeC
$LN6@HUF_writeC:

; 133  :     {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, huffWeight, maxSymbolValue) );

	lea	rdx, QWORD PTR [rbp-1]
	mov	r9, rbx
	lea	rcx, QWORD PTR [rsi+1]
	lea	r8, QWORD PTR huffWeight$[rsp]
	call	HUF_compressWeights
	mov	rdx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 133  :     {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, huffWeight, maxSymbolValue) );

	ja	SHORT $LN35@HUF_writeC

; 134  :         if ((hSize>1) & (hSize < maxSymbolValue/2)) {   /* FSE compressed */

	xor	r8d, r8d
	mov	rax, rbx
	shr	rax, 1
	mov	ecx, r8d
	cmp	rdx, rax
	mov	eax, r8d
	setb	cl
	cmp	rdx, 1
	seta	al
	test	ecx, eax
	je	SHORT $LN13@HUF_writeC

; 135  :             op[0] = (BYTE)hSize;

	mov	BYTE PTR [rsi], dl

; 136  :             return hSize+1;

	lea	rax, QWORD PTR [rdx+1]
$LN35@HUF_writeC:
	mov	rdi, QWORD PTR [rsp+368]
$LN1@HUF_writeC:

; 147  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 320				; 00000140H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN13@HUF_writeC:

; 137  :     }   }
; 138  : 
; 139  :     /* write raw values as 4-bits (max : 15) */
; 140  :     if (maxSymbolValue > (256-128)) return ERROR(GENERIC);   /* should not happen : likely means source cannot be compressed */

	cmp	ebx, 128				; 00000080H
	jbe	SHORT $LN14@HUF_writeC
	mov	rax, -1
	jmp	SHORT $LN35@HUF_writeC
$LN14@HUF_writeC:

; 141  :     if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);   /* not enough space within dst buffer */

	lea	r9d, DWORD PTR [rbx+1]
	shr	r9d, 1
	inc	r9d
	cmp	r9, rbp
	jbe	SHORT $LN15@HUF_writeC
	mov	rax, -70				; ffffffffffffffbaH
	jmp	SHORT $LN35@HUF_writeC
$LN15@HUF_writeC:

; 142  :     op[0] = (BYTE)(128 /*special case*/ + (maxSymbolValue-1));

	lea	eax, DWORD PTR [rbx+127]
	mov	BYTE PTR [rsi], al

; 143  :     huffWeight[maxSymbolValue] = 0;   /* to be sure it doesn't cause msan issue in final combination */

	cmp	rbx, 255				; 000000ffH
	jae	SHORT $LN19@HUF_writeC
	mov	BYTE PTR huffWeight$[rsp+rbx], r8b

; 144  :     for (n=0; n<maxSymbolValue; n+=2)

	test	ebx, ebx
	je	SHORT $LN9@HUF_writeC
	npad	15
$LL10@HUF_writeC:

; 145  :         op[(n/2)+1] = (BYTE)((huffWeight[n] << 4) + huffWeight[n+1]);

	movzx	edx, BYTE PTR huffWeight$[rsp+r8]
	lea	eax, DWORD PTR [r8+1]
	mov	ecx, r8d
	shl	dl, 4
	add	dl, BYTE PTR huffWeight$[rsp+rax]
	add	r8d, 2
	shr	ecx, 1
	inc	ecx
	mov	BYTE PTR [rcx+rsi], dl
	cmp	r8d, ebx
	jb	SHORT $LL10@HUF_writeC
$LN9@HUF_writeC:

; 146  :     return ((maxSymbolValue+1)/2) + 1;

	mov	rax, r9
	jmp	$LN35@HUF_writeC
$LN19@HUF_writeC:

; 143  :     huffWeight[maxSymbolValue] = 0;   /* to be sure it doesn't cause msan issue in final combination */

	call	__report_rangecheckfailure
	int	3
$LN36@HUF_writeC:
HUF_writeCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
maxSymbolValue$GSCopy$1$ = 32
tv2435 = 36
tv2441 = 40
r$1 = 40
r$2 = 40
tree$GSCopy$1$ = 48
nbPerRank$3 = 56
valPerRank$4 = 88
__$ArrayPad$ = 120
tree$ = 208
count$ = 216
maxSymbolValue$ = 224
maxNbBits$ = 232
workSpace$ = 240
wkspSize$ = 248
HUF_buildCTable_wksp PROC

; 339  : {

$LN117:
	push	rbx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12, QWORD PTR workSpace$[rsp]
	mov	r15, rdx
	movsxd	r13, r8d
	mov	r14, rcx
	mov	DWORD PTR maxSymbolValue$GSCopy$1$[rsp], r13d
	mov	QWORD PTR tree$GSCopy$1$[rsp], rcx

; 340  :     HUF_buildCTable_wksp_tables* const wksp_tables = (HUF_buildCTable_wksp_tables*)workSpace;
; 341  :     nodeElt* const huffNode0 = wksp_tables->huffNodeTbl;
; 342  :     nodeElt* const huffNode = huffNode0+1;

	lea	rbx, QWORD PTR [r12+8]

; 343  :     int nonNullRank;
; 344  :     int lowS, lowN;
; 345  :     int nodeNb = STARTNODE;
; 346  :     int n, nodeRoot;
; 347  : 
; 348  :     /* safety checks */
; 349  :     if (((size_t)workSpace & 3) != 0) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	test	r12b, 3
	jne	$LN113@HUF_buildC

; 350  :     if (wkspSize < sizeof(HUF_buildCTable_wksp_tables))

	cmp	QWORD PTR wkspSize$[rsp], 4352		; 00001100H
	jae	SHORT $LN28@HUF_buildC

; 351  :       return ERROR(workSpace_tooSmall);

	mov	rax, -66				; ffffffffffffffbeH
	jmp	$LN1@HUF_buildC
$LN28@HUF_buildC:

; 352  :     if (maxNbBits == 0) maxNbBits = HUF_TABLELOG_DEFAULT;
; 353  :     if (maxSymbolValue > HUF_SYMBOLVALUE_MAX)

	test	r9d, r9d
	mov	eax, 11
	cmovne	eax, r9d
	mov	DWORD PTR tv2435[rsp], eax
	cmp	r13d, 255				; 000000ffH
	jbe	SHORT $LN30@HUF_buildC

; 354  :       return ERROR(maxSymbolValue_tooLarge);

	mov	rax, -46				; ffffffffffffffd2H
	jmp	$LN1@HUF_buildC
$LN30@HUF_buildC:
	mov	QWORD PTR [rsp+144], rbp

; 355  :     memset(huffNode0, 0, sizeof(huffNodeTable));

	xor	edx, edx
	mov	r8d, 4096				; 00001000H
	mov	QWORD PTR [rsp+136], rsi
	mov	rcx, r12
	call	memset

; 356  : 
; 357  :     /* sort, decreasing order */
; 358  :     HUF_sort(huffNode, count, maxSymbolValue, wksp_tables->rankPosition);

	lea	rsi, QWORD PTR [r12+4096]

; 311  :     memset(rankPosition, 0, sizeof(*rankPosition) * RANK_POSITION_TABLE_SIZE);

	xor	edx, edx
	mov	rcx, rsi
	mov	r8d, 256				; 00000100H
	call	memset

; 312  :     for (n=0; n<=maxSymbolValue; n++) {

	xor	edi, edi
	mov	edx, edi
	npad	10
$LL40@HUF_buildC:

; 313  :         U32 r = BIT_highbit32(count[n] + 1);

	mov	eax, edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	mov	DWORD PTR r$2[rsp], edi
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 313  :         U32 r = BIT_highbit32(count[n] + 1);

	mov	ecx, DWORD PTR [r15+rax*4]
	inc	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, ecx
	mov	ecx, edi
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 312  :     for (n=0; n<=maxSymbolValue; n++) {

	inc	edx

; 314  :         rankPosition[r].base ++;

	inc	DWORD PTR [rsi+rcx*8]
	cmp	edx, r13d
	jbe	SHORT $LL40@HUF_buildC

; 315  :     }
; 316  :     for (n=30; n>0; n--) rankPosition[n-1].base += rankPosition[n].base;

	mov	edx, 30
	lea	rcx, QWORD PTR [r12+4328]
	npad	5
$LL43@HUF_buildC:
	mov	eax, DWORD PTR [rcx+8]
	add	DWORD PTR [rcx], eax
	lea	rcx, QWORD PTR [rcx-8]
	add	edx, -1					; ffffffffH
	jne	SHORT $LL43@HUF_buildC

; 317  :     for (n=0; n<32; n++) rankPosition[n].current = rankPosition[n].base;

	mov	rcx, rsi
	mov	edx, 32					; 00000020H
	npad	10
$LL46@HUF_buildC:
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rcx+4], eax
	lea	rcx, QWORD PTR [rcx+8]
	sub	rdx, 1
	jne	SHORT $LL46@HUF_buildC

; 318  :     for (n=0; n<=maxSymbolValue; n++) {

	mov	r11d, edi
	npad	14
$LL49@HUF_buildC:

; 319  :         U32 const c = count[n];

	mov	eax, r11d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 144  :         unsigned long r=0;

	mov	DWORD PTR r$1[rsp], edi
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 319  :         U32 const c = count[n];

	mov	r9d, DWORD PTR [r15+rax*4]

; 320  :         U32 const r = BIT_highbit32(c+1) + 1;

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, edi
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 320  :         U32 const r = BIT_highbit32(c+1) + 1;

	inc	eax

; 321  :         U32 pos = rankPosition[r].current++;

	lea	r10, QWORD PTR [rsi+rax*8]
	mov	eax, DWORD PTR [rsi+rax*8+4]
	lea	ecx, DWORD PTR [rax+1]
	mov	DWORD PTR [r10+4], ecx

; 322  :         while ((pos > rankPosition[r].base) && (c > huffNode[pos-1].count)) {

	cmp	eax, DWORD PTR [r10]
	jbe	SHORT $LN114@HUF_buildC
	npad	3
$LL50@HUF_buildC:
	lea	edx, DWORD PTR [rax-1]
	cmp	r9d, DWORD PTR [rbx+rdx*8]
	lea	r8, QWORD PTR [rbx+rdx*8]
	jbe	SHORT $LN114@HUF_buildC

; 323  :             huffNode[pos] = huffNode[pos-1];

	mov	ecx, eax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rbx+rcx*8], rax

; 324  :             pos--;

	mov	eax, edx
	cmp	edx, DWORD PTR [r10]
	ja	SHORT $LL50@HUF_buildC
$LN114@HUF_buildC:

; 325  :         }
; 326  :         huffNode[pos].count = c;

	mov	ecx, eax

; 327  :         huffNode[pos].byte  = (BYTE)n;

	mov	BYTE PTR [rbx+rcx*8+6], r11b
	inc	r11d
	mov	DWORD PTR [rbx+rcx*8], r9d
	cmp	r11d, r13d
	jbe	SHORT $LL49@HUF_buildC

; 359  : 
; 360  :     /* init for parents */
; 361  :     nonNullRank = (int)maxSymbolValue;

	lea	rcx, QWORD PTR [rbx+r13*8]
	mov	ebp, r13d

; 362  :     while(huffNode[nonNullRank].count == 0) nonNullRank--;

	cmp	DWORD PTR [rcx], edi
	jne	SHORT $LN3@HUF_buildC
	npad	5
$LL2@HUF_buildC:
	dec	ebp
	lea	rcx, QWORD PTR [rcx-8]
	cmp	DWORD PTR [rcx], edi
	je	SHORT $LL2@HUF_buildC
$LN3@HUF_buildC:

; 363  :     lowS = nonNullRank; nodeRoot = nodeNb + lowS - 1; lowN = nodeNb;
; 364  :     huffNode[nodeNb].count = huffNode[lowS].count + huffNode[lowS-1].count;

	movsxd	r15, ebp
	lea	r9, QWORD PTR [rbx+2048]
	mov	edx, 256				; 00000100H
	lea	ecx, DWORD PTR [rbp+255]
	mov	r11d, edx

; 365  :     huffNode[lowS].parent = huffNode[lowS-1].parent = (U16)nodeNb;
; 366  :     nodeNb++; lowS-=2;

	lea	esi, DWORD PTR [rbp-2]
	mov	r10d, 257				; 00000101H
	mov	eax, DWORD PTR [rbx+r15*8-8]
	add	eax, DWORD PTR [rbx+r15*8]
	mov	DWORD PTR [r9], eax
	mov	WORD PTR [rbx+r15*8-4], dx
	mov	WORD PTR [rbx+r15*8+4], dx

; 367  :     for (n=nodeNb; n<=nodeRoot; n++) huffNode[n].count = (U32)(1U<<30);

	movsxd	rdx, ecx
	mov	QWORD PTR tv2441[rsp], rdx
	cmp	rdx, r10
	jl	SHORT $LN5@HUF_buildC
	mov	eax, r10d
	npad	13
$LL6@HUF_buildC:
	mov	DWORD PTR [rbx+rax*8], 1073741824	; 40000000H
	inc	rax
	cmp	rax, rdx
	jle	SHORT $LL6@HUF_buildC
$LN5@HUF_buildC:

; 368  :     huffNode0[0].count = (U32)(1U<<31);  /* fake entry, strong barrier */

	mov	DWORD PTR [r12], -2147483648		; 80000000H

; 369  : 
; 370  :     /* create parents */
; 371  :     while (nodeNb <= nodeRoot) {

	cmp	ecx, r10d
	jl	$LN8@HUF_buildC
	movsxd	rax, esi
	lea	r12, QWORD PTR [rbx+2056]
	lea	edi, DWORD PTR [rbp+255]
	lea	r8, QWORD PTR [rbx+rax*8]
$LL7@HUF_buildC:

; 372  :         int const n1 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;

	mov	edx, DWORD PTR [r9]
	mov	ecx, DWORD PTR [r8]
	cmp	ecx, edx
	jae	SHORT $LN33@HUF_buildC
	mov	r15d, DWORD PTR [r8-8]
	sub	r8, 8
	mov	r14d, edx
	jmp	SHORT $LN34@HUF_buildC
$LN33@HUF_buildC:
	mov	r14d, DWORD PTR [r9+8]
	add	r9, 8
	mov	r15d, ecx
$LN34@HUF_buildC:

; 373  :         int const n2 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;

	cmp	ecx, edx
	lea	eax, DWORD PTR [r11+1]
	mov	r13d, esi
	cmovae	r13d, r11d
	cmovae	r11d, eax
	lea	eax, DWORD PTR [rsi-1]
	cmovae	eax, esi
	mov	esi, eax
	cmp	r15d, r14d
	jae	SHORT $LN35@HUF_buildC
	dec	esi
	sub	r8, 8
	jmp	SHORT $LN36@HUF_buildC
$LN35@HUF_buildC:
	mov	eax, r11d
	inc	r11d
	add	r9, 8
$LN36@HUF_buildC:

; 374  :         huffNode[nodeNb].count = huffNode[n1].count + huffNode[n2].count;

	cdqe
	lea	rdx, QWORD PTR [rbx+rax*8]
	movsxd	rax, r13d
	lea	rcx, QWORD PTR [rbx+rax*8]
	mov	eax, DWORD PTR [rdx]
	add	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r12], eax

; 375  :         huffNode[n1].parent = huffNode[n2].parent = (U16)nodeNb;
; 376  :         nodeNb++;

	add	r12, 8
	mov	WORD PTR [rdx+4], r10w
	mov	WORD PTR [rcx+4], r10w
	inc	r10d
	cmp	r10d, edi
	jle	SHORT $LL7@HUF_buildC
	mov	r14, QWORD PTR tree$GSCopy$1$[rsp]
	lea	ecx, DWORD PTR [rbp+255]
	mov	rdx, QWORD PTR tv2441[rsp]
	xor	edi, edi
	mov	r13d, DWORD PTR maxSymbolValue$GSCopy$1$[rsp]
	movsxd	r15, ebp
$LN8@HUF_buildC:

; 377  :     }
; 378  : 
; 379  :     /* distribute weights (unlimited tree height) */
; 380  :     huffNode[nodeRoot].nbBits = 0;

	mov	rsi, QWORD PTR [rsp+136]

; 381  :     for (n=nodeRoot-1; n>=STARTNODE; n--)

	lea	eax, DWORD PTR [rcx-1]
	movsxd	r8, eax
	mov	BYTE PTR [rbx+rdx*8+7], 0
	cmp	r8, 256					; 00000100H
	jl	SHORT $LN10@HUF_buildC

; 377  :     }
; 378  : 
; 379  :     /* distribute weights (unlimited tree height) */
; 380  :     huffNode[nodeRoot].nbBits = 0;

	lea	rdx, QWORD PTR [rbx+7]
	lea	rdx, QWORD PTR [rdx+r8*8]
	add	r8, -255				; ffffffffffffff01H
	npad	10
$LL11@HUF_buildC:

; 382  :         huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;

	movzx	eax, WORD PTR [rdx-3]
	lea	rdx, QWORD PTR [rdx-8]
	movzx	ecx, BYTE PTR [rbx+rax*8+7]
	inc	cl
	mov	BYTE PTR [rdx+8], cl
	sub	r8, 1
	jne	SHORT $LL11@HUF_buildC
$LN10@HUF_buildC:

; 383  :     for (n=0; n<=nonNullRank; n++)

	test	r15, r15
	js	SHORT $LN13@HUF_buildC
	lea	r9, QWORD PTR [rbx+7]
	lea	r10, QWORD PTR [r15+1]
	npad	11
$LL14@HUF_buildC:

; 384  :         huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;

	movzx	eax, WORD PTR [r9-3]
	lea	r9, QWORD PTR [r9+8]
	movzx	ecx, BYTE PTR [rbx+rax*8+7]
	inc	cl
	mov	BYTE PTR [r9-8], cl
	sub	r10, 1
	jne	SHORT $LL14@HUF_buildC
$LN13@HUF_buildC:

; 385  : 
; 386  :     /* enforce maxTableLog */
; 387  :     maxNbBits = HUF_setMaxHeight(huffNode, (U32)nonNullRank, maxNbBits);

	mov	r8d, DWORD PTR tv2435[rsp]
	mov	edx, ebp
	mov	rcx, rbx
	call	HUF_setMaxHeight

; 388  : 
; 389  :     /* fill result into tree (val, nbBits) */
; 390  :     {   U16 nbPerRank[HUF_TABLELOG_MAX+1] = {0};
; 391  :         U16 valPerRank[HUF_TABLELOG_MAX+1] = {0};
; 392  :         int const alphabetSize = (int)(maxSymbolValue + 1);

	mov	rbp, QWORD PTR [rsp+144]
	lea	r8d, DWORD PTR [r13+1]
	mov	r9d, eax
	xorps	xmm1, xmm1
	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR nbPerRank$3[rsp+16], rax
	mov	WORD PTR nbPerRank$3[rsp+24], ax
	mov	QWORD PTR valPerRank$4[rsp+16], rax
	mov	WORD PTR valPerRank$4[rsp+24], ax
	movups	XMMWORD PTR nbPerRank$3[rsp], xmm1
	movups	XMMWORD PTR valPerRank$4[rsp], xmm0

; 393  :         if (maxNbBits > HUF_TABLELOG_MAX) return ERROR(GENERIC);   /* check fit into table */

	cmp	r9d, 12
	ja	$LN113@HUF_buildC

; 394  :         for (n=0; n<=nonNullRank; n++)

	test	r15, r15
	js	SHORT $LN16@HUF_buildC
	lea	rcx, QWORD PTR [rbx+7]
	lea	rdx, QWORD PTR [r15+1]
	npad	11
$LL17@HUF_buildC:

; 395  :             nbPerRank[huffNode[n].nbBits]++;

	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+8]
	inc	WORD PTR nbPerRank$3[rsp+rax*2]
	sub	rdx, 1
	jne	SHORT $LL17@HUF_buildC
$LN16@HUF_buildC:

; 396  :         /* determine stating value per rank */
; 397  :         {   U16 min = 0;
; 398  :             for (n=(int)maxNbBits; n>0; n--) {

	movsxd	rdx, r9d
	movzx	ecx, di
	test	r9d, r9d
	jle	SHORT $LN19@HUF_buildC
	npad	3
$LL20@HUF_buildC:

; 399  :                 valPerRank[n] = min;      /* get starting value within each rank */

	mov	WORD PTR valPerRank$4[rsp+rdx*2], cx

; 400  :                 min += nbPerRank[n];

	add	cx, WORD PTR nbPerRank$3[rsp+rdx*2]
	dec	rdx

; 401  :                 min >>= 1;

	shr	cx, 1
	test	rdx, rdx
	jg	SHORT $LL20@HUF_buildC
$LN19@HUF_buildC:

; 402  :         }   }
; 403  :         for (n=0; n<alphabetSize; n++)

	movsxd	r8, r8d
	test	r8, r8
	jle	SHORT $LN25@HUF_buildC
	add	rbx, 6
	mov	rdx, r8
	npad	12
$LL23@HUF_buildC:

; 404  :             tree[huffNode[n].byte].nbBits = huffNode[n].nbBits;   /* push nbBits per symbol, symbol order */

	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+1]
	lea	rbx, QWORD PTR [rbx+8]
	mov	BYTE PTR [r14+rcx*4+2], al
	sub	rdx, 1
	jne	SHORT $LL23@HUF_buildC
	npad	10
$LL26@HUF_buildC:

; 405  :         for (n=0; n<alphabetSize; n++)
; 406  :             tree[n].val = valPerRank[tree[n].nbBits]++;   /* assign value within rank, symbol order */

	movzx	eax, BYTE PTR [r14+rdi*4+2]
	lea	rcx, QWORD PTR valPerRank$4[rsp]
	lea	rcx, QWORD PTR [rcx+rax*2]
	movzx	eax, WORD PTR [rcx]
	mov	WORD PTR [r14+rdi*4], ax
	inc	ax
	inc	rdi
	mov	WORD PTR [rcx], ax
	cmp	rdi, r8
	jl	SHORT $LL26@HUF_buildC
$LN25@HUF_buildC:

; 407  :     }
; 408  : 
; 409  :     return maxNbBits;

	mov	rax, r9
	jmp	SHORT $LN1@HUF_buildC
$LN113@HUF_buildC:

; 393  :         if (maxNbBits > HUF_TABLELOG_MAX) return ERROR(GENERIC);   /* check fit into table */

	mov	rax, -1
$LN1@HUF_buildC:

; 410  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
HUF_buildCTable_wksp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
CTable$ = 32
count$ = 40
maxSymbolValue$ = 48
HUF_estimateCompressedSize PROC

; 423  : {

$LN17:
	push	rbx
	push	r14
	push	r15
	xor	r10d, r10d
	mov	ebx, r8d
	mov	r15, rdx
	mov	r11d, r10d

; 424  :     size_t nbBits = 0;

	mov	r9d, r10d

; 425  :     int s;
; 426  :     for (s = 0; s <= (int)maxSymbolValue; ++s) {

	test	r8d, r8d
	js	$LN11@HUF_estima
	lea	eax, DWORD PTR [r8+1]
	mov	QWORD PTR [rsp+32], rbp
	cmp	eax, 2
	jl	SHORT $LC12@HUF_estima
	mov	QWORD PTR [rsp+40], rsi
	lea	rdx, QWORD PTR [rcx+6]
	mov	QWORD PTR [rsp+48], rdi
	mov	rax, r15
	sub	rax, rcx
	mov	QWORD PTR [rsp+56], r12
	inc	r8d
	shr	r8, 1
	lea	rdi, QWORD PTR [rax-2]
	lea	rsi, QWORD PTR [rax-6]
	lea	r12d, DWORD PTR [r8+r8]
	lea	rbp, QWORD PTR [r8+r8]
	npad	5
$LL14@HUF_estima:

; 427  :         nbBits += CTable[s].nbBits * count[s];

	movzx	eax, BYTE PTR [rdx-4]
	imul	eax, DWORD PTR [rsi+rdx]
	lea	rdx, QWORD PTR [rdx+8]
	add	r10, rax
	movzx	eax, BYTE PTR [rdx-8]
	imul	eax, DWORD PTR [rdi+rdx-8]
	add	r11, rax
	sub	r8, 1
	jne	SHORT $LL14@HUF_estima

; 425  :     int s;
; 426  :     for (s = 0; s <= (int)maxSymbolValue; ++s) {

	mov	rdi, QWORD PTR [rsp+48]
	cmp	r12d, ebx
	mov	r12, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+40]
	jle	SHORT $LL8@HUF_estima
	jmp	SHORT $LN13@HUF_estima
$LC12@HUF_estima:
	mov	rbp, r10
	npad	6
$LL8@HUF_estima:

; 427  :         nbBits += CTable[s].nbBits * count[s];

	movzx	r9d, BYTE PTR [rcx+rbp*4+2]
	imul	r9d, DWORD PTR [r15+rbp*4]
$LN13@HUF_estima:
	mov	rbp, QWORD PTR [rsp+32]
	lea	rcx, QWORD PTR [r11+r10]
	add	r9, rcx
$LN11@HUF_estima:

; 428  :     }
; 429  :     return nbBits >> 3;

	shr	r9, 3
	mov	rax, r9

; 430  : }

	pop	r15
	pop	r14
	pop	rbx
	ret	0
HUF_estimateCompressedSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
symbolTable$ = 8
symbolValue$ = 16
HUF_getNbBits PROC

; 202  :     const HUF_CElt* table = (const HUF_CElt*)symbolTable;
; 203  :     assert(symbolValue <= HUF_SYMBOLVALUE_MAX);
; 204  :     return table[symbolValue].nbBits;

	mov	eax, edx
	movzx	eax, BYTE PTR [rcx+rax*4+2]

; 205  : }

	ret	0
HUF_getNbBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write16 PROC

; 259  :     memcpy(memPtr, &value, sizeof(value));

	mov	WORD PTR [rcx], dx

; 260  : }

	ret	0
MEM_write16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write32 PROC

; 264  :     memcpy(memPtr, &value, sizeof(value));

	mov	DWORD PTR [rcx], edx

; 265  : }

	ret	0
MEM_write32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
value$ = 16
MEM_write64 PROC

; 269  :     memcpy(memPtr, &value, sizeof(value));

	mov	QWORD PTR [rcx], rdx

; 270  : }

	ret	0
MEM_write64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLE16 PROC

; 330  :     if (MEM_isLittleEndian()) {
; 331  :         MEM_write16(memPtr, val);

	mov	WORD PTR [rcx], dx

; 332  :     } else {
; 333  :         BYTE* p = (BYTE*)memPtr;
; 334  :         p[0] = (BYTE)val;
; 335  :         p[1] = (BYTE)(val>>8);
; 336  :     }
; 337  : }

	ret	0
MEM_writeLE16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val32$ = 16
MEM_writeLE32 PROC

; 360  :     if (MEM_isLittleEndian())
; 361  :         MEM_write32(memPtr, val32);

	mov	DWORD PTR [rcx], edx

; 362  :     else
; 363  :         MEM_write32(memPtr, MEM_swap32(val32));
; 364  : }

	ret	0
MEM_writeLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val64$ = 16
MEM_writeLE64 PROC

; 376  :     if (MEM_isLittleEndian())
; 377  :         MEM_write64(memPtr, val64);

	mov	QWORD PTR [rcx], rdx

; 378  :     else
; 379  :         MEM_write64(memPtr, MEM_swap64(val64));
; 380  : }

	ret	0
MEM_writeLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
val$ = 16
MEM_writeLEST PROC

; 392  :     if (MEM_32bits())
; 393  :         MEM_writeLE32(memPtr, (U32)val);
; 394  :     else
; 395  :         MEM_writeLE64(memPtr, (U64)val);

	mov	QWORD PTR [rcx], rdx

; 396  : }

	ret	0
MEM_writeLEST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
val$ = 8
BIT_highbit32 PROC

; 141  :     assert(val != 0);
; 142  :     {
; 143  : #   if defined(_MSC_VER)   /* Visual */
; 144  :         unsigned long r=0;

	xor	eax, eax

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 146  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* Use GCC Intrinsic */
; 147  :         return __builtin_clz (val) ^ 31;
; 148  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 149  :         return 31 - __CLZ(val);
; 150  : #   else   /* Software version */
; 151  :         static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,
; 152  :                                                  11, 14, 16, 18, 22, 25,  3, 30,
; 153  :                                                   8, 12, 20, 28, 15, 17, 24,  7,
; 154  :                                                  19, 27, 23,  6, 26,  5,  4, 31 };
; 155  :         U32 v = val;
; 156  :         v |= v >> 1;
; 157  :         v |= v >> 2;
; 158  :         v |= v >> 4;
; 159  :         v |= v >> 8;
; 160  :         v |= v >> 16;
; 161  :         return DeBruijnClz[ (U32) (v * 0x07C4ACDDU) >> 27];
; 162  : #   endif
; 163  :     }
; 164  : }

	ret	0
BIT_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
startPtr$ = 16
dstCapacity$ = 24
BIT_initCStream PROC

; 186  :     bitC->bitContainer = 0;

	xor	eax, eax

; 187  :     bitC->bitPos = 0;
; 188  :     bitC->startPtr = (char*)startPtr;

	mov	QWORD PTR [rcx+16], rdx

; 189  :     bitC->ptr = bitC->startPtr;

	mov	QWORD PTR [rcx+24], rdx

; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	add	rdx, -8
	add	rdx, r8
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	r8, 8
	mov	QWORD PTR [rcx+32], rdx
	mov	rcx, -70				; ffffffffffffffbaH
	cmovbe	rax, rcx

; 192  :     return 0;
; 193  : }

	ret	0
BIT_initCStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
value$ = 16
nbBits$ = 24
BIT_addBitsFast PROC

; 213  : {

	mov	r9, rcx

; 214  :     assert((value>>nbBits) == 0);
; 215  :     assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, DWORD PTR [rcx+8]
	shl	rdx, cl
	or	QWORD PTR [r9], rdx

; 217  :     bitC->bitPos += nbBits;

	lea	eax, DWORD PTR [rcx+r8]
	mov	DWORD PTR [r9+8], eax

; 218  : }

	ret	0
BIT_addBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_flushBits PROC

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	r8d, DWORD PTR [rcx+8]
	mov	r11, rcx

; 242  :     assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
; 243  :     assert(bitC->ptr <= bitC->endPtr);
; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rcx+24]
	mov	r9d, r8d
	mov	r10, QWORD PTR [rcx]
	shr	r9, 3
	mov	QWORD PTR [rax], r10

; 245  :     bitC->ptr += nbBytes;

	lea	rdx, QWORD PTR [rax+r9]

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	cmp	rdx, QWORD PTR [rcx+32]
	cmova	rdx, QWORD PTR [rcx+32]

; 247  :     bitC->bitPos &= 7;

	and	r8d, 7
	mov	DWORD PTR [rcx+8], r8d
	mov	QWORD PTR [rcx+24], rdx

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, r9b
	shl	cl, 3
	shr	r10, cl
	mov	QWORD PTR [r11], r10

; 249  : }

	ret	0
BIT_flushBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitC$ = 8
BIT_closeCStream PROC

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	eax, DWORD PTR [rcx+8]

; 255  : {

	mov	rdx, rcx

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	r9, QWORD PTR [rcx]
	bts	r9, rax

; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	mov	r11, QWORD PTR [rdx+32]

; 217  :     bitC->bitPos += nbBits;

	lea	r8d, DWORD PTR [rax+1]

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	rax, QWORD PTR [rdx+24]
	mov	ecx, r8d

; 245  :     bitC->ptr += nbBytes;
; 246  :     if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;

	and	r8d, 7
	shr	rcx, 3
	mov	DWORD PTR [rdx+8], r8d
	mov	QWORD PTR [rax], r9
	lea	r10, QWORD PTR [rax+rcx]
	shl	cl, 3
	shr	r9, cl
	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx], r9
	cmp	r10, r11
	jbe	SHORT $LN11@BIT_closeC
	mov	QWORD PTR [rdx+24], r11

; 256  :     BIT_addBitsFast(bitC, 1, 1);   /* endMark */
; 257  :     BIT_flushBits(bitC);
; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	xor	eax, eax

; 260  : }

	ret	0
$LN11@BIT_closeC:

; 256  :     BIT_addBitsFast(bitC, 1, 1);   /* endMark */
; 257  :     BIT_flushBits(bitC);
; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	jb	SHORT $LN2@BIT_closeC
	xor	eax, eax

; 260  : }

	ret	0
$LN2@BIT_closeC:

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	xor	eax, eax
	test	r8d, r8d
	setne	al
	sub	rax, QWORD PTR [rdx+16]
	add	rax, r10

; 260  : }

	ret	0
BIT_closeCStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\fse_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$GSCopy$1$ = 48
maxSymbolValue$ = 56
tableLog$1$ = 60
wtSize$GSCopy$1$ = 64
weightTable$GSCopy$1$ = 72
CTable$ = 80
norm$ = 320
scratchBuffer$ = 352
count$ = 352
__$ArrayPad$ = 416
dst$ = 512
dstSize$ = 520
weightTable$ = 528
wtSize$ = 536
HUF_compressWeights PROC

; 64   : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 456				; 000001c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR wtSize$GSCopy$1$[rsp], r9
	mov	rsi, r9
	mov	QWORD PTR weightTable$GSCopy$1$[rsp], r8
	mov	rbx, rdx
	mov	QWORD PTR dst$GSCopy$1$[rsp], rcx
	mov	r15, rcx

; 65   :     BYTE* const ostart = (BYTE*) dst;
; 66   :     BYTE* op = ostart;
; 67   :     BYTE* const oend = ostart + dstSize;
; 68   : 
; 69   :     unsigned maxSymbolValue = HUF_TABLELOG_MAX;

	mov	DWORD PTR maxSymbolValue$[rsp], 12
	lea	r13, QWORD PTR [rdx+rcx]

; 70   :     U32 tableLog = MAX_FSE_TABLELOG_FOR_HUFF_HEADER;
; 71   : 
; 72   :     FSE_CTable CTable[FSE_CTABLE_SIZE_U32(MAX_FSE_TABLELOG_FOR_HUFF_HEADER, HUF_TABLELOG_MAX)];
; 73   :     BYTE scratchBuffer[1<<MAX_FSE_TABLELOG_FOR_HUFF_HEADER];
; 74   : 
; 75   :     unsigned count[HUF_TABLELOG_MAX+1];
; 76   :     S16 norm[HUF_TABLELOG_MAX+1];
; 77   : 
; 78   :     /* init conditions */
; 79   :     if (wtSize <= 1) return 0;  /* Not compressible */

	cmp	r9, 1
	jbe	$LN129@HUF_compre

; 80   : 
; 81   :     /* Scan input and build symbol stats */
; 82   :     {   unsigned const maxCount = HIST_count_simple(count, &maxSymbolValue, weightTable, wtSize);   /* never fails */

	lea	rdx, QWORD PTR maxSymbolValue$[rsp]
	lea	rcx, QWORD PTR count$[rsp]
	call	HIST_count_simple

; 83   :         if (maxCount == wtSize) return 1;   /* only a single symbol in src : rle */

	mov	ecx, eax
	cmp	rcx, rsi
	jne	SHORT $LN3@HUF_compre
	mov	eax, 1
	jmp	$LN1@HUF_compre
$LN3@HUF_compre:

; 84   :         if (maxCount == 1) return 0;        /* each symbol present maximum once => not compressible */

	cmp	eax, 1
	je	$LN129@HUF_compre

; 85   :     }
; 86   : 
; 87   :     tableLog = FSE_optimalTableLog(tableLog, wtSize, maxSymbolValue);

	mov	r12d, DWORD PTR maxSymbolValue$[rsp]
	mov	rdx, rsi
	mov	r8d, r12d
	mov	ecx, 6
	call	FSE_optimalTableLog

; 88   :     CHECK_F( FSE_normalizeCount(norm, tableLog, count, wtSize, maxSymbolValue) );

	mov	r9, rsi
	mov	DWORD PTR tableLog$1$[rsp], eax
	mov	edx, eax
	mov	DWORD PTR [rsp+32], r12d
	lea	rcx, QWORD PTR norm$[rsp]
	mov	edi, eax
	lea	r8, QWORD PTR count$[rsp]
	call	FSE_normalizeCount
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 88   :     CHECK_F( FSE_normalizeCount(norm, tableLog, count, wtSize, maxSymbolValue) );

	ja	$LN1@HUF_compre
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 291  :     if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */

	cmp	edi, 12
	jbe	SHORT $LN14@HUF_compre
	mov	rax, -44				; ffffffffffffffd4H
	jmp	$LN1@HUF_compre
$LN14@HUF_compre:

; 292  :     if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */

	cmp	edi, 5
	jae	SHORT $LN15@HUF_compre
	mov	rax, -1
	jmp	$LN1@HUF_compre
$LN15@HUF_compre:
	mov	QWORD PTR [rsp+448], rbp

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	lea	r8d, DWORD PTR [rdi-5]
	mov	ecx, edi
	mov	QWORD PTR [rsp+440], r14

; 188  :     size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;

	lea	r14d, DWORD PTR [r12+1]

; 189  :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */

	mov	esi, 1
	shl	esi, cl
	lea	ebp, DWORD PTR [rdi+1]
	mov	edx, r14d
	mov	eax, 512				; 00000200H
	imul	edx, edi
	shr	edx, 3
	add	edx, 3
	test	r12d, r12d
	cmovne	eax, edx

; 294  :     if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))

	xor	r12d, r12d
	mov	ecx, r12d
	lea	r11d, QWORD PTR [r12+4]
	cmp	rbx, rax
	jae	$LN16@HUF_compre

; 198  :     BYTE* out = ostart;

	mov	rbx, r15

; 199  :     BYTE* const oend = ostart + headerBufferSize;
; 200  :     int nbBits;
; 201  :     const int tableSize = 1 << tableLog;
; 202  :     int remaining;
; 203  :     int threshold;
; 204  :     U32 bitStream = 0;
; 205  :     int bitCount = 0;
; 206  :     unsigned symbol = 0;
; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */

	lea	r15d, DWORD PTR [rsi+1]
	mov	edi, r12d

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	test	r14d, r14d
	je	$LN22@HUF_compre
$LL21@HUF_compre:
	cmp	r15d, 1
	jle	$LN131@HUF_compre

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN34@HUF_compre

; 221  :             unsigned start = symbol;

	mov	edx, edi

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	edi, r14d
	jae	SHORT $LN132@HUF_compre
	mov	eax, edi
	lea	rcx, QWORD PTR norm$[rsp]
	lea	rcx, QWORD PTR [rcx+rax*2]
	npad	3
$LL23@HUF_compre:
	cmp	WORD PTR [rcx], r12w
	jne	SHORT $LN128@HUF_compre
	inc	edi
	add	rcx, 2
	cmp	edi, r14d
	jb	SHORT $LL23@HUF_compre
$LN132@HUF_compre:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN92@HUF_compre
$LN128@HUF_compre:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	edi, r9d
	jb	SHORT $LN111@HUF_compre
	mov	ecx, r11d
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
	lea	rcx, QWORD PTR [r13-2]
$LL25@HUF_compre:

; 225  :                 start+=24;

	add	edx, 24
	add	r9d, 24

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r8d, r10d

; 227  :                 if ((!writeIsSafe) && (out > oend-2))

	cmp	rbx, rcx
	ja	$LN86@HUF_compre

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rbx], r8b
	shr	eax, 8
	mov	BYTE PTR [rbx+1], al

; 231  :                 out+=2;

	add	rbx, 2

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	cmp	edi, r9d
	jae	SHORT $LL25@HUF_compre
$LN111@HUF_compre:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	edi, r9d
	jb	SHORT $LN28@HUF_compre
	npad	11
$LL27@HUF_compre:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, r11d
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	r11d, 2
	cmp	r9d, edi
	jbe	SHORT $LL27@HUF_compre
$LN28@HUF_compre:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, r11d
	mov	eax, edi
	sub	eax, edx

; 240  :             bitCount += 2;

	add	r11d, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN34@HUF_compre

; 242  :                 if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	cmp	rbx, rax
	ja	$LN86@HUF_compre

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rbx], r8b
	shr	eax, 8
	mov	BYTE PTR [rbx+1], al

; 246  :                 out += 2;

	add	rbx, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	r11d, 16
$LN34@HUF_compre:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	mov	eax, edi

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r10d, DWORD PTR [rsi+rsi]
	sub	r10d, r15d
	inc	edi
	movsx	ecx, WORD PTR norm$[rsp+rax*2]

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	lea	r9d, DWORD PTR [r10-1]
	cdq
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	mov	eax, 1
	cmovl	r10d, eax
	add	r10d, ecx
	mov	ecx, r11d
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	mov	ecx, r12d
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	mov	ecx, r12d
	add	r11d, eax
	cmp	r10d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	$LN92@HUF_compre

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, esi
	jge	SHORT $LN30@HUF_compre
	npad	2
$LL29@HUF_compre:
	dec	ebp
	sar	esi, 1
	cmp	r15d, esi
	jl	SHORT $LL29@HUF_compre
$LN30@HUF_compre:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN124@HUF_compre

; 264  :             if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	cmp	rbx, rax
	ja	SHORT $LN86@HUF_compre

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rbx], r8b
	shr	eax, 8
	mov	BYTE PTR [rbx+1], al

; 268  :             out += 2;

	add	rbx, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	r11d, 16
$LN124@HUF_compre:

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	edi, r14d
	jb	$LL21@HUF_compre
$LN22@HUF_compre:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN131@HUF_compre:
	mov	rsi, QWORD PTR dst$GSCopy$1$[rsp]
	je	SHORT $LN40@HUF_compre

; 274  :         return ERROR(GENERIC);  /* incorrect normalized distribution */

	mov	rax, -1
	jmp	$LN43@HUF_compre
$LN86@HUF_compre:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rsi, QWORD PTR dst$GSCopy$1$[rsp]
	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN43@HUF_compre
$LN40@HUF_compre:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 278  :     if ((!writeIsSafe) && (out > oend - 2))

	lea	rax, QWORD PTR [r13-2]
	cmp	rbx, rax
	jbe	SHORT $LN41@HUF_compre

; 279  :         return ERROR(dstSize_tooSmall);   /* Buffer overflow */

	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN43@HUF_compre
$LN41@HUF_compre:

; 280  :     out[0] = (BYTE)bitStream;
; 281  :     out[1] = (BYTE)(bitStream>>8);
; 282  :     out+= (bitCount+7) /8;

	lea	eax, DWORD PTR [r11+7]
	mov	BYTE PTR [rbx], r8b
	cdq
	shr	r8d, 8
	and	edx, 7
	mov	BYTE PTR [rbx+1], r8b
	add	eax, edx
	sar	eax, 3

; 284  :     return (out-ostart);

	cdqe
	sub	rax, rsi
	add	rax, rbx

; 295  :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);

	jmp	$LN43@HUF_compre
$LN16@HUF_compre:

; 198  :     BYTE* out = ostart;

	mov	rdi, r15

; 199  :     BYTE* const oend = ostart + headerBufferSize;
; 200  :     int nbBits;
; 201  :     const int tableSize = 1 << tableLog;
; 202  :     int remaining;
; 203  :     int threshold;
; 204  :     U32 bitStream = 0;
; 205  :     int bitCount = 0;
; 206  :     unsigned symbol = 0;
; 207  :     unsigned const alphabetSize = maxSymbolValue + 1;
; 208  :     int previousIs0 = 0;
; 209  : 
; 210  :     /* Table Size */
; 211  :     bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
; 212  :     bitCount  += 4;
; 213  : 
; 214  :     /* Init */
; 215  :     remaining = tableSize+1;   /* +1 for extra accuracy */

	lea	r15d, DWORD PTR [rsi+1]
	mov	ebx, r12d

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	test	r14d, r14d
	je	$LN45@HUF_compre
	npad	2
$LL44@HUF_compre:
	cmp	r15d, 1
	jle	$LN133@HUF_compre

; 220  :         if (previousIs0) {

	test	ecx, ecx
	je	$LN57@HUF_compre

; 221  :             unsigned start = symbol;

	mov	edx, ebx

; 222  :             while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;

	cmp	ebx, r14d
	jae	SHORT $LN134@HUF_compre
	mov	eax, ebx
	lea	rcx, QWORD PTR norm$[rsp]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LL46@HUF_compre:
	cmp	WORD PTR [rcx], r12w
	jne	SHORT $LN126@HUF_compre
	inc	ebx
	add	rcx, 2
	cmp	ebx, r14d
	jb	SHORT $LL46@HUF_compre
$LN134@HUF_compre:

; 223  :             if (symbol == alphabetSize) break;   /* incorrect distribution */

	je	$LN92@HUF_compre
$LN126@HUF_compre:

; 224  :             while (symbol >= start+24) {

	lea	r9d, DWORD PTR [rdx+24]
	cmp	ebx, r9d
	jb	SHORT $LN84@HUF_compre
	mov	ecx, r11d
	mov	r10d, 65535				; 0000ffffH
	shl	r10d, cl
	npad	13
$LL48@HUF_compre:

; 226  :                 bitStream += 0xFFFFU << bitCount;

	add	r8d, r10d
	add	edx, 24

; 228  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 229  :                 out[0] = (BYTE) bitStream;
; 230  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rdi], r8b
	shr	eax, 8
	add	r9d, 24
	mov	BYTE PTR [rdi+1], al

; 231  :                 out+=2;

	add	rdi, 2

; 232  :                 bitStream>>=16;

	shr	r8d, 16
	cmp	r9d, ebx
	jbe	SHORT $LL48@HUF_compre
$LN84@HUF_compre:

; 233  :             }
; 234  :             while (symbol >= start+3) {

	lea	r9d, DWORD PTR [rdx+3]
	cmp	ebx, r9d
	jb	SHORT $LN51@HUF_compre
	npad	4
$LL50@HUF_compre:

; 235  :                 start+=3;
; 236  :                 bitStream += 3 << bitCount;

	mov	ecx, r11d
	mov	eax, 3
	shl	eax, cl
	add	edx, 3
	add	r8d, eax
	add	r9d, 3

; 237  :                 bitCount += 2;

	add	r11d, 2
	cmp	r9d, ebx
	jbe	SHORT $LL50@HUF_compre
$LN51@HUF_compre:

; 238  :             }
; 239  :             bitStream += (symbol-start) << bitCount;

	mov	ecx, r11d
	mov	eax, ebx
	sub	eax, edx

; 240  :             bitCount += 2;

	add	r11d, 2
	shl	eax, cl
	add	r8d, eax

; 241  :             if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN57@HUF_compre

; 243  :                     return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 244  :                 out[0] = (BYTE)bitStream;
; 245  :                 out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rdi], r8b
	shr	eax, 8
	mov	BYTE PTR [rdi+1], al

; 246  :                 out += 2;

	add	rdi, 2

; 247  :                 bitStream >>= 16;

	shr	r8d, 16

; 248  :                 bitCount -= 16;

	sub	r11d, 16
$LN57@HUF_compre:

; 249  :         }   }
; 250  :         {   int count = normalizedCounter[symbol++];

	mov	eax, ebx

; 251  :             int const max = (2*threshold-1) - remaining;

	lea	r10d, DWORD PTR [rsi+rsi]
	sub	r10d, r15d
	inc	ebx
	movsx	ecx, WORD PTR norm$[rsp+rax*2]

; 252  :             remaining -= count < 0 ? -count : count;

	mov	eax, ecx
	lea	r9d, DWORD PTR [r10-1]
	cdq
	xor	eax, edx
	sub	eax, edx
	sub	r15d, eax
	lea	eax, DWORD PTR [rcx+1]

; 253  :             count++;   /* +1 for extra accuracy */
; 254  :             if (count>=threshold)
; 255  :                 count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
; 256  :             bitStream += count << bitCount;

	cmp	eax, esi
	mov	eax, 1
	cmovl	r10d, eax
	add	r10d, ecx
	mov	ecx, r11d
	mov	eax, r10d
	shl	eax, cl

; 257  :             bitCount  += nbBits;
; 258  :             bitCount  -= (count<max);

	mov	ecx, r12d
	add	r8d, eax
	mov	eax, ebp
	cmp	r10d, r9d
	setl	cl
	sub	eax, ecx

; 259  :             previousIs0  = (count==1);

	mov	ecx, r12d
	add	r11d, eax
	cmp	r10d, 1
	sete	cl

; 260  :             if (remaining<1) return ERROR(GENERIC);

	cmp	r15d, 1
	jl	SHORT $LN92@HUF_compre

; 261  :             while (remaining<threshold) { nbBits--; threshold>>=1; }

	cmp	r15d, esi
	jge	SHORT $LN53@HUF_compre
	npad	3
$LL52@HUF_compre:
	dec	ebp
	sar	esi, 1
	cmp	r15d, esi
	jl	SHORT $LL52@HUF_compre
$LN53@HUF_compre:

; 262  :         }
; 263  :         if (bitCount>16) {

	cmp	r11d, 16
	jle	SHORT $LN61@HUF_compre

; 265  :                 return ERROR(dstSize_tooSmall);   /* Buffer overflow */
; 266  :             out[0] = (BYTE)bitStream;
; 267  :             out[1] = (BYTE)(bitStream>>8);

	mov	eax, r8d
	mov	BYTE PTR [rdi], r8b
	shr	eax, 8
	mov	BYTE PTR [rdi+1], al

; 268  :             out += 2;

	add	rdi, 2

; 269  :             bitStream >>= 16;

	shr	r8d, 16

; 270  :             bitCount -= 16;

	sub	r11d, 16
$LN61@HUF_compre:

; 216  :     threshold = tableSize;
; 217  :     nbBits = tableLog+1;
; 218  : 
; 219  :     while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */

	cmp	ebx, r14d
	jb	$LL44@HUF_compre
$LN45@HUF_compre:

; 271  :     }   }
; 272  : 
; 273  :     if (remaining != 1)

	cmp	r15d, 1
$LN133@HUF_compre:
	je	SHORT $LN63@HUF_compre
$LN92@HUF_compre:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rsi, QWORD PTR dst$GSCopy$1$[rsp]
	mov	rax, -1
	jmp	SHORT $LN43@HUF_compre
$LN63@HUF_compre:
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 284  :     return (out-ostart);

	mov	rsi, QWORD PTR dst$GSCopy$1$[rsp]
	lea	eax, DWORD PTR [r11+7]
	cdq
	mov	BYTE PTR [rdi], r8b
	and	edx, 7
	shr	r8d, 8
	add	eax, edx
	mov	BYTE PTR [rdi+1], r8b
	sar	eax, 3
	cdqe
	sub	rax, rsi
	add	rax, rdi
$LN43@HUF_compre:
	mov	r14, QWORD PTR [rsp+440]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rbp, QWORD PTR [rsp+448]
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 91   :     {   CHECK_V_F(hSize, FSE_writeNCount(op, (size_t)(oend-op), norm, maxSymbolValue, tableLog) );

	ja	$LN1@HUF_compre

; 96   :     CHECK_F( FSE_buildCTable_wksp(CTable, norm, maxSymbolValue, tableLog, scratchBuffer, sizeof(scratchBuffer)) );

	mov	r9d, DWORD PTR tableLog$1$[rsp]
	lea	rbx, QWORD PTR [rsi+rax]
	mov	r8d, DWORD PTR maxSymbolValue$[rsp]
	lea	rax, QWORD PTR scratchBuffer$[rsp]
	mov	QWORD PTR [rsp+40], 64			; 00000040H
	lea	rdx, QWORD PTR norm$[rsp]
	lea	rcx, QWORD PTR CTable$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	FSE_buildCTable_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 96   :     CHECK_F( FSE_buildCTable_wksp(CTable, norm, maxSymbolValue, tableLog, scratchBuffer, sizeof(scratchBuffer)) );

	ja	SHORT $LN1@HUF_compre
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 617  :     unsigned const fast = (dstSize >= FSE_BLOCKBOUND(srcSize));

	mov	r9, QWORD PTR wtSize$GSCopy$1$[rsp]
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 97   :     {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, CTable) );

	sub	r13, rbx
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	r8, QWORD PTR weightTable$GSCopy$1$[rsp]
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 617  :     unsigned const fast = (dstSize >= FSE_BLOCKBOUND(srcSize));

	mov	rax, r9
	shr	rax, 7
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	rdx, r13
; File E:\dev\pyzstd\lib\compress\fse_compress.c

; 617  :     unsigned const fast = (dstSize >= FSE_BLOCKBOUND(srcSize));

	lea	rcx, QWORD PTR [r9+12]
	add	rcx, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	lea	rax, QWORD PTR CTable$[rsp]
	cmp	r13, rcx
	mov	rcx, rbx
	setae	r12b
	mov	DWORD PTR [rsp+40], r12d
	mov	QWORD PTR [rsp+32], rax
	call	FSE_compress_usingCTable_generic
	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 97   :     {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, CTable) );

	ja	SHORT $LN1@HUF_compre

; 98   :         if (cSize == 0) return 0;   /* not enough space for compressed data */

	test	rax, rax
	je	SHORT $LN129@HUF_compre

; 99   :         op += cSize;
; 100  :     }
; 101  : 
; 102  :     return (size_t)(op-ostart);

	sub	rax, rsi
	add	rax, rbx
	jmp	SHORT $LN1@HUF_compre
$LN129@HUF_compre:

; 98   :         if (cSize == 0) return 0;   /* not enough space for compressed data */

	xor	eax, eax
$LN1@HUF_compre:

; 103  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 456				; 000001c8H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
HUF_compressWeights ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
rankLast$1 = 8
__$ArrayPad$ = 64
huffNode$ = 128
lastNonNull$ = 136
maxNbBits$ = 144
HUF_setMaxHeight PROC

; 216  : {

	push	rbx
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebx, r8d
	movsxd	r9, edx

; 217  :     const U32 largestBits = huffNode[lastNonNull].nbBits;

	mov	eax, r9d
	mov	r11, rcx
	movzx	r8d, BYTE PTR [rcx+rax*8+7]

; 218  :     if (largestBits <= maxNbBits) return largestBits;   /* early exit : no elt > maxNbBits */

	cmp	r8d, ebx
	ja	SHORT $LN20@HUF_setMax
	mov	eax, r8d

; 291  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
$LN20@HUF_setMax:
	mov	QWORD PTR [rsp+152], rbp

; 219  : 
; 220  :     /* there are several too large elements (at least >= 2) */
; 221  :     {   int totalCost = 0;
; 222  :         const U32 baseCost = 1 << (largestBits - maxNbBits);
; 223  :         int n = (int)lastNonNull;
; 224  : 
; 225  :         while (huffNode[n].nbBits > maxNbBits) {

	mov	r10, r9
	mov	QWORD PTR [rsp+104], rsi
	mov	ebp, 1
	mov	QWORD PTR [rsp+96], rdi
	lea	rsi, QWORD PTR [r11+7]
	mov	QWORD PTR [rsp+88], r14
	lea	rsi, QWORD PTR [rsi+r9*8]
	mov	r14d, r8d
	mov	QWORD PTR [rsp+80], r15
	sub	r14d, ebx
	xor	r15d, r15d
	mov	ecx, r14d
	mov	edi, r15d
	shl	ebp, cl
	movzx	ecx, BYTE PTR [rsi]
	cmp	ecx, ebx
	jbe	SHORT $LN35@HUF_setMax
	npad	10
$LL2@HUF_setMax:

; 226  :             totalCost += baseCost - (1 << (largestBits - huffNode[n].nbBits));

	movzx	eax, cl

; 227  :             huffNode[n].nbBits = (BYTE)maxNbBits;
; 228  :             n --;

	lea	r10, QWORD PTR [r10-1]
	mov	BYTE PTR [rsi], bl
	mov	ecx, r8d
	sub	ecx, eax
	lea	rsi, QWORD PTR [r11+7]
	mov	edx, 1
	lea	rsi, QWORD PTR [rsi+r10*8]
	shl	edx, cl
	mov	eax, ebp
	sub	eax, edx
	dec	r9d
	add	edi, eax
	movzx	eax, BYTE PTR [rsi]
	movzx	ecx, al
	cmp	eax, ebx
	ja	SHORT $LL2@HUF_setMax
$LN35@HUF_setMax:

; 229  :         }  /* n stops at huffNode[n].nbBits <= maxNbBits */
; 230  :         while (huffNode[n].nbBits == maxNbBits) n--;   /* n end at index of smallest symbol using < maxNbBits */

	mov	rsi, QWORD PTR [rsp+104]
	lea	rdx, QWORD PTR [r11+7]
	mov	rbp, QWORD PTR [rsp+152]
	movsxd	rax, r9d
	lea	rdx, QWORD PTR [rdx+rax*8]
	movzx	eax, BYTE PTR [rdx]
	cmp	eax, ebx
	jne	SHORT $LN5@HUF_setMax
	npad	1
$LL4@HUF_setMax:
	movzx	eax, BYTE PTR [rdx-8]
	lea	rdx, QWORD PTR [rdx-8]
	dec	r9d
	cmp	eax, ebx
	je	SHORT $LL4@HUF_setMax
$LN5@HUF_setMax:

; 231  : 
; 232  :         /* renorm totalCost */
; 233  :         totalCost >>= (largestBits - maxNbBits);  /* note : totalCost is necessarily a multiple of baseCost */
; 234  : 
; 235  :         /* repay normalized cost */
; 236  :         {   U32 const noSymbol = 0xF0F0F0F0;
; 237  :             U32 rankLast[HUF_TABLELOG_MAX+2];
; 238  : 
; 239  :             /* Get pos of last (smallest) symbol per rank */
; 240  :             memset(rankLast, 0xF0, sizeof(rankLast));

	movdqa	xmm0, XMMWORD PTR __xmm@f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0
	mov	ecx, r14d

; 241  :             {   U32 currentNbBits = maxNbBits;
; 242  :                 int pos;
; 243  :                 for (pos=n ; pos >= 0; pos--) {

	mov	r14, QWORD PTR [rsp+88]
	mov	r8d, ebx
	sar	edi, cl
	mov	ecx, r9d
	movq	QWORD PTR rankLast$1[rsp+48], xmm0
	movups	XMMWORD PTR rankLast$1[rsp], xmm0
	movups	XMMWORD PTR rankLast$1[rsp+16], xmm0
	movups	XMMWORD PTR rankLast$1[rsp+32], xmm0
	test	r9d, r9d
	js	SHORT $LN37@HUF_setMax
	movsxd	rax, r9d
	lea	rdx, QWORD PTR [r11+7]
	lea	rdx, QWORD PTR [rdx+rax*8]
	npad	4
$LL8@HUF_setMax:

; 244  :                     if (huffNode[pos].nbBits >= currentNbBits) continue;

	movzx	eax, BYTE PTR [rdx]
	cmp	eax, r8d
	jae	SHORT $LN6@HUF_setMax

; 245  :                     currentNbBits = huffNode[pos].nbBits;   /* < maxNbBits */

	mov	r8d, eax

; 246  :                     rankLast[maxNbBits-currentNbBits] = (U32)pos;

	mov	eax, ebx
	sub	eax, r8d
	mov	DWORD PTR rankLast$1[rsp+rax*4], ecx
$LN6@HUF_setMax:

; 241  :             {   U32 currentNbBits = maxNbBits;
; 242  :                 int pos;
; 243  :                 for (pos=n ; pos >= 0; pos--) {

	sub	rdx, 8
	sub	ecx, 1
	jns	SHORT $LL8@HUF_setMax
$LN37@HUF_setMax:

; 247  :             }   }
; 248  : 
; 249  :             while (totalCost > 0) {

	test	edi, edi
	jle	$LN40@HUF_setMax
	npad	11
$LL9@HUF_setMax:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, edi
	mov	eax, r15d
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 250  :                 U32 nBitsToDecrease = BIT_highbit32((U32)totalCost) + 1;

	inc	eax

; 251  :                 for ( ; nBitsToDecrease > 1; nBitsToDecrease--) {

	cmp	eax, 1
	jbe	SHORT $LN71@HUF_setMax
	lea	r8, QWORD PTR rankLast$1[rsp]
	lea	r8, QWORD PTR [r8+rax*4]
	npad	7
$LL13@HUF_setMax:

; 252  :                     U32 const highPos = rankLast[nBitsToDecrease];

	mov	r10d, DWORD PTR [r8]

; 254  :                     if (highPos == noSymbol) continue;

	cmp	r10d, -252645136			; f0f0f0f0H
	je	SHORT $LN11@HUF_setMax

; 253  :                     U32 const lowPos = rankLast[nBitsToDecrease-1];

	lea	ecx, DWORD PTR [rax-1]
	mov	ecx, DWORD PTR rankLast$1[rsp+rcx*4]

; 255  :                     if (lowPos == noSymbol) break;

	cmp	ecx, -252645136				; f0f0f0f0H
	je	SHORT $LN71@HUF_setMax

; 256  :                     {   U32 const highTotal = huffNode[highPos].count;
; 257  :                         U32 const lowTotal = 2 * huffNode[lowPos].count;

	mov	edx, DWORD PTR [r11+rcx*8]
	add	edx, edx

; 258  :                         if (highTotal <= lowTotal) break;

	cmp	DWORD PTR [r11+r10*8], edx
	jbe	SHORT $LN71@HUF_setMax
$LN11@HUF_setMax:

; 251  :                 for ( ; nBitsToDecrease > 1; nBitsToDecrease--) {

	dec	eax
	sub	r8, 4
	cmp	eax, 1
	ja	SHORT $LL13@HUF_setMax
$LN71@HUF_setMax:

; 259  :                 }   }
; 260  :                 /* only triggered when no more rank 1 symbol left => find closest one (note : there is necessarily at least one !) */
; 261  :                 /* HUF_MAX_TABLELOG test just to please gcc 5+; but it should not be necessary */
; 262  :                 while ((nBitsToDecrease<=HUF_TABLELOG_MAX) && (rankLast[nBitsToDecrease] == noSymbol))

	cmp	eax, 12
	ja	SHORT $LN72@HUF_setMax
	npad	9
$LL14@HUF_setMax:
	cmp	DWORD PTR rankLast$1[rsp+rax*4], -252645136 ; f0f0f0f0H
	jne	SHORT $LN72@HUF_setMax

; 263  :                     nBitsToDecrease ++;

	inc	eax
	cmp	eax, 12
	jbe	SHORT $LL14@HUF_setMax
$LN72@HUF_setMax:

; 264  :                 totalCost -= 1 << (nBitsToDecrease-1);

	lea	ecx, DWORD PTR [rax-1]
	mov	edx, -1
	shl	edx, cl

; 265  :                 if (rankLast[nBitsToDecrease-1] == noSymbol)

	lea	r8, QWORD PTR rankLast$1[rsp]
	add	edi, edx
	lea	r8, QWORD PTR [r8+rcx*4]
	cmp	DWORD PTR [r8], -252645136		; f0f0f0f0H
	mov	edx, eax
	jne	SHORT $LN60@HUF_setMax

; 266  :                     rankLast[nBitsToDecrease-1] = rankLast[nBitsToDecrease];   /* this rank is no longer empty */

	mov	ecx, DWORD PTR rankLast$1[rsp+rax*4]
	mov	DWORD PTR [r8], ecx
$LN60@HUF_setMax:

; 267  :                 huffNode[rankLast[nBitsToDecrease]].nbBits ++;

	lea	r8, QWORD PTR rankLast$1[rsp]
	mov	ecx, DWORD PTR [r8+rdx*4]
	lea	r8, QWORD PTR [r8+rdx*4]
	inc	BYTE PTR [r11+rcx*8+7]

; 268  :                 if (rankLast[nBitsToDecrease] == 0)    /* special case, reached largest symbol */

	test	ecx, ecx
	je	SHORT $LN70@HUF_setMax

; 269  :                     rankLast[nBitsToDecrease] = noSymbol;
; 270  :                 else {
; 271  :                     rankLast[nBitsToDecrease]--;

	dec	ecx
	mov	DWORD PTR [r8], ecx

; 272  :                     if (huffNode[rankLast[nBitsToDecrease]].nbBits != maxNbBits-nBitsToDecrease)

	movzx	edx, BYTE PTR [r11+rcx*8+7]
	mov	ecx, ebx
	sub	ecx, eax
	cmp	edx, ecx
	je	SHORT $LN28@HUF_setMax
$LN70@HUF_setMax:

; 273  :                         rankLast[nBitsToDecrease] = noSymbol;   /* this rank is now empty */

	mov	DWORD PTR [r8], -252645136		; f0f0f0f0H
$LN28@HUF_setMax:

; 247  :             }   }
; 248  : 
; 249  :             while (totalCost > 0) {

	test	edi, edi
	jg	$LL9@HUF_setMax
$LN40@HUF_setMax:
	mov	r15, QWORD PTR [rsp+80]

; 274  :             }   }   /* while (totalCost > 0) */
; 275  : 
; 276  :             while (totalCost < 0) {  /* Sometimes, cost correction overshoot */

	test	edi, edi
	jns	SHORT $LN17@HUF_setMax
	mov	eax, DWORD PTR rankLast$1[rsp+4]
	movsxd	rdx, r9d
$LL16@HUF_setMax:

; 277  :                 if (rankLast[1] == noSymbol) {  /* special case : no rank 1 symbol (using maxNbBits-1); let's create one from largest rank 0 (using maxNbBits) */

	cmp	eax, -252645136				; f0f0f0f0H
	jne	SHORT $LN29@HUF_setMax

; 278  :                     while (huffNode[n].nbBits == maxNbBits) n--;

	lea	rcx, QWORD PTR [r11+7]
	movzx	eax, BYTE PTR [rcx+rdx*8]
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	eax, ebx
	jne	SHORT $LN19@HUF_setMax
	npad	9
$LL18@HUF_setMax:
	movzx	eax, BYTE PTR [rcx-8]
	lea	rcx, QWORD PTR [rcx-8]
	dec	r9d
	dec	rdx
	cmp	eax, ebx
	je	SHORT $LL18@HUF_setMax
$LN19@HUF_setMax:

; 279  :                     huffNode[n+1].nbBits--;

	dec	BYTE PTR [r11+rdx*8+15]

; 280  :                     assert(n >= 0);
; 281  :                     rankLast[1] = (U32)(n+1);

	lea	eax, DWORD PTR [r9+1]

; 282  :                     totalCost++;
; 283  :                     continue;

	jmp	SHORT $LN50@HUF_setMax
$LN29@HUF_setMax:

; 284  :                 }
; 285  :                 huffNode[ rankLast[1] + 1 ].nbBits--;

	inc	eax
	dec	BYTE PTR [r11+rax*8+7]
$LN50@HUF_setMax:

; 274  :             }   }   /* while (totalCost > 0) */
; 275  : 
; 276  :             while (totalCost < 0) {  /* Sometimes, cost correction overshoot */

	add	edi, 1
	js	SHORT $LL16@HUF_setMax
$LN17@HUF_setMax:

; 286  :                 rankLast[1]++;
; 287  :                 totalCost ++;
; 288  :     }   }   }   /* there are several too large elements (at least >= 2) */
; 289  : 
; 290  :     return maxNbBits;

	mov	rdi, QWORD PTR [rsp+96]
	mov	eax, ebx

; 291  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
HUF_setMaxHeight ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
huffNode$ = 64
count$ = 72
maxSymbolValue$ = 80
rankPosition$ = 88
HUF_sort PROC

; 308  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	esi, r8d
	mov	r14, rdx
	mov	rbx, rcx

; 309  :     U32 n;
; 310  : 
; 311  :     memset(rankPosition, 0, sizeof(*rankPosition) * RANK_POSITION_TABLE_SIZE);

	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	rcx, r9
	mov	rdi, r9
	call	memset

; 312  :     for (n=0; n<=maxSymbolValue; n++) {

	xor	ebp, ebp
	mov	r10d, ebp
	npad	13
$LL4@HUF_sort:

; 313  :         U32 r = BIT_highbit32(count[n] + 1);

	mov	eax, r10d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	ecx, ebp
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 313  :         U32 r = BIT_highbit32(count[n] + 1);

	mov	r9d, DWORD PTR [r14+rax*4]
	inc	r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r9d
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 312  :     for (n=0; n<=maxSymbolValue; n++) {

	inc	r10d

; 314  :         rankPosition[r].base ++;

	inc	DWORD PTR [rdi+rcx*8]
	cmp	r10d, esi
	jbe	SHORT $LL4@HUF_sort

; 315  :     }
; 316  :     for (n=30; n>0; n--) rankPosition[n-1].base += rankPosition[n].base;

	mov	edx, 30
	lea	rcx, QWORD PTR [rdi+232]
	npad	6
$LL7@HUF_sort:
	mov	eax, DWORD PTR [rcx+8]
	add	DWORD PTR [rcx], eax
	lea	rcx, QWORD PTR [rcx-8]
	add	edx, -1					; ffffffffH
	jne	SHORT $LL7@HUF_sort

; 317  :     for (n=0; n<32; n++) rankPosition[n].current = rankPosition[n].base;

	mov	rcx, rdi
	mov	edx, 32					; 00000020H
	npad	10
$LL10@HUF_sort:
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rcx+4], eax
	lea	rcx, QWORD PTR [rcx+8]
	sub	rdx, 1
	jne	SHORT $LL10@HUF_sort

; 318  :     for (n=0; n<=maxSymbolValue; n++) {

	mov	r10d, ebp
	npad	14
$LL13@HUF_sort:

; 319  :         U32 const c = count[n];

	mov	eax, r10d
	mov	r9d, DWORD PTR [r14+rax*4]

; 320  :         U32 const r = BIT_highbit32(c+1) + 1;

	lea	eax, DWORD PTR [r9+1]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	mov	eax, ebp
	cmovne	eax, ecx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 320  :         U32 const r = BIT_highbit32(c+1) + 1;

	inc	eax

; 321  :         U32 pos = rankPosition[r].current++;

	lea	r11, QWORD PTR [rdi+rax*8]
	mov	eax, DWORD PTR [rdi+rax*8+4]
	lea	ecx, DWORD PTR [rax+1]
	mov	DWORD PTR [r11+4], ecx

; 322  :         while ((pos > rankPosition[r].base) && (c > huffNode[pos-1].count)) {

	cmp	eax, DWORD PTR [r11]
	jbe	SHORT $LN41@HUF_sort
	npad	7
$LL14@HUF_sort:
	lea	edx, DWORD PTR [rax-1]
	cmp	r9d, DWORD PTR [rbx+rdx*8]
	lea	r8, QWORD PTR [rbx+rdx*8]
	jbe	SHORT $LN41@HUF_sort

; 323  :             huffNode[pos] = huffNode[pos-1];

	mov	ecx, eax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rbx+rcx*8], rax

; 324  :             pos--;

	mov	eax, edx
	cmp	edx, DWORD PTR [r11]
	ja	SHORT $LL14@HUF_sort
$LN41@HUF_sort:

; 325  :         }
; 326  :         huffNode[pos].count = c;

	mov	ecx, eax

; 327  :         huffNode[pos].byte  = (BYTE)n;

	mov	BYTE PTR [rbx+rcx*8+6], r10b
	inc	r10d
	mov	DWORD PTR [rbx+rcx*8], r9d
	cmp	r10d, esi
	jbe	SHORT $LL13@HUF_sort

; 328  :     }
; 329  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
HUF_sort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
workspace$ = 48
__$ArrayPad$ = 4400
tree$ = 4432
count$ = 4440
maxSymbolValue$dead$ = 4448
maxNbBits$dead$ = 4456
HUF_buildCTable PROC

; 417  : {

$LN4:
	mov	eax, 4424				; 00001148H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 418  :     HUF_buildCTable_wksp_tables workspace;
; 419  :     return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));

	lea	rax, QWORD PTR workspace$[rsp]
	mov	QWORD PTR [rsp+40], 4352		; 00001100H
	mov	r9d, 11
	mov	QWORD PTR [rsp+32], rax
	mov	r8d, 255				; 000000ffH
	call	HUF_buildCTable_wksp

; 420  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4424				; 00001148H
	ret	0
HUF_buildCTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
bitCPtr$ = 8
symbol$ = 16
CTable$ = 24
HUF_encodeSymbol PROC

; 445  : {

	mov	r9, rcx

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	mov	eax, edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, DWORD PTR [rcx+8]
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	lea	rdx, QWORD PTR [r8+rax*4]
	movzx	eax, WORD PTR [r8+rax*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	shl	rax, cl
	or	QWORD PTR [r9], rax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	eax, BYTE PTR [rdx+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 217  :     bitC->bitPos += nbBits;

	add	eax, ecx
	mov	DWORD PTR [r9+8], eax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 447  : }

	ret	0
HUF_encodeSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 64
tv1443 = 72
dstSize$ = 72
bitC$$sroa$592$1$ = 80
src$ = 80
srcSize$ = 88
CTable$ = 96
HUF_compress1X_usingCTable_internal_body PROC

; 461  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 24
	mov	rsi, r8
	mov	rbx, rcx

; 462  :     const BYTE* ip = (const BYTE*) src;
; 463  :     BYTE* const ostart = (BYTE*)dst;
; 464  :     BYTE* const oend = ostart + dstSize;
; 465  :     BYTE* op = ostart;
; 466  :     size_t n;
; 467  :     BIT_CStream_t bitC;
; 468  : 
; 469  :     /* init */
; 470  :     if (dstSize < 8) return 0;   /* not enough space to compress */

	cmp	rdx, 8
	jb	$LN85@HUF_compre
; File E:\dev\pyzstd\lib\common\bitstream.h

; 186  :     bitC->bitContainer = 0;

	xor	r15d, r15d

; 187  :     bitC->bitPos = 0;
; 188  :     bitC->startPtr = (char*)startPtr;
; 189  :     bitC->ptr = bitC->startPtr;
; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	lea	r11, QWORD PTR [rdx-8]
	add	r11, rcx
	mov	r14d, r15d
	mov	QWORD PTR bitC$$sroa$592$1$[rsp], r11
	mov	eax, r15d

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	rdx, 8
	jbe	$LN85@HUF_compre
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 474  :     n = srcSize & ~3;  /* join to mod 4 */

	mov	r10, r9
	mov	QWORD PTR [rsp+16], rdi

; 475  :     switch (srcSize & 3)

	mov	rdi, QWORD PTR CTable$[rsp]
	and	r10, -4
	and	r9d, 3
	mov	QWORD PTR [rsp+8], r12
	mov	r12, rcx
	sub	r9, 1
	je	SHORT $LN35@HUF_compre
	sub	r9, 1
	je	SHORT $LN28@HUF_compre
	cmp	r9, 1
	jne	SHORT $LN42@HUF_compre

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	eax, BYTE PTR [r10+r8+2]
	movzx	r14d, WORD PTR [rdi+rax*4]
	movzx	eax, BYTE PTR [rdi+rax*4+2]
$LN28@HUF_compre:
	movzx	ecx, BYTE PTR [r10+r8+1]
	movzx	edx, WORD PTR [rdi+rcx*4]
	lea	r8, QWORD PTR [rdi+rcx*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, eax
	shl	rdx, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r8+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r14, rdx

; 217  :     bitC->bitPos += nbBits;

	add	eax, ecx
$LN35@HUF_compre:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r10+rsi]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 247  :     bitC->bitPos &= 7;

	mov	r12, r11
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	edx, WORD PTR [rdi+rcx*4]
	lea	r8, QWORD PTR [rdi+rcx*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, eax
	shl	rdx, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r8+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r14, rdx

; 217  :     bitC->bitPos += nbBits;

	add	eax, ecx

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [rbx], r14
	mov	ecx, eax

; 247  :     bitC->bitPos &= 7;

	and	eax, 7
	shr	rcx, 3
	lea	rdx, QWORD PTR [rcx+rbx]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	r14, cl
	cmp	rdx, r11
	cmovbe	r12, rdx
$LN42@HUF_compre:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	test	r10, r10
	je	$LN5@HUF_compre
	mov	r15, QWORD PTR bitC$$sroa$592$1$[rsp]
	lea	r11, QWORD PTR [rsi-2]
	add	r11, r10
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp], r13
	lea	r13, QWORD PTR [r10-1]
	shr	r13, 2
	inc	r13
	mov	QWORD PTR tv1443[rsp], r11
	npad	12
$LL6@HUF_compre:

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r11+1]
	movzx	edx, BYTE PTR [r11-1]
	lea	r9, QWORD PTR [rdi+rcx*4]
	movzx	ecx, BYTE PTR [r11]
	lea	r8, QWORD PTR [rdi+rdx*4]
	movzx	edx, BYTE PTR [r11-2]
	lea	rbx, QWORD PTR [rdi+rcx*4]
	movzx	r11d, WORD PTR [rdi+rdx*4]
	lea	rdi, QWORD PTR [rdi+rdx*4]
	movzx	esi, BYTE PTR [r9+2]
	movzx	r10d, BYTE PTR [rbx+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 217  :     bitC->bitPos += nbBits;

	add	esi, eax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ebp, BYTE PTR [r8+2]
	add	r10d, esi
	movzx	edx, WORD PTR [r9]
	add	ebp, r10d
	mov	ecx, ebp
	shl	r11, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, eax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	eax, WORD PTR [r8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	shl	rdx, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	mov	ecx, r10d
	shl	rax, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r11, rdx
	or	r11, rax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	mov	ecx, esi
	movzx	eax, WORD PTR [rbx]
	shl	rax, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r11, rax
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	eax, BYTE PTR [rdi+2]

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	mov	rdi, QWORD PTR CTable$[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r14, r11
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	mov	r11, QWORD PTR tv1443[rsp]

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	add	eax, ebp
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r12], r14
	mov	edx, eax
	shr	rdx, 3
	lea	rcx, QWORD PTR [r12+rdx]

; 247  :     bitC->bitPos &= 7;

	mov	r12, r15
	cmp	rcx, r15
	cmovbe	r12, rcx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	sub	r11, 4
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	mov	QWORD PTR tv1443[rsp], r11
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	and	eax, 7
	shr	r14, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	sub	r13, 1
	jne	$LL6@HUF_compre
	mov	r11, QWORD PTR bitC$$sroa$592$1$[rsp]
	xor	r15d, r15d
	mov	rbx, QWORD PTR dst$[rsp]
	mov	r13, QWORD PTR [rsp]
	mov	rbp, QWORD PTR [rsp+88]
$LN5@HUF_compre:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 247  :     bitC->bitPos &= 7;

	mov	rdi, QWORD PTR [rsp+16]

; 217  :     bitC->bitPos += nbBits;

	lea	edx, DWORD PTR [rax+1]
	mov	ecx, eax

; 247  :     bitC->bitPos &= 7;

	mov	rax, r11

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	bts	r14, rcx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	ecx, edx
	shr	rcx, 3
	add	rcx, r12

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r12], r14

; 247  :     bitC->bitPos &= 7;

	mov	r12, QWORD PTR [rsp+8]
	cmp	rcx, r11
	cmovbe	rax, rcx

; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	cmp	rax, r11
	jae	SHORT $LN73@HUF_compre

; 247  :     bitC->bitPos &= 7;

	test	dl, 7

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	seta	r15b
	sub	r15, rbx
	add	r15, rax
$LN73@HUF_compre:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 501  :     return BIT_closeCStream(&bitC);

	mov	rax, r15

; 502  : }

	add	rsp, 24
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN85@HUF_compre:

; 471  :     { size_t const initErr = BIT_initCStream(&bitC, op, (size_t)(oend-op));
; 472  :       if (HUF_isError(initErr)) return 0; }

	xor	eax, eax

; 502  : }

	add	rsp, 24
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
HUF_compress1X_usingCTable_internal_body ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 64
tv1445 = 72
dstSize$ = 72
src$ = 80
srcSize$ = 88
CTable$ = 96
bmi2$dead$ = 104
HUF_compress1X_usingCTable_internal PROC

; 539  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H

; 470  :     if (dstSize < 8) return 0;   /* not enough space to compress */

	xor	eax, eax

; 539  : {

	mov	rbx, r8
	mov	r11, rcx

; 470  :     if (dstSize < 8) return 0;   /* not enough space to compress */

	cmp	rdx, 8
	jb	$LN3@HUF_compre
	mov	QWORD PTR [rsp+80], rbp
; File E:\dev\pyzstd\lib\common\bitstream.h

; 187  :     bitC->bitPos = 0;

	mov	ebp, eax
	mov	QWORD PTR [rsp+16], r13

; 188  :     bitC->startPtr = (char*)startPtr;
; 189  :     bitC->ptr = bitC->startPtr;
; 190  :     bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);

	lea	r13, QWORD PTR [rdx-8]
	add	r13, rcx
	mov	QWORD PTR [rsp+8], r14

; 186  :     bitC->bitContainer = 0;

	mov	r14d, eax

; 191  :     if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);

	cmp	rdx, 8
	jbe	$LN75@HUF_compre
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 474  :     n = srcSize & ~3;  /* join to mod 4 */

	mov	r10, r9
	mov	QWORD PTR [rsp], r15
	and	r10, -4

; 475  :     switch (srcSize & 3)

	and	r9d, 3
	mov	r15, rcx
	sub	r9, 1
	je	SHORT $LN88@HUF_compre
	sub	r9, 1
	je	SHORT $LN89@HUF_compre
	cmp	r9, 1
	jne	SHORT $LN44@HUF_compre

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r10+r8+2]
	mov	r9, QWORD PTR CTable$[rsp]
	movzx	r14d, WORD PTR [r9+rcx*4]
	movzx	ebp, BYTE PTR [r9+rcx*4+2]

; 475  :     switch (srcSize & 3)

	jmp	SHORT $LN30@HUF_compre
$LN89@HUF_compre:
	mov	r9, QWORD PTR CTable$[rsp]
$LN30@HUF_compre:

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r10+r8+1]
	movzx	edx, WORD PTR [r9+rcx*4]
	lea	r8, QWORD PTR [r9+rcx*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, ebp
	shl	rdx, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r8+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r14, rdx

; 217  :     bitC->bitPos += nbBits;

	add	ebp, ecx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 475  :     switch (srcSize & 3)

	jmp	SHORT $LN37@HUF_compre
$LN88@HUF_compre:
	mov	r9, QWORD PTR CTable$[rsp]
$LN37@HUF_compre:

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r10+rbx]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 247  :     bitC->bitPos &= 7;

	mov	r15, r13
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	edx, WORD PTR [r9+rcx*4]
	lea	r8, QWORD PTR [r9+rcx*4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, ebp
	shl	rdx, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r8+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r14, rdx

; 217  :     bitC->bitPos += nbBits;

	add	ebp, ecx

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r11], r14
	mov	ecx, ebp

; 247  :     bitC->bitPos &= 7;

	and	ebp, 7
	shr	rcx, 3
	lea	rdx, QWORD PTR [rcx+r11]

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	shr	r14, cl
	cmp	rdx, r13
	cmovbe	r15, rdx
$LN44@HUF_compre:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	test	r10, r10
	je	$LN7@HUF_compre
	mov	rax, QWORD PTR CTable$[rsp]
	lea	r11, QWORD PTR [rbx-2]
	mov	QWORD PTR [rsp+40], rsi
	add	r11, r10
	mov	QWORD PTR [rsp+32], rdi
	mov	QWORD PTR [rsp+24], r12
	lea	r12, QWORD PTR [r10-1]
	shr	r12, 2
	inc	r12
	mov	QWORD PTR tv1445[rsp], r11
	npad	8
$LL8@HUF_compre:

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ecx, BYTE PTR [r11+1]
	movzx	edx, BYTE PTR [r11]
	lea	rdi, QWORD PTR [rax+rcx*4]
	movzx	ecx, BYTE PTR [rax+rdx*4+2]
	lea	r9, QWORD PTR [rax+rdx*4]
	movzx	edx, BYTE PTR [r11-1]
	movzx	r10d, BYTE PTR [rdi+2]
	lea	r8, QWORD PTR [rax+rdx*4]
	movzx	edx, BYTE PTR [r11-2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 217  :     bitC->bitPos += nbBits;

	add	r10d, ebp
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	esi, BYTE PTR [r8+2]
	lea	rbx, QWORD PTR [rax+rdx*4]
	movzx	r11d, WORD PTR [r8]
	add	ecx, r10d
	movzx	edx, WORD PTR [r9]
	add	esi, ecx
	shl	r11, cl
	mov	ecx, r10d
	shl	rdx, cl
	mov	ecx, esi
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r11, rdx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	edx, WORD PTR [rbx]
	shl	rdx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, ebp
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	ebp, BYTE PTR [rbx+2]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r11, rdx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 446  :     BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);

	movzx	edx, WORD PTR [rdi]
	add	ebp, esi
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	shl	rdx, cl
	or	r11, rdx

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	mov	edx, ebp

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	or	r14, r11

; 241  :     size_t const nbBytes = bitC->bitPos >> 3;

	shr	rdx, 3
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	mov	r11, QWORD PTR tv1445[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], r14
	lea	rcx, QWORD PTR [r15+rdx]

; 247  :     bitC->bitPos &= 7;

	mov	r15, r13
	cmp	rcx, r13
	cmovbe	r15, rcx
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	sub	r11, 4
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	movzx	ecx, dl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	mov	QWORD PTR tv1445[rsp], r11
; File E:\dev\pyzstd\lib\common\bitstream.h

; 248  :     bitC->bitContainer >>= nbBytes*8;

	shl	cl, 3
	and	ebp, 7
	shr	r14, cl
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 490  :     for (; n>0; n-=4) {  /* note : n&3==0 at this stage */

	sub	r12, 1
	jne	$LL8@HUF_compre
	mov	r11, QWORD PTR dst$[rsp]
	xor	eax, eax
	mov	r12, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
$LN7@HUF_compre:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 216  :     bitC->bitContainer |= value << bitC->bitPos;

	mov	ecx, ebp
	bts	r14, rcx

; 247  :     bitC->bitPos &= 7;

	mov	rcx, r13

; 217  :     bitC->bitPos += nbBits;

	inc	ebp

; 244  :     MEM_writeLEST(bitC->ptr, bitC->bitContainer);

	mov	QWORD PTR [r15], r14
	mov	edx, ebp
	shr	rdx, 3
	add	rdx, r15

; 247  :     bitC->bitPos &= 7;

	mov	r15, QWORD PTR [rsp]
	cmp	rdx, r13
	cmovbe	rcx, rdx

; 258  :     if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */

	cmp	rcx, r13
	jae	SHORT $LN75@HUF_compre

; 247  :     bitC->bitPos &= 7;

	test	bpl, 7

; 259  :     return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);

	seta	al
	sub	rax, r11
	add	rax, rcx
$LN75@HUF_compre:
	mov	r13, QWORD PTR [rsp+16]
	mov	rbp, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+8]
$LN3@HUF_compre:
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 542  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
HUF_compress1X_usingCTable_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
dst$ = 96
dstSize$ = 104
src$ = 112
srcSize$ = 120
CTable$ = 128
bmi2$dead$ = 136
HUF_compress4X_usingCTable_internal PROC

; 556  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 557  :     size_t const segmentSize = (srcSize+3)/4;   /* first 3 segments */

	lea	rdi, QWORD PTR [r9+3]
	mov	r15, r8
	shr	rdi, 2

; 558  :     const BYTE* ip = (const BYTE*) src;
; 559  :     const BYTE* const iend = ip + srcSize;

	lea	r13, QWORD PTR [r8+r9]

; 560  :     BYTE* const ostart = (BYTE*) dst;
; 561  :     BYTE* const oend = ostart + dstSize;

	lea	r14, QWORD PTR [rcx+rdx]
	mov	rsi, rcx

; 562  :     BYTE* op = ostart;
; 563  : 
; 564  :     if (dstSize < 6 + 1 + 1 + 1 + 8) return 0;   /* minimum space to compress successfully */

	cmp	rdx, 17
	jb	$LN21@HUF_compre

; 565  :     if (srcSize < 12) return 0;   /* no saving possible : too small input */

	cmp	r9, 12
	jb	$LN21@HUF_compre

; 569  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );

	mov	r12, QWORD PTR CTable$[rsp]
	lea	rbx, QWORD PTR [rcx+6]
	mov	rdx, r14
	mov	QWORD PTR [rsp+32], r12
	sub	rdx, rbx
	mov	rcx, rbx
	mov	r9, rdi
	call	HUF_compress1X_usingCTable_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 569  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );

	ja	$LN1@HUF_compre

; 570  :         if (cSize==0) return 0;

	test	rax, rax
	je	$LN21@HUF_compre

; 571  :         assert(cSize <= 65535);
; 572  :         MEM_writeLE16(ostart, (U16)cSize);
; 573  :         op += cSize;

	add	rbx, rax
	mov	WORD PTR [rsi], ax

; 574  :     }
; 575  : 
; 576  :     ip += segmentSize;

	lea	rbp, QWORD PTR [rdi+r15]

; 578  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );

	mov	QWORD PTR [rsp+32], r12
	mov	rdx, r14
	mov	r8, rbp
	sub	rdx, rbx
	mov	rcx, rbx
	mov	r9, rdi
	call	HUF_compress1X_usingCTable_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 578  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );

	ja	SHORT $LN1@HUF_compre

; 579  :         if (cSize==0) return 0;

	test	rax, rax
	je	SHORT $LN21@HUF_compre

; 580  :         assert(cSize <= 65535);
; 581  :         MEM_writeLE16(ostart+2, (U16)cSize);
; 582  :         op += cSize;

	add	rbx, rax
	mov	WORD PTR [rsi+2], ax

; 583  :     }
; 584  : 
; 585  :     ip += segmentSize;

	add	rbp, rdi

; 587  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );

	mov	QWORD PTR [rsp+32], r12
	mov	rdx, r14
	mov	r8, rbp
	sub	rdx, rbx
	mov	rcx, rbx
	mov	r9, rdi
	call	HUF_compress1X_usingCTable_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 587  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );

	ja	SHORT $LN1@HUF_compre

; 588  :         if (cSize==0) return 0;

	test	rax, rax
	je	SHORT $LN21@HUF_compre

; 589  :         assert(cSize <= 65535);
; 590  :         MEM_writeLE16(ostart+4, (U16)cSize);
; 591  :         op += cSize;

	add	rbx, rax
	mov	WORD PTR [rsi+4], ax

; 592  :     }
; 593  : 
; 594  :     ip += segmentSize;

	add	rbp, rdi

; 597  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, (size_t)(iend-ip), CTable, bmi2) );

	mov	QWORD PTR [rsp+32], r12
	sub	r13, rbp
	sub	r14, rbx
	mov	r9, r13
	mov	rdx, r14
	mov	r8, rbp
	mov	rcx, rbx
	call	HUF_compress1X_usingCTable_internal
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 597  :     {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, (size_t)(iend-ip), CTable, bmi2) );

	ja	SHORT $LN1@HUF_compre

; 598  :         if (cSize==0) return 0;

	test	rax, rax
	je	SHORT $LN21@HUF_compre

; 599  :         op += cSize;
; 600  :     }
; 601  : 
; 602  :     return (size_t)(op-ostart);

	sub	rax, rsi
	add	rax, rbx
	jmp	SHORT $LN1@HUF_compre
$LN21@HUF_compre:

; 598  :         if (cSize==0) return 0;

	xor	eax, eax
$LN1@HUF_compre:

; 603  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
HUF_compress4X_usingCTable_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
ostart$ = 64
op$ = 72
oend$ = 80
src$ = 88
srcSize$ = 96
nbStreams$ = 104
CTable$ = 112
bmi2$dead$ = 120
HUF_compressCTable_internal PROC

; 616  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 617  :     size_t const cSize = (nbStreams==HUF_singleStream) ?

	mov	rax, QWORD PTR CTable$[rsp]
	mov	r10, r8
	mov	rdi, QWORD PTR srcSize$[rsp]
	sub	r10, rdx
	cmp	DWORD PTR nbStreams$[rsp], 0
	mov	rbx, rdx
	mov	r11, r9
	mov	QWORD PTR [rsp+32], rax
	mov	rsi, rcx
	mov	r8, r9
	mov	rdx, r10
	mov	rcx, rbx
	mov	r9, rdi
	jne	SHORT $LN6@HUF_compre
	call	HUF_compress1X_usingCTable_internal
	jmp	SHORT $LN7@HUF_compre
$LN6@HUF_compre:
	call	HUF_compress4X_usingCTable_internal
$LN7@HUF_compre:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 620  :     if (HUF_isError(cSize)) { return cSize; }

	ja	SHORT $LN1@HUF_compre

; 621  :     if (cSize==0) { return 0; }   /* uncompressible */

	test	rax, rax
	je	SHORT $LN10@HUF_compre

; 622  :     op += cSize;

	add	rbx, rax

; 623  :     /* check compressibility */
; 624  :     assert(op >= ostart);
; 625  :     if ((size_t)(op-ostart) >= srcSize-1) { return 0; }

	lea	rax, QWORD PTR [rdi-1]
	sub	rbx, rsi
	cmp	rbx, rax
	jae	SHORT $LN10@HUF_compre

; 626  :     return (size_t)(op-ostart);

	mov	rax, rbx

; 627  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN10@HUF_compre:

; 623  :     /* check compressibility */
; 624  :     assert(op >= ostart);
; 625  :     if ((size_t)(op-ostart) >= srcSize-1) { return 0; }

	xor	eax, eax
$LN1@HUF_compre:

; 627  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
HUF_compressCTable_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\compress\hist.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\compress\huf_compress.c
_TEXT	SEGMENT
maxSymbolValue$ = 64
oend$1$ = 144
dst$ = 144
dstSize$ = 152
src$ = 160
srcSize$ = 168
maxSymbolValue$dead$ = 176
huffLog$dead$ = 184
nbStreams$ = 192
workSpace$ = 200
wkspSize$dead$ = 208
oldHufTable$ = 216
repeat$ = 224
preferRepeat$ = 232
bmi2$dead$ = 240
HUF_compress_internal PROC

; 645  : {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H

; 646  :     HUF_compress_tables_t* const table = (HUF_compress_tables_t*)workSpace;
; 647  :     BYTE* const ostart = (BYTE*)dst;
; 648  :     BYTE* const oend = ostart + dstSize;
; 649  :     BYTE* op = ostart;
; 650  : 
; 651  :     HUF_STATIC_ASSERT(sizeof(*table) <= HUF_WORKSPACE_SIZE);
; 652  : 
; 653  :     /* checks & inits */
; 654  :     if (((size_t)workSpace & 3) != 0) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */

	mov	rbp, QWORD PTR workSpace$[rsp]
	mov	r15, rcx
	add	rcx, rdx
	mov	rsi, r9
	mov	QWORD PTR oend$1$[rsp], rcx
	mov	r13, r8
	test	bpl, 3
	je	SHORT $LN3@HUF_compre
	mov	rax, -1

; 722  :                                        src, srcSize,
; 723  :                                        nbStreams, table->CTable, bmi2);
; 724  : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbp
	ret	0
$LN3@HUF_compre:
	mov	QWORD PTR [rsp+160], rbx
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+88], r12
	mov	QWORD PTR [rsp+80], r14

; 655  :     if (wkspSize < HUF_WORKSPACE_SIZE) return ERROR(workSpace_tooSmall);
; 656  :     if (!srcSize) return 0;  /* Uncompressed */

	test	rsi, rsi
	je	$LN43@HUF_compre

; 657  :     if (!dstSize) return 0;  /* cannot fit anything within dst budget */

	test	rdx, rdx
	je	$LN43@HUF_compre

; 658  :     if (srcSize > HUF_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);   /* current block size limit */

	cmp	rsi, 131072				; 00020000H
	jbe	SHORT $LN6@HUF_compre
	mov	rax, -72				; ffffffffffffffb8H
	jmp	$LN50@HUF_compre
$LN6@HUF_compre:

; 659  :     if (huffLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);
; 660  :     if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);
; 661  :     if (!maxSymbolValue) maxSymbolValue = HUF_SYMBOLVALUE_MAX;
; 662  :     if (!huffLog) huffLog = HUF_TABLELOG_DEFAULT;
; 663  : 
; 664  :     /* Heuristic : If old table is valid, use it for small inputs */
; 665  :     if (preferRepeat && repeat && *repeat == HUF_repeat_valid) {

	mov	r12d, DWORD PTR preferRepeat$[rsp]
	mov	r14, QWORD PTR repeat$[rsp]
	test	r12d, r12d
	je	SHORT $LN11@HUF_compre
	test	r14, r14
	je	SHORT $LN11@HUF_compre
	cmp	DWORD PTR [r14], 2
	jne	SHORT $LN11@HUF_compre

; 666  :         return HUF_compressCTable_internal(ostart, op, oend,

	mov	rax, QWORD PTR oldHufTable$[rsp]
	mov	r8, rcx
	mov	QWORD PTR [rsp+48], rax
	mov	r9, r13
	mov	eax, DWORD PTR nbStreams$[rsp]
	mov	rdx, r15
	mov	DWORD PTR [rsp+40], eax
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], rsi
	call	HUF_compressCTable_internal
	jmp	$LN50@HUF_compre
$LN11@HUF_compre:
; File E:\dev\pyzstd\lib\compress\hist.c

; 174  :     *maxSymbolValuePtr = 255;

	mov	DWORD PTR maxSymbolValue$[rsp], 255	; 000000ffH

; 148  :     if (sourceSize < 1500) /* heuristic threshold */

	lea	rdx, QWORD PTR maxSymbolValue$[rsp]
	mov	rcx, rbp
	cmp	rsi, 1500				; 000005dcH
	jae	SHORT $LN32@HUF_compre

; 149  :         return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);

	call	HIST_count_simple
	mov	ecx, eax
	jmp	SHORT $LN31@HUF_compre
$LN32@HUF_compre:

; 150  :     if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
; 151  :     if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
; 152  :     return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);

	mov	QWORD PTR [rsp+40], rbp
	mov	DWORD PTR [rsp+32], 0
	call	HIST_count_parallel_wksp
	mov	rcx, rax
$LN31@HUF_compre:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rcx, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 672  :     {   CHECK_V_F(largest, HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, workSpace, wkspSize) );

	jbe	SHORT $LN12@HUF_compre
	mov	rax, rcx
	jmp	$LN50@HUF_compre
$LN12@HUF_compre:

; 673  :         if (largest == srcSize) { *ostart = ((const BYTE*)src)[0]; return 1; }   /* single symbol, rle */

	cmp	rcx, rsi
	jne	SHORT $LN13@HUF_compre
	movzx	eax, BYTE PTR [r13]
	mov	BYTE PTR [r15], al
	mov	eax, 1
	jmp	$LN50@HUF_compre
$LN13@HUF_compre:

; 674  :         if (largest <= (srcSize >> 7)+4) return 0;   /* heuristic : probably not compressible enough */

	mov	rax, rsi
	shr	rax, 7
	add	rax, 4
	cmp	rcx, rax
	jbe	$LN43@HUF_compre

; 675  :     }
; 676  : 
; 677  :     /* Check validity of previous table */
; 678  :     if ( repeat
; 679  :       && *repeat == HUF_repeat_check
; 680  :       && !HUF_validateCTable(oldHufTable, table->count, maxSymbolValue)) {

	mov	rdi, QWORD PTR oldHufTable$[rsp]
	mov	ebx, DWORD PTR maxSymbolValue$[rsp]
	test	r14, r14
	je	SHORT $LN15@HUF_compre
	cmp	DWORD PTR [r14], 1
	jne	SHORT $LN15@HUF_compre
	mov	r8d, ebx
	mov	rdx, rbp
	mov	rcx, rdi
	call	HUF_validateCTable
	test	eax, eax
	jne	SHORT $LN15@HUF_compre

; 681  :         *repeat = HUF_repeat_none;

	mov	DWORD PTR [r14], eax
$LN15@HUF_compre:

; 682  :     }
; 683  :     /* Heuristic : use existing table for small inputs */
; 684  :     if (preferRepeat && repeat && *repeat != HUF_repeat_none) {

	test	r12d, r12d
	je	SHORT $LN16@HUF_compre
	test	r14, r14
	je	SHORT $LN16@HUF_compre
	cmp	DWORD PTR [r14], 0
	jne	$LN21@HUF_compre
$LN16@HUF_compre:

; 685  :         return HUF_compressCTable_internal(ostart, op, oend,
; 686  :                                            src, srcSize,
; 687  :                                            nbStreams, oldHufTable, bmi2);
; 688  :     }
; 689  : 
; 690  :     /* Build Huffman Tree */
; 691  :     huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);

	mov	r8d, ebx
	mov	rdx, rsi
	call	HUF_optimalTableLog

; 692  :     {   size_t const maxBits = HUF_buildCTable_wksp(table->CTable, table->count,

	lea	rcx, QWORD PTR [rbp+2048]
	mov	QWORD PTR [rsp+40], 4352		; 00001100H
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, eax
	lea	rcx, QWORD PTR [rbp+1024]
	mov	rdx, rbp
	call	HUF_buildCTable_wksp
	mov	r12, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 695  :         CHECK_F(maxBits);

	ja	$LN50@HUF_compre

; 696  :         huffLog = (U32)maxBits;
; 697  :         /* Zero unused symbols in CTable, so we can check it for validity */
; 698  :         memset(table->CTable + (maxSymbolValue + 1), 0,

	lea	eax, DWORD PTR [rbx+1]
	mov	r8d, 1024				; 00000400H
	lea	rcx, QWORD PTR [rax*4]
	xor	edx, edx
	sub	r8, rcx
	add	rcx, 1024				; 00000400H
	add	rcx, rbp
	call	memset

; 703  :     {   CHECK_V_F(hSize, HUF_writeCTable (op, dstSize, table->CTable, maxSymbolValue, huffLog) );

	mov	rdx, QWORD PTR dstSize$[rsp]
	lea	r8, QWORD PTR [rbp+1024]
	mov	r9d, ebx
	mov	DWORD PTR [rsp+32], r12d
	mov	rcx, r15
	call	HUF_writeCTable
	mov	r12, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\compress\huf_compress.c

; 703  :     {   CHECK_V_F(hSize, HUF_writeCTable (op, dstSize, table->CTable, maxSymbolValue, huffLog) );

	ja	$LN50@HUF_compre

; 704  :         /* Check if using previous huffman table is beneficial */
; 705  :         if (repeat && *repeat != HUF_repeat_none) {

	test	r14, r14
	je	SHORT $LN20@HUF_compre
	cmp	DWORD PTR [r14], 0
	je	SHORT $LN20@HUF_compre

; 706  :             size_t const oldSize = HUF_estimateCompressedSize(oldHufTable, table->count, maxSymbolValue);
; 707  :             size_t const newSize = HUF_estimateCompressedSize(table->CTable, table->count, maxSymbolValue);

	mov	r8d, ebx
	lea	rcx, QWORD PTR [rbp+1024]
	mov	rdx, rbp
	call	HUF_estimateCompressedSize
	mov	r8d, DWORD PTR maxSymbolValue$[rsp]
	mov	rdx, rbp
	mov	rcx, rdi

; 708  :             if (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {

	lea	rbx, QWORD PTR [r12+rax]
	call	HUF_estimateCompressedSize
	cmp	rax, rbx
	jbe	SHORT $LN21@HUF_compre
	lea	rax, QWORD PTR [r12+12]
	cmp	rax, rsi
	jb	SHORT $LN20@HUF_compre
$LN21@HUF_compre:

; 709  :                 return HUF_compressCTable_internal(ostart, op, oend,

	mov	eax, DWORD PTR nbStreams$[rsp]
	mov	r9, r13
	mov	r8, QWORD PTR oend$1$[rsp]
	mov	rdx, r15
	mov	QWORD PTR [rsp+48], rdi
	mov	rcx, r15
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rsi
	call	HUF_compressCTable_internal
	jmp	$LN50@HUF_compre
$LN20@HUF_compre:

; 710  :                                                    src, srcSize,
; 711  :                                                    nbStreams, oldHufTable, bmi2);
; 712  :         }   }
; 713  : 
; 714  :         /* Use the new huffman table */
; 715  :         if (hSize + 12ul >= srcSize) { return 0; }

	lea	rax, QWORD PTR [r12+12]
	cmp	rax, rsi
	jae	$LN43@HUF_compre

; 716  :         op += hSize;

	lea	rdx, QWORD PTR [r12+r15]

; 717  :         if (repeat) { *repeat = HUF_repeat_none; }

	test	r14, r14
	je	SHORT $LN23@HUF_compre
	mov	DWORD PTR [r14], 0
$LN23@HUF_compre:

; 718  :         if (oldHufTable)

	test	rdi, rdi
	je	SHORT $LN24@HUF_compre

; 719  :             memcpy(oldHufTable, table->CTable, sizeof(table->CTable));  /* Save new table */

	lea	rax, QWORD PTR [rbp+1024]
	mov	ecx, 8
$LL44@HUF_compre:
	lea	rdi, QWORD PTR [rdi+128]
	movups	xmm0, XMMWORD PTR [rax]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [rdi-128], xmm0
	movups	xmm1, XMMWORD PTR [rax-112]
	movups	XMMWORD PTR [rdi-112], xmm1
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rdi-96], xmm0
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rdi-80], xmm1
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rdi-64], xmm0
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rdi-48], xmm1
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rdi-32], xmm0
	movups	xmm1, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rdi-16], xmm1
	sub	rcx, 1
	jne	SHORT $LL44@HUF_compre
$LN24@HUF_compre:

; 720  :     }
; 721  :     return HUF_compressCTable_internal(ostart, op, oend,

	mov	r8, QWORD PTR oend$1$[rsp]
	lea	rax, QWORD PTR [rbp+1024]
	mov	QWORD PTR [rsp+48], rax
	mov	r9, r13
	mov	eax, DWORD PTR nbStreams$[rsp]
	mov	rcx, r15
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rsi
	call	HUF_compressCTable_internal
	jmp	SHORT $LN50@HUF_compre
$LN43@HUF_compre:

; 710  :                                                    src, srcSize,
; 711  :                                                    nbStreams, oldHufTable, bmi2);
; 712  :         }   }
; 713  : 
; 714  :         /* Use the new huffman table */
; 715  :         if (hSize + 12ul >= srcSize) { return 0; }

	xor	eax, eax
$LN50@HUF_compre:
	mov	r12, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+160]
	mov	r14, QWORD PTR [rsp+80]

; 722  :                                        src, srcSize,
; 723  :                                        nbStreams, table->CTable, bmi2);
; 724  : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbp
	ret	0
HUF_compress_internal ENDP
_TEXT	ENDS
END
