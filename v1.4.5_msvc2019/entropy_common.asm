; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	HUF_readStats
PUBLIC	FSE_isError
PUBLIC	FSE_readNCount
pdata	SEGMENT
$pdata$HUF_readStats DD imagerel $LN44
	DD	imagerel $LN44+469
	DD	imagerel $unwind$HUF_readStats
$pdata$FSE_readNCount DD imagerel $LN61
	DD	imagerel $LN61+738
	DD	imagerel $unwind$FSE_readNCount
xdata	SEGMENT
$unwind$HUF_readStats DD 092519H
	DD	0333413H
	DD	02c0113H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$FSE_readNCount DD 0a1e01H
	DD	0e341eH
	DD	0f01a521eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
_TEXT	SEGMENT
normalizedCounter$ = 112
maxSVPtr$ = 120
tableLogPtr$ = 128
buffer$1 = 136
headerBuffer$ = 136
hbSize$ = 144
FSE_readNCount PROC

; 43   : {

$LN61:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+32], r9
	mov	QWORD PTR [rax+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 44   :     const BYTE* const istart = (const BYTE*) headerBuffer;
; 45   :     const BYTE* const iend = istart + hbSize;

	mov	rdi, QWORD PTR hbSize$[rsp]
	mov	r12, rcx

; 46   :     const BYTE* ip = istart;
; 47   :     int nbBits;
; 48   :     int remaining;
; 49   :     int threshold;
; 50   :     U32 bitStream;
; 51   :     int bitCount;
; 52   :     unsigned charnum = 0;

	xor	ecx, ecx
	mov	rsi, r8
	mov	r13, rdx
	mov	rbx, r9
	mov	r15d, ecx

; 53   :     int previous0 = 0;

	mov	ebp, ecx
	lea	r14, QWORD PTR [r9+rdi]

; 54   : 
; 55   :     if (hbSize < 4) {

	cmp	rdi, 4
	jae	SHORT $LN12@FSE_readNC

; 56   :         /* This function only works when hbSize >= 4 */
; 57   :         char buffer[4];
; 58   :         memset(buffer, 0, sizeof(buffer));

	mov	DWORD PTR [rax+32], ecx

; 59   :         memcpy(buffer, headerBuffer, hbSize);

	mov	r8, rdi
	lea	rcx, QWORD PTR [rax+32]
	mov	rdx, r9
	call	memcpy

; 60   :         {   size_t const countSize = FSE_readNCount(normalizedCounter, maxSVPtr, tableLogPtr,

	mov	r8d, 4
	lea	r9, QWORD PTR buffer$1[rsp]
	mov	QWORD PTR [rsp+32], r8
	mov	rdx, r13
	mov	r8, rsi
	mov	rcx, r12
	call	FSE_readNCount
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 62   :             if (FSE_isError(countSize)) return countSize;

	ja	SHORT $LN1@FSE_readNC

; 63   :             if (countSize > hbSize) return ERROR(corruption_detected);

	cmp	rax, rdi
	jbe	SHORT $LN1@FSE_readNC
$LN56@FSE_readNC:

; 140  :     if (bitCount > 32) return ERROR(corruption_detected);

	mov	rax, -20
$LN1@FSE_readNC:

; 145  : }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN12@FSE_readNC:

; 64   :             return countSize;
; 65   :     }   }
; 66   :     assert(hbSize >= 4);
; 67   : 
; 68   :     /* init */
; 69   :     memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]));   /* all symbols not present in NCount have a frequency of 0 */

	mov	r13d, DWORD PTR [rdx]
	mov	rcx, r12
	xor	edx, edx
	lea	r8d, DWORD PTR [r13+1]
	add	r8, r8
	call	memset

; 70   :     bitStream = MEM_readLE32(ip);

	mov	rdi, QWORD PTR headerBuffer$[rsp]
	mov	edx, DWORD PTR [rdi]

; 71   :     nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */

	mov	r11d, edx
	and	r11d, 15
	add	r11d, 5

; 72   :     if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);

	cmp	r11d, 15
	jbe	SHORT $LN15@FSE_readNC
	mov	rax, -44				; ffffffffffffffd4H
	jmp	SHORT $LN1@FSE_readNC
$LN15@FSE_readNC:

; 73   :     bitStream >>= 4;
; 74   :     bitCount = 4;
; 75   :     *tableLogPtr = nbBits;
; 76   :     remaining = (1<<nbBits)+1;

	mov	ecx, r11d
	mov	DWORD PTR [rsi], r11d
	mov	r10d, 1
	shr	edx, 4
	shl	r10d, cl

; 77   :     threshold = 1<<nbBits;
; 78   :     nbBits++;

	inc	r11d
	mov	r8d, 4
	lea	esi, DWORD PTR [r10+1]

; 79   : 
; 80   :     while ((remaining>1) & (charnum<=*maxSVPtr)) {

	cmp	esi, 1
	jle	$LN59@FSE_readNC
	npad	3
$LL2@FSE_readNC:

; 81   :         if (previous0) {

	test	ebp, ebp
	je	$LN21@FSE_readNC

; 82   :             unsigned n0 = charnum;

	mov	r9d, r15d

; 83   :             while ((bitStream & 0xFFFF) == 0xFFFF) {

	cmp	dx, 65535				; 0000ffffH
	jne	SHORT $LN38@FSE_readNC
	lea	rdi, QWORD PTR [r14-5]
$LL4@FSE_readNC:

; 84   :                 n0 += 24;

	add	r9d, 24

; 85   :                 if (ip < iend-5) {

	cmp	rbx, rdi
	jae	SHORT $LN17@FSE_readNC

; 86   :                     ip += 2;
; 87   :                     bitStream = MEM_readLE32(ip) >> bitCount;

	mov	edx, DWORD PTR [rbx+2]
	add	rbx, 2
	mov	ecx, r8d
	shr	edx, cl

; 88   :                 } else {

	jmp	SHORT $LN18@FSE_readNC
$LN17@FSE_readNC:

; 89   :                     bitStream >>= 16;

	shr	edx, 16

; 90   :                     bitCount   += 16;

	add	r8d, 16
$LN18@FSE_readNC:

; 83   :             while ((bitStream & 0xFFFF) == 0xFFFF) {

	cmp	dx, 65535				; 0000ffffH
	je	SHORT $LL4@FSE_readNC
$LN38@FSE_readNC:

; 91   :             }   }
; 92   :             while ((bitStream & 3) == 3) {

	mov	eax, edx
	and	eax, 3
	cmp	al, 3
	jne	SHORT $LN7@FSE_readNC
	npad	12
$LL6@FSE_readNC:

; 93   :                 n0 += 3;
; 94   :                 bitStream >>= 2;

	shr	edx, 2
	add	r9d, 3
	mov	eax, edx

; 95   :                 bitCount += 2;

	add	r8d, 2
	and	eax, 3
	cmp	al, 3
	je	SHORT $LL6@FSE_readNC
$LN7@FSE_readNC:

; 96   :             }
; 97   :             n0 += bitStream & 3;

	mov	eax, edx

; 98   :             bitCount += 2;

	add	r8d, 2
	and	eax, 3
	add	r9d, eax

; 99   :             if (n0 > *maxSVPtr) return ERROR(maxSymbolValue_tooSmall);

	cmp	r9d, r13d
	ja	$LN41@FSE_readNC

; 100  :             while (charnum < n0) normalizedCounter[charnum++] = 0;

	cmp	r15d, r9d
	jae	SHORT $LN9@FSE_readNC
	mov	ecx, r9d
	mov	edi, r15d
	sub	ecx, r15d
	mov	r15d, r9d
	xor	eax, eax
	movsx	rax, ax
	lea	rdi, QWORD PTR [r12+rdi*2]
	rep stosw
$LN9@FSE_readNC:

; 101  :             if ((ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {

	lea	rax, QWORD PTR [r14-7]
	cmp	rbx, rax
	jbe	SHORT $LN22@FSE_readNC
	mov	eax, r8d
	sar	eax, 3
	movsxd	rcx, eax
	lea	rax, QWORD PTR [r14-4]
	add	rcx, rbx
	cmp	rcx, rax
	jbe	SHORT $LN22@FSE_readNC

; 106  :             } else {
; 107  :                 bitStream >>= 2;

	shr	edx, 2
	jmp	SHORT $LN21@FSE_readNC
$LN22@FSE_readNC:

; 102  :                 assert((bitCount >> 3) <= 3); /* For first condition to work */
; 103  :                 ip += bitCount>>3;

	movsxd	rax, r8d

; 104  :                 bitCount &= 7;

	and	r8d, 7
	sar	rax, 3

; 105  :                 bitStream = MEM_readLE32(ip) >> bitCount;

	mov	ecx, r8d
	add	rbx, rax
	mov	edx, DWORD PTR [rbx]
	shr	edx, cl
$LN21@FSE_readNC:

; 108  :         }   }
; 109  :         {   int const max = (2*threshold-1) - remaining;

	lea	ecx, DWORD PTR [r10+r10]
	mov	r9d, ecx

; 110  :             int count;
; 111  : 
; 112  :             if ((bitStream & (threshold-1)) < (U32)max) {

	lea	eax, DWORD PTR [r10-1]
	sub	r9d, esi
	and	eax, edx
	dec	r9d
	cmp	eax, r9d
	jae	SHORT $LN23@FSE_readNC

; 113  :                 count = bitStream & (threshold-1);

	lea	edi, DWORD PTR [r10-1]

; 114  :                 bitCount += nbBits-1;

	dec	r8d
	and	edi, edx
	add	r8d, r11d

; 115  :             } else {

	jmp	SHORT $LN24@FSE_readNC
$LN23@FSE_readNC:

; 116  :                 count = bitStream & (2*threshold-1);

	dec	ecx

; 117  :                 if (count >= threshold) count -= max;
; 118  :                 bitCount += nbBits;

	add	r8d, r11d
	and	ecx, edx
	mov	edi, ecx
	sub	edi, r9d
	cmp	ecx, r10d
	cmovl	edi, ecx
$LN24@FSE_readNC:

; 119  :             }
; 120  : 
; 121  :             count--;   /* extra accuracy */

	dec	edi

; 122  :             remaining -= count < 0 ? -count : count;   /* -1 means +1 */
; 123  :             normalizedCounter[charnum++] = (short)count;
; 124  :             previous0 = !count;

	xor	r9d, r9d
	mov	eax, edi
	mov	ebp, r9d
	cdq
	xor	eax, edx
	sub	eax, edx
	sub	esi, eax
	mov	eax, r15d
	inc	r15d
	test	edi, edi
	sete	bpl
	mov	WORD PTR [r12+rax*2], di

; 125  :             while (remaining < threshold) {

	cmp	esi, r10d
	jge	SHORT $LN11@FSE_readNC
	npad	2
$LL10@FSE_readNC:

; 126  :                 nbBits--;

	dec	r11d

; 127  :                 threshold >>= 1;

	sar	r10d, 1
	cmp	esi, r10d
	jl	SHORT $LL10@FSE_readNC
$LN11@FSE_readNC:

; 128  :             }
; 129  : 
; 130  :             if ((ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {

	lea	rax, QWORD PTR [r14-7]
	cmp	rbx, rax
	jbe	SHORT $LN28@FSE_readNC
	mov	eax, r8d
	lea	rdx, QWORD PTR [r14-4]
	sar	eax, 3
	movsxd	rcx, eax
	add	rcx, rbx
	cmp	rcx, rdx
	jbe	SHORT $LN28@FSE_readNC

; 133  :             } else {
; 134  :                 bitCount -= (int)(8 * (iend - 4 - ip));

	sub	ebx, r14d
	lea	r8d, DWORD PTR [r8+rbx*8]

; 135  :                 ip = iend - 4;

	mov	rbx, rdx
	add	r8d, 32					; 00000020H
	jmp	SHORT $LN27@FSE_readNC
$LN28@FSE_readNC:

; 131  :                 ip += bitCount>>3;

	movsxd	rax, r8d
	sar	rax, 3
	add	rbx, rax

; 132  :                 bitCount &= 7;

	and	r8d, 7
$LN27@FSE_readNC:

; 136  :             }
; 137  :             bitStream = MEM_readLE32(ip) >> (bitCount & 31);

	mov	edx, DWORD PTR [rbx]
	mov	eax, r9d
	mov	ecx, r8d
	and	ecx, 31
	shr	edx, cl
	mov	ecx, r9d
	cmp	r15d, r13d
	setbe	cl
	cmp	esi, 1
	setg	al
	test	ecx, eax
	jne	$LL2@FSE_readNC

; 138  :     }   }   /* while ((remaining>1) & (charnum<=*maxSVPtr)) */
; 139  :     if (remaining != 1) return ERROR(corruption_detected);

	mov	rdi, QWORD PTR headerBuffer$[rsp]
	cmp	esi, 1
$LN59@FSE_readNC:
	jne	$LN56@FSE_readNC

; 140  :     if (bitCount > 32) return ERROR(corruption_detected);

	cmp	r8d, 32					; 00000020H
	jg	$LN56@FSE_readNC

; 141  :     *maxSVPtr = charnum-1;

	mov	rcx, QWORD PTR maxSVPtr$[rsp]
	lea	eax, DWORD PTR [r15-1]
	mov	DWORD PTR [rcx], eax

; 142  : 
; 143  :     ip += (bitCount+7)>>3;

	lea	eax, DWORD PTR [r8+7]

; 144  :     return ip-istart;

	cdqe
	sar	rax, 3
	sub	rax, rdi
	add	rax, rbx
	jmp	$LN1@FSE_readNC
$LN41@FSE_readNC:

; 99   :             if (n0 > *maxSVPtr) return ERROR(maxSymbolValue_tooSmall);

	mov	rax, -48				; ffffffffffffffd0H
	jmp	$LN1@FSE_readNC
FSE_readNCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
val$ = 8
BIT_highbit32 PROC

; 141  :     assert(val != 0);
; 142  :     {
; 143  : #   if defined(_MSC_VER)   /* Visual */
; 144  :         unsigned long r=0;

	xor	eax, eax

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 146  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* Use GCC Intrinsic */
; 147  :         return __builtin_clz (val) ^ 31;
; 148  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 149  :         return 31 - __CLZ(val);
; 150  : #   else   /* Software version */
; 151  :         static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,
; 152  :                                                  11, 14, 16, 18, 22, 25,  3, 30,
; 153  :                                                   8, 12, 20, 28, 15, 17, 24,  7,
; 154  :                                                  19, 27, 23,  6, 26,  5,  4, 31 };
; 155  :         U32 v = val;
; 156  :         v |= v >> 1;
; 157  :         v |= v >> 2;
; 158  :         v |= v >> 4;
; 159  :         v |= v >> 8;
; 160  :         v |= v >> 16;
; 161  :         return DeBruijnClz[ (U32) (v * 0x07C4ACDDU) >> 27];
; 162  : #   endif
; 163  :     }
; 164  : }

	ret	0
BIT_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
_TEXT	SEGMENT
code$ = 8
FSE_isError PROC
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 31   : unsigned FSE_isError(size_t code) { return ERR_isError(code); }

	ret	0
FSE_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\common\entropy_common.c
_TEXT	SEGMENT
fseWorkspace$1 = 64
__$ArrayPad$ = 336
huffWeight$ = 400
hwSize$dead$ = 408
rankStats$ = 416
nbSymbolsPtr$ = 424
tableLogPtr$ = 432
src$ = 440
srcSize$ = 448
HUF_readStats PROC

; 158  : {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, QWORD PTR tableLogPtr$[rsp]
	mov	rbx, rcx

; 159  :     U32 weightTotal;
; 160  :     const BYTE* ip = (const BYTE*) src;
; 161  :     size_t iSize;
; 162  :     size_t oSize;
; 163  : 
; 164  :     if (!srcSize) return ERROR(srcSize_wrong);

	mov	rcx, QWORD PTR srcSize$[rsp]
	mov	r14, r9
	mov	rdx, QWORD PTR src$[rsp]
	mov	rsi, r8
	test	rcx, rcx
	je	$LN42@HUF_readSt

; 165  :     iSize = ip[0];

	movzx	r9d, BYTE PTR [rdx]

; 166  :     /* memset(huffWeight, 0, hwSize);   *//* is not necessary, even though some analyzer complain ... */
; 167  : 
; 168  :     if (iSize >= 128) {  /* special header */

	xor	edi, edi
	cmp	r9, 128					; 00000080H
	jb	SHORT $LN9@HUF_readSt

; 169  :         oSize = iSize - 127;

	lea	r8, QWORD PTR [r9-127]

; 170  :         iSize = ((oSize+1)/2);

	lea	rbp, QWORD PTR [r8+1]
	shr	rbp, 1

; 171  :         if (iSize+1 > srcSize) return ERROR(srcSize_wrong);

	inc	rbp
	cmp	rbp, rcx
	ja	$LN42@HUF_readSt

; 172  :         if (oSize >= hwSize) return ERROR(corruption_detected);

	cmp	r8, 256					; 00000100H
	jae	$LN20@HUF_readSt

; 173  :         ip += 1;

	lea	r10, QWORD PTR [rdx+1]
	mov	r9d, edi

; 174  :         {   U32 n;
; 175  :             for (n=0; n<oSize; n+=2) {

	test	r8, r8
	je	SHORT $LN14@HUF_readSt
	mov	edx, edi
$LL4@HUF_readSt:

; 176  :                 huffWeight[n]   = ip[n/2] >> 4;

	mov	rcx, rdx
	shr	rcx, 1
	movzx	eax, BYTE PTR [rcx+r10]
	shr	al, 4
	mov	BYTE PTR [rdx+rbx], al

; 177  :                 huffWeight[n+1] = ip[n/2] & 15;

	lea	eax, DWORD PTR [r9+1]
	movzx	edx, BYTE PTR [rcx+r10]
	add	r9d, 2
	and	dl, 15
	mov	BYTE PTR [rax+rbx], dl
	mov	edx, r9d
	cmp	rdx, r8
	jb	SHORT $LL4@HUF_readSt

; 178  :     }   }   }

	jmp	SHORT $LN14@HUF_readSt
$LN9@HUF_readSt:

; 179  :     else  {   /* header compressed with FSE (normal case) */
; 180  :         FSE_DTable fseWorkspace[FSE_DTABLE_SIZE_U32(6)];  /* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) */
; 181  :         if (iSize+1 > srcSize) return ERROR(srcSize_wrong);

	lea	rbp, QWORD PTR [r9+1]
	cmp	rbp, rcx
	ja	$LN42@HUF_readSt

; 182  :         oSize = FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6);   /* max (hwSize-1) values decoded, as last one is implied */

	lea	rax, QWORD PTR fseWorkspace$1[rsp]
	mov	rcx, rbx
	lea	r8, QWORD PTR [rdx+1]
	mov	QWORD PTR [rsp+32], rax
	call	FSE_decompress_wksp
	mov	r8, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 183  :         if (FSE_isError(oSize)) return oSize;

	ja	$LN1@HUF_readSt
$LN14@HUF_readSt:
	xorps	xmm0, xmm0

; 184  :     }
; 185  : 
; 186  :     /* collect weight stats */
; 187  :     memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32));

	xor	eax, eax

; 188  :     weightTotal = 0;

	mov	r9d, edi

; 189  :     {   U32 n; for (n=0; n<oSize; n++) {

	mov	edx, edi
	movups	XMMWORD PTR [rsi], xmm0
	movups	XMMWORD PTR [rsi+16], xmm0
	movups	XMMWORD PTR [rsi+32], xmm0
	mov	DWORD PTR [rsi+48], eax
	test	r8, r8
	je	$LN20@HUF_readSt
	mov	rcx, rdi
	lea	r10d, QWORD PTR [rax+1]
	npad	10
$LL7@HUF_readSt:

; 190  :             if (huffWeight[n] >= HUF_TABLELOG_MAX) return ERROR(corruption_detected);

	movzx	eax, BYTE PTR [rcx+rbx]
	cmp	al, 12
	jae	$LN20@HUF_readSt

; 191  :             rankStats[huffWeight[n]]++;

	inc	DWORD PTR [rsi+rax*4]
	inc	edx

; 192  :             weightTotal += (1 << huffWeight[n]) >> 1;

	movzx	ecx, BYTE PTR [rcx+rbx]
	mov	eax, r10d
	shl	eax, cl
	sar	eax, 1
	add	r9d, eax
	mov	ecx, edx
	cmp	rcx, r8
	jb	SHORT $LL7@HUF_readSt

; 193  :     }   }
; 194  :     if (weightTotal == 0) return ERROR(corruption_detected);

	test	r9d, r9d
	je	SHORT $LN20@HUF_readSt
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r9d
	mov	ecx, edi
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 197  :     {   U32 const tableLog = BIT_highbit32(weightTotal) + 1;

	inc	ecx

; 198  :         if (tableLog > HUF_TABLELOG_MAX) return ERROR(corruption_detected);

	cmp	ecx, 12
	ja	SHORT $LN20@HUF_readSt

; 199  :         *tableLogPtr = tableLog;
; 200  :         /* determine last weight */
; 201  :         {   U32 const total = 1 << tableLog;

	mov	edx, r10d
	mov	DWORD PTR [r15], ecx
	shl	edx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	ecx, edi
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 202  :             U32 const rest = total - weightTotal;

	sub	edx, r9d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	ecx, eax
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 203  :             U32 const verif = 1 << BIT_highbit32(rest);

	shl	r10d, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, edx
	cmovne	edi, eax
; File E:\dev\pyzstd\lib\common\entropy_common.c

; 204  :             U32 const lastWeight = BIT_highbit32(rest) + 1;

	inc	edi

; 205  :             if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */

	cmp	r10d, edx
	jne	SHORT $LN20@HUF_readSt

; 206  :             huffWeight[oSize] = (BYTE)lastWeight;

	mov	BYTE PTR [rbx+r8], dil

; 207  :             rankStats[lastWeight]++;

	inc	DWORD PTR [rsi+rdi*4]

; 208  :     }   }
; 209  : 
; 210  :     /* check tree construction validity */
; 211  :     if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */

	mov	ecx, DWORD PTR [rsi+4]
	cmp	ecx, 2
	jb	SHORT $LN20@HUF_readSt
	test	cl, 1
	jne	SHORT $LN20@HUF_readSt

; 212  : 
; 213  :     /* results */
; 214  :     *nbSymbolsPtr = (U32)(oSize+1);

	lea	ecx, DWORD PTR [r8+1]

; 215  :     return iSize+1;

	mov	rax, rbp
	mov	DWORD PTR [r14], ecx
	jmp	SHORT $LN1@HUF_readSt
$LN20@HUF_readSt:

; 208  :     }   }
; 209  : 
; 210  :     /* check tree construction validity */
; 211  :     if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */

	mov	rax, -20
	jmp	SHORT $LN1@HUF_readSt
$LN42@HUF_readSt:

; 179  :     else  {   /* header compressed with FSE (normal case) */
; 180  :         FSE_DTable fseWorkspace[FSE_DTABLE_SIZE_U32(6)];  /* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) */
; 181  :         if (iSize+1 > srcSize) return ERROR(srcSize_wrong);

	mov	rax, -72				; ffffffffffffffb8H
$LN1@HUF_readSt:

; 216  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+408]
	add	rsp, 352				; 00000160H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
HUF_readStats ENDP
_TEXT	ENDS
END
