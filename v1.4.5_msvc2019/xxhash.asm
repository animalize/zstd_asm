; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

PRIME32_1 DD	09e3779b1H
PRIME32_2 DD	085ebca77H
PRIME32_5 DD	0165667b1H
PRIME32_4 DD	027d4eb2fH
PRIME64_3 DQ	165667b19e3779f9H
PRIME64_5 DQ	27d4eb2f165667c5H
PRIME64_1 DQ	9e3779b185ebca87H
PRIME64_4 DQ	85ebca77c2b2ae63H
PRIME64_2 DQ	c2b2ae3d27d4eb4fH
g_one	DD	01H
PRIME32_3 DD	0c2b2ae3dH
PUBLIC	XXH64_digest
PUBLIC	XXH64_update
PUBLIC	XXH64_reset
PUBLIC	XXH64
pdata	SEGMENT
$pdata$XXH64_digest DD imagerel $LN117
	DD	imagerel $LN117+460
	DD	imagerel $unwind$XXH64_digest
$pdata$XXH64_digest_endian DD imagerel XXH64_digest_endian
	DD	imagerel XXH64_digest_endian+478
	DD	imagerel $unwind$XXH64_digest_endian
$pdata$XXH64_update DD imagerel $LN241
	DD	imagerel $LN241+82
	DD	imagerel $unwind$XXH64_update
$pdata$1$XXH64_update DD imagerel $LN241+82
	DD	imagerel $LN241+403
	DD	imagerel $chain$1$XXH64_update
$pdata$2$XXH64_update DD imagerel $LN241+403
	DD	imagerel $LN241+441
	DD	imagerel $chain$2$XXH64_update
$pdata$XXH64_update_endian DD imagerel XXH64_update_endian
	DD	imagerel XXH64_update_endian+82
	DD	imagerel $unwind$XXH64_update_endian
$pdata$1$XXH64_update_endian DD imagerel XXH64_update_endian+82
	DD	imagerel XXH64_update_endian+315
	DD	imagerel $chain$1$XXH64_update_endian
$pdata$2$XXH64_update_endian DD imagerel XXH64_update_endian+315
	DD	imagerel XXH64_update_endian+492
	DD	imagerel $chain$2$XXH64_update_endian
$pdata$3$XXH64_update_endian DD imagerel XXH64_update_endian+492
	DD	imagerel XXH64_update_endian+507
	DD	imagerel $chain$3$XXH64_update_endian
$pdata$4$XXH64_update_endian DD imagerel XXH64_update_endian+507
	DD	imagerel XXH64_update_endian+545
	DD	imagerel $chain$4$XXH64_update_endian
$pdata$XXH64_reset DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$XXH64_reset
$pdata$XXH64 DD	imagerel $LN378
	DD	imagerel $LN378+522
	DD	imagerel $unwind$XXH64
$pdata$XXH64_endian_align DD imagerel XXH64_endian_align
	DD	imagerel XXH64_endian_align+12
	DD	imagerel $unwind$XXH64_endian_align
$pdata$1$XXH64_endian_align DD imagerel XXH64_endian_align+12
	DD	imagerel XXH64_endian_align+28
	DD	imagerel $chain$1$XXH64_endian_align
$pdata$2$XXH64_endian_align DD imagerel XXH64_endian_align+28
	DD	imagerel XXH64_endian_align+90
	DD	imagerel $chain$2$XXH64_endian_align
$pdata$5$XXH64_endian_align DD imagerel XXH64_endian_align+90
	DD	imagerel XXH64_endian_align+452
	DD	imagerel $chain$5$XXH64_endian_align
$pdata$6$XXH64_endian_align DD imagerel XXH64_endian_align+452
	DD	imagerel XXH64_endian_align+472
	DD	imagerel $chain$6$XXH64_endian_align
$pdata$7$XXH64_endian_align DD imagerel XXH64_endian_align+472
	DD	imagerel XXH64_endian_align+545
	DD	imagerel $chain$7$XXH64_endian_align
$pdata$8$XXH64_endian_align DD imagerel XXH64_endian_align+545
	DD	imagerel XXH64_endian_align+592
	DD	imagerel $chain$8$XXH64_endian_align
$pdata$9$XXH64_endian_align DD imagerel XXH64_endian_align+592
	DD	imagerel XXH64_endian_align+665
	DD	imagerel $chain$9$XXH64_endian_align
$pdata$XXH_memcpy DD imagerel XXH_memcpy
	DD	imagerel XXH_memcpy+23
	DD	imagerel $unwind$XXH_memcpy
xdata	SEGMENT
$unwind$XXH64_digest DD 0b1a01H
	DD	07741aH
	DD	06641aH
	DD	05541aH
	DD	04341aH
	DD	0e018f01aH
	DD	0c016H
$unwind$XXH64_digest_endian DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
$unwind$XXH64_update DD 060c01H
	DD	0a340cH
	DD	07008320cH
	DD	050066007H
$chain$1$XXH64_update DD 041421H
	DD	09f414H
	DD	08e405H
	DD	imagerel $LN241
	DD	imagerel $LN241+82
	DD	imagerel $unwind$XXH64_update
$chain$2$XXH64_update DD 021H
	DD	imagerel $LN241
	DD	imagerel $LN241+82
	DD	imagerel $unwind$XXH64_update
$unwind$XXH64_update_endian DD 060b01H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
$chain$1$XXH64_update_endian DD 041421H
	DD	0bd414H
	DD	0ac405H
	DD	imagerel XXH64_update_endian
	DD	imagerel XXH64_update_endian+82
	DD	imagerel $unwind$XXH64_update_endian
$chain$2$XXH64_update_endian DD 020521H
	DD	0cf405H
	DD	imagerel XXH64_update_endian+82
	DD	imagerel XXH64_update_endian+315
	DD	imagerel $chain$1$XXH64_update_endian
$chain$3$XXH64_update_endian DD 021H
	DD	imagerel XXH64_update_endian+82
	DD	imagerel XXH64_update_endian+315
	DD	imagerel $chain$1$XXH64_update_endian
$chain$4$XXH64_update_endian DD 021H
	DD	imagerel XXH64_update_endian
	DD	imagerel XXH64_update_endian+82
	DD	imagerel $unwind$XXH64_update_endian
$unwind$XXH64_reset DD 010401H
	DD	0c204H
$unwind$XXH64 DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
$unwind$XXH64_endian_align DD 030c01H
	DD	0d008220cH
	DD	03006H
$chain$1$XXH64_endian_align DD 040d21H
	DD	09740dH
	DD	086405H
	DD	imagerel XXH64_endian_align
	DD	imagerel XXH64_endian_align+12
	DD	imagerel $unwind$XXH64_endian_align
$chain$2$XXH64_endian_align DD 020521H
	DD	02c405H
	DD	imagerel XXH64_endian_align+12
	DD	imagerel XXH64_endian_align+28
	DD	imagerel $chain$1$XXH64_endian_align
$chain$5$XXH64_endian_align DD 062221H
	DD	0f422H
	DD	01e414H
	DD	065405H
	DD	imagerel XXH64_endian_align+28
	DD	imagerel XXH64_endian_align+90
	DD	imagerel $chain$2$XXH64_endian_align
$chain$6$XXH64_endian_align DD 021H
	DD	imagerel XXH64_endian_align+28
	DD	imagerel XXH64_endian_align+90
	DD	imagerel $chain$2$XXH64_endian_align
$chain$7$XXH64_endian_align DD 021H
	DD	imagerel XXH64_endian_align+12
	DD	imagerel XXH64_endian_align+28
	DD	imagerel $chain$1$XXH64_endian_align
$chain$8$XXH64_endian_align DD 020021H
	DD	097400H
	DD	imagerel XXH64_endian_align
	DD	imagerel XXH64_endian_align+12
	DD	imagerel $unwind$XXH64_endian_align
$chain$9$XXH64_endian_align DD 021H
	DD	imagerel XXH64_endian_align
	DD	imagerel XXH64_endian_align+12
	DD	imagerel $unwind$XXH64_endian_align
$unwind$XXH_memcpy DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
dest$ = 48
src$ = 56
size$ = 64
XXH_memcpy PROC

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	memcpy
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
XXH_memcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
memPtr$ = 8
XXH_read32 PROC

; 165  :     U32 val;
; 166  :     memcpy(&val, memPtr, sizeof(val));
; 167  :     return val;

	mov	eax, DWORD PTR [rcx]

; 168  : }

	ret	0
XXH_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
memPtr$ = 8
XXH_read64 PROC

; 172  :     U64 val;
; 173  :     memcpy(&val, memPtr, sizeof(val));
; 174  :     return val;

	mov	rax, QWORD PTR [rcx]

; 175  : }

	ret	0
XXH_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
ptr$ = 8
endian$ = 16
align$dead$ = 24
XXH_readLE32_align PROC

; 245  : {

	mov	eax, DWORD PTR [rcx]

; 246  :     if (align==XXH_unaligned)
; 247  :         return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));

	cmp	edx, 1
	je	SHORT $LN6@XXH_readLE
	bswap	eax
$LN6@XXH_readLE:

; 248  :     else
; 249  :         return endian==XXH_littleEndian ? *(const U32*)ptr : XXH_swap32(*(const U32*)ptr);
; 250  : }

	ret	0
XXH_readLE32_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
ptr$ = 8
endian$ = 16
XXH_readLE32 PROC

; 253  : {

	mov	eax, DWORD PTR [rcx]

; 247  :         return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));

	cmp	edx, 1
	je	SHORT $LN8@XXH_readLE
	bswap	eax
$LN8@XXH_readLE:

; 254  :     return XXH_readLE32_align(ptr, endian, XXH_unaligned);
; 255  : }

	ret	0
XXH_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
ptr$ = 8
endian$ = 16
align$dead$ = 24
XXH_readLE64_align PROC

; 263  : {

	mov	rax, QWORD PTR [rcx]

; 264  :     if (align==XXH_unaligned)
; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	edx, 1
	je	SHORT $LN6@XXH_readLE
	bswap	rax
$LN6@XXH_readLE:

; 266  :     else
; 267  :         return endian==XXH_littleEndian ? *(const U64*)ptr : XXH_swap64(*(const U64*)ptr);
; 268  : }

	ret	0
XXH_readLE64_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
ptr$ = 8
endian$ = 16
XXH_readLE64 PROC

; 271  : {

	mov	rax, QWORD PTR [rcx]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	edx, 1
	je	SHORT $LN8@XXH_readLE
	bswap	rax
$LN8@XXH_readLE:

; 272  :     return XXH_readLE64_align(ptr, endian, XXH_unaligned);
; 273  : }

	ret	0
XXH_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
acc$ = 8
input$ = 16
XXH64_round PROC

; 417  :     acc += input * PRIME64_2;

	mov	rax, -4417276706812531889		; c2b2ae3d27d4eb4fH
	imul	rdx, rax

; 418  :     acc  = XXH_rotl64(acc, 31);
; 419  :     acc *= PRIME64_1;

	mov	rax, -7046029288634856825		; 9e3779b185ebca87H
	add	rdx, rcx
	rol	rdx, 31
	imul	rax, rdx

; 420  :     return acc;
; 421  : }

	ret	0
XXH64_round ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
acc$ = 8
val$ = 16
XXH64_mergeRound PROC

; 417  :     acc += input * PRIME64_2;

	mov	rax, -4417276706812531889		; c2b2ae3d27d4eb4fH
	imul	rdx, rax

; 418  :     acc  = XXH_rotl64(acc, 31);
; 419  :     acc *= PRIME64_1;

	mov	rax, -7046029288634856825		; 9e3779b185ebca87H
	rol	rdx, 31
	imul	rdx, rax

; 425  :     val  = XXH64_round(0, val);
; 426  :     acc ^= val;

	xor	rdx, rcx

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rdx, rax
	mov	rax, 8796714831421723037		; 7a1435883d4d519dH
	sub	rdx, rax

; 428  :     return acc;

	mov	rax, rdx

; 429  : }

	ret	0
XXH64_mergeRound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
input$ = 48
len$ = 56
seed$dead$ = 64
endian$ = 72
align$dead$ = 80
XXH64_endian_align PROC

; 432  : {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	r13
	sub	rsp, 24
	mov	QWORD PTR [rsp+64], rsi
	mov	r8, rcx
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, r9d
	mov	QWORD PTR [rsp+16], r12
	mov	r12, rdx

; 433  :     const BYTE* p = (const BYTE*)input;
; 434  :     const BYTE* const bEnd = p + len;

	lea	rbx, QWORD PTR [rcx+rdx]

; 435  :     U64 h64;
; 436  : #define XXH_get64bits(p) XXH_readLE64_align(p, endian, align)
; 437  : 
; 438  : #ifdef XXH_ACCEPT_NULL_INPUT_POINTER
; 439  :     if (p==NULL) {
; 440  :         len=0;
; 441  :         bEnd=p=(const BYTE*)(size_t)32;
; 442  :     }
; 443  : #endif
; 444  : 
; 445  :     if (len>=32) {

	mov	r9, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	rsi, 8796714831421723037		; 7a1435883d4d519dH
	mov	r10, 2870177450012600261		; 27d4eb2f165667c5H
	mov	r13, -7046029288634856825		; 9e3779b185ebca87H
	cmp	rdx, 32					; 00000020H
	jb	$LN9@XXH64_endi

; 446  :         const BYTE* const limit = bEnd - 32;

	mov	QWORD PTR [rsp+48], rbp

; 447  :         U64 v1 = seed + PRIME64_1 + PRIME64_2;
; 448  :         U64 v2 = seed + PRIME64_2;

	mov	r12, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	QWORD PTR [rsp+8], r14
	mov	r9, 6983438078262162902			; 60ea27eeadc0b5d6H
	mov	QWORD PTR [rsp], r15
	mov	r10, r12
	lea	r15, QWORD PTR [rbx-32]

; 449  :         U64 v3 = seed + 0;

	xor	edx, edx

; 450  :         U64 v4 = seed - PRIME64_1;

	mov	r11, 7046029288634856825		; 61c8864e7a143579H
	npad	1
$LL4@XXH64_endi:

; 264  :     if (align==XXH_unaligned)

	mov	rcx, r10
	lea	r10, QWORD PTR [r8+8]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	mov	rax, QWORD PTR [r10+16]
	mov	r14, r9
	mov	rbp, r9
	mov	r9, QWORD PTR [r8]
	lea	r8, QWORD PTR [r10+16]
	mov	rsi, rdx
	mov	rdx, QWORD PTR [r10+8]
	mov	r10, QWORD PTR [r10]
	cmp	edi, 1
	jne	SHORT $LN17@XXH64_endi
	imul	r9, r12
	add	r9, rbp
	jmp	SHORT $LN101@XXH64_endi
$LN17@XXH64_endi:
	bswap	r9
	imul	r9, r12
	bswap	rax
	add	r9, r14
	bswap	rdx
	bswap	r10
$LN101@XXH64_endi:

; 417  :     acc += input * PRIME64_2;

	imul	rdx, r12
	imul	r10, r12
	imul	rax, r12
	add	rdx, rsi
	rol	r9, 31
	add	r10, rcx
	rol	rdx, 31
	rol	r10, 31

; 451  : 
; 452  :         do {
; 453  :             v1 = XXH64_round(v1, XXH_get64bits(p)); p+=8;
; 454  :             v2 = XXH64_round(v2, XXH_get64bits(p)); p+=8;
; 455  :             v3 = XXH64_round(v3, XXH_get64bits(p)); p+=8;
; 456  :             v4 = XXH64_round(v4, XXH_get64bits(p)); p+=8;

	add	r8, 8

; 417  :     acc += input * PRIME64_2;

	imul	rdx, r13
	imul	r10, r13
	imul	r9, r13
	add	r11, rax

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r11, 31

; 419  :     acc *= PRIME64_1;

	imul	r11, r13

; 457  :         } while (p<=limit);

	cmp	r8, r15
	jbe	$LL4@XXH64_endi

; 460  :         h64 = XXH64_mergeRound(h64, v1);
; 461  :         h64 = XXH64_mergeRound(h64, v2);
; 462  :         h64 = XXH64_mergeRound(h64, v3);
; 463  :         h64 = XXH64_mergeRound(h64, v4);
; 464  : 
; 465  :     } else {

	mov	r15, QWORD PTR [rsp]
	mov	rax, r11
	mov	r14, QWORD PTR [rsp+8]
	mov	rcx, rdx
	mov	rbp, QWORD PTR [rsp+48]

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	mov	rsi, 8796714831421723037		; 7a1435883d4d519dH

; 458  : 
; 459  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	rol	rax, 18
	rol	rcx, 12
	add	rax, rcx
	mov	rcx, r10

; 417  :     acc += input * PRIME64_2;

	imul	r10, r12
	imul	rdx, r12
	imul	r11, r12

; 458  : 
; 459  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	rol	rcx, 7
	add	rax, rcx

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r10, 31

; 458  : 
; 459  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	mov	rcx, r9

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rdx, 31

; 417  :     acc += input * PRIME64_2;

	imul	r9, r12

; 419  :     acc *= PRIME64_1;

	imul	r10, r13
	imul	rdx, r13

; 460  :         h64 = XXH64_mergeRound(h64, v1);
; 461  :         h64 = XXH64_mergeRound(h64, v2);
; 462  :         h64 = XXH64_mergeRound(h64, v3);
; 463  :         h64 = XXH64_mergeRound(h64, v4);
; 464  : 
; 465  :     } else {

	mov	r12, QWORD PTR len$[rsp]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31

; 419  :     acc *= PRIME64_1;

	imul	r9, r13

; 458  : 
; 459  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	rol	rcx, 1
	add	rax, rcx

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r11, 31

; 426  :     acc ^= val;

	xor	rax, r9

; 460  :         h64 = XXH64_mergeRound(h64, v1);
; 461  :         h64 = XXH64_mergeRound(h64, v2);
; 462  :         h64 = XXH64_mergeRound(h64, v3);
; 463  :         h64 = XXH64_mergeRound(h64, v4);
; 464  : 
; 465  :     } else {

	mov	r9, -4417276706812531889		; c2b2ae3d27d4eb4fH

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, r13

; 419  :     acc *= PRIME64_1;

	imul	r11, r13

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	rax, rsi

; 426  :     acc ^= val;

	xor	rax, r10

; 460  :         h64 = XXH64_mergeRound(h64, v1);
; 461  :         h64 = XXH64_mergeRound(h64, v2);
; 462  :         h64 = XXH64_mergeRound(h64, v3);
; 463  :         h64 = XXH64_mergeRound(h64, v4);
; 464  : 
; 465  :     } else {

	mov	r10, 2870177450012600261		; 27d4eb2f165667c5H

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, r13
	sub	rax, rsi

; 426  :     acc ^= val;

	xor	rax, rdx

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, r13
	sub	rax, rsi

; 426  :     acc ^= val;

	xor	rax, r11

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, r13
	sub	rax, rsi

; 460  :         h64 = XXH64_mergeRound(h64, v1);
; 461  :         h64 = XXH64_mergeRound(h64, v2);
; 462  :         h64 = XXH64_mergeRound(h64, v3);
; 463  :         h64 = XXH64_mergeRound(h64, v4);
; 464  : 
; 465  :     } else {

	jmp	SHORT $LN10@XXH64_endi
$LN9@XXH64_endi:

; 466  :         h64  = seed + PRIME64_5;

	mov	rax, r10
$LN10@XXH64_endi:

; 467  :     }
; 468  : 
; 469  :     h64 += (U64) len;

	add	rax, r12

; 470  : 
; 471  :     while (p+8<=bEnd) {

	lea	rdx, QWORD PTR [r8+8]
	mov	r12, QWORD PTR [rsp+16]
	cmp	rdx, rbx
	ja	SHORT $LN6@XXH64_endi
$LL5@XXH64_endi:

; 264  :     if (align==XXH_unaligned)

	mov	rcx, QWORD PTR [r8]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	edi, 1
	je	SHORT $LN74@XXH64_endi
	bswap	rcx
$LN74@XXH64_endi:

; 417  :     acc += input * PRIME64_2;

	imul	rcx, r9

; 475  :         p+=8;

	mov	r8, rdx
	add	rdx, 8

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rcx, 31

; 419  :     acc *= PRIME64_1;

	imul	rcx, r13

; 472  :         U64 const k1 = XXH64_round(0, XXH_get64bits(p));
; 473  :         h64 ^= k1;

	xor	rax, rcx

; 474  :         h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;

	rol	rax, 27
	imul	rax, r13
	sub	rax, rsi
	cmp	rdx, rbx
	jbe	SHORT $LL5@XXH64_endi
$LN6@XXH64_endi:

; 476  :     }
; 477  : 
; 478  :     if (p+4<=bEnd) {

	mov	rsi, QWORD PTR [rsp+64]
	lea	rdx, QWORD PTR [r8+4]
	mov	r11, 1609587929392839161		; 165667b19e3779f9H
	cmp	rdx, rbx
	ja	SHORT $LN89@XXH64_endi

; 246  :     if (align==XXH_unaligned)

	mov	ecx, DWORD PTR [r8]

; 247  :         return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));

	cmp	edi, 1
	je	SHORT $LN84@XXH64_endi
	bswap	ecx
$LN84@XXH64_endi:

; 479  :         h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1;

	mov	ecx, ecx

; 480  :         h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
; 481  :         p+=4;

	mov	r8, rdx
	imul	rcx, r13
	xor	rax, rcx
	rol	rax, 23
	imul	rax, r9
	add	rax, r11
$LN89@XXH64_endi:

; 482  :     }
; 483  : 
; 484  :     while (p<bEnd) {

	mov	rdi, QWORD PTR [rsp+72]
	cmp	r8, rbx
	jae	SHORT $LN8@XXH64_endi
	npad	4
$LL7@XXH64_endi:

; 485  :         h64 ^= (*p) * PRIME64_5;

	movzx	ecx, BYTE PTR [r8]

; 486  :         h64 = XXH_rotl64(h64, 11) * PRIME64_1;
; 487  :         p++;

	inc	r8
	imul	rcx, r10
	xor	rax, rcx
	rol	rax, 11
	imul	rax, r13
	cmp	r8, rbx
	jb	SHORT $LL7@XXH64_endi
$LN8@XXH64_endi:

; 488  :     }
; 489  : 
; 490  :     h64 ^= h64 >> 33;

	mov	rcx, rax
	shr	rcx, 33					; 00000021H
	xor	rcx, rax

; 491  :     h64 *= PRIME64_2;

	imul	rcx, r9

; 492  :     h64 ^= h64 >> 29;

	mov	rdx, rcx
	shr	rdx, 29
	xor	rdx, rcx

; 493  :     h64 *= PRIME64_3;

	imul	rdx, r11

; 494  :     h64 ^= h64 >> 32;

	mov	rax, rdx
	shr	rax, 32					; 00000020H
	xor	rax, rdx

; 495  : 
; 496  :     return h64;
; 497  : }

	add	rsp, 24
	pop	r13
	pop	rbx
	ret	0
XXH64_endian_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
input$ = 24
len$ = 32
seed$dead$ = 40
XXH64	PROC

; 501  : {

$LN378:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 434  :     const BYTE* const bEnd = p + len;

	lea	rbx, QWORD PTR [rcx+rdx]

; 501  : {

	mov	rdi, rdx
	mov	r8, rcx

; 445  :     if (len>=32) {

	mov	rbp, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	rsi, -7046029288634856825		; 9e3779b185ebca87H
	mov	r14, 2870177450012600261		; 27d4eb2f165667c5H
	mov	r15, 8796714831421723037		; 7a1435883d4d519dH
	cmp	rdx, 32					; 00000020H
	jb	$LN191@XXH64

; 446  :         const BYTE* const limit = bEnd - 32;

	lea	rcx, QWORD PTR [rbx-32]

; 447  :         U64 v1 = seed + PRIME64_1 + PRIME64_2;

	mov	r9, 6983438078262162902			; 60ea27eeadc0b5d6H

; 448  :         U64 v2 = seed + PRIME64_2;

	mov	r10, rbp

; 449  :         U64 v3 = seed + 0;

	xor	edx, edx

; 450  :         U64 v4 = seed - PRIME64_1;

	mov	r11, 7046029288634856825		; 61c8864e7a143579H
$LL186@XXH64:

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [r8]
	imul	rax, rbp
	add	r9, rax
	mov	rax, QWORD PTR [r8+8]
	imul	rax, rbp

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31

; 417  :     acc += input * PRIME64_2;

	add	r10, rax
	mov	rax, QWORD PTR [r8+16]
	imul	rax, rbp

; 419  :     acc *= PRIME64_1;

	imul	r9, rsi

; 417  :     acc += input * PRIME64_2;

	add	rdx, rax

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r10, 31

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [r8+24]

; 456  :             v4 = XXH64_round(v4, XXH_get64bits(p)); p+=8;

	add	r8, 32					; 00000020H

; 417  :     acc += input * PRIME64_2;

	imul	rax, rbp

; 419  :     acc *= PRIME64_1;

	imul	r10, rsi

; 417  :     acc += input * PRIME64_2;

	add	r11, rax

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rdx, 31
	rol	r11, 31

; 419  :     acc *= PRIME64_1;

	imul	r11, rsi
	imul	rdx, rsi

; 457  :         } while (p<=limit);

	cmp	r8, rcx
	jbe	SHORT $LL186@XXH64

; 458  : 
; 459  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	mov	rax, r11
	mov	rcx, rdx
	rol	rax, 18
	rol	rcx, 12
	add	rax, rcx
	mov	rcx, r10
	rol	rcx, 7
	add	rax, rcx
	mov	rcx, r9

; 417  :     acc += input * PRIME64_2;

	imul	r9, rbp
	imul	r10, rbp
	imul	rdx, rbp
	imul	r11, rbp

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31

; 419  :     acc *= PRIME64_1;

	imul	r9, rsi

; 459  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	rol	rcx, 1
	add	rax, rcx

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r10, 31

; 426  :     acc ^= val;

	xor	rax, r9

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rdx, 31

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, rsi

; 419  :     acc *= PRIME64_1;

	imul	r10, rsi
	imul	rdx, rsi

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	rax, r15

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r11, 31

; 426  :     acc ^= val;

	xor	rax, r10

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, rsi

; 419  :     acc *= PRIME64_1;

	imul	r11, rsi

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	rax, r15

; 426  :     acc ^= val;

	xor	rax, rdx

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, rsi
	sub	rax, r15

; 426  :     acc ^= val;

	xor	rax, r11

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	rax, rsi
	sub	rax, r15

; 465  :     } else {

	jmp	SHORT $LN192@XXH64
$LN191@XXH64:

; 466  :         h64  = seed + PRIME64_5;

	mov	rax, r14
$LN192@XXH64:

; 467  :     }
; 468  : 
; 469  :     h64 += (U64) len;

	add	rax, rdi

; 470  : 
; 471  :     while (p+8<=bEnd) {

	lea	rdx, QWORD PTR [r8+8]
	cmp	rdx, rbx
	ja	SHORT $LN188@XXH64
$LL187@XXH64:

; 417  :     acc += input * PRIME64_2;

	mov	rcx, QWORD PTR [r8]

; 475  :         p+=8;

	mov	r8, rdx

; 417  :     acc += input * PRIME64_2;

	imul	rcx, rbp

; 471  :     while (p+8<=bEnd) {

	add	rdx, 8

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rcx, 31

; 419  :     acc *= PRIME64_1;

	imul	rcx, rsi

; 473  :         h64 ^= k1;

	xor	rax, rcx

; 474  :         h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;

	rol	rax, 27
	imul	rax, rsi
	sub	rax, r15
	cmp	rdx, rbx
	jbe	SHORT $LL187@XXH64
$LN188@XXH64:

; 476  :     }
; 477  : 
; 478  :     if (p+4<=bEnd) {

	lea	rdx, QWORD PTR [r8+4]
	mov	r9, 1609587929392839161			; 165667b19e3779f9H
	cmp	rdx, rbx
	ja	SHORT $LN360@XXH64

; 479  :         h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1;

	mov	ecx, DWORD PTR [r8]

; 480  :         h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
; 481  :         p+=4;

	mov	r8, rdx
	imul	rcx, rsi
	xor	rax, rcx
	rol	rax, 23
	imul	rax, rbp
	add	rax, r9
$LN360@XXH64:

; 482  :     }
; 483  : 
; 484  :     while (p<bEnd) {

	cmp	r8, rbx
	jae	SHORT $LN190@XXH64
	npad	5
$LL189@XXH64:

; 485  :         h64 ^= (*p) * PRIME64_5;

	movzx	ecx, BYTE PTR [r8]

; 486  :         h64 = XXH_rotl64(h64, 11) * PRIME64_1;
; 487  :         p++;

	inc	r8
	imul	rcx, r14
	xor	rax, rcx
	rol	rax, 11
	imul	rax, rsi
	cmp	r8, rbx
	jb	SHORT $LL189@XXH64
$LN190@XXH64:

; 502  : #if 0
; 503  :     /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
; 504  :     XXH64_CREATESTATE_STATIC(state);
; 505  :     XXH64_reset(state, seed);
; 506  :     XXH64_update(state, input, len);
; 507  :     return XXH64_digest(state);
; 508  : #else
; 509  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 510  : 
; 511  :     if (XXH_FORCE_ALIGN_CHECK) {
; 512  :         if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
; 513  :             if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 514  :                 return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
; 515  :             else
; 516  :                 return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
; 517  :     }   }
; 518  : 
; 519  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 520  :         return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
; 521  :     else
; 522  :         return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
; 523  : #endif
; 524  : }

	mov	rbx, QWORD PTR [rsp+24]

; 490  :     h64 ^= h64 >> 33;

	mov	rcx, rax

; 502  : #if 0
; 503  :     /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
; 504  :     XXH64_CREATESTATE_STATIC(state);
; 505  :     XXH64_reset(state, seed);
; 506  :     XXH64_update(state, input, len);
; 507  :     return XXH64_digest(state);
; 508  : #else
; 509  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 510  : 
; 511  :     if (XXH_FORCE_ALIGN_CHECK) {
; 512  :         if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
; 513  :             if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 514  :                 return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
; 515  :             else
; 516  :                 return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
; 517  :     }   }
; 518  : 
; 519  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 520  :         return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
; 521  :     else
; 522  :         return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
; 523  : #endif
; 524  : }

	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]

; 490  :     h64 ^= h64 >> 33;

	shr	rcx, 33					; 00000021H
	xor	rcx, rax

; 491  :     h64 *= PRIME64_2;

	imul	rcx, rbp

; 502  : #if 0
; 503  :     /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
; 504  :     XXH64_CREATESTATE_STATIC(state);
; 505  :     XXH64_reset(state, seed);
; 506  :     XXH64_update(state, input, len);
; 507  :     return XXH64_digest(state);
; 508  : #else
; 509  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 510  : 
; 511  :     if (XXH_FORCE_ALIGN_CHECK) {
; 512  :         if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
; 513  :             if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 514  :                 return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
; 515  :             else
; 516  :                 return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
; 517  :     }   }
; 518  : 
; 519  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 520  :         return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
; 521  :     else
; 522  :         return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
; 523  : #endif
; 524  : }

	mov	rbp, QWORD PTR [rsp+32]

; 492  :     h64 ^= h64 >> 29;

	mov	rdx, rcx
	shr	rdx, 29
	xor	rdx, rcx

; 493  :     h64 *= PRIME64_3;

	imul	rdx, r9

; 494  :     h64 ^= h64 >> 32;

	mov	rax, rdx
	shr	rax, 32					; 00000020H
	xor	rax, rdx

; 502  : #if 0
; 503  :     /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
; 504  :     XXH64_CREATESTATE_STATIC(state);
; 505  :     XXH64_reset(state, seed);
; 506  :     XXH64_update(state, input, len);
; 507  :     return XXH64_digest(state);
; 508  : #else
; 509  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 510  : 
; 511  :     if (XXH_FORCE_ALIGN_CHECK) {
; 512  :         if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
; 513  :             if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 514  :                 return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
; 515  :             else
; 516  :                 return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
; 517  :     }   }
; 518  : 
; 519  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 520  :         return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
; 521  :     else
; 522  :         return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
; 523  : #endif
; 524  : }

	pop	r15
	pop	r14
	ret	0
XXH64	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
state$ = 0
statePtr$ = 112
seed$dead$ = 120
XXH64_reset PROC

; 568  : {

$LN4:
	sub	rsp, 104				; 00000068H

; 569  :     XXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
; 570  :     memset(&state, 0, sizeof(state)-8);   /* do not write into reserved, for future removal */

	xor	edx, edx

; 571  :     state.v1 = seed + PRIME64_1 + PRIME64_2;

	mov	rax, 6983438078262162902		; 60ea27eeadc0b5d6H
	mov	QWORD PTR state$[rsp+8], rax
	xorps	xmm2, xmm2

; 572  :     state.v2 = seed + PRIME64_2;

	mov	rax, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	QWORD PTR state$[rsp], rdx

; 573  :     state.v3 = seed + 0;
; 574  :     state.v4 = seed - PRIME64_1;
; 575  :     memcpy(statePtr, &state, sizeof(state));

	movaps	xmm0, XMMWORD PTR state$[rsp]
	xorps	xmm3, xmm3
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR state$[rsp+16], rax
	mov	rax, 7046029288634856825		; 61c8864e7a143579H
	mov	QWORD PTR state$[rsp+32], rax

; 576  :     return XXH_OK;

	xor	eax, eax
	mov	QWORD PTR state$[rsp+24], rdx
	movaps	xmm1, XMMWORD PTR state$[rsp+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	mov	QWORD PTR state$[rsp+40], rdx
	movaps	xmm0, XMMWORD PTR state$[rsp+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movsd	xmm0, QWORD PTR state$[rsp+80]
	movups	XMMWORD PTR [rcx+48], xmm2
	movups	XMMWORD PTR [rcx+64], xmm3
	movsd	QWORD PTR [rcx+80], xmm0

; 577  : }

	add	rsp, 104				; 00000068H
	ret	0
XXH64_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
state$ = 80
input$ = 88
len$ = 96
endian$ = 104
XXH64_update_endian PROC

; 701  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 702  :     const BYTE* p = (const BYTE*)input;
; 703  :     const BYTE* const bEnd = p + len;
; 704  : 
; 705  : #ifdef XXH_ACCEPT_NULL_INPUT_POINTER
; 706  :     if (input==NULL) return XXH_ERROR;
; 707  : #endif
; 708  : 
; 709  :     state->total_len += len;

	add	QWORD PTR [rcx], r8
	lea	r14, QWORD PTR [rdx+r8]
	mov	rbx, rcx
	mov	ebp, r9d

; 710  : 
; 711  :     if (state->memsize + len < 32) {  /* fill in tmp buffer */

	mov	ecx, DWORD PTR [rcx+72]
	mov	rsi, r8
	mov	rdi, rdx
	lea	rax, QWORD PTR [rcx+r8]
	cmp	rax, 32					; 00000020H
	jae	SHORT $LN5@XXH64_upda

; 712  :         if (input != NULL) {

	test	rdx, rdx
	je	SHORT $LN6@XXH64_upda

; 713  :             XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, len);

	add	rcx, 40					; 00000028H
	add	rcx, rbx

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	call	memcpy
	mov	ecx, DWORD PTR [rbx+72]
$LN6@XXH64_upda:

; 714  :         }
; 715  :         state->memsize += (U32)len;

	lea	eax, DWORD PTR [rsi+rcx]
	mov	DWORD PTR [rbx+72], eax

; 752  :     }
; 753  : 
; 754  :     return XXH_OK;
; 755  : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN5@XXH64_upda:
	mov	QWORD PTR [rsp+80], r12

; 716  :         return XXH_OK;
; 717  :     }
; 718  : 
; 719  :     if (state->memsize) {   /* tmp buffer is full */

	mov	r12, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	QWORD PTR [rsp+88], r13
	mov	r13, -7046029288634856825		; 9e3779b185ebca87H
	test	ecx, ecx
	je	$LN117@XXH64_upda

; 720  :         XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, 32-state->memsize);

	mov	esi, 32					; 00000020H
	mov	r8d, esi
	sub	r8d, ecx
	add	rcx, 40					; 00000028H
	add	rcx, rbx

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	call	memcpy

; 721  :         state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0, endian));

	mov	rax, QWORD PTR [rbx+40]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	ebp, 1
	je	SHORT $LN22@XXH64_upda
	bswap	rax
$LN22@XXH64_upda:

; 417  :     acc += input * PRIME64_2;

	imul	rax, r12
	add	rax, QWORD PTR [rbx+8]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r13

; 721  :         state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0, endian));

	mov	QWORD PTR [rbx+8], rax

; 722  :         state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1, endian));

	mov	rax, QWORD PTR [rbx+48]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	ebp, 1
	je	SHORT $LN34@XXH64_upda
	bswap	rax
$LN34@XXH64_upda:

; 417  :     acc += input * PRIME64_2;

	imul	rax, r12
	add	rax, QWORD PTR [rbx+16]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r13

; 722  :         state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1, endian));

	mov	QWORD PTR [rbx+16], rax

; 723  :         state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2, endian));

	mov	rax, QWORD PTR [rbx+56]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	ebp, 1
	je	SHORT $LN46@XXH64_upda
	bswap	rax
$LN46@XXH64_upda:

; 417  :     acc += input * PRIME64_2;

	imul	rax, r12
	add	rax, QWORD PTR [rbx+24]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r13

; 723  :         state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2, endian));

	mov	QWORD PTR [rbx+24], rax

; 724  :         state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3, endian));

	mov	rax, QWORD PTR [rbx+64]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	ebp, 1
	je	SHORT $LN58@XXH64_upda
	bswap	rax
$LN58@XXH64_upda:

; 725  :         p += 32-state->memsize;

	sub	esi, DWORD PTR [rbx+72]

; 417  :     acc += input * PRIME64_2;

	imul	rax, r12

; 726  :         state->memsize = 0;

	mov	DWORD PTR [rbx+72], 0

; 417  :     acc += input * PRIME64_2;

	add	rax, QWORD PTR [rbx+32]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r13

; 724  :         state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3, endian));

	mov	QWORD PTR [rbx+32], rax

; 725  :         p += 32-state->memsize;

	mov	eax, esi
	add	rdi, rax
$LN117@XXH64_upda:

; 727  :     }
; 728  : 
; 729  :     if (p+32 <= bEnd) {

	lea	rax, QWORD PTR [rdi+32]
	cmp	rax, r14
	ja	$LN8@XXH64_upda

; 730  :         const BYTE* const limit = bEnd - 32;
; 731  :         U64 v1 = state->v1;

	mov	rax, QWORD PTR [rbx+8]

; 732  :         U64 v2 = state->v2;

	mov	r9, QWORD PTR [rbx+16]

; 733  :         U64 v3 = state->v3;

	mov	rcx, QWORD PTR [rbx+24]

; 734  :         U64 v4 = state->v4;

	mov	r8, QWORD PTR [rbx+32]
	mov	QWORD PTR [rsp+96], r15
	lea	r15, QWORD PTR [r14-32]
	npad	12
$LL4@XXH64_upda:

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	mov	rdx, QWORD PTR [rdi+8]
	mov	rsi, rcx
	lea	rcx, QWORD PTR [rdi+8]
	mov	r11, rax
	mov	r10, rax
	mov	rax, QWORD PTR [rdi]
	cmp	ebp, 1
	jne	SHORT $LN69@XXH64_upda
	imul	rax, r12
	add	rax, r10
	jmp	SHORT $LN120@XXH64_upda
$LN69@XXH64_upda:
	bswap	rax
	imul	rax, r12
	bswap	rdx
	add	rax, r11
$LN120@XXH64_upda:

; 417  :     acc += input * PRIME64_2;

	imul	rdx, r12
	rol	rax, 31

; 735  : 
; 736  :         do {
; 737  :             v1 = XXH64_round(v1, XXH_readLE64(p, endian)); p+=8;
; 738  :             v2 = XXH64_round(v2, XXH_readLE64(p, endian)); p+=8;

	lea	rdi, QWORD PTR [rcx+16]

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	mov	rcx, QWORD PTR [rcx+8]

; 417  :     acc += input * PRIME64_2;

	add	r9, rdx

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	mov	rdx, QWORD PTR [rdi]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31

; 419  :     acc *= PRIME64_1;

	imul	r9, r13
	imul	rax, r13

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	cmp	ebp, 1
	je	SHORT $LN121@XXH64_upda
	bswap	rdx
	bswap	rcx
$LN121@XXH64_upda:

; 417  :     acc += input * PRIME64_2;

	imul	rcx, r12
	imul	rdx, r12
	add	rcx, rsi

; 739  :             v3 = XXH64_round(v3, XXH_readLE64(p, endian)); p+=8;
; 740  :             v4 = XXH64_round(v4, XXH_readLE64(p, endian)); p+=8;

	add	rdi, 8

; 417  :     acc += input * PRIME64_2;

	rol	rcx, 31
	imul	rcx, r13
	add	r8, rdx

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r8, 31

; 419  :     acc *= PRIME64_1;

	imul	r8, r13

; 741  :         } while (p<=limit);

	cmp	rdi, r15
	jbe	$LL4@XXH64_upda

; 742  : 
; 743  :         state->v1 = v1;
; 744  :         state->v2 = v2;
; 745  :         state->v3 = v3;
; 746  :         state->v4 = v4;

	mov	r15, QWORD PTR [rsp+96]
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], r9
	mov	QWORD PTR [rbx+24], rcx
	mov	QWORD PTR [rbx+32], r8
$LN8@XXH64_upda:

; 747  :     }
; 748  : 
; 749  :     if (p < bEnd) {

	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+80]
	cmp	rdi, r14
	jae	SHORT $LN9@XXH64_upda

; 750  :         XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));

	mov	r8, r14
	lea	rcx, QWORD PTR [rbx+40]
	sub	r8, rdi

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	mov	rdx, rdi
	call	memcpy

; 751  :         state->memsize = (unsigned)(bEnd-p);

	sub	r14d, edi
	mov	DWORD PTR [rbx+72], r14d
$LN9@XXH64_upda:

; 752  :     }
; 753  : 
; 754  :     return XXH_OK;
; 755  : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
XXH64_update_endian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
state_in$ = 64
input$ = 72
len$ = 80
XXH64_update PROC

; 758  : {

$LN241:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 709  :     state->total_len += len;

	add	QWORD PTR [rcx], r8
	lea	rbp, QWORD PTR [rdx+r8]

; 758  : {

	mov	rbx, rcx
	mov	rdi, r8

; 711  :     if (state->memsize + len < 32) {  /* fill in tmp buffer */

	mov	ecx, DWORD PTR [rcx+72]

; 758  : {

	mov	rsi, rdx

; 711  :     if (state->memsize + len < 32) {  /* fill in tmp buffer */

	lea	rax, QWORD PTR [rcx+r8]
	cmp	rax, 32					; 00000020H
	jae	SHORT $LN10@XXH64_upda

; 712  :         if (input != NULL) {

	test	rdx, rdx
	je	SHORT $LN11@XXH64_upda

; 713  :             XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, len);

	add	rcx, 40					; 00000028H
	add	rcx, rbx

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	call	memcpy
	mov	ecx, DWORD PTR [rbx+72]
$LN11@XXH64_upda:

; 715  :         state->memsize += (U32)len;

	lea	eax, DWORD PTR [rcx+rdi]
	mov	DWORD PTR [rbx+72], eax

; 759  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 760  : 
; 761  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 762  :         return XXH64_update_endian(state_in, input, len, XXH_littleEndian);
; 763  :     else
; 764  :         return XXH64_update_endian(state_in, input, len, XXH_bigEndian);
; 765  : }

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN10@XXH64_upda:
	mov	QWORD PTR [rsp+64], r14

; 719  :     if (state->memsize) {   /* tmp buffer is full */

	mov	r14, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	QWORD PTR [rsp+72], r15
	mov	r15, -7046029288634856825		; 9e3779b185ebca87H
	test	ecx, ecx
	je	$LN238@XXH64_upda

; 720  :         XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, 32-state->memsize);

	mov	edi, 32					; 00000020H
	mov	r8d, edi
	sub	r8d, ecx
	add	rcx, 40					; 00000028H
	add	rcx, rbx

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	call	memcpy

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [rbx+40]

; 725  :         p += 32-state->memsize;

	sub	edi, DWORD PTR [rbx+72]

; 417  :     acc += input * PRIME64_2;

	imul	rax, r14
	add	rax, QWORD PTR [rbx+8]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r15

; 721  :         state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0, endian));

	mov	QWORD PTR [rbx+8], rax

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [rbx+48]
	imul	rax, r14
	add	rax, QWORD PTR [rbx+16]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r15

; 722  :         state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1, endian));

	mov	QWORD PTR [rbx+16], rax

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [rbx+56]
	imul	rax, r14
	add	rax, QWORD PTR [rbx+24]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r15

; 723  :         state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2, endian));

	mov	QWORD PTR [rbx+24], rax

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [rbx+64]
	imul	rax, r14

; 726  :         state->memsize = 0;

	mov	DWORD PTR [rbx+72], 0

; 417  :     acc += input * PRIME64_2;

	add	rax, QWORD PTR [rbx+32]

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rax, 31

; 419  :     acc *= PRIME64_1;

	imul	rax, r15

; 724  :         state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3, endian));

	mov	QWORD PTR [rbx+32], rax

; 725  :         p += 32-state->memsize;

	mov	eax, edi
	add	rsi, rax
$LN238@XXH64_upda:

; 727  :     }
; 728  : 
; 729  :     if (p+32 <= bEnd) {

	lea	rax, QWORD PTR [rsi+32]
	cmp	rax, rbp
	ja	$LN13@XXH64_upda

; 730  :         const BYTE* const limit = bEnd - 32;
; 731  :         U64 v1 = state->v1;

	mov	rdx, QWORD PTR [rbx+8]
	lea	r11, QWORD PTR [rbp-32]

; 732  :         U64 v2 = state->v2;

	mov	r8, QWORD PTR [rbx+16]

; 733  :         U64 v3 = state->v3;

	mov	r9, QWORD PTR [rbx+24]

; 734  :         U64 v4 = state->v4;

	mov	r10, QWORD PTR [rbx+32]
	npad	1
$LL9@XXH64_upda:

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [rsi]
	imul	rax, r14
	add	rdx, rax
	mov	rax, QWORD PTR [rsi+8]
	imul	rax, r14

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rdx, 31

; 417  :     acc += input * PRIME64_2;

	add	r8, rax
	mov	rax, QWORD PTR [rsi+16]
	imul	rax, r14

; 419  :     acc *= PRIME64_1;

	imul	rdx, r15

; 417  :     acc += input * PRIME64_2;

	add	r9, rax

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r8, 31

; 417  :     acc += input * PRIME64_2;

	mov	rax, QWORD PTR [rsi+24]

; 740  :             v4 = XXH64_round(v4, XXH_readLE64(p, endian)); p+=8;

	add	rsi, 32					; 00000020H

; 417  :     acc += input * PRIME64_2;

	imul	rax, r14

; 419  :     acc *= PRIME64_1;

	imul	r8, r15

; 417  :     acc += input * PRIME64_2;

	add	r10, rax

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31
	rol	r10, 31

; 419  :     acc *= PRIME64_1;

	imul	r10, r15
	imul	r9, r15

; 741  :         } while (p<=limit);

	cmp	rsi, r11
	jbe	SHORT $LL9@XXH64_upda

; 742  : 
; 743  :         state->v1 = v1;

	mov	QWORD PTR [rbx+8], rdx

; 744  :         state->v2 = v2;

	mov	QWORD PTR [rbx+16], r8

; 745  :         state->v3 = v3;

	mov	QWORD PTR [rbx+24], r9

; 746  :         state->v4 = v4;

	mov	QWORD PTR [rbx+32], r10
$LN13@XXH64_upda:
	mov	r15, QWORD PTR [rsp+72]

; 747  :     }
; 748  : 
; 749  :     if (p < bEnd) {

	mov	r14, QWORD PTR [rsp+64]
	cmp	rsi, rbp
	jae	SHORT $LN239@XXH64_upda

; 750  :         XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));

	mov	r8, rbp
	lea	rcx, QWORD PTR [rbx+40]
	sub	r8, rsi

; 87   : static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }

	mov	rdx, rsi
	call	memcpy

; 751  :         state->memsize = (unsigned)(bEnd-p);

	sub	ebp, esi
	mov	DWORD PTR [rbx+72], ebp
$LN239@XXH64_upda:

; 759  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 760  : 
; 761  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 762  :         return XXH64_update_endian(state_in, input, len, XXH_littleEndian);
; 763  :     else
; 764  :         return XXH64_update_endian(state_in, input, len, XXH_bigEndian);
; 765  : }

	mov	rbx, QWORD PTR [rsp+80]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
XXH64_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
state$ = 40
endian$ = 48
XXH64_digest_endian PROC

; 770  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 771  :     const BYTE * p = (const BYTE*)state->mem64;
; 772  :     const BYTE* const bEnd = (const BYTE*)state->mem64 + state->memsize;

	mov	eax, DWORD PTR [rcx+72]
	lea	rbx, QWORD PTR [rcx+40]

; 773  :     U64 h64;
; 774  : 
; 775  :     if (state->total_len >= 32) {

	mov	rbp, QWORD PTR [rcx]
	lea	r11, QWORD PTR [rcx+40]
	add	rbx, rax
	mov	esi, edx
	mov	rdi, rcx
	mov	r12, 2870177450012600261		; 27d4eb2f165667c5H
	mov	r15, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	r14, -7046029288634856825		; 9e3779b185ebca87H
	mov	r13, 8796714831421723037		; 7a1435883d4d519dH
	cmp	rbp, 32					; 00000020H
	jb	$LN6@XXH64_dige

; 776  :         U64 const v1 = state->v1;

	mov	rcx, QWORD PTR [rcx+8]

; 777  :         U64 const v2 = state->v2;
; 778  :         U64 const v3 = state->v3;

	mov	r8, QWORD PTR [rdi+24]

; 779  :         U64 const v4 = state->v4;

	mov	r9, QWORD PTR [rdi+32]

; 780  : 
; 781  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	mov	rax, r8
	mov	rdx, QWORD PTR [rdi+16]
	mov	r10, r9
	rol	r10, 18
	rol	rax, 12
	add	r10, rax
	mov	rax, rdx
	rol	rax, 7
	add	r10, rax
	mov	rax, rcx

; 417  :     acc += input * PRIME64_2;

	imul	rcx, r15
	imul	rdx, r15
	imul	r8, r15
	imul	r9, r15

; 780  : 
; 781  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	rol	rax, 1
	add	r10, rax

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rcx, 31

; 419  :     acc *= PRIME64_1;

	imul	rcx, r14

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rdx, 31

; 782  :         h64 = XXH64_mergeRound(h64, v1);
; 783  :         h64 = XXH64_mergeRound(h64, v2);
; 784  :         h64 = XXH64_mergeRound(h64, v3);
; 785  :         h64 = XXH64_mergeRound(h64, v4);

	mov	rax, -8796714831421723037		; 85ebca77c2b2ae63H

; 426  :     acc ^= val;

	xor	r10, rcx

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r8, 31

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, r14

; 419  :     acc *= PRIME64_1;

	imul	rdx, r14
	imul	r8, r14

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	r10, r13

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31

; 426  :     acc ^= val;

	xor	r10, rdx

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, r14

; 419  :     acc *= PRIME64_1;

	imul	r9, r14

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	r10, r13

; 426  :     acc ^= val;

	xor	r10, r8

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, r14
	sub	r10, r13

; 426  :     acc ^= val;

	xor	r10, r9

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, r14

; 782  :         h64 = XXH64_mergeRound(h64, v1);
; 783  :         h64 = XXH64_mergeRound(h64, v2);
; 784  :         h64 = XXH64_mergeRound(h64, v3);
; 785  :         h64 = XXH64_mergeRound(h64, v4);

	add	rax, r10

; 786  :     } else {

	jmp	SHORT $LN56@XXH64_dige
$LN6@XXH64_dige:

; 787  :         h64  = state->v3 + PRIME64_5;

	mov	rax, QWORD PTR [rcx+24]
	add	rax, r12
$LN56@XXH64_dige:

; 788  :     }
; 789  : 
; 790  :     h64 += (U64) state->total_len;
; 791  : 
; 792  :     while (p+8<=bEnd) {

	add	rax, rbp
	lea	rdx, QWORD PTR [rdi+48]
	cmp	rdx, rbx
	ja	SHORT $LN3@XXH64_dige
	npad	1
$LL2@XXH64_dige:

; 265  :         return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));

	mov	rcx, QWORD PTR [r11]
	cmp	esi, 1
	je	SHORT $LN33@XXH64_dige
	bswap	rcx
$LN33@XXH64_dige:

; 417  :     acc += input * PRIME64_2;

	imul	rcx, r15

; 796  :         p+=8;

	add	r11, 8
	add	rdx, 8

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rcx, 31

; 419  :     acc *= PRIME64_1;

	imul	rcx, r14

; 793  :         U64 const k1 = XXH64_round(0, XXH_readLE64(p, endian));
; 794  :         h64 ^= k1;

	xor	rax, rcx

; 795  :         h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;

	rol	rax, 27
	imul	rax, r14
	sub	rax, r13
	cmp	rdx, rbx
	jbe	SHORT $LL2@XXH64_dige
$LN3@XXH64_dige:

; 797  :     }
; 798  : 
; 799  :     if (p+4<=bEnd) {

	lea	rdx, QWORD PTR [r11+4]
	mov	r8, 1609587929392839161			; 165667b19e3779f9H
	cmp	rdx, rbx
	ja	SHORT $LN49@XXH64_dige

; 247  :         return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));

	mov	ecx, DWORD PTR [r11]
	cmp	esi, 1
	je	SHORT $LN45@XXH64_dige
	bswap	ecx
$LN45@XXH64_dige:

; 800  :         h64 ^= (U64)(XXH_readLE32(p, endian)) * PRIME64_1;

	mov	ecx, ecx

; 801  :         h64  = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
; 802  :         p+=4;

	mov	r11, rdx
	imul	rcx, r14
	xor	rax, rcx
	rol	rax, 23
	imul	rax, r15
	add	rax, r8
$LN49@XXH64_dige:

; 803  :     }
; 804  : 
; 805  :     while (p<bEnd) {

	cmp	r11, rbx
	jae	SHORT $LN5@XXH64_dige
	npad	5
$LL4@XXH64_dige:

; 806  :         h64 ^= (*p) * PRIME64_5;

	movzx	ecx, BYTE PTR [r11]

; 807  :         h64  = XXH_rotl64(h64, 11) * PRIME64_1;
; 808  :         p++;

	inc	r11
	imul	rcx, r12
	xor	rax, rcx
	rol	rax, 11
	imul	rax, r14
	cmp	r11, rbx
	jb	SHORT $LL4@XXH64_dige
$LN5@XXH64_dige:

; 809  :     }
; 810  : 
; 811  :     h64 ^= h64 >> 33;
; 812  :     h64 *= PRIME64_2;
; 813  :     h64 ^= h64 >> 29;
; 814  :     h64 *= PRIME64_3;
; 815  :     h64 ^= h64 >> 32;
; 816  : 
; 817  :     return h64;
; 818  : }

	mov	rbx, QWORD PTR [rsp+40]
	mov	rcx, rax
	mov	rbp, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	shr	rcx, 33					; 00000021H
	xor	rcx, rax
	imul	rcx, r15
	mov	rdx, rcx
	shr	rdx, 29
	xor	rdx, rcx
	imul	rdx, r8
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	xor	rax, rdx
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	ret	0
XXH64_digest_endian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\xxhash.c
_TEXT	SEGMENT
state_in$ = 32
XXH64_digest PROC

; 822  : {

$LN117:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	mov	eax, DWORD PTR [rcx+72]
	lea	rbx, QWORD PTR [rcx+40]
	mov	rsi, QWORD PTR [rcx]
	lea	r11, QWORD PTR [rcx+40]
	add	rbx, rax
	mov	rdi, rcx

; 775  :     if (state->total_len >= 32) {

	mov	rbp, -7046029288634856825		; 9e3779b185ebca87H
	mov	r15, 2870177450012600261		; 27d4eb2f165667c5H
	mov	r14, -4417276706812531889		; c2b2ae3d27d4eb4fH
	mov	r12, 8796714831421723037		; 7a1435883d4d519dH
	cmp	rsi, 32					; 00000020H
	jb	$LN11@XXH64_dige

; 776  :         U64 const v1 = state->v1;

	mov	rcx, QWORD PTR [rcx+8]

; 777  :         U64 const v2 = state->v2;
; 778  :         U64 const v3 = state->v3;

	mov	r8, QWORD PTR [rdi+24]

; 779  :         U64 const v4 = state->v4;

	mov	r9, QWORD PTR [rdi+32]

; 780  : 
; 781  :         h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

	mov	rax, r8
	mov	rdx, QWORD PTR [rdi+16]
	mov	r10, r9
	rol	r10, 18
	rol	rax, 12
	add	r10, rax
	mov	rax, rdx
	rol	rax, 7
	add	r10, rax
	mov	rax, rcx
	rol	rax, 1
	add	r10, rax

; 782  :         h64 = XXH64_mergeRound(h64, v1);
; 783  :         h64 = XXH64_mergeRound(h64, v2);
; 784  :         h64 = XXH64_mergeRound(h64, v3);
; 785  :         h64 = XXH64_mergeRound(h64, v4);

	mov	rax, -8796714831421723037		; 85ebca77c2b2ae63H

; 417  :     acc += input * PRIME64_2;

	imul	rcx, r14
	imul	rdx, r14
	imul	r8, r14
	imul	r9, r14

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rcx, 31

; 419  :     acc *= PRIME64_1;

	imul	rcx, rbp

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rdx, 31

; 426  :     acc ^= val;

	xor	r10, rcx

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r8, 31

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, rbp

; 419  :     acc *= PRIME64_1;

	imul	rdx, rbp
	imul	r8, rbp

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	r10, r12

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	r9, 31

; 426  :     acc ^= val;

	xor	r10, rdx

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, rbp

; 419  :     acc *= PRIME64_1;

	imul	r9, rbp

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	sub	r10, r12

; 426  :     acc ^= val;

	xor	r10, r8

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, rbp
	sub	r10, r12

; 426  :     acc ^= val;

	xor	r10, r9

; 427  :     acc  = acc * PRIME64_1 + PRIME64_4;

	imul	r10, rbp

; 785  :         h64 = XXH64_mergeRound(h64, v4);

	add	rax, r10
	add	rax, rsi

; 786  :     } else {

	jmp	SHORT $LN12@XXH64_dige
$LN11@XXH64_dige:

; 787  :         h64  = state->v3 + PRIME64_5;

	lea	rax, QWORD PTR [rsi+r15]
	add	rax, QWORD PTR [rcx+24]
$LN12@XXH64_dige:

; 788  :     }
; 789  : 
; 790  :     h64 += (U64) state->total_len;
; 791  : 
; 792  :     while (p+8<=bEnd) {

	lea	rdx, QWORD PTR [rdi+48]
	cmp	rdx, rbx
	ja	SHORT $LN8@XXH64_dige
	npad	4
$LL7@XXH64_dige:

; 417  :     acc += input * PRIME64_2;

	mov	rcx, QWORD PTR [r11]

; 796  :         p+=8;

	add	rdx, 8

; 417  :     acc += input * PRIME64_2;

	imul	rcx, r14

; 796  :         p+=8;

	add	r11, 8

; 418  :     acc  = XXH_rotl64(acc, 31);

	rol	rcx, 31

; 419  :     acc *= PRIME64_1;

	imul	rcx, rbp

; 794  :         h64 ^= k1;

	xor	rax, rcx

; 795  :         h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;

	rol	rax, 27
	imul	rax, rbp
	sub	rax, r12
	cmp	rdx, rbx
	jbe	SHORT $LL7@XXH64_dige
$LN8@XXH64_dige:

; 797  :     }
; 798  : 
; 799  :     if (p+4<=bEnd) {

	lea	rdx, QWORD PTR [r11+4]
	mov	r8, 1609587929392839161			; 165667b19e3779f9H
	cmp	rdx, rbx
	ja	SHORT $LN103@XXH64_dige

; 800  :         h64 ^= (U64)(XXH_readLE32(p, endian)) * PRIME64_1;

	mov	ecx, DWORD PTR [r11]

; 801  :         h64  = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
; 802  :         p+=4;

	mov	r11, rdx
	imul	rcx, rbp
	xor	rax, rcx
	rol	rax, 23
	imul	rax, r14
	add	rax, r8
$LN103@XXH64_dige:

; 803  :     }
; 804  : 
; 805  :     while (p<bEnd) {

	cmp	r11, rbx
	jae	SHORT $LN10@XXH64_dige
	npad	6
$LL9@XXH64_dige:

; 806  :         h64 ^= (*p) * PRIME64_5;

	movzx	ecx, BYTE PTR [r11]

; 807  :         h64  = XXH_rotl64(h64, 11) * PRIME64_1;
; 808  :         p++;

	inc	r11
	imul	rcx, r15
	xor	rax, rcx
	rol	rax, 11
	imul	rax, rbp
	cmp	r11, rbx
	jb	SHORT $LL9@XXH64_dige
$LN10@XXH64_dige:

; 823  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 824  : 
; 825  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 826  :         return XXH64_digest_endian(state_in, XXH_littleEndian);
; 827  :     else
; 828  :         return XXH64_digest_endian(state_in, XXH_bigEndian);
; 829  : }

	mov	rbx, QWORD PTR [rsp+32]

; 811  :     h64 ^= h64 >> 33;

	mov	rcx, rax

; 823  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 824  : 
; 825  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 826  :         return XXH64_digest_endian(state_in, XXH_littleEndian);
; 827  :     else
; 828  :         return XXH64_digest_endian(state_in, XXH_bigEndian);
; 829  : }

	mov	rbp, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]

; 811  :     h64 ^= h64 >> 33;

	shr	rcx, 33					; 00000021H
	xor	rcx, rax

; 812  :     h64 *= PRIME64_2;

	imul	rcx, r14

; 813  :     h64 ^= h64 >> 29;

	mov	rdx, rcx
	shr	rdx, 29
	xor	rdx, rcx

; 814  :     h64 *= PRIME64_3;

	imul	rdx, r8

; 815  :     h64 ^= h64 >> 32;

	mov	rax, rdx
	shr	rax, 32					; 00000020H
	xor	rax, rdx

; 823  :     XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
; 824  : 
; 825  :     if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
; 826  :         return XXH64_digest_endian(state_in, XXH_littleEndian);
; 827  :     else
; 828  :         return XXH64_digest_endian(state_in, XXH_bigEndian);
; 829  : }

	pop	r15
	pop	r14
	pop	r12
	ret	0
XXH64_digest ENDP
_TEXT	ENDS
END
