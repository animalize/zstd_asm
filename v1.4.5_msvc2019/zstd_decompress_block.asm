; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

LL_base	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	012H
	DD	014H
	DD	016H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	02000H
	DD	04000H
	DD	08000H
	DD	010000H
ML_base	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	020H
	DD	021H
	DD	022H
	DD	023H
	DD	025H
	DD	027H
	DD	029H
	DD	02bH
	DD	02fH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	083H
	DD	0103H
	DD	0203H
	DD	0403H
	DD	0803H
	DD	01003H
	DD	02003H
	DD	04003H
	DD	08003H
	DD	010003H
ZSTD_blockHeaderSize DQ 0000000000000003H
OF_defaultDTable DW 01H
	DB	01H
	DB	01H
	DD	05H
	DW	00H
	DB	00H
	DB	05H
	DD	00H
	DW	00H
	DB	06H
	DB	04H
	DD	03dH
	DW	00H
	DB	09H
	DB	05H
	DD	01fdH
	DW	00H
	DB	0fH
	DB	05H
	DD	07ffdH
	DW	00H
	DB	015H
	DB	05H
	DD	01ffffdH
	DW	00H
	DB	03H
	DB	05H
	DD	05H
	DW	00H
	DB	07H
	DB	04H
	DD	07dH
	DW	00H
	DB	0cH
	DB	05H
	DD	0ffdH
	DW	00H
	DB	012H
	DB	05H
	DD	03fffdH
	DW	00H
	DB	017H
	DB	05H
	DD	07ffffdH
	DW	00H
	DB	05H
	DB	05H
	DD	01dH
	DW	00H
	DB	08H
	DB	04H
	DD	0fdH
	DW	00H
	DB	0eH
	DB	05H
	DD	03ffdH
	DW	00H
	DB	014H
	DB	05H
	DD	0ffffdH
	DW	00H
	DB	02H
	DB	05H
	DD	01H
	DW	010H
	DB	07H
	DB	04H
	DD	07dH
	DW	00H
	DB	0bH
	DB	05H
	DD	07fdH
	DW	00H
	DB	011H
	DB	05H
	DD	01fffdH
	DW	00H
	DB	016H
	DB	05H
	DD	03ffffdH
	DW	00H
	DB	04H
	DB	05H
	DD	0dH
	DW	010H
	DB	08H
	DB	04H
	DD	0fdH
	DW	00H
	DB	0dH
	DB	05H
	DD	01ffdH
	DW	00H
	DB	013H
	DB	05H
	DD	07fffdH
	DW	00H
	DB	01H
	DB	05H
	DD	01H
	DW	010H
	DB	06H
	DB	04H
	DD	03dH
	DW	00H
	DB	0aH
	DB	05H
	DD	03fdH
	DW	00H
	DB	010H
	DB	05H
	DD	0fffdH
	DW	00H
	DB	01cH
	DB	05H
	DD	0ffffffdH
	DW	00H
	DB	01bH
	DB	05H
	DD	07fffffdH
	DW	00H
	DB	01aH
	DB	05H
	DD	03fffffdH
	DW	00H
	DB	019H
	DB	05H
	DD	01fffffdH
	DW	00H
	DB	018H
	DB	05H
	DD	0fffffdH
LL_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
?dec64table@?2??ZSTD_overlapCopy8@@9@9 DD 08H		; `ZSTD_overlapCopy8'::`3'::dec64table
	DD	08H
	DD	08H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
BIT_mask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	DD	01ffffH
	DD	03ffffH
	DD	07ffffH
	DD	0fffffH
	DD	01fffffH
	DD	03fffffH
	DD	07fffffH
	DD	0ffffffH
	DD	01ffffffH
	DD	03ffffffH
	DD	07ffffffH
	DD	0fffffffH
	DD	01fffffffH
	DD	03fffffffH
	DD	07fffffffH
OF_base	DD	00H
	DD	01H
	DD	01H
	DD	05H
	DD	0dH
	DD	01dH
	DD	03dH
	DD	07dH
	DD	0fdH
	DD	01fdH
	DD	03fdH
	DD	07fdH
	DD	0ffdH
	DD	01ffdH
	DD	03ffdH
	DD	07ffdH
	DD	0fffdH
	DD	01fffdH
	DD	03fffdH
	DD	07fffdH
	DD	0ffffdH
	DD	01ffffdH
	DD	03ffffdH
	DD	07ffffdH
	DD	0fffffdH
	DD	01fffffdH
	DD	03fffffdH
	DD	07fffffdH
	DD	0ffffffdH
	DD	01ffffffdH
	DD	03ffffffdH
	DD	07ffffffdH
ML_bits	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	ORG $+12
ML_defaultDTable DW 01H
	DB	01H
	DB	01H
	DD	06H
	DW	00H
	DB	00H
	DB	06H
	DD	03H
	DW	00H
	DB	00H
	DB	04H
	DD	04H
	DW	020H
	DB	00H
	DB	05H
	DD	05H
	DW	00H
	DB	00H
	DB	05H
	DD	06H
	DW	00H
	DB	00H
	DB	05H
	DD	08H
	DW	00H
	DB	00H
	DB	05H
	DD	09H
	DW	00H
	DB	00H
	DB	05H
	DD	0bH
	DW	00H
	DB	00H
	DB	06H
	DD	0dH
	DW	00H
	DB	00H
	DB	06H
	DD	010H
	DW	00H
	DB	00H
	DB	06H
	DD	013H
	DW	00H
	DB	00H
	DB	06H
	DD	016H
	DW	00H
	DB	00H
	DB	06H
	DD	019H
	DW	00H
	DB	00H
	DB	06H
	DD	01cH
	DW	00H
	DB	00H
	DB	06H
	DD	01fH
	DW	00H
	DB	00H
	DB	06H
	DD	022H
	DW	00H
	DB	01H
	DB	06H
	DD	025H
	DW	00H
	DB	01H
	DB	06H
	DD	029H
	DW	00H
	DB	02H
	DB	06H
	DD	02fH
	DW	00H
	DB	03H
	DB	06H
	DD	03bH
	DW	00H
	DB	04H
	DB	06H
	DD	053H
	DW	00H
	DB	07H
	DB	06H
	DD	083H
	DW	00H
	DB	09H
	DB	06H
	DD	0203H
	DW	010H
	DB	00H
	DB	04H
	DD	04H
	DW	00H
	DB	00H
	DB	04H
	DD	05H
	DW	020H
	DB	00H
	DB	05H
	DD	06H
	DW	00H
	DB	00H
	DB	05H
	DD	07H
	DW	020H
	DB	00H
	DB	05H
	DD	09H
	DW	00H
	DB	00H
	DB	05H
	DD	0aH
	DW	00H
	DB	00H
	DB	06H
	DD	0cH
	DW	00H
	DB	00H
	DB	06H
	DD	0fH
	DW	00H
	DB	00H
	DB	06H
	DD	012H
	DW	00H
	DB	00H
	DB	06H
	DD	015H
	DW	00H
	DB	00H
	DB	06H
	DD	018H
	DW	00H
	DB	00H
	DB	06H
	DD	01bH
	DW	00H
	DB	00H
	DB	06H
	DD	01eH
	DW	00H
	DB	00H
	DB	06H
	DD	021H
	DW	00H
	DB	01H
	DB	06H
	DD	023H
	DW	00H
	DB	01H
	DB	06H
	DD	027H
	DW	00H
	DB	02H
	DB	06H
	DD	02bH
	DW	00H
	DB	03H
	DB	06H
	DD	033H
	DW	00H
	DB	04H
	DB	06H
	DD	043H
	DW	00H
	DB	05H
	DB	06H
	DD	063H
	DW	00H
	DB	08H
	DB	06H
	DD	0103H
	DW	020H
	DB	00H
	DB	04H
	DD	04H
	DW	030H
	DB	00H
	DB	04H
	DD	04H
	DW	010H
	DB	00H
	DB	04H
	DD	05H
	DW	020H
	DB	00H
	DB	05H
	DD	07H
	DW	020H
	DB	00H
	DB	05H
	DD	08H
	DW	020H
	DB	00H
	DB	05H
	DD	0aH
	DW	020H
	DB	00H
	DB	05H
	DD	0bH
	DW	00H
	DB	00H
	DB	06H
	DD	0eH
	DW	00H
	DB	00H
	DB	06H
	DD	011H
	DW	00H
	DB	00H
	DB	06H
	DD	014H
	DW	00H
	DB	00H
	DB	06H
	DD	017H
	DW	00H
	DB	00H
	DB	06H
	DD	01aH
	DW	00H
	DB	00H
	DB	06H
	DD	01dH
	DW	00H
	DB	00H
	DB	06H
	DD	020H
	DW	00H
	DB	010H
	DB	06H
	DD	010003H
	DW	00H
	DB	0fH
	DB	06H
	DD	08003H
	DW	00H
	DB	0eH
	DB	06H
	DD	04003H
	DW	00H
	DB	0dH
	DB	06H
	DD	02003H
	DW	00H
	DB	0cH
	DB	06H
	DD	01003H
	DW	00H
	DB	0bH
	DB	06H
	DD	0803H
	DW	00H
	DB	0aH
	DB	06H
	DD	0403H
LL_defaultDTable DW 01H
	DB	01H
	DB	01H
	DD	06H
	DW	00H
	DB	00H
	DB	04H
	DD	00H
	DW	010H
	DB	00H
	DB	04H
	DD	00H
	DW	020H
	DB	00H
	DB	05H
	DD	01H
	DW	00H
	DB	00H
	DB	05H
	DD	03H
	DW	00H
	DB	00H
	DB	05H
	DD	04H
	DW	00H
	DB	00H
	DB	05H
	DD	06H
	DW	00H
	DB	00H
	DB	05H
	DD	07H
	DW	00H
	DB	00H
	DB	05H
	DD	09H
	DW	00H
	DB	00H
	DB	05H
	DD	0aH
	DW	00H
	DB	00H
	DB	05H
	DD	0cH
	DW	00H
	DB	00H
	DB	06H
	DD	0eH
	DW	00H
	DB	01H
	DB	05H
	DD	010H
	DW	00H
	DB	01H
	DB	05H
	DD	014H
	DW	00H
	DB	01H
	DB	05H
	DD	016H
	DW	00H
	DB	02H
	DB	05H
	DD	01cH
	DW	00H
	DB	03H
	DB	05H
	DD	020H
	DW	00H
	DB	04H
	DB	05H
	DD	030H
	DW	020H
	DB	06H
	DB	05H
	DD	040H
	DW	00H
	DB	07H
	DB	05H
	DD	080H
	DW	00H
	DB	08H
	DB	06H
	DD	0100H
	DW	00H
	DB	0aH
	DB	06H
	DD	0400H
	DW	00H
	DB	0cH
	DB	06H
	DD	01000H
	DW	020H
	DB	00H
	DB	04H
	DD	00H
	DW	00H
	DB	00H
	DB	04H
	DD	01H
	DW	00H
	DB	00H
	DB	05H
	DD	02H
	DW	020H
	DB	00H
	DB	05H
	DD	04H
	DW	00H
	DB	00H
	DB	05H
	DD	05H
	DW	020H
	DB	00H
	DB	05H
	DD	07H
	DW	00H
	DB	00H
	DB	05H
	DD	08H
	DW	020H
	DB	00H
	DB	05H
	DD	0aH
	DW	00H
	DB	00H
	DB	05H
	DD	0bH
	DW	00H
	DB	00H
	DB	06H
	DD	0dH
	DW	020H
	DB	01H
	DB	05H
	DD	010H
	DW	00H
	DB	01H
	DB	05H
	DD	012H
	DW	020H
	DB	01H
	DB	05H
	DD	016H
	DW	00H
	DB	02H
	DB	05H
	DD	018H
	DW	020H
	DB	03H
	DB	05H
	DD	020H
	DW	00H
	DB	03H
	DB	05H
	DD	028H
	DW	00H
	DB	06H
	DB	04H
	DD	040H
	DW	010H
	DB	06H
	DB	04H
	DD	040H
	DW	020H
	DB	07H
	DB	05H
	DD	080H
	DW	00H
	DB	09H
	DB	06H
	DD	0200H
	DW	00H
	DB	0bH
	DB	06H
	DD	0800H
	DW	030H
	DB	00H
	DB	04H
	DD	00H
	DW	010H
	DB	00H
	DB	04H
	DD	01H
	DW	020H
	DB	00H
	DB	05H
	DD	02H
	DW	020H
	DB	00H
	DB	05H
	DD	03H
	DW	020H
	DB	00H
	DB	05H
	DD	05H
	DW	020H
	DB	00H
	DB	05H
	DD	06H
	DW	020H
	DB	00H
	DB	05H
	DD	08H
	DW	020H
	DB	00H
	DB	05H
	DD	09H
	DW	020H
	DB	00H
	DB	05H
	DD	0bH
	DW	020H
	DB	00H
	DB	05H
	DD	0cH
	DW	00H
	DB	00H
	DB	06H
	DD	0fH
	DW	020H
	DB	01H
	DB	05H
	DD	012H
	DW	020H
	DB	01H
	DB	05H
	DD	014H
	DW	020H
	DB	02H
	DB	05H
	DD	018H
	DW	020H
	DB	02H
	DB	05H
	DD	01cH
	DW	020H
	DB	03H
	DB	05H
	DD	028H
	DW	020H
	DB	04H
	DB	05H
	DD	030H
	DW	00H
	DB	010H
	DB	06H
	DD	010000H
	DW	00H
	DB	0fH
	DB	06H
	DD	08000H
	DW	00H
	DB	0eH
	DB	06H
	DD	04000H
	DW	00H
	DB	0dH
	DB	06H
	DD	02000H
OF_bits	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
?dec32table@?2??ZSTD_overlapCopy8@@9@9 DD 00H		; `ZSTD_overlapCopy8'::`3'::dec32table
	DD	01H
	DD	02H
	DD	01H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
PUBLIC	ZSTD_decodeSeqHeaders
PUBLIC	ZSTD_decodeLiteralsBlock
PUBLIC	ZSTD_buildFSETable
PUBLIC	ZSTD_checkContinuity
PUBLIC	ZSTD_getcBlockSize
PUBLIC	ZSTD_decompressBlock_internal
pdata	SEGMENT
$pdata$ZSTD_decompressSequencesLong_default DD imagerel ZSTD_decompressSequencesLong_default
	DD	imagerel ZSTD_decompressSequencesLong_default+3124
	DD	imagerel $unwind$ZSTD_decompressSequencesLong_default
$pdata$ZSTD_decompressSequencesLong_body DD imagerel ZSTD_decompressSequencesLong_body
	DD	imagerel ZSTD_decompressSequencesLong_body+3873
	DD	imagerel $unwind$ZSTD_decompressSequencesLong_body
$pdata$ZSTD_decompressSequences_default DD imagerel ZSTD_decompressSequences_default
	DD	imagerel ZSTD_decompressSequences_default+241
	DD	imagerel $unwind$ZSTD_decompressSequences_default
$pdata$1$ZSTD_decompressSequences_default DD imagerel ZSTD_decompressSequences_default+241
	DD	imagerel ZSTD_decompressSequences_default+1520
	DD	imagerel $chain$1$ZSTD_decompressSequences_default
$pdata$2$ZSTD_decompressSequences_default DD imagerel ZSTD_decompressSequences_default+1520
	DD	imagerel ZSTD_decompressSequences_default+1670
	DD	imagerel $chain$2$ZSTD_decompressSequences_default
$pdata$ZSTD_decompressSequences_body DD imagerel ZSTD_decompressSequences_body
	DD	imagerel ZSTD_decompressSequences_body+257
	DD	imagerel $unwind$ZSTD_decompressSequences_body
$pdata$1$ZSTD_decompressSequences_body DD imagerel ZSTD_decompressSequences_body+257
	DD	imagerel ZSTD_decompressSequences_body+1829
	DD	imagerel $chain$1$ZSTD_decompressSequences_body
$pdata$2$ZSTD_decompressSequences_body DD imagerel ZSTD_decompressSequences_body+1829
	DD	imagerel ZSTD_decompressSequences_body+1989
	DD	imagerel $chain$2$ZSTD_decompressSequences_body
$pdata$ZSTD_decodeSequence DD imagerel ZSTD_decodeSequence
	DD	imagerel ZSTD_decodeSequence+679
	DD	imagerel $unwind$ZSTD_decodeSequence
$pdata$ZSTD_initFseState DD imagerel ZSTD_initFseState
	DD	imagerel ZSTD_initFseState+82
	DD	imagerel $unwind$ZSTD_initFseState
$pdata$ZSTD_execSequence DD imagerel ZSTD_execSequence
	DD	imagerel ZSTD_execSequence+614
	DD	imagerel $unwind$ZSTD_execSequence
$pdata$ZSTD_execSequenceEnd DD imagerel ZSTD_execSequenceEnd
	DD	imagerel ZSTD_execSequenceEnd+415
	DD	imagerel $unwind$ZSTD_execSequenceEnd
$pdata$ZSTD_safecopy DD imagerel ZSTD_safecopy
	DD	imagerel ZSTD_safecopy+112
	DD	imagerel $unwind$ZSTD_safecopy
$pdata$0$ZSTD_safecopy DD imagerel ZSTD_safecopy+112
	DD	imagerel ZSTD_safecopy+158
	DD	imagerel $chain$0$ZSTD_safecopy
$pdata$1$ZSTD_safecopy DD imagerel ZSTD_safecopy+158
	DD	imagerel ZSTD_safecopy+404
	DD	imagerel $chain$1$ZSTD_safecopy
$pdata$ZSTD_decodeSeqHeaders DD imagerel $LN271
	DD	imagerel $LN271+215
	DD	imagerel $unwind$ZSTD_decodeSeqHeaders
$pdata$4$ZSTD_decodeSeqHeaders DD imagerel $LN271+215
	DD	imagerel $LN271+2282
	DD	imagerel $chain$4$ZSTD_decodeSeqHeaders
$pdata$5$ZSTD_decodeSeqHeaders DD imagerel $LN271+2282
	DD	imagerel $LN271+2308
	DD	imagerel $chain$5$ZSTD_decodeSeqHeaders
$pdata$6$ZSTD_decodeSeqHeaders DD imagerel $LN271+2308
	DD	imagerel $LN271+2330
	DD	imagerel $chain$6$ZSTD_decodeSeqHeaders
$pdata$7$ZSTD_decodeSeqHeaders DD imagerel $LN271+2330
	DD	imagerel $LN271+2339
	DD	imagerel $chain$7$ZSTD_decodeSeqHeaders
$pdata$ZSTD_buildSeqTable DD imagerel ZSTD_buildSeqTable
	DD	imagerel ZSTD_buildSeqTable+56
	DD	imagerel $unwind$ZSTD_buildSeqTable
$pdata$0$ZSTD_buildSeqTable DD imagerel ZSTD_buildSeqTable+56
	DD	imagerel ZSTD_buildSeqTable+105
	DD	imagerel $chain$0$ZSTD_buildSeqTable
$pdata$1$ZSTD_buildSeqTable DD imagerel ZSTD_buildSeqTable+105
	DD	imagerel ZSTD_buildSeqTable+131
	DD	imagerel $chain$1$ZSTD_buildSeqTable
$pdata$2$ZSTD_buildSeqTable DD imagerel ZSTD_buildSeqTable+131
	DD	imagerel ZSTD_buildSeqTable+443
	DD	imagerel $chain$2$ZSTD_buildSeqTable
$pdata$3$ZSTD_buildSeqTable DD imagerel ZSTD_buildSeqTable+443
	DD	imagerel ZSTD_buildSeqTable+461
	DD	imagerel $chain$3$ZSTD_buildSeqTable
$pdata$ZSTD_decodeLiteralsBlock DD imagerel $LN1132
	DD	imagerel $LN1132+998
	DD	imagerel $unwind$ZSTD_decodeLiteralsBlock
$pdata$BIT_reloadDStream DD imagerel BIT_reloadDStream
	DD	imagerel BIT_reloadDStream+175
	DD	imagerel $unwind$BIT_reloadDStream
$pdata$ZSTD_buildFSETable DD imagerel $LN44
	DD	imagerel $LN44+470
	DD	imagerel $unwind$ZSTD_buildFSETable
$pdata$ZSTD_decompressBlock_internal DD imagerel $LN884
	DD	imagerel $LN884+84
	DD	imagerel $unwind$ZSTD_decompressBlock_internal
$pdata$0$ZSTD_decompressBlock_internal DD imagerel $LN884+84
	DD	imagerel $LN884+328
	DD	imagerel $chain$0$ZSTD_decompressBlock_internal
$pdata$1$ZSTD_decompressBlock_internal DD imagerel $LN884+328
	DD	imagerel $LN884+348
	DD	imagerel $chain$1$ZSTD_decompressBlock_internal
xdata	SEGMENT
$unwind$ZSTD_decompressSequencesLong_default DD 0a2d19H
	DD	047011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$ZSTD_decompressSequencesLong_body DD 0a2d19H
	DD	04f011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$ZSTD_decompressSequences_default DD 082919H
	DD	03b0118H
	DD	0d007e009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$chain$1$ZSTD_decompressSequences_default DD 041021H
	DD	039f410H
	DD	03ac408H
	DD	imagerel ZSTD_decompressSequences_default
	DD	imagerel ZSTD_decompressSequences_default+241
	DD	imagerel $unwind$ZSTD_decompressSequences_default
$chain$2$ZSTD_decompressSequences_default DD 021H
	DD	imagerel ZSTD_decompressSequences_default
	DD	imagerel ZSTD_decompressSequences_default+241
	DD	imagerel $unwind$ZSTD_decompressSequences_default
$unwind$ZSTD_decompressSequences_body DD 082919H
	DD	03d0118H
	DD	0e007f009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$chain$1$ZSTD_decompressSequences_body DD 041021H
	DD	03bd410H
	DD	03cc408H
	DD	imagerel ZSTD_decompressSequences_body
	DD	imagerel ZSTD_decompressSequences_body+257
	DD	imagerel $unwind$ZSTD_decompressSequences_body
$chain$2$ZSTD_decompressSequences_body DD 021H
	DD	imagerel ZSTD_decompressSequences_body
	DD	imagerel ZSTD_decompressSequences_body+257
	DD	imagerel $unwind$ZSTD_decompressSequences_body
$unwind$ZSTD_decodeSequence DD 0a1901H
	DD	0103419H
	DD	0f0155219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$ZSTD_initFseState DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$ZSTD_execSequence DD 0c1c01H
	DD	014641cH
	DD	013541cH
	DD	012341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
$unwind$ZSTD_execSequenceEnd DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0f01a521eH
	DD	0c016e018H
$unwind$ZSTD_safecopy DD 010201H
	DD	03002H
$chain$0$ZSTD_safecopy DD 020521H
	DD	027405H
	DD	imagerel ZSTD_safecopy
	DD	imagerel ZSTD_safecopy+112
	DD	imagerel $unwind$ZSTD_safecopy
$chain$1$ZSTD_safecopy DD 021H
	DD	imagerel ZSTD_safecopy
	DD	imagerel ZSTD_safecopy+112
	DD	imagerel $unwind$ZSTD_safecopy
$unwind$ZSTD_decodeSeqHeaders DD 052419H
	DD	0500113H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0240H
$chain$4$ZSTD_decodeSeqHeaders DD 0a4821H
	DD	04bf448H
	DD	04ce440H
	DD	04dd41cH
	DD	04ec412H
	DD	04f7408H
	DD	imagerel $LN271
	DD	imagerel $LN271+215
	DD	imagerel $unwind$ZSTD_decodeSeqHeaders
$chain$5$ZSTD_decodeSeqHeaders DD 021H
	DD	imagerel $LN271
	DD	imagerel $LN271+215
	DD	imagerel $unwind$ZSTD_decodeSeqHeaders
$chain$6$ZSTD_decodeSeqHeaders DD 0a0021H
	DD	04bf400H
	DD	04ce400H
	DD	04dd400H
	DD	04ec400H
	DD	04f7400H
	DD	imagerel $LN271
	DD	imagerel $LN271+215
	DD	imagerel $unwind$ZSTD_decodeSeqHeaders
$chain$7$ZSTD_decodeSeqHeaders DD 021H
	DD	imagerel $LN271
	DD	imagerel $LN271+215
	DD	imagerel $unwind$ZSTD_decodeSeqHeaders
$unwind$ZSTD_buildSeqTable DD 041c19H
	DD	019010aH
	DD	030027003H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$chain$0$ZSTD_buildSeqTable DD 020821H
	DD	0186408H
	DD	imagerel ZSTD_buildSeqTable
	DD	imagerel ZSTD_buildSeqTable+56
	DD	imagerel $unwind$ZSTD_buildSeqTable
$chain$1$ZSTD_buildSeqTable DD 021H
	DD	imagerel ZSTD_buildSeqTable
	DD	imagerel ZSTD_buildSeqTable+56
	DD	imagerel $unwind$ZSTD_buildSeqTable
$chain$2$ZSTD_buildSeqTable DD 020021H
	DD	0186400H
	DD	imagerel ZSTD_buildSeqTable
	DD	imagerel ZSTD_buildSeqTable+56
	DD	imagerel $unwind$ZSTD_buildSeqTable
$chain$3$ZSTD_buildSeqTable DD 021H
	DD	imagerel ZSTD_buildSeqTable
	DD	imagerel ZSTD_buildSeqTable+56
	DD	imagerel $unwind$ZSTD_buildSeqTable
$unwind$ZSTD_decodeLiteralsBlock DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
$unwind$BIT_reloadDStream DD 036601H
	DD	03466H
	DD	0204H
$unwind$ZSTD_buildFSETable DD 0d3119H
	DD	01b641fH
	DD	01a541fH
	DD	019341fH
	DD	012011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$ZSTD_decompressBlock_internal DD 081301H
	DD	0e6413H
	DD	0d3413H
	DD	0f00f7213H
	DD	0700be00dH
$chain$0$ZSTD_decompressBlock_internal DD 020521H
	DD	0c5405H
	DD	imagerel $LN884
	DD	imagerel $LN884+84
	DD	imagerel $unwind$ZSTD_decompressBlock_internal
$chain$1$ZSTD_decompressBlock_internal DD 021H
	DD	imagerel $LN884
	DD	imagerel $LN884+84
	DD	imagerel $unwind$ZSTD_decompressBlock_internal
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dctx$ = 96
dst$ = 104
dstCapacity$ = 112
src$ = 120
srcSize$ = 128
frame$dead$ = 136
nbSeq$1 = 136
ZSTD_decompressBlock_internal PROC

; 1344 : {   /* blockType == blockCompressed */

$LN884:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 1345 :     const BYTE* ip = (const BYTE*)src;
; 1346 :     /* isLongOffset must be true if there are long offsets.
; 1347 :      * Offsets are long if they are larger than 2^STREAM_ACCUMULATOR_MIN.
; 1348 :      * We don't expect that to be the case in 64-bit mode.
; 1349 :      * In block mode, window size is not known, so we have to be conservative.
; 1350 :      * (note: but it could be evaluated from current-lowLimit)
; 1351 :      */
; 1352 :     ZSTD_longOffset_e const isLongOffset = (ZSTD_longOffset_e)(MEM_32bits() && (!frame || (dctx->fParams.windowSize > (1ULL << STREAM_ACCUMULATOR_MIN))));
; 1353 :     DEBUGLOG(5, "ZSTD_decompressBlock_internal (size : %u)", (U32)srcSize);
; 1354 : 
; 1355 :     RETURN_ERROR_IF(srcSize >= ZSTD_BLOCKSIZE_MAX, srcSize_wrong, "");

	mov	rbx, QWORD PTR srcSize$[rsp]
	mov	rsi, r9
	mov	r15, r8
	mov	r14, rdx
	mov	rdi, rcx
	cmp	rbx, 131072				; 00020000H
	jb	SHORT $LN2@ZSTD_decom
	mov	rax, -72				; ffffffffffffffb8H
	jmp	$LN1@ZSTD_decom
$LN2@ZSTD_decom:

; 1356 : 
; 1357 :     /* Decode literals section */
; 1358 :     {   size_t const litCSize = ZSTD_decodeLiteralsBlock(dctx, src, srcSize);

	mov	r8, rbx
	mov	rdx, rsi
	call	ZSTD_decodeLiteralsBlock
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1360 :         if (ZSTD_isError(litCSize)) return litCSize;

	ja	$LN1@ZSTD_decom

; 1361 :         ip += litCSize;
; 1362 :         srcSize -= litCSize;

	sub	rbx, rax
	mov	QWORD PTR [rsp+96], rbp
	lea	rbp, QWORD PTR [rax+rsi]

; 1363 :     }
; 1364 : 
; 1365 :     /* Build Decoding Tables */
; 1366 :     {
; 1367 :         /* These macros control at build-time which decompressor implementation
; 1368 :          * we use. If neither is defined, we do some inspection and dispatch at
; 1369 :          * runtime.
; 1370 :          */
; 1371 : #if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \
; 1372 :     !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)
; 1373 :         int usePrefetchDecoder = dctx->ddictIsCold;
; 1374 : #endif
; 1375 :         int nbSeq;
; 1376 :         size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, srcSize);

	mov	r9, rbx
	mov	esi, DWORD PTR [rdi+29036]
	lea	rdx, QWORD PTR nbSeq$1[rsp]
	mov	r8, rbp
	mov	rcx, rdi
	call	ZSTD_decodeSeqHeaders
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1377 :         if (ZSTD_isError(seqHSize)) return seqHSize;

	ja	$LN882@ZSTD_decom

; 1378 :         ip += seqHSize;
; 1379 :         srcSize -= seqHSize;
; 1380 : 
; 1381 :         RETURN_ERROR_IF(dst == NULL && nbSeq > 0, dstSize_tooSmall, "NULL not handled");

	mov	r9d, DWORD PTR nbSeq$1[rsp]
	add	rbp, rax
	sub	rbx, rax
	test	r14, r14
	jne	SHORT $LN6@ZSTD_decom
	test	r9d, r9d
	jle	SHORT $LN6@ZSTD_decom
	lea	rax, QWORD PTR [r14-70]
	jmp	$LN882@ZSTD_decom
$LN6@ZSTD_decom:

; 1382 : 
; 1383 : #if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \
; 1384 :     !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)
; 1385 :         if ( !usePrefetchDecoder
; 1386 :           && (!frame || (dctx->fParams.windowSize > (1<<24)))
; 1387 :           && (nbSeq>ADVANCED_SEQS) ) {  /* could probably use a larger nbSeq limit */

	xor	r11d, r11d
	test	esi, esi
	jne	SHORT $LN8@ZSTD_decom
	cmp	QWORD PTR [rdi+28792], 16777216		; 01000000H
	jbe	SHORT $LN8@ZSTD_decom
	cmp	r9d, 4
	jle	SHORT $LN8@ZSTD_decom

; 1388 :             U32 const shareLongOffsets = ZSTD_getLongOffsetsShare(dctx->OFTptr);

	mov	r8, QWORD PTR [rdi+16]

; 1324 :     U32 const max = 1 << tableLog;

	mov	eax, 1

; 1325 :     U32 u, total = 0;

	mov	edx, r11d
	mov	r10d, DWORD PTR [r8+4]
	mov	ecx, r10d
	shl	eax, cl

; 1326 :     DEBUGLOG(5, "ZSTD_getLongOffsetsShare: (tableLog=%u)", tableLog);
; 1327 : 
; 1328 :     assert(max <= (1 << OffFSELog));  /* max not too large */
; 1329 :     for (u=0; u<max; u++) {

	test	eax, eax
	je	SHORT $LN21@ZSTD_decom
	lea	rcx, QWORD PTR [r8+10]
	mov	r8d, eax
	npad	2
$LL877@ZSTD_decom:
	cmp	BYTE PTR [rcx], 22
	lea	eax, DWORD PTR [rdx+1]
	lea	rcx, QWORD PTR [rcx+8]
	cmovbe	eax, edx
	mov	edx, eax
	sub	r8, 1
	jne	SHORT $LL877@ZSTD_decom
$LN21@ZSTD_decom:

; 1330 :         if (table[u].nbAdditionalBits > 22) total += 1;
; 1331 :     }
; 1332 : 
; 1333 :     assert(tableLog <= OffFSELog);
; 1334 :     total <<= (OffFSELog - tableLog);  /* scale to OffFSELog */

	mov	ecx, 8

; 1389 :             U32 const minShare = MEM_64bits() ? 7 : 20; /* heuristic values, correspond to 2.73% and 7.81% */
; 1390 :             usePrefetchDecoder = (shareLongOffsets >= minShare);

	mov	esi, r11d

; 1334 :     total <<= (OffFSELog - tableLog);  /* scale to OffFSELog */

	sub	ecx, r10d
	shl	edx, cl

; 1389 :             U32 const minShare = MEM_64bits() ? 7 : 20; /* heuristic values, correspond to 2.73% and 7.81% */
; 1390 :             usePrefetchDecoder = (shareLongOffsets >= minShare);

	cmp	edx, 7
	setae	sil
$LN8@ZSTD_decom:

; 1391 :         }
; 1392 : #endif
; 1393 : 
; 1394 :         dctx->ddictIsCold = 0;
; 1395 : 
; 1396 : #if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \
; 1397 :     !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)
; 1398 :         if (usePrefetchDecoder)

	mov	DWORD PTR [rsp+56], 1
	mov	r8, r15
	mov	DWORD PTR [rsp+48], r11d
	mov	rdx, r14
	mov	DWORD PTR [rsp+40], r9d
	mov	r9, rbp
	mov	QWORD PTR [rsp+32], rbx
	mov	rcx, rdi
	mov	DWORD PTR [rdi+29036], r11d
	test	esi, esi
	je	SHORT $LN10@ZSTD_decom

; 1306 :   return ZSTD_decompressSequencesLong_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	call	ZSTD_decompressSequencesLong_default

; 1399 : #endif
; 1400 : #ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT
; 1401 :             return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);

	jmp	SHORT $LN882@ZSTD_decom
$LN10@ZSTD_decom:

; 1282 :   return ZSTD_decompressSequences_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	call	ZSTD_decompressSequences_default
$LN882@ZSTD_decom:
	mov	rbp, QWORD PTR [rsp+96]
$LN1@ZSTD_decom:

; 1402 : #endif
; 1403 : 
; 1404 : #ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG
; 1405 :         /* else */
; 1406 :         return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);
; 1407 : #endif
; 1408 :     }
; 1409 : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
ZSTD_decompressBlock_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
src$ = 8
srcSize$ = 16
bpPtr$ = 24
ZSTD_getcBlockSize PROC

; 58   : {

	mov	rax, rcx

; 59   :     RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, "");

	cmp	rdx, 3
	jae	SHORT $LN2@ZSTD_getcB
	mov	rax, -72				; ffffffffffffffb8H

; 69   :     }
; 70   : }

	ret	0
$LN2@ZSTD_getcB:
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	ecx, BYTE PTR [rcx+2]
	movzx	eax, WORD PTR [rax]
	shl	ecx, 16
	add	ecx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 62   :         U32 const cSize = cBlockHeader >> 3;

	mov	edx, ecx

; 63   :         bpPtr->lastBlock = cBlockHeader & 1;

	mov	eax, ecx

; 64   :         bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);

	shr	ecx, 1
	and	eax, 1
	and	ecx, 3
	shr	edx, 3
	mov	DWORD PTR [r8+4], eax
	mov	DWORD PTR [r8], ecx

; 65   :         bpPtr->origSize = cSize;   /* only useful for RLE */

	mov	DWORD PTR [r8+8], edx

; 66   :         if (bpPtr->blockType == bt_rle) return 1;

	cmp	ecx, 1
	jne	SHORT $LN4@ZSTD_getcB
	mov	eax, ecx

; 69   :     }
; 70   : }

	ret	0
$LN4@ZSTD_getcB:

; 67   :         RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, "");

	mov	rax, -20
	cmp	ecx, 3
	je	SHORT $LN1@ZSTD_getcB

; 68   :         return cSize;

	mov	eax, edx
$LN1@ZSTD_getcB:

; 69   :     }
; 70   : }

	ret	0
ZSTD_getcBlockSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dctx$ = 8
dst$ = 16
ZSTD_checkContinuity PROC

; 1414 :     if (dst != dctx->previousDstEnd) {   /* not contiguous */

	mov	r8, QWORD PTR [rcx+28744]
	cmp	rdx, r8
	je	SHORT $LN2@ZSTD_check

; 1415 :         dctx->dictEnd = dctx->previousDstEnd;
; 1416 :         dctx->virtualStart = (const char*)dst - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));

	mov	rax, QWORD PTR [rcx+28752]
	sub	rax, r8
	mov	QWORD PTR [rcx+28768], r8
	add	rax, rdx

; 1417 :         dctx->prefixStart = dst;

	mov	QWORD PTR [rcx+28752], rdx
	mov	QWORD PTR [rcx+28760], rax

; 1418 :         dctx->previousDstEnd = dst;

	mov	QWORD PTR [rcx+28744], rdx
$LN2@ZSTD_check:

; 1419 :     }
; 1420 : }

	ret	0
ZSTD_checkContinuity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
tv918 = 0
DTableH$1 = 8
symbolNext$ = 16
__$ArrayPad$ = 128
dt$ = 192
normalizedCounter$ = 200
maxSymbolValue$ = 208
baseValue$ = 216
nbAdditionalBits$ = 224
tableLog$ = 232
ZSTD_buildFSETable PROC

; 372  : {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 373  :     ZSTD_seqSymbol* const tableDecode = dt+1;
; 374  :     U16 symbolNext[MaxSeq+1];
; 375  : 
; 376  :     U32 const maxSV1 = maxSymbolValue + 1;
; 377  :     U32 const tableSize = 1 << tableLog;

	mov	r15d, DWORD PTR tableLog$[rsp]
	lea	ebp, DWORD PTR [r8+1]
	mov	r13d, 1

; 378  :     U32 highThreshold = tableSize-1;
; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$1[rsp+4], r15d
	mov	rdi, rcx

; 387  :         DTableH.fastMode = 1;

	mov	DWORD PTR DTableH$1[rsp], r13d
	mov	ecx, r15d
	mov	r14d, r13d
	shl	r14d, cl

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	ebx, r13d
	lea	ecx, DWORD PTR [r15-1]
	mov	r12, r9
	shl	bx, cl
	mov	rsi, rdx
	xor	ecx, ecx
	mov	r9d, r13d
	mov	DWORD PTR tv918[rsp], ecx
	lea	r10d, DWORD PTR [r14-1]
	mov	r8d, r10d
	mov	edx, ecx

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	test	ebp, ebp
	je	$LN3@ZSTD_build
	lea	rax, QWORD PTR symbolNext$[rsp]
	mov	r11, rsi
	sub	r11, rax
	lea	rcx, QWORD PTR symbolNext$[rsp]
$LL4@ZSTD_build:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR [r11+rcx]
	cmp	ax, -1
	jne	SHORT $LN16@ZSTD_build

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	eax, r8d
	dec	r8d
	mov	DWORD PTR [rdi+rax*8+12], edx

; 393  :                     symbolNext[s] = 1;

	movzx	eax, r13w

; 394  :                 } else {

	jmp	SHORT $LN2@ZSTD_build
$LN16@ZSTD_build:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, bx
	cmovge	r9d, DWORD PTR tv918[rsp]
	mov	DWORD PTR DTableH$1[rsp], r9d
$LN2@ZSTD_build:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR [rcx], ax
	inc	edx
	add	rcx, 2
	cmp	edx, ebp
	jb	SHORT $LL4@ZSTD_build
	mov	rax, QWORD PTR DTableH$1[rsp]
	xor	ecx, ecx
	mov	r9d, r14d
	mov	QWORD PTR [rdi], rax
	shr	r9d, 1
	mov	edx, r14d
	add	r9d, 3
	shr	edx, 3
	add	r9d, edx
	mov	eax, ecx
	mov	r11d, ecx
	npad	7
$LL7@ZSTD_build:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	ecx, WORD PTR [rsi]
	test	ecx, ecx
	jle	SHORT $LN5@ZSTD_build
	mov	edx, ecx
	npad	7
$LL10@ZSTD_build:

; 409  :                 tableDecode[position].baseValue = s;

	mov	ecx, eax

; 410  :                 position = (position + step) & tableMask;

	add	eax, r9d
	and	eax, r10d
	mov	DWORD PTR [rdi+rcx*8+12], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	eax, r8d
	jbe	SHORT $LN8@ZSTD_build
$LL11@ZSTD_build:
	add	eax, r9d
	and	eax, r10d
	cmp	eax, r8d
	ja	SHORT $LL11@ZSTD_build
$LN8@ZSTD_build:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rdx, r13
	jne	SHORT $LL10@ZSTD_build
$LN5@ZSTD_build:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rsi, 2
	cmp	r11d, ebp
	jb	SHORT $LL7@ZSTD_build
	xor	ecx, ecx
	jmp	SHORT $LN6@ZSTD_build
$LN3@ZSTD_build:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rax, QWORD PTR DTableH$1[rsp]
	mov	QWORD PTR [rdi], rax
$LN6@ZSTD_build:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	test	r14d, r14d
	je	SHORT $LN14@ZSTD_build
	mov	rbx, QWORD PTR nbAdditionalBits$[rsp]
	lea	r10, QWORD PTR [rdi+12]
	mov	r11d, r14d
	npad	2
$LL15@ZSTD_build:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, ecx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r15b
	movzx	r8d, WORD PTR symbolNext$[rsp+r9*2]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$[rsp+r9*2], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	mov	ecx, 0
	sub	r8w, r14w
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR [rbx+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR [r12+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, r13
	jne	SHORT $LL15@ZSTD_build
$LN14@ZSTD_build:

; 426  :     }   }
; 427  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
ZSTD_buildFSETable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_32bits PROC

; 183  : MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }

	xor	eax, eax
	ret	0
MEM_32bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_64bits PROC

; 184  : MEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }

	mov	eax, 1
	ret	0
MEM_64bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap32 PROC

; 276  : #if defined(_MSC_VER)     /* Visual Studio */
; 277  :     return _byteswap_ulong(in);

	bswap	ecx
	mov	eax, ecx

; 278  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 279  :   || (defined(__clang__) && __has_builtin(__builtin_bswap32))
; 280  :     return __builtin_bswap32(in);
; 281  : #else
; 282  :     return  ((in << 24) & 0xff000000 ) |
; 283  :             ((in <<  8) & 0x00ff0000 ) |
; 284  :             ((in >>  8) & 0x0000ff00 ) |
; 285  :             ((in >> 24) & 0x000000ff );
; 286  : #endif
; 287  : }

	ret	0
MEM_swap32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE16 PROC

; 320  :     if (MEM_isLittleEndian())
; 321  :         return MEM_read16(memPtr);

	movzx	eax, WORD PTR [rcx]

; 322  :     else {
; 323  :         const BYTE* p = (const BYTE*)memPtr;
; 324  :         return (U16)(p[0] + (p[1]<<8));
; 325  :     }
; 326  : }

	ret	0
MEM_readLE16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE24 PROC

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	eax, BYTE PTR [rcx+2]
	movzx	ecx, WORD PTR [rcx]
	shl	eax, 16
	add	eax, ecx

; 342  : }

	ret	0
MEM_readLE24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE32 PROC

; 352  :     if (MEM_isLittleEndian())
; 353  :         return MEM_read32(memPtr);

	mov	eax, DWORD PTR [rcx]

; 354  :     else
; 355  :         return MEM_swap32(MEM_read32(memPtr));
; 356  : }

	ret	0
MEM_readLE32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLEST PROC

; 384  :     if (MEM_32bits())
; 385  :         return (size_t)MEM_readLE32(memPtr);
; 386  :     else
; 387  :         return (size_t)MEM_readLE64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 388  : }

	ret	0
MEM_readLEST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\error_private.h
_TEXT	SEGMENT
code$ = 8
ERR_isError PROC

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	xor	eax, eax
	cmp	rcx, -120				; ffffffffffffff88H
	seta	al
	ret	0
ERR_isError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
val$ = 8
BIT_highbit32 PROC

; 141  :     assert(val != 0);
; 142  :     {
; 143  : #   if defined(_MSC_VER)   /* Visual */
; 144  :         unsigned long r=0;

	xor	eax, eax

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	edx, ecx
	cmovne	eax, edx

; 146  : #   elif defined(__GNUC__) && (__GNUC__ >= 3)   /* Use GCC Intrinsic */
; 147  :         return __builtin_clz (val) ^ 31;
; 148  : #   elif defined(__ICCARM__)    /* IAR Intrinsic */
; 149  :         return 31 - __CLZ(val);
; 150  : #   else   /* Software version */
; 151  :         static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,
; 152  :                                                  11, 14, 16, 18, 22, 25,  3, 30,
; 153  :                                                   8, 12, 20, 28, 15, 17, 24,  7,
; 154  :                                                  19, 27, 23,  6, 26,  5,  4, 31 };
; 155  :         U32 v = val;
; 156  :         v |= v >> 1;
; 157  :         v |= v >> 2;
; 158  :         v |= v >> 4;
; 159  :         v |= v >> 8;
; 160  :         v |= v >> 16;
; 161  :         return DeBruijnClz[ (U32) (v * 0x07C4ACDDU) >> 27];
; 162  : #   endif
; 163  :     }
; 164  : }

	ret	0
BIT_highbit32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
srcBuffer$ = 16
srcSize$ = 24
BIT_initDStream PROC

; 273  : {

	mov	r9, rcx

; 274  :     if (srcSize < 1) { memset(bitD, 0, sizeof(*bitD)); return ERROR(srcSize_wrong); }

	cmp	r8, 1
	jae	SHORT $LN4@BIT_initDS
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	QWORD PTR [rcx+32], rax
	mov	rax, -72				; ffffffffffffffb8H

; 318  : }

	ret	0
$LN4@BIT_initDS:

; 275  : 
; 276  :     bitD->start = (const char*)srcBuffer;

	mov	QWORD PTR [rcx+24], rdx

; 277  :     bitD->limitPtr = bitD->start + sizeof(bitD->bitContainer);

	lea	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+32], rax

; 278  : 
; 279  :     if (srcSize >=  sizeof(bitD->bitContainer)) {  /* normal case */

	cmp	r8, 8
	jb	SHORT $LN5@BIT_initDS

; 280  :         bitD->ptr   = (const char*)srcBuffer + srcSize - sizeof(bitD->bitContainer);

	lea	rax, QWORD PTR [r8-8]
	add	rax, rdx
	mov	QWORD PTR [rcx+16], rax

; 281  :         bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 282  :         { BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];

	movzx	eax, BYTE PTR [rdx+r8-1]

; 283  :           bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */

	xor	edx, edx
	test	al, al
	je	SHORT $LN17@BIT_initDS

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax

; 315  :     }
; 316  : 
; 317  :     return srcSize;

	mov	rax, r8

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	cmovne	edx, ecx

; 283  :           bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */

	mov	ecx, 8
	sub	ecx, edx
	mov	DWORD PTR [r9+8], ecx

; 318  : }

	ret	0
$LN17@BIT_initDS:

; 283  :           bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */

	mov	DWORD PTR [rcx+8], edx

; 284  :           if (lastByte == 0) return ERROR(GENERIC); /* endMark not present */ }

	mov	rax, -1

; 318  : }

	ret	0
$LN5@BIT_initDS:

; 285  :     } else {
; 286  :         bitD->ptr   = bitD->start;

	mov	QWORD PTR [rcx+16], rdx

; 287  :         bitD->bitContainer = *(const BYTE*)(bitD->start);
; 288  :         switch(srcSize)

	lea	rax, QWORD PTR [r8-2]
	movzx	ecx, BYTE PTR [rdx]
	mov	QWORD PTR [r9], rcx
	cmp	rax, 5
	ja	SHORT $LN14@BIT_initDS
	lea	r10, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN27@BIT_initDS[r10+rax*4]
	add	rax, r10
	jmp	rax
$LN8@BIT_initDS:

; 289  :         {
; 290  :         case 7: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[6]) << (sizeof(bitD->bitContainer)*8 - 16);

	movzx	eax, BYTE PTR [rdx+6]
	shl	rax, 48					; 00000030H
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN9@BIT_initDS:

; 291  :                 /* fall-through */
; 292  : 
; 293  :         case 6: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[5]) << (sizeof(bitD->bitContainer)*8 - 24);

	movzx	eax, BYTE PTR [rdx+5]
	shl	rax, 40					; 00000028H
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN10@BIT_initDS:

; 294  :                 /* fall-through */
; 295  : 
; 296  :         case 5: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[4]) << (sizeof(bitD->bitContainer)*8 - 32);

	movzx	eax, BYTE PTR [rdx+4]
	shl	rax, 32					; 00000020H
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN11@BIT_initDS:

; 297  :                 /* fall-through */
; 298  : 
; 299  :         case 4: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[3]) << 24;

	movzx	eax, BYTE PTR [rdx+3]
	shl	rax, 24
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN12@BIT_initDS:

; 300  :                 /* fall-through */
; 301  : 
; 302  :         case 3: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[2]) << 16;

	movzx	eax, BYTE PTR [rdx+2]
	shl	rax, 16
	add	rcx, rax
	mov	QWORD PTR [r9], rcx
$LN13@BIT_initDS:

; 303  :                 /* fall-through */
; 304  : 
; 305  :         case 2: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[1]) <<  8;

	movzx	eax, BYTE PTR [rdx+1]
	shl	rax, 8
	add	rax, rcx
	mov	QWORD PTR [r9], rax
$LN14@BIT_initDS:

; 306  :                 /* fall-through */
; 307  : 
; 308  :         default: break;
; 309  :         }
; 310  :         {   BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];

	movzx	eax, BYTE PTR [rdx+r8-1]

; 311  :             bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;

	xor	edx, edx
	test	al, al
	je	SHORT $LN19@BIT_initDS

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	ecx, eax
	cmovne	edx, ecx

; 311  :             bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;

	mov	ecx, 8
	mov	eax, ecx
	sub	eax, edx

; 313  :         }
; 314  :         bitD->bitsConsumed += (U32)(sizeof(bitD->bitContainer) - srcSize)*8;

	sub	ecx, r8d
	lea	eax, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR [r9+8], eax

; 315  :     }
; 316  : 
; 317  :     return srcSize;

	mov	rax, r8

; 318  : }

	ret	0
$LN19@BIT_initDS:

; 311  :             bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;

	mov	DWORD PTR [r9+8], edx

; 312  :             if (lastByte == 0) return ERROR(corruption_detected);  /* endMark not present */

	mov	rax, -20

; 318  : }

	ret	0
	npad	3
$LN27@BIT_initDS:
	DD	$LN13@BIT_initDS
	DD	$LN12@BIT_initDS
	DD	$LN11@BIT_initDS
	DD	$LN10@BIT_initDS
	DD	$LN9@BIT_initDS
	DD	$LN8@BIT_initDS
BIT_initDStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitContainer$ = 8
start$ = 16
nbBits$ = 24
BIT_getMiddleBits PROC

; 326  : {

	mov	r9, rcx

; 327  :     U32 const regMask = sizeof(bitContainer)*8 - 1;
; 328  :     /* if start > regMask, bitstream is corrupted, and result is undefined */
; 329  :     assert(nbBits < BIT_MASK_SIZE);
; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, r8d
	and	edx, 63					; 0000003fH
	movzx	ecx, dl
	shr	r9, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	eax, DWORD PTR [rcx+rax*4]
	and	rax, r9

; 331  : }

	ret	0
BIT_getMiddleBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_lookBits PROC

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	rax, QWORD PTR [rcx]

; 347  :     /* arbitrate between double-shift and shift+mask */
; 348  : #if 1
; 349  :     /* if bitD->bitsConsumed + nbBits > sizeof(bitD->bitContainer)*8,
; 350  :      * bitstream is likely corrupted, and result is undefined */
; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	ecx, DWORD PTR [rcx+8]
	add	ecx, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	rax, cl
	mov	ecx, edx
	lea	rdx, OFFSET FLAT:BIT_mask
	mov	edx, DWORD PTR [rdx+rcx*4]
	and	rax, rdx

; 352  : #else
; 353  :     /* this code path is slower on my os-x laptop */
; 354  :     U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;
; 355  :     return ((bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> 1) >> ((regMask-nbBits) & regMask);
; 356  : #endif
; 357  : }

	ret	0
BIT_lookBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_lookBitsFast PROC

; 363  :     U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;
; 364  :     assert(nbBits >= 1);
; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, QWORD PTR [rcx]
	neg	edx
	mov	ecx, DWORD PTR [rcx+8]
	and	edx, 63					; 0000003fH
	and	ecx, 63					; 0000003fH
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 366  : }

	ret	0
BIT_lookBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_skipBits PROC

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rcx+8], edx

; 371  : }

	ret	0
BIT_skipBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_readBits PROC

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rcx+8], edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	rax, QWORD PTR [rcx]

; 370  :     bitD->bitsConsumed += nbBits;

	mov	ecx, DWORD PTR [rcx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	rax, cl
	mov	ecx, edx
	lea	rdx, OFFSET FLAT:BIT_mask
	mov	edx, DWORD PTR [rdx+rcx*4]
	and	rax, rdx

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);
; 380  :     BIT_skipBits(bitD, nbBits);
; 381  :     return value;
; 382  : }

	ret	0
BIT_readBits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
nbBits$ = 16
BIT_readBitsFast PROC

; 387  : {

	mov	r8, rcx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [rcx+8]

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+rdx]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [r8+8], eax

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);
; 389  :     assert(nbBits >= 1);
; 390  :     BIT_skipBits(bitD, nbBits);
; 391  :     return value;

	neg	edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, QWORD PTR [r8]
	and	edx, 63					; 0000003fH
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 392  : }

	ret	0
BIT_readBitsFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 8
BIT_reloadDStreamFast PROC

; 402  :     if (UNLIKELY(bitD->ptr < bitD->limitPtr))

	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rcx
	cmp	r8, QWORD PTR [rcx+32]
	jae	SHORT $LN2@BIT_reload

; 403  :         return BIT_DStream_overflow;

	mov	eax, 3

; 409  : }

	ret	0
$LN2@BIT_reload:

; 404  :     assert(bitD->bitsConsumed <= sizeof(bitD->bitContainer)*8);
; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, ecx

; 406  :     bitD->bitsConsumed &= 7;

	and	ecx, 7
	shr	rax, 3
	sub	r8, rax
	mov	DWORD PTR [rdx+8], ecx
	mov	QWORD PTR [rdx+16], r8

; 407  :     bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 408  :     return BIT_DStream_unfinished;

	xor	eax, eax

; 409  : }

	ret	0
BIT_reloadDStreamFast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\bitstream.h
_TEXT	SEGMENT
bitD$ = 16
BIT_reloadDStream PROC

; 417  : {

	sub	rsp, 8

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	mov	r9d, DWORD PTR [rcx+8]
	mov	r8, rcx
	cmp	r9d, 64					; 00000040H
	jbe	SHORT $LN2@BIT_reload

; 419  :         return BIT_DStream_overflow;

	mov	eax, 3

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
$LN2@BIT_reload:

; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	mov	rdx, QWORD PTR [rcx+16]
	cmp	rdx, QWORD PTR [rcx+32]
	jb	SHORT $LN3@BIT_reload

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	rax, r9

; 406  :     bitD->bitsConsumed &= 7;

	and	r9d, 7
	shr	rax, 3
	sub	rdx, rax
	mov	DWORD PTR [rcx+8], r9d
	mov	QWORD PTR [rcx+16], rdx

; 407  :     bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 422  :         return BIT_reloadDStreamFast(bitD);

	xor	eax, eax

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
$LN3@BIT_reload:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	mov	r11, QWORD PTR [rcx+24]
	cmp	rdx, r11
	jne	SHORT $LN4@BIT_reload

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;

	cmp	r9d, 64					; 00000040H
	sbb	eax, eax
	add	eax, 2

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
$LN4@BIT_reload:

; 426  :         return BIT_DStream_completed;
; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	r10d, r9d
	mov	QWORD PTR [rsp], rbx
	shr	r10d, 3

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, rdx
	mov	eax, r10d
	xor	ebx, ebx
	sub	rcx, rax
	cmp	rcx, r11
	jae	SHORT $LN6@BIT_reload

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	r10d, edx

; 433  :             result = BIT_DStream_endOfBuffer;

	mov	ebx, 1
	sub	r10d, r11d
$LN6@BIT_reload:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	ecx, r10d

; 436  :         bitD->bitsConsumed -= nbBytes*8;
; 437  :         bitD->bitContainer = MEM_readLEST(bitD->ptr);   /* reminder : srcSize > sizeof(bitD->bitContainer), otherwise bitD->ptr == bitD->start */
; 438  :         return result;

	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp]
	sub	rdx, rcx
	lea	ecx, DWORD PTR [r10*8]
	mov	QWORD PTR [r8+16], rdx
	sub	r9d, ecx
	mov	DWORD PTR [r8+8], r9d
	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rcx

; 439  :     }
; 440  : }

	add	rsp, 8
	ret	0
BIT_reloadDStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
format$ = 8
_force_has_format_string PROC

; 69   : void _force_has_format_string(const char *format, ...) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9

; 70   :   (void)format;
; 71   : }

	ret	0
_force_has_format_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy8 PROC

; 231  : #ifdef __aarch64__
; 232  :     vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));
; 233  : #else
; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 235  : #endif
; 236  : }

	ret	0
ZSTD_copy8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy16 PROC

; 240  : #ifdef __aarch64__
; 241  :     vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));
; 242  : #else
; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 244  : #endif
; 245  : }

	ret	0
ZSTD_copy16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
length$ = 24
ovtype$ = 32
ZSTD_wildcopy PROC

; 268  :     const BYTE* ip = (const BYTE*)src;
; 269  :     BYTE* op = (BYTE*)dst;
; 270  :     BYTE* const oend = op + length;

	lea	r10, QWORD PTR [rcx+r8]

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	r9d, 1
	jne	SHORT $LN20@ZSTD_wildc

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	rax, rcx
	sub	rax, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rax, 16
	jge	SHORT $LN20@ZSTD_wildc

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	sub	rdx, rcx
	npad	7
$LL4@ZSTD_wildc:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR [rcx], rax
	add	rcx, 8

; 278  :         } while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL4@ZSTD_wildc

; 292  : #else
; 293  :         COPY16(op, ip);
; 294  :         if (op >= oend) return;
; 295  :         do {
; 296  :             COPY16(op, ip);
; 297  :             COPY16(op, ip);
; 298  :         }
; 299  :         while (op < oend);
; 300  : #endif
; 301  :     }
; 302  : }

	ret	0
$LN20@ZSTD_wildc:
	sub	rdx, rcx
	npad	12
$LL7@ZSTD_wildc:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 279  :     } else {
; 280  :         assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);
; 281  :         /* Separate out the first COPY16() call because the copy length is
; 282  :          * almost certain to be short, so the branches have different
; 283  :          * probabilities. Since it is almost certain to be short, only do
; 284  :          * one COPY16() in the first call. Then, do two calls per loop since
; 285  :          * at that point it is more likely to have a high trip count.
; 286  :          */
; 287  : #ifndef __aarch64__
; 288  :         do {
; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL7@ZSTD_wildc

; 292  : #else
; 293  :         COPY16(op, ip);
; 294  :         if (op >= oend) return;
; 295  :         do {
; 296  :             COPY16(op, ip);
; 297  :             COPY16(op, ip);
; 298  :         }
; 299  :         while (op < oend);
; 300  : #endif
; 301  :     }
; 302  : }

	ret	0
ZSTD_wildcopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy4 PROC

; 47   : static void ZSTD_copy4(void* dst, const void* src) { memcpy(dst, src, 4); }

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	ret	0
ZSTD_copy4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\mem.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dctx$ = 112
src$ = 120
srcSize$ = 128
ZSTD_decodeLiteralsBlock PROC

; 81   : {

$LN1132:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r9, rdx
	mov	rdi, rcx

; 82   :     DEBUGLOG(5, "ZSTD_decodeLiteralsBlock");
; 83   :     RETURN_ERROR_IF(srcSize < MIN_CBLOCK_SIZE, corruption_detected, "");

	cmp	r8, 3
	jb	$LN1128@ZSTD_decod

; 84   : 
; 85   :     {   const BYTE* const istart = (const BYTE*) src;
; 86   :         symbolEncodingType_e const litEncType = (symbolEncodingType_e)(istart[0] & 3);

	movzx	r10d, BYTE PTR [rdx]
	mov	r14d, r10d
	and	r14d, 3

; 87   : 
; 88   :         switch(litEncType)

	mov	ecx, r14d
	je	$LN41@ZSTD_decod
	sub	ecx, 1
	je	$LN48@ZSTD_decod
	sub	ecx, 1
	je	SHORT $LN19@ZSTD_decod
	cmp	ecx, 1
	jne	$LN1128@ZSTD_decod

; 89   :         {
; 90   :         case set_repeat:
; 91   :             DEBUGLOG(5, "set_repeat flag : re-using stats from previous compressed literals block");
; 92   :             RETURN_ERROR_IF(dctx->litEntropy==0, dictionary_corrupted, "");

	cmp	DWORD PTR [rdi+28840], 0
	jne	SHORT $LN19@ZSTD_decod
	mov	rax, -30
	jmp	$LN14@ZSTD_decod
$LN19@ZSTD_decod:

; 93   :             /* fall-through */
; 94   : 
; 95   :         case set_compressed:
; 96   :             RETURN_ERROR_IF(srcSize < 5, corruption_detected, "srcSize >= MIN_CBLOCK_SIZE == 3; here we need up to 5 for case 3");

	cmp	r8, 5
	jb	$LN1128@ZSTD_decod

; 97   :             {   size_t lhSize, litSize, litCSize;
; 98   :                 U32 singleStream=0;
; 99   :                 U32 const lhlCode = (istart[0] >> 2) & 3;
; 100  :                 U32 const lhc = MEM_readLE32(istart);

	mov	ebx, DWORD PTR [r9]
	xor	edx, edx
	shr	r10d, 2
	mov	r11d, ebx
	and	r10d, 3
	shr	r11, 4

; 101  :                 size_t hufSuccess;
; 102  :                 switch(lhlCode)

	mov	eax, r10d
	mov	r12d, edx
	sub	eax, 2
	je	SHORT $LN25@ZSTD_decod
	cmp	eax, 1
	je	SHORT $LN26@ZSTD_decod

; 103  :                 {
; 104  :                 case 0: case 1: default:   /* note : default is impossible, since lhlCode into [0..3] */
; 105  :                     /* 2 - 2 - 10 - 10 */
; 106  :                     singleStream = !lhlCode;

	test	r10d, r10d

; 107  :                     lhSize = 3;

	lea	esi, QWORD PTR [rdx+3]

; 108  :                     litSize  = (lhc >> 4) & 0x3FF;
; 109  :                     litCSize = (lhc >> 14) & 0x3FF;

	mov	ebp, 1023				; 000003ffH
	sete	r12b
	shr	rbx, 14
	and	rbx, rbp

; 110  :                     break;

	jmp	SHORT $LN4@ZSTD_decod
$LN26@ZSTD_decod:

; 116  :                     break;
; 117  :                 case 3:
; 118  :                     /* 2 - 2 - 18 - 18 */
; 119  :                     lhSize = 5;
; 120  :                     litSize  = (lhc >> 4) & 0x3FFFF;
; 121  :                     litCSize = (lhc >> 22) + ((size_t)istart[4] << 10);

	movzx	ecx, BYTE PTR [r9+4]
	mov	esi, 5
	shl	rcx, 10
	mov	ebp, 262143				; 0003ffffH
	shr	rbx, 22
	add	rbx, rcx
	jmp	SHORT $LN4@ZSTD_decod
$LN25@ZSTD_decod:

; 111  :                 case 2:
; 112  :                     /* 2 - 2 - 14 - 14 */
; 113  :                     lhSize = 4;

	mov	esi, 4

; 114  :                     litSize  = (lhc >> 4) & 0x3FFF;
; 115  :                     litCSize = lhc >> 18;

	shr	rbx, 18
	mov	ebp, 16383				; 00003fffH
$LN4@ZSTD_decod:

; 122  :                     break;
; 123  :                 }
; 124  :                 RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, "");

	and	rbp, r11
	cmp	rbp, 131072				; 00020000H
	ja	$LN1128@ZSTD_decod

; 125  :                 RETURN_ERROR_IF(litCSize + lhSize > srcSize, corruption_detected, "");

	lea	r13, QWORD PTR [rbx+rsi]
	cmp	r13, r8
	ja	$LN1128@ZSTD_decod

; 126  : 
; 127  :                 /* prefetch huffman table if cold */
; 128  :                 if (dctx->ddictIsCold && (litSize > 768 /* heuristic */)) {

	cmp	DWORD PTR [rdi+29036], edx
	je	SHORT $LN7@ZSTD_decod
	cmp	rbp, 768				; 00000300H
	jbe	SHORT $LN7@ZSTD_decod

; 129  :                     PREFETCH_AREA(dctx->HUFptr, sizeof(dctx->entropy.hufTable));

	mov	rax, QWORD PTR [rdi+24]
	npad	2
$LL8@ZSTD_decod:
	prefetcht1 BYTE PTR [rdx+rax]
	add	rdx, 64					; 00000040H
	cmp	rdx, 16388				; 00004004H
	jb	SHORT $LL8@ZSTD_decod
$LN7@ZSTD_decod:

; 130  :                 }
; 131  : 
; 132  :                 if (litEncType==set_repeat) {

	add	rsi, r9
	cmp	r14d, 3
	jne	SHORT $LN32@ZSTD_decod

; 133  :                     if (singleStream) {

	mov	rcx, QWORD PTR [rdi+24]
	mov	r9, rbx
	mov	r8, rsi
	mov	eax, DWORD PTR [rcx]
	shr	eax, 8
	test	r12d, r12d
	je	SHORT $LN34@ZSTD_decod
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c

; 1192 :     return dtd.tableType ? HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2) :

	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR [rdi+29176]
	mov	rdx, rbp
	test	al, al
	je	$LN61@ZSTD_decod
	call	HUF_decompress1X2_usingDTable_internal
	jmp	$LN1116@ZSTD_decod
$LN34@ZSTD_decod:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 138  :                         hufSuccess = HUF_decompress4X_usingDTable_bmi2(

	mov	edx, DWORD PTR [rdi+29008]
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c

; 1223 :     return dtd.tableType ? HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2) :

	mov	DWORD PTR [rsp+40], edx
	mov	rdx, rbp
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR [rdi+29176]
	test	al, al
	je	SHORT $LN67@ZSTD_decod
	call	HUF_decompress4X2_usingDTable_internal
	jmp	$LN1116@ZSTD_decod
$LN67@ZSTD_decod:
	call	HUF_decompress4X1_usingDTable_internal
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 142  :                 } else {

	jmp	$LN1116@ZSTD_decod
$LN32@ZSTD_decod:

; 143  :                     if (singleStream) {

	lea	r10, QWORD PTR [rdi+26696]
	lea	r15, QWORD PTR [rdi+10296]
	test	r12d, r12d
	je	SHORT $LN36@ZSTD_decod
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c

; 1202 :     size_t const hSize = HUF_readDTableX1_wksp(dctx, cSrc, cSrcSize, workSpace, wkspSize);

	mov	r9, r10
	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, r15
	call	HUF_readDTableX1_wksp
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c

; 1203 :     if (HUF_isError(hSize)) return hSize;

	ja	$LN1128@ZSTD_decod

; 1204 :     if (hSize >= cSrcSize) return ERROR(srcSize_wrong);

	cmp	rax, rbx
	jae	$LN1128@ZSTD_decod

; 1205 :     ip += hSize; cSrcSize -= hSize;

	sub	rbx, rax

; 1207 :     return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);

	mov	QWORD PTR [rsp+32], r15
	mov	r9, rbx
	lea	r8, QWORD PTR [rsi+rax]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 150  :                         hufSuccess = HUF_decompress1X1_DCtx_wksp_bmi2(

	lea	rcx, QWORD PTR [rdi+29176]
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c

; 1207 :     return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);

	mov	rdx, rbp
$LN61@ZSTD_decod:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	call	HUF_decompress1X1_usingDTable_internal
	jmp	SHORT $LN1116@ZSTD_decod
$LN36@ZSTD_decod:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 156  :                         hufSuccess = HUF_decompress4X_hufOnly_wksp_bmi2(

	mov	r11d, DWORD PTR [rdi+29008]
; File E:\dev\pyzstd\lib\decompress\huf_decompress.c

; 1231 :     if (dstSize == 0) return ERROR(dstSize_tooSmall);

	test	rbp, rbp
	je	$LN1128@ZSTD_decod

; 1232 :     if (cSrcSize == 0) return ERROR(corruption_detected);

	test	rbx, rbx
	je	$LN1128@ZSTD_decod

; 1233 : 
; 1234 :     {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);

	mov	rdx, rbx
	mov	rcx, rbp
	call	HUF_selectDecoder

; 1235 : #if defined(HUF_FORCE_DECOMPRESS_X1)
; 1236 :         (void)algoNb;
; 1237 :         assert(algoNb == 0);
; 1238 :         return HUF_decompress4X1_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2);
; 1239 : #elif defined(HUF_FORCE_DECOMPRESS_X2)
; 1240 :         (void)algoNb;
; 1241 :         assert(algoNb == 1);
; 1242 :         return HUF_decompress4X2_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2);
; 1243 : #else
; 1244 :         return algoNb ? HUF_decompress4X2_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2) :

	mov	DWORD PTR [rsp+56], r11d
	mov	r9, rsi
	mov	QWORD PTR [rsp+40], r10
	mov	r8, rbp
	mov	QWORD PTR [rsp+32], rbx
	lea	rdx, QWORD PTR [rdi+29176]
	mov	rcx, r15
	test	eax, eax
	je	SHORT $LN1115@ZSTD_decod
	call	HUF_decompress4X2_DCtx_wksp_bmi2
	jmp	SHORT $LN1116@ZSTD_decod
$LN1115@ZSTD_decod:
	call	HUF_decompress4X1_DCtx_wksp_bmi2
$LN1116@ZSTD_decod:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 163  :                 RETURN_ERROR_IF(HUF_isError(hufSuccess), corruption_detected, "");

	ja	$LN1128@ZSTD_decod

; 164  : 
; 165  :                 dctx->litPtr = dctx->litBuffer;
; 166  :                 dctx->litSize = litSize;

	mov	QWORD PTR [rdi+28984], rbp
	lea	rax, QWORD PTR [rdi+29176]
	mov	QWORD PTR [rdi+28952], rax

; 167  :                 dctx->litEntropy = 1;

	mov	esi, 1
	mov	DWORD PTR [rdi+28840], esi

; 168  :                 if (litEncType==set_compressed) dctx->HUFptr = dctx->entropy.hufTable;

	cmp	r14d, 2
	jne	SHORT $LN40@ZSTD_decod
	lea	rcx, QWORD PTR [rdi+10296]
	mov	QWORD PTR [rdi+24], rcx
$LN40@ZSTD_decod:

; 169  :                 memset(dctx->litBuffer + dctx->litSize, 0, WILDCOPY_OVERLENGTH);
; 170  :                 return litCSize + lhSize;

	xorps	xmm0, xmm0
	mov	rax, r13
	movups	XMMWORD PTR [rdi+rbp+29176], xmm0
	movups	XMMWORD PTR [rdi+rbp+29192], xmm0
	jmp	SHORT $LN14@ZSTD_decod
$LN48@ZSTD_decod:

; 204  :             }
; 205  : 
; 206  :         case set_rle:
; 207  :             {   U32 const lhlCode = ((istart[0]) >> 2) & 3;

	mov	eax, r10d
	shr	eax, 2
	and	eax, 3

; 208  :                 size_t litSize, lhSize;
; 209  :                 switch(lhlCode)

	sub	eax, 1
	je	SHORT $LN50@ZSTD_decod
	cmp	eax, 2
	je	SHORT $LN51@ZSTD_decod

; 210  :                 {
; 211  :                 case 0: case 2: default:   /* note : default is impossible, since lhlCode into [0..3] */
; 212  :                     lhSize = 1;
; 213  :                     litSize = istart[0] >> 3;

	mov	rbp, r10
	mov	esi, 1
	shr	rbp, 3

; 214  :                     break;

	jmp	SHORT $LN52@ZSTD_decod
$LN51@ZSTD_decod:
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	ebp, BYTE PTR [rdx+2]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 220  :                     lhSize = 3;

	mov	esi, 3
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	eax, WORD PTR [rdx]
	shl	rbp, 16
	add	rbp, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 221  :                     litSize = MEM_readLE24(istart) >> 4;

	shr	rbp, 4

; 222  :                     RETURN_ERROR_IF(srcSize<4, corruption_detected, "srcSize >= MIN_CBLOCK_SIZE == 3; here we need lhSize+1 = 4");

	cmp	r8, 4
	jae	SHORT $LN52@ZSTD_decod
$LN1128@ZSTD_decod:

; 193  :                     RETURN_ERROR_IF(litSize+lhSize > srcSize, corruption_detected, "");

	mov	rax, -20
$LN14@ZSTD_decod:

; 230  :             }
; 231  :         default:
; 232  :             RETURN_ERROR(corruption_detected, "impossible");
; 233  :         }
; 234  :     }
; 235  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN50@ZSTD_decod:

; 215  :                 case 1:
; 216  :                     lhSize = 2;
; 217  :                     litSize = MEM_readLE16(istart) >> 4;

	movzx	ebp, WORD PTR [rdx]
	mov	esi, 2
	shr	rbp, 4
$LN52@ZSTD_decod:

; 223  :                     break;
; 224  :                 }
; 225  :                 RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, "");

	cmp	rbp, 131072				; 00020000H
	ja	SHORT $LN1128@ZSTD_decod

; 226  :                 memset(dctx->litBuffer, istart[lhSize], litSize + WILDCOPY_OVERLENGTH);

	movzx	edx, BYTE PTR [rsi+rdx]
	lea	rbx, QWORD PTR [rdi+29176]
	mov	rcx, rbx
	lea	r8, QWORD PTR [rbp+32]
	call	memset

; 227  :                 dctx->litPtr = dctx->litBuffer;
; 228  :                 dctx->litSize = litSize;
; 229  :                 return lhSize+1;

	lea	rax, QWORD PTR [rsi+1]
	mov	QWORD PTR [rdi+28952], rbx
	mov	QWORD PTR [rdi+28984], rbp
	jmp	SHORT $LN14@ZSTD_decod
$LN41@ZSTD_decod:

; 171  :             }
; 172  : 
; 173  :         case set_basic:
; 174  :             {   size_t litSize, lhSize;
; 175  :                 U32 const lhlCode = ((istart[0]) >> 2) & 3;

	mov	eax, r10d
	shr	eax, 2
	and	eax, 3

; 176  :                 switch(lhlCode)

	sub	eax, 1
	je	SHORT $LN43@ZSTD_decod
	cmp	eax, 2
	je	SHORT $LN44@ZSTD_decod

; 177  :                 {
; 178  :                 case 0: case 2: default:   /* note : default is impossible, since lhlCode into [0..3] */
; 179  :                     lhSize = 1;
; 180  :                     litSize = istart[0] >> 3;

	mov	r14, r10
	mov	esi, 1
	shr	r14, 3

; 181  :                     break;

	jmp	SHORT $LN9@ZSTD_decod
$LN44@ZSTD_decod:
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	r14d, BYTE PTR [rdx+2]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 187  :                     lhSize = 3;

	mov	esi, 3
; File E:\dev\pyzstd\lib\common\mem.h

; 341  :     return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);

	movzx	eax, WORD PTR [rdx]
	shl	r14, 16
	add	r14, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 188  :                     litSize = MEM_readLE24(istart) >> 4;

	jmp	SHORT $LN1130@ZSTD_decod
$LN43@ZSTD_decod:

; 182  :                 case 1:
; 183  :                     lhSize = 2;
; 184  :                     litSize = MEM_readLE16(istart) >> 4;

	movzx	r14d, WORD PTR [rdx]
	mov	esi, 2
$LN1130@ZSTD_decod:

; 189  :                     break;
; 190  :                 }
; 191  : 
; 192  :                 if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {  /* risk reading beyond src buffer with wildcopy */

	shr	r14, 4
$LN9@ZSTD_decod:
	lea	rbp, QWORD PTR [r14+rsi]
	lea	rax, QWORD PTR [rbp+32]
	cmp	rax, r8
	jbe	SHORT $LN45@ZSTD_decod

; 193  :                     RETURN_ERROR_IF(litSize+lhSize > srcSize, corruption_detected, "");

	cmp	rbp, r8
	ja	$LN1128@ZSTD_decod

; 194  :                     memcpy(dctx->litBuffer, istart+lhSize, litSize);

	lea	rbx, QWORD PTR [rdi+29176]
	add	rdx, rsi
	mov	rcx, rbx
	mov	r8, r14
	call	memcpy
	xorps	xmm0, xmm0

; 195  :                     dctx->litPtr = dctx->litBuffer;

	mov	QWORD PTR [rdi+28952], rbx

; 196  :                     dctx->litSize = litSize;

	mov	QWORD PTR [rdi+28984], r14

; 197  :                     memset(dctx->litBuffer + dctx->litSize, 0, WILDCOPY_OVERLENGTH);
; 198  :                     return lhSize+litSize;

	mov	rax, rbp
	movups	XMMWORD PTR [r14+rdi+29176], xmm0
	movups	XMMWORD PTR [r14+rdi+29192], xmm0
	jmp	$LN14@ZSTD_decod
$LN45@ZSTD_decod:

; 199  :                 }
; 200  :                 /* direct reference into compressed stream */
; 201  :                 dctx->litPtr = istart+lhSize;

	lea	rax, QWORD PTR [rsi+rdx]

; 202  :                 dctx->litSize = litSize;

	mov	QWORD PTR [rdi+28984], r14
	mov	QWORD PTR [rdi+28952], rax

; 203  :                 return lhSize+litSize;

	mov	rax, rbp
	jmp	$LN14@ZSTD_decod
ZSTD_decodeLiteralsBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dt$ = 8
baseValue$ = 16
nbAddBits$ = 24
ZSTD_buildSeqTable_rle PROC

; 348  :     void* ptr = dt;
; 349  :     ZSTD_seqSymbol_header* const DTableH = (ZSTD_seqSymbol_header*)ptr;
; 350  :     ZSTD_seqSymbol* const cell = dt + 1;
; 351  : 
; 352  :     DTableH->tableLog = 0;

	xor	eax, eax

; 353  :     DTableH->fastMode = 0;
; 354  : 
; 355  :     cell->nbBits = 0;
; 356  :     cell->nextState = 0;
; 357  :     assert(nbAddBits < 255);
; 358  :     cell->nbAdditionalBits = (BYTE)nbAddBits;

	mov	BYTE PTR [rcx+10], r8b
	mov	QWORD PTR [rcx], rax
	mov	BYTE PTR [rcx+11], al
	mov	WORD PTR [rcx+8], ax

; 359  :     cell->baseValue = baseValue;

	mov	DWORD PTR [rcx+12], edx

; 360  : }

	ret	0
ZSTD_buildSeqTable_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
max$GSCopy$ = 48
tableLog$1 = 56
norm$2 = 64
__$ArrayPad$ = 176
DTableSpace$ = 224
DTablePtr$ = 232
type$ = 240
max$ = 248
maxLog$ = 256
src$ = 264
srcSize$ = 272
baseValue$ = 280
nbAdditionalBits$ = 288
defaultTable$ = 296
flagRepeatTable$ = 304
ddictIsCold$ = 312
nbSeq$ = 320
ZSTD_buildSeqTable PROC

; 439  : {

	push	rbx
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR max$GSCopy$[rsp], r9d
	mov	rbx, rcx
	mov	rcx, QWORD PTR src$[rsp]
	mov	rdi, rdx

; 440  :     switch(type)

	test	r8d, r8d
	je	$LN15@ZSTD_build
	mov	QWORD PTR [rsp+192], rsi
	sub	r8d, 1
	je	$LN10@ZSTD_build
	sub	r8d, 1
	je	$LN20@ZSTD_build
	cmp	r8d, 1
	je	SHORT $LN16@ZSTD_build

; 473  :         }
; 474  :     default :
; 475  :         assert(0);
; 476  :         RETURN_ERROR(GENERIC, "impossible");

	mov	rax, -1
$LN37@ZSTD_build:
	mov	rsi, QWORD PTR [rsp+192]
$LN8@ZSTD_build:

; 477  :     }
; 478  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rbx
	ret	0
$LN16@ZSTD_build:

; 455  :     case set_repeat:
; 456  :         RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, "");

	cmp	DWORD PTR flagRepeatTable$[rsp], 0
	je	$LN36@ZSTD_build

; 457  :         /* prefetch FSE table if used */
; 458  :         if (ddictIsCold && (nbSeq > 24 /* heuristic */)) {

	cmp	DWORD PTR ddictIsCold$[rsp], 0
	je	SHORT $LN5@ZSTD_build
	cmp	DWORD PTR nbSeq$[rsp], 24
	jle	SHORT $LN5@ZSTD_build

; 459  :             const void* const pStart = *DTablePtr;
; 460  :             size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));

	mov	ecx, DWORD PTR maxLog$[rsp]
	mov	eax, 1

; 461  :             PREFETCH_AREA(pStart, pSize);

	mov	rdx, QWORD PTR [rdx]
	shl	eax, cl
	inc	eax
	movsxd	rcx, eax
	xor	eax, eax
	shl	rcx, 3
	test	rcx, rcx
	je	SHORT $LN5@ZSTD_build
	npad	10
$LL6@ZSTD_build:
	prefetcht1 BYTE PTR [rax+rdx]
	add	rax, 64					; 00000040H
	cmp	rax, rcx
	jb	SHORT $LL6@ZSTD_build
$LN5@ZSTD_build:

; 462  :         }
; 463  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN37@ZSTD_build
$LN20@ZSTD_build:

; 464  :     case set_compressed :
; 465  :         {   unsigned tableLog;
; 466  :             S16 norm[MaxSeq+1];
; 467  :             size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);

	mov	rax, QWORD PTR srcSize$[rsp]
	lea	r8, QWORD PTR tableLog$1[rsp]
	mov	r9, rcx
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR norm$2[rsp]
	lea	rdx, QWORD PTR max$GSCopy$[rsp]
	call	FSE_readNCount
	mov	rsi, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 468  :             RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, "");

	ja	SHORT $LN36@ZSTD_build

; 469  :             RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, "");

	mov	eax, DWORD PTR tableLog$1[rsp]
	cmp	eax, DWORD PTR maxLog$[rsp]
	ja	SHORT $LN36@ZSTD_build

; 470  :             ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);

	mov	r9, QWORD PTR baseValue$[rsp]
	lea	rdx, QWORD PTR norm$2[rsp]
	mov	r8d, DWORD PTR max$GSCopy$[rsp]
	mov	rcx, rbx
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR nbAdditionalBits$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_buildFSETable

; 471  :             *DTablePtr = DTableSpace;
; 472  :             return headerSize;

	mov	rax, rsi
	mov	QWORD PTR [rdi], rbx
	jmp	$LN37@ZSTD_build
$LN10@ZSTD_build:

; 441  :     {
; 442  :     case set_rle :
; 443  :         RETURN_ERROR_IF(!srcSize, srcSize_wrong, "");

	cmp	QWORD PTR srcSize$[rsp], 0
	jne	SHORT $LN11@ZSTD_build
	mov	rax, -72				; ffffffffffffffb8H
	jmp	$LN37@ZSTD_build
$LN11@ZSTD_build:

; 444  :         RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, "");

	movzx	eax, BYTE PTR [rcx]
	cmp	eax, r9d
	jbe	SHORT $LN13@ZSTD_build
$LN36@ZSTD_build:
	mov	rax, -20
	jmp	$LN37@ZSTD_build
$LN13@ZSTD_build:

; 445  :         {   U32 const symbol = *(const BYTE*)src;
; 446  :             U32 const baseline = baseValue[symbol];

	lea	rcx, QWORD PTR [rax*4]
	mov	rax, QWORD PTR baseValue$[rsp]
	mov	r8d, DWORD PTR [rcx+rax]

; 447  :             U32 const nbBits = nbAdditionalBits[symbol];

	mov	rax, QWORD PTR nbAdditionalBits$[rsp]
	mov	edx, DWORD PTR [rcx+rax]

; 352  :     DTableH->tableLog = 0;

	xor	eax, eax

; 353  :     DTableH->fastMode = 0;

	mov	QWORD PTR [rbx], rax

; 354  : 
; 355  :     cell->nbBits = 0;

	mov	BYTE PTR [rbx+11], al

; 356  :     cell->nextState = 0;

	mov	WORD PTR [rbx+8], ax

; 451  :         return 1;

	mov	eax, 1

; 358  :     cell->nbAdditionalBits = (BYTE)nbAddBits;

	mov	BYTE PTR [rbx+10], dl

; 359  :     cell->baseValue = baseValue;

	mov	DWORD PTR [rbx+12], r8d

; 448  :             ZSTD_buildSeqTable_rle(DTableSpace, baseline, nbBits);
; 449  :         }
; 450  :         *DTablePtr = DTableSpace;

	mov	QWORD PTR [rdi], rbx

; 451  :         return 1;

	jmp	$LN37@ZSTD_build
$LN15@ZSTD_build:

; 452  :     case set_basic :
; 453  :         *DTablePtr = defaultTable;

	mov	rax, QWORD PTR defaultTable$[rsp]
	mov	QWORD PTR [rdx], rax

; 454  :         return 0;

	xor	eax, eax
	jmp	$LN8@ZSTD_build
ZSTD_buildSeqTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
tableLog$1$ = 48
r$1 = 48
DTableH$2 = 48
max$ = 48
tableLog$3 = 48
r$4 = 48
tableLog$5 = 48
nbSeq$1$ = 56
MLtype$1$ = 64
DTableH$6 = 64
tableLog$7 = 64
DTableH$8 = 72
max$ = 72
max$ = 80
ip$1$ = 88
dctx$GSCopy$1$ = 96
headerSize$1$ = 104
ofhSize$1$ = 104
srcSize$1$ = 112
src$GSCopy$1$ = 120
norm$9 = 128
norm$10 = 128
norm$11 = 128
symbolNext$12 = 240
symbolNext$13 = 352
symbolNext$14 = 464
__$ArrayPad$ = 576
dctx$ = 672
nbSeqPtr$ = 680
src$ = 688
srcSize$ = 696
ZSTD_decodeSeqHeaders PROC

; 482  : {

$LN271:
	push	rbp
	push	rbx
	push	rsi
	lea	rbp, QWORD PTR [rsp-384]
	sub	rsp, 640				; 00000280H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR dctx$GSCopy$1$[rsp], rcx
	mov	rax, r8
	mov	QWORD PTR src$GSCopy$1$[rsp], rax

; 483  :     const BYTE* const istart = (const BYTE* const)src;
; 484  :     const BYTE* const iend = istart + srcSize;

	lea	r10, QWORD PTR [r9+r8]
	mov	QWORD PTR srcSize$1$[rsp], r10
	mov	r11, rcx

; 485  :     const BYTE* ip = istart;
; 486  :     int nbSeq;
; 487  :     DEBUGLOG(5, "ZSTD_decodeSeqHeaders");
; 488  : 
; 489  :     /* check */
; 490  :     RETURN_ERROR_IF(srcSize < MIN_SEQUENCES_SIZE, srcSize_wrong, "");

	cmp	r9, 1
	jb	$LN263@ZSTD_decod

; 491  : 
; 492  :     /* SeqHead */
; 493  :     nbSeq = *ip++;

	movzx	r8d, BYTE PTR [r8]
	lea	rcx, QWORD PTR [rax+1]
	mov	DWORD PTR nbSeq$1$[rsp], r8d

; 494  :     if (!nbSeq) {

	test	r8d, r8d
	jne	SHORT $LN4@ZSTD_decod

; 495  :         *nbSeqPtr=0;

	xor	esi, esi
	mov	DWORD PTR [rdx], esi

; 496  :         RETURN_ERROR_IF(srcSize != 1, srcSize_wrong, "");

	cmp	r9, 1
	jne	$LN263@ZSTD_decod

; 497  :         return 1;

	mov	rax, r9
	jmp	$LN1@ZSTD_decod
$LN4@ZSTD_decod:

; 498  :     }
; 499  :     if (nbSeq > 0x7F) {

	cmp	r8d, 127				; 0000007fH
	jbe	SHORT $LN9@ZSTD_decod

; 500  :         if (nbSeq == 0xFF) {

	cmp	r8d, 255				; 000000ffH
	jne	SHORT $LN8@ZSTD_decod

; 501  :             RETURN_ERROR_IF(ip+2 > iend, srcSize_wrong, "");

	lea	rax, QWORD PTR [rcx+2]
	cmp	rax, r10
	ja	$LN263@ZSTD_decod

; 502  :             nbSeq = MEM_readLE16(ip) + LONGNBSEQ, ip+=2;

	movzx	r8d, WORD PTR [rcx]
	mov	rcx, rax
	add	r8d, 32512				; 00007f00H

; 503  :         } else {

	jmp	SHORT $LN269@ZSTD_decod
$LN8@ZSTD_decod:

; 504  :             RETURN_ERROR_IF(ip >= iend, srcSize_wrong, "");

	cmp	rcx, r10
	jae	$LN263@ZSTD_decod

; 505  :             nbSeq = ((nbSeq-0x80)<<8) + *ip++;

	movzx	eax, BYTE PTR [rcx]
	add	r8d, -128				; ffffffffffffff80H
	shl	r8d, 8
	add	r8d, eax
	inc	rcx
$LN269@ZSTD_decod:

; 506  :         }
; 507  :     }
; 508  :     *nbSeqPtr = nbSeq;

	mov	DWORD PTR nbSeq$1$[rsp], r8d
$LN9@ZSTD_decod:

; 509  : 
; 510  :     /* FSE table descriptors */
; 511  :     RETURN_ERROR_IF(ip+1 > iend, srcSize_wrong, ""); /* minimum possible size: 1 byte for symbol encoding types */

	lea	r9, QWORD PTR [rcx+1]
	mov	DWORD PTR [rdx], r8d
	mov	QWORD PTR ip$1$[rsp], r9
	cmp	r9, r10
	ja	$LN263@ZSTD_decod

; 512  :     {   symbolEncodingType_e const LLtype = (symbolEncodingType_e)(*ip >> 6);

	movzx	edx, BYTE PTR [rcx]

; 440  :     switch(type)

	mov	ebx, 1

; 512  :     {   symbolEncodingType_e const LLtype = (symbolEncodingType_e)(*ip >> 6);

	mov	QWORD PTR [rsp+632], rdi

; 513  :         symbolEncodingType_e const OFtype = (symbolEncodingType_e)((*ip >> 4) & 3);
; 514  :         symbolEncodingType_e const MLtype = (symbolEncodingType_e)((*ip >> 2) & 3);

	mov	eax, edx
	mov	QWORD PTR [rsp+624], r12
	mov	edi, edx
	mov	QWORD PTR [rsp+616], r13

; 515  :         ip++;
; 516  : 
; 517  :         /* Build DTables */
; 518  :         {   size_t const llhSize = ZSTD_buildSeqTable(dctx->entropy.LLTable, &dctx->LLTptr,

	mov	rcx, r10
	shr	edi, 4

; 440  :     switch(type)

	lea	r13, OFFSET FLAT:__ImageBase

; 513  :         symbolEncodingType_e const OFtype = (symbolEncodingType_e)((*ip >> 4) & 3);
; 514  :         symbolEncodingType_e const MLtype = (symbolEncodingType_e)((*ip >> 2) & 3);

	shr	eax, 2
	and	edi, 3
	and	eax, 3
	shr	edx, 6

; 515  :         ip++;
; 516  : 
; 517  :         /* Build DTables */
; 518  :         {   size_t const llhSize = ZSTD_buildSeqTable(dctx->entropy.LLTable, &dctx->LLTptr,

	sub	rcx, r9
	mov	QWORD PTR [rsp+608], r14
	mov	QWORD PTR [rsp+600], r15
	lea	r15, QWORD PTR [r11+32]
	mov	DWORD PTR MLtype$1$[rsp], eax
	mov	DWORD PTR max$[rsp], 35			; 00000023H

; 440  :     switch(type)

	test	edx, edx
	je	$LN37@ZSTD_decod
	sub	edx, ebx
	je	$LN32@ZSTD_decod
	sub	edx, ebx
	je	SHORT $LN42@ZSTD_decod
	cmp	edx, ebx
	jne	$LN259@ZSTD_decod

; 455  :     case set_repeat:
; 456  :         RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, "");

	cmp	DWORD PTR [r11+28844], 0
	je	$LN259@ZSTD_decod

; 457  :         /* prefetch FSE table if used */
; 458  :         if (ddictIsCold && (nbSeq > 24 /* heuristic */)) {

	xor	esi, esi
	cmp	DWORD PTR [r11+29036], esi
	je	$LN27@ZSTD_decod
	cmp	r8d, 24
	jle	$LN27@ZSTD_decod

; 459  :             const void* const pStart = *DTablePtr;
; 460  :             size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));
; 461  :             PREFETCH_AREA(pStart, pSize);

	mov	rcx, QWORD PTR [r11]
	mov	eax, esi
	npad	9
$LL28@ZSTD_decod:
	prefetcht1 BYTE PTR [rax+rcx]
	add	rax, 64					; 00000040H
	cmp	rax, 4104				; 00001008H
	jb	SHORT $LL28@ZSTD_decod

; 462  :         }
; 463  :         return 0;

	jmp	$LN27@ZSTD_decod
$LN42@ZSTD_decod:

; 464  :     case set_compressed :
; 465  :         {   unsigned tableLog;
; 466  :             S16 norm[MaxSeq+1];
; 467  :             size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, QWORD PTR tableLog$5[rsp]
	lea	rcx, QWORD PTR norm$11[rbp-256]
	lea	rdx, QWORD PTR max$[rsp]
	call	FSE_readNCount
	mov	r12, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 468  :             RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, "");

	ja	$LN259@ZSTD_decod

; 469  :             RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, "");

	mov	ebx, DWORD PTR tableLog$5[rsp]
	mov	DWORD PTR tableLog$1$[rsp], ebx
	cmp	ebx, 9
	ja	$LN259@ZSTD_decod

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	r14d, DWORD PTR max$[rsp]
	mov	eax, 1
	mov	ecx, ebx

; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$8[rsp+4], ebx

; 470  :             ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);

	xor	esi, esi

; 387  :         DTableH.fastMode = 1;

	mov	DWORD PTR DTableH$8[rsp], eax
	mov	r13d, eax

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	r11d, eax
	shl	r13d, cl
	mov	edx, eax
	lea	ecx, DWORD PTR [rbx-1]

; 470  :             ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);

	mov	r9d, esi

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	shl	r11w, cl
	lea	r10d, DWORD PTR [r13-1]
	mov	r8d, r10d
	add	r14d, eax

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	je	$LN56@ZSTD_decod
	mov	ecx, esi
	mov	ebx, eax
	npad	6
$LL57@ZSTD_decod:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR norm$11[rbp+rcx-256]
	cmp	ax, -1
	jne	SHORT $LN69@ZSTD_decod

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	eax, r8d
	dec	r8d
	mov	DWORD PTR [r15+rax*8+12], r9d

; 393  :                     symbolNext[s] = 1;

	movzx	eax, bx

; 394  :                 } else {

	jmp	SHORT $LN55@ZSTD_decod
$LN69@ZSTD_decod:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r11w
	cmovge	edx, esi
	mov	DWORD PTR DTableH$8[rsp], edx
$LN55@ZSTD_decod:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR symbolNext$12[rbp+rcx-256], ax
	inc	r9d
	add	rcx, 2
	cmp	r9d, r14d
	jb	SHORT $LL57@ZSTD_decod
	mov	rax, QWORD PTR DTableH$8[rsp]
	lea	rbx, QWORD PTR norm$11[rbp-256]
	mov	r9d, r13d
	mov	QWORD PTR [r15], rax
	shr	r9d, 1
	mov	ecx, r13d
	add	r9d, 3
	shr	ecx, 3
	add	r9d, ecx
	mov	edx, esi
	mov	r11d, esi
	npad	5
$LL60@ZSTD_decod:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	eax, WORD PTR [rbx]
	test	eax, eax
	jle	SHORT $LN58@ZSTD_decod
	mov	ecx, eax
	npad	7
$LL63@ZSTD_decod:

; 409  :                 tableDecode[position].baseValue = s;

	mov	eax, edx

; 410  :                 position = (position + step) & tableMask;

	add	edx, r9d
	and	edx, r10d
	mov	DWORD PTR [r15+rax*8+12], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	edx, r8d
	jbe	SHORT $LN61@ZSTD_decod
$LL64@ZSTD_decod:
	add	edx, r9d
	and	edx, r10d
	cmp	edx, r8d
	ja	SHORT $LL64@ZSTD_decod
$LN61@ZSTD_decod:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rcx, 1
	jne	SHORT $LL63@ZSTD_decod
$LN58@ZSTD_decod:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rbx, 2
	cmp	r11d, r14d
	jb	SHORT $LL60@ZSTD_decod
	mov	ebx, DWORD PTR tableLog$1$[rsp]
	jmp	SHORT $LN59@ZSTD_decod
$LN56@ZSTD_decod:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rax, QWORD PTR DTableH$8[rsp]
	mov	QWORD PTR [r15], rax
$LN59@ZSTD_decod:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	test	r13d, r13d
	je	SHORT $LN67@ZSTD_decod
	lea	r10, QWORD PTR [r15+12]
	mov	r11d, r13d
	lea	r14, OFFSET FLAT:__ImageBase
$LL68@ZSTD_decod:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, esi
	mov	DWORD PTR r$4[rsp], esi
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, bl
	movzx	r8d, WORD PTR symbolNext$12[rbp+r9*2-256]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$12[rbp+r9*2-256], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, r13w
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR LL_bits[r14+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR LL_base[r14+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, 1
	jne	SHORT $LL68@ZSTD_decod
$LN67@ZSTD_decod:

; 471  :             *DTablePtr = DTableSpace;

	mov	r11, QWORD PTR dctx$GSCopy$1$[rsp]

; 472  :             return headerSize;

	lea	r13, OFFSET FLAT:__ImageBase
	mov	r8d, DWORD PTR nbSeq$1$[rsp]
	mov	ebx, 1
	mov	r10, QWORD PTR srcSize$1$[rsp]
	mov	r9, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR [r11], r15
	jmp	SHORT $LN16@ZSTD_decod
$LN32@ZSTD_decod:

; 441  :     {
; 442  :     case set_rle :
; 443  :         RETURN_ERROR_IF(!srcSize, srcSize_wrong, "");

	test	rcx, rcx
	je	$LN259@ZSTD_decod

; 444  :         RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, "");

	movzx	eax, BYTE PTR [r9]
	cmp	al, 35					; 00000023H
	ja	$LN259@ZSTD_decod

; 445  :         {   U32 const symbol = *(const BYTE*)src;
; 446  :             U32 const baseline = baseValue[symbol];

	mov	edx, DWORD PTR LL_base[r13+rax*4]

; 352  :     DTableH->tableLog = 0;

	xor	esi, esi

; 447  :             U32 const nbBits = nbAdditionalBits[symbol];

	mov	ecx, DWORD PTR LL_bits[r13+rax*4]

; 451  :         return 1;

	mov	r12, rbx

; 353  :     DTableH->fastMode = 0;

	mov	QWORD PTR [r15], rsi

; 354  : 
; 355  :     cell->nbBits = 0;

	mov	BYTE PTR [r15+11], sil

; 356  :     cell->nextState = 0;

	mov	WORD PTR [r15+8], si

; 357  :     assert(nbAddBits < 255);
; 358  :     cell->nbAdditionalBits = (BYTE)nbAddBits;

	mov	BYTE PTR [r15+10], cl

; 359  :     cell->baseValue = baseValue;

	mov	DWORD PTR [r15+12], edx

; 450  :         *DTablePtr = DTableSpace;

	mov	QWORD PTR [r11], r15

; 451  :         return 1;

	jmp	SHORT $LN16@ZSTD_decod
$LN37@ZSTD_decod:

; 452  :     case set_basic :
; 453  :         *DTablePtr = defaultTable;

	lea	rax, OFFSET FLAT:LL_defaultDTable

; 454  :         return 0;

	xor	esi, esi
	mov	QWORD PTR [r11], rax
$LN27@ZSTD_decod:

; 519  :                                                       LLtype, MaxLL, LLFSELog,
; 520  :                                                       ip, iend-ip,
; 521  :                                                       LL_base, LL_bits,
; 522  :                                                       LL_defaultDTable, dctx->fseEntropy,
; 523  :                                                       dctx->ddictIsCold, nbSeq);
; 524  :             RETURN_ERROR_IF(ZSTD_isError(llhSize), corruption_detected, "ZSTD_buildSeqTable failed");
; 525  :             ip += llhSize;

	mov	r12, rsi
$LN16@ZSTD_decod:
	add	r9, r12

; 526  :         }
; 527  : 
; 528  :         {   size_t const ofhSize = ZSTD_buildSeqTable(dctx->entropy.OFTable, &dctx->OFTptr,

	mov	DWORD PTR max$[rsp], 31
	mov	rcx, r10
	mov	QWORD PTR ip$1$[rsp], r9
	sub	rcx, r9
	lea	r14, QWORD PTR [r11+4136]

; 440  :     switch(type)

	test	edi, edi
	je	$LN91@ZSTD_decod
	sub	edi, 1
	je	$LN86@ZSTD_decod
	sub	edi, 1
	je	SHORT $LN96@ZSTD_decod
	cmp	edi, 1
	jne	$LN259@ZSTD_decod

; 455  :     case set_repeat:
; 456  :         RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, "");

	cmp	DWORD PTR [r11+28844], 0
	je	$LN259@ZSTD_decod

; 457  :         /* prefetch FSE table if used */
; 458  :         if (ddictIsCold && (nbSeq > 24 /* heuristic */)) {

	cmp	DWORD PTR [r11+29036], 0
	je	$LN81@ZSTD_decod
	cmp	r8d, 24
	jle	$LN81@ZSTD_decod

; 459  :             const void* const pStart = *DTablePtr;
; 460  :             size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));
; 461  :             PREFETCH_AREA(pStart, pSize);

	mov	rcx, QWORD PTR [r11+16]
	mov	rax, rsi
	npad	4
$LL82@ZSTD_decod:
	prefetcht1 BYTE PTR [rax+rcx]
	add	rax, 64					; 00000040H
	cmp	rax, 2056				; 00000808H
	jb	SHORT $LL82@ZSTD_decod

; 462  :         }
; 463  :         return 0;

	jmp	$LN81@ZSTD_decod
$LN96@ZSTD_decod:

; 464  :     case set_compressed :
; 465  :         {   unsigned tableLog;
; 466  :             S16 norm[MaxSeq+1];
; 467  :             size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, QWORD PTR tableLog$3[rsp]
	lea	rcx, QWORD PTR norm$10[rbp-256]
	lea	rdx, QWORD PTR max$[rsp]
	call	FSE_readNCount
	mov	QWORD PTR ofhSize$1$[rsp], rax
	mov	r12, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 468  :             RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, "");

	ja	$LN259@ZSTD_decod

; 469  :             RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, "");

	mov	r13d, DWORD PTR tableLog$3[rsp]
	cmp	r13d, 8
	ja	$LN259@ZSTD_decod

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	edi, DWORD PTR max$[rsp]
	mov	ecx, r13d
	mov	r15d, ebx

; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$2[rsp+4], r13d
	shl	r15d, cl

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	r11d, ebx
	lea	ecx, DWORD PTR [r13-1]
	mov	DWORD PTR DTableH$2[rsp], ebx
	shl	r11w, cl
	mov	edx, ebx

; 470  :             ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);

	mov	r9d, esi

; 378  :     U32 highThreshold = tableSize-1;

	lea	r10d, DWORD PTR [r15-1]
	mov	r8d, r10d
	add	edi, 1

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	je	$LN110@ZSTD_decod
	mov	rcx, rsi
	npad	9
$LL111@ZSTD_decod:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR norm$10[rbp+rcx-256]
	cmp	ax, -1
	jne	SHORT $LN123@ZSTD_decod

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	eax, r8d
	dec	r8d
	mov	DWORD PTR [r14+rax*8+12], r9d

; 393  :                     symbolNext[s] = 1;

	movzx	eax, bx

; 394  :                 } else {

	jmp	SHORT $LN109@ZSTD_decod
$LN123@ZSTD_decod:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r11w
	cmovge	edx, esi
	mov	DWORD PTR DTableH$2[rsp], edx
$LN109@ZSTD_decod:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR symbolNext$13[rbp+rcx-256], ax
	inc	r9d
	add	rcx, 2
	cmp	r9d, edi
	jb	SHORT $LL111@ZSTD_decod
	mov	rax, QWORD PTR DTableH$2[rsp]
	lea	rbx, QWORD PTR norm$10[rbp-256]
	mov	r9d, r15d
	mov	QWORD PTR [r14], rax
	shr	r9d, 1
	mov	ecx, r15d
	add	r9d, 3
	shr	ecx, 3
	add	r9d, ecx
	mov	edx, esi
	mov	r11d, esi
	npad	5
$LL114@ZSTD_decod:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	eax, WORD PTR [rbx]
	test	eax, eax
	jle	SHORT $LN112@ZSTD_decod
	mov	ecx, eax
	npad	7
$LL117@ZSTD_decod:

; 409  :                 tableDecode[position].baseValue = s;

	mov	eax, edx

; 410  :                 position = (position + step) & tableMask;

	add	edx, r9d
	and	edx, r10d
	mov	DWORD PTR [r14+rax*8+12], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	edx, r8d
	jbe	SHORT $LN115@ZSTD_decod
$LL118@ZSTD_decod:
	add	edx, r9d
	and	edx, r10d
	cmp	edx, r8d
	ja	SHORT $LL118@ZSTD_decod
$LN115@ZSTD_decod:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rcx, 1
	jne	SHORT $LL117@ZSTD_decod
$LN112@ZSTD_decod:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rbx, 2
	cmp	r11d, edi
	jb	SHORT $LL114@ZSTD_decod
	mov	ebx, 1
	jmp	SHORT $LN113@ZSTD_decod
$LN110@ZSTD_decod:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rax, QWORD PTR DTableH$2[rsp]
	mov	QWORD PTR [r14], rax
$LN113@ZSTD_decod:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	test	r15d, r15d
	je	SHORT $LN121@ZSTD_decod
	lea	r10, QWORD PTR [r14+12]
	mov	r11d, r15d
	lea	r12, OFFSET FLAT:__ImageBase
$LL122@ZSTD_decod:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, esi
	mov	DWORD PTR r$1[rsp], esi
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r13b
	movzx	r8d, WORD PTR symbolNext$13[rbp+r9*2-256]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$13[rbp+r9*2-256], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, r15w
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR OF_bits[r12+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR OF_base[r12+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, 1
	jne	SHORT $LL122@ZSTD_decod
	mov	r12, QWORD PTR ofhSize$1$[rsp]
$LN121@ZSTD_decod:

; 471  :             *DTablePtr = DTableSpace;

	mov	r11, QWORD PTR dctx$GSCopy$1$[rsp]

; 472  :             return headerSize;

	mov	r10, QWORD PTR srcSize$1$[rsp]
	mov	r9, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR [r11+16], r14
	jmp	SHORT $LN18@ZSTD_decod
$LN86@ZSTD_decod:

; 441  :     {
; 442  :     case set_rle :
; 443  :         RETURN_ERROR_IF(!srcSize, srcSize_wrong, "");

	test	rcx, rcx
	je	$LN259@ZSTD_decod

; 444  :         RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, "");

	movzx	eax, BYTE PTR [r9]
	cmp	al, 31
	ja	$LN259@ZSTD_decod

; 445  :         {   U32 const symbol = *(const BYTE*)src;
; 446  :             U32 const baseline = baseValue[symbol];

	mov	edx, DWORD PTR OF_base[r13+rax*4]

; 451  :         return 1;

	mov	r12, rbx
	mov	ecx, DWORD PTR OF_bits[r13+rax*4]

; 353  :     DTableH->fastMode = 0;

	mov	QWORD PTR [r14], 0

; 354  : 
; 355  :     cell->nbBits = 0;

	mov	BYTE PTR [r14+11], 0

; 356  :     cell->nextState = 0;

	mov	WORD PTR [r14+8], si

; 357  :     assert(nbAddBits < 255);
; 358  :     cell->nbAdditionalBits = (BYTE)nbAddBits;

	mov	BYTE PTR [r14+10], cl

; 359  :     cell->baseValue = baseValue;

	mov	DWORD PTR [r14+12], edx

; 450  :         *DTablePtr = DTableSpace;

	mov	QWORD PTR [r11+16], r14

; 451  :         return 1;

	jmp	SHORT $LN18@ZSTD_decod
$LN91@ZSTD_decod:

; 452  :     case set_basic :
; 453  :         *DTablePtr = defaultTable;

	lea	rax, OFFSET FLAT:OF_defaultDTable
	mov	QWORD PTR [r11+16], rax
$LN81@ZSTD_decod:

; 529  :                                                       OFtype, MaxOff, OffFSELog,
; 530  :                                                       ip, iend-ip,
; 531  :                                                       OF_base, OF_bits,
; 532  :                                                       OF_defaultDTable, dctx->fseEntropy,
; 533  :                                                       dctx->ddictIsCold, nbSeq);
; 534  :             RETURN_ERROR_IF(ZSTD_isError(ofhSize), corruption_detected, "ZSTD_buildSeqTable failed");
; 535  :             ip += ofhSize;

	mov	r12, rsi
$LN18@ZSTD_decod:

; 440  :     switch(type)

	mov	ecx, DWORD PTR MLtype$1$[rsp]

; 536  :         }
; 537  : 
; 538  :         {   size_t const mlhSize = ZSTD_buildSeqTable(dctx->entropy.MLTable, &dctx->MLTptr,

	lea	rdi, QWORD PTR [r11+6192]
	add	r9, r12
	mov	DWORD PTR max$[rsp], 52			; 00000034H
	sub	r10, r9
	mov	QWORD PTR ip$1$[rsp], r9

; 440  :     switch(type)

	test	ecx, ecx
	je	$LN145@ZSTD_decod
	sub	ecx, 1
	je	$LN140@ZSTD_decod
	sub	ecx, 1
	je	SHORT $LN150@ZSTD_decod
	cmp	ecx, 1
	jne	$LN259@ZSTD_decod

; 455  :     case set_repeat:
; 456  :         RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, "");

	cmp	DWORD PTR [r11+28844], 0
	je	$LN259@ZSTD_decod

; 457  :         /* prefetch FSE table if used */
; 458  :         if (ddictIsCold && (nbSeq > 24 /* heuristic */)) {

	cmp	DWORD PTR [r11+29036], 0
	je	$LN20@ZSTD_decod
	cmp	DWORD PTR nbSeq$1$[rsp], 24
	jle	$LN20@ZSTD_decod

; 459  :             const void* const pStart = *DTablePtr;
; 460  :             size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));
; 461  :             PREFETCH_AREA(pStart, pSize);

	mov	rcx, QWORD PTR [r11+8]
	mov	rax, rsi
	npad	8
$LL136@ZSTD_decod:
	prefetcht1 BYTE PTR [rax+rcx]
	add	rax, 64					; 00000040H
	cmp	rax, 4104				; 00001008H
	jb	SHORT $LL136@ZSTD_decod

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	sub	rsi, QWORD PTR src$GSCopy$1$[rsp]
	lea	rax, QWORD PTR [r9+rsi]
	jmp	$LN268@ZSTD_decod
$LN150@ZSTD_decod:

; 467  :             size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);

	lea	r8, QWORD PTR tableLog$7[rsp]
	mov	QWORD PTR [rsp+32], r10
	lea	rdx, QWORD PTR max$[rsp]
	lea	rcx, QWORD PTR norm$9[rbp-256]
	call	FSE_readNCount
	mov	QWORD PTR headerSize$1$[rsp], rax
	mov	r12, rax
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 468  :             RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, "");

	ja	$LN259@ZSTD_decod

; 469  :             RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, "");

	mov	r13d, DWORD PTR tableLog$7[rsp]
	cmp	r13d, 9
	ja	$LN259@ZSTD_decod

; 376  :     U32 const maxSV1 = maxSymbolValue + 1;

	mov	r14d, DWORD PTR max$[rsp]
	mov	ecx, r13d
	mov	r15d, ebx

; 379  : 
; 380  :     /* Sanity Checks */
; 381  :     assert(maxSymbolValue <= MaxSeq);
; 382  :     assert(tableLog <= MaxFSELog);
; 383  : 
; 384  :     /* Init, lay down lowprob symbols */
; 385  :     {   ZSTD_seqSymbol_header DTableH;
; 386  :         DTableH.tableLog = tableLog;

	mov	DWORD PTR DTableH$6[rsp+4], r13d
	shl	r15d, cl

; 388  :         {   S16 const largeLimit= (S16)(1 << (tableLog-1));

	mov	r11d, ebx
	lea	ecx, DWORD PTR [r13-1]
	mov	DWORD PTR DTableH$6[rsp], ebx
	shl	r11w, cl
	mov	edx, ebx

; 470  :             ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);

	mov	r9d, esi

; 378  :     U32 highThreshold = tableSize-1;

	lea	r10d, DWORD PTR [r15-1]
	mov	r8d, r10d
	add	r14d, 1

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	je	$LN164@ZSTD_decod
	mov	rcx, rsi
$LL165@ZSTD_decod:

; 391  :                 if (normalizedCounter[s]==-1) {

	movzx	eax, WORD PTR norm$9[rbp+rcx-256]
	cmp	ax, -1
	jne	SHORT $LN177@ZSTD_decod

; 392  :                     tableDecode[highThreshold--].baseValue = s;

	mov	eax, r8d
	dec	r8d
	mov	DWORD PTR [rdi+rax*8+12], r9d

; 393  :                     symbolNext[s] = 1;

	movzx	eax, bx

; 394  :                 } else {

	jmp	SHORT $LN163@ZSTD_decod
$LN177@ZSTD_decod:

; 395  :                     if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;

	cmp	ax, r11w
	cmovge	edx, esi
	mov	DWORD PTR DTableH$6[rsp], edx
$LN163@ZSTD_decod:

; 389  :             U32 s;
; 390  :             for (s=0; s<maxSV1; s++) {

	mov	WORD PTR symbolNext$14[rbp+rcx-256], ax
	inc	r9d
	add	rcx, 2
	cmp	r9d, r14d
	jb	SHORT $LL165@ZSTD_decod
	mov	rax, QWORD PTR DTableH$6[rsp]
	lea	rbx, QWORD PTR norm$9[rbp-256]
	mov	r9d, r15d
	mov	QWORD PTR [rdi], rax
	shr	r9d, 1
	mov	edx, r15d
	add	r9d, 3
	shr	edx, 3
	add	r9d, edx
	mov	eax, esi
	mov	r11d, esi
$LL168@ZSTD_decod:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	movsx	ecx, WORD PTR [rbx]
	test	ecx, ecx
	jle	SHORT $LN166@ZSTD_decod
	mov	edx, ecx
	npad	7
$LL171@ZSTD_decod:

; 409  :                 tableDecode[position].baseValue = s;

	mov	ecx, eax

; 410  :                 position = (position + step) & tableMask;

	add	eax, r9d
	and	eax, r10d
	mov	DWORD PTR [rdi+rcx*8+12], r11d

; 411  :                 while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */

	cmp	eax, r8d
	jbe	SHORT $LN169@ZSTD_decod
$LL172@ZSTD_decod:
	add	eax, r9d
	and	eax, r10d
	cmp	eax, r8d
	ja	SHORT $LL172@ZSTD_decod
$LN169@ZSTD_decod:

; 407  :             int i;
; 408  :             for (i=0; i<normalizedCounter[s]; i++) {

	sub	rdx, 1
	jne	SHORT $LL171@ZSTD_decod
$LN166@ZSTD_decod:

; 400  :     }
; 401  : 
; 402  :     /* Spread symbols */
; 403  :     {   U32 const tableMask = tableSize-1;
; 404  :         U32 const step = FSE_TABLESTEP(tableSize);
; 405  :         U32 s, position = 0;
; 406  :         for (s=0; s<maxSV1; s++) {

	inc	r11d
	add	rbx, 2
	cmp	r11d, r14d
	jb	SHORT $LL168@ZSTD_decod
	jmp	SHORT $LN167@ZSTD_decod
$LN164@ZSTD_decod:

; 396  :                     assert(normalizedCounter[s]>=0);
; 397  :                     symbolNext[s] = (U16)normalizedCounter[s];
; 398  :         }   }   }
; 399  :         memcpy(dt, &DTableH, sizeof(DTableH));

	mov	rax, QWORD PTR DTableH$6[rsp]
	mov	QWORD PTR [rdi], rax
$LN167@ZSTD_decod:

; 412  :         }   }
; 413  :         assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
; 414  :     }
; 415  : 
; 416  :     /* Build Decoding table */
; 417  :     {   U32 u;
; 418  :         for (u=0; u<tableSize; u++) {

	test	r15d, r15d
	je	SHORT $LN175@ZSTD_decod
	lea	r10, QWORD PTR [rdi+12]
	mov	r11d, r15d
	lea	r12, OFFSET FLAT:__ImageBase
	npad	4
$LL176@ZSTD_decod:

; 419  :             U32 const symbol = tableDecode[u].baseValue;
; 420  :             U32 const nextState = symbolNext[symbol]++;

	mov	r9d, DWORD PTR [r10]
	lea	r10, QWORD PTR [r10+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	mov	edx, esi
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	movzx	ecx, r13b
	movzx	r8d, WORD PTR symbolNext$14[rbp+r9*2-256]
	lea	eax, DWORD PTR [r8+1]
	mov	WORD PTR symbolNext$14[rbp+r9*2-256], ax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 145  :         return _BitScanReverse ( &r, val ) ? (unsigned)r : 0;

	bsr	eax, r8d
	movzx	eax, al
	cmovne	edx, eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 421  :             tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );

	sub	cl, dl
	mov	BYTE PTR [r10-9], cl

; 422  :             tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);

	shl	r8w, cl
	sub	r8w, r15w
	mov	WORD PTR [r10-12], r8w

; 423  :             assert(nbAdditionalBits[symbol] < 255);
; 424  :             tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];

	movzx	eax, BYTE PTR ML_bits[r12+r9*4]
	mov	BYTE PTR [r10-10], al

; 425  :             tableDecode[u].baseValue = baseValue[symbol];

	mov	eax, DWORD PTR ML_base[r12+r9*4]
	mov	DWORD PTR [r10-8], eax
	sub	r11, 1
	jne	SHORT $LL176@ZSTD_decod
	mov	r12, QWORD PTR headerSize$1$[rsp]
$LN175@ZSTD_decod:

; 471  :             *DTablePtr = DTableSpace;

	mov	rax, QWORD PTR dctx$GSCopy$1$[rsp]

; 472  :             return headerSize;

	mov	rsi, r12

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	sub	rsi, QWORD PTR src$GSCopy$1$[rsp]

; 472  :             return headerSize;

	mov	r9, QWORD PTR ip$1$[rsp]
	mov	QWORD PTR [rax+8], rdi

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	lea	rax, QWORD PTR [r9+rsi]
	jmp	SHORT $LN268@ZSTD_decod
$LN140@ZSTD_decod:

; 443  :         RETURN_ERROR_IF(!srcSize, srcSize_wrong, "");

	test	r10, r10
	je	SHORT $LN259@ZSTD_decod

; 444  :         RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, "");

	movzx	eax, BYTE PTR [r9]
	cmp	al, 52					; 00000034H
	ja	SHORT $LN259@ZSTD_decod

; 445  :         {   U32 const symbol = *(const BYTE*)src;
; 446  :             U32 const baseline = baseValue[symbol];

	lea	r14, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR ML_base[r14+rax*4]

; 447  :             U32 const nbBits = nbAdditionalBits[symbol];

	mov	ecx, DWORD PTR ML_bits[r14+rax*4]

; 356  :     cell->nextState = 0;

	mov	WORD PTR [rdi+8], si

; 451  :         return 1;

	mov	rsi, rbx

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	sub	rsi, QWORD PTR src$GSCopy$1$[rsp]

; 353  :     DTableH->fastMode = 0;

	mov	QWORD PTR [rdi], 0

; 354  : 
; 355  :     cell->nbBits = 0;

	mov	BYTE PTR [rdi+11], 0

; 357  :     assert(nbAddBits < 255);
; 358  :     cell->nbAdditionalBits = (BYTE)nbAddBits;

	mov	BYTE PTR [rdi+10], cl

; 359  :     cell->baseValue = baseValue;

	mov	DWORD PTR [rdi+12], edx

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	lea	rax, QWORD PTR [r9+rsi]

; 450  :         *DTablePtr = DTableSpace;

	mov	QWORD PTR [r11+8], rdi

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	jmp	SHORT $LN268@ZSTD_decod
$LN259@ZSTD_decod:

; 539  :                                                       MLtype, MaxML, MLFSELog,
; 540  :                                                       ip, iend-ip,
; 541  :                                                       ML_base, ML_bits,
; 542  :                                                       ML_defaultDTable, dctx->fseEntropy,
; 543  :                                                       dctx->ddictIsCold, nbSeq);
; 544  :             RETURN_ERROR_IF(ZSTD_isError(mlhSize), corruption_detected, "ZSTD_buildSeqTable failed");

	mov	rax, -20
$LN268@ZSTD_decod:
	mov	r14, QWORD PTR [rsp+608]
	mov	r13, QWORD PTR [rsp+616]
	mov	r12, QWORD PTR [rsp+624]
	mov	rdi, QWORD PTR [rsp+632]
	mov	r15, QWORD PTR [rsp+600]
$LN1@ZSTD_decod:

; 550  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 640				; 00000280H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN145@ZSTD_decod:

; 453  :         *DTablePtr = defaultTable;

	lea	rax, OFFSET FLAT:ML_defaultDTable
	mov	QWORD PTR [r11+8], rax
$LN20@ZSTD_decod:

; 545  :             ip += mlhSize;
; 546  :         }
; 547  :     }
; 548  : 
; 549  :     return ip-istart;

	sub	rsi, QWORD PTR src$GSCopy$1$[rsp]
	lea	rax, QWORD PTR [r9+rsi]
	jmp	SHORT $LN268@ZSTD_decod
$LN263@ZSTD_decod:

; 509  : 
; 510  :     /* FSE table descriptors */
; 511  :     RETURN_ERROR_IF(ip+1 > iend, srcSize_wrong, ""); /* minimum possible size: 1 byte for symbol encoding types */

	mov	rax, -72				; ffffffffffffffb8H
	jmp	SHORT $LN1@ZSTD_decod
ZSTD_decodeSeqHeaders ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
op$ = 8
ip$ = 16
offset$ = 24
ZSTD_overlapCopy8 PROC

; 583  : HINT_INLINE void ZSTD_overlapCopy8(BYTE** op, BYTE const** ip, size_t offset) {

	mov	rax, QWORD PTR [rdx]
	mov	r11, rcx
	mov	rcx, QWORD PTR [rcx]
	mov	r10, rdx

; 584  :     assert(*ip <= *op);
; 585  :     if (offset < 8) {

	cmp	r8, 8
	jae	SHORT $LN2@ZSTD_overl

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR [rdx]
	mov	r9, QWORD PTR [r11]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR [r9+1], al
	mov	rax, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [r11]
	movzx	eax, BYTE PTR [rax+2]
	mov	BYTE PTR [rdx+2], al

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR [r10]
	mov	rcx, QWORD PTR [r11]
	movzx	eax, BYTE PTR [rax+3]
	mov	BYTE PTR [rcx+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rdx+r8*4]
	add	QWORD PTR [r10], rax
	mov	rax, QWORD PTR [r10]

; 595  :         ZSTD_copy4(*op+4, *ip);

	mov	rcx, QWORD PTR [r11]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx+4], eax

; 596  :         *ip -= sub2;

	mov	rcx, QWORD PTR [r10]
	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rdx+r8*4]
	sub	rcx, rax

; 599  :     }
; 600  :     *ip += 8;

	lea	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [r10], rax

; 601  :     *op += 8;

	add	QWORD PTR [r11], 8

; 602  :     assert(*op - *ip >= 8);
; 603  : }

	ret	0
$LN2@ZSTD_overl:

; 597  :     } else {
; 598  :         ZSTD_copy8(*op, *ip);

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR [rdx]

; 599  :     }
; 600  :     *ip += 8;

	lea	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [r10], rax

; 601  :     *op += 8;

	add	QWORD PTR [r11], 8

; 602  :     assert(*op - *ip >= 8);
; 603  : }

	ret	0
ZSTD_overlapCopy8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
op$ = 16
oend_w$ = 24
ip$ = 32
length$ = 40
ovtype$ = 48
ZSTD_safecopy PROC

; 616  : static void ZSTD_safecopy(BYTE* op, BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype) {

	push	rbx
	mov	r11, rdx

; 617  :     ptrdiff_t const diff = op - ip;
; 618  :     BYTE* const oend = op + length;

	lea	r10, QWORD PTR [rcx+r9]
	mov	rdx, rcx
	mov	rbx, r9
	sub	rdx, r8

; 619  : 
; 620  :     assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||
; 621  :            (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));
; 622  : 
; 623  :     if (length < 8) {

	cmp	r9, 8
	jge	SHORT $LN6@ZSTD_safec

; 624  :         /* Handle short lengths. */
; 625  :         while (op < oend) *op++ = *ip++;

	cmp	rcx, r10
	jae	$LN5@ZSTD_safec
	sub	r8, rcx
	npad	12
$LL53@ZSTD_safec:
	movzx	eax, BYTE PTR [r8+rcx]
	mov	BYTE PTR [rcx], al
	inc	rcx
	cmp	rcx, r10
	jb	SHORT $LL53@ZSTD_safec

; 650  : }

	pop	rbx
	ret	0
$LN6@ZSTD_safec:

; 626  :         return;
; 627  :     }
; 628  :     if (ovtype == ZSTD_overlap_src_before_dst) {

	mov	r9d, DWORD PTR ovtype$[rsp]
	cmp	r9d, 1
	jne	SHORT $LN11@ZSTD_safec

; 585  :     if (offset < 8) {

	cmp	rdx, 8
	jae	SHORT $LN12@ZSTD_safec

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx], al

; 591  :         (*op)[1] = (*ip)[1];

	movzx	eax, BYTE PTR [r8+1]
	mov	BYTE PTR [rcx+1], al

; 592  :         (*op)[2] = (*ip)[2];

	movzx	eax, BYTE PTR [r8+2]
	mov	BYTE PTR [rcx+2], al

; 593  :         (*op)[3] = (*ip)[3];

	movzx	eax, BYTE PTR [r8+3]
	mov	BYTE PTR [rcx+3], al
	mov	QWORD PTR [rsp+16], rdi

; 594  :         *ip += dec32table[offset];

	lea	rdi, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rdi+rdx*4]
	add	r8, rax

; 595  :         ZSTD_copy4(*op+4, *ip);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rdi+rdx*4]
	mov	rdi, QWORD PTR [rsp+16]
	sub	r8, rax

; 597  :     } else {

	jmp	SHORT $LN13@ZSTD_safec
$LN12@ZSTD_safec:

; 598  :         ZSTD_copy8(*op, *ip);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
$LN13@ZSTD_safec:

; 599  :     }
; 600  :     *ip += 8;

	add	r8, 8

; 601  :     *op += 8;

	add	rcx, 8
$LN11@ZSTD_safec:

; 629  :         /* Copy 8 bytes and ensure the offset >= 8 when there can be overlap. */
; 630  :         assert(length >= 8);
; 631  :         ZSTD_overlapCopy8(&op, &ip, diff);
; 632  :         assert(op - ip >= 8);
; 633  :         assert(op <= oend);
; 634  :     }
; 635  : 
; 636  :     if (oend <= oend_w) {

	cmp	r10, r11
	ja	SHORT $LN8@ZSTD_safec
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rdx, QWORD PTR [rcx+rbx]

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	r9d, 1
	jne	SHORT $LN67@ZSTD_safec

; 244  : #endif
; 245  : }
; 246  : #define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }
; 247  : 
; 248  : #define WILDCOPY_OVERLENGTH 32
; 249  : #define WILDCOPY_VECLEN 16
; 250  : 
; 251  : typedef enum {
; 252  :     ZSTD_no_overlap,
; 253  :     ZSTD_overlap_src_before_dst
; 254  :     /*  ZSTD_overlap_dst_before_src, */
; 255  : } ZSTD_overlap_e;
; 256  : 
; 257  : /*! ZSTD_wildcopy() :
; 258  :  *  Custom version of memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0)
; 259  :  *  @param ovtype controls the overlap detection
; 260  :  *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
; 261  :  *         - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.
; 262  :  *           The src buffer must be before the dst buffer.
; 263  :  */
; 264  : MEM_STATIC FORCE_INLINE_ATTR 
; 265  : void ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)
; 266  : {
; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	rax, rcx
	sub	rax, r8

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rax, 16
	jge	SHORT $LN67@ZSTD_safec

; 244  : #endif
; 245  : }
; 246  : #define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }
; 247  : 
; 248  : #define WILDCOPY_OVERLENGTH 32
; 249  : #define WILDCOPY_VECLEN 16
; 250  : 
; 251  : typedef enum {
; 252  :     ZSTD_no_overlap,
; 253  :     ZSTD_overlap_src_before_dst
; 254  :     /*  ZSTD_overlap_dst_before_src, */
; 255  : } ZSTD_overlap_e;
; 256  : 
; 257  : /*! ZSTD_wildcopy() :
; 258  :  *  Custom version of memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0)
; 259  :  *  @param ovtype controls the overlap detection
; 260  :  *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
; 261  :  *         - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.
; 262  :  *           The src buffer must be before the dst buffer.
; 263  :  */
; 264  : MEM_STATIC FORCE_INLINE_ATTR 
; 265  : void ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)
; 266  : {
; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	sub	r8, rcx
	npad	6
$LL18@ZSTD_safec:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rax, QWORD PTR [r8+rcx]
	mov	QWORD PTR [rcx], rax
	add	rcx, 8

; 278  :         } while (op < oend);

	cmp	rcx, rdx
	jb	SHORT $LL18@ZSTD_safec
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 650  : }

	pop	rbx
	ret	0
$LN67@ZSTD_safec:
	sub	r8, rcx
	npad	11
$LL21@ZSTD_safec:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rdx
	jb	SHORT $LL21@ZSTD_safec
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 650  : }

	pop	rbx
	ret	0
$LN8@ZSTD_safec:

; 637  :         /* No risk of overwrite. */
; 638  :         ZSTD_wildcopy(op, ip, length, ovtype);
; 639  :         return;
; 640  :     }
; 641  :     if (op <= oend_w) {

	cmp	rcx, r11
	ja	SHORT $LN44@ZSTD_safec
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 269  :     BYTE* op = (BYTE*)dst;

	mov	rdx, rcx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	r9d, 1
	jne	SHORT $LN69@ZSTD_safec

; 244  : #endif
; 245  : }
; 246  : #define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }
; 247  : 
; 248  : #define WILDCOPY_OVERLENGTH 32
; 249  : #define WILDCOPY_VECLEN 16
; 250  : 
; 251  : typedef enum {
; 252  :     ZSTD_no_overlap,
; 253  :     ZSTD_overlap_src_before_dst
; 254  :     /*  ZSTD_overlap_dst_before_src, */
; 255  : } ZSTD_overlap_e;
; 256  : 
; 257  : /*! ZSTD_wildcopy() :
; 258  :  *  Custom version of memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0)
; 259  :  *  @param ovtype controls the overlap detection
; 260  :  *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
; 261  :  *         - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.
; 262  :  *           The src buffer must be before the dst buffer.
; 263  :  */
; 264  : MEM_STATIC FORCE_INLINE_ATTR 
; 265  : void ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)
; 266  : {
; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	rax, rcx
	sub	rax, r8

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rax, 16
	jge	SHORT $LN69@ZSTD_safec

; 244  : #endif
; 245  : }
; 246  : #define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }
; 247  : 
; 248  : #define WILDCOPY_OVERLENGTH 32
; 249  : #define WILDCOPY_VECLEN 16
; 250  : 
; 251  : typedef enum {
; 252  :     ZSTD_no_overlap,
; 253  :     ZSTD_overlap_src_before_dst
; 254  :     /*  ZSTD_overlap_dst_before_src, */
; 255  : } ZSTD_overlap_e;
; 256  : 
; 257  : /*! ZSTD_wildcopy() :
; 258  :  *  Custom version of memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0)
; 259  :  *  @param ovtype controls the overlap detection
; 260  :  *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
; 261  :  *         - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.
; 262  :  *           The src buffer must be before the dst buffer.
; 263  :  */
; 264  : MEM_STATIC FORCE_INLINE_ATTR 
; 265  : void ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)
; 266  : {
; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	r9, r8
	sub	r9, rcx
	npad	13
$LL30@ZSTD_safec:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rax, QWORD PTR [r9+rdx]
	mov	QWORD PTR [rdx], rax
	add	rdx, 8

; 278  :         } while (op < oend);

	cmp	rdx, r11
	jb	SHORT $LL30@ZSTD_safec

; 279  :     } else {

	jmp	SHORT $LN32@ZSTD_safec
$LN69@ZSTD_safec:
	mov	rax, r8
	sub	rax, rcx
	npad	8
$LL33@ZSTD_safec:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rax+rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 289  :             COPY16(op, ip);

	add	rdx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdx, r11
	jb	SHORT $LL33@ZSTD_safec
$LN32@ZSTD_safec:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 645  :         ip += oend_w - op;

	mov	rax, r11
	sub	rax, rcx

; 646  :         op = oend_w;

	mov	rcx, r11
	add	r8, rax
$LN44@ZSTD_safec:

; 647  :     }
; 648  :     /* Handle the leftovers. */
; 649  :     while (op < oend) *op++ = *ip++;

	cmp	rcx, r10
	jae	SHORT $LN5@ZSTD_safec
	npad	15
$LL55@ZSTD_safec:
	movzx	eax, BYTE PTR [r8]
	lea	r8, QWORD PTR [r8+1]
	mov	BYTE PTR [rcx], al
	inc	rcx
	cmp	rcx, r10
	jb	SHORT $LL55@ZSTD_safec
$LN5@ZSTD_safec:

; 650  : }

	pop	rbx
	ret	0
ZSTD_safecopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
op$ = 80
oend$ = 88
sequence$ = 96
litPtr$ = 104
litLimit$ = 112
prefixStart$ = 120
virtualStart$ = 128
dictEnd$ = 136
ZSTD_execSequenceEnd PROC

; 665  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 666  :     BYTE* const oLitEnd = op + sequence.litLength;

	mov	rdi, QWORD PTR [r8]

; 667  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 668  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;
; 669  :     const BYTE* match = oLitEnd - sequence.offset;
; 670  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;

	lea	rsi, QWORD PTR [rdx-32]
	mov	r14, QWORD PTR [r8+8]
	mov	r15, r8
	mov	r10, QWORD PTR [r9]

; 671  : 
; 672  :     /* bounds checks : careful of address space overflow in 32-bit mode */
; 673  :     RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, "last match must fit within dstBuffer");

	sub	rdx, rcx
	mov	r8, QWORD PTR [r8+16]
	lea	rbx, QWORD PTR [rdi+rcx]
	mov	r11, rbx
	lea	r12, QWORD PTR [r14+rdi]
	sub	r11, r8
	lea	rbp, QWORD PTR [r10+rdi]
	cmp	r12, rdx
	jbe	SHORT $LN2@ZSTD_execS
	mov	rax, -70				; ffffffffffffffbaH
	jmp	$LN1@ZSTD_execS
$LN2@ZSTD_execS:

; 674  :     RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, "try to read beyond literal buffer");

	mov	rax, QWORD PTR litLimit$[rsp]
	sub	rax, r10
	cmp	rdi, rax
	ja	$LN69@ZSTD_execS

; 623  :     if (length < 8) {

	cmp	rdi, 8
	jge	SHORT $LN16@ZSTD_execS

; 624  :         /* Handle short lengths. */
; 625  :         while (op < oend) *op++ = *ip++;

	cmp	rcx, rbx
	jae	SHORT $LN15@ZSTD_execS
	sub	r10, rcx
	npad	8
$LL55@ZSTD_execS:
	movzx	eax, BYTE PTR [r10+rcx]
	mov	BYTE PTR [rcx], al
	inc	rcx
	cmp	rcx, rbx
	jb	SHORT $LL55@ZSTD_execS

; 626  :         return;

	jmp	SHORT $LN15@ZSTD_execS
$LN16@ZSTD_execS:

; 627  :     }
; 628  :     if (ovtype == ZSTD_overlap_src_before_dst) {
; 629  :         /* Copy 8 bytes and ensure the offset >= 8 when there can be overlap. */
; 630  :         assert(length >= 8);
; 631  :         ZSTD_overlapCopy8(&op, &ip, diff);
; 632  :         assert(op - ip >= 8);
; 633  :         assert(op <= oend);
; 634  :     }
; 635  : 
; 636  :     if (oend <= oend_w) {

	cmp	rbx, rsi
	ja	SHORT $LN18@ZSTD_execS
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 269  :     BYTE* op = (BYTE*)dst;

	sub	r10, rcx
	npad	7
$LL31@ZSTD_execS:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rbx
	jb	SHORT $LL31@ZSTD_execS
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 639  :         return;

	jmp	SHORT $LN15@ZSTD_execS
$LN18@ZSTD_execS:

; 640  :     }
; 641  :     if (op <= oend_w) {

	cmp	rcx, rsi
	ja	SHORT $LN52@ZSTD_execS
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 269  :     BYTE* op = (BYTE*)dst;

	sub	r10, rcx
	npad	5
$LL43@ZSTD_execS:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rsi
	jb	SHORT $LL43@ZSTD_execS
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 646  :         op = oend_w;

	add	r10, rsi
	mov	rcx, rsi
$LN52@ZSTD_execS:

; 647  :     }
; 648  :     /* Handle the leftovers. */
; 649  :     while (op < oend) *op++ = *ip++;

	cmp	rcx, rbx
	jae	SHORT $LN15@ZSTD_execS
	npad	4
$LL57@ZSTD_execS:
	movzx	eax, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	mov	BYTE PTR [rcx], al
	inc	rcx
	cmp	rcx, rbx
	jb	SHORT $LL57@ZSTD_execS
$LN15@ZSTD_execS:

; 675  :     assert(op < op + sequenceLength);
; 676  :     assert(oLitEnd < op + sequenceLength);
; 677  : 
; 678  :     /* copy literals */
; 679  :     ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);
; 680  :     op = oLitEnd;
; 681  :     *litPtr = iLitEnd;

	mov	QWORD PTR [r9], rbp

; 682  : 
; 683  :     /* copy Match */
; 684  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	rax, rbx
	mov	rbp, QWORD PTR prefixStart$[rsp]
	sub	rax, rbp
	cmp	r8, rax
	jbe	SHORT $LN68@ZSTD_execS

; 685  :         /* offset beyond prefix */
; 686  :         RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, "");

	mov	rax, rbx
	sub	rax, QWORD PTR virtualStart$[rsp]
	cmp	r8, rax
	ja	SHORT $LN69@ZSTD_execS

; 687  :         match = dictEnd - (prefixStart-match);

	mov	rdi, QWORD PTR dictEnd$[rsp]
	mov	rcx, rdi
	sub	rcx, rbp
	add	r11, rcx

; 688  :         if (match + sequence.matchLength <= dictEnd) {

	mov	rdx, r11
	lea	rcx, QWORD PTR [r14+r11]
	cmp	rcx, rdi
	mov	rcx, rbx
	ja	SHORT $LN9@ZSTD_execS

; 689  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r14
	call	memmove

; 690  :             return sequenceLength;

	mov	rax, r12
	jmp	SHORT $LN1@ZSTD_execS
$LN9@ZSTD_execS:

; 691  :         }
; 692  :         /* span extDict & currentPrefixSegment */
; 693  :         {   size_t const length1 = dictEnd - match;

	sub	rdi, r11

; 694  :             memmove(oLitEnd, match, length1);

	mov	r8, rdi
	call	memmove

; 695  :             op = oLitEnd + length1;

	add	rbx, rdi

; 696  :             sequence.matchLength -= length1;
; 697  :             match = prefixStart;

	mov	r11, rbp
	sub	r14, rdi
	mov	QWORD PTR [r15+8], r14
$LN68@ZSTD_execS:

; 698  :     }   }
; 699  :     ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);

	mov	r9, QWORD PTR [r15+8]
	mov	r8, r11
	mov	rdx, rsi
	mov	DWORD PTR [rsp+32], 1
	mov	rcx, rbx
	call	ZSTD_safecopy

; 700  :     return sequenceLength;

	mov	rax, r12
	jmp	SHORT $LN1@ZSTD_execS
$LN69@ZSTD_execS:

; 685  :         /* offset beyond prefix */
; 686  :         RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, "");

	mov	rax, -20
$LN1@ZSTD_execS:

; 701  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
ZSTD_execSequenceEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
$T1 = 64
op$ = 144
oend$ = 152
sequence$ = 160
litPtr$ = 168
litLimit$ = 176
prefixStart$ = 184
virtualStart$ = 192
dictEnd$ = 200
ZSTD_execSequence PROC

; 708  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	mov	r10, QWORD PTR [r9]
	mov	r14, r8
	mov	r8, QWORD PTR [r8]
	mov	rsi, rdx
	mov	rbp, r9
	mov	r11, rcx

; 714  :     const BYTE* match = oLitEnd - sequence.offset;
; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	mov	r9, QWORD PTR litLimit$[rsp]
	mov	r15, QWORD PTR [r14+8]
	mov	rdi, QWORD PTR [r14+16]
	lea	rbx, QWORD PTR [r8+rcx]
	mov	rdx, rbx
	lea	r13, QWORD PTR [r10+r8]
	sub	rdx, rdi
	lea	r12, QWORD PTR [r15+r8]
	cmp	r13, r9
	ja	$LN3@ZSTD_execS

; 709  :     BYTE* const oLitEnd = op + sequence.litLength;
; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */
; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rcx, r12
	lea	rax, QWORD PTR [rsi-32]

; 714  :     const BYTE* match = oLitEnd - sequence.offset;
; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN3@ZSTD_execS
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10]
	movups	XMMWORD PTR [r11], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r8, 16
	jbe	SHORT $LN19@ZSTD_execS

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	lea	rax, QWORD PTR [r11+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 268  :     const BYTE* ip = (const BYTE*)src;

	sub	r10, r11
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	lea	rcx, QWORD PTR [r8-16]
	add	rcx, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 268  :     const BYTE* ip = (const BYTE*)src;

	add	r10, rax
	npad	8
$LL20@ZSTD_execS:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10]

; 289  :             COPY16(op, ip);

	lea	r10, QWORD PTR [r10+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL20@ZSTD_execS
$LN19@ZSTD_execS:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 747  :     *litPtr = iLitEnd;   /* update for next sequence */

	mov	QWORD PTR [rbp], r13

; 748  : 
; 749  :     /* Copy Match */
; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	rax, rbx
	mov	rbp, QWORD PTR prefixStart$[rsp]
	sub	rax, rbp
	cmp	rdi, rax
	jbe	SHORT $LN71@ZSTD_execS

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rbx
	sub	rax, QWORD PTR virtualStart$[rsp]
	cmp	rdi, rax
	jbe	SHORT $LN6@ZSTD_execS
	mov	rax, -20
	jmp	$LN1@ZSTD_execS
$LN6@ZSTD_execS:

; 753  :         match = dictEnd + (match - prefixStart);

	mov	rsi, QWORD PTR dictEnd$[rsp]

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	mov	rcx, rbx
	mov	r9, rsi
	sub	r9, rbp
	add	rdx, r9
	lea	r9, QWORD PTR [r15+rdx]
	cmp	r9, rsi
	ja	SHORT $LN8@ZSTD_execS

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r15
	call	memmove

; 756  :             return sequenceLength;

	mov	rax, r12
	jmp	$LN1@ZSTD_execS
$LN8@ZSTD_execS:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	sub	rsi, rdx

; 760  :             memmove(oLitEnd, match, length1);

	mov	r8, rsi
	call	memmove

; 761  :             op = oLitEnd + length1;

	add	rbx, rsi

; 762  :             sequence.matchLength -= length1;
; 763  :             match = prefixStart;

	mov	rdx, rbp
	sub	r15, rsi
	mov	QWORD PTR [r14+8], r15
$LN71@ZSTD_execS:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	cmp	rdi, 16
	jb	SHORT $LN9@ZSTD_execS
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rcx, QWORD PTR [r14+8]
	add	rcx, rbx
	sub	rdx, rbx
	npad	4
$LL32@ZSTD_execS:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rbx]
	movups	XMMWORD PTR [rbx], xmm0

; 289  :             COPY16(op, ip);

	add	rbx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rbx, rcx
	jb	SHORT $LL32@ZSTD_execS
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	mov	rax, r12
	jmp	$LN1@ZSTD_execS
$LN9@ZSTD_execS:

; 585  :     if (offset < 8) {

	cmp	rdi, 8
	jae	SHORT $LN39@ZSTD_execS

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rbx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rbx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rbx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rbx+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rcx+rdi*4]
	add	rdx, rax

; 595  :         ZSTD_copy4(*op+4, *ip);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rbx+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rcx+rdi*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN40@ZSTD_execS
$LN39@ZSTD_execS:

; 598  :         ZSTD_copy8(*op, *ip);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rbx], rax
$LN40@ZSTD_execS:

; 781  :     }
; 782  :     assert(sequence.offset < WILDCOPY_VECLEN);
; 783  : 
; 784  :     /* Copy 8 bytes and spread the offset to be >= 8. */
; 785  :     ZSTD_overlapCopy8(&op, &match, sequence.offset);
; 786  : 
; 787  :     /* If the match length is > 8 bytes, then continue with the wildcopy. */
; 788  :     if (sequence.matchLength > 8) {

	mov	rcx, QWORD PTR [r14+8]
	cmp	rcx, 8
	jbe	SHORT $LN47@ZSTD_execS

; 600  :     *ip += 8;

	add	rdx, 8

; 601  :     *op += 8;

	lea	rax, QWORD PTR [rbx+8]

; 790  :         ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength-8, ZSTD_overlap_src_before_dst);

	lea	r9, QWORD PTR [rcx-8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	r8, rdx
	mov	rcx, rax
	sub	r8, rax
	sub	rcx, rdx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 790  :         ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength-8, ZSTD_overlap_src_before_dst);

	add	r9, rax
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rcx, 16
	jge	SHORT $LL48@ZSTD_execS
	npad	4
$LL45@ZSTD_execS:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rcx, QWORD PTR [r8+rax]
	mov	QWORD PTR [rax], rcx
	add	rax, 8

; 278  :         } while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL45@ZSTD_execS
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	rax, r12
	jmp	SHORT $LN1@ZSTD_execS
	npad	11
$LL48@ZSTD_execS:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+rax]
	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL48@ZSTD_execS
$LN47@ZSTD_execS:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	rax, r12
	jmp	SHORT $LN1@ZSTD_execS
$LN3@ZSTD_execS:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	mov	rax, QWORD PTR dictEnd$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	movaps	xmm0, XMMWORD PTR [r14]
	mov	rdx, rsi
	movaps	xmm1, XMMWORD PTR [r14+16]
	mov	rcx, r11
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR virtualStart$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r9
	mov	r9, rbp
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	XMMWORD PTR $T1[rsp+16], xmm1
	call	ZSTD_execSequenceEnd
$LN1@ZSTD_execS:

; 793  : }

	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
ZSTD_execSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
DStatePtr$ = 48
bitD$ = 56
dt$ = 64
ZSTD_initFseState PROC

; 797  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 798  :     const void* ptr = dt;
; 799  :     const ZSTD_seqSymbol_header* const DTableH = (const ZSTD_seqSymbol_header*)ptr;
; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	r10d, DWORD PTR [r8+4]
	mov	rbx, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rdx+8], r10d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 797  : {

	mov	rdi, r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	ecx, DWORD PTR [rdx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r9, QWORD PTR [rdx]
	neg	ecx
	and	ecx, 63					; 0000003fH
	shr	r9, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+r10*4]
	and	r9, rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	mov	rcx, rdx
	mov	QWORD PTR [rbx], r9
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 805  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_initFseState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
DStatePtr$ = 8
bitD$ = 16
ZSTD_updateFseState PROC

; 810  :     ZSTD_seqSymbol const DInfo = DStatePtr->table[DStatePtr->state];

	mov	r8, QWORD PTR [rcx]
	mov	r10, rcx
	mov	rax, QWORD PTR [rcx+8]
	mov	r9, QWORD PTR [rax+r8*8]
	mov	rax, r9
	shr	rax, 24
	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rdx+8], r8d
	mov	ecx, DWORD PTR [rdx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	rdx, QWORD PTR [rdx]
	neg	ecx
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	movzx	eax, r9w

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	rdx, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+r8*4]
	and	rdx, rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 813  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	rdx, rax
	mov	QWORD PTR [r10], rdx

; 814  : }

	ret	0
ZSTD_updateFseState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
DStatePtr$ = 8
bitD$ = 16
DInfo$ = 24
ZSTD_updateFseStateWithDInfo PROC

; 818  : {

	mov	r10, rcx

; 819  :     U32 const nbBits = DInfo.nbBits;

	mov	rax, r8
	shr	rax, 24
	movzx	r9d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	DWORD PTR [rdx+8], r9d
	mov	ecx, DWORD PTR [rdx+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	rdx, QWORD PTR [rdx]
	neg	ecx
	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, r8w
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	rdx, cl
	lea	rcx, OFFSET FLAT:BIT_mask
	mov	ecx, DWORD PTR [rcx+r9*4]
	and	rdx, rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	rdx, rax
	mov	QWORD PTR [r10], rdx

; 822  : }

	ret	0
ZSTD_updateFseStateWithDInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
mlDInfo$ = 32
ofDInfo$ = 40
tv1528 = 112
$T1 = 112
llDInfo$ = 120
seqState$ = 120
longOffsets$dead$ = 128
prefetch$ = 136
ZSTD_decodeSequence PROC

; 839  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	DWORD PTR [rsp+32], r9d
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 840  :     seq_t seq;
; 841  :     ZSTD_seqSymbol const llDInfo = seqState->stateLL.table[seqState->stateLL.state];

	mov	rax, QWORD PTR [rdx+40]
	mov	r14, rdx
	mov	rbx, QWORD PTR [rdx+48]
	mov	r15, rcx

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rdi, QWORD PTR [rdx+80]

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rsi, QWORD PTR [rdx+64]
	mov	rbx, QWORD PTR [rbx+rax*8]
	mov	rax, QWORD PTR [rdx+72]
	mov	r12, rbx
	shr	r12, 16
	mov	rbp, rbx
	shr	rbp, 32					; 00000020H
	mov	QWORD PTR llDInfo$[rsp], rbx
	mov	rdi, QWORD PTR [rdi+rax*8]
	mov	rax, rdi
	mov	QWORD PTR mlDInfo$[rsp], rdi
	shr	rax, 32					; 00000020H
	mov	r9, rdi
	mov	QWORD PTR tv1528[rsp], rax
	mov	rax, QWORD PTR [rdx+56]
	shr	r9, 16
	mov	rsi, QWORD PTR [rsi+rax*8]
	mov	rax, rsi
	mov	QWORD PTR ofDInfo$[rsp], rsi
	shr	rax, 16
	mov	r11, rsi
	shr	r11, 32					; 00000020H

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;

	lea	r13d, DWORD PTR [r9+rax]
	add	r13b, r12b

; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	cmp	al, 1
	jbe	SHORT $LN2@ZSTD_decod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [r14+8]
	mov	r8, QWORD PTR [r14]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	edx, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+rdx]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [r14+8], eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	neg	edx

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	rax, QWORD PTR [r14+96]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	shl	r8, cl
	movzx	ecx, dl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	QWORD PTR [r14+104], rax

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR [r14+88]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r8, r11

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR [r14+96], rax

; 870  :             seqState->prevOffset[0] = offset;
; 871  :         } else {

	jmp	$LN130@ZSTD_decod
$LN2@ZSTD_decod:

; 872  :             U32 const ll0 = (llBase == 0);

	xor	r8d, r8d
	test	ebp, ebp
	mov	r10d, r8d
	sete	r10b

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN8@ZSTD_decod

; 874  :                 if (LIKELY(!ll0))

	mov	rax, QWORD PTR [rdx+88]
	test	ebp, ebp
	je	SHORT $LN10@ZSTD_decod

; 875  :                     offset = seqState->prevOffset[0];

	mov	r8, rax
	jmp	SHORT $LN9@ZSTD_decod
$LN10@ZSTD_decod:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];

	mov	r8, QWORD PTR [rdx+96]

; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];
; 879  :                     seqState->prevOffset[0] = offset;

	mov	QWORD PTR [rdx+88], r8
	mov	QWORD PTR [rdx+96], rax

; 880  :                 }
; 881  :             } else {

	jmp	SHORT $LN9@ZSTD_decod
$LN8@ZSTD_decod:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [rdx+8]

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+1]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [rdx+8], eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, QWORD PTR [rdx]
	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	lea	ecx, DWORD PTR [r11+r10]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	add	rdx, rcx

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	mov	rcx, QWORD PTR [r14+88]
	cmp	rdx, 3
	jne	SHORT $LN26@ZSTD_decod
	lea	rax, QWORD PTR [rcx-1]
	test	rax, rax
	sete	r8b
	add	r8, rax
	jmp	SHORT $LN129@ZSTD_decod
$LN26@ZSTD_decod:
	mov	rax, QWORD PTR [r14+rdx*8+88]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r8b
	add	r8, rax

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rdx, 1
	je	SHORT $LN12@ZSTD_decod
$LN129@ZSTD_decod:
	mov	rax, QWORD PTR [r14+96]
	mov	QWORD PTR [r14+104], rax
$LN12@ZSTD_decod:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR [r14+96], rcx
$LN130@ZSTD_decod:

; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	QWORD PTR [r14+88], r8
$LN9@ZSTD_decod:
	mov	QWORD PTR [r15+16], r8

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	r8, QWORD PTR tv1528[rsp]
	mov	QWORD PTR [r15+8], r8

; 893  :     if (mlBits > 0)

	test	r9b, r9b
	je	SHORT $LN128@ZSTD_decod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [r14+8]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+rdx]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [r14+8], eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	neg	edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, QWORD PTR [r14]
	and	edx, 63					; 0000003fH
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	add	rax, r8
	mov	QWORD PTR [r15+8], rax
$LN128@ZSTD_decod:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	r13b, 31
	jb	SHORT $LN15@ZSTD_decod

; 899  :         BIT_reloadDStream(&seqState->DStream);

	mov	rcx, r14
	call	BIT_reloadDStream
$LN15@ZSTD_decod:

; 900  :     /* Ensure there are enough bits to read the rest of data in 64-bit mode. */
; 901  :     ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);
; 902  : 
; 903  :     seq.litLength = llBase;

	mov	QWORD PTR [r15], rbp
	mov	r8, rbp

; 904  :     if (llBits > 0)

	test	r12b, r12b
	je	SHORT $LN127@ZSTD_decod
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, DWORD PTR [r14+8]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	edx, r12b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	eax, DWORD PTR [rcx+rdx]

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [r14+8], eax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	neg	edx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, QWORD PTR [r14]
	and	edx, 63					; 0000003fH
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	add	r8, rax
	mov	QWORD PTR [r15], r8
$LN127@ZSTD_decod:

; 906  : 
; 907  :     if (MEM_32bits())
; 908  :         BIT_reloadDStream(&seqState->DStream);
; 909  : 
; 910  :     DEBUGLOG(6, "seq: litL=%u, matchL=%u, offset=%u",
; 911  :                 (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);
; 912  : 
; 913  :     if (prefetch == ZSTD_p_prefetch) {

	cmp	DWORD PTR prefetch$[rsp], 1
	jne	SHORT $LN18@ZSTD_decod

; 914  :         size_t const pos = seqState->pos + seq.litLength;

	mov	rcx, QWORD PTR [r14+128]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	mov	rdx, QWORD PTR [r15+16]
	add	rcx, r8
	cmp	rdx, rcx
	jbe	SHORT $LN28@ZSTD_decod
	mov	rax, QWORD PTR [r14+120]
	jmp	SHORT $LN29@ZSTD_decod
$LN28@ZSTD_decod:
	mov	rax, QWORD PTR [r14+112]
$LN29@ZSTD_decod:

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	sub	rax, rdx
	add	rax, rcx

; 917  :                                                     * No consequence though : no memory access will occur, offset is only used for prefetching */
; 918  :         seqState->pos = pos + seq.matchLength;

	add	rcx, QWORD PTR [r15+8]
	mov	QWORD PTR [r14+128], rcx
	mov	QWORD PTR [r15+24], rax
$LN18@ZSTD_decod:

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$[rsp+3]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	r11, OFFSET FLAT:BIT_mask
	mov	r10, QWORD PTR [r14]

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR [r14+8]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r10

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR [r11+rdx*4]
	mov	ecx, r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$[rsp+3]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	and	ecx, 63					; 0000003fH

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	r8, cl
	mov	ecx, r9d
	and	r8, rax
	neg	ecx
	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, bx
	add	r8, rax
	movzx	eax, di
	mov	QWORD PTR [r14+40], r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r10
	shr	r8, cl
	mov	ecx, DWORD PTR [r11+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$[rsp+3]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	r8, rax
	mov	QWORD PTR [r14+72], r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	lea	eax, DWORD PTR [r9+rdx]

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR [r14+8], eax

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	eax
	and	eax, 63					; 0000003fH
	movzx	ecx, al
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, si
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	r10, cl
	mov	ecx, DWORD PTR [r11+rdx*4]
	and	r10, rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	r10, rax

; 919  :     }
; 920  : 
; 921  :     /* ANS state update
; 922  :      * gcc-9.0.0 does 2.5% worse with ZSTD_updateFseStateWithDInfo().
; 923  :      * clang-9.2.0 does 7% worse with ZSTD_updateFseState().
; 924  :      * Naturally it seems like ZSTD_updateFseStateWithDInfo() should be the
; 925  :      * better option, so it is the default for other compilers. But, if you
; 926  :      * measure that it is worse, please put up a pull request.
; 927  :      */
; 928  :     {
; 929  : #if defined(__GNUC__) && !defined(__clang__)
; 930  :         const int kUseUpdateFseState = 1;
; 931  : #else
; 932  :         const int kUseUpdateFseState = 0;
; 933  : #endif
; 934  :         if (kUseUpdateFseState) {
; 935  :             ZSTD_updateFseState(&seqState->stateLL, &seqState->DStream);    /* <=  9 bits */
; 936  :             ZSTD_updateFseState(&seqState->stateML, &seqState->DStream);    /* <=  9 bits */
; 937  :             if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);    /* <= 18 bits */
; 938  :             ZSTD_updateFseState(&seqState->stateOffb, &seqState->DStream);  /* <=  8 bits */
; 939  :         } else {
; 940  :             ZSTD_updateFseStateWithDInfo(&seqState->stateLL, &seqState->DStream, llDInfo);    /* <=  9 bits */
; 941  :             ZSTD_updateFseStateWithDInfo(&seqState->stateML, &seqState->DStream, mlDInfo);    /* <=  9 bits */
; 942  :             if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);    /* <= 18 bits */
; 943  :             ZSTD_updateFseStateWithDInfo(&seqState->stateOffb, &seqState->DStream, ofDInfo);  /* <=  8 bits */
; 944  :         }
; 945  :     }
; 946  : 
; 947  :     return seq;

	mov	rax, r15
	mov	QWORD PTR [r14+56], r10

; 948  : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_decodeSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
totalBits$1$ = 64
litPtr$1$ = 72
prefixStart$1$ = 80
litPtr$ = 88
op$1$ = 96
oend$1$ = 104
seqState$3$ = 112
llDInfo$1 = 112
seqState$5$ = 120
mlDInfo$2 = 120
seqState$4$ = 128
ofDInfo$3 = 128
dictEnd$1$ = 136
vBase$1$ = 144
error$1$ = 152
lastLLSize$1$ = 160
tv2507 = 168
tv2509 = 176
dctx$GSCopy$1$ = 184
dst$GSCopy$1$ = 192
$T4 = 200
$T5 = 240
$T6 = 272
seqState$7 = 304
__$ArrayPad$ = 448
dctx$ = 544
dst$ = 552
maxDstSize$ = 560
seqStart$ = 568
seqSize$ = 576
nbSeq$ = 584
isLongOffset$dead$ = 592
frame$dead$ = 600
ZSTD_decompressSequences_body PROC

; 1000 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-232]
	sub	rsp, 488				; 000001e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r10, QWORD PTR seqSize$[rbp-256]
	mov	rsi, rcx
	mov	QWORD PTR dctx$GSCopy$1$[rbp-256], rcx
	mov	r15, rdx

; 1001 :     const BYTE* ip = (const BYTE*)seqStart;
; 1002 :     const BYTE* const iend = ip + seqSize;
; 1003 :     BYTE* const ostart = (BYTE* const)dst;
; 1004 :     BYTE* const oend = ostart + maxDstSize;

	lea	rcx, QWORD PTR [rdx+r8]
	mov	QWORD PTR dst$GSCopy$1$[rbp-256], rdx
	mov	QWORD PTR oend$1$[rsp], rcx

; 1005 :     BYTE* op = ostart;

	mov	rbx, rdx

; 1006 :     const BYTE* litPtr = dctx->litPtr;

	mov	rdi, QWORD PTR [rsi+28952]

; 1007 :     const BYTE* const litEnd = litPtr + dctx->litSize;
; 1008 :     const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);

	mov	rax, QWORD PTR [rsi+28752]
	mov	r14, QWORD PTR [rsi+28984]
	mov	QWORD PTR prefixStart$1$[rsp], rax
	add	r14, rdi

; 1009 :     const BYTE* const vBase = (const BYTE*) (dctx->virtualStart);
; 1010 :     const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);
; 1011 :     DEBUGLOG(5, "ZSTD_decompressSequences_body");
; 1012 :     (void)frame;
; 1013 : 
; 1014 :     /* Regen sequences */
; 1015 :     if (nbSeq) {

	cmp	DWORD PTR nbSeq$[rbp-256], 0
	mov	rax, QWORD PTR [rsi+28760]
	mov	QWORD PTR vBase$1$[rbp-256], rax
	mov	rax, QWORD PTR [rsi+28768]
	mov	QWORD PTR dictEnd$1$[rbp-256], rax
	mov	QWORD PTR op$1$[rsp], rdx
	mov	QWORD PTR litPtr$1$[rsp], rdi
	mov	QWORD PTR litPtr$[rsp], rdi
	mov	QWORD PTR lastLLSize$1$[rbp-256], r14
	je	$LN9@ZSTD_decom

; 1016 :         seqState_t seqState;
; 1017 :         size_t error = 0;
; 1018 :         dctx->fseEntropy = 1;

	mov	DWORD PTR [rsi+28844], 1

; 1020 :         RETURN_ERROR_IF(

	lea	rcx, QWORD PTR seqState$7[rbp-256]
	mov	eax, DWORD PTR [rsi+26684]
	mov	r8, r10
	mov	QWORD PTR seqState$7[rbp-168], rax
	mov	rdx, r9
	mov	eax, DWORD PTR [rsi+26688]
	mov	QWORD PTR seqState$7[rbp-160], rax
	mov	eax, DWORD PTR [rsi+26692]
	mov	QWORD PTR seqState$7[rbp-152], rax
	mov	QWORD PTR error$1$[rbp-256], 0
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1020 :         RETURN_ERROR_IF(

	ja	$LN292@ZSTD_decom
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR seqState$7[rbp-248]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rdi, OFFSET FLAT:__ImageBase
	mov	r8, QWORD PTR seqState$7[rbp-256]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1023 :         ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);

	mov	rbx, QWORD PTR [rsi]
	mov	QWORD PTR [rsp+480], r12
	mov	QWORD PTR [rsp+472], r13

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	edx, DWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$7[rbp-248], r9d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	eax, DWORD PTR BIT_mask[rdi+rdx*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$7[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	QWORD PTR seqState$7[rbp-216], r8

; 803  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR seqState$7[rbp-248]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, QWORD PTR seqState$7[rbp-256]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1024 :         ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);

	mov	rbx, QWORD PTR [rsi+16]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$7[rbp-208], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	edx, DWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$7[rbp-248], r9d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	eax, DWORD PTR BIT_mask[rdi+rdx*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$7[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	QWORD PTR seqState$7[rbp-200], r8

; 803  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR seqState$7[rbp-248]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, QWORD PTR seqState$7[rbp-256]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1025 :         ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);

	mov	rbx, QWORD PTR [rsi+8]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$7[rbp-192], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	edx, DWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$7[rbp-248], r9d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	eax, DWORD PTR BIT_mask[rdi+rdx*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$7[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	QWORD PTR seqState$7[rbp-184], r8

; 803  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	mov	rdi, QWORD PTR seqState$7[rbp-184]
	lea	r8, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR seqState$7[rbp-200]
	mov	rcx, QWORD PTR seqState$7[rbp-216]
	mov	r13, QWORD PTR seqState$7[rbp-240]
	mov	r14d, DWORD PTR seqState$7[rbp-248]
	mov	QWORD PTR seqState$7[rbp-176], r8

; 1091 :             if (UNLIKELY(!--nbSeq)) break;

	jmp	SHORT $LN5@ZSTD_decom
	npad	2
$LL300@ZSTD_decom:
	mov	rdi, QWORD PTR seqState$5$[rsp]
$LN5@ZSTD_decom:

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rdi, QWORD PTR [r8+rdi*8]

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rsi, QWORD PTR seqState$7[rbp-192]
	mov	r10, rdi
	mov	rbx, QWORD PTR seqState$7[rbp-208]
	mov	r12, rdi

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;
; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	mov	r9, QWORD PTR seqState$7[rbp-256]
	shr	r10, 16
	mov	rsi, QWORD PTR [rsi+rax*8]
	mov	rbx, QWORD PTR [rbx+rcx*8]
	mov	rax, rsi
	shr	rax, 16
	mov	rdx, rbx
	shr	rdx, 16
	mov	rcx, rbx
	shr	rcx, 32					; 00000020H
	mov	r11, rsi
	shr	r12, 32					; 00000020H
	lea	r8d, DWORD PTR [r10+rax]
	shr	r11, 32					; 00000020H
	add	r8b, dl
	mov	QWORD PTR llDInfo$1[rsp], rbx
	mov	QWORD PTR tv2509[rbp-256], rdx
	mov	QWORD PTR tv2507[rbp-256], rcx
	mov	QWORD PTR mlDInfo$2[rsp], rdi
	mov	QWORD PTR ofDInfo$3[rbp-256], rsi
	mov	BYTE PTR totalBits$1$[rsp], r8b
	cmp	al, 1
	jbe	SHORT $LN59@ZSTD_decom

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, r8d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r15, r9

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$7[rbp-248], r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	r15, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 871  :         } else {

	movzx	r8d, BYTE PTR totalBits$1$[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shr	r15, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r15, r11

; 871  :         } else {

	jmp	SHORT $LN291@ZSTD_decom
$LN59@ZSTD_decom:

; 872  :             U32 const ll0 = (llBase == 0);

	xor	r15d, r15d
	test	ecx, ecx
	sete	r15b

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN65@ZSTD_decom

; 874  :                 if (LIKELY(!ll0))

	test	ecx, ecx
	je	SHORT $LN67@ZSTD_decom

; 875  :                     offset = seqState->prevOffset[0];

	mov	r15, QWORD PTR seqState$7[rbp-168]
	jmp	SHORT $LN66@ZSTD_decom
$LN67@ZSTD_decom:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];

	mov	r15, QWORD PTR seqState$7[rbp-160]

; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];
; 879  :                     seqState->prevOffset[0] = offset;
; 880  :                 }
; 881  :             } else {

	jmp	SHORT $LN69@ZSTD_decom
$LN65@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
	mov	rdx, r9
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	inc	r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	lea	ecx, DWORD PTR [r15+r11]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	xor	r15d, r15d
	add	rcx, rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$7[rbp-248], r14d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	cmp	rcx, 3
	jne	SHORT $LN83@ZSTD_decom
	mov	rax, QWORD PTR seqState$7[rbp-168]
	sub	rax, 1
	sete	r15b
	add	r15, rax
	jmp	SHORT $LN291@ZSTD_decom
$LN83@ZSTD_decom:
	mov	rax, QWORD PTR seqState$7[rbp+rcx*8-168]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r15b
	add	r15, rax

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rcx, 1
	je	SHORT $LN69@ZSTD_decom
$LN291@ZSTD_decom:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];
; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	rax, QWORD PTR seqState$7[rbp-160]
	mov	QWORD PTR seqState$7[rbp-152], rax
$LN69@ZSTD_decom:
	mov	rax, QWORD PTR seqState$7[rbp-168]
	mov	QWORD PTR seqState$7[rbp-160], rax
	mov	QWORD PTR seqState$7[rbp-168], r15
$LN66@ZSTD_decom:
	mov	QWORD PTR $T4[rbp-240], r15

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	QWORD PTR $T4[rbp-248], r12

; 893  :     if (mlBits > 0)

	test	r10b, r10b
	je	SHORT $LN70@ZSTD_decom

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, r10b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx
	mov	DWORD PTR seqState$7[rbp-248], r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	mov	rax, r9
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r12, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	mov	QWORD PTR $T4[rbp-248], r12
$LN70@ZSTD_decom:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	r8b, 31
	jb	SHORT $LN72@ZSTD_decom

; 899  :         BIT_reloadDStream(&seqState->DStream);

	lea	rcx, QWORD PTR seqState$7[rbp-256]
	call	BIT_reloadDStream
	mov	r13, QWORD PTR seqState$7[rbp-240]
	mov	r14d, DWORD PTR seqState$7[rbp-248]
$LN72@ZSTD_decom:

; 900  :     /* Ensure there are enough bits to read the rest of data in 64-bit mode. */
; 901  :     ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);
; 902  : 
; 903  :     seq.litLength = llBase;
; 904  :     if (llBits > 0)

	mov	rax, QWORD PTR tv2509[rbp-256]
	mov	r10d, DWORD PTR tv2507[rbp-256]
	mov	r11, QWORD PTR seqState$7[rbp-256]
	mov	QWORD PTR $T4[rbp-256], r10
	test	al, al
	je	SHORT $LN73@ZSTD_decom

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	edx, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, r11
	shl	rax, cl
	and	edx, 63					; 0000003fH
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r10, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	mov	QWORD PTR $T4[rbp-256], r10
$LN73@ZSTD_decom:

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$1[rsp+3]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r9, r11
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movups	xmm0, XMMWORD PTR $T4[rbp-256]
	movups	xmm1, XMMWORD PTR $T4[rbp-240]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	r8d, DWORD PTR [r14+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r8d

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movaps	XMMWORD PTR $T5[rbp-256], xmm0

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	neg	ecx

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movaps	XMMWORD PTR $T5[rbp-240], xmm1
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	shr	r9, cl
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR BIT_mask[rcx+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$2[rsp+3]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r9, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, bx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rbx, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	r9, rax
	mov	QWORD PTR seqState$3$[rsp], r9
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[rbx+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$7[rbp-216], r9
; File E:\dev\pyzstd\lib\common\bitstream.h

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r9d, DWORD PTR [r8+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$3[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r9d
	neg	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r11
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	and	r8, rax

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r14d, DWORD PTR [r9+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	mov	r9, QWORD PTR litPtr$1$[rsp]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r14d
	movzx	eax, di
	neg	ecx
	add	r8, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$7[rbp-248], r14d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[rbx+rdx*4]
	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 709  :     BYTE* const oLitEnd = op + sequence.litLength;

	mov	rbx, QWORD PTR op$1$[rsp]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$5$[rsp], r8
	mov	QWORD PTR seqState$7[rbp-184], r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r11
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	lea	r11, QWORD PTR [r10+r9]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 709  :     BYTE* const oLitEnd = op + sequence.litLength;

	lea	rdi, QWORD PTR [r10+rbx]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, si

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	mov	rdx, rdi

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	r8, rax

; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;

	lea	rsi, QWORD PTR [r10+r12]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$4$[rbp-256], r8

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	sub	rdx, r15

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$7[rbp-200], r8

; 723  :     if (UNLIKELY(

	mov	r8, QWORD PTR lastLLSize$1$[rbp-256]
	cmp	r11, r8
	ja	$LN185@ZSTD_decom

; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */

	mov	rax, QWORD PTR oend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+rbx]

; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rax, -32				; ffffffffffffffe0H

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN185@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rbx], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r10, 16
	jbe	SHORT $LN201@ZSTD_decom

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	lea	rax, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r8, QWORD PTR [rax-16]
	add	r8, r10
	lea	rcx, QWORD PTR [r9+16]
	npad	13
$LL202@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r8
	jb	SHORT $LL202@ZSTD_decom
$LN201@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 747  :     *litPtr = iLitEnd;   /* update for next sequence */

	mov	rcx, r11

; 748  : 
; 749  :     /* Copy Match */
; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	rax, rdi
	mov	QWORD PTR litPtr$1$[rsp], rcx
	mov	QWORD PTR litPtr$[rsp], rcx
	mov	rcx, QWORD PTR prefixStart$1$[rsp]
	sub	rax, rcx
	cmp	r15, rax
	jbe	SHORT $LN297@ZSTD_decom

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rdi
	sub	rax, QWORD PTR vBase$1$[rbp-256]
	cmp	r15, rax
	jbe	SHORT $LN188@ZSTD_decom
	mov	rsi, -20
	mov	rdi, r11
	jmp	$LN183@ZSTD_decom
$LN188@ZSTD_decom:

; 753  :         match = dictEnd + (match - prefixStart);

	mov	r8, QWORD PTR dictEnd$1$[rbp-256]
	mov	rax, r8
	sub	rax, rcx

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	mov	rcx, rdi
	add	rdx, rax
	lea	rax, QWORD PTR [r12+rdx]
	cmp	rax, r8
	ja	SHORT $LN190@ZSTD_decom

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r12
	call	memmove

; 756  :             return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	$LN183@ZSTD_decom
$LN190@ZSTD_decom:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	mov	rbx, r8
	sub	rbx, rdx

; 760  :             memmove(oLitEnd, match, length1);

	mov	r8, rbx
	call	memmove

; 761  :             op = oLitEnd + length1;
; 762  :             sequence.matchLength -= length1;
; 763  :             match = prefixStart;

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	add	rdi, rbx
	sub	r12, rbx
	mov	rbx, QWORD PTR op$1$[rsp]
	jmp	SHORT $LN187@ZSTD_decom
$LN297@ZSTD_decom:

; 748  : 
; 749  :     /* Copy Match */
; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	r12, QWORD PTR $T5[rbp-248]
$LN187@ZSTD_decom:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	mov	rcx, QWORD PTR $T5[rbp-240]
	cmp	rcx, 16
	jb	SHORT $LN191@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [r12+rdi]
	sub	rdx, rdi
	npad	5
$LL214@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rdi]
	movups	XMMWORD PTR [rdi], xmm0

; 289  :             COPY16(op, ip);

	add	rdi, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdi, rax
	jb	SHORT $LL214@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	$LN183@ZSTD_decom
$LN191@ZSTD_decom:

; 585  :     if (offset < 8) {

	cmp	rcx, 8
	jae	SHORT $LN221@ZSTD_decom

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	r8, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rdi], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rdi+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[r8+rcx*4]
	add	rdx, rax

; 595  :         ZSTD_copy4(*op+4, *ip);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[r8+rcx*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN222@ZSTD_decom
$LN221@ZSTD_decom:

; 598  :         ZSTD_copy8(*op, *ip);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
$LN222@ZSTD_decom:

; 788  :     if (sequence.matchLength > 8) {

	cmp	r12, 8
	jbe	SHORT $LN229@ZSTD_decom

; 600  :     *ip += 8;

	add	rdx, 8

; 601  :     *op += 8;

	lea	rax, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rax-8]
	mov	r8, rdx
	mov	rcx, rax
	add	r9, r12
	sub	r8, rax
	sub	rcx, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rcx, 16
	jge	SHORT $LL230@ZSTD_decom
	npad	5
$LL227@ZSTD_decom:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rcx, QWORD PTR [r8+rax]
	mov	QWORD PTR [rax], rcx
	add	rax, 8

; 278  :         } while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL227@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	SHORT $LN183@ZSTD_decom
	npad	9
$LL230@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+rax]
	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL230@ZSTD_decom
$LN229@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	SHORT $LN183@ZSTD_decom
$LN185@ZSTD_decom:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	mov	rax, QWORD PTR dictEnd$1$[rbp-256]
	lea	r9, QWORD PTR litPtr$[rsp]
	mov	rdx, QWORD PTR oend$1$[rsp]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR vBase$1$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r8
	lea	r8, QWORD PTR $T6[rbp-256]
	movaps	XMMWORD PTR $T6[rbp-256], xmm0
	movaps	XMMWORD PTR $T6[rbp-240], xmm1
	call	ZSTD_execSequenceEnd
	mov	rdi, QWORD PTR litPtr$[rsp]
	mov	rsi, rax
	mov	QWORD PTR litPtr$1$[rsp], rdi
$LN183@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	cmp	r14d, 64				; 00000040H
	ja	SHORT $LN236@ZSTD_decom

; 419  :         return BIT_DStream_overflow;
; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	r13, QWORD PTR seqState$7[rbp-224]
	jb	SHORT $LN238@ZSTD_decom

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r14d
	shr	rax, 3
	sub	r13, rax

; 406  :     bitD->bitsConsumed &= 7;

	and	r14d, 7

; 407  :     bitD->bitContainer = MEM_readLEST(bitD->ptr);

	mov	rcx, QWORD PTR [r13]
	mov	QWORD PTR seqState$7[rbp-256], rcx

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN302@ZSTD_decom
$LN238@ZSTD_decom:

; 423  :     }
; 424  :     if (bitD->ptr == bitD->start) {

	mov	r8, QWORD PTR seqState$7[rbp-232]
	cmp	r13, r8
	je	SHORT $LN236@ZSTD_decom

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;
; 426  :         return BIT_DStream_completed;
; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r14d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, r13
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r8
	jae	SHORT $LN241@ZSTD_decom

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	edx, DWORD PTR seqState$7[rbp-240]
	sub	edx, r8d
$LN241@ZSTD_decom:

; 433  :             result = BIT_DStream_endOfBuffer;
; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	r13, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	r14d, eax

; 437  :         bitD->bitContainer = MEM_readLEST(bitD->ptr);   /* reminder : srcSize > sizeof(bitD->bitContainer), otherwise bitD->ptr == bitD->start */

	mov	rax, QWORD PTR [r13]
	mov	QWORD PTR seqState$7[rbp-256], rax
$LN302@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1091 :             if (UNLIKELY(!--nbSeq)) break;

	mov	DWORD PTR seqState$7[rbp-248], r14d
	mov	QWORD PTR seqState$7[rbp-240], r13
$LN236@ZSTD_decom:
	mov	rcx, QWORD PTR seqState$3$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	mov	r8, QWORD PTR seqState$7[rbp-176]
	cmp	rsi, -120				; ffffffffffffff88H
	mov	r15, rsi
	cmovbe	r15, QWORD PTR error$1$[rbp-256]
	cmovbe	rbx, rax
	sub	DWORD PTR nbSeq$[rbp-256], 1
	mov	rax, QWORD PTR seqState$4$[rbp-256]
	mov	QWORD PTR error$1$[rbp-256], r15
	mov	QWORD PTR op$1$[rsp], rbx
	jne	$LL300@ZSTD_decom
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	r13, QWORD PTR [rsp+472]
	mov	r12, QWORD PTR [rsp+480]
	cmp	r15, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1096 :         if (ZSTD_isError(error)) return error;

	jbe	SHORT $LN17@ZSTD_decom
	mov	rax, r15
	jmp	SHORT $LN1@ZSTD_decom
$LN17@ZSTD_decom:

; 1097 :         RETURN_ERROR_IF(nbSeq, corruption_detected, "");
; 1098 :         RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, "");

	lea	rcx, QWORD PTR seqState$7[rbp-256]
	call	BIT_reloadDStream
	cmp	eax, 2
	jl	SHORT $LN292@ZSTD_decom

; 1099 :         /* save reps for next block */
; 1100 :         { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }

	mov	rcx, QWORD PTR dctx$GSCopy$1$[rbp-256]
	mov	eax, DWORD PTR seqState$7[rbp-168]
	mov	r14, QWORD PTR lastLLSize$1$[rbp-256]
	mov	r15, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rcx+26684], eax
	mov	eax, DWORD PTR seqState$7[rbp-160]
	mov	DWORD PTR [rcx+26688], eax
	mov	eax, DWORD PTR seqState$7[rbp-152]
	mov	DWORD PTR [rcx+26692], eax
	mov	rcx, QWORD PTR oend$1$[rsp]
$LN9@ZSTD_decom:

; 1101 :     }
; 1102 : 
; 1103 :     /* last literal segment */
; 1104 :     {   size_t const lastLLSize = litEnd - litPtr;

	sub	r14, rdi

; 1105 :         RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");

	sub	rcx, rbx
	cmp	r14, rcx
	jbe	SHORT $LN22@ZSTD_decom
	mov	rax, -70				; ffffffffffffffbaH
	jmp	SHORT $LN1@ZSTD_decom
$LN292@ZSTD_decom:

; 1097 :         RETURN_ERROR_IF(nbSeq, corruption_detected, "");
; 1098 :         RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, "");

	mov	rax, -20
	jmp	SHORT $LN1@ZSTD_decom
$LN22@ZSTD_decom:

; 1106 :         if (op != NULL) {

	test	rbx, rbx
	je	SHORT $LN24@ZSTD_decom

; 1107 :             memcpy(op, litPtr, lastLLSize);

	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rbx
	call	memcpy

; 1108 :             op += lastLLSize;

	add	rbx, r14
$LN24@ZSTD_decom:

; 1109 :         }
; 1110 :     }
; 1111 : 
; 1112 :     return op-ostart;

	sub	rbx, r15
	mov	rax, rbx
$LN1@ZSTD_decom:

; 1113 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 488				; 000001e8H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_decompressSequences_body ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
totalBits$1$ = 64
litPtr$1 = 72
oend$1$ = 80
tv2193 = 88
lastLLSize$1$ = 96
dictEnd$1$ = 104
vBase$1$ = 112
prefixStart$1$ = 120
$T2 = 128
tv2196 = 136
llDInfo$3 = 144
mlDInfo$4 = 152
ofDInfo$5 = 160
dctx$GSCopy$1$ = 168
dst$GSCopy$1$ = 176
$T6 = 184
$T7 = 224
$T8 = 256
seqState$9 = 288
__$ArrayPad$ = 432
dctx$ = 528
dst$ = 536
maxDstSize$ = 544
seqStart$ = 552
seqSize$ = 560
nbSeq$ = 568
isLongOffset$dead$ = 576
frame$dead$ = 584
ZSTD_decompressSequences_default PROC

; 1121 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	lea	rbp, QWORD PTR [rsp-216]
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, rcx
	mov	QWORD PTR dctx$GSCopy$1$[rbp-256], rcx

; 1004 :     BYTE* const oend = ostart + maxDstSize;

	lea	rcx, QWORD PTR [r8+rdx]

; 1121 : {

	mov	QWORD PTR dst$GSCopy$1$[rbp-256], rdx
	mov	rsi, rdx

; 1004 :     BYTE* const oend = ostart + maxDstSize;

	mov	QWORD PTR oend$1$[rsp], rcx

; 1005 :     BYTE* op = ostart;

	mov	r13, rdx

; 1006 :     const BYTE* litPtr = dctx->litPtr;
; 1007 :     const BYTE* const litEnd = litPtr + dctx->litSize;
; 1008 :     const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);

	mov	rax, QWORD PTR [rdi+28752]
	mov	rdx, QWORD PTR [rdi+28952]
	mov	rbx, QWORD PTR [rdi+28984]
	mov	QWORD PTR prefixStart$1$[rsp], rax
	add	rbx, rdx

; 1009 :     const BYTE* const vBase = (const BYTE*) (dctx->virtualStart);
; 1010 :     const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);
; 1011 :     DEBUGLOG(5, "ZSTD_decompressSequences_body");
; 1012 :     (void)frame;
; 1013 : 
; 1014 :     /* Regen sequences */
; 1015 :     if (nbSeq) {

	cmp	DWORD PTR nbSeq$[rbp-256], 0
	mov	rax, QWORD PTR [rdi+28760]
	mov	QWORD PTR vBase$1$[rsp], rax
	mov	rax, QWORD PTR [rdi+28768]
	mov	QWORD PTR dictEnd$1$[rsp], rax
	mov	QWORD PTR litPtr$1[rsp], rdx
	mov	QWORD PTR lastLLSize$1$[rsp], rbx
	je	$LN11@ZSTD_decom

; 1020 :         RETURN_ERROR_IF(

	mov	r8, QWORD PTR seqSize$[rbp-256]
	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	DWORD PTR [rdi+28844], 1
	mov	rdx, r9
	mov	eax, DWORD PTR [rdi+26684]
	mov	QWORD PTR seqState$9[rbp-168], rax
	mov	eax, DWORD PTR [rdi+26688]
	mov	QWORD PTR seqState$9[rbp-160], rax
	mov	eax, DWORD PTR [rdi+26692]
	mov	QWORD PTR seqState$9[rbp-152], rax
	mov	QWORD PTR $T2[rbp-256], 0
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1020 :         RETURN_ERROR_IF(

	jbe	SHORT $LN14@ZSTD_decom
$LN517@ZSTD_decom:

; 1123 : }

	mov	rax, -20
	jmp	$LN3@ZSTD_decom
$LN14@ZSTD_decom:

; 1023 :         ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);

	mov	rbx, QWORD PTR [rdi]

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	QWORD PTR [rsp+464], r12
	mov	QWORD PTR [rsp+456], r15
	mov	edx, DWORD PTR [rbx+4]
	call	BIT_readBits

; 801  :     DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
; 802  :                 (U32)DStatePtr->state, DTableH->tableLog);
; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	QWORD PTR seqState$9[rbp-216], rax
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]

; 1024 :         ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);

	mov	rbx, QWORD PTR [rdi+16]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$9[rbp-208], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	edx, DWORD PTR [rbx+4]
	call	BIT_readBits

; 801  :     DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
; 802  :                 (U32)DStatePtr->state, DTableH->tableLog);
; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	QWORD PTR seqState$9[rbp-200], rax
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]

; 1025 :         ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);

	mov	rbx, QWORD PTR [rdi+8]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$9[rbp-192], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	edx, DWORD PTR [rbx+4]
	call	BIT_readBits

; 801  :     DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
; 802  :                 (U32)DStatePtr->state, DTableH->tableLog);
; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	mov	QWORD PTR seqState$9[rbp-184], rax
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR seqState$9[rbp-176], rcx
	npad	8
$LL7@ZSTD_decom:

; 841  :     ZSTD_seqSymbol const llDInfo = seqState->stateLL.table[seqState->stateLL.state];

	mov	rax, QWORD PTR seqState$9[rbp-216]
	mov	rbx, QWORD PTR seqState$9[rbp-208]

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rdi, QWORD PTR seqState$9[rbp-184]

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rsi, QWORD PTR seqState$9[rbp-200]

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;
; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	mov	r10, QWORD PTR seqState$9[rbp-256]
	mov	rbx, QWORD PTR [rbx+rax*8]
	mov	rdi, QWORD PTR [rcx+rdi*8]
	mov	rdx, rbx
	mov	rax, QWORD PTR seqState$9[rbp-192]
	mov	rcx, rdi
	mov	r9d, DWORD PTR seqState$9[rbp-248]
	mov	r12, rbx
	shr	rcx, 16
	mov	r15, rdi
	shr	rdx, 16
	mov	rsi, QWORD PTR [rax+rsi*8]
	mov	rax, rsi
	shr	r12, 32					; 00000020H
	shr	rax, 16
	mov	r11, rsi
	shr	r15, 32					; 00000020H
	shr	r11, 32					; 00000020H
	mov	QWORD PTR llDInfo$3[rbp-256], rbx
	lea	r8d, DWORD PTR [rcx+rax]
	mov	QWORD PTR tv2196[rbp-256], rdx
	add	r8b, dl
	mov	QWORD PTR mlDInfo$4[rbp-256], rdi
	mov	QWORD PTR tv2193[rsp], rcx
	mov	QWORD PTR ofDInfo$5[rbp-256], rsi
	mov	BYTE PTR totalBits$1$[rsp], r8b
	cmp	al, 1
	jbe	SHORT $LN115@ZSTD_decom

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	rax, QWORD PTR seqState$9[rbp-160]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	QWORD PTR seqState$9[rbp-152], rax

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR seqState$9[rbp-168]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r14, r10
	shl	r14, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
	neg	ecx

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$9[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$9[rbp-160], rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r14, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r14, r11

; 870  :             seqState->prevOffset[0] = offset;
; 871  :         } else {

	jmp	$LN515@ZSTD_decom
$LN115@ZSTD_decom:

; 872  :             U32 const ll0 = (llBase == 0);

	xor	r8d, r8d
	test	r12d, r12d
	sete	r8b

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN121@ZSTD_decom

; 874  :                 if (LIKELY(!ll0))

	test	r12d, r12d
	je	SHORT $LN123@ZSTD_decom

; 875  :                     offset = seqState->prevOffset[0];

	mov	r14, QWORD PTR seqState$9[rbp-168]
	jmp	$LN122@ZSTD_decom
$LN123@ZSTD_decom:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];
; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR seqState$9[rbp-168]
	mov	r14, QWORD PTR seqState$9[rbp-160]
	mov	QWORD PTR seqState$9[rbp-160], rax

; 879  :                     seqState->prevOffset[0] = offset;
; 880  :                 }
; 881  :             } else {

	jmp	SHORT $LN516@ZSTD_decom
$LN121@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
	mov	rdx, r10
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	inc	r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	xor	r14d, r14d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	lea	ecx, DWORD PTR [r11+r8]
	add	rcx, rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$9[rbp-248], r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	mov	rdx, QWORD PTR seqState$9[rbp-168]
	cmp	rcx, 3
	jne	SHORT $LN139@ZSTD_decom
	lea	rax, QWORD PTR [rdx-1]
	test	rax, rax
	sete	r14b
	add	r14, rax
	jmp	SHORT $LN500@ZSTD_decom
$LN139@ZSTD_decom:
	mov	rax, QWORD PTR seqState$9[rbp+rcx*8-168]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r14b
	add	r14, rax

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rcx, 1
	je	SHORT $LN125@ZSTD_decom
$LN500@ZSTD_decom:
	mov	rax, QWORD PTR seqState$9[rbp-160]
	mov	QWORD PTR seqState$9[rbp-152], rax
$LN125@ZSTD_decom:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$9[rbp-160], rdx
$LN515@ZSTD_decom:

; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	rcx, QWORD PTR tv2193[rsp]
$LN516@ZSTD_decom:
	mov	QWORD PTR seqState$9[rbp-168], r14
$LN122@ZSTD_decom:
	mov	QWORD PTR $T6[rbp-240], r14

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	QWORD PTR $T6[rbp-248], r15

; 893  :     if (mlBits > 0)

	test	cl, cl
	je	SHORT $LN126@ZSTD_decom

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, cl
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, r10
	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$9[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r15, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	mov	QWORD PTR $T6[rbp-248], r15
$LN126@ZSTD_decom:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	BYTE PTR totalBits$1$[rsp], 31
	jb	SHORT $LN128@ZSTD_decom

; 899  :         BIT_reloadDStream(&seqState->DStream);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	call	BIT_reloadDStream
	mov	r9d, DWORD PTR seqState$9[rbp-248]
	mov	r10, QWORD PTR seqState$9[rbp-256]
$LN128@ZSTD_decom:

; 900  :     /* Ensure there are enough bits to read the rest of data in 64-bit mode. */
; 901  :     ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);
; 902  : 
; 903  :     seq.litLength = llBase;
; 904  :     if (llBits > 0)

	mov	rax, QWORD PTR tv2196[rbp-256]
	mov	QWORD PTR $T6[rbp-256], r12
	test	al, al
	je	SHORT $LN129@ZSTD_decom

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	eax, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shl	r10, cl

; 370  :     bitD->bitsConsumed += nbBits;

	neg	eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$9[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	movzx	ecx, al
	shr	r10, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r12, r10
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	mov	QWORD PTR $T6[rbp-256], r12
$LN129@ZSTD_decom:

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$3[rbp-253]

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	call	BIT_readBits

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$4[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, bx
	add	rax, rcx

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$9[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$9[rbp-216], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$5[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, di
	add	rax, rcx

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$9[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$9[rbp-184], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	mov	r8, QWORD PTR litPtr$1[rsp]
	lea	rdi, QWORD PTR [r12+r13]

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movups	xmm0, XMMWORD PTR $T6[rbp-256]

; 723  :     if (UNLIKELY(

	mov	rbx, QWORD PTR lastLLSize$1$[rsp]
	mov	rdx, rdi

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movups	xmm1, XMMWORD PTR $T6[rbp-240]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, si

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	lea	r9, QWORD PTR [r12+r8]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	rax, rcx

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movaps	XMMWORD PTR $T7[rbp-256], xmm0

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	sub	rdx, r14

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$9[rbp-200], rax

; 1076 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);

	movaps	XMMWORD PTR $T7[rbp-240], xmm1

; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;

	lea	rsi, QWORD PTR [r12+r15]

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	r9, rbx
	ja	$LN255@ZSTD_decom

; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */

	mov	rax, QWORD PTR oend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+r13]

; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rax, -32				; ffffffffffffffe0H

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN255@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r13], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r12, 16
	jbe	SHORT $LN273@ZSTD_decom

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	mov	rcx, QWORD PTR litPtr$1[rsp]
	lea	rax, QWORD PTR [r13+16]
	add	rcx, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r8, QWORD PTR [rax-16]
	add	r8, r12
	npad	8
$LL274@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r8
	jb	SHORT $LL274@ZSTD_decom
$LN273@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	r12, QWORD PTR prefixStart$1$[rsp]
	mov	rax, rdi
	sub	rax, r12
	mov	QWORD PTR litPtr$1[rsp], r9
	cmp	r14, rax
	jbe	SHORT $LN506@ZSTD_decom

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rdi
	sub	rax, QWORD PTR vBase$1$[rsp]
	cmp	r14, rax
	jbe	SHORT $LN258@ZSTD_decom
	mov	rsi, -20
	jmp	$LN253@ZSTD_decom
$LN258@ZSTD_decom:

; 753  :         match = dictEnd + (match - prefixStart);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
	mov	rax, rcx
	sub	rax, r12
	add	rdx, rax

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	lea	rax, QWORD PTR [r15+rdx]
	cmp	rax, rcx
	ja	SHORT $LN260@ZSTD_decom

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r15
	mov	rcx, rdi
	call	memmove

; 756  :             return sequenceLength;

	jmp	$LN253@ZSTD_decom
$LN260@ZSTD_decom:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	mov	rbx, rcx

; 760  :             memmove(oLitEnd, match, length1);

	mov	rcx, rdi
	sub	rbx, rdx
	mov	r8, rbx
	call	memmove

; 761  :             op = oLitEnd + length1;

	add	rdi, rbx

; 762  :             sequence.matchLength -= length1;
; 763  :             match = prefixStart;

	mov	rdx, r12
	sub	r15, rbx
	mov	rbx, QWORD PTR lastLLSize$1$[rsp]
	jmp	SHORT $LN257@ZSTD_decom
$LN506@ZSTD_decom:

; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	r15, QWORD PTR $T7[rbp-248]
$LN257@ZSTD_decom:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	mov	rcx, QWORD PTR $T7[rbp-240]
	cmp	rcx, 16
	jb	SHORT $LN261@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [r15+rdi]
	sub	rdx, rdi
	npad	2
$LL288@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi+rdx]
	movups	XMMWORD PTR [rdi], xmm0

; 289  :             COPY16(op, ip);

	add	rdi, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdi, rax
	jb	SHORT $LL288@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	jmp	$LN253@ZSTD_decom
$LN261@ZSTD_decom:

; 585  :     if (offset < 8) {

	cmp	rcx, 8
	jae	SHORT $LN297@ZSTD_decom

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	r8, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rdi], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rdi+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[r8+rcx*4]
	add	rdx, rax

; 47   : static void ZSTD_copy4(void* dst, const void* src) { memcpy(dst, src, 4); }

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[r8+rcx*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN302@ZSTD_decom
$LN297@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
$LN302@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 788  :     if (sequence.matchLength > 8) {

	cmp	r15, 8
	jbe	$LN253@ZSTD_decom

; 600  :     *ip += 8;

	add	rdx, 8

; 601  :     *op += 8;

	lea	rax, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rax-8]
	mov	r8, rdx
	mov	rcx, rax
	add	r9, r15
	sub	r8, rax
	sub	rcx, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rcx, 16
	jge	SHORT $LL310@ZSTD_decom
	npad	6
$LL307@ZSTD_decom:

; 234  :     memcpy(dst, src, 8);

	mov	rcx, QWORD PTR [rax+r8]
	mov	QWORD PTR [rax], rcx

; 277  :             COPY8(op, ip)

	add	rax, 8

; 278  :         } while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL307@ZSTD_decom

; 279  :     } else {

	jmp	SHORT $LN253@ZSTD_decom
	npad	14
$LL310@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rax+r8]
	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL310@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	jmp	SHORT $LN253@ZSTD_decom
$LN255@ZSTD_decom:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	mov	rax, QWORD PTR dictEnd$1$[rsp]
	lea	r9, QWORD PTR litPtr$1[rsp]
	mov	rdx, QWORD PTR oend$1$[rsp]
	lea	r8, QWORD PTR $T8[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, r13
	mov	rax, QWORD PTR vBase$1$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	movaps	XMMWORD PTR $T8[rbp-256], xmm0
	movaps	XMMWORD PTR $T8[rbp-240], xmm1
	call	ZSTD_execSequenceEnd
	mov	rsi, rax
$LN253@ZSTD_decom:

; 1082 :             BIT_reloadDStream(&(seqState.DStream));

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	call	BIT_reloadDStream

; 1083 :             /* gcc and clang both don't like early returns in this loop.
; 1084 :              * gcc doesn't like early breaks either.
; 1085 :              * Instead save an error and report it at the end.
; 1086 :              * When there is an error, don't increment op, so we don't
; 1087 :              * overwrite.
; 1088 :              */
; 1089 :             if (UNLIKELY(ZSTD_isError(oneSeqSize))) error = oneSeqSize;
; 1090 :             else op += oneSeqSize;
; 1091 :             if (UNLIKELY(!--nbSeq)) break;

	cmp	rsi, -120				; ffffffffffffff88H
	lea	rcx, QWORD PTR [rsi+r13]
	mov	r14, rsi
	cmovbe	r14, QWORD PTR $T2[rbp-256]
	cmovbe	r13, rcx
	sub	DWORD PTR nbSeq$[rbp-256], 1
	mov	QWORD PTR $T2[rbp-256], r14
	je	SHORT $LN513@ZSTD_decom
	mov	rcx, QWORD PTR seqState$9[rbp-176]
	jmp	$LL7@ZSTD_decom
$LN513@ZSTD_decom:
	mov	r15, QWORD PTR [rsp+456]
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	mov	r12, QWORD PTR [rsp+464]
	cmp	r14, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1096 :         if (ZSTD_isError(error)) return error;

	jbe	SHORT $LN19@ZSTD_decom

; 1122 :     return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	rax, r14

; 1096 :         if (ZSTD_isError(error)) return error;

	jmp	SHORT $LN3@ZSTD_decom
$LN19@ZSTD_decom:

; 1097 :         RETURN_ERROR_IF(nbSeq, corruption_detected, "");
; 1098 :         RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, "");

	lea	rcx, QWORD PTR seqState$9[rbp-256]
	call	BIT_reloadDStream
	cmp	eax, 2
	jl	$LN517@ZSTD_decom

; 1099 :         /* save reps for next block */
; 1100 :         { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }

	mov	rcx, QWORD PTR dctx$GSCopy$1$[rbp-256]
	mov	eax, DWORD PTR seqState$9[rbp-168]
	mov	rdx, QWORD PTR litPtr$1[rsp]
	mov	rsi, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rcx+26684], eax
	mov	eax, DWORD PTR seqState$9[rbp-160]
	mov	DWORD PTR [rcx+26688], eax
	mov	eax, DWORD PTR seqState$9[rbp-152]
	mov	DWORD PTR [rcx+26692], eax
	mov	rcx, QWORD PTR oend$1$[rsp]
$LN11@ZSTD_decom:

; 1101 :     }
; 1102 : 
; 1103 :     /* last literal segment */
; 1104 :     {   size_t const lastLLSize = litEnd - litPtr;

	sub	rbx, rdx

; 1105 :         RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");

	sub	rcx, r13
	cmp	rbx, rcx
	jbe	SHORT $LN24@ZSTD_decom

; 1122 :     return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	rax, -70				; ffffffffffffffbaH

; 1105 :         RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");

	jmp	SHORT $LN3@ZSTD_decom
$LN24@ZSTD_decom:

; 1106 :         if (op != NULL) {

	test	r13, r13
	je	SHORT $LN26@ZSTD_decom

; 1107 :             memcpy(op, litPtr, lastLLSize);

	mov	r8, rbx
	mov	rcx, r13
	call	memcpy

; 1108 :             op += lastLLSize;

	add	r13, rbx
$LN26@ZSTD_decom:

; 1109 :         }
; 1110 :     }
; 1111 : 
; 1112 :     return op-ostart;

	sub	r13, rsi

; 1122 :     return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	rax, r13
$LN3@ZSTD_decom:

; 1123 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_decompressSequences_default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
seqState$4$ = 64
ll0$1$ = 64
offset$2$ = 64
ll0$1$ = 64
seqNb$1$ = 72
$T1 = 80
offset$2$ = 80
litPtr$1$ = 88
litPtr$ = 96
op$1$ = 104
$T2 = 112
seqState$3$ = 112
seqAdvance$1$ = 120
prefixStart$1$ = 128
oend$1$ = 136
seqState$5$ = 144
tv4132 = 144
tv4306 = 152
tv3845 = 152
$T3 = 160
tv4076 = 160
mlDInfo$4 = 160
$T5 = 176
tv4077 = 176
ofDInfo$6 = 176
iLitEnd$1$ = 184
tv4072 = 184
tv3873 = 184
dictEnd$1$ = 192
dictStart$1$ = 200
lastLLSize$1$ = 208
$T7 = 216
$T8 = 216
tv4136 = 248
ofDInfo$9 = 248
tv4137 = 256
mlDInfo$10 = 256
llDInfo$11 = 264
llDInfo$12 = 264
$T13 = 272
dctx$GSCopy$1$ = 280
dst$GSCopy$1$ = 288
$T14 = 304
$T15 = 304
seqState$16 = 336
sequences$17 = 480
__$ArrayPad$ = 608
dctx$ = 704
dst$ = 712
maxDstSize$ = 720
seqStart$ = 728
seqSize$ = 736
nbSeq$ = 744
isLongOffset$dead$ = 752
frame$dead$ = 760
ZSTD_decompressSequencesLong_body PROC

; 1134 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-376]
	sub	rsp, 632				; 00000278H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1135 :     const BYTE* ip = (const BYTE*)seqStart;
; 1136 :     const BYTE* const iend = ip + seqSize;
; 1137 :     BYTE* const ostart = (BYTE* const)dst;
; 1138 :     BYTE* const oend = ostart + maxDstSize;
; 1139 :     BYTE* op = ostart;
; 1140 :     const BYTE* litPtr = dctx->litPtr;

	mov	rdi, QWORD PTR [rcx+28952]
	mov	r14, rcx

; 1141 :     const BYTE* const litEnd = litPtr + dctx->litSize;

	mov	rsi, QWORD PTR [rcx+28984]
	add	r8, rdx
	mov	r10, QWORD PTR seqSize$[rbp-256]
	add	rsi, rdi
	mov	r15, rdx
	mov	QWORD PTR dst$GSCopy$1$[rbp-256], rdx

; 1142 :     const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);
; 1143 :     const BYTE* const dictStart = (const BYTE*) (dctx->virtualStart);

	mov	rax, QWORD PTR [r14+28760]
	mov	rbx, rdx
	mov	QWORD PTR dictStart$1$[rbp-256], rax

; 1144 :     const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);
; 1145 :     (void)frame;
; 1146 : 
; 1147 :     /* Regen sequences */
; 1148 :     if (nbSeq) {

	mov	eax, DWORD PTR nbSeq$[rbp-256]
	mov	QWORD PTR dctx$GSCopy$1$[rbp-256], rcx
	mov	rcx, QWORD PTR [rcx+28752]
	mov	QWORD PTR op$1$[rsp], rdx
	mov	rdx, QWORD PTR [r14+28768]
	mov	QWORD PTR oend$1$[rbp-256], r8
	mov	QWORD PTR litPtr$1$[rsp], rdi
	mov	QWORD PTR litPtr$[rsp], rdi
	mov	QWORD PTR lastLLSize$1$[rbp-256], rsi
	mov	QWORD PTR prefixStart$1$[rbp-256], rcx
	mov	QWORD PTR dictEnd$1$[rbp-256], rdx
	test	eax, eax
	je	$LN15@ZSTD_decom

; 1149 : #define STORED_SEQS 4
; 1150 : #define STORED_SEQS_MASK (STORED_SEQS-1)
; 1151 : #define ADVANCED_SEQS 4
; 1152 :         seq_t sequences[STORED_SEQS];
; 1153 :         int const seqAdvance = MIN(nbSeq, ADVANCED_SEQS);
; 1154 :         seqState_t seqState;
; 1155 :         int seqNb;
; 1156 :         dctx->fseEntropy = 1;

	mov	DWORD PTR [r14+28844], 1
	mov	edi, 4
	cmp	eax, edi

; 1157 :         { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }
; 1158 :         seqState.prefixStart = prefixStart;

	mov	QWORD PTR seqState$16[rbp-144], rcx

; 1159 :         seqState.pos = (size_t)(op-prefixStart);
; 1160 :         seqState.dictEnd = dictEnd;

	mov	QWORD PTR seqState$16[rbp-136], rdx

; 1163 :         RETURN_ERROR_IF(

	mov	r8, r10
	cmovl	edi, eax
	mov	rdx, r9
	mov	eax, DWORD PTR [r14+26684]
	mov	QWORD PTR seqState$16[rbp-168], rax
	mov	eax, DWORD PTR [r14+26688]
	mov	QWORD PTR seqState$16[rbp-160], rax
	mov	eax, DWORD PTR [r14+26692]
	mov	QWORD PTR seqState$16[rbp-152], rax
	mov	rax, rbx
	sub	rax, rcx
	mov	DWORD PTR seqAdvance$1$[rsp], edi
	lea	rcx, QWORD PTR seqState$16[rbp-256]
	mov	QWORD PTR seqState$16[rbp-128], rax
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1163 :         RETURN_ERROR_IF(

	ja	$LN560@ZSTD_decom
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR seqState$16[rbp-248]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	rsi, OFFSET FLAT:__ImageBase
	mov	r8, QWORD PTR seqState$16[rbp-256]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1166 :         ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);

	mov	rbx, QWORD PTR [r14]

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	edx, DWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r9d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	eax, DWORD PTR BIT_mask[rsi+rdx*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$16[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	QWORD PTR seqState$16[rbp-216], r8

; 803  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR seqState$16[rbp-248]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, QWORD PTR seqState$16[rbp-256]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1167 :         ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);

	mov	rbx, QWORD PTR [r14+16]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$16[rbp-208], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	edx, DWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r9d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	eax, DWORD PTR BIT_mask[rsi+rdx*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$16[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	QWORD PTR seqState$16[rbp-200], r8

; 803  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	mov	r9d, DWORD PTR seqState$16[rbp-248]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, QWORD PTR seqState$16[rbp-256]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1168 :         ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);

	mov	rbx, QWORD PTR [r14+8]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$16[rbp-192], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	edx, DWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 351  :     return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);

	add	r9d, edx

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r9d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	neg	ecx
	mov	eax, DWORD PTR BIT_mask[rsi+rdx*4]
	and	ecx, 63					; 0000003fH
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$16[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	mov	QWORD PTR seqState$16[rbp-184], r8

; 803  :     BIT_reloadDStream(bitD);

	call	BIT_reloadDStream

; 1166 :         ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);

	mov	r11, QWORD PTR seqState$16[rbp-184]
	lea	rax, QWORD PTR sequences$17[rbp-232]
	mov	r13, QWORD PTR seqState$16[rbp-168]

; 804  :     DStatePtr->table = dt + 1;

	lea	r9, QWORD PTR [rbx+8]

; 1166 :         ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);

	mov	rsi, QWORD PTR seqState$16[rbp-216]

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	xor	r8d, r8d
	mov	r15, QWORD PTR seqState$16[rbp-240]
	xor	r10d, r10d
	mov	r14d, DWORD PTR seqState$16[rbp-248]
	mov	r12, QWORD PTR seqState$16[rbp-256]
	mov	QWORD PTR tv3845[rbp-256], rax
	mov	rax, QWORD PTR seqState$16[rbp-200]
	movsxd	rbx, edi
	mov	QWORD PTR seqState$4$[rsp], rax

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$16[rbp-176], r9

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	mov	QWORD PTR tv3873[rbp-256], rbx
	mov	QWORD PTR seqState$5$[rbp-256], r11
$LN606@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	mov	QWORD PTR $T13[rbp-256], r10
	mov	DWORD PTR seqNb$1$[rsp], r8d
	cmp	r14d, 64				; 00000040H
	ja	$LN556@ZSTD_decom

; 419  :         return BIT_DStream_overflow;
; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	r15, QWORD PTR seqState$16[rbp-224]
	jb	SHORT $LN64@ZSTD_decom

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r14d
	shr	rax, 3
	sub	r15, rax

; 406  :     bitD->bitsConsumed &= 7;

	and	r14d, 7
$LN609@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	mov	r12, QWORD PTR [r15]
	mov	rax, QWORD PTR seqState$4$[rsp]
	mov	QWORD PTR seqState$16[rbp-256], r12
	mov	QWORD PTR seqState$16[rbp-240], r15
	mov	DWORD PTR seqState$16[rbp-248], r14d
	jmp	SHORT $LN554@ZSTD_decom
$LN64@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 424  :     if (bitD->ptr == bitD->start) {

	mov	r9, QWORD PTR seqState$16[rbp-232]
	cmp	r15, r9
	je	SHORT $LN597@ZSTD_decom

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;
; 426  :         return BIT_DStream_completed;
; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r14d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, r15
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r9
	mov	r9, QWORD PTR seqState$16[rbp-176]
	jae	SHORT $LN67@ZSTD_decom

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR seqState$16[rbp-240]
	sub	eax, DWORD PTR seqState$16[rbp-232]
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	imul	eax, eax, -8				; fffffff8H
	sub	r15, rcx
	add	r14d, eax
	jmp	SHORT $LN609@ZSTD_decom
$LN67@ZSTD_decom:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	r15, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
	add	r14d, eax
	jmp	SHORT $LN609@ZSTD_decom
$LN597@ZSTD_decom:

; 424  :     if (bitD->ptr == bitD->start) {

	mov	r9, QWORD PTR seqState$16[rbp-176]
$LN554@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	cmp	r10, rbx
	jge	$LN556@ZSTD_decom

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rdi, QWORD PTR [r9+r11*8]
	mov	rbx, QWORD PTR seqState$16[rbp-208]
	mov	r10, rdi
	shr	r10, 16
	mov	r9, rdi
	shr	r9, 32					; 00000020H
	mov	QWORD PTR mlDInfo$4[rbp-256], rdi
	mov	rbx, QWORD PTR [rbx+rsi*8]

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rsi, QWORD PTR seqState$16[rbp-192]
	mov	rdx, rbx
	shr	rdx, 16
	mov	rcx, rbx
	shr	rcx, 32					; 00000020H
	mov	QWORD PTR llDInfo$12[rbp-256], rbx
	mov	rsi, QWORD PTR [rsi+rax*8]
	mov	rax, rsi
	mov	QWORD PTR tv4137[rbp-256], rdx
	shr	rax, 16
	mov	r8, rsi
	shr	r8, 32					; 00000020H
	mov	QWORD PTR tv4136[rbp-256], rcx
	mov	QWORD PTR $T2[rsp], r9

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;

	lea	r11d, DWORD PTR [r10+rax]
	mov	QWORD PTR ofDInfo$6[rbp-256], rsi
	add	r11b, dl
	mov	QWORD PTR tv4132[rbp-256], r8

; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	cmp	al, 1
	jbe	SHORT $LN73@ZSTD_decom

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, r8d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, r12

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	mov	r8d, DWORD PTR tv4132[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shr	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r8, rdx
	mov	QWORD PTR offset$2$[rsp], r8

; 866  :                 if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);
; 867  :             }
; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];
; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];
; 870  :             seqState->prevOffset[0] = offset;
; 871  :         } else {

	jmp	$LN559@ZSTD_decom
$LN73@ZSTD_decom:

; 872  :             U32 const ll0 = (llBase == 0);

	xor	edx, edx
	test	ecx, ecx
	sete	dl
	mov	DWORD PTR ll0$1$[rsp], edx

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN79@ZSTD_decom

; 874  :                 if (LIKELY(!ll0))

	test	ecx, ecx
	je	SHORT $LN81@ZSTD_decom

; 875  :                     offset = seqState->prevOffset[0];

	mov	r8, r13
	mov	QWORD PTR offset$2$[rsp], r13
	jmp	$LN80@ZSTD_decom
$LN81@ZSTD_decom:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];

	mov	rax, QWORD PTR seqState$16[rbp-160]

; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$16[rbp-160], r13
	mov	r8, rax
	mov	QWORD PTR offset$2$[rsp], rax

; 879  :                     seqState->prevOffset[0] = offset;

	mov	r13, rax
	mov	QWORD PTR seqState$16[rbp-168], rax

; 880  :                 }
; 881  :             } else {

	jmp	SHORT $LN80@ZSTD_decom
$LN79@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
	mov	rdx, r12
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	inc	r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	mov	ecx, DWORD PTR ll0$1$[rsp]
	add	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	add	rcx, rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r14d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	xor	r8d, r8d
	cmp	rcx, 3
	jne	SHORT $LN97@ZSTD_decom
	lea	rax, QWORD PTR [r13-1]
	test	rax, rax
	sete	r8b
	add	r8, rax
	mov	QWORD PTR offset$2$[rsp], r8
	jmp	SHORT $LN559@ZSTD_decom
$LN97@ZSTD_decom:
	mov	rax, QWORD PTR seqState$16[rbp+rcx*8-168]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r8b
	add	r8, rax
	mov	QWORD PTR offset$2$[rsp], r8

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rcx, 1
	je	SHORT $LN83@ZSTD_decom
$LN559@ZSTD_decom:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];
; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	rax, QWORD PTR seqState$16[rbp-160]
	mov	QWORD PTR seqState$16[rbp-152], rax
$LN83@ZSTD_decom:
	mov	QWORD PTR seqState$16[rbp-160], r13
	mov	r13, r8
	mov	QWORD PTR seqState$16[rbp-168], r8
$LN80@ZSTD_decom:
	mov	QWORD PTR $T8[rbp-240], r8

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	QWORD PTR $T8[rbp-248], r9

; 893  :     if (mlBits > 0)

	test	r10b, r10b
	je	SHORT $LN84@ZSTD_decom

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, r10b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx
	mov	DWORD PTR seqState$16[rbp-248], r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	mov	rax, r12
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9, rax
	mov	QWORD PTR $T2[rsp], r9
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	mov	QWORD PTR $T8[rbp-248], r9
$LN84@ZSTD_decom:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	r11b, 31
	jb	SHORT $LN86@ZSTD_decom

; 899  :         BIT_reloadDStream(&seqState->DStream);

	lea	rcx, QWORD PTR seqState$16[rbp-256]
	call	BIT_reloadDStream
	mov	r8, QWORD PTR offset$2$[rsp]
	mov	r9, QWORD PTR $T2[rsp]
	mov	r13, QWORD PTR seqState$16[rbp-168]
	mov	r15, QWORD PTR seqState$16[rbp-240]
	mov	r14d, DWORD PTR seqState$16[rbp-248]
	mov	r12, QWORD PTR seqState$16[rbp-256]
$LN86@ZSTD_decom:

; 904  :     if (llBits > 0)

	mov	rax, QWORD PTR tv4137[rbp-256]
	mov	r10d, DWORD PTR tv4136[rbp-256]
	mov	QWORD PTR $T8[rbp-256], r10
	test	al, al
	je	SHORT $LN87@ZSTD_decom

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	edx, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, r12
	shl	rax, cl
	and	edx, 63					; 0000003fH
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r10, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	mov	QWORD PTR $T8[rbp-256], r10
$LN87@ZSTD_decom:

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$12[rbp-253]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r11, r12
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 914  :         size_t const pos = seqState->pos + seq.litLength;

	mov	rcx, QWORD PTR seqState$16[rbp-128]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	mov	rax, QWORD PTR seqState$16[rbp-144]
	add	rcx, r10

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	xmm0, XMMWORD PTR $T8[rbp-256]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	cmp	r8, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	r10, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	cmova	rax, QWORD PTR seqState$16[rbp-136]

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	sub	rax, r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	r8d, DWORD PTR [r14+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	add	rax, rcx
	mov	QWORD PTR $T8[rbp-232], rax

; 917  :                                                     * No consequence though : no memory access will occur, offset is only used for prefetching */
; 918  :         seqState->pos = pos + seq.matchLength;

	lea	rax, QWORD PTR [r9+rcx]

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	xmm1, XMMWORD PTR $T8[rbp-240]

; 918  :         seqState->pos = pos + seq.matchLength;

	mov	QWORD PTR seqState$16[rbp-128], rax

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[r10+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	neg	ecx

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$4[rbp-253]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	mov	r9, r12
	shr	r9, cl
	and	r9, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, bx
	add	r9, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[r10+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$3$[rsp], r9
	mov	QWORD PTR seqState$16[rbp-216], r9
; File E:\dev\pyzstd\lib\common\bitstream.h

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r9d, DWORD PTR [r8+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$6[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r9d
	neg	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	shr	r11, cl

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r14d, DWORD PTR [r9+rdx]

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r11, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r14d
	movzx	eax, di
	add	r11, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r14d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[r10+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	neg	ecx

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	mov	rdx, QWORD PTR tv3845[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
	mov	r9, r12
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$16[rbp-184], r11
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	r9, cl
	and	r9, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, si
	add	r9, rax

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	XMMWORD PTR [rdx-24], xmm0

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$4$[rsp], r9

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	XMMWORD PTR [rdx-8], xmm1

; 1173 :             PREFETCH_L1(sequences[seqNb].match); PREFETCH_L1(sequences[seqNb].match + sequences[seqNb].matchLength - 1); /* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */

	mov	rcx, QWORD PTR [rdx]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$16[rbp-200], r9

; 1173 :             PREFETCH_L1(sequences[seqNb].match); PREFETCH_L1(sequences[seqNb].match + sequences[seqNb].matchLength - 1); /* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */

	prefetcht0 BYTE PTR [rcx]
	mov	rax, QWORD PTR [rdx-16]
	prefetcht0 BYTE PTR [rax+rcx-1]

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	mov	r8d, DWORD PTR seqNb$1$[rsp]
	mov	rax, r9
	mov	r10, QWORD PTR $T13[rbp-256]
	inc	r8d
	mov	rsi, QWORD PTR seqState$3$[rsp]
	inc	r10
	mov	rbx, QWORD PTR tv3873[rbp-256]
	add	rdx, 32					; 00000020H
	mov	r9, QWORD PTR seqState$16[rbp-176]
	mov	QWORD PTR tv3845[rbp-256], rdx
	jmp	$LN606@ZSTD_decom
$LN556@ZSTD_decom:
	mov	QWORD PTR seqState$5$[rbp-256], r11

; 1174 :         }
; 1175 :         RETURN_ERROR_IF(seqNb<seqAdvance, corruption_detected, "");

	cmp	r8d, DWORD PTR seqAdvance$1$[rsp]
	jl	$LN560@ZSTD_decom
	mov	rbx, QWORD PTR op$1$[rsp]
	mov	rdi, QWORD PTR litPtr$1$[rsp]
$LL540@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 418  :     if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */

	cmp	r14d, 64				; 00000040H
	ja	$LN9@ZSTD_decom

; 419  :         return BIT_DStream_overflow;
; 420  : 
; 421  :     if (bitD->ptr >= bitD->limitPtr) {

	cmp	r15, QWORD PTR seqState$16[rbp-224]
	jb	SHORT $LN199@ZSTD_decom

; 405  :     bitD->ptr -= bitD->bitsConsumed >> 3;

	mov	eax, r14d
	shr	rax, 3
	sub	r15, rax

; 406  :     bitD->bitsConsumed &= 7;

	and	r14d, 7

; 422  :         return BIT_reloadDStreamFast(bitD);

	jmp	SHORT $LN607@ZSTD_decom
$LN199@ZSTD_decom:

; 424  :     if (bitD->ptr == bitD->start) {

	mov	r9, QWORD PTR seqState$16[rbp-232]
	cmp	r15, r9
	je	SHORT $LN555@ZSTD_decom

; 425  :         if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;
; 426  :         return BIT_DStream_completed;
; 427  :     }
; 428  :     /* start < ptr < limitPtr */
; 429  :     {   U32 nbBytes = bitD->bitsConsumed >> 3;

	mov	edx, r14d

; 430  :         BIT_DStream_status result = BIT_DStream_unfinished;
; 431  :         if (bitD->ptr - nbBytes < bitD->start) {

	mov	rcx, r15
	shr	edx, 3
	mov	eax, edx
	sub	rcx, rax
	cmp	rcx, r9
	jae	SHORT $LN202@ZSTD_decom

; 432  :             nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */

	mov	eax, DWORD PTR seqState$16[rbp-240]
	sub	eax, r9d
	mov	ecx, eax

; 433  :             result = BIT_DStream_endOfBuffer;

	sub	r15, rcx
	imul	eax, eax, -8				; fffffff8H
	jmp	SHORT $LN608@ZSTD_decom
$LN202@ZSTD_decom:

; 434  :         }
; 435  :         bitD->ptr -= nbBytes;

	mov	eax, edx
	sub	r15, rax

; 436  :         bitD->bitsConsumed -= nbBytes*8;

	imul	eax, edx, -8				; fffffff8H
$LN608@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1178 :         for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb<nbSeq) ; seqNb++) {

	add	r14d, eax
$LN607@ZSTD_decom:
	mov	r12, QWORD PTR [r15]
	mov	QWORD PTR seqState$16[rbp-256], r12
	mov	QWORD PTR seqState$16[rbp-240], r15
	mov	DWORD PTR seqState$16[rbp-248], r14d
$LN555@ZSTD_decom:
	cmp	r8d, DWORD PTR nbSeq$[rbp-256]
	jge	$LN598@ZSTD_decom

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rax, QWORD PTR seqState$16[rbp-176]
	mov	rbx, QWORD PTR seqState$16[rbp-208]
	mov	rdi, QWORD PTR seqState$5$[rbp-256]
	mov	rbx, QWORD PTR [rbx+rsi*8]
	mov	rdi, QWORD PTR [rax+rdi*8]
	mov	r11, rbx

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rax, QWORD PTR seqState$4$[rsp]
	mov	r9, rdi
	mov	rsi, QWORD PTR seqState$16[rbp-192]
	mov	rcx, rbx
	shr	r11, 16
	mov	rdx, rdi
	shr	r9, 16
	shr	rcx, 32					; 00000020H
	mov	rsi, QWORD PTR [rsi+rax*8]
	shr	rdx, 32					; 00000020H
	mov	rax, rsi
	shr	rax, 16
	mov	r8, rsi
	shr	r8, 32					; 00000020H
	mov	QWORD PTR llDInfo$11[rbp-256], rbx
	mov	QWORD PTR tv4077[rbp-256], r11

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;

	lea	r10d, DWORD PTR [r9+rax]
	mov	QWORD PTR tv4076[rbp-256], rcx
	add	r10b, r11b
	mov	QWORD PTR mlDInfo$10[rbp-256], rdi
	mov	QWORD PTR $T1[rsp], rdx
	mov	QWORD PTR ofDInfo$9[rbp-256], rsi
	mov	QWORD PTR tv4072[rbp-256], r8

; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	cmp	al, 1
	jbe	SHORT $LN208@ZSTD_decom

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, r8d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, r12

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	mov	r8d, DWORD PTR tv4072[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shr	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r8, rdx
	mov	QWORD PTR offset$2$[rsp], r8

; 866  :                 if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);
; 867  :             }
; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];
; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];
; 870  :             seqState->prevOffset[0] = offset;
; 871  :         } else {

	jmp	$LN558@ZSTD_decom
$LN208@ZSTD_decom:

; 872  :             U32 const ll0 = (llBase == 0);

	test	ecx, ecx
	mov	DWORD PTR ll0$1$[rsp], 0
	sete	BYTE PTR ll0$1$[rsp]

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN214@ZSTD_decom

; 874  :                 if (LIKELY(!ll0))

	test	ecx, ecx
	je	SHORT $LN216@ZSTD_decom

; 875  :                     offset = seqState->prevOffset[0];

	mov	r8, r13
	mov	QWORD PTR offset$2$[rsp], r13
	jmp	$LN215@ZSTD_decom
$LN216@ZSTD_decom:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];

	mov	rax, QWORD PTR seqState$16[rbp-160]

; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$16[rbp-160], r13
	mov	r8, rax
	mov	QWORD PTR offset$2$[rsp], rax

; 879  :                     seqState->prevOffset[0] = offset;

	mov	r13, rax
	mov	QWORD PTR seqState$16[rbp-168], rax

; 880  :                 }
; 881  :             } else {

	jmp	$LN215@ZSTD_decom
$LN214@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
	mov	rdx, r12
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	inc	r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	mov	ecx, DWORD PTR ll0$1$[rsp]
	add	ecx, r8d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	add	rcx, rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r14d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	xor	r8d, r8d
	cmp	rcx, 3
	jne	SHORT $LN232@ZSTD_decom
	lea	rax, QWORD PTR [r13-1]
	test	rax, rax
	sete	r8b
	add	r8, rax
	mov	QWORD PTR offset$2$[rsp], r8
	jmp	SHORT $LN558@ZSTD_decom
$LN232@ZSTD_decom:
	mov	rax, QWORD PTR seqState$16[rbp+rcx*8-168]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r8b
	add	r8, rax
	mov	QWORD PTR offset$2$[rsp], r8

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rcx, 1
	je	SHORT $LN218@ZSTD_decom
$LN558@ZSTD_decom:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];
; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	rax, QWORD PTR seqState$16[rbp-160]
	mov	QWORD PTR seqState$16[rbp-152], rax
$LN218@ZSTD_decom:
	mov	rdx, QWORD PTR $T1[rsp]
	mov	QWORD PTR seqState$16[rbp-160], r13
	mov	r13, r8
	mov	QWORD PTR seqState$16[rbp-168], r8
$LN215@ZSTD_decom:
	mov	QWORD PTR $T7[rbp-240], r8

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	QWORD PTR $T7[rbp-248], rdx

; 893  :     if (mlBits > 0)

	test	r9b, r9b
	je	SHORT $LN219@ZSTD_decom
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, r9b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx
	mov	DWORD PTR seqState$16[rbp-248], r14d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	mov	rax, r12
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	mov	rcx, QWORD PTR $T1[rsp]
	add	rcx, rax
	mov	QWORD PTR $T1[rsp], rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	mov	QWORD PTR $T7[rbp-248], rcx
$LN219@ZSTD_decom:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	r10b, 31
	jb	SHORT $LN221@ZSTD_decom

; 899  :         BIT_reloadDStream(&seqState->DStream);

	lea	rcx, QWORD PTR seqState$16[rbp-256]
	call	BIT_reloadDStream
	mov	r8, QWORD PTR offset$2$[rsp]
	mov	r11, QWORD PTR tv4077[rbp-256]
	mov	r13, QWORD PTR seqState$16[rbp-168]
	mov	r15, QWORD PTR seqState$16[rbp-240]
	mov	r14d, DWORD PTR seqState$16[rbp-248]
	mov	r12, QWORD PTR seqState$16[rbp-256]
$LN221@ZSTD_decom:

; 900  :     /* Ensure there are enough bits to read the rest of data in 64-bit mode. */
; 901  :     ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);
; 902  : 
; 903  :     seq.litLength = llBase;

	mov	r9d, DWORD PTR tv4076[rbp-256]
	mov	QWORD PTR $T7[rbp-256], r9

; 904  :     if (llBits > 0)

	test	r11b, r11b
	je	SHORT $LN222@ZSTD_decom

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	edx, r11b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r14d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r14d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rax, r12
	shl	rax, cl
	and	edx, 63					; 0000003fH
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	mov	QWORD PTR $T7[rbp-256], r9
$LN222@ZSTD_decom:

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$11[rbp-253]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	lea	r10, OFFSET FLAT:__ImageBase
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 914  :         size_t const pos = seqState->pos + seq.litLength;

	mov	rcx, QWORD PTR seqState$16[rbp-128]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	mov	rax, QWORD PTR seqState$16[rbp-144]
	add	rcx, r9
	cmp	r8, rcx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r9, r12
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	cmova	rax, QWORD PTR seqState$16[rbp-136]

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	sub	rax, r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	lea	r8d, DWORD PTR [r14+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	add	rax, rcx
	mov	QWORD PTR $T7[rbp-232], rax

; 917  :                                                     * No consequence though : no memory access will occur, offset is only used for prefetching */
; 918  :         seqState->pos = pos + seq.matchLength;

	mov	rax, QWORD PTR $T1[rsp]
	add	rax, rcx

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r8d
	neg	ecx

; 918  :         seqState->pos = pos + seq.matchLength;

	mov	QWORD PTR seqState$16[rbp-128], rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[r10+rdx*4]
	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$10[rbp-253]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	shr	r9, cl
	and	r9, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, bx

; 709  :     BYTE* const oLitEnd = op + sequence.litLength;

	mov	rbx, QWORD PTR op$1$[rsp]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	r9, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[r10+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$3$[rsp], r9
	mov	QWORD PTR seqState$16[rbp-216], r9
; File E:\dev\pyzstd\lib\common\bitstream.h

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r9d, DWORD PTR [r8+rdx]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$9[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	ecx, r9d
	neg	ecx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r12
	and	ecx, 63					; 0000003fH
	shr	r8, cl
	and	r8, rax

; 379  :     size_t const value = BIT_lookBits(bitD, nbBits);

	lea	r14d, DWORD PTR [rdx+r9]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, di
	mov	ecx, r14d
	add	r8, rax
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$16[rbp-248], r14d

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	eax, DWORD PTR BIT_mask[r10+rdx*4]
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	neg	ecx
	mov	QWORD PTR seqState$5$[rbp-256], r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	ecx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$16[rbp-184], r8
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	mov	r8, r12
	shr	r8, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1180 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	lea	rcx, QWORD PTR sequences$17[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 330  :     return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];

	and	r8, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	eax, si
	add	r8, rax

; 1180 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	mov	eax, DWORD PTR seqNb$1$[rsp]
	and	eax, 3

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$4$[rsp], r8

; 1180 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	shl	rax, 5
	add	rax, rcx

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$16[rbp-200], r8

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	mov	r8, QWORD PTR litPtr$1$[rsp]

; 1180 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	mov	QWORD PTR tv4306[rbp-256], rax
	movups	xmm0, XMMWORD PTR [rax]

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	mov	r11, QWORD PTR [rax+16]
	mov	QWORD PTR $T3[rbp-256], r11
	movq	r10, xmm0
	psrldq	xmm0, 8
	movq	r9, xmm0
	mov	QWORD PTR $T5[rbp-256], r9
	lea	rcx, QWORD PTR [r10+r8]
	lea	rdi, QWORD PTR [r10+rbx]
	mov	QWORD PTR iLitEnd$1$[rbp-256], rcx
	mov	rdx, rdi
	lea	rsi, QWORD PTR [r9+r10]
	sub	rdx, r11

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, QWORD PTR lastLLSize$1$[rbp-256]
	ja	$LN334@ZSTD_decom

; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */

	mov	rax, QWORD PTR oend$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+rbx]

; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rax, -32				; ffffffffffffffe0H

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN596@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rbx], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r10, 16
	jbe	SHORT $LN350@ZSTD_decom

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	lea	rax, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	r10, -16
	add	r10, rax
	lea	rcx, QWORD PTR [r8+16]
	npad	1
$LL351@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r10
	jb	SHORT $LL351@ZSTD_decom
$LN350@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 747  :     *litPtr = iLitEnd;   /* update for next sequence */

	mov	r8, QWORD PTR iLitEnd$1$[rbp-256]

; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	rax, rdi
	mov	rcx, QWORD PTR prefixStart$1$[rbp-256]
	sub	rax, rcx
	mov	QWORD PTR litPtr$1$[rsp], r8
	mov	QWORD PTR litPtr$[rsp], r8
	cmp	r11, rax
	jbe	SHORT $LN336@ZSTD_decom

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rdi
	sub	rax, QWORD PTR dictStart$1$[rbp-256]
	cmp	r11, rax
	ja	$LN551@ZSTD_decom

; 753  :         match = dictEnd + (match - prefixStart);

	mov	r8, QWORD PTR dictEnd$1$[rbp-256]
	mov	rax, r8
	sub	rax, rcx

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	mov	rcx, rdi
	add	rdx, rax
	lea	rax, QWORD PTR [r9+rdx]
	cmp	rax, r8
	ja	SHORT $LN339@ZSTD_decom

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r9
	call	memmove

; 756  :             return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	$LN332@ZSTD_decom
$LN339@ZSTD_decom:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	mov	rbx, r8
	sub	rbx, rdx

; 760  :             memmove(oLitEnd, match, length1);

	mov	r8, rbx
	call	memmove

; 762  :             sequence.matchLength -= length1;

	mov	r9, QWORD PTR $T5[rbp-256]
	add	rdi, rbx

; 763  :             match = prefixStart;

	mov	rdx, QWORD PTR prefixStart$1$[rbp-256]
	sub	r9, rbx
	mov	rbx, QWORD PTR op$1$[rsp]
	mov	r11, QWORD PTR $T3[rbp-256]
$LN336@ZSTD_decom:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	cmp	r11, 16
	jb	SHORT $LN340@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [r9+rdi]
	sub	rdx, rdi
	npad	3
$LL363@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi+rdx]
	movups	XMMWORD PTR [rdi], xmm0

; 289  :             COPY16(op, ip);

	add	rdi, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdi, rax
	jb	SHORT $LL363@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	$LN332@ZSTD_decom
$LN340@ZSTD_decom:

; 585  :     if (offset < 8) {

	cmp	r11, 8
	jae	SHORT $LN370@ZSTD_decom

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rdi], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rdi+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rcx+r11*4]
	add	rdx, rax

; 595  :         ZSTD_copy4(*op+4, *ip);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rcx+r11*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN371@ZSTD_decom
$LN370@ZSTD_decom:

; 598  :         ZSTD_copy8(*op, *ip);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
$LN371@ZSTD_decom:

; 788  :     if (sequence.matchLength > 8) {

	cmp	r9, 8
	jbe	SHORT $LN378@ZSTD_decom

; 600  :     *ip += 8;

	lea	rcx, QWORD PTR [rdx+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	r9, -8
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 601  :     *op += 8;

	lea	rdx, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	r8, rcx
	mov	rax, rdx

; 270  :     BYTE* const oend = op + length;

	add	r9, rdx
	sub	rax, rcx
	sub	r8, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rax, 16
	jge	SHORT $LL379@ZSTD_decom
	npad	5
$LL376@ZSTD_decom:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rax, QWORD PTR [r8+rdx]
	mov	QWORD PTR [rdx], rax
	add	rdx, 8

; 278  :         } while (op < oend);

	cmp	rdx, r9
	jb	SHORT $LL376@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	SHORT $LN332@ZSTD_decom
	npad	9
$LL379@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 289  :             COPY16(op, ip);

	add	rdx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdx, r9
	jb	SHORT $LL379@ZSTD_decom
$LN378@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	rdi, QWORD PTR litPtr$1$[rsp]
	jmp	SHORT $LN332@ZSTD_decom
$LN596@ZSTD_decom:

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	mov	rax, QWORD PTR tv4306[rbp-256]
$LN334@ZSTD_decom:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	movups	xmm0, XMMWORD PTR [rax]
	mov	rdx, QWORD PTR oend$1$[rbp-256]
	lea	r9, QWORD PTR litPtr$[rsp]
	movups	xmm1, XMMWORD PTR [rax+16]
	mov	rax, QWORD PTR dictEnd$1$[rbp-256]
	lea	r8, QWORD PTR $T15[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, rbx
	mov	rax, QWORD PTR dictStart$1$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR lastLLSize$1$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T15[rbp-256], xmm0
	movaps	XMMWORD PTR $T15[rbp-240], xmm1
	call	ZSTD_execSequenceEnd
	mov	rdi, QWORD PTR litPtr$[rsp]
	mov	rsi, rax
	mov	QWORD PTR litPtr$1$[rsp], rdi
$LN332@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rsi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1185 :             if (ZSTD_isError(oneSeqSize)) return oneSeqSize;

	ja	SHORT $LN455@ZSTD_decom

; 1186 :             PREFETCH_L1(sequence.match); PREFETCH_L1(sequence.match + sequence.matchLength - 1); /* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */

	mov	rcx, QWORD PTR $T7[rbp-232]
	prefetcht0 BYTE PTR [rcx]
	mov	rax, QWORD PTR $T1[rsp]
	prefetcht0 BYTE PTR [rax+rcx-1]

; 1187 :             sequences[seqNb & STORED_SEQS_MASK] = sequence;

	mov	rax, QWORD PTR tv4306[rbp-256]

; 1188 :             op += oneSeqSize;

	add	rbx, rsi
	mov	r8d, DWORD PTR seqNb$1$[rsp]
	movups	xmm0, XMMWORD PTR $T7[rbp-256]
	mov	rsi, QWORD PTR seqState$3$[rsp]
	inc	r8d
	movups	xmm1, XMMWORD PTR $T7[rbp-240]
	mov	QWORD PTR op$1$[rsp], rbx
	movups	XMMWORD PTR [rax], xmm0
	mov	DWORD PTR seqNb$1$[rsp], r8d
	movups	XMMWORD PTR [rax+16], xmm1
	jmp	$LL540@ZSTD_decom
$LN551@ZSTD_decom:

; 1218 : }

	mov	rsi, -20
$LN455@ZSTD_decom:
	mov	rax, rsi
	jmp	$LN1@ZSTD_decom
$LN9@ZSTD_decom:

; 1189 :         }
; 1190 :         RETURN_ERROR_IF(seqNb<nbSeq, corruption_detected, "");

	mov	r13d, DWORD PTR nbSeq$[rbp-256]
	cmp	r8d, r13d
	jge	SHORT $LN23@ZSTD_decom
$LN560@ZSTD_decom:
	mov	rax, -20
	jmp	$LN1@ZSTD_decom
$LN598@ZSTD_decom:

; 1178 :         for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb<nbSeq) ; seqNb++) {

	mov	r13d, DWORD PTR nbSeq$[rbp-256]
$LN23@ZSTD_decom:

; 1191 : 
; 1192 :         /* finish queue */
; 1193 :         seqNb -= seqAdvance;

	sub	r8d, DWORD PTR seqAdvance$1$[rsp]
	mov	DWORD PTR seqNb$1$[rsp], r8d

; 1194 :         for ( ; seqNb<nbSeq ; seqNb++) {

	cmp	r8d, r13d
	jge	$LN12@ZSTD_decom
	mov	r12, QWORD PTR litPtr$1$[rsp]
$LL13@ZSTD_decom:

; 723  :     if (UNLIKELY(

	mov	r11, QWORD PTR lastLLSize$1$[rbp-256]

; 1195 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[seqNb&STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	lea	r9, QWORD PTR sequences$17[rbp-256]
	mov	eax, r8d
	and	eax, 3
	shl	rax, 5
	add	r9, rax
	movups	xmm0, XMMWORD PTR [r9]

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	mov	r15, QWORD PTR [r9+16]
	movq	r8, xmm0
	psrldq	xmm0, 8
	movq	r14, xmm0
	lea	rdi, QWORD PTR [r8+rbx]
	mov	rdx, rdi
	lea	r10, QWORD PTR [r8+r12]
	sub	rdx, r15
	lea	rsi, QWORD PTR [r14+r8]

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	r10, r11
	ja	$LN389@ZSTD_decom

; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */

	mov	rax, QWORD PTR oend$1$[rbp-256]
	lea	rcx, QWORD PTR [rsi+rbx]

; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rax, -32				; ffffffffffffffe0H

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN389@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR [rbx], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r8, 16
	jbe	SHORT $LN405@ZSTD_decom

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	lea	rax, QWORD PTR [rbx+16]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rax-16]
	add	r9, r8
	lea	rcx, QWORD PTR [r12+16]
	npad	3
$LL406@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL406@ZSTD_decom
$LN405@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	r13, QWORD PTR prefixStart$1$[rbp-256]
	mov	rax, rdi
	sub	rax, r13
	mov	QWORD PTR litPtr$1$[rsp], r10
	mov	QWORD PTR litPtr$[rsp], r10
	mov	r12, r10
	cmp	r15, rax
	jbe	SHORT $LN391@ZSTD_decom

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rdi
	sub	rax, QWORD PTR dictStart$1$[rbp-256]
	cmp	r15, rax
	ja	$LN551@ZSTD_decom

; 753  :         match = dictEnd + (match - prefixStart);

	mov	rcx, QWORD PTR dictEnd$1$[rbp-256]
	mov	rax, rcx
	sub	rax, r13
	add	rdx, rax

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	lea	rax, QWORD PTR [r14+rdx]
	cmp	rax, rcx
	ja	SHORT $LN394@ZSTD_decom

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r14
	mov	rcx, rdi
	call	memmove

; 756  :             return sequenceLength;

	mov	r13d, DWORD PTR nbSeq$[rbp-256]
	jmp	$LN387@ZSTD_decom
$LN394@ZSTD_decom:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	mov	rbx, rcx

; 760  :             memmove(oLitEnd, match, length1);

	mov	rcx, rdi
	sub	rbx, rdx
	mov	r8, rbx
	call	memmove

; 761  :             op = oLitEnd + length1;

	add	rdi, rbx

; 763  :             match = prefixStart;

	mov	rdx, r13
	sub	r14, rbx
	mov	rbx, QWORD PTR op$1$[rsp]
$LN391@ZSTD_decom:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	cmp	r15, 16
	jb	SHORT $LN395@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [r14+rdi]
	sub	rdx, rdi
	npad	8
$LL418@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi+rdx]
	movups	XMMWORD PTR [rdi], xmm0

; 289  :             COPY16(op, ip);

	add	rdi, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdi, rax
	jb	SHORT $LL418@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	mov	r13d, DWORD PTR nbSeq$[rbp-256]
	jmp	$LN387@ZSTD_decom
$LN395@ZSTD_decom:

; 585  :     if (offset < 8) {

	cmp	r15, 8
	jae	SHORT $LN425@ZSTD_decom

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rdi], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rdi+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rcx+r15*4]
	add	rdx, rax

; 595  :         ZSTD_copy4(*op+4, *ip);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rcx+r15*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN426@ZSTD_decom
$LN425@ZSTD_decom:

; 598  :         ZSTD_copy8(*op, *ip);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
$LN426@ZSTD_decom:

; 788  :     if (sequence.matchLength > 8) {

	cmp	r14, 8
	jbe	SHORT $LN433@ZSTD_decom

; 600  :     *ip += 8;

	add	rdx, 8

; 601  :     *op += 8;

	lea	rax, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rax-8]
	mov	r8, rdx
	mov	rcx, rax
	add	r9, r14
	sub	r8, rax
	sub	rcx, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rcx, 16
	jge	SHORT $LL434@ZSTD_decom
	npad	3
$LL431@ZSTD_decom:

; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)

	mov	rcx, QWORD PTR [rax+r8]
	mov	QWORD PTR [rax], rcx
	add	rax, 8

; 278  :         } while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL431@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	r13d, DWORD PTR nbSeq$[rbp-256]
	jmp	SHORT $LN387@ZSTD_decom
	npad	7
$LL434@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rax+r8]
	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL434@ZSTD_decom
$LN433@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	r13d, DWORD PTR nbSeq$[rbp-256]
	jmp	SHORT $LN387@ZSTD_decom
$LN389@ZSTD_decom:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	movups	xmm0, XMMWORD PTR [r9]
	mov	rax, QWORD PTR dictEnd$1$[rbp-256]
	lea	r8, QWORD PTR $T14[rbp-256]
	movups	xmm1, XMMWORD PTR [r9+16]
	mov	rdx, QWORD PTR oend$1$[rbp-256]
	lea	r9, QWORD PTR litPtr$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, rbx
	mov	rax, QWORD PTR dictStart$1$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$1$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r11
	movaps	XMMWORD PTR $T14[rbp-256], xmm0
	movaps	XMMWORD PTR $T14[rbp-240], xmm1
	call	ZSTD_execSequenceEnd
	mov	r12, QWORD PTR litPtr$[rsp]
	mov	rsi, rax
	mov	QWORD PTR litPtr$1$[rsp], r12
$LN387@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rsi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1200 :             if (ZSTD_isError(oneSeqSize)) return oneSeqSize;

	ja	$LN455@ZSTD_decom

; 1201 :             op += oneSeqSize;

	mov	r8d, DWORD PTR seqNb$1$[rsp]
	add	rbx, rsi
	inc	r8d
	mov	QWORD PTR op$1$[rsp], rbx
	mov	DWORD PTR seqNb$1$[rsp], r8d
	cmp	r8d, r13d
	jl	$LL13@ZSTD_decom

; 1194 :         for ( ; seqNb<nbSeq ; seqNb++) {

	mov	rdi, QWORD PTR litPtr$1$[rsp]
$LN12@ZSTD_decom:

; 1202 :         }
; 1203 : 
; 1204 :         /* save reps for next block */
; 1205 :         { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }

	mov	rcx, QWORD PTR dctx$GSCopy$1$[rbp-256]
	mov	eax, DWORD PTR seqState$16[rbp-168]
	mov	r8, QWORD PTR oend$1$[rbp-256]
	mov	rsi, QWORD PTR lastLLSize$1$[rbp-256]
	mov	r15, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rcx+26684], eax
	mov	eax, DWORD PTR seqState$16[rbp-160]
	mov	DWORD PTR [rcx+26688], eax
	mov	eax, DWORD PTR seqState$16[rbp-152]
	mov	DWORD PTR [rcx+26692], eax
$LN15@ZSTD_decom:

; 1206 :     }
; 1207 : 
; 1208 :     /* last literal segment */
; 1209 :     {   size_t const lastLLSize = litEnd - litPtr;

	sub	rsi, rdi

; 1210 :         RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");

	sub	r8, rbx
	cmp	rsi, r8
	jbe	SHORT $LN26@ZSTD_decom
	mov	rax, -70				; ffffffffffffffbaH
	jmp	SHORT $LN1@ZSTD_decom
$LN26@ZSTD_decom:

; 1211 :         if (op != NULL) {

	test	rbx, rbx
	je	SHORT $LN28@ZSTD_decom

; 1212 :             memcpy(op, litPtr, lastLLSize);

	mov	r8, rsi
	mov	rdx, rdi
	mov	rcx, rbx
	call	memcpy

; 1213 :             op += lastLLSize;

	add	rbx, rsi
$LN28@ZSTD_decom:

; 1214 :         }
; 1215 :     }
; 1216 : 
; 1217 :     return op-ostart;

	sub	rbx, r15
	mov	rax, rbx
$LN1@ZSTD_decom:

; 1218 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 632				; 00000278H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_decompressSequencesLong_body ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\bitstream.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
; File E:\dev\pyzstd\lib\common\error_private.h
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
totalBits$1$ = 64
totalBits$1$ = 64
seqNb$1$ = 68
litPtr$1 = 72
$T2 = 80
$T3 = 80
seqAdvance$1$ = 88
lastLLSize$1$ = 96
prefixStart$1$ = 104
oend$1$ = 112
$T4 = 120
tv3590 = 120
llDInfo$5 = 120
ll0$1$ = 128
tv3193 = 128
dictEnd$1$ = 136
dictStart$1$ = 144
$T6 = 152
$T7 = 152
ofDInfo$8 = 184
mlDInfo$9 = 184
mlDInfo$10 = 192
ofDInfo$11 = 192
tv3441 = 200
tv3443 = 208
llDInfo$12 = 216
dctx$GSCopy$1$ = 224
dst$GSCopy$1$ = 232
$T13 = 240
$T14 = 240
seqState$15 = 272
sequences$16 = 416
__$ArrayPad$ = 544
dctx$ = 640
dst$ = 648
maxDstSize$ = 656
seqStart$ = 664
seqSize$ = 672
nbSeq$ = 680
isLongOffset$dead$ = 688
frame$dead$ = 696
ZSTD_decompressSequencesLong_default PROC

; 1226 : {

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-312]
	sub	rsp, 568				; 00000238H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1141 :     const BYTE* const litEnd = litPtr + dctx->litSize;

	mov	rbx, QWORD PTR [rcx+28984]
	lea	r10, QWORD PTR [r8+rdx]

; 1145 :     (void)frame;
; 1146 : 
; 1147 :     /* Regen sequences */
; 1148 :     if (nbSeq) {

	mov	edi, DWORD PTR nbSeq$[rbp-256]

; 1226 : {

	mov	r14, rcx
	mov	r12, rdx
	mov	QWORD PTR dst$GSCopy$1$[rbp-256], rdx

; 1139 :     BYTE* op = ostart;

	mov	r15, rdx
	mov	QWORD PTR $T4[rsp], rdx

; 1140 :     const BYTE* litPtr = dctx->litPtr;

	mov	rdx, QWORD PTR [rcx+28952]

; 1143 :     const BYTE* const dictStart = (const BYTE*) (dctx->virtualStart);

	mov	rax, QWORD PTR [r14+28760]
	add	rbx, rdx

; 1144 :     const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);

	mov	r8, QWORD PTR [r14+28768]

; 1226 : {

	mov	QWORD PTR dctx$GSCopy$1$[rbp-256], rcx

; 1142 :     const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);

	mov	rcx, QWORD PTR [rcx+28752]

; 1143 :     const BYTE* const dictStart = (const BYTE*) (dctx->virtualStart);

	mov	QWORD PTR dictStart$1$[rbp-256], rax

; 1144 :     const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);

	mov	QWORD PTR dictEnd$1$[rbp-256], r8
	mov	QWORD PTR oend$1$[rsp], r10
	mov	QWORD PTR litPtr$1[rsp], rdx
	mov	QWORD PTR lastLLSize$1$[rsp], rbx
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 1145 :     (void)frame;
; 1146 : 
; 1147 :     /* Regen sequences */
; 1148 :     if (nbSeq) {

	test	edi, edi
	je	$LN17@ZSTD_decom

; 1149 : #define STORED_SEQS 4
; 1150 : #define STORED_SEQS_MASK (STORED_SEQS-1)
; 1151 : #define ADVANCED_SEQS 4
; 1152 :         seq_t sequences[STORED_SEQS];
; 1153 :         int const seqAdvance = MIN(nbSeq, ADVANCED_SEQS);
; 1154 :         seqState_t seqState;
; 1155 :         int seqNb;
; 1156 :         dctx->fseEntropy = 1;

	mov	DWORD PTR [r14+28844], 1
	mov	esi, 4

; 1157 :         { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }

	mov	eax, DWORD PTR [r14+26684]
	cmp	edi, esi
	mov	QWORD PTR seqState$15[rbp-168], rax

; 1163 :         RETURN_ERROR_IF(

	mov	rdx, r9
	mov	eax, DWORD PTR [r14+26688]
	cmovl	esi, edi
	mov	QWORD PTR seqState$15[rbp-160], rax
	mov	eax, DWORD PTR [r14+26692]
	mov	QWORD PTR seqState$15[rbp-152], rax
	mov	rax, r15
	sub	rax, rcx
	mov	QWORD PTR seqState$15[rbp-144], rcx
	mov	QWORD PTR seqState$15[rbp-136], r8
	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	r8, QWORD PTR seqSize$[rbp-256]
	mov	QWORD PTR seqState$15[rbp-128], rax
	mov	DWORD PTR seqAdvance$1$[rsp], esi
	call	BIT_initDStream
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rax, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1163 :         RETURN_ERROR_IF(

	ja	$LN807@ZSTD_decom

; 1164 :             ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),
; 1165 :             corruption_detected, "");
; 1166 :         ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);

	mov	rbx, QWORD PTR [r14]

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	edx, DWORD PTR [rbx+4]
	call	BIT_readBits

; 801  :     DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
; 802  :                 (U32)DStatePtr->state, DTableH->tableLog);
; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	QWORD PTR seqState$15[rbp-216], rax
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]

; 1167 :         ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);

	mov	rbx, QWORD PTR [r14+16]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$15[rbp-208], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	edx, DWORD PTR [rbx+4]
	call	BIT_readBits

; 801  :     DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
; 802  :                 (U32)DStatePtr->state, DTableH->tableLog);
; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	QWORD PTR seqState$15[rbp-200], rax
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]

; 1168 :         ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);

	mov	rbx, QWORD PTR [r14+8]

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$15[rbp-192], rax

; 800  :     DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	edx, DWORD PTR [rbx+4]
	call	BIT_readBits

; 801  :     DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
; 802  :                 (U32)DStatePtr->state, DTableH->tableLog);
; 803  :     BIT_reloadDStream(bitD);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	QWORD PTR seqState$15[rbp-184], rax
	call	BIT_reloadDStream

; 804  :     DStatePtr->table = dt + 1;

	lea	rax, QWORD PTR [rbx+8]

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	xor	ebx, ebx
	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	DWORD PTR seqNb$1$[rsp], ebx

; 804  :     DStatePtr->table = dt + 1;

	mov	QWORD PTR seqState$15[rbp-176], rax

; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	call	BIT_reloadDStream
	cmp	eax, 2
	jg	$LN8@ZSTD_decom
	xor	edi, edi
	movsxd	r15, esi
	lea	rax, QWORD PTR sequences$16[rbp-232]
	mov	QWORD PTR $T3[rsp], rdi
	mov	QWORD PTR tv3193[rbp-256], rax
$LL9@ZSTD_decom:
	cmp	rdi, r15
	jge	$LN795@ZSTD_decom

; 841  :     ZSTD_seqSymbol const llDInfo = seqState->stateLL.table[seqState->stateLL.state];

	mov	rax, QWORD PTR seqState$15[rbp-216]
	mov	rbx, QWORD PTR seqState$15[rbp-208]

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rdi, QWORD PTR seqState$15[rbp-176]

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rsi, QWORD PTR seqState$15[rbp-192]

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;
; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	mov	r10, QWORD PTR seqState$15[rbp-256]
	mov	rbx, QWORD PTR [rbx+rax*8]
	mov	rax, QWORD PTR seqState$15[rbp-184]
	mov	rcx, rbx
	mov	r9d, DWORD PTR seqState$15[rbp-248]
	mov	r13, rbx
	shr	rcx, 16
	shr	r13, 32					; 00000020H
	mov	rdi, QWORD PTR [rdi+rax*8]
	mov	rax, QWORD PTR seqState$15[rbp-200]
	mov	r8, rdi
	shr	r8, 16
	mov	r12, rdi
	shr	r12, 32					; 00000020H
	mov	QWORD PTR llDInfo$12[rbp-256], rbx
	mov	rsi, QWORD PTR [rsi+rax*8]
	mov	rax, rsi
	mov	QWORD PTR tv3443[rbp-256], rcx
	shr	rax, 16
	mov	r11, rsi
	shr	r11, 32					; 00000020H
	mov	QWORD PTR mlDInfo$9[rbp-256], rdi
	mov	QWORD PTR tv3441[rbp-256], r8
	lea	edx, DWORD PTR [r8+rax]
	mov	QWORD PTR ofDInfo$11[rbp-256], rsi
	add	dl, cl
	mov	BYTE PTR totalBits$1$[rsp], dl
	cmp	al, 1
	jbe	SHORT $LN189@ZSTD_decom

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	rax, QWORD PTR seqState$15[rbp-160]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	QWORD PTR seqState$15[rbp-152], rax

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR seqState$15[rbp-168]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	r14, r10
	shl	r14, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 871  :         } else {

	mov	r8, QWORD PTR tv3441[rbp-256]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$15[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	r14, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r14, r11

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$15[rbp-160], rax

; 871  :         } else {

	jmp	$LN804@ZSTD_decom
$LN189@ZSTD_decom:

; 872  :             U32 const ll0 = (llBase == 0);

	xor	r14d, r14d
	test	r13d, r13d
	sete	r14b

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN195@ZSTD_decom

; 874  :                 if (LIKELY(!ll0))

	test	r13d, r13d
	je	SHORT $LN197@ZSTD_decom

; 875  :                     offset = seqState->prevOffset[0];

	mov	r14, QWORD PTR seqState$15[rbp-168]
	jmp	SHORT $LN196@ZSTD_decom
$LN197@ZSTD_decom:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];
; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR seqState$15[rbp-168]
	mov	r14, QWORD PTR seqState$15[rbp-160]
	mov	QWORD PTR seqState$15[rbp-160], rax

; 879  :                     seqState->prevOffset[0] = offset;
; 880  :                 }
; 881  :             } else {

	jmp	SHORT $LN804@ZSTD_decom
$LN195@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
	mov	rdx, r10
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	inc	r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	lea	ecx, DWORD PTR [r14+r11]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	xor	r14d, r14d
	add	rcx, rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$15[rbp-248], r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	mov	rdx, QWORD PTR seqState$15[rbp-168]
	cmp	rcx, 3
	jne	SHORT $LN213@ZSTD_decom
	lea	rax, QWORD PTR [rdx-1]
	test	rax, rax
	sete	r14b
	add	r14, rax
	jmp	SHORT $LN764@ZSTD_decom
$LN213@ZSTD_decom:
	mov	rax, QWORD PTR seqState$15[rbp+rcx*8-168]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r14b
	add	r14, rax

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rcx, 1
	je	SHORT $LN199@ZSTD_decom
$LN764@ZSTD_decom:
	mov	rax, QWORD PTR seqState$15[rbp-160]
	mov	QWORD PTR seqState$15[rbp-152], rax
$LN199@ZSTD_decom:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$15[rbp-160], rdx
$LN804@ZSTD_decom:

; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	QWORD PTR seqState$15[rbp-168], r14
$LN196@ZSTD_decom:
	mov	QWORD PTR $T7[rbp-240], r14

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	QWORD PTR $T7[rbp-248], r12

; 893  :     if (mlBits > 0)

	test	r8b, r8b
	je	SHORT $LN200@ZSTD_decom

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, r8b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx
	mov	DWORD PTR seqState$15[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	mov	rax, r10
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	r12, rax
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	mov	QWORD PTR $T7[rbp-248], r12
$LN200@ZSTD_decom:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	BYTE PTR totalBits$1$[rsp], 31
	jb	SHORT $LN202@ZSTD_decom

; 899  :         BIT_reloadDStream(&seqState->DStream);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	call	BIT_reloadDStream
	mov	r9d, DWORD PTR seqState$15[rbp-248]
	mov	r10, QWORD PTR seqState$15[rbp-256]
$LN202@ZSTD_decom:

; 904  :     if (llBits > 0)

	mov	rax, QWORD PTR tv3443[rbp-256]
	mov	rdx, r13
	mov	QWORD PTR $T7[rbp-256], rdx
	test	al, al
	je	SHORT $LN203@ZSTD_decom

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	eax, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shl	r10, cl

; 370  :     bitD->bitsConsumed += nbBits;

	neg	eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$15[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	movzx	ecx, al
	shr	r10, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	rdx, r10
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	mov	QWORD PTR $T7[rbp-256], rdx
$LN203@ZSTD_decom:

; 906  : 
; 907  :     if (MEM_32bits())
; 908  :         BIT_reloadDStream(&seqState->DStream);
; 909  : 
; 910  :     DEBUGLOG(6, "seq: litL=%u, matchL=%u, offset=%u",
; 911  :                 (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);
; 912  : 
; 913  :     if (prefetch == ZSTD_p_prefetch) {
; 914  :         size_t const pos = seqState->pos + seq.litLength;

	mov	rcx, QWORD PTR seqState$15[rbp-128]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	mov	rax, QWORD PTR seqState$15[rbp-144]
	add	rcx, rdx

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$12[rbp-253]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	cmp	r14, rcx
	cmova	rax, QWORD PTR seqState$15[rbp-136]

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	sub	rax, r14
	add	rax, rcx
	mov	QWORD PTR $T7[rbp-232], rax

; 917  :                                                     * No consequence though : no memory access will occur, offset is only used for prefetching */
; 918  :         seqState->pos = pos + seq.matchLength;

	lea	rax, QWORD PTR [r12+rcx]

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$15[rbp-256]

; 918  :         seqState->pos = pos + seq.matchLength;

	mov	QWORD PTR seqState$15[rbp-128], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$9[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, bx
	add	rax, rcx

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$15[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$15[rbp-216], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$11[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, di
	add	rax, rcx

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$15[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$15[rbp-184], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	xmm0, XMMWORD PTR $T7[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, si

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	mov	rsi, QWORD PTR tv3193[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	add	rax, rcx

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	xmm1, XMMWORD PTR $T7[rbp-240]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$15[rbp-200], rax

; 1172 :             sequences[seqNb] = ZSTD_decodeSequence(&seqState, isLongOffset, ZSTD_p_prefetch);

	movups	XMMWORD PTR [rsi-24], xmm0
	movups	XMMWORD PTR [rsi-8], xmm1

; 1173 :             PREFETCH_L1(sequences[seqNb].match); PREFETCH_L1(sequences[seqNb].match + sequences[seqNb].matchLength - 1); /* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */

	mov	rcx, QWORD PTR [rsi]
	prefetcht0 BYTE PTR [rcx]
	mov	rax, QWORD PTR [rsi-16]
	prefetcht0 BYTE PTR [rax+rcx-1]

; 1169 : 
; 1170 :         /* prepare in advance */
; 1171 :         for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {

	mov	ebx, DWORD PTR seqNb$1$[rsp]
	lea	rcx, QWORD PTR seqState$15[rbp-256]
	mov	rdi, QWORD PTR $T3[rsp]
	inc	ebx
	inc	rdi
	mov	DWORD PTR seqNb$1$[rsp], ebx
	add	rsi, 32					; 00000020H
	mov	QWORD PTR $T3[rsp], rdi
	mov	QWORD PTR tv3193[rbp-256], rsi
	call	BIT_reloadDStream
	cmp	eax, 2
	jle	$LL9@ZSTD_decom
$LN795@ZSTD_decom:
	mov	r15, QWORD PTR $T4[rsp]
	mov	esi, DWORD PTR seqAdvance$1$[rsp]
	mov	edi, DWORD PTR nbSeq$[rbp-256]
$LN8@ZSTD_decom:

; 1174 :         }
; 1175 :         RETURN_ERROR_IF(seqNb<seqAdvance, corruption_detected, "");

	cmp	ebx, esi
	jl	$LN807@ZSTD_decom

; 1176 : 
; 1177 :         /* decode and decompress */
; 1178 :         for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb<nbSeq) ; seqNb++) {

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	call	BIT_reloadDStream
	cmp	eax, 2
	jg	$LN11@ZSTD_decom
	npad	1
$LL12@ZSTD_decom:
	cmp	ebx, edi
	jge	$LN796@ZSTD_decom

; 841  :     ZSTD_seqSymbol const llDInfo = seqState->stateLL.table[seqState->stateLL.state];

	mov	rax, QWORD PTR seqState$15[rbp-216]
	mov	rbx, QWORD PTR seqState$15[rbp-208]

; 842  :     ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];

	mov	rdi, QWORD PTR seqState$15[rbp-176]

; 843  :     ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];

	mov	rsi, QWORD PTR seqState$15[rbp-192]

; 844  :     U32 const llBase = llDInfo.baseValue;
; 845  :     U32 const mlBase = mlDInfo.baseValue;
; 846  :     U32 const ofBase = ofDInfo.baseValue;
; 847  :     BYTE const llBits = llDInfo.nbAdditionalBits;
; 848  :     BYTE const mlBits = mlDInfo.nbAdditionalBits;
; 849  :     BYTE const ofBits = ofDInfo.nbAdditionalBits;
; 850  :     BYTE const totalBits = llBits+mlBits+ofBits;
; 851  : 
; 852  :     /* sequence */
; 853  :     {   size_t offset;
; 854  :         if (ofBits > 1) {

	mov	r10, QWORD PTR seqState$15[rbp-256]
	mov	rbx, QWORD PTR [rbx+rax*8]
	mov	rax, QWORD PTR seqState$15[rbp-184]
	mov	r13, rbx
	mov	r9d, DWORD PTR seqState$15[rbp-248]
	mov	r12, rbx
	shr	r13, 16
	shr	r12, 32					; 00000020H
	mov	rdi, QWORD PTR [rdi+rax*8]
	mov	rax, QWORD PTR seqState$15[rbp-200]
	mov	r11, rdi
	shr	r11, 16
	mov	rdx, rdi
	shr	rdx, 32					; 00000020H
	mov	QWORD PTR llDInfo$5[rsp], rbx
	mov	rsi, QWORD PTR [rsi+rax*8]
	mov	rax, rsi
	mov	QWORD PTR mlDInfo$10[rbp-256], rdi
	shr	rax, 16
	mov	r14, rsi
	shr	r14, 32					; 00000020H
	mov	QWORD PTR $T2[rsp], rdx
	mov	QWORD PTR ofDInfo$8[rbp-256], rsi
	lea	r8d, DWORD PTR [r11+rax]
	add	r8b, r13b
	mov	BYTE PTR totalBits$1$[rsp], r8b
	cmp	al, 1
	jbe	SHORT $LN398@ZSTD_decom

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	movzx	r8d, al
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	rax, QWORD PTR seqState$15[rbp-160]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 868  :             seqState->prevOffset[2] = seqState->prevOffset[1];

	mov	QWORD PTR seqState$15[rbp-152], rax

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR seqState$15[rbp-168]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	rdx, r10
	shl	rdx, cl

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	mov	ecx, r8d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 871  :         } else {

	movzx	r8d, BYTE PTR totalBits$1$[rsp]
; File E:\dev\pyzstd\lib\common\bitstream.h

; 388  :     size_t const value = BIT_lookBitsFast(bitD, nbBits);

	neg	ecx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$15[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 865  :                 offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */

	add	r14, rdx

; 869  :             seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$15[rbp-160], rax

; 871  :         } else {

	jmp	$LN805@ZSTD_decom
$LN398@ZSTD_decom:

; 872  :             U32 const ll0 = (llBase == 0);

	xor	ecx, ecx
	test	r12d, r12d
	sete	cl
	mov	DWORD PTR ll0$1$[rbp-256], ecx

; 873  :             if (LIKELY((ofBits == 0))) {

	test	al, al
	jne	SHORT $LN404@ZSTD_decom

; 874  :                 if (LIKELY(!ll0))

	test	r12d, r12d
	je	SHORT $LN406@ZSTD_decom

; 875  :                     offset = seqState->prevOffset[0];

	mov	r14, QWORD PTR seqState$15[rbp-168]
	jmp	SHORT $LN405@ZSTD_decom
$LN406@ZSTD_decom:

; 876  :                 else {
; 877  :                     offset = seqState->prevOffset[1];
; 878  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	rax, QWORD PTR seqState$15[rbp-168]
	mov	r14, QWORD PTR seqState$15[rbp-160]
	mov	QWORD PTR seqState$15[rbp-160], rax

; 879  :                     seqState->prevOffset[0] = offset;
; 880  :                 }
; 881  :             } else {

	jmp	SHORT $LN806@ZSTD_decom
$LN404@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
	mov	rdx, r10
	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	inc	r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shl	rdx, cl
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	mov	ecx, DWORD PTR ll0$1$[rbp-256]
	add	ecx, r14d
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	shr	rdx, 63					; 0000003fH
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 882  :                 offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);

	add	rcx, rdx
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$15[rbp-248], r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 883  :                 {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];

	mov	rdx, QWORD PTR seqState$15[rbp-168]
	xor	r14d, r14d
	cmp	rcx, 3
	jne	SHORT $LN422@ZSTD_decom
	lea	rax, QWORD PTR [rdx-1]
	test	rax, rax
	sete	r14b
	add	r14, rax
	jmp	SHORT $LN763@ZSTD_decom
$LN422@ZSTD_decom:
	mov	rax, QWORD PTR seqState$15[rbp+rcx*8-168]

; 884  :                     temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */

	test	rax, rax
	sete	r14b
	add	r14, rax

; 885  :                     if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];

	cmp	rcx, 1
	je	SHORT $LN408@ZSTD_decom
$LN763@ZSTD_decom:
	mov	rax, QWORD PTR seqState$15[rbp-160]
	mov	QWORD PTR seqState$15[rbp-152], rax
$LN408@ZSTD_decom:

; 886  :                     seqState->prevOffset[1] = seqState->prevOffset[0];

	mov	QWORD PTR seqState$15[rbp-160], rdx
$LN805@ZSTD_decom:

; 887  :                     seqState->prevOffset[0] = offset = temp;
; 888  :         }   }   }
; 889  :         seq.offset = offset;

	mov	rdx, QWORD PTR $T2[rsp]
$LN806@ZSTD_decom:
	mov	QWORD PTR seqState$15[rbp-168], r14
$LN405@ZSTD_decom:
	mov	QWORD PTR $T6[rbp-240], r14

; 890  :     }
; 891  : 
; 892  :     seq.matchLength = mlBase;

	mov	QWORD PTR $T6[rbp-248], rdx

; 893  :     if (mlBits > 0)

	test	r11b, r11b
	je	SHORT $LN409@ZSTD_decom
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	movzx	edx, r11b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, edx

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	neg	edx
	mov	DWORD PTR seqState$15[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	edx, 63					; 0000003fH
	mov	rax, r10
	shl	rax, cl
	movzx	ecx, dl
	shr	rax, cl

; 370  :     bitD->bitsConsumed += nbBits;

	mov	rcx, QWORD PTR $T2[rsp]
	add	rcx, rax
	mov	QWORD PTR $T2[rsp], rcx
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 894  :         seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);

	mov	QWORD PTR $T6[rbp-248], rcx
$LN409@ZSTD_decom:

; 895  : 
; 896  :     if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
; 897  :         BIT_reloadDStream(&seqState->DStream);
; 898  :     if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))

	cmp	r8b, 31
	jb	SHORT $LN411@ZSTD_decom

; 899  :         BIT_reloadDStream(&seqState->DStream);

	lea	rcx, QWORD PTR seqState$15[rbp-256]
	call	BIT_reloadDStream
	mov	r9d, DWORD PTR seqState$15[rbp-248]
	mov	r10, QWORD PTR seqState$15[rbp-256]
$LN411@ZSTD_decom:

; 900  :     /* Ensure there are enough bits to read the rest of data in 64-bit mode. */
; 901  :     ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);
; 902  : 
; 903  :     seq.litLength = llBase;

	mov	rdx, r12
	mov	QWORD PTR $T6[rbp-256], rdx

; 904  :     if (llBits > 0)

	test	r13b, r13b
	je	SHORT $LN412@ZSTD_decom

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	movzx	eax, r13b
; File E:\dev\pyzstd\lib\common\bitstream.h

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	mov	ecx, r9d

; 370  :     bitD->bitsConsumed += nbBits;

	add	r9d, eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	ecx, 63					; 0000003fH
	shl	r10, cl

; 370  :     bitD->bitsConsumed += nbBits;

	neg	eax

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	and	eax, 63					; 0000003fH

; 370  :     bitD->bitsConsumed += nbBits;

	mov	DWORD PTR seqState$15[rbp-248], r9d

; 365  :     return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);

	movzx	ecx, al
	shr	r10, cl

; 370  :     bitD->bitsConsumed += nbBits;

	add	rdx, r10
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 905  :         seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);

	mov	QWORD PTR $T6[rbp-256], rdx
$LN412@ZSTD_decom:

; 906  : 
; 907  :     if (MEM_32bits())
; 908  :         BIT_reloadDStream(&seqState->DStream);
; 909  : 
; 910  :     DEBUGLOG(6, "seq: litL=%u, matchL=%u, offset=%u",
; 911  :                 (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);
; 912  : 
; 913  :     if (prefetch == ZSTD_p_prefetch) {
; 914  :         size_t const pos = seqState->pos + seq.litLength;

	mov	rcx, QWORD PTR seqState$15[rbp-128]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	mov	rax, QWORD PTR seqState$15[rbp-144]
	add	rcx, rdx

; 917  :                                                     * No consequence though : no memory access will occur, offset is only used for prefetching */
; 918  :         seqState->pos = pos + seq.matchLength;

	mov	r13, QWORD PTR $T2[rsp]
	cmp	r14, rcx

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR llDInfo$5[rsp+3]

; 915  :         const BYTE* const matchBase = (seq.offset > pos) ? seqState->dictEnd : seqState->prefixStart;

	cmova	rax, QWORD PTR seqState$15[rbp-136]

; 916  :         seq.match = matchBase + pos - seq.offset;  /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.

	sub	rax, r14
	add	rax, rcx
	mov	QWORD PTR $T6[rbp-232], rax

; 917  :                                                     * No consequence though : no memory access will occur, offset is only used for prefetching */
; 918  :         seqState->pos = pos + seq.matchLength;

	lea	rax, QWORD PTR [rcx+r13]

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$15[rbp-256]

; 918  :         seqState->pos = pos + seq.matchLength;

	mov	QWORD PTR seqState$15[rbp-128], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR mlDInfo$10[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, bx
	add	rax, rcx

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$15[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$15[rbp-216], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 819  :     U32 const nbBits = DInfo.nbBits;

	movzx	edx, BYTE PTR ofDInfo$8[rbp-253]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, di
	add	rax, rcx

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	lea	rcx, QWORD PTR seqState$15[rbp-256]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	mov	QWORD PTR seqState$15[rbp-184], rax

; 820  :     size_t const lowBits = BIT_readBits(bitD, nbBits);

	call	BIT_readBits

; 1180 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	mov	ebx, DWORD PTR seqNb$1$[rsp]
	lea	r10, QWORD PTR sequences$16[rbp-256]

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	mov	r9, QWORD PTR litPtr$1[rsp]

; 821  :     DStatePtr->state = DInfo.nextState + lowBits;

	movzx	ecx, si
	add	rax, rcx
	mov	QWORD PTR seqState$15[rbp-200], rax

; 1180 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	mov	eax, ebx
	and	eax, 3
	shl	rax, 5
	add	r10, rax
	mov	QWORD PTR tv3590[rsp], r10
	movups	xmm0, XMMWORD PTR [r10]

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	mov	r12, QWORD PTR [r10+16]
	movq	r8, xmm0
	psrldq	xmm0, 8
	movq	r14, xmm0
	lea	rdi, QWORD PTR [r8+r15]
	mov	rdx, rdi
	lea	r11, QWORD PTR [r8+r9]
	sub	rdx, r12
	lea	rsi, QWORD PTR [r14+r8]

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	r11, QWORD PTR lastLLSize$1$[rsp]
	ja	$LN538@ZSTD_decom

; 602  :     assert(*op - *ip >= 8);
; 603  : }
; 604  : 
; 605  : /*! ZSTD_safecopy() :
; 606  :  *  Specialized version of memcpy() that is allowed to READ up to WILDCOPY_OVERLENGTH past the input buffer
; 607  :  *  and write up to 16 bytes past oend_w (op >= oend_w is allowed).
; 608  :  *  This function is only called in the uncommon case where the sequence is near the end of the block. It
; 609  :  *  should be fast for a single long sequence, but can be slow for several short sequences.
; 610  :  *
; 611  :  *  @param ovtype controls the overlap detection
; 612  :  *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
; 613  :  *         - ZSTD_overlap_src_before_dst: The src and dst may overlap and may be any distance apart.
; 614  :  *           The src buffer must be before the dst buffer.
; 615  :  */
; 616  : static void ZSTD_safecopy(BYTE* op, BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype) {
; 617  :     ptrdiff_t const diff = op - ip;
; 618  :     BYTE* const oend = op + length;
; 619  : 
; 620  :     assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||
; 621  :            (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));
; 622  : 
; 623  :     if (length < 8) {
; 624  :         /* Handle short lengths. */
; 625  :         while (op < oend) *op++ = *ip++;
; 626  :         return;
; 627  :     }
; 628  :     if (ovtype == ZSTD_overlap_src_before_dst) {
; 629  :         /* Copy 8 bytes and ensure the offset >= 8 when there can be overlap. */
; 630  :         assert(length >= 8);
; 631  :         ZSTD_overlapCopy8(&op, &ip, diff);
; 632  :         assert(op - ip >= 8);
; 633  :         assert(op <= oend);
; 634  :     }
; 635  : 
; 636  :     if (oend <= oend_w) {
; 637  :         /* No risk of overwrite. */
; 638  :         ZSTD_wildcopy(op, ip, length, ovtype);
; 639  :         return;
; 640  :     }
; 641  :     if (op <= oend_w) {
; 642  :         /* Wildcopy until we get close to the end. */
; 643  :         assert(oend > oend_w);
; 644  :         ZSTD_wildcopy(op, ip, oend_w - op, ovtype);
; 645  :         ip += oend_w - op;
; 646  :         op = oend_w;
; 647  :     }
; 648  :     /* Handle the leftovers. */
; 649  :     while (op < oend) *op++ = *ip++;
; 650  : }
; 651  : 
; 652  : /* ZSTD_execSequenceEnd():
; 653  :  * This version handles cases that are near the end of the output buffer. It requires
; 654  :  * more careful checks to make sure there is no overflow. By separating out these hard
; 655  :  * and unlikely cases, we can speed up the common cases.
; 656  :  *
; 657  :  * NOTE: This function needs to be fast for a single long sequence, but doesn't need
; 658  :  * to be optimized for many small sequences, since those fall into ZSTD_execSequence().
; 659  :  */
; 660  : FORCE_NOINLINE
; 661  : size_t ZSTD_execSequenceEnd(BYTE* op,
; 662  :                             BYTE* const oend, seq_t sequence,
; 663  :                             const BYTE** litPtr, const BYTE* const litLimit,
; 664  :                             const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
; 665  : {
; 666  :     BYTE* const oLitEnd = op + sequence.litLength;
; 667  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 668  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;
; 669  :     const BYTE* match = oLitEnd - sequence.offset;
; 670  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;
; 671  : 
; 672  :     /* bounds checks : careful of address space overflow in 32-bit mode */
; 673  :     RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, "last match must fit within dstBuffer");
; 674  :     RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, "try to read beyond literal buffer");
; 675  :     assert(op < op + sequenceLength);
; 676  :     assert(oLitEnd < op + sequenceLength);
; 677  : 
; 678  :     /* copy literals */
; 679  :     ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);
; 680  :     op = oLitEnd;
; 681  :     *litPtr = iLitEnd;
; 682  : 
; 683  :     /* copy Match */
; 684  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {
; 685  :         /* offset beyond prefix */
; 686  :         RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, "");
; 687  :         match = dictEnd - (prefixStart-match);
; 688  :         if (match + sequence.matchLength <= dictEnd) {
; 689  :             memmove(oLitEnd, match, sequence.matchLength);
; 690  :             return sequenceLength;
; 691  :         }
; 692  :         /* span extDict & currentPrefixSegment */
; 693  :         {   size_t const length1 = dictEnd - match;
; 694  :             memmove(oLitEnd, match, length1);
; 695  :             op = oLitEnd + length1;
; 696  :             sequence.matchLength -= length1;
; 697  :             match = prefixStart;
; 698  :     }   }
; 699  :     ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);
; 700  :     return sequenceLength;
; 701  : }
; 702  : 
; 703  : HINT_INLINE
; 704  : size_t ZSTD_execSequence(BYTE* op,
; 705  :                          BYTE* const oend, seq_t sequence,
; 706  :                          const BYTE** litPtr, const BYTE* const litLimit,
; 707  :                          const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
; 708  : {
; 709  :     BYTE* const oLitEnd = op + sequence.litLength;
; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */

	mov	rax, QWORD PTR oend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+r15]

; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rax, -32				; ffffffffffffffe0H

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN538@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r15], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r8, 16
	jbe	SHORT $LN556@ZSTD_decom

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	mov	rcx, QWORD PTR litPtr$1[rsp]
	lea	rax, QWORD PTR [r15+16]
	add	rcx, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	r8, -16
	add	r8, rax
$LL557@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r8
	jb	SHORT $LL557@ZSTD_decom
$LN556@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	rcx, QWORD PTR prefixStart$1$[rsp]
	mov	rax, rdi
	sub	rax, rcx
	mov	QWORD PTR litPtr$1[rsp], r11
	cmp	r12, rax
	jbe	SHORT $LN540@ZSTD_decom

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rdi
	sub	rax, QWORD PTR dictStart$1$[rbp-256]
	cmp	r12, rax
	ja	$LN759@ZSTD_decom

; 753  :         match = dictEnd + (match - prefixStart);

	mov	r8, QWORD PTR dictEnd$1$[rbp-256]
	mov	rax, r8
	sub	rax, rcx

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	mov	rcx, rdi
	add	rdx, rax
	lea	rax, QWORD PTR [r14+rdx]
	cmp	rax, r8
	ja	SHORT $LN543@ZSTD_decom

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r14
	call	memmove

; 756  :             return sequenceLength;

	jmp	$LN536@ZSTD_decom
$LN543@ZSTD_decom:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	mov	rbx, r8
	sub	rbx, rdx

; 760  :             memmove(oLitEnd, match, length1);

	mov	r8, rbx
	call	memmove

; 762  :             sequence.matchLength -= length1;
; 763  :             match = prefixStart;

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	add	rdi, rbx
	sub	r14, rbx
	mov	ebx, DWORD PTR seqNb$1$[rsp]
$LN540@ZSTD_decom:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	cmp	r12, 16
	jb	SHORT $LN544@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [r14+rdi]
	sub	rdx, rdi
	npad	7
$LL571@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi+rdx]
	movups	XMMWORD PTR [rdi], xmm0

; 289  :             COPY16(op, ip);

	add	rdi, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdi, rax
	jb	SHORT $LL571@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	jmp	$LN536@ZSTD_decom
$LN544@ZSTD_decom:

; 585  :     if (offset < 8) {

	cmp	r12, 8
	jae	SHORT $LN580@ZSTD_decom

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rdi], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rdi+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rcx+r12*4]
	add	rdx, rax

; 47   : static void ZSTD_copy4(void* dst, const void* src) { memcpy(dst, src, 4); }

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rcx+r12*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN585@ZSTD_decom
$LN580@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
$LN585@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 788  :     if (sequence.matchLength > 8) {

	cmp	r14, 8
	jbe	$LN536@ZSTD_decom

; 600  :     *ip += 8;

	lea	rcx, QWORD PTR [rdx+8]

; 601  :     *op += 8;

	lea	rdx, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;

	mov	r8, rcx

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rdx-8]
	mov	rax, rdx
	add	r9, r14
	sub	rax, rcx
	sub	r8, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rax, 16
	jge	SHORT $LL593@ZSTD_decom
	npad	6
$LL590@ZSTD_decom:

; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx+r8]
	mov	QWORD PTR [rdx], rax

; 277  :             COPY8(op, ip)

	add	rdx, 8

; 278  :         } while (op < oend);

	cmp	rdx, r9
	jb	SHORT $LL590@ZSTD_decom

; 279  :     } else {

	jmp	SHORT $LN536@ZSTD_decom
	npad	14
$LL593@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+r8]
	movups	XMMWORD PTR [rdx], xmm0

; 289  :             COPY16(op, ip);

	add	rdx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdx, r9
	jb	SHORT $LL593@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	jmp	SHORT $LN536@ZSTD_decom
$LN538@ZSTD_decom:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	mov	rax, QWORD PTR dictEnd$1$[rbp-256]
	lea	r9, QWORD PTR litPtr$1[rsp]
	movups	xmm0, XMMWORD PTR [r10]
	mov	rdx, QWORD PTR oend$1$[rsp]
	lea	r8, QWORD PTR $T14[rbp-256]
	movups	xmm1, XMMWORD PTR [r10+16]
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, r15
	mov	rax, QWORD PTR dictStart$1$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR lastLLSize$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movaps	XMMWORD PTR $T14[rbp-256], xmm0
	movaps	XMMWORD PTR $T14[rbp-240], xmm1
	call	ZSTD_execSequenceEnd
	mov	rsi, rax
$LN536@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rsi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1185 :             if (ZSTD_isError(oneSeqSize)) return oneSeqSize;

	ja	SHORT $LN683@ZSTD_decom

; 1186 :             PREFETCH_L1(sequence.match); PREFETCH_L1(sequence.match + sequence.matchLength - 1); /* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */

	mov	rax, QWORD PTR $T6[rbp-232]
	prefetcht0 BYTE PTR [rax]
	prefetcht0 BYTE PTR [rax+r13-1]

; 1187 :             sequences[seqNb & STORED_SEQS_MASK] = sequence;

	mov	rax, QWORD PTR tv3590[rsp]
	lea	rcx, QWORD PTR seqState$15[rbp-256]
	movups	xmm0, XMMWORD PTR $T6[rbp-256]
	inc	ebx

; 1188 :             op += oneSeqSize;

	add	r15, rsi
	movups	xmm1, XMMWORD PTR $T6[rbp-240]
	mov	DWORD PTR seqNb$1$[rsp], ebx
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm1
	call	BIT_reloadDStream
	mov	edi, DWORD PTR nbSeq$[rbp-256]
	cmp	eax, 2
	jle	$LL12@ZSTD_decom

; 1176 : 
; 1177 :         /* decode and decompress */
; 1178 :         for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb<nbSeq) ; seqNb++) {

	mov	esi, DWORD PTR seqAdvance$1$[rsp]
$LN11@ZSTD_decom:

; 1189 :         }
; 1190 :         RETURN_ERROR_IF(seqNb<nbSeq, corruption_detected, "");

	cmp	ebx, edi
	jge	SHORT $LN25@ZSTD_decom
$LN807@ZSTD_decom:

; 1228 : }

	mov	rax, -20
	jmp	$LN3@ZSTD_decom
$LN759@ZSTD_decom:
	mov	rsi, -20
$LN683@ZSTD_decom:
	mov	rax, rsi
	jmp	$LN3@ZSTD_decom
$LN796@ZSTD_decom:

; 1178 :         for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb<nbSeq) ; seqNb++) {

	mov	esi, DWORD PTR seqAdvance$1$[rsp]
$LN25@ZSTD_decom:

; 1191 : 
; 1192 :         /* finish queue */
; 1193 :         seqNb -= seqAdvance;

	sub	ebx, esi
	mov	DWORD PTR seqNb$1$[rsp], ebx

; 1194 :         for ( ; seqNb<nbSeq ; seqNb++) {

	cmp	ebx, edi
	jge	$LL14@ZSTD_decom
	mov	r13, QWORD PTR lastLLSize$1$[rsp]
	npad	11
$LL15@ZSTD_decom:

; 713  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;

	mov	r10, QWORD PTR litPtr$1[rsp]

; 1195 :             size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[seqNb&STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);

	lea	r9, QWORD PTR sequences$16[rbp-256]
	mov	eax, ebx
	and	eax, 3
	shl	rax, 5
	add	r9, rax
	movups	xmm0, XMMWORD PTR [r9]

; 714  :     const BYTE* match = oLitEnd - sequence.offset;

	mov	r12, QWORD PTR [r9+16]
	movq	r8, xmm0
	psrldq	xmm0, 8
	movq	r14, xmm0
	lea	rdi, QWORD PTR [r8+r15]
	mov	rdx, rdi
	lea	r11, QWORD PTR [r8+r10]
	sub	rdx, r12
	lea	rsi, QWORD PTR [r14+r8]

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	r11, r13
	ja	$LN605@ZSTD_decom

; 602  :     assert(*op - *ip >= 8);
; 603  : }
; 604  : 
; 605  : /*! ZSTD_safecopy() :
; 606  :  *  Specialized version of memcpy() that is allowed to READ up to WILDCOPY_OVERLENGTH past the input buffer
; 607  :  *  and write up to 16 bytes past oend_w (op >= oend_w is allowed).
; 608  :  *  This function is only called in the uncommon case where the sequence is near the end of the block. It
; 609  :  *  should be fast for a single long sequence, but can be slow for several short sequences.
; 610  :  *
; 611  :  *  @param ovtype controls the overlap detection
; 612  :  *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
; 613  :  *         - ZSTD_overlap_src_before_dst: The src and dst may overlap and may be any distance apart.
; 614  :  *           The src buffer must be before the dst buffer.
; 615  :  */
; 616  : static void ZSTD_safecopy(BYTE* op, BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype) {
; 617  :     ptrdiff_t const diff = op - ip;
; 618  :     BYTE* const oend = op + length;
; 619  : 
; 620  :     assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||
; 621  :            (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));
; 622  : 
; 623  :     if (length < 8) {
; 624  :         /* Handle short lengths. */
; 625  :         while (op < oend) *op++ = *ip++;
; 626  :         return;
; 627  :     }
; 628  :     if (ovtype == ZSTD_overlap_src_before_dst) {
; 629  :         /* Copy 8 bytes and ensure the offset >= 8 when there can be overlap. */
; 630  :         assert(length >= 8);
; 631  :         ZSTD_overlapCopy8(&op, &ip, diff);
; 632  :         assert(op - ip >= 8);
; 633  :         assert(op <= oend);
; 634  :     }
; 635  : 
; 636  :     if (oend <= oend_w) {
; 637  :         /* No risk of overwrite. */
; 638  :         ZSTD_wildcopy(op, ip, length, ovtype);
; 639  :         return;
; 640  :     }
; 641  :     if (op <= oend_w) {
; 642  :         /* Wildcopy until we get close to the end. */
; 643  :         assert(oend > oend_w);
; 644  :         ZSTD_wildcopy(op, ip, oend_w - op, ovtype);
; 645  :         ip += oend_w - op;
; 646  :         op = oend_w;
; 647  :     }
; 648  :     /* Handle the leftovers. */
; 649  :     while (op < oend) *op++ = *ip++;
; 650  : }
; 651  : 
; 652  : /* ZSTD_execSequenceEnd():
; 653  :  * This version handles cases that are near the end of the output buffer. It requires
; 654  :  * more careful checks to make sure there is no overflow. By separating out these hard
; 655  :  * and unlikely cases, we can speed up the common cases.
; 656  :  *
; 657  :  * NOTE: This function needs to be fast for a single long sequence, but doesn't need
; 658  :  * to be optimized for many small sequences, since those fall into ZSTD_execSequence().
; 659  :  */
; 660  : FORCE_NOINLINE
; 661  : size_t ZSTD_execSequenceEnd(BYTE* op,
; 662  :                             BYTE* const oend, seq_t sequence,
; 663  :                             const BYTE** litPtr, const BYTE* const litLimit,
; 664  :                             const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
; 665  : {
; 666  :     BYTE* const oLitEnd = op + sequence.litLength;
; 667  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 668  :     const BYTE* const iLitEnd = *litPtr + sequence.litLength;
; 669  :     const BYTE* match = oLitEnd - sequence.offset;
; 670  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;
; 671  : 
; 672  :     /* bounds checks : careful of address space overflow in 32-bit mode */
; 673  :     RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, "last match must fit within dstBuffer");
; 674  :     RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, "try to read beyond literal buffer");
; 675  :     assert(op < op + sequenceLength);
; 676  :     assert(oLitEnd < op + sequenceLength);
; 677  : 
; 678  :     /* copy literals */
; 679  :     ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);
; 680  :     op = oLitEnd;
; 681  :     *litPtr = iLitEnd;
; 682  : 
; 683  :     /* copy Match */
; 684  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {
; 685  :         /* offset beyond prefix */
; 686  :         RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, "");
; 687  :         match = dictEnd - (prefixStart-match);
; 688  :         if (match + sequence.matchLength <= dictEnd) {
; 689  :             memmove(oLitEnd, match, sequence.matchLength);
; 690  :             return sequenceLength;
; 691  :         }
; 692  :         /* span extDict & currentPrefixSegment */
; 693  :         {   size_t const length1 = dictEnd - match;
; 694  :             memmove(oLitEnd, match, length1);
; 695  :             op = oLitEnd + length1;
; 696  :             sequence.matchLength -= length1;
; 697  :             match = prefixStart;
; 698  :     }   }
; 699  :     ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);
; 700  :     return sequenceLength;
; 701  : }
; 702  : 
; 703  : HINT_INLINE
; 704  : size_t ZSTD_execSequence(BYTE* op,
; 705  :                          BYTE* const oend, seq_t sequence,
; 706  :                          const BYTE** litPtr, const BYTE* const litLimit,
; 707  :                          const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
; 708  : {
; 709  :     BYTE* const oLitEnd = op + sequence.litLength;
; 710  :     size_t const sequenceLength = sequence.litLength + sequence.matchLength;
; 711  :     BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */

	mov	rax, QWORD PTR oend$1$[rsp]
	lea	rcx, QWORD PTR [rsi+r15]

; 712  :     BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */

	add	rax, -32				; ffffffffffffffe0H

; 715  : 
; 716  :     assert(op != NULL /* Precondition */);
; 717  :     assert(oend_w < oend /* No underflow */);
; 718  :     /* Handle edge cases in a slow path:
; 719  :      *   - Read beyond end of literals
; 720  :      *   - Match end is within WILDCOPY_OVERLIMIT of oend
; 721  :      *   - 32-bit mode and the match length overflows
; 722  :      */
; 723  :     if (UNLIKELY(

	cmp	rcx, rax
	ja	$LN605@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r10]
	movups	XMMWORD PTR [r15], xmm0
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 743  :     if (UNLIKELY(sequence.litLength > 16)) {

	cmp	r8, 16
	jbe	SHORT $LN623@ZSTD_decom

; 744  :         ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);

	mov	rcx, QWORD PTR litPtr$1[rsp]
	lea	rax, QWORD PTR [r15+16]
	add	rcx, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rax-16]
	add	r9, r8
$LL624@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx]

; 289  :             COPY16(op, ip);

	lea	rcx, QWORD PTR [rcx+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL624@ZSTD_decom
$LN623@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 750  :     if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {

	mov	r13, QWORD PTR prefixStart$1$[rsp]
	mov	rax, rdi
	sub	rax, r13
	mov	QWORD PTR litPtr$1[rsp], r11
	cmp	r12, rax
	jbe	SHORT $LN607@ZSTD_decom

; 751  :         /* offset beyond prefix -> go into extDict */
; 752  :         RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");

	mov	rax, rdi
	sub	rax, QWORD PTR dictStart$1$[rbp-256]
	cmp	r12, rax
	ja	$LN759@ZSTD_decom

; 753  :         match = dictEnd + (match - prefixStart);

	mov	rcx, QWORD PTR dictEnd$1$[rbp-256]
	mov	rax, rcx
	sub	rax, r13
	add	rdx, rax

; 754  :         if (match + sequence.matchLength <= dictEnd) {

	lea	rax, QWORD PTR [r14+rdx]
	cmp	rax, rcx
	ja	SHORT $LN610@ZSTD_decom

; 755  :             memmove(oLitEnd, match, sequence.matchLength);

	mov	r8, r14
	mov	rcx, rdi
	call	memmove

; 756  :             return sequenceLength;

	mov	r13, QWORD PTR lastLLSize$1$[rsp]
	jmp	$LN603@ZSTD_decom
$LN610@ZSTD_decom:

; 757  :         }
; 758  :         /* span extDict & currentPrefixSegment */
; 759  :         {   size_t const length1 = dictEnd - match;

	mov	rbx, rcx

; 760  :             memmove(oLitEnd, match, length1);

	mov	rcx, rdi
	sub	rbx, rdx
	mov	r8, rbx
	call	memmove

; 761  :             op = oLitEnd + length1;

	add	rdi, rbx

; 762  :             sequence.matchLength -= length1;
; 763  :             match = prefixStart;

	mov	rdx, r13
	sub	r14, rbx
	mov	ebx, DWORD PTR seqNb$1$[rsp]
$LN607@ZSTD_decom:

; 764  :     }   }
; 765  :     /* Match within prefix of 1 or more bytes */
; 766  :     assert(op <= oMatchEnd);
; 767  :     assert(oMatchEnd <= oend_w);
; 768  :     assert(match >= prefixStart);
; 769  :     assert(sequence.matchLength >= 1);
; 770  : 
; 771  :     /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
; 772  :      * without overlap checking.
; 773  :      */
; 774  :     if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {

	cmp	r12, 16
	jb	SHORT $LN611@ZSTD_decom
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [r14+rdi]
	sub	rdx, rdi
$LL638@ZSTD_decom:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi+rdx]
	movups	XMMWORD PTR [rdi], xmm0

; 289  :             COPY16(op, ip);

	add	rdi, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rdi, rax
	jb	SHORT $LL638@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 780  :         return sequenceLength;

	mov	r13, QWORD PTR lastLLSize$1$[rsp]
	jmp	$LN603@ZSTD_decom
$LN611@ZSTD_decom:

; 585  :     if (offset < 8) {

	cmp	r12, 8
	jae	SHORT $LN647@ZSTD_decom

; 586  :         /* close range match, overlap */
; 587  :         static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
; 588  :         static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
; 589  :         int const sub2 = dec64table[offset];
; 590  :         (*op)[0] = (*ip)[0];

	movzx	eax, BYTE PTR [rdx]

; 591  :         (*op)[1] = (*ip)[1];
; 592  :         (*op)[2] = (*ip)[2];
; 593  :         (*op)[3] = (*ip)[3];
; 594  :         *ip += dec32table[offset];

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	BYTE PTR [rdi], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rdi+3], al
	mov	eax, DWORD PTR ?dec32table@?2??ZSTD_overlapCopy8@@9@9[rcx+r12*4]
	add	rdx, rax

; 47   : static void ZSTD_copy4(void* dst, const void* src) { memcpy(dst, src, 4); }

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi+4], eax

; 596  :         *ip -= sub2;

	movsxd	rax, DWORD PTR ?dec64table@?2??ZSTD_overlapCopy8@@9@9[rcx+r12*4]
	sub	rdx, rax

; 597  :     } else {

	jmp	SHORT $LN652@ZSTD_decom
$LN647@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
$LN652@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 788  :     if (sequence.matchLength > 8) {

	cmp	r14, 8
	jbe	SHORT $LN659@ZSTD_decom

; 600  :     *ip += 8;

	add	rdx, 8

; 601  :     *op += 8;

	lea	rax, QWORD PTR [rdi+8]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	r9, QWORD PTR [rax-8]
	mov	r8, rdx
	mov	rcx, rax
	add	r9, r14
	sub	r8, rax
	sub	rcx, rdx

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {

	cmp	rcx, 16
	jge	SHORT $LL660@ZSTD_decom
	npad	5
$LL657@ZSTD_decom:

; 234  :     memcpy(dst, src, 8);

	mov	rcx, QWORD PTR [rax+r8]
	mov	QWORD PTR [rax], rcx

; 277  :             COPY8(op, ip)

	add	rax, 8

; 278  :         } while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL657@ZSTD_decom
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	r13, QWORD PTR lastLLSize$1$[rsp]
	jmp	SHORT $LN603@ZSTD_decom
	npad	9
$LL660@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rax+r8]
	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, r9
	jb	SHORT $LL660@ZSTD_decom
$LN659@ZSTD_decom:
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 792  :     return sequenceLength;

	mov	r13, QWORD PTR lastLLSize$1$[rsp]
	jmp	SHORT $LN603@ZSTD_decom
$LN605@ZSTD_decom:

; 724  :             iLitEnd > litLimit ||
; 725  :             oMatchEnd > oend_w ||
; 726  :             (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
; 727  :         return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);

	movups	xmm0, XMMWORD PTR [r9]
	mov	rax, QWORD PTR dictEnd$1$[rbp-256]
	lea	r8, QWORD PTR $T13[rbp-256]
	movups	xmm1, XMMWORD PTR [r9+16]
	mov	rdx, QWORD PTR oend$1$[rsp]
	lea	r9, QWORD PTR litPtr$1[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, r15
	mov	rax, QWORD PTR dictStart$1$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR prefixStart$1$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r13
	movaps	XMMWORD PTR $T13[rbp-256], xmm0
	movaps	XMMWORD PTR $T13[rbp-240], xmm1
	call	ZSTD_execSequenceEnd
	mov	rsi, rax
$LN603@ZSTD_decom:
; File E:\dev\pyzstd\lib\common\error_private.h

; 56   : ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }

	cmp	rsi, -120				; ffffffffffffff88H
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c

; 1200 :             if (ZSTD_isError(oneSeqSize)) return oneSeqSize;

	ja	$LN683@ZSTD_decom

; 1201 :             op += oneSeqSize;

	inc	ebx
	add	r15, rsi
	mov	DWORD PTR seqNb$1$[rsp], ebx
	cmp	ebx, DWORD PTR nbSeq$[rbp-256]
	jl	$LL15@ZSTD_decom
$LL14@ZSTD_decom:

; 1202 :         }
; 1203 : 
; 1204 :         /* save reps for next block */
; 1205 :         { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }

	mov	rcx, QWORD PTR dctx$GSCopy$1$[rbp-256]
	mov	eax, DWORD PTR seqState$15[rbp-168]
	mov	rdx, QWORD PTR litPtr$1[rsp]
	mov	r10, QWORD PTR oend$1$[rsp]
	mov	rbx, QWORD PTR lastLLSize$1$[rsp]
	mov	r12, QWORD PTR dst$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rcx+26684], eax
	mov	eax, DWORD PTR seqState$15[rbp-160]
	mov	DWORD PTR [rcx+26688], eax
	mov	eax, DWORD PTR seqState$15[rbp-152]
	mov	DWORD PTR [rcx+26692], eax
$LN17@ZSTD_decom:

; 1206 :     }
; 1207 : 
; 1208 :     /* last literal segment */
; 1209 :     {   size_t const lastLLSize = litEnd - litPtr;

	sub	rbx, rdx

; 1210 :         RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");

	sub	r10, r15
	cmp	rbx, r10
	jbe	SHORT $LN28@ZSTD_decom

; 1227 :     return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	rax, -70				; ffffffffffffffbaH

; 1210 :         RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");

	jmp	SHORT $LN3@ZSTD_decom
$LN28@ZSTD_decom:

; 1211 :         if (op != NULL) {

	test	r15, r15
	je	SHORT $LN30@ZSTD_decom

; 1212 :             memcpy(op, litPtr, lastLLSize);

	mov	r8, rbx
	mov	rcx, r15
	call	memcpy

; 1213 :             op += lastLLSize;

	add	r15, rbx
$LN30@ZSTD_decom:

; 1214 :         }
; 1215 :     }
; 1216 : 
; 1217 :     return op-ostart;

	sub	r15, r12

; 1227 :     return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	rax, r15
$LN3@ZSTD_decom:

; 1228 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 568				; 00000238H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
ZSTD_decompressSequencesLong_default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dctx$ = 8
dst$ = 16
maxDstSize$ = 24
seqStart$ = 32
seqSize$ = 40
nbSeq$ = 48
isLongOffset$ = 56
frame$dead$ = 64
ZSTD_decompressSequences PROC

; 1276 :     DEBUGLOG(5, "ZSTD_decompressSequences");
; 1277 : #if DYNAMIC_BMI2
; 1278 :     if (dctx->bmi2) {
; 1279 :         return ZSTD_decompressSequences_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
; 1280 :     }
; 1281 : #endif
; 1282 :   return ZSTD_decompressSequences_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	DWORD PTR frame$dead$[rsp], 1
	jmp	ZSTD_decompressSequences_default
ZSTD_decompressSequences ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
dctx$ = 8
dst$ = 16
maxDstSize$ = 24
seqStart$ = 32
seqSize$ = 40
nbSeq$ = 48
isLongOffset$ = 56
frame$dead$ = 64
ZSTD_decompressSequencesLong PROC

; 1300 :     DEBUGLOG(5, "ZSTD_decompressSequencesLong");
; 1301 : #if DYNAMIC_BMI2
; 1302 :     if (dctx->bmi2) {
; 1303 :         return ZSTD_decompressSequencesLong_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
; 1304 :     }
; 1305 : #endif
; 1306 :   return ZSTD_decompressSequencesLong_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);

	mov	DWORD PTR frame$dead$[rsp], 1
	jmp	ZSTD_decompressSequencesLong_default
ZSTD_decompressSequencesLong ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\decompress\zstd_decompress_block.c
_TEXT	SEGMENT
offTable$ = 8
ZSTD_getLongOffsetsShare PROC

; 1321 :     const void* ptr = offTable;
; 1322 :     U32 const tableLog = ((const ZSTD_seqSymbol_header*)ptr)[0].tableLog;

	mov	r9d, DWORD PTR [rcx+4]
	mov	rdx, rcx

; 1323 :     const ZSTD_seqSymbol* table = offTable + 1;
; 1324 :     U32 const max = 1 << tableLog;

	mov	ecx, r9d
	mov	r8d, 1
	shl	r8d, cl

; 1325 :     U32 u, total = 0;

	xor	eax, eax

; 1326 :     DEBUGLOG(5, "ZSTD_getLongOffsetsShare: (tableLog=%u)", tableLog);
; 1327 : 
; 1328 :     assert(max <= (1 << OffFSELog));  /* max not too large */
; 1329 :     for (u=0; u<max; u++) {

	test	r8d, r8d
	je	SHORT $LN3@ZSTD_getLo
	add	rdx, 10
	npad	2
$LL9@ZSTD_getLo:
	cmp	BYTE PTR [rdx], 22
	lea	ecx, DWORD PTR [rax+1]
	lea	rdx, QWORD PTR [rdx+8]
	cmovbe	ecx, eax
	mov	eax, ecx
	sub	r8, 1
	jne	SHORT $LL9@ZSTD_getLo
$LN3@ZSTD_getLo:

; 1330 :         if (table[u].nbAdditionalBits > 22) total += 1;
; 1331 :     }
; 1332 : 
; 1333 :     assert(tableLog <= OffFSELog);
; 1334 :     total <<= (OffFSELog - tableLog);  /* scale to OffFSELog */

	mov	ecx, 8
	sub	ecx, r9d
	shl	eax, cl

; 1335 : 
; 1336 :     return total;
; 1337 : }

	ret	0
ZSTD_getLongOffsetsShare ENDP
_TEXT	ENDS
END
