; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB OLDNAMES

prime4bytes DD	09e3779b1H
prime8bytes DQ	cf1bbcdcb7a56463H
prime5bytes DQ	000000cf1bbcdcbbH
prime7bytes DQ	00cf1bbcdcbfa563H
prime6bytes DQ	0000cf1bbcdcbf9bH
PUBLIC	ZSTD_compressBlock_fast_dictMatchState
PUBLIC	ZSTD_compressBlock_fast
PUBLIC	ZSTD_compressBlock_fast_extDict
PUBLIC	ZSTD_fillHashTable
pdata	SEGMENT
$pdata$ZSTD_compressBlock_fast_extDict_generic DD imagerel ZSTD_compressBlock_fast_extDict_generic
	DD	imagerel ZSTD_compressBlock_fast_extDict_generic+4427
	DD	imagerel $unwind$ZSTD_compressBlock_fast_extDict_generic
$pdata$ZSTD_compressBlock_fast_dictMatchState_generic DD imagerel ZSTD_compressBlock_fast_dictMatchState_generic
	DD	imagerel ZSTD_compressBlock_fast_dictMatchState_generic+3035
	DD	imagerel $unwind$ZSTD_compressBlock_fast_dictMatchState_generic
$pdata$ZSTD_compressBlock_fast_generic DD imagerel ZSTD_compressBlock_fast_generic
	DD	imagerel ZSTD_compressBlock_fast_generic+2429
	DD	imagerel $unwind$ZSTD_compressBlock_fast_generic
$pdata$ZSTD_count_2segments DD imagerel ZSTD_count_2segments
	DD	imagerel ZSTD_count_2segments+106
	DD	imagerel $unwind$ZSTD_count_2segments
$pdata$ZSTD_storeSeq DD imagerel ZSTD_storeSeq
	DD	imagerel ZSTD_storeSeq+271
	DD	imagerel $unwind$ZSTD_storeSeq
$pdata$ZSTD_compressBlock_fast_dictMatchState DD imagerel $LN2086
	DD	imagerel $LN2086+7299
	DD	imagerel $unwind$ZSTD_compressBlock_fast_dictMatchState
$pdata$ZSTD_compressBlock_fast DD imagerel $LN1524
	DD	imagerel $LN1524+6647
	DD	imagerel $unwind$ZSTD_compressBlock_fast
$pdata$ZSTD_compressBlock_fast_extDict DD imagerel $LN193
	DD	imagerel $LN193+136
	DD	imagerel $unwind$ZSTD_compressBlock_fast_extDict
$pdata$ZSTD_fillHashTable DD imagerel $LN84
	DD	imagerel $LN84+70
	DD	imagerel $unwind$ZSTD_fillHashTable
$pdata$2$ZSTD_fillHashTable DD imagerel $LN84+70
	DD	imagerel $LN84+434
	DD	imagerel $chain$2$ZSTD_fillHashTable
$pdata$3$ZSTD_fillHashTable DD imagerel $LN84+434
	DD	imagerel $LN84+446
	DD	imagerel $chain$3$ZSTD_fillHashTable
xdata	SEGMENT
$unwind$ZSTD_compressBlock_fast_extDict_generic DD 0b1c01H
	DD	01b341cH
	DD	012011cH
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$ZSTD_compressBlock_fast_dictMatchState_generic DD 0b1c01H
	DD	01d341cH
	DD	014011cH
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$ZSTD_compressBlock_fast_generic DD 0a1901H
	DD	0133419H
	DD	0f0159219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$ZSTD_count_2segments DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$ZSTD_storeSeq DD 020501H
	DD	013405H
$unwind$ZSTD_compressBlock_fast_dictMatchState DD 0b1c01H
	DD	01f341cH
	DD	016011cH
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$ZSTD_compressBlock_fast DD 0a1e01H
	DD	015341eH
	DD	0f01a921eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$ZSTD_compressBlock_fast_extDict DD 010401H
	DD	06204H
$unwind$ZSTD_fillHashTable DD 060c01H
	DD	0f008120cH
	DD	07004e006H
	DD	030025003H
$chain$2$ZSTD_fillHashTable DD 061c21H
	DD	0d41cH
	DD	01c410H
	DD	0a6405H
	DD	imagerel $LN84
	DD	imagerel $LN84+70
	DD	imagerel $unwind$ZSTD_fillHashTable
$chain$3$ZSTD_fillHashTable DD 021H
	DD	imagerel $LN84
	DD	imagerel $LN84+70
	DD	imagerel $unwind$ZSTD_fillHashTable
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
tv434 = 64
ms$ = 64
base$1$ = 72
end$ = 72
dtlm$ = 80
ZSTD_fillHashTable PROC

; 18   : {

$LN84:
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 16

; 19   :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 20   :     U32* const hashTable = ms->hashTable;
; 21   :     U32  const hBits = cParams->hashLog;
; 22   :     U32  const mls = cParams->minMatch;
; 23   :     const BYTE* const base = ms->window.base;

	mov	r14, QWORD PTR [rcx+8]

; 24   :     const BYTE* ip = base + ms->nextToUpdate;
; 25   :     const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;
; 26   :     const U32 fastHashFillStep = 3;
; 27   : 
; 28   :     /* Always insert every fastHashFillStep position into the hash table.
; 29   :      * Insert the other positions if their hash entry is empty.
; 30   :      */
; 31   :     for ( ; ip + fastHashFillStep < iend + 2; ip += fastHashFillStep) {

	lea	rbp, QWORD PTR [rdx-6]
	mov	r11d, DWORD PTR [rcx+36]
	mov	r15d, r8d
	mov	rdi, QWORD PTR [rcx+48]
	add	r11, r14
	mov	r9d, DWORD PTR [rcx+192]
	mov	ebx, DWORD PTR [rcx+200]
	mov	QWORD PTR base$1$[rsp], r14
	lea	rax, QWORD PTR [r11+3]
	mov	QWORD PTR tv434[rsp], rbp
	cmp	rax, rbp
	jae	$LN3@ZSTD_fillH
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+80], rsi

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r10d, 64				; 00000040H

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	QWORD PTR [rsp+8], r12
	mov	esi, 32					; 00000020H
	sub	esi, r9d
	mov	QWORD PTR [rsp], r13

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	sub	r10d, r9d
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r12, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r13, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H
	npad	3
$LL4@ZSTD_fillH:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 32   :         U32 const current = (U32)(ip - base);

	mov	r9d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, ebx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 32   :         U32 const current = (U32)(ip - base);

	sub	r9d, r14d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	SHORT $LN15@ZSTD_fillH
	sub	eax, 1
	je	SHORT $LN16@ZSTD_fillH
	sub	eax, 1
	je	SHORT $LN17@ZSTD_fillH
	cmp	eax, 1
	je	SHORT $LN18@ZSTD_fillH

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r11], -1640531535	; 9e3779b1H
	mov	rcx, rsi

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN79@ZSTD_fillH
$LN18@ZSTD_fillH:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r11]
	imul	rdx, r12

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN80@ZSTD_fillH
$LN17@ZSTD_fillH:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r11]
	imul	rdx, r13

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN80@ZSTD_fillH
$LN16@ZSTD_fillH:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r11]
	imul	rdx, rcx

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN80@ZSTD_fillH
$LN15@ZSTD_fillH:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r11]
	imul	rdx, r8
$LN80@ZSTD_fillH:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 34   :         hashTable[hash0] = current;

	mov	ecx, r10d
$LN79@ZSTD_fillH:
	shr	rdx, cl
	mov	DWORD PTR [rdi+rdx*4], r9d

; 35   :         if (dtlm == ZSTD_dtlm_fast) continue;

	test	r15d, r15d
	je	$LN2@ZSTD_fillH

; 36   :         /* Only load extra positions for ZSTD_dtlm_full */
; 37   :         {   U32 p;
; 38   :             for (p = 1; p < fastHashFillStep; ++p) {

	mov	r8d, 1
	lea	rdx, QWORD PTR [r11+1]
	mov	rbp, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r14, -3523014627271114752		; cf1bbcdcbb000000H
	npad	5
$LL7@ZSTD_fillH:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, ebx
	sub	eax, 5
	je	SHORT $LN44@ZSTD_fillH
	sub	eax, 1
	je	SHORT $LN45@ZSTD_fillH
	sub	eax, 1
	je	SHORT $LN46@ZSTD_fillH
	cmp	eax, 1
	je	SHORT $LN47@ZSTD_fillH

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rdx], -1640531535	; 9e3779b1H
	mov	rcx, rsi

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN81@ZSTD_fillH
$LN47@ZSTD_fillH:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rdx]
	imul	rax, r12

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN82@ZSTD_fillH
$LN46@ZSTD_fillH:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rdx]
	imul	rax, r13

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN82@ZSTD_fillH
$LN45@ZSTD_fillH:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rdx]
	imul	rax, rbp

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN82@ZSTD_fillH
$LN44@ZSTD_fillH:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rdx]
	imul	rax, r14
$LN82@ZSTD_fillH:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 40   :                 if (hashTable[hash] == 0) {  /* not yet filled */

	mov	ecx, r10d
$LN81@ZSTD_fillH:
	shr	rax, cl
	cmp	DWORD PTR [rdi+rax*4], 0
	lea	rcx, QWORD PTR [rdi+rax*4]
	jne	SHORT $LN5@ZSTD_fillH

; 41   :                     hashTable[hash] = current + p;

	lea	eax, DWORD PTR [r8+r9]
	mov	DWORD PTR [rcx], eax
$LN5@ZSTD_fillH:

; 36   :         /* Only load extra positions for ZSTD_dtlm_full */
; 37   :         {   U32 p;
; 38   :             for (p = 1; p < fastHashFillStep; ++p) {

	inc	r8d
	inc	rdx
	cmp	r8d, 3
	jb	SHORT $LL7@ZSTD_fillH
	mov	rbp, QWORD PTR tv434[rsp]
	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H
	mov	r14, QWORD PTR base$1$[rsp]
$LN2@ZSTD_fillH:

; 24   :     const BYTE* ip = base + ms->nextToUpdate;
; 25   :     const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;
; 26   :     const U32 fastHashFillStep = 3;
; 27   : 
; 28   :     /* Always insert every fastHashFillStep position into the hash table.
; 29   :      * Insert the other positions if their hash entry is empty.
; 30   :      */
; 31   :     for ( ; ip + fastHashFillStep < iend + 2; ip += fastHashFillStep) {

	add	r11, 3
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	lea	rax, QWORD PTR [r11+3]
	cmp	rax, rbp
	jb	$LL4@ZSTD_fillH
	mov	r13, QWORD PTR [rsp]
	mov	r12, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+80]
$LN3@ZSTD_fillH:

; 42   :     }   }   }   }
; 43   : }

	add	rsp, 16
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
ZSTD_fillHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
ms$ = 64
seqStore$ = 72
rep$ = 80
src$ = 88
srcSize$ = 96
ZSTD_compressBlock_fast_extDict PROC

; 482  : {

$LN193:
	sub	rsp, 56					; 00000038H

; 483  :     U32 const mls = ms->cParams.minMatch;
; 484  :     switch(mls)

	mov	r10d, DWORD PTR [rcx+200]
	sub	r10d, 5
	je	SHORT $LN5@ZSTD_compr
	sub	r10d, 1
	je	SHORT $LN6@ZSTD_compr
	mov	rax, QWORD PTR srcSize$[rsp]
	cmp	r10d, 1
	je	SHORT $LN7@ZSTD_compr

; 485  :     {
; 486  :     default: /* includes case 3 */
; 487  :     case 4 :
; 488  :         return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 4);

	mov	DWORD PTR [rsp+40], 4

; 495  :     }
; 496  : }

	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressBlock_fast_extDict_generic
	add	rsp, 56					; 00000038H
	ret	0
$LN7@ZSTD_compr:

; 489  :     case 5 :
; 490  :         return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 5);
; 491  :     case 6 :
; 492  :         return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 6);
; 493  :     case 7 :
; 494  :         return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 7);

	mov	DWORD PTR [rsp+40], 7

; 495  :     }
; 496  : }

	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressBlock_fast_extDict_generic
	add	rsp, 56					; 00000038H
	ret	0
$LN6@ZSTD_compr:
	mov	rax, QWORD PTR srcSize$[rsp]
	mov	DWORD PTR [rsp+40], 6
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressBlock_fast_extDict_generic
	add	rsp, 56					; 00000038H
	ret	0
$LN5@ZSTD_compr:
	mov	rax, QWORD PTR srcSize$[rsp]
	mov	DWORD PTR [rsp+40], 5
	mov	QWORD PTR [rsp+32], rax
	call	ZSTD_compressBlock_fast_extDict_generic
	add	rsp, 56					; 00000038H
	ret	0
ZSTD_compressBlock_fast_extDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
offset_1$1$ = 0
offset_1$1$ = 0
offset_1$1$ = 0
offset_2$1$ = 0
val1$1$ = 4
val1$1$ = 4
val1$1$ = 4
val1$1$ = 4
r$1 = 4
r$2 = 4
r$3 = 4
r$4 = 4
r$5 = 4
r$6 = 4
r$7 = 4
r$8 = 4
r$9 = 4
r$10 = 4
r$11 = 4
r$12 = 4
r$13 = 4
r$14 = 4
r$15 = 4
r$16 = 4
offset_2$1$ = 8
offset_2$1$ = 8
offset_2$1$ = 8
current0$1$ = 8
base$1$ = 16
base$1$ = 16
base$1$ = 16
base$1$ = 16
current0$1$ = 24
current0$1$ = 24
current0$1$ = 24
prefixStartIndex$1$ = 24
hashTable$1$ = 32
matchIndex1$1$ = 40
tv9147 = 40
tv8904 = 40
tv8792 = 40
prefixStartIndex$1$ = 44
prefixStartIndex$1$ = 44
prefixStartIndex$1$ = 44
tv8678 = 44
iend$1$ = 48
iend$1$ = 48
iend$1$ = 48
iend$1$ = 48
ilimit$1$ = 56
ilimit$1$ = 56
ilimit$1$ = 56
tv8110 = 56
stepSize$1$ = 64
stepSize$1$ = 64
stepSize$1$ = 64
prefixStart$1$ = 64
prefixStart$1$ = 72
prefixStart$1$ = 72
prefixStart$1$ = 72
stepSize$1$ = 72
offset_1$1$ = 144
tv8109 = 144
ms$ = 144
seqStore$ = 152
rep$ = 160
src$ = 168
srcSize$ = 176
ZSTD_compressBlock_fast PROC

; 189  : {

$LN1524:
	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 190  :     U32 const mls = ms->cParams.minMatch;
; 191  :     assert(ms->dictMatchState == NULL);
; 192  :     switch(mls)

	mov	rax, QWORD PTR [rcx+48]
	mov	r14, r8
	mov	rbx, QWORD PTR srcSize$[rsp]
	mov	rsi, rdx
	mov	edx, DWORD PTR [rcx+204]
	mov	r13, rcx
	mov	edi, DWORD PTR [rcx+24]
	mov	r8d, r9d
	mov	r10d, DWORD PTR [rcx+32]
	mov	r11d, 1
	mov	QWORD PTR hashTable$1$[rsp], rax
	lea	r12, QWORD PTR [r9+rbx]
	mov	eax, DWORD PTR [rcx+200]
	mov	QWORD PTR iend$1$[rsp], r12
	sub	eax, 5
	je	$LN5@ZSTD_compr
	sub	eax, r11d
	je	$LN6@ZSTD_compr
	cmp	eax, r11d
	mov	eax, edx
	je	$LN7@ZSTD_compr

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	neg	eax
	sbb	ecx, ecx
	lea	eax, DWORD PTR [rcx+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r13+184]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	add	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	r11d, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 57   :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [r13+8]

; 58   :     const BYTE* const istart = (const BYTE*)src;
; 59   :     /* We check ip0 (ip + 0) and ip1 (ip + 1) each loop */
; 60   :     const BYTE* ip0 = istart;
; 61   :     const BYTE* ip1;
; 62   :     const BYTE* anchor = istart;
; 63   :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	sub	r8d, edx
	mov	QWORD PTR stepSize$1$[rsp], rax
	add	r8d, ebx
	mov	QWORD PTR base$1$[rsp], rdx

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	mov	ebx, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r8d, r11d
	sub	eax, edi
	cmp	eax, r11d
	cmovbe	r8d, edi
	test	r10d, r10d

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 73   :     ip0 += (ip0 == prefixStart);

	xor	ebp, ebp
	mov	ecx, r8d
	mov	eax, ebp
	add	rcx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR prefixStartIndex$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 68   :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	r8d, DWORD PTR [r14+4]

; 69   :     U32 offsetSaved = 0;

	cmp	r9, rcx
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 73   :     ip0 += (ip0 == prefixStart);

	sete	al
	lea	r14, QWORD PTR [rax+r9]

; 74   :     ip1 = ip0 + 1;
; 75   :     {   U32 const current = (U32)(ip0 - base);

	mov	edx, r14d
	lea	r15, QWORD PTR [r14+1]
	sub	edx, DWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, edx

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, edx
	sub	ecx, r11d
	sub	eax, edi
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r11d, ebx
	lea	rax, QWORD PTR [r12-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, edi
	test	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	mov	r10d, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 77   :         U32 const maxRep = current - windowLow;

	sub	edx, ecx

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	cmp	r8d, edx
	cmovbe	r10d, r8d
	cmovbe	r8d, ebp

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	cmp	ebx, edx
	cmovbe	r11d, r8d
	mov	r8d, ebp
	cmovbe	r8d, ebx
	mov	DWORD PTR tv8678[rsp], r11d
	cmp	r15, rax
	jae	$LN11@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	DWORD PTR offset_2$1$[rsp], r10d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	sub	ecx, DWORD PTR [r13+192]

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	QWORD PTR tv8110[rsp], rcx
	mov	DWORD PTR offset_1$1$[rsp], r8d
	npad	4
$LL10@ZSTD_compr:

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	eax, DWORD PTR [r15]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 101  :         BYTE const* repMatch = ip2 - offset_1;

	lea	r11, QWORD PTR [r14+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r13d, DWORD PTR [r14]
	imul	edx, eax, -1640531535			; 9e3779b1H
	mov	DWORD PTR val1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 97   :         U32 const current0 = (U32)(ip0-base);

	mov	eax, r14d
	sub	eax, DWORD PTR base$1$[rsp]
	mov	DWORD PTR current0$1$[rsp], eax

; 98   :         U32 const current1 = (U32)(ip1-base);
; 99   :         U32 const matchIndex0 = hashTable[h0];

	mov	rax, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
	imul	r8d, r13d, -1640531535			; 9e3779b1H
	shr	r8, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 100  :         U32 const matchIndex1 = hashTable[h1];

	mov	ecx, DWORD PTR [rax+rdx*4]

; 102  :         const BYTE* match0 = base + matchIndex0;
; 103  :         const BYTE* match1 = base + matchIndex1;

	mov	ebx, ecx
	mov	DWORD PTR matchIndex1$1$[rsp], ecx

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	r12d, DWORD PTR [rax+r8*4]
	add	rbx, QWORD PTR base$1$[rsp]
	mov	r10d, r12d
	add	r10, QWORD PTR base$1$[rsp]
	mov	eax, DWORD PTR offset_1$1$[rsp]
	sub	r11, rax
	mov	eax, DWORD PTR current0$1$[rsp]
	mov	DWORD PTR [rcx+r8*4], eax
	mov	eax, r15d
	sub	eax, DWORD PTR base$1$[rsp]

; 111  :         hashTable[h1] = current1;   /* update hash table */
; 112  : 
; 113  :         assert(ip0 + 1 == ip1);
; 114  : 
; 115  :         if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR [rcx+rdx*4], eax
	mov	ecx, ebp
	mov	eax, DWORD PTR [r14+2]
	cmp	DWORD PTR [r11], eax
	mov	eax, ebp
	sete	cl
	test	r8d, r8d
	setne	al
	test	ecx, eax
	je	SHORT $LN18@ZSTD_compr

; 116  :             mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;

	movzx	eax, BYTE PTR [r11-1]
	mov	rbx, rbp
	cmp	BYTE PTR [r14+1], al

; 117  :             ip0 = ip2 - mLength;
; 118  :             match0 = repMatch - mLength;

	mov	r10, r11

; 119  :             mLength += 4;
; 120  :             offcode = 0;
; 121  :             goto _match;

	mov	r13d, DWORD PTR offset_2$1$[rsp]
	mov	r15d, ebp
	sete	bl
	add	r14, 2
	sub	r14, rbx
	sub	r10, rbx
	add	rbx, 4
	jmp	$_match$1525
$LN18@ZSTD_compr:

; 122  :         }
; 123  :         if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	r12d, eax
	jbe	SHORT $LN19@ZSTD_compr
	cmp	DWORD PTR [r10], r13d
	je	SHORT $_offset$1526
$LN19@ZSTD_compr:

; 124  :             /* found a regular match */
; 125  :             goto _offset;
; 126  :         }
; 127  :         if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {

	cmp	DWORD PTR matchIndex1$1$[rsp], eax
	jbe	$LN20@ZSTD_compr
	mov	eax, DWORD PTR val1$1$[rsp]
	cmp	DWORD PTR [rbx], eax
	jne	$LN20@ZSTD_compr

; 128  :             /* found a regular match after one literal */
; 129  :             ip0 = ip1;

	mov	r14, r15

; 130  :             match0 = match1;

	mov	r10, rbx
$_offset$1526:

; 137  :             continue;
; 138  :         }
; 139  : _offset: /* Requires: ip0, match0 */
; 140  :         /* Compute the offset code */
; 141  :         offset_2 = offset_1;
; 142  :         offset_1 = (U32)(ip0-match0);
; 143  :         offcode = offset_1 + ZSTD_REP_MOVE;
; 144  :         mLength = 4;
; 145  :         /* Count the backwards match length */
; 146  :         while (((ip0>anchor) & (match0>prefixStart))
; 147  :              && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; } /* catch up */

	mov	r11, QWORD PTR prefixStart$1$[rsp]
	mov	ecx, ebp
	mov	eax, r14d
	mov	DWORD PTR offset_2$1$[rsp], r8d
	sub	eax, r10d
	mov	r13d, r8d
	cmp	r10, r11
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	ebx, 4
	seta	cl
	cmp	r14, r9
	lea	r15d, DWORD PTR [rax+2]
	mov	eax, ebp
	seta	al
	test	ecx, eax
	je	SHORT $_match$1525
	npad	8
$LL12@ZSTD_compr:
	movzx	eax, BYTE PTR [r10-1]
	lea	rdx, QWORD PTR [r10-1]
	cmp	BYTE PTR [r14-1], al
	lea	r8, QWORD PTR [r14-1]
	jne	SHORT $_match$1525
	inc	rbx
	mov	ecx, ebp
	cmp	rdx, r11
	mov	eax, ebp
	mov	r14, r8
	mov	r10, rdx
	seta	cl
	cmp	r8, r9
	seta	al
	test	ecx, eax
	jne	SHORT $LL12@ZSTD_compr
$_match$1525:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	lea	rcx, QWORD PTR [rbx+r14]
	lea	rdx, QWORD PTR [rbx+r10]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r11, QWORD PTR [r12-7]

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r11
	jae	SHORT $LN93@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN95@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$16[rsp], ebp
	je	SHORT $LN110@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN91@ZSTD_compr
$LN110@ZSTD_compr:
	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN91@ZSTD_compr
$LN95@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r11
	jae	SHORT $LN93@ZSTD_compr
$LL92@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN96@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r11
	jb	SHORT $LL92@ZSTD_compr
$LN93@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN97@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN97@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN97@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN98@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN98@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN98@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN99@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN99@ZSTD_compr
	inc	rcx
$LN99@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r8
$LN91@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
	lea	r10, QWORD PTR [r12-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	add	rbx, rax

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	mov	rdx, r14
	sub	rdx, r9
	lea	rdi, QWORD PTR [rbx-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdx+r9]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r10
	ja	SHORT $LN135@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	$LN157@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
	add	r9, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdx
	npad	11
$LL149@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]

; 289  :             COPY16(op, ip);

	lea	r9, QWORD PTR [r9+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL149@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN157@ZSTD_compr
$LN96@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$15[rsp], ebp
	je	SHORT $LN126@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN91@ZSTD_compr
$LN126@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	$LN91@ZSTD_compr
$LN135@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	r9, r10
	ja	SHORT $LN1342@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rax, rcx
	sub	rax, r9
	add	r10, rax
	sub	r9, rcx
	npad	3
$LL166@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL166@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	lea	r9, QWORD PTR [r12-32]
$LN1342@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r9, r8
	jae	SHORT $LN157@ZSTD_compr
	sub	rcx, r9
	npad	15
$LL1405@ZSTD_compr:
	movzx	eax, BYTE PTR [r9]
	mov	BYTE PTR [rcx+r9], al
	inc	r9
	cmp	r9, r8
	jb	SHORT $LL1405@ZSTD_compr
$LN157@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rdx
	mov	rcx, QWORD PTR [rsi+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN1461@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1461@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], dx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r15+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN1462@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1462@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 154  :         ip0 += mLength;

	add	r14, rbx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 155  :         anchor = ip0;

	lea	rax, QWORD PTR [r12-8]
	mov	r9, r14
	cmp	r14, rax

; 156  : 
; 157  :         if (ip0 <= ilimit) {

	ja	$LN15@ZSTD_compr

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	eax, DWORD PTR current0$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r8d, r14d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	r9, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r15, QWORD PTR base$1$[rsp]
	mov	rcx, QWORD PTR tv8110[rsp]
	sub	r8d, r15d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	edx, DWORD PTR [rax+2]

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	sub	r8d, 2
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rax+r15+2], -1640531535	; 9e3779b1H
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [r9+rax*4], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r14-2], -1640531535	; 9e3779b1H
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	mov	DWORD PTR [r9+rdx*4], r8d
	mov	r9, r14

; 162  : 
; 163  :             if (offset_2 > 0) { /* offset_2==0 means offset_2 is invalidated */

	test	r13d, r13d
	je	$LN15@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	lea	rdi, QWORD PTR [r12-32]
$LL14@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	mov	ebx, DWORD PTR [r14]
	mov	rdx, r14
	mov	eax, r13d
	sub	rdx, rax
	cmp	ebx, DWORD PTR [rdx]
	jne	$LN1514@ZSTD_compr

; 165  :                     /* store sequence */
; 166  :                     size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;

	lea	rcx, QWORD PTR [r14+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r11
	jae	SHORT $LN232@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN234@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$14[rsp], ebp
	je	SHORT $LN249@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r10d, eax
	jmp	SHORT $LN230@ZSTD_compr
$LN249@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r10d, eax
	jmp	SHORT $LN230@ZSTD_compr
$LN234@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r11
	jae	SHORT $LN232@ZSTD_compr
$LL231@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN235@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r11
	jb	SHORT $LL231@ZSTD_compr
$LN232@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN236@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN236@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN236@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN237@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN237@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN237@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN238@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN238@ZSTD_compr
	inc	rcx
$LN238@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	r10, rcx
	sub	r10, r8
$LN230@ZSTD_compr:

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, QWORD PTR tv8110[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 167  :                     { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; } /* swap offset_2 <=> offset_1 */

	mov	eax, r13d
	mov	r13d, DWORD PTR offset_1$1$[rsp]

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	r8d, r14d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, ebx, -1640531535			; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, 4
	sub	r8d, r15d
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	rax, QWORD PTR hashTable$1$[rsp]
	add	r14, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 170  :                     ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, 0 /*offCode*/, rLength-MINMATCH);

	inc	r10
	mov	DWORD PTR [rax+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [rsi+24]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r9, rdi
	ja	SHORT $LL334@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rax], xmm0
	npad	4
$LL334@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	mov	WORD PTR [rax+4], bp

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r10, 65535				; 0000ffffH
	jbe	SHORT $LN1463@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1463@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r10w
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	lea	rax, QWORD PTR [r12-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 171  :                     anchor = ip0;

	mov	r9, r14
	cmp	r14, rax
	jbe	$LL14@ZSTD_compr
$LN1514@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], r13d
$LN15@ZSTD_compr:

; 175  :     }

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	lea	r15, QWORD PTR [r14+1]
	jmp	SHORT $LN1383@ZSTD_compr
$LN235@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$13[rsp], ebp
	je	SHORT $LN265@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	r10d, edx
	sub	r10, r8
	add	r10, rcx
	jmp	$LN230@ZSTD_compr
$LN265@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	r10d, edx
	sub	r10, r8
	add	r10, rcx
	jmp	$LN230@ZSTD_compr
$LN20@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 133  :         {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;

	mov	rax, r14
	sub	rax, r9
	shr	rax, 7
	add	rax, QWORD PTR stepSize$1$[rsp]

; 134  :             assert(step >= 2);
; 135  :             ip0 += step;

	add	r14, rax

; 136  :             ip1 += step;

	add	r15, rax
$LN1383@ZSTD_compr:

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	rcx, QWORD PTR tv8110[rsp]
	lea	rax, QWORD PTR [r12-8]
	cmp	r15, rax
	jb	$LL10@ZSTD_compr
	mov	r10d, DWORD PTR offset_2$1$[rsp]
	mov	r11d, DWORD PTR tv8678[rsp]
$LN11@ZSTD_compr:

; 176  : 
; 177  :     /* save reps for next block */
; 178  :     rep[0] = offset_1 ? offset_1 : offsetSaved;

	mov	rdx, QWORD PTR rep$[rsp]
	test	r8d, r8d
	mov	ecx, r11d
	cmovne	ecx, r8d

; 179  :     rep[1] = offset_2 ? offset_2 : offsetSaved;

	test	r10d, r10d
	cmovne	r11d, r10d
	mov	DWORD PTR [rdx+4], r11d

; 193  :     {
; 194  :     default: /* includes case 3 */
; 195  :     case 4 :
; 196  :         return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 4);

	jmp	$LN1521@ZSTD_compr
$LN7@ZSTD_compr:

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	neg	eax
	sbb	ecx, ecx
	lea	eax, DWORD PTR [rcx+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r13+184]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	add	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	r11d, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 57   :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [r13+8]

; 58   :     const BYTE* const istart = (const BYTE*)src;
; 59   :     /* We check ip0 (ip + 0) and ip1 (ip + 1) each loop */
; 60   :     const BYTE* ip0 = istart;
; 61   :     const BYTE* ip1;
; 62   :     const BYTE* anchor = istart;
; 63   :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	sub	r8d, edx
	mov	QWORD PTR stepSize$1$[rsp], rax
	add	r8d, ebx
	mov	QWORD PTR base$1$[rsp], rdx

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	mov	ebx, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, edi

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r8d, r11d
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	lea	rax, QWORD PTR [r12-8]
	mov	QWORD PTR ilimit$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r8d, edi
	test	r10d, r10d

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 73   :     ip0 += (ip0 == prefixStart);

	xor	ebp, ebp
	mov	ecx, r8d
	mov	eax, ebp
	add	rcx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR prefixStartIndex$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 68   :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	r8d, DWORD PTR [r14+4]

; 69   :     U32 offsetSaved = 0;

	cmp	r9, rcx
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 73   :     ip0 += (ip0 == prefixStart);

	sete	al
	lea	r14, QWORD PTR [rax+r9]

; 74   :     ip1 = ip0 + 1;
; 75   :     {   U32 const current = (U32)(ip0 - base);

	mov	edx, r14d
	lea	r15, QWORD PTR [r14+1]
	sub	edx, DWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, edx
	mov	eax, edx
	sub	ecx, r11d
	sub	eax, edi
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	mov	eax, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, edi
	test	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r10d, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 77   :         U32 const maxRep = current - windowLow;

	sub	edx, ecx

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	lea	rcx, QWORD PTR [r12-8]
	cmp	r8d, edx
	cmovbe	eax, r8d
	cmovbe	r8d, ebp
	cmp	ebx, edx
	cmovbe	r10d, r8d
	mov	r8d, ebp
	cmovbe	r8d, ebx
	mov	DWORD PTR tv8792[rsp], r10d
	cmp	r15, rcx
	jae	$LN342@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	ecx, 64					; 00000040H
	mov	DWORD PTR offset_2$1$[rsp], eax
	sub	ecx, DWORD PTR [r13+192]
	mov	r10, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	DWORD PTR tv8109[rsp], ecx
	mov	DWORD PTR offset_1$1$[rsp], r8d
	npad	10
$LL1003@ZSTD_compr:
	mov	rdx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r15]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	rsi, QWORD PTR hashTable$1$[rsp]
	mov	r13d, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	imul	rax, r10
	imul	rdx, r10
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 101  :         BYTE const* repMatch = ip2 - offset_1;

	lea	r10, QWORD PTR [r14+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 96   :         U32 const val1 = MEM_read32(ip1);

	mov	ecx, DWORD PTR [r15]
	mov	DWORD PTR val1$1$[rsp], ecx

; 97   :         U32 const current0 = (U32)(ip0-base);

	mov	ecx, r14d
	sub	ecx, DWORD PTR base$1$[rsp]
	mov	DWORD PTR current0$1$[rsp], ecx

; 98   :         U32 const current1 = (U32)(ip1-base);
; 99   :         U32 const matchIndex0 = hashTable[h0];

	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 100  :         U32 const matchIndex1 = hashTable[h1];

	mov	r12d, DWORD PTR [rcx+rax*4]

; 102  :         const BYTE* match0 = base + matchIndex0;
; 103  :         const BYTE* match1 = base + matchIndex1;

	mov	r11d, r12d
	add	r11, QWORD PTR base$1$[rsp]
	mov	edi, DWORD PTR [rcx+rdx*4]
	lea	rcx, QWORD PTR [rcx+rax*4]
	mov	eax, r8d
	mov	r8d, edi
	add	r8, QWORD PTR base$1$[rsp]
	sub	r10, rax

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	eax, DWORD PTR current0$1$[rsp]
	mov	DWORD PTR [rsi+rdx*4], eax
	mov	eax, r15d
	sub	eax, DWORD PTR base$1$[rsp]

; 111  :         hashTable[h1] = current1;   /* update hash table */
; 112  : 
; 113  :         assert(ip0 + 1 == ip1);
; 114  : 
; 115  :         if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {

	mov	edx, DWORD PTR offset_1$1$[rsp]
	mov	rsi, QWORD PTR seqStore$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	ecx, ebp
	mov	eax, DWORD PTR [r14+2]
	cmp	DWORD PTR [r10], eax
	mov	eax, ebp
	sete	cl
	test	edx, edx
	setne	al
	test	ecx, eax
	je	SHORT $LN1011@ZSTD_compr

; 116  :             mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;

	movzx	eax, BYTE PTR [r10-1]
	mov	r11, rbp
	cmp	BYTE PTR [r14+1], al

; 117  :             ip0 = ip2 - mLength;
; 118  :             match0 = repMatch - mLength;

	mov	r8, r10

; 119  :             mLength += 4;
; 120  :             offcode = 0;
; 121  :             goto _match;

	mov	r15d, DWORD PTR offset_2$1$[rsp]
	mov	edi, ebp
	sete	r11b
	mov	r13d, edx
	add	r14, 2
	sub	r8, r11
	sub	r14, r11
	add	r11, 4
	jmp	$_match$1527
$LN1011@ZSTD_compr:

; 122  :         }
; 123  :         if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	edi, eax
	jbe	SHORT $LN1012@ZSTD_compr
	cmp	DWORD PTR [r8], r13d
	je	SHORT $_offset$1528
$LN1012@ZSTD_compr:

; 124  :             /* found a regular match */
; 125  :             goto _offset;
; 126  :         }
; 127  :         if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {

	cmp	r12d, eax
	jbe	$LN1013@ZSTD_compr
	mov	eax, DWORD PTR val1$1$[rsp]
	cmp	DWORD PTR [r11], eax
	jne	$LN1013@ZSTD_compr

; 128  :             /* found a regular match after one literal */
; 129  :             ip0 = ip1;

	mov	r14, r15

; 130  :             match0 = match1;

	mov	r8, r11
$_offset$1528:

; 137  :             continue;
; 138  :         }
; 139  : _offset: /* Requires: ip0, match0 */
; 140  :         /* Compute the offset code */
; 141  :         offset_2 = offset_1;
; 142  :         offset_1 = (U32)(ip0-match0);
; 143  :         offcode = offset_1 + ZSTD_REP_MOVE;
; 144  :         mLength = 4;
; 145  :         /* Count the backwards match length */
; 146  :         while (((ip0>anchor) & (match0>prefixStart))
; 147  :              && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; } /* catch up */

	mov	rbx, QWORD PTR prefixStart$1$[rsp]
	mov	ecx, ebp
	mov	eax, ebp
	mov	DWORD PTR offset_2$1$[rsp], edx
	mov	r13d, r14d
	mov	r15d, edx
	sub	r13d, r8d
	mov	r11d, 4
	cmp	r8, rbx
	mov	DWORD PTR offset_1$1$[rsp], r13d
	seta	cl
	cmp	r14, r9
	lea	edi, DWORD PTR [r13+2]
	seta	al
	test	ecx, eax
	je	SHORT $_match$1527
	npad	9
$LL1005@ZSTD_compr:
	movzx	eax, BYTE PTR [r8-1]
	lea	rdx, QWORD PTR [r8-1]
	cmp	BYTE PTR [r14-1], al
	lea	r10, QWORD PTR [r14-1]
	jne	SHORT $_match$1527
	inc	r11
	mov	ecx, ebp
	cmp	rdx, rbx
	mov	eax, ebp
	mov	r14, r10
	mov	r8, rdx
	seta	cl
	cmp	r10, r9
	seta	al
	test	ecx, eax
	jne	SHORT $LL1005@ZSTD_compr
$_match$1527:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	lea	rcx, QWORD PTR [r11+r14]
	lea	rdx, QWORD PTR [r11+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r10, QWORD PTR [r12-7]

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN1086@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN1088@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$4[rsp], ebp
	je	SHORT $LN1103@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN1084@ZSTD_compr
$LN1103@ZSTD_compr:
	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN1084@ZSTD_compr
$LN1088@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN1086@ZSTD_compr
$LL1085@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN1089@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r10
	jb	SHORT $LL1085@ZSTD_compr
$LN1086@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN1090@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN1090@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN1090@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN1091@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN1091@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN1091@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN1092@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN1092@ZSTD_compr
	inc	rcx
$LN1092@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r8
$LN1084@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	add	r11, rax

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	mov	rdx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rax, QWORD PTR [r12-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	sub	rdx, r9
	lea	rbx, QWORD PTR [r11-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdx+r9]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rax
	ja	SHORT $LN1128@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	$LN1150@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
	add	r9, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdx
	npad	11
$LL1142@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]

; 289  :             COPY16(op, ip);

	lea	r9, QWORD PTR [r9+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL1142@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1150@ZSTD_compr
$LN1089@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$3[rsp], ebp
	je	SHORT $LN1119@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN1084@ZSTD_compr
$LN1119@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	$LN1084@ZSTD_compr
$LN1128@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	r9, rax
	ja	SHORT $LN1352@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rax, rcx
	sub	rax, r9
	add	rax, -32				; ffffffffffffffe0H
	add	rax, r12
	sub	r9, rcx
$LL1159@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+r9]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL1159@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, rax
	lea	r9, QWORD PTR [r12-32]
$LN1352@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r9, r8
	jae	SHORT $LN1150@ZSTD_compr
	sub	rcx, r9
	npad	14
$LL1409@ZSTD_compr:
	movzx	eax, BYTE PTR [r9]
	mov	BYTE PTR [r9+rcx], al
	inc	r9
	cmp	r9, r8
	jb	SHORT $LL1409@ZSTD_compr
$LN1150@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rdx
	mov	rcx, QWORD PTR [rsi+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN1464@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1464@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], dx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rdi+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1465@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1465@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 154  :         ip0 += mLength;

	add	r14, r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 155  :         anchor = ip0;

	lea	rdi, QWORD PTR [r12-8]
	mov	r9, r14
	cmp	r14, rdi

; 156  : 
; 157  :         if (ip0 <= ilimit) {

	ja	$LN1008@ZSTD_compr

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	eax, DWORD PTR current0$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	r11, -3523014627193167104		; cf1bbcdcbfa56300H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	r9, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rbx, QWORD PTR base$1$[rsp]
	mov	ecx, DWORD PTR tv8109[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	r8d, DWORD PTR [rax+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rax+rbx+2]
	imul	rdx, r11
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [r9+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	edx, r14d
	mov	rax, QWORD PTR [r14-2]
	sub	edx, ebx
	imul	rax, r11
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	sub	edx, 2
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	mov	DWORD PTR [r9+rax*4], edx
	mov	r9, r14

; 162  : 
; 163  :             if (offset_2 > 0) { /* offset_2==0 means offset_2 is invalidated */

	test	r15d, r15d
	je	$LN1008@ZSTD_compr
	npad	10
$LL1007@ZSTD_compr:

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	mov	eax, r15d
	mov	rdx, r14
	sub	rdx, rax
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r14], eax
	jne	$LN1516@ZSTD_compr

; 165  :                     /* store sequence */
; 166  :                     size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;

	lea	rcx, QWORD PTR [r14+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r11, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN1225@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN1227@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], ebp
	je	SHORT $LN1242@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r8d, eax
	jmp	SHORT $LN1223@ZSTD_compr
$LN1242@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r8d, eax
	jmp	SHORT $LN1223@ZSTD_compr
$LN1227@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN1225@ZSTD_compr
$LL1224@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN1228@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r10
	jb	SHORT $LL1224@ZSTD_compr
$LN1225@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN1229@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN1229@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN1229@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN1230@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN1230@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN1230@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN1231@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN1231@ZSTD_compr
	inc	rcx
$LN1231@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	r8, rcx
	sub	r8, r11
$LN1223@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 167  :                     { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; } /* swap offset_2 <=> offset_1 */

	mov	eax, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193167104		; cf1bbcdcbfa56300H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	edx, r14d
	mov	r15d, r13d
	mov	r13d, eax
	sub	edx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	imul	rax, rcx
	mov	ecx, DWORD PTR tv8109[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 170  :                     ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, 0 /*offCode*/, rLength-MINMATCH);

	inc	r8
	mov	DWORD PTR [rcx+rax*4], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rcx, QWORD PTR [r12-32]
	mov	rax, QWORD PTR [rsi+24]
	cmp	r9, rcx
	ja	SHORT $LL1327@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rax], xmm0
$LL1327@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	mov	WORD PTR [rax+4], bp

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r8, 65535				; 0000ffffH
	jbe	SHORT $LN1466@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1466@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r8w
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 171  :                     anchor = ip0;

	mov	r9, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	cmp	r14, rdi
	jbe	$LL1007@ZSTD_compr
$LN1516@ZSTD_compr:
	mov	DWORD PTR offset_1$1$[rsp], r13d
	mov	DWORD PTR offset_2$1$[rsp], r15d
$LN1008@ZSTD_compr:

; 172  :                     continue;   /* faster when present (confirmed on gcc-8) ... (?) */
; 173  :         }   }   }
; 174  :         ip1 = ip0 + 1;

	lea	r15, QWORD PTR [r14+1]

; 175  :     }

	jmp	SHORT $LN1390@ZSTD_compr
$LN1228@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], ebp
	je	SHORT $LN1258@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	r8d, edx
	sub	r8, r11
	add	r8, rcx
	jmp	$LN1223@ZSTD_compr
$LN1258@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	r8d, edx
	sub	r8, r11
	add	r8, rcx
	jmp	$LN1223@ZSTD_compr
$LN1013@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 133  :         {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;

	mov	rax, r14
	mov	rdi, QWORD PTR ilimit$1$[rsp]
	sub	rax, r9
	shr	rax, 7
	add	rax, QWORD PTR stepSize$1$[rsp]

; 134  :             assert(step >= 2);
; 135  :             ip0 += step;

	add	r14, rax

; 136  :             ip1 += step;

	add	r15, rax
$LN1390@ZSTD_compr:

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	mov	r10, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	ecx, DWORD PTR tv8109[rsp]
	cmp	r15, rdi
	jb	$LL1003@ZSTD_compr

; 201  :     case 7 :
; 202  :         return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 7);

	mov	r10d, DWORD PTR tv8792[rsp]
	jmp	$LN1522@ZSTD_compr
$LN6@ZSTD_compr:

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	mov	eax, edx
	neg	eax
	sbb	ecx, ecx
	lea	eax, DWORD PTR [rcx+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r13+184]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	add	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	r11d, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 57   :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [r13+8]

; 58   :     const BYTE* const istart = (const BYTE*)src;
; 59   :     /* We check ip0 (ip + 0) and ip1 (ip + 1) each loop */
; 60   :     const BYTE* ip0 = istart;
; 61   :     const BYTE* ip1;
; 62   :     const BYTE* anchor = istart;
; 63   :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	sub	r8d, edx
	mov	QWORD PTR stepSize$1$[rsp], rax
	add	r8d, ebx
	mov	QWORD PTR base$1$[rsp], rdx

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	mov	ebx, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, edi

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r8d, r11d
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	lea	rax, QWORD PTR [r12-8]
	mov	QWORD PTR ilimit$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r8d, edi
	test	r10d, r10d

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 73   :     ip0 += (ip0 == prefixStart);

	xor	ebp, ebp
	mov	ecx, r8d
	mov	eax, ebp
	add	rcx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR prefixStartIndex$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 68   :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	r8d, DWORD PTR [r14+4]

; 69   :     U32 offsetSaved = 0;

	cmp	r9, rcx
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 73   :     ip0 += (ip0 == prefixStart);

	sete	al
	lea	r14, QWORD PTR [rax+r9]

; 74   :     ip1 = ip0 + 1;
; 75   :     {   U32 const current = (U32)(ip0 - base);

	mov	edx, r14d
	lea	r15, QWORD PTR [r14+1]
	sub	edx, DWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, edx
	mov	eax, edx
	sub	ecx, r11d
	sub	eax, edi
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	mov	eax, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, edi
	test	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r10d, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 77   :         U32 const maxRep = current - windowLow;

	sub	edx, ecx

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	lea	rcx, QWORD PTR [r12-8]
	cmp	r8d, edx
	cmovbe	eax, r8d
	cmovbe	r8d, ebp
	cmp	ebx, edx
	cmovbe	r10d, r8d
	mov	r8d, ebp
	cmovbe	r8d, ebx
	mov	DWORD PTR tv8904[rsp], r10d
	cmp	r15, rcx
	jae	$LN342@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	ecx, 64					; 00000040H
	mov	DWORD PTR offset_2$1$[rsp], eax
	sub	ecx, DWORD PTR [r13+192]
	mov	r10, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	DWORD PTR tv8109[rsp], ecx
	mov	DWORD PTR offset_1$1$[rsp], r8d
$LL672@ZSTD_compr:
	mov	rdx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r15]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	rsi, QWORD PTR hashTable$1$[rsp]
	mov	r13d, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, r10
	imul	rdx, r10
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 101  :         BYTE const* repMatch = ip2 - offset_1;

	lea	r10, QWORD PTR [r14+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 96   :         U32 const val1 = MEM_read32(ip1);

	mov	ecx, DWORD PTR [r15]
	mov	DWORD PTR val1$1$[rsp], ecx

; 97   :         U32 const current0 = (U32)(ip0-base);

	mov	ecx, r14d
	sub	ecx, DWORD PTR base$1$[rsp]
	mov	DWORD PTR current0$1$[rsp], ecx

; 98   :         U32 const current1 = (U32)(ip1-base);
; 99   :         U32 const matchIndex0 = hashTable[h0];

	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 100  :         U32 const matchIndex1 = hashTable[h1];

	mov	r12d, DWORD PTR [rcx+rax*4]

; 102  :         const BYTE* match0 = base + matchIndex0;
; 103  :         const BYTE* match1 = base + matchIndex1;

	mov	r11d, r12d
	add	r11, QWORD PTR base$1$[rsp]
	mov	edi, DWORD PTR [rcx+rdx*4]
	lea	rcx, QWORD PTR [rcx+rax*4]
	mov	eax, r8d
	mov	r8d, edi
	add	r8, QWORD PTR base$1$[rsp]
	sub	r10, rax

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	eax, DWORD PTR current0$1$[rsp]
	mov	DWORD PTR [rsi+rdx*4], eax
	mov	eax, r15d
	sub	eax, DWORD PTR base$1$[rsp]

; 111  :         hashTable[h1] = current1;   /* update hash table */
; 112  : 
; 113  :         assert(ip0 + 1 == ip1);
; 114  : 
; 115  :         if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {

	mov	edx, DWORD PTR offset_1$1$[rsp]
	mov	rsi, QWORD PTR seqStore$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	ecx, ebp
	mov	eax, DWORD PTR [r14+2]
	cmp	DWORD PTR [r10], eax
	mov	eax, ebp
	sete	cl
	test	edx, edx
	setne	al
	test	ecx, eax
	je	SHORT $LN680@ZSTD_compr

; 116  :             mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;

	movzx	eax, BYTE PTR [r10-1]
	mov	r11, rbp
	cmp	BYTE PTR [r14+1], al

; 117  :             ip0 = ip2 - mLength;
; 118  :             match0 = repMatch - mLength;

	mov	r8, r10

; 119  :             mLength += 4;
; 120  :             offcode = 0;
; 121  :             goto _match;

	mov	r15d, DWORD PTR offset_2$1$[rsp]
	mov	edi, ebp
	sete	r11b
	mov	r13d, edx
	add	r14, 2
	sub	r8, r11
	sub	r14, r11
	add	r11, 4
	jmp	$_match$1529
$LN680@ZSTD_compr:

; 122  :         }
; 123  :         if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	edi, eax
	jbe	SHORT $LN681@ZSTD_compr
	cmp	DWORD PTR [r8], r13d
	je	SHORT $_offset$1530
$LN681@ZSTD_compr:

; 124  :             /* found a regular match */
; 125  :             goto _offset;
; 126  :         }
; 127  :         if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {

	cmp	r12d, eax
	jbe	$LN682@ZSTD_compr
	mov	eax, DWORD PTR val1$1$[rsp]
	cmp	DWORD PTR [r11], eax
	jne	$LN682@ZSTD_compr

; 128  :             /* found a regular match after one literal */
; 129  :             ip0 = ip1;

	mov	r14, r15

; 130  :             match0 = match1;

	mov	r8, r11
$_offset$1530:

; 137  :             continue;
; 138  :         }
; 139  : _offset: /* Requires: ip0, match0 */
; 140  :         /* Compute the offset code */
; 141  :         offset_2 = offset_1;
; 142  :         offset_1 = (U32)(ip0-match0);
; 143  :         offcode = offset_1 + ZSTD_REP_MOVE;
; 144  :         mLength = 4;
; 145  :         /* Count the backwards match length */
; 146  :         while (((ip0>anchor) & (match0>prefixStart))
; 147  :              && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; } /* catch up */

	mov	rbx, QWORD PTR prefixStart$1$[rsp]
	mov	ecx, ebp
	mov	eax, ebp
	mov	DWORD PTR offset_2$1$[rsp], edx
	mov	r13d, r14d
	mov	r15d, edx
	sub	r13d, r8d
	mov	r11d, 4
	cmp	r8, rbx
	mov	DWORD PTR offset_1$1$[rsp], r13d
	seta	cl
	cmp	r14, r9
	lea	edi, DWORD PTR [r13+2]
	seta	al
	test	ecx, eax
	je	SHORT $_match$1529
	npad	8
$LL674@ZSTD_compr:
	movzx	eax, BYTE PTR [r8-1]
	lea	r10, QWORD PTR [r8-1]
	cmp	BYTE PTR [r14-1], al
	lea	rdx, QWORD PTR [r14-1]
	jne	SHORT $_match$1529
	inc	r11
	mov	ecx, ebp
	cmp	r10, rbx
	mov	eax, ebp
	mov	r14, rdx
	mov	r8, r10
	seta	cl
	cmp	rdx, r9
	seta	al
	test	ecx, eax
	jne	SHORT $LL674@ZSTD_compr
$_match$1529:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	lea	rcx, QWORD PTR [r14+r11]
	lea	rdx, QWORD PTR [r11+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r10, QWORD PTR [r12-7]

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN755@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN757@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$8[rsp], ebp
	je	SHORT $LN772@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN753@ZSTD_compr
$LN772@ZSTD_compr:
	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN753@ZSTD_compr
$LN757@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN755@ZSTD_compr
$LL754@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN758@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r10
	jb	SHORT $LL754@ZSTD_compr
$LN755@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN759@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN759@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN759@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN760@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN760@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN760@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN761@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN761@ZSTD_compr
	inc	rcx
$LN761@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r8
$LN753@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	add	r11, rax

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	mov	rdx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rax, QWORD PTR [r12-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	sub	rdx, r9
	lea	rbx, QWORD PTR [r11-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r9+rdx]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rax
	ja	SHORT $LN797@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	$LN819@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
	add	r9, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdx
	npad	11
$LL811@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]

; 289  :             COPY16(op, ip);

	lea	r9, QWORD PTR [r9+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL811@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN819@ZSTD_compr
$LN758@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$7[rsp], ebp
	je	SHORT $LN788@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN753@ZSTD_compr
$LN788@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	$LN753@ZSTD_compr
$LN797@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	r9, rax
	ja	SHORT $LN1362@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rax, rcx
	sub	rax, r9
	add	rax, -32				; ffffffffffffffe0H
	add	rax, r12
	sub	r9, rcx
$LL828@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL828@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, rax
	lea	r9, QWORD PTR [r12-32]
$LN1362@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r9, r8
	jae	SHORT $LN819@ZSTD_compr
	sub	rcx, r9
	npad	14
$LL1413@ZSTD_compr:
	movzx	eax, BYTE PTR [r9]
	mov	BYTE PTR [rcx+r9], al
	inc	r9
	cmp	r9, r8
	jb	SHORT $LL1413@ZSTD_compr
$LN819@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rdx
	mov	rcx, QWORD PTR [rsi+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN1467@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1467@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], dx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rdi+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1468@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1468@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 154  :         ip0 += mLength;

	add	r14, r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 155  :         anchor = ip0;

	lea	rdi, QWORD PTR [r12-8]
	mov	r9, r14
	cmp	r14, rdi

; 156  : 
; 157  :         if (ip0 <= ilimit) {

	ja	$LN677@ZSTD_compr

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	eax, DWORD PTR current0$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r11, -3523014627193847808		; cf1bbcdcbf9b0000H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	r9, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rbx, QWORD PTR base$1$[rsp]
	mov	ecx, DWORD PTR tv8109[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	r8d, DWORD PTR [rax+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rax+rbx+2]
	imul	rdx, r11
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [r9+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	edx, r14d
	mov	rax, QWORD PTR [r14-2]
	sub	edx, ebx
	imul	rax, r11
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	sub	edx, 2
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	mov	DWORD PTR [r9+rax*4], edx
	mov	r9, r14

; 162  : 
; 163  :             if (offset_2 > 0) { /* offset_2==0 means offset_2 is invalidated */

	test	r15d, r15d
	je	$LN677@ZSTD_compr
	npad	10
$LL676@ZSTD_compr:

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	mov	eax, r15d
	mov	rdx, r14
	sub	rdx, rax
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r14], eax
	jne	$LN1518@ZSTD_compr

; 165  :                     /* store sequence */
; 166  :                     size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;

	lea	rcx, QWORD PTR [r14+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r11, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN894@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN896@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$6[rsp], ebp
	je	SHORT $LN911@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r8d, eax
	jmp	SHORT $LN892@ZSTD_compr
$LN911@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r8d, eax
	jmp	SHORT $LN892@ZSTD_compr
$LN896@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN894@ZSTD_compr
$LL893@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rdx]
	xor	rax, QWORD PTR [rcx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN897@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r10
	jb	SHORT $LL893@ZSTD_compr
$LN894@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN898@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN898@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN898@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN899@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN899@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN899@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN900@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN900@ZSTD_compr
	inc	rcx
$LN900@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	r8, rcx
	sub	r8, r11
$LN892@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 167  :                     { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; } /* swap offset_2 <=> offset_1 */

	mov	eax, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	edx, r14d
	mov	r15d, r13d
	mov	r13d, eax
	sub	edx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	imul	rax, rcx
	mov	ecx, DWORD PTR tv8109[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 170  :                     ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, 0 /*offCode*/, rLength-MINMATCH);

	inc	r8
	mov	DWORD PTR [rcx+rax*4], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rcx, QWORD PTR [r12-32]
	mov	rax, QWORD PTR [rsi+24]
	cmp	r9, rcx
	ja	SHORT $LL996@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rax], xmm0
$LL996@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	mov	WORD PTR [rax+4], bp

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r8, 65535				; 0000ffffH
	jbe	SHORT $LN1469@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1469@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r8w
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 171  :                     anchor = ip0;

	mov	r9, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	cmp	r14, rdi
	jbe	$LL676@ZSTD_compr
$LN1518@ZSTD_compr:
	mov	DWORD PTR offset_1$1$[rsp], r13d
	mov	DWORD PTR offset_2$1$[rsp], r15d
$LN677@ZSTD_compr:

; 172  :                     continue;   /* faster when present (confirmed on gcc-8) ... (?) */
; 173  :         }   }   }
; 174  :         ip1 = ip0 + 1;

	lea	r15, QWORD PTR [r14+1]

; 175  :     }

	jmp	SHORT $LN1397@ZSTD_compr
$LN897@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$5[rsp], ebp
	je	SHORT $LN927@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	r8d, edx
	sub	r8, r11
	add	r8, rcx
	jmp	$LN892@ZSTD_compr
$LN927@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	r8d, edx
	sub	r8, r11
	add	r8, rcx
	jmp	$LN892@ZSTD_compr
$LN682@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 133  :         {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;

	mov	rax, r14
	mov	rdi, QWORD PTR ilimit$1$[rsp]
	sub	rax, r9
	shr	rax, 7
	add	rax, QWORD PTR stepSize$1$[rsp]

; 134  :             assert(step >= 2);
; 135  :             ip0 += step;

	add	r14, rax

; 136  :             ip1 += step;

	add	r15, rax
$LN1397@ZSTD_compr:

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	mov	r10, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	ecx, DWORD PTR tv8109[rsp]
	cmp	r15, rdi
	jb	$LL672@ZSTD_compr

; 197  :     case 5 :
; 198  :         return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 5);
; 199  :     case 6 :
; 200  :         return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 6);

	mov	r10d, DWORD PTR tv8904[rsp]
	jmp	$LN1522@ZSTD_compr
$LN5@ZSTD_compr:

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	mov	eax, edx
	neg	eax
	sbb	ecx, ecx
	lea	eax, DWORD PTR [rcx+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [r13+184]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	add	eax, edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	shl	r11d, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 57   :     const BYTE* const base = ms->window.base;

	mov	rdx, QWORD PTR [r13+8]

; 58   :     const BYTE* const istart = (const BYTE*)src;
; 59   :     /* We check ip0 (ip + 0) and ip1 (ip + 1) each loop */
; 60   :     const BYTE* ip0 = istart;
; 61   :     const BYTE* ip1;
; 62   :     const BYTE* anchor = istart;
; 63   :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	sub	r8d, edx
	mov	QWORD PTR stepSize$1$[rsp], rax
	add	r8d, ebx
	mov	QWORD PTR base$1$[rsp], rdx

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	mov	ebx, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r8d
	sub	eax, edi

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r8d, r11d
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 67   :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	lea	rax, QWORD PTR [r12-8]
	mov	QWORD PTR ilimit$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	r8d, edi
	test	r10d, r10d

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r8d, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 73   :     ip0 += (ip0 == prefixStart);

	xor	ebp, ebp
	mov	ecx, r8d
	mov	eax, ebp
	add	rcx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR prefixStartIndex$1$[rsp], r8d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 68   :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	r8d, DWORD PTR [r14+4]

; 69   :     U32 offsetSaved = 0;

	cmp	r9, rcx
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 73   :     ip0 += (ip0 == prefixStart);

	sete	al
	lea	r14, QWORD PTR [rax+r9]

; 74   :     ip1 = ip0 + 1;
; 75   :     {   U32 const current = (U32)(ip0 - base);

	mov	edx, r14d
	lea	r15, QWORD PTR [r14+1]
	sub	edx, DWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, edx
	mov	eax, edx
	sub	ecx, r11d
	sub	eax, edi
	cmp	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	mov	eax, ebp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, edi
	test	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r10d, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 77   :         U32 const maxRep = current - windowLow;

	sub	edx, ecx

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	lea	rcx, QWORD PTR [r12-8]
	cmp	r8d, edx
	cmovbe	eax, r8d
	cmovbe	r8d, ebp
	cmp	ebx, edx
	cmovbe	r10d, r8d
	mov	r8d, ebp
	cmovbe	r8d, ebx
	mov	DWORD PTR tv9147[rsp], r10d
	cmp	r15, rcx
	jae	$LN342@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	ecx, 64					; 00000040H
	mov	DWORD PTR offset_2$1$[rsp], eax
	sub	ecx, DWORD PTR [r13+192]
	mov	r10, -3523014627271114752		; cf1bbcdcbb000000H
	mov	DWORD PTR tv8109[rsp], ecx
	mov	DWORD PTR offset_1$1$[rsp], r8d
$LL341@ZSTD_compr:
	mov	rdx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r15]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	rsi, QWORD PTR hashTable$1$[rsp]
	mov	r13d, DWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	imul	rax, r10
	imul	rdx, r10
	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 101  :         BYTE const* repMatch = ip2 - offset_1;

	lea	r10, QWORD PTR [r14+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 96   :         U32 const val1 = MEM_read32(ip1);

	mov	ecx, DWORD PTR [r15]
	mov	DWORD PTR val1$1$[rsp], ecx

; 97   :         U32 const current0 = (U32)(ip0-base);

	mov	ecx, r14d
	sub	ecx, DWORD PTR base$1$[rsp]
	mov	DWORD PTR current0$1$[rsp], ecx

; 98   :         U32 const current1 = (U32)(ip1-base);
; 99   :         U32 const matchIndex0 = hashTable[h0];

	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 100  :         U32 const matchIndex1 = hashTable[h1];

	mov	r12d, DWORD PTR [rcx+rax*4]

; 102  :         const BYTE* match0 = base + matchIndex0;
; 103  :         const BYTE* match1 = base + matchIndex1;

	mov	r11d, r12d
	add	r11, QWORD PTR base$1$[rsp]
	mov	edi, DWORD PTR [rcx+rdx*4]
	lea	rcx, QWORD PTR [rcx+rax*4]
	mov	eax, r8d
	mov	r8d, edi
	add	r8, QWORD PTR base$1$[rsp]
	sub	r10, rax

; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	eax, DWORD PTR current0$1$[rsp]
	mov	DWORD PTR [rsi+rdx*4], eax
	mov	eax, r15d
	sub	eax, DWORD PTR base$1$[rsp]

; 111  :         hashTable[h1] = current1;   /* update hash table */
; 112  : 
; 113  :         assert(ip0 + 1 == ip1);
; 114  : 
; 115  :         if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {

	mov	edx, DWORD PTR offset_1$1$[rsp]
	mov	rsi, QWORD PTR seqStore$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	ecx, ebp
	mov	eax, DWORD PTR [r14+2]
	cmp	DWORD PTR [r10], eax
	mov	eax, ebp
	sete	cl
	test	edx, edx
	setne	al
	test	ecx, eax
	je	SHORT $LN349@ZSTD_compr

; 116  :             mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;

	movzx	eax, BYTE PTR [r10-1]
	mov	r11, rbp
	cmp	BYTE PTR [r14+1], al

; 117  :             ip0 = ip2 - mLength;
; 118  :             match0 = repMatch - mLength;

	mov	r8, r10

; 119  :             mLength += 4;
; 120  :             offcode = 0;
; 121  :             goto _match;

	mov	r15d, DWORD PTR offset_2$1$[rsp]
	mov	edi, ebp
	sete	r11b
	mov	r13d, edx
	add	r14, 2
	sub	r8, r11
	sub	r14, r11
	add	r11, 4
	jmp	$_match$1531
$LN349@ZSTD_compr:

; 122  :         }
; 123  :         if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	edi, eax
	jbe	SHORT $LN350@ZSTD_compr
	cmp	DWORD PTR [r8], r13d
	je	SHORT $_offset$1532
$LN350@ZSTD_compr:

; 124  :             /* found a regular match */
; 125  :             goto _offset;
; 126  :         }
; 127  :         if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {

	cmp	r12d, eax
	jbe	$LN351@ZSTD_compr
	mov	eax, DWORD PTR val1$1$[rsp]
	cmp	DWORD PTR [r11], eax
	jne	$LN351@ZSTD_compr

; 128  :             /* found a regular match after one literal */
; 129  :             ip0 = ip1;

	mov	r14, r15

; 130  :             match0 = match1;

	mov	r8, r11
$_offset$1532:

; 137  :             continue;
; 138  :         }
; 139  : _offset: /* Requires: ip0, match0 */
; 140  :         /* Compute the offset code */
; 141  :         offset_2 = offset_1;
; 142  :         offset_1 = (U32)(ip0-match0);
; 143  :         offcode = offset_1 + ZSTD_REP_MOVE;
; 144  :         mLength = 4;
; 145  :         /* Count the backwards match length */
; 146  :         while (((ip0>anchor) & (match0>prefixStart))
; 147  :              && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; } /* catch up */

	mov	rbx, QWORD PTR prefixStart$1$[rsp]
	mov	ecx, ebp
	mov	eax, ebp
	mov	DWORD PTR offset_2$1$[rsp], edx
	mov	r13d, r14d
	mov	r15d, edx
	sub	r13d, r8d
	mov	r11d, 4
	cmp	r8, rbx
	mov	DWORD PTR offset_1$1$[rsp], r13d
	seta	cl
	cmp	r14, r9
	lea	edi, DWORD PTR [r13+2]
	seta	al
	test	ecx, eax
	je	SHORT $_match$1531
	npad	8
$LL343@ZSTD_compr:
	movzx	eax, BYTE PTR [r8-1]
	lea	rdx, QWORD PTR [r8-1]
	cmp	BYTE PTR [r14-1], al
	lea	r10, QWORD PTR [r14-1]
	jne	SHORT $_match$1531
	inc	r11
	mov	ecx, ebp
	cmp	rdx, rbx
	mov	eax, ebp
	mov	r14, r10
	mov	r8, rdx
	seta	cl
	cmp	r10, r9
	seta	al
	test	ecx, eax
	jne	SHORT $LL343@ZSTD_compr
$_match$1531:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	lea	rcx, QWORD PTR [r11+r14]
	lea	rdx, QWORD PTR [r11+r8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r10, QWORD PTR [r12-7]

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN424@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN426@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$12[rsp], ebp
	je	SHORT $LN441@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN422@ZSTD_compr
$LN441@ZSTD_compr:
	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN422@ZSTD_compr
$LN426@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN424@ZSTD_compr
$LL423@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN427@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r10
	jb	SHORT $LL423@ZSTD_compr
$LN424@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN428@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN428@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN428@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN429@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN429@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN429@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN430@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN430@ZSTD_compr
	inc	rcx
$LN430@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r8
$LN422@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rsi+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	add	r11, rax

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	mov	rdx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rax, QWORD PTR [r12-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	sub	rdx, r9
	lea	rbx, QWORD PTR [r11-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdx+r9]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rax
	ja	SHORT $LN466@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	$LN488@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rsi+24]
	add	r9, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdx
	npad	11
$LL480@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]

; 289  :             COPY16(op, ip);

	lea	r9, QWORD PTR [r9+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL480@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN488@ZSTD_compr
$LN427@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$11[rsp], ebp
	je	SHORT $LN457@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN422@ZSTD_compr
$LN457@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	$LN422@ZSTD_compr
$LN466@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	r9, rax
	ja	SHORT $LN1372@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rax, rcx
	sub	rax, r9
	add	rax, -32				; ffffffffffffffe0H
	add	rax, r12
	sub	r9, rcx
$LL497@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+r9]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL497@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, rax
	lea	r9, QWORD PTR [r12-32]
$LN1372@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r9, r8
	jae	SHORT $LN488@ZSTD_compr
	sub	rcx, r9
	npad	14
$LL1417@ZSTD_compr:
	movzx	eax, BYTE PTR [r9]
	mov	BYTE PTR [r9+rcx], al
	inc	r9
	cmp	r9, r8
	jb	SHORT $LL1417@ZSTD_compr
$LN488@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rsi+24], rdx
	mov	rcx, QWORD PTR [rsi+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN1470@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 1
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1470@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], dx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rdi+1]
	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rbx, 65535				; 0000ffffH
	jbe	SHORT $LN1471@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1471@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 154  :         ip0 += mLength;

	add	r14, r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], bx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 155  :         anchor = ip0;

	lea	rdi, QWORD PTR [r12-8]
	mov	r9, r14
	cmp	r14, rdi

; 156  : 
; 157  :         if (ip0 <= ilimit) {

	ja	$LN346@ZSTD_compr

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	eax, DWORD PTR current0$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	r11, -3523014627271114752		; cf1bbcdcbb000000H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	r9, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rbx, QWORD PTR base$1$[rsp]
	mov	ecx, DWORD PTR tv8109[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	r8d, DWORD PTR [rax+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rax+rbx+2]
	imul	rdx, r11
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [r9+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	edx, r14d
	mov	rax, QWORD PTR [r14-2]
	sub	edx, ebx
	imul	rax, r11
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	sub	edx, 2
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	mov	DWORD PTR [r9+rax*4], edx
	mov	r9, r14

; 162  : 
; 163  :             if (offset_2 > 0) { /* offset_2==0 means offset_2 is invalidated */

	test	r15d, r15d
	je	$LN346@ZSTD_compr
	npad	10
$LL345@ZSTD_compr:

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	mov	eax, r15d
	mov	rdx, r14
	sub	rdx, rax
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r14], eax
	jne	$LN1520@ZSTD_compr

; 165  :                     /* store sequence */
; 166  :                     size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;

	lea	rcx, QWORD PTR [r14+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r11, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN563@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN565@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$10[rsp], ebp
	je	SHORT $LN580@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r8d, eax
	jmp	SHORT $LN561@ZSTD_compr
$LN580@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	r8d, eax
	jmp	SHORT $LN561@ZSTD_compr
$LN565@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r10
	jae	SHORT $LN563@ZSTD_compr
$LL562@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN566@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r10
	jb	SHORT $LL562@ZSTD_compr
$LN563@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r12-3]
	cmp	rcx, rax
	jae	SHORT $LN567@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN567@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN567@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r12-1]
	cmp	rcx, rax
	jae	SHORT $LN568@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN568@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN568@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r12
	jae	SHORT $LN569@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN569@ZSTD_compr
	inc	rcx
$LN569@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	r8, rcx
	sub	r8, r11
$LN561@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 167  :                     { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; } /* swap offset_2 <=> offset_1 */

	mov	eax, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	edx, r14d
	mov	r15d, r13d
	mov	r13d, eax
	sub	edx, ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [r14]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	imul	rax, rcx
	mov	ecx, DWORD PTR tv8109[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 169  :                     ip0 += rLength;

	add	r14, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rax, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 170  :                     ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, 0 /*offCode*/, rLength-MINMATCH);

	inc	r8
	mov	DWORD PTR [rcx+rax*4], edx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rcx, QWORD PTR [r12-32]
	mov	rax, QWORD PTR [rsi+24]
	cmp	r9, rcx
	ja	SHORT $LL665@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rax], xmm0
$LL665@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rsi+8]
	mov	WORD PTR [rax+4], bp

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rsi+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rsi+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r8, 65535				; 0000ffffH
	jbe	SHORT $LN1472@ZSTD_compr

; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rsi+72], 2
	sub	rax, QWORD PTR [rsi]
	sar	rax, 3
	mov	DWORD PTR [rsi+76], eax
$LN1472@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r8w
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 171  :                     anchor = ip0;

	mov	r9, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rsi+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	cmp	r14, rdi
	jbe	$LL345@ZSTD_compr
$LN1520@ZSTD_compr:
	mov	DWORD PTR offset_1$1$[rsp], r13d
	mov	DWORD PTR offset_2$1$[rsp], r15d
$LN346@ZSTD_compr:

; 172  :                     continue;   /* faster when present (confirmed on gcc-8) ... (?) */
; 173  :         }   }   }
; 174  :         ip1 = ip0 + 1;

	lea	r15, QWORD PTR [r14+1]

; 175  :     }

	jmp	SHORT $LN1404@ZSTD_compr
$LN566@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$9[rsp], ebp
	je	SHORT $LN596@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	r8d, edx
	sub	r8, r11
	add	r8, rcx
	jmp	$LN561@ZSTD_compr
$LN596@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	r8d, edx
	sub	r8, r11
	add	r8, rcx
	jmp	$LN561@ZSTD_compr
$LN351@ZSTD_compr:
	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 133  :         {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;

	mov	rax, r14
	mov	rdi, QWORD PTR ilimit$1$[rsp]
	sub	rax, r9
	shr	rax, 7
	add	rax, QWORD PTR stepSize$1$[rsp]

; 134  :             assert(step >= 2);
; 135  :             ip0 += step;

	add	r14, rax

; 136  :             ip1 += step;

	add	r15, rax
$LN1404@ZSTD_compr:

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	mov	r10, -3523014627271114752		; cf1bbcdcbb000000H
	mov	ecx, DWORD PTR tv8109[rsp]
	cmp	r15, rdi
	jb	$LL341@ZSTD_compr
	mov	r10d, DWORD PTR tv9147[rsp]
$LN1522@ZSTD_compr:

; 203  :     }
; 204  : }

	mov	eax, DWORD PTR offset_2$1$[rsp]
$LN342@ZSTD_compr:
	mov	rdx, QWORD PTR rep$[rsp]
	test	r8d, r8d
	mov	ecx, r10d
	cmovne	ecx, r8d
	test	eax, eax
	cmovne	r10d, eax
	mov	DWORD PTR [rdx+4], r10d
$LN1521@ZSTD_compr:
	mov	rbx, QWORD PTR [rsp+168]
	sub	r12, r9
	mov	rax, r12
	mov	DWORD PTR [rdx], ecx
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressBlock_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
offset_2$1$ = 48
iend$1$ = 56
iend$1$ = 56
iend$1$ = 56
iend$1$ = 56
hlog$1$ = 64
dictIndexDelta$1$ = 68
dictIndexDelta$1$ = 68
dictIndexDelta$1$ = 68
dictIndexDelta$1$ = 68
prefixStart$1$ = 72
prefixStart$1$ = 72
prefixStart$1$ = 72
prefixStart$1$ = 72
current$1$ = 80
current$1$ = 80
current$1$ = 80
stepSize$1$ = 80
stepSize$1$ = 84
stepSize$1$ = 84
stepSize$1$ = 84
current$1$ = 84
dictEnd$1$ = 88
dictEnd$1$ = 88
dictEnd$1$ = 88
dictEnd$1$ = 88
prefixStartIndex$1$ = 96
base$1$ = 104
dictStartIndex$1$ = 112
dictStartIndex$1$ = 112
dictStartIndex$1$ = 112
dictHLog$1$ = 112
dictHLog$1$ = 116
dictHLog$1$ = 116
dictHLog$1$ = 116
dictStartIndex$1$ = 116
dictBase$1$ = 120
dictBase$1$ = 120
dictBase$1$ = 120
dictBase$1$ = 120
hashTable$1$ = 128
ilimit$1$ = 136
ilimit$1$ = 136
ilimit$1$ = 136
litLimit_w$1$ = 136
dictStart$1$ = 144
dictHashTable$1$ = 144
dictHashTable$1$ = 144
dictStart$1$ = 144
dictHashTable$1$ = 152
litLimit_w$1$ = 152
litLimit_w$1$ = 152
ilimit$1$ = 152
dictStart$1$ = 160
dictStart$1$ = 160
dictHashTable$1$ = 160
offset_1$1$ = 240
ms$ = 240
seqStore$ = 248
rep$ = 256
src$ = 264
srcSize$ = 272
ZSTD_compressBlock_fast_dictMatchState PROC

; 357  : {

$LN2086:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H

; 358  :     U32 const mls = ms->cParams.minMatch;
; 359  :     assert(ms->dictMatchState != NULL);
; 360  :     switch(mls)

	mov	rax, QWORD PTR [rcx+48]
	mov	r14, r9
	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, rdx
	mov	r11d, DWORD PTR [rcx+24]
	mov	r13d, DWORD PTR [rcx+192]
	mov	r9d, DWORD PTR [rcx+204]
	mov	rdx, QWORD PTR [rcx+176]
	mov	QWORD PTR hashTable$1$[rsp], rax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR offset_1$1$[rsp], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR offset_2$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+200]
	mov	DWORD PTR hlog$1$[rsp], r13d
	mov	QWORD PTR base$1$[rsp], rdi
	mov	DWORD PTR prefixStartIndex$1$[rsp], r11d
	sub	eax, 5
	je	$LN5@ZSTD_compr
	sub	eax, 1
	je	$LN6@ZSTD_compr
	xor	r10d, r10d
	cmp	eax, 1
	mov	eax, r10d
	je	$LN7@ZSTD_compr

; 231  :     const BYTE* const dictBase     = dms->window.base;

	mov	rbp, QWORD PTR [rdx+8]
	lea	r12, QWORD PTR [rdi+r11]
	mov	rsi, QWORD PTR srcSize$[rsp]
	test	r9d, r9d
	mov	QWORD PTR prefixStart$1$[rsp], r12
	sete	al
	mov	QWORD PTR dictBase$1$[rsp], rbp
	add	eax, r9d
	add	rsi, r14

; 232  :     const BYTE* const dictStart    = dictBase + dictStartIndex;
; 233  :     const BYTE* const dictEnd      = dms->window.nextSrc;

	mov	r9, QWORD PTR [rdx]
	mov	DWORD PTR stepSize$1$[rsp], eax
	mov	rax, QWORD PTR [rdx+48]
	mov	QWORD PTR dictHashTable$1$[rsp], rax
	lea	rcx, QWORD PTR [rsi-8]
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR dictStartIndex$1$[rsp], eax
	mov	QWORD PTR iend$1$[rsp], rsi
	mov	QWORD PTR ilimit$1$[rsp], rcx
	lea	r8, QWORD PTR [rax+rbp]
	mov	QWORD PTR dictEnd$1$[rsp], r9

; 234  :     const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);

	mov	eax, ebp
	mov	QWORD PTR dictStart$1$[rsp], r8
	sub	eax, r9d
	add	eax, r11d
	mov	DWORD PTR dictIndexDelta$1$[rsp], eax

; 235  :     const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);
; 236  :     const U32 dictHLog             = dictCParams->hashLog;

	mov	eax, DWORD PTR [rdx+192]
	mov	DWORD PTR dictHLog$1$[rsp], eax

; 237  : 
; 238  :     /* if a dictionary is still attached, it necessarily means that
; 239  :      * it is within window size. So we just check it. */
; 240  :     const U32 maxDistance = 1U << cParams->windowLog;
; 241  :     const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);
; 242  :     assert(endIndex - prefixStartIndex <= maxDistance);
; 243  :     (void)maxDistance; (void)endIndex;   /* these variables are not used when assert() is disabled */
; 244  : 
; 245  :     /* ensure there will be no no underflow
; 246  :      * when translating a dict index into a local index */
; 247  :     assert(prefixStartIndex >= (U32)(dictEnd - dictBase));
; 248  : 
; 249  :     /* init */
; 250  :     DEBUGLOG(5, "ZSTD_compressBlock_fast_dictMatchState_generic");
; 251  :     ip += (dictAndPrefixLength == 0);

	mov	eax, r14d
	sub	eax, r12d
	sub	eax, r8d
	add	eax, r9d
	mov	eax, r10d
	sete	al
	lea	r15, QWORD PTR [rax+r14]
	cmp	r15, rcx

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	jae	$LN313@ZSTD_compr
	npad	6
$LL10@ZSTD_compr:

; 259  :         size_t mLength;
; 260  :         size_t const h = ZSTD_hashPtr(ip, hlog, mls);

	mov	r8d, 4
	mov	edx, r13d
	mov	rcx, r15
	call	ZSTD_hashPtr

; 261  :         U32 const current = (U32)(ip-base);
; 262  :         U32 const matchIndex = hashTable[h];

	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	r13d, r15d
	mov	r9d, DWORD PTR [rcx+rax*4]
	sub	r13d, edi

; 263  :         const BYTE* match = base + matchIndex;
; 264  :         const U32 repIndex = current + 1 - offset_1;
; 265  :         const BYTE* repMatch = (repIndex < prefixStartIndex) ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edx, r13d
	sub	edx, DWORD PTR offset_1$1$[rsp]
	lea	r8, QWORD PTR [rcx+rax*4]
	add	rdi, r9
	mov	DWORD PTR current$1$[rsp], r13d
	inc	edx
	cmp	edx, r10d
	jae	SHORT $LN30@ZSTD_compr
	mov	ecx, edx
	sub	ecx, DWORD PTR dictIndexDelta$1$[rsp]
	add	rcx, rbp
	jmp	SHORT $LN31@ZSTD_compr
$LN30@ZSTD_compr:
	mov	ecx, edx
	add	rcx, QWORD PTR base$1$[rsp]
$LN31@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, r10d
	mov	DWORD PTR [r8], r13d
	sub	eax, edx
	dec	eax
	cmp	eax, 3
	jb	$LN18@ZSTD_compr
	mov	eax, DWORD PTR [r15+1]
	lea	r12, QWORD PTR [r15+1]
	cmp	DWORD PTR [rcx], eax
	jne	$LN2057@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	lea	rdi, QWORD PTR [rcx+4]
	cmp	edx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 272  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	r15, 5
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, r8
	cmovb	r8, rcx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rcx, r15
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, rsi
	mov	rsi, QWORD PTR iend$1$[rsp]
	jne	SHORT $LN118@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+rbp]
	mov	r8, rsi
	call	ZSTD_count
	add	rbp, rax
$LN118@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
	lea	r9, QWORD PTR [rsi-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	rbp, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	QWORD PTR litLimit_w$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 274  :             ip++;

	mov	r15, r12

; 275  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);

	sub	r12, r14
	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r12+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN124@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r12, 16
	jbe	SHORT $LN125@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r12
	npad	10
$LL138@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL138@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN125@ZSTD_compr
$LN124@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN125@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], r12
	mov	rcx, QWORD PTR [rbx+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r12, 65535				; 0000ffffH
	jbe	SHORT $LN1985@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1985@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r12w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN1986@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1986@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	mov	r12, QWORD PTR litLimit_w$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	jmp	$LN2064@ZSTD_compr
$LN2057@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	r12, QWORD PTR prefixStart$1$[rsp]
$LN18@ZSTD_compr:

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	cmp	r9d, r10d
	ja	$LN20@ZSTD_compr

; 277  :             size_t const dictHash = ZSTD_hashPtr(ip, dictHLog, mls);

	mov	edx, DWORD PTR dictHLog$1$[rsp]
	mov	r8d, 4
	mov	rcx, r15
	call	ZSTD_hashPtr

; 278  :             U32 const dictMatchIndex = dictHashTable[dictHash];

	mov	rcx, QWORD PTR dictHashTable$1$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4]

; 279  :             const BYTE* dictMatch = dictBase + dictMatchIndex;

	lea	rsi, QWORD PTR [rcx+rbp]

; 280  :             if (dictMatchIndex <= dictStartIndex ||

	cmp	ecx, DWORD PTR dictStartIndex$1$[rsp]
	jbe	$LN24@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rsi], eax
	jne	$LN24@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 288  :                 mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [r15+4]
	sub	r13d, ecx
	lea	rdi, QWORD PTR [rsi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
	mov	rax, r12
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 287  :                 U32 const offset = (U32)(current-dictMatchIndex-dictIndexDelta);

	sub	r13d, DWORD PTR dictIndexDelta$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmp	rcx, r8
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, rdi
	cmp	rax, QWORD PTR dictEnd$1$[rsp]
	je	SHORT $LN230@ZSTD_compr
	mov	r12, QWORD PTR iend$1$[rsp]
	jmp	SHORT $LN229@ZSTD_compr
$LN230@ZSTD_compr:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r12+rbp]
	mov	r12, QWORD PTR iend$1$[rsp]
	mov	r8, r12
	call	ZSTD_count
	add	rbp, rax
$LN229@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 290  :                      && (ip[-1] == dictMatch[-1])) {

	mov	r8, QWORD PTR dictStart$1$[rsp]
	xor	r9d, r9d
	add	rbp, 4
	mov	ecx, r9d
	cmp	rsi, r8
	mov	eax, r9d
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	je	SHORT $LN2044@ZSTD_compr
	npad	1
$LL12@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rsi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2044@ZSTD_compr

; 291  :                     ip--; dictMatch--; mLength++;

	inc	rbp
	mov	ecx, r9d
	cmp	rdx, r14
	mov	eax, r9d
	mov	r15, rdx
	seta	cl
	cmp	rsi, r8
	seta	al
	test	ecx, eax
	jne	SHORT $LL12@ZSTD_compr
$LN2044@ZSTD_compr:

; 292  :                 } /* catch up */
; 293  :                 offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
	sub	rdi, r14
	mov	DWORD PTR offset_2$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 294  :                 offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	$LN262@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	$LN263@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
$LL249@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL249@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	$LN263@ZSTD_compr
$LN24@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 283  :                 ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15

; 284  :                 continue;

	mov	rsi, QWORD PTR iend$1$[rsp]
	sub	rcx, r14
	sar	rcx, 8
	add	r15, rax
	add	r15, rcx
	jmp	$LN28@ZSTD_compr
$LN20@ZSTD_compr:

; 296  :             }
; 297  :         } else if (MEM_read32(match) != MEM_read32(ip)) {

	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdi], eax
	je	SHORT $LN25@ZSTD_compr

; 298  :             /* it's not a match, and we're not going to check the dictionary */
; 299  :             assert(stepSize >= 1);
; 300  :             ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15
	sub	rcx, r14
	add	r15, rax
	sar	rcx, 8
	add	r15, rcx

; 301  :             continue;

	jmp	$LN28@ZSTD_compr
$LN25@ZSTD_compr:

; 302  :         } else {
; 303  :             /* found a regular match */
; 304  :             U32 const offset = (U32)(ip-match);

	mov	r13d, r15d

; 305  :             mLength = ZSTD_count(ip+4, match+4, iend) + 4;

	lea	rdx, QWORD PTR [rdi+4]
	lea	rcx, QWORD PTR [r15+4]
	mov	r8, rsi
	sub	r13d, edi
	call	ZSTD_count

; 306  :             while (((ip>anchor) & (match>prefixStart))
; 307  :                  && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */

	xor	r8d, r8d
	cmp	rdi, r12
	mov	ecx, r8d
	seta	cl
	lea	rbp, QWORD PTR [rax+4]
	cmp	r15, r14
	mov	eax, r8d
	seta	al
	test	ecx, eax
	je	SHORT $LN2045@ZSTD_compr
	npad	5
$LL14@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rdi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2045@ZSTD_compr
	inc	rbp
	mov	ecx, r8d
	cmp	rdi, r12
	mov	eax, r8d
	mov	r15, rdx
	seta	cl
	cmp	rdx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL14@ZSTD_compr
$LN2045@ZSTD_compr:

; 308  :             offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	sub	rdi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 308  :             offset_2 = offset_1;

	mov	DWORD PTR offset_2$1$[rsp], eax

; 309  :             offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN262@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	SHORT $LN263@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
	npad	2
$LL276@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL276@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN263@ZSTD_compr
$LN262@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 314  :         ip += mLength;

	mov	r9, r12
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN263@ZSTD_compr:
	add	QWORD PTR [rbx+24], rdi
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN1989@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1989@ZSTD_compr:
	mov	WORD PTR [rcx+4], di
	lea	ecx, DWORD PTR [r13+3]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN1990@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1990@ZSTD_compr:
	mov	r13d, DWORD PTR current$1$[rsp]
	mov	WORD PTR [rcx+6], si
	mov	rsi, QWORD PTR iend$1$[rsp]
$LN2064@ZSTD_compr:
	add	QWORD PTR [rbx+8], 8
	lea	r14, QWORD PTR [r15+rbp]

; 315  :         anchor = ip;

	lea	rbp, QWORD PTR [rsi-8]
	mov	r15, r14
	cmp	r14, rbp

; 316  : 
; 317  :         if (ip <= ilimit) {

	ja	$LN2060@ZSTD_compr

; 318  :             /* Fill Table */
; 319  :             assert(base+current+2 > istart);  /* check base overflow */
; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	mov	rbp, QWORD PTR base$1$[rsp]
	lea	edi, DWORD PTR [r13+2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 4
	mov	eax, r13d
	lea	rcx, QWORD PTR [rbp+2]
	add	rcx, rax
	call	ZSTD_hashPtr
	mov	r13, QWORD PTR hashTable$1$[rsp]

; 321  :             hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);

	lea	rcx, QWORD PTR [r14-2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 4
	mov	DWORD PTR [r13+rax*4], edi
	mov	edi, r14d
	sub	edi, ebp
	sub	edi, 2
	call	ZSTD_hashPtr
	mov	DWORD PTR [r13+rax*4], edi
	mov	r13, QWORD PTR dictBase$1$[rsp]
$LL16@ZSTD_compr:

; 322  : 
; 323  :             /* check immediate repcode */
; 324  :             while (ip <= ilimit) {
; 325  :                 U32 const current2 = (U32)(ip-base);
; 326  :                 U32 const repIndex2 = current2 - offset_2;
; 327  :                 const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edi, r15d
	sub	edi, ebp
	mov	ecx, edi
	sub	ecx, DWORD PTR offset_2$1$[rsp]
	mov	r8d, ecx
	cmp	ecx, r10d
	jae	SHORT $LN32@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	mov	rdx, r13
	sub	rdx, rax
	add	rdx, r8
	jmp	SHORT $LN33@ZSTD_compr
$LN32@ZSTD_compr:
	lea	rdx, QWORD PTR [rcx+rbp]
$LN33@ZSTD_compr:

; 328  :                         dictBase - dictIndexDelta + repIndex2 :
; 329  :                         base + repIndex2;
; 330  :                 if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
; 331  :                    && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN2046@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdx], eax
	jne	$LN2046@ZSTD_compr

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	mov	rax, QWORD PTR prefixStart$1$[rsp]
	cmp	ecx, r10d
	mov	r9, rsi
	mov	QWORD PTR [rsp+32], rax
	cmovb	r9, QWORD PTR dictEnd$1$[rsp]
	lea	rcx, QWORD PTR [r15+4]
	add	rdx, 4
	mov	r8, rsi
	call	ZSTD_count_2segments

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	ecx, DWORD PTR offset_1$1$[rsp]
	lea	rbp, QWORD PTR [rax+4]
	mov	eax, DWORD PTR offset_2$1$[rsp]
	mov	DWORD PTR offset_2$1$[rsp], ecx

; 335  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LN289@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN290@ZSTD_compr
$LN289@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN290@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN2041@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [rbx+8]
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
	mov	DWORD PTR [rbx+72], 2
$LN2041@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	r8d, 4
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	call	ZSTD_hashPtr
	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 337  :                     ip += repLength2;

	add	r15, rbp
	mov	r14, r15
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	rbp, QWORD PTR base$1$[rsp]
	mov	DWORD PTR [rcx+rax*4], edi
	cmp	r15, QWORD PTR ilimit$1$[rsp]
	jbe	$LL16@ZSTD_compr
$LN2046@ZSTD_compr:
	mov	rsi, QWORD PTR iend$1$[rsp]
$LN2060@ZSTD_compr:

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	mov	rbp, QWORD PTR dictBase$1$[rsp]
$LN28@ZSTD_compr:
	mov	r12, QWORD PTR prefixStart$1$[rsp]
	lea	rax, QWORD PTR [rsi-8]
	mov	rdi, QWORD PTR base$1$[rsp]
	mov	r13d, DWORD PTR hlog$1$[rsp]
	cmp	r15, rax
	jb	$LL10@ZSTD_compr

; 361  :     {
; 362  :     default: /* includes case 3 */
; 363  :     case 4 :
; 364  :         return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 4);

	jmp	$LN313@ZSTD_compr
$LN7@ZSTD_compr:

; 231  :     const BYTE* const dictBase     = dms->window.base;

	mov	r12, QWORD PTR [rdx+8]
	lea	rsi, QWORD PTR [rdi+r11]
	mov	rbp, QWORD PTR srcSize$[rsp]
	test	r9d, r9d
	mov	QWORD PTR prefixStart$1$[rsp], rsi
	sete	al
	mov	QWORD PTR dictBase$1$[rsp], r12
	add	eax, r9d
	add	rbp, r14

; 232  :     const BYTE* const dictStart    = dictBase + dictStartIndex;
; 233  :     const BYTE* const dictEnd      = dms->window.nextSrc;

	mov	r9, QWORD PTR [rdx]
	mov	DWORD PTR stepSize$1$[rsp], eax
	mov	rax, QWORD PTR [rdx+48]
	mov	QWORD PTR dictHashTable$1$[rsp], rax
	lea	rcx, QWORD PTR [rbp-8]
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR dictStartIndex$1$[rsp], eax
	mov	QWORD PTR iend$1$[rsp], rbp
	mov	QWORD PTR ilimit$1$[rsp], rcx
	lea	r8, QWORD PTR [r12+rax]
	mov	QWORD PTR dictEnd$1$[rsp], r9

; 234  :     const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);

	mov	eax, r12d
	mov	QWORD PTR dictStart$1$[rsp], r8
	sub	eax, r9d
	add	eax, r11d
	mov	DWORD PTR dictIndexDelta$1$[rsp], eax

; 235  :     const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);
; 236  :     const U32 dictHLog             = dictCParams->hashLog;

	mov	eax, DWORD PTR [rdx+192]
	mov	DWORD PTR dictHLog$1$[rsp], eax

; 237  : 
; 238  :     /* if a dictionary is still attached, it necessarily means that
; 239  :      * it is within window size. So we just check it. */
; 240  :     const U32 maxDistance = 1U << cParams->windowLog;
; 241  :     const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);
; 242  :     assert(endIndex - prefixStartIndex <= maxDistance);
; 243  :     (void)maxDistance; (void)endIndex;   /* these variables are not used when assert() is disabled */
; 244  : 
; 245  :     /* ensure there will be no no underflow
; 246  :      * when translating a dict index into a local index */
; 247  :     assert(prefixStartIndex >= (U32)(dictEnd - dictBase));
; 248  : 
; 249  :     /* init */
; 250  :     DEBUGLOG(5, "ZSTD_compressBlock_fast_dictMatchState_generic");
; 251  :     ip += (dictAndPrefixLength == 0);

	mov	eax, r9d
	sub	eax, esi
	sub	eax, r8d
	add	eax, r14d
	mov	rax, r10
	sete	al
	lea	r15, QWORD PTR [rax+r14]
	cmp	r15, rcx

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	jae	$LN1262@ZSTD_compr
	npad	10
$LL1261@ZSTD_compr:

; 259  :         size_t mLength;
; 260  :         size_t const h = ZSTD_hashPtr(ip, hlog, mls);

	mov	r8d, 7
	mov	edx, r13d
	mov	rcx, r15
	call	ZSTD_hashPtr

; 261  :         U32 const current = (U32)(ip-base);
; 262  :         U32 const matchIndex = hashTable[h];

	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	r13d, r15d
	mov	r9d, DWORD PTR [rcx+rax*4]
	sub	r13d, edi

; 263  :         const BYTE* match = base + matchIndex;
; 264  :         const U32 repIndex = current + 1 - offset_1;
; 265  :         const BYTE* repMatch = (repIndex < prefixStartIndex) ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edx, r13d
	sub	edx, DWORD PTR offset_1$1$[rsp]
	lea	r8, QWORD PTR [rcx+rax*4]
	add	rdi, r9
	mov	DWORD PTR current$1$[rsp], r13d
	inc	edx
	cmp	edx, r10d
	jae	SHORT $LN1281@ZSTD_compr
	mov	ecx, edx
	sub	ecx, DWORD PTR dictIndexDelta$1$[rsp]
	add	rcx, r12
	jmp	SHORT $LN1282@ZSTD_compr
$LN1281@ZSTD_compr:
	mov	ecx, edx
	add	rcx, QWORD PTR base$1$[rsp]
$LN1282@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, r10d
	mov	DWORD PTR [r8], r13d
	sub	eax, edx
	dec	eax
	cmp	eax, 3
	jb	$LN1269@ZSTD_compr
	mov	eax, DWORD PTR [r15+1]
	lea	r12, QWORD PTR [r15+1]
	cmp	DWORD PTR [rcx], eax
	jne	$LN2063@ZSTD_compr

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	lea	rdi, QWORD PTR [rcx+4]
	cmp	edx, r10d
	mov	rsi, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rbp
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 272  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	r15, 5
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, rbp
	cmovb	r8, rcx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rcx, r15
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, rsi
	mov	rsi, QWORD PTR iend$1$[rsp]
	jne	SHORT $LN1369@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+rax]
	mov	r8, rsi
	call	ZSTD_count
	add	rbp, rax
$LN1369@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
	lea	r9, QWORD PTR [rsi-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	rbp, 4

; 274  :             ip++;

	mov	r15, r12

; 275  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);

	sub	r12, r14
	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r12+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN1375@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r12, 16
	jbe	SHORT $LN1376@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r12
$LL1389@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL1389@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1376@ZSTD_compr
$LN1375@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN1376@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], r12
	mov	rcx, QWORD PTR [rbx+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r12, 65535				; 0000ffffH
	jbe	SHORT $LN1992@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1992@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r12w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN1993@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1993@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	jmp	$LN2069@ZSTD_compr
$LN2063@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	r12, QWORD PTR dictBase$1$[rsp]
$LN1269@ZSTD_compr:

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	cmp	r9d, r10d
	ja	$LN1271@ZSTD_compr

; 277  :             size_t const dictHash = ZSTD_hashPtr(ip, dictHLog, mls);

	mov	edx, DWORD PTR dictHLog$1$[rsp]
	mov	r8d, 7
	mov	rcx, r15
	call	ZSTD_hashPtr

; 278  :             U32 const dictMatchIndex = dictHashTable[dictHash];

	mov	rcx, QWORD PTR dictHashTable$1$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4]

; 279  :             const BYTE* dictMatch = dictBase + dictMatchIndex;

	lea	rsi, QWORD PTR [r12+rcx]

; 280  :             if (dictMatchIndex <= dictStartIndex ||

	cmp	ecx, DWORD PTR dictStartIndex$1$[rsp]
	jbe	$LN1275@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rsi], eax
	jne	$LN1275@ZSTD_compr

; 287  :                 U32 const offset = (U32)(current-dictMatchIndex-dictIndexDelta);

	sub	r13d, ecx

; 288  :                 mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [r15+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 288  :                 mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;

	lea	rdi, QWORD PTR [rsi+4]
	sub	r13d, DWORD PTR dictIndexDelta$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rax, r12
	sub	rax, rdi
	mov	r8, rbp
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmp	rcx, rbp
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	je	SHORT $LN1500@ZSTD_compr
	mov	r12, QWORD PTR iend$1$[rsp]
	jmp	SHORT $LN1499@ZSTD_compr
$LN1500@ZSTD_compr:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r12+rax]
	mov	r12, QWORD PTR iend$1$[rsp]
	mov	r8, r12
	call	ZSTD_count
	add	rbp, rax
$LN1499@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 290  :                      && (ip[-1] == dictMatch[-1])) {

	mov	r8, QWORD PTR dictStart$1$[rsp]
	xor	r9d, r9d
	add	rbp, 4
	mov	ecx, r9d
	cmp	r15, r14
	mov	eax, r9d
	seta	cl
	cmp	rsi, r8
	seta	al
	test	ecx, eax
	je	SHORT $LN2047@ZSTD_compr
	npad	10
$LL1263@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rsi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2047@ZSTD_compr

; 291  :                     ip--; dictMatch--; mLength++;

	inc	rbp
	mov	ecx, r9d
	cmp	rdx, r14
	mov	eax, r9d
	mov	r15, rdx
	seta	cl
	cmp	rsi, r8
	seta	al
	test	ecx, eax
	jne	SHORT $LL1263@ZSTD_compr
$LN2047@ZSTD_compr:

; 292  :                 } /* catch up */
; 293  :                 offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
	sub	rdi, r14
	mov	DWORD PTR offset_2$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 294  :                 offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	$LN1580@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	$LN1581@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
$LL1519@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL1519@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	$LN1581@ZSTD_compr
$LN1275@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 283  :                 ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15
	sub	rcx, r14
	add	r15, rax
	sar	rcx, 8
	add	r15, rcx

; 284  :                 continue;

	jmp	$LN2074@ZSTD_compr
$LN1271@ZSTD_compr:

; 296  :             }
; 297  :         } else if (MEM_read32(match) != MEM_read32(ip)) {

	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdi], eax
	je	SHORT $LN1276@ZSTD_compr

; 298  :             /* it's not a match, and we're not going to check the dictionary */
; 299  :             assert(stepSize >= 1);
; 300  :             ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15
	sub	rcx, r14
	add	r15, rax
	sar	rcx, 8
	add	r15, rcx

; 301  :             continue;

	jmp	$LN1279@ZSTD_compr
$LN1276@ZSTD_compr:

; 302  :         } else {
; 303  :             /* found a regular match */
; 304  :             U32 const offset = (U32)(ip-match);

	mov	r13d, r15d

; 305  :             mLength = ZSTD_count(ip+4, match+4, iend) + 4;

	lea	rdx, QWORD PTR [rdi+4]
	lea	rcx, QWORD PTR [r15+4]
	mov	r8, rbp
	sub	r13d, edi
	call	ZSTD_count

; 306  :             while (((ip>anchor) & (match>prefixStart))
; 307  :                  && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */

	xor	r8d, r8d
	cmp	r15, r14
	mov	edx, r8d
	mov	ecx, r8d
	seta	dl
	lea	rbp, QWORD PTR [rax+4]
	cmp	rdi, rsi
	seta	cl
	test	edx, ecx
	je	SHORT $LN2048@ZSTD_compr
	npad	10
$LL1265@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rdi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2048@ZSTD_compr
	inc	rbp
	mov	ecx, r8d
	cmp	rdi, rsi
	mov	eax, r8d
	mov	r15, rdx
	seta	cl
	cmp	rdx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL1265@ZSTD_compr
$LN2048@ZSTD_compr:

; 308  :             offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	sub	rdi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 308  :             offset_2 = offset_1;

	mov	DWORD PTR offset_2$1$[rsp], eax

; 309  :             offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN1580@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	SHORT $LN1581@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
	npad	2
$LL1594@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL1594@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1581@ZSTD_compr
$LN1580@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 314  :         ip += mLength;

	mov	r9, r12
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN1581@ZSTD_compr:
	add	QWORD PTR [rbx+24], rdi
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN1996@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1996@ZSTD_compr:
	mov	WORD PTR [rcx+4], di
	lea	ecx, DWORD PTR [r13+3]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN1997@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1997@ZSTD_compr:
	mov	r13d, DWORD PTR current$1$[rsp]
	mov	WORD PTR [rcx+6], si
$LN2069@ZSTD_compr:
	add	QWORD PTR [rbx+8], 8
	lea	r14, QWORD PTR [r15+rbp]
	mov	r15, r14

; 315  :         anchor = ip;

	cmp	r14, QWORD PTR ilimit$1$[rsp]

; 316  : 
; 317  :         if (ip <= ilimit) {

	ja	$LN2056@ZSTD_compr

; 318  :             /* Fill Table */
; 319  :             assert(base+current+2 > istart);  /* check base overflow */
; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	mov	rsi, QWORD PTR base$1$[rsp]
	lea	edi, DWORD PTR [r13+2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 7
	mov	eax, r13d
	lea	rcx, QWORD PTR [rsi+2]
	add	rcx, rax
	call	ZSTD_hashPtr
	mov	r12, QWORD PTR hashTable$1$[rsp]

; 321  :             hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);

	lea	rcx, QWORD PTR [r14-2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 7
	mov	DWORD PTR [r12+rax*4], edi
	mov	edi, r14d
	sub	edi, esi
	sub	edi, 2
	call	ZSTD_hashPtr
	mov	DWORD PTR [r12+rax*4], edi
	npad	11
$LL1267@ZSTD_compr:

; 322  : 
; 323  :             /* check immediate repcode */
; 324  :             while (ip <= ilimit) {
; 325  :                 U32 const current2 = (U32)(ip-base);
; 326  :                 U32 const repIndex2 = current2 - offset_2;
; 327  :                 const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	r13d, r15d
	sub	r13d, esi
	mov	ecx, r13d
	sub	ecx, DWORD PTR offset_2$1$[rsp]
	mov	edx, ecx
	cmp	ecx, r10d
	jae	SHORT $LN1283@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	mov	rdi, QWORD PTR dictBase$1$[rsp]
	sub	rdi, rax
	add	rdi, rdx
	jmp	SHORT $LN1284@ZSTD_compr
$LN1283@ZSTD_compr:
	lea	rdi, QWORD PTR [rcx+rsi]
$LN1284@ZSTD_compr:

; 328  :                         dictBase - dictIndexDelta + repIndex2 :
; 329  :                         base + repIndex2;
; 330  :                 if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
; 331  :                    && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN2056@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdi], eax
	jne	$LN2056@ZSTD_compr

; 332  :                     const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;

	mov	rdx, QWORD PTR iend$1$[rsp]

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	lea	r12, QWORD PTR [r15+4]
	cmp	ecx, r10d
	mov	rsi, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdx
	mov	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 332  :                     const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	add	rdi, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, rdx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, rsi
	jne	SHORT $LN1783@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r12+rax]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	rbp, rax
$LN1783@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	ecx, DWORD PTR offset_1$1$[rsp]
	add	rbp, 4
	mov	eax, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	r12, QWORD PTR iend$1$[rsp]
	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], ecx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 335  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);

	lea	rdi, QWORD PTR [rbp-3]
	mov	DWORD PTR offset_1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LN1789@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1790@ZSTD_compr
$LN1789@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN1790@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN1998@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1998@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 7
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	call	ZSTD_hashPtr
	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 337  :                     ip += repLength2;

	add	r15, rbp
	mov	r14, r15
	mov	rsi, QWORD PTR base$1$[rsp]
	mov	DWORD PTR [rcx+rax*4], r13d
	cmp	r15, QWORD PTR ilimit$1$[rsp]
	jbe	$LL1267@ZSTD_compr
$LN2056@ZSTD_compr:

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	mov	rbp, QWORD PTR iend$1$[rsp]
$LN2074@ZSTD_compr:
	mov	rsi, QWORD PTR prefixStart$1$[rsp]
$LN1279@ZSTD_compr:
	mov	r12, QWORD PTR dictBase$1$[rsp]
	lea	rax, QWORD PTR [rbp-8]
	mov	rdi, QWORD PTR base$1$[rsp]
	mov	r13d, DWORD PTR hlog$1$[rsp]
	cmp	r15, rax
	jb	$LL1261@ZSTD_compr
$LN1262@ZSTD_compr:

; 338  :                     anchor = ip;
; 339  :                     continue;
; 340  :                 }
; 341  :                 break;
; 342  :             }
; 343  :         }
; 344  :     }
; 345  : 
; 346  :     /* save reps for next block */
; 347  :     rep[0] = offset_1 ? offset_1 : offsetSaved;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 348  :     rep[1] = offset_2 ? offset_2 : offsetSaved;
; 349  : 
; 350  :     /* Return the last literals size */
; 351  :     return (size_t)(iend - anchor);

	sub	rbp, r14
	mov	rcx, QWORD PTR rep$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR offset_2$1$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 369  :     case 7 :
; 370  :         return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 7);

	mov	rax, rbp
	jmp	$LN1@ZSTD_compr
$LN6@ZSTD_compr:

; 231  :     const BYTE* const dictBase     = dms->window.base;

	mov	rbp, QWORD PTR [rdx+8]
	lea	r12, QWORD PTR [rdi+r11]
	mov	rsi, QWORD PTR srcSize$[rsp]
	xor	r10d, r10d
	test	r9d, r9d
	mov	QWORD PTR prefixStart$1$[rsp], r12
	mov	eax, r10d
	mov	QWORD PTR dictBase$1$[rsp], rbp
	sete	al
	add	rsi, r14
	add	eax, r9d
	mov	QWORD PTR iend$1$[rsp], rsi

; 232  :     const BYTE* const dictStart    = dictBase + dictStartIndex;
; 233  :     const BYTE* const dictEnd      = dms->window.nextSrc;

	mov	r9, QWORD PTR [rdx]
	mov	DWORD PTR stepSize$1$[rsp], eax
	mov	rax, QWORD PTR [rdx+48]
	lea	rcx, QWORD PTR [rsi-8]
	mov	QWORD PTR dictHashTable$1$[rsp], rax
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR dictStartIndex$1$[rsp], eax
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	QWORD PTR dictEnd$1$[rsp], r9
	lea	r8, QWORD PTR [rax+rbp]

; 234  :     const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);

	mov	eax, r11d
	sub	eax, r9d
	mov	QWORD PTR dictStart$1$[rsp], r8
	add	eax, ebp
	mov	DWORD PTR dictIndexDelta$1$[rsp], eax

; 235  :     const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);
; 236  :     const U32 dictHLog             = dictCParams->hashLog;

	mov	eax, DWORD PTR [rdx+192]
	mov	DWORD PTR dictHLog$1$[rsp], eax

; 237  : 
; 238  :     /* if a dictionary is still attached, it necessarily means that
; 239  :      * it is within window size. So we just check it. */
; 240  :     const U32 maxDistance = 1U << cParams->windowLog;
; 241  :     const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);
; 242  :     assert(endIndex - prefixStartIndex <= maxDistance);
; 243  :     (void)maxDistance; (void)endIndex;   /* these variables are not used when assert() is disabled */
; 244  : 
; 245  :     /* ensure there will be no no underflow
; 246  :      * when translating a dict index into a local index */
; 247  :     assert(prefixStartIndex >= (U32)(dictEnd - dictBase));
; 248  : 
; 249  :     /* init */
; 250  :     DEBUGLOG(5, "ZSTD_compressBlock_fast_dictMatchState_generic");
; 251  :     ip += (dictAndPrefixLength == 0);

	mov	eax, r14d
	sub	eax, r12d
	sub	eax, r8d
	add	eax, r9d
	mov	eax, r10d
	sete	al
	lea	r15, QWORD PTR [rax+r14]
	cmp	r15, rcx

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	jae	$LN313@ZSTD_compr
$LL772@ZSTD_compr:

; 259  :         size_t mLength;
; 260  :         size_t const h = ZSTD_hashPtr(ip, hlog, mls);

	mov	r8d, 6
	mov	edx, r13d
	mov	rcx, r15
	call	ZSTD_hashPtr

; 261  :         U32 const current = (U32)(ip-base);
; 262  :         U32 const matchIndex = hashTable[h];

	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	r13d, r15d
	mov	r9d, DWORD PTR [rcx+rax*4]
	sub	r13d, edi

; 263  :         const BYTE* match = base + matchIndex;
; 264  :         const U32 repIndex = current + 1 - offset_1;
; 265  :         const BYTE* repMatch = (repIndex < prefixStartIndex) ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edx, r13d
	sub	edx, DWORD PTR offset_1$1$[rsp]
	lea	r8, QWORD PTR [rcx+rax*4]
	add	rdi, r9
	mov	DWORD PTR current$1$[rsp], r13d
	inc	edx
	cmp	edx, r10d
	jae	SHORT $LN792@ZSTD_compr
	mov	ecx, edx
	sub	ecx, DWORD PTR dictIndexDelta$1$[rsp]
	add	rcx, rbp
	jmp	SHORT $LN793@ZSTD_compr
$LN792@ZSTD_compr:
	mov	ecx, edx
	add	rcx, QWORD PTR base$1$[rsp]
$LN793@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, r10d
	mov	DWORD PTR [r8], r13d
	sub	eax, edx
	dec	eax
	cmp	eax, 3
	jb	$LN780@ZSTD_compr
	mov	eax, DWORD PTR [r15+1]
	lea	r12, QWORD PTR [r15+1]
	cmp	DWORD PTR [rcx], eax
	jne	$LN2058@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	lea	rdi, QWORD PTR [rcx+4]
	cmp	edx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 272  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	r15, 5
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, r8
	cmovb	r8, rcx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rcx, r15
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, rsi
	mov	rsi, QWORD PTR iend$1$[rsp]
	jne	SHORT $LN880@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+rax]
	mov	r8, rsi
	call	ZSTD_count
	add	rbp, rax
$LN880@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
	lea	r9, QWORD PTR [rsi-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	rbp, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	QWORD PTR litLimit_w$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 274  :             ip++;

	mov	r15, r12

; 275  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);

	sub	r12, r14
	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r14+r12]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN886@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r12, 16
	jbe	SHORT $LN887@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r12
	npad	5
$LL900@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL900@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN887@ZSTD_compr
$LN886@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN887@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], r12
	mov	rcx, QWORD PTR [rbx+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r12, 65535				; 0000ffffH
	jbe	SHORT $LN1999@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN1999@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r12w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN2000@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2000@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	mov	r12, QWORD PTR litLimit_w$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	jmp	$LN2075@ZSTD_compr
$LN2058@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	r12, QWORD PTR prefixStart$1$[rsp]
$LN780@ZSTD_compr:

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	cmp	r9d, r10d
	ja	$LN782@ZSTD_compr

; 277  :             size_t const dictHash = ZSTD_hashPtr(ip, dictHLog, mls);

	mov	edx, DWORD PTR dictHLog$1$[rsp]
	mov	r8d, 6
	mov	rcx, r15
	call	ZSTD_hashPtr

; 278  :             U32 const dictMatchIndex = dictHashTable[dictHash];

	mov	rcx, QWORD PTR dictHashTable$1$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4]

; 279  :             const BYTE* dictMatch = dictBase + dictMatchIndex;

	lea	rsi, QWORD PTR [rcx+rbp]

; 280  :             if (dictMatchIndex <= dictStartIndex ||

	cmp	ecx, DWORD PTR dictStartIndex$1$[rsp]
	jbe	$LN786@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rsi], eax
	jne	$LN786@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 288  :                 mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [r15+4]
	sub	r13d, ecx
	lea	rdi, QWORD PTR [rsi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
	mov	rax, r12
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 287  :                 U32 const offset = (U32)(current-dictMatchIndex-dictIndexDelta);

	sub	r13d, DWORD PTR dictIndexDelta$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmp	rcx, r8
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	je	SHORT $LN992@ZSTD_compr
	mov	r12, QWORD PTR iend$1$[rsp]
	jmp	SHORT $LN991@ZSTD_compr
$LN992@ZSTD_compr:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r12+rax]
	mov	r12, QWORD PTR iend$1$[rsp]
	mov	r8, r12
	call	ZSTD_count
	add	rbp, rax
$LN991@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 290  :                      && (ip[-1] == dictMatch[-1])) {

	mov	r8, QWORD PTR dictStart$1$[rsp]
	xor	r9d, r9d
	add	rbp, 4
	mov	ecx, r9d
	cmp	r15, r14
	mov	eax, r9d
	seta	cl
	cmp	rsi, r8
	seta	al
	test	ecx, eax
	je	SHORT $LN2050@ZSTD_compr
$LL774@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rsi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2050@ZSTD_compr

; 291  :                     ip--; dictMatch--; mLength++;

	inc	rbp
	mov	ecx, r9d
	cmp	rsi, r8
	mov	eax, r9d
	mov	r15, rdx
	seta	cl
	cmp	rdx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL774@ZSTD_compr
$LN2050@ZSTD_compr:

; 292  :                 } /* catch up */
; 293  :                 offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
	sub	rdi, r14
	mov	DWORD PTR offset_2$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 294  :                 offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r14+rdi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	$LN1053@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	$LN1054@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
$LL1011@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL1011@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	$LN1054@ZSTD_compr
$LN786@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 283  :                 ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15

; 284  :                 continue;

	mov	rsi, QWORD PTR iend$1$[rsp]
	sub	rcx, r14
	sar	rcx, 8
	add	r15, rax
	add	r15, rcx
	jmp	$LN790@ZSTD_compr
$LN782@ZSTD_compr:

; 296  :             }
; 297  :         } else if (MEM_read32(match) != MEM_read32(ip)) {

	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdi], eax
	je	SHORT $LN787@ZSTD_compr

; 298  :             /* it's not a match, and we're not going to check the dictionary */
; 299  :             assert(stepSize >= 1);
; 300  :             ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15
	sub	rcx, r14
	add	r15, rax
	sar	rcx, 8
	add	r15, rcx

; 301  :             continue;

	jmp	$LN790@ZSTD_compr
$LN787@ZSTD_compr:

; 302  :         } else {
; 303  :             /* found a regular match */
; 304  :             U32 const offset = (U32)(ip-match);

	mov	r13d, r15d

; 305  :             mLength = ZSTD_count(ip+4, match+4, iend) + 4;

	lea	rdx, QWORD PTR [rdi+4]
	lea	rcx, QWORD PTR [r15+4]
	mov	r8, rsi
	sub	r13d, edi
	call	ZSTD_count

; 306  :             while (((ip>anchor) & (match>prefixStart))
; 307  :                  && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */

	xor	r8d, r8d
	cmp	r15, r14
	mov	edx, r8d
	mov	ecx, r8d
	seta	dl
	lea	rbp, QWORD PTR [rax+4]
	cmp	rdi, r12
	seta	cl
	test	edx, ecx
	je	SHORT $LN2051@ZSTD_compr
	npad	5
$LL776@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rdi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2051@ZSTD_compr
	inc	rbp
	mov	ecx, r8d
	cmp	rdi, r12
	mov	eax, r8d
	mov	r15, rdx
	seta	cl
	cmp	rdx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL776@ZSTD_compr
$LN2051@ZSTD_compr:

; 308  :             offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	sub	rdi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 308  :             offset_2 = offset_1;

	mov	DWORD PTR offset_2$1$[rsp], eax

; 309  :             offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r14+rdi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN1053@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	SHORT $LN1054@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
	npad	2
$LL1067@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL1067@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1054@ZSTD_compr
$LN1053@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 314  :         ip += mLength;

	mov	r9, r12
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN1054@ZSTD_compr:
	add	QWORD PTR [rbx+24], rdi
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN2003@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2003@ZSTD_compr:
	mov	WORD PTR [rcx+4], di
	lea	ecx, DWORD PTR [r13+3]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN2004@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2004@ZSTD_compr:
	mov	r13d, DWORD PTR current$1$[rsp]
	mov	WORD PTR [rcx+6], si
	mov	rsi, QWORD PTR iend$1$[rsp]
$LN2075@ZSTD_compr:
	add	QWORD PTR [rbx+8], 8
	lea	r14, QWORD PTR [r15+rbp]

; 315  :         anchor = ip;

	lea	rbp, QWORD PTR [rsi-8]
	mov	r15, r14
	cmp	r14, rbp

; 316  : 
; 317  :         if (ip <= ilimit) {

	ja	$LN2061@ZSTD_compr

; 318  :             /* Fill Table */
; 319  :             assert(base+current+2 > istart);  /* check base overflow */
; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	mov	rbp, QWORD PTR base$1$[rsp]
	lea	edi, DWORD PTR [r13+2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 6
	mov	eax, r13d
	lea	rcx, QWORD PTR [rbp+2]
	add	rcx, rax
	call	ZSTD_hashPtr
	mov	r13, QWORD PTR hashTable$1$[rsp]

; 321  :             hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);

	lea	rcx, QWORD PTR [r14-2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 6
	mov	DWORD PTR [r13+rax*4], edi
	mov	edi, r14d
	sub	edi, ebp
	sub	edi, 2
	call	ZSTD_hashPtr
	mov	DWORD PTR [r13+rax*4], edi
	mov	r13, QWORD PTR dictBase$1$[rsp]
$LL778@ZSTD_compr:

; 322  : 
; 323  :             /* check immediate repcode */
; 324  :             while (ip <= ilimit) {
; 325  :                 U32 const current2 = (U32)(ip-base);
; 326  :                 U32 const repIndex2 = current2 - offset_2;
; 327  :                 const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edi, r15d
	sub	edi, ebp
	mov	ecx, edi
	sub	ecx, DWORD PTR offset_2$1$[rsp]
	mov	edx, ecx
	cmp	ecx, r10d
	jae	SHORT $LN794@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	sub	rdx, rax
	add	rdx, r13
	jmp	SHORT $LN795@ZSTD_compr
$LN794@ZSTD_compr:
	add	rdx, rbp
$LN795@ZSTD_compr:

; 328  :                         dictBase - dictIndexDelta + repIndex2 :
; 329  :                         base + repIndex2;
; 330  :                 if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
; 331  :                    && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN2052@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdx], eax
	jne	$LN2052@ZSTD_compr

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	mov	rax, QWORD PTR prefixStart$1$[rsp]
	cmp	ecx, r10d
	mov	r9, rsi
	mov	QWORD PTR [rsp+32], rax
	cmovb	r9, QWORD PTR dictEnd$1$[rsp]
	lea	rcx, QWORD PTR [r15+4]
	add	rdx, 4
	mov	r8, rsi
	call	ZSTD_count_2segments

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	ecx, DWORD PTR offset_2$1$[rsp]
	lea	rbp, QWORD PTR [rax+4]
	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_1$1$[rsp], ecx

; 335  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LN1238@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN1239@ZSTD_compr
$LN1238@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN1239@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN2042@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [rbx+8]
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
	mov	DWORD PTR [rbx+72], 2
$LN2042@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	r8d, 6
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	call	ZSTD_hashPtr
	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 337  :                     ip += repLength2;

	add	r15, rbp
	mov	r14, r15
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	rbp, QWORD PTR base$1$[rsp]
	mov	DWORD PTR [rcx+rax*4], edi
	cmp	r15, QWORD PTR ilimit$1$[rsp]
	jbe	$LL778@ZSTD_compr
$LN2052@ZSTD_compr:
	mov	rsi, QWORD PTR iend$1$[rsp]
$LN2061@ZSTD_compr:

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	mov	rbp, QWORD PTR dictBase$1$[rsp]
$LN790@ZSTD_compr:
	mov	r12, QWORD PTR prefixStart$1$[rsp]
	lea	rax, QWORD PTR [rsi-8]
	mov	rdi, QWORD PTR base$1$[rsp]
	mov	r13d, DWORD PTR hlog$1$[rsp]
	cmp	r15, rax
	jb	$LL772@ZSTD_compr

; 365  :     case 5 :
; 366  :         return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 5);
; 367  :     case 6 :
; 368  :         return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 6);

	jmp	$LN313@ZSTD_compr
$LN5@ZSTD_compr:

; 231  :     const BYTE* const dictBase     = dms->window.base;

	mov	rbp, QWORD PTR [rdx+8]
	lea	r12, QWORD PTR [rdi+r11]
	mov	rsi, QWORD PTR srcSize$[rsp]
	xor	r10d, r10d
	test	r9d, r9d
	mov	QWORD PTR prefixStart$1$[rsp], r12
	mov	eax, r10d
	mov	QWORD PTR dictBase$1$[rsp], rbp
	sete	al
	add	rsi, r14
	add	eax, r9d
	mov	QWORD PTR iend$1$[rsp], rsi

; 232  :     const BYTE* const dictStart    = dictBase + dictStartIndex;
; 233  :     const BYTE* const dictEnd      = dms->window.nextSrc;

	mov	r9, QWORD PTR [rdx]
	mov	DWORD PTR stepSize$1$[rsp], eax
	mov	rax, QWORD PTR [rdx+48]
	lea	rcx, QWORD PTR [rsi-8]
	mov	QWORD PTR dictHashTable$1$[rsp], rax
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR dictStartIndex$1$[rsp], eax
	mov	QWORD PTR ilimit$1$[rsp], rcx
	mov	QWORD PTR dictEnd$1$[rsp], r9
	lea	r8, QWORD PTR [rax+rbp]

; 234  :     const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);

	mov	eax, ebp
	sub	eax, r9d
	mov	QWORD PTR dictStart$1$[rsp], r8
	add	eax, r11d
	mov	DWORD PTR dictIndexDelta$1$[rsp], eax

; 235  :     const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);
; 236  :     const U32 dictHLog             = dictCParams->hashLog;

	mov	eax, DWORD PTR [rdx+192]
	mov	DWORD PTR dictHLog$1$[rsp], eax

; 237  : 
; 238  :     /* if a dictionary is still attached, it necessarily means that
; 239  :      * it is within window size. So we just check it. */
; 240  :     const U32 maxDistance = 1U << cParams->windowLog;
; 241  :     const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);
; 242  :     assert(endIndex - prefixStartIndex <= maxDistance);
; 243  :     (void)maxDistance; (void)endIndex;   /* these variables are not used when assert() is disabled */
; 244  : 
; 245  :     /* ensure there will be no no underflow
; 246  :      * when translating a dict index into a local index */
; 247  :     assert(prefixStartIndex >= (U32)(dictEnd - dictBase));
; 248  : 
; 249  :     /* init */
; 250  :     DEBUGLOG(5, "ZSTD_compressBlock_fast_dictMatchState_generic");
; 251  :     ip += (dictAndPrefixLength == 0);

	mov	eax, r14d
	sub	eax, r12d
	sub	eax, r8d
	add	eax, r9d
	mov	eax, r10d
	sete	al
	lea	r15, QWORD PTR [rax+r14]
	cmp	r15, rcx

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	jae	$LN313@ZSTD_compr
	npad	9
$LL312@ZSTD_compr:

; 259  :         size_t mLength;
; 260  :         size_t const h = ZSTD_hashPtr(ip, hlog, mls);

	mov	r8d, 5
	mov	edx, r13d
	mov	rcx, r15
	call	ZSTD_hashPtr

; 261  :         U32 const current = (U32)(ip-base);
; 262  :         U32 const matchIndex = hashTable[h];

	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	r13d, r15d
	mov	r9d, DWORD PTR [rcx+rax*4]
	sub	r13d, edi

; 263  :         const BYTE* match = base + matchIndex;
; 264  :         const U32 repIndex = current + 1 - offset_1;
; 265  :         const BYTE* repMatch = (repIndex < prefixStartIndex) ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edx, r13d
	sub	edx, DWORD PTR offset_1$1$[rsp]
	lea	r8, QWORD PTR [rcx+rax*4]
	add	rdi, r9
	mov	DWORD PTR current$1$[rsp], r13d
	inc	edx
	cmp	edx, r10d
	jae	SHORT $LN332@ZSTD_compr
	mov	ecx, edx
	sub	ecx, DWORD PTR dictIndexDelta$1$[rsp]
	add	rcx, rbp
	jmp	SHORT $LN333@ZSTD_compr
$LN332@ZSTD_compr:
	mov	ecx, edx
	add	rcx, QWORD PTR base$1$[rsp]
$LN333@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, r10d
	mov	DWORD PTR [r8], r13d
	sub	eax, edx
	dec	eax
	cmp	eax, 3
	jb	$LN320@ZSTD_compr
	mov	eax, DWORD PTR [r15+1]
	lea	r12, QWORD PTR [r15+1]
	cmp	DWORD PTR [rcx], eax
	jne	$LN2059@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	lea	rdi, QWORD PTR [rcx+4]
	cmp	edx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 272  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	cmovb	rsi, QWORD PTR dictEnd$1$[rsp]

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	r15, 5
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
	sub	rcx, rdi
	add	rcx, rsi
	cmp	rcx, r8
	cmovb	r8, rcx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rcx, r15
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, rsi
	mov	rsi, QWORD PTR iend$1$[rsp]
	jne	SHORT $LN420@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r15+rax]
	mov	r8, rsi
	call	ZSTD_count
	add	rbp, rax
$LN420@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
	lea	r9, QWORD PTR [rsi-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	rbp, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	QWORD PTR litLimit_w$1$[rsp], r9
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 274  :             ip++;

	mov	r15, r12

; 275  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);

	sub	r12, r14
	lea	rdi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r12+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r9
	ja	SHORT $LN426@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r12, 16
	jbe	SHORT $LN427@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r12
	npad	9
$LL440@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL440@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN427@ZSTD_compr
$LN426@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN427@ZSTD_compr:

; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbx+24], r12
	mov	rcx, QWORD PTR [rbx+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r12, 65535				; 0000ffffH
	jbe	SHORT $LN2006@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2006@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r12w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbx+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN2007@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2007@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	mov	r12, QWORD PTR litLimit_w$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	jmp	$LN2080@ZSTD_compr
$LN2059@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */
; 269  : 
; 270  :         if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	r12, QWORD PTR prefixStart$1$[rsp]
$LN320@ZSTD_compr:

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	cmp	r9d, r10d
	ja	$LN322@ZSTD_compr

; 277  :             size_t const dictHash = ZSTD_hashPtr(ip, dictHLog, mls);

	mov	edx, DWORD PTR dictHLog$1$[rsp]
	mov	r8d, 5
	mov	rcx, r15
	call	ZSTD_hashPtr

; 278  :             U32 const dictMatchIndex = dictHashTable[dictHash];

	mov	rcx, QWORD PTR dictHashTable$1$[rsp]
	mov	ecx, DWORD PTR [rcx+rax*4]

; 279  :             const BYTE* dictMatch = dictBase + dictMatchIndex;

	lea	rsi, QWORD PTR [rcx+rbp]

; 280  :             if (dictMatchIndex <= dictStartIndex ||

	cmp	ecx, DWORD PTR dictStartIndex$1$[rsp]
	jbe	$LN326@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rsi], eax
	jne	$LN326@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 288  :                 mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;

	lea	r12, QWORD PTR [r15+4]
	sub	r13d, ecx
	lea	rdi, QWORD PTR [rsi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
	mov	rax, r12
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 287  :                 U32 const offset = (U32)(current-dictMatchIndex-dictIndexDelta);

	sub	r13d, DWORD PTR dictIndexDelta$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, rdi
	add	rcx, rax

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, rdi
	cmp	rcx, r8
	cmovb	r8, rcx
	mov	rcx, r12
	call	ZSTD_count
	mov	rbp, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rdi+rax]
	cmp	rcx, QWORD PTR dictEnd$1$[rsp]
	je	SHORT $LN532@ZSTD_compr
	mov	r12, QWORD PTR iend$1$[rsp]
	jmp	SHORT $LN531@ZSTD_compr
$LN532@ZSTD_compr:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [r12+rax]
	mov	r12, QWORD PTR iend$1$[rsp]
	mov	r8, r12
	call	ZSTD_count
	add	rbp, rax
$LN531@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 290  :                      && (ip[-1] == dictMatch[-1])) {

	mov	r8, QWORD PTR dictStart$1$[rsp]
	xor	r9d, r9d
	add	rbp, 4
	mov	ecx, r9d
	cmp	rsi, r8
	mov	eax, r9d
	seta	cl
	cmp	r15, r14
	seta	al
	test	ecx, eax
	je	SHORT $LN2053@ZSTD_compr
$LL314@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rsi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2053@ZSTD_compr

; 291  :                     ip--; dictMatch--; mLength++;

	inc	rbp
	mov	ecx, r9d
	cmp	rsi, r8
	mov	eax, r9d
	mov	r15, rdx
	seta	cl
	cmp	rdx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL314@ZSTD_compr
$LN2053@ZSTD_compr:

; 292  :                 } /* catch up */
; 293  :                 offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
	sub	rdi, r14
	mov	DWORD PTR offset_2$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 294  :                 offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	$LN564@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	$LN565@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
$LL551@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL551@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	$LN565@ZSTD_compr
$LN326@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 283  :                 ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15

; 284  :                 continue;

	mov	rsi, QWORD PTR iend$1$[rsp]
	sub	rcx, r14
	sar	rcx, 8
	add	r15, rax
	add	r15, rcx
	jmp	$LN330@ZSTD_compr
$LN322@ZSTD_compr:

; 296  :             }
; 297  :         } else if (MEM_read32(match) != MEM_read32(ip)) {

	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdi], eax
	je	SHORT $LN327@ZSTD_compr

; 298  :             /* it's not a match, and we're not going to check the dictionary */
; 299  :             assert(stepSize >= 1);
; 300  :             ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, r15
	sub	rcx, r14
	add	r15, rax
	sar	rcx, 8
	add	r15, rcx

; 301  :             continue;

	jmp	$LN330@ZSTD_compr
$LN327@ZSTD_compr:

; 302  :         } else {
; 303  :             /* found a regular match */
; 304  :             U32 const offset = (U32)(ip-match);

	mov	r13d, r15d

; 305  :             mLength = ZSTD_count(ip+4, match+4, iend) + 4;

	lea	rdx, QWORD PTR [rdi+4]
	lea	rcx, QWORD PTR [r15+4]
	mov	r8, rsi
	sub	r13d, edi
	call	ZSTD_count

; 306  :             while (((ip>anchor) & (match>prefixStart))
; 307  :                  && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */

	xor	r8d, r8d
	cmp	rdi, r12
	mov	edx, r8d
	mov	ecx, r8d
	seta	dl
	lea	rbp, QWORD PTR [rax+4]
	cmp	r15, r14
	seta	cl
	test	edx, ecx
	je	SHORT $LN2054@ZSTD_compr
	npad	5
$LL316@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi-1]
	lea	rdx, QWORD PTR [r15-1]
	dec	rdi
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN2054@ZSTD_compr
	inc	rbp
	mov	ecx, r8d
	cmp	rdi, r12
	mov	eax, r8d
	mov	r15, rdx
	seta	cl
	cmp	rdx, r14
	seta	al
	test	ecx, eax
	jne	SHORT $LL316@ZSTD_compr
$LN2054@ZSTD_compr:

; 308  :             offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r12, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	rdi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	sub	rdi, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	add	r12, -32				; ffffffffffffffe0H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 308  :             offset_2 = offset_1;

	mov	DWORD PTR offset_2$1$[rsp], eax

; 309  :             offset_1 = offset;

	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdi+r14]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r12
	ja	SHORT $LN564@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdi, 16
	jbe	SHORT $LN565@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbx+24]
	add	r14, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdi
	npad	2
$LL578@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]

; 289  :             COPY16(op, ip);

	lea	r14, QWORD PTR [r14+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL578@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN565@ZSTD_compr
$LN564@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 314  :         ip += mLength;

	mov	r9, r12
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN565@ZSTD_compr:
	add	QWORD PTR [rbx+24], rdi
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN2010@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 1
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2010@ZSTD_compr:
	mov	WORD PTR [rcx+4], di
	lea	ecx, DWORD PTR [r13+3]
	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbx+8]
	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN2011@ZSTD_compr
	mov	rax, rcx
	mov	DWORD PTR [rbx+72], 2
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
$LN2011@ZSTD_compr:
	mov	r13d, DWORD PTR current$1$[rsp]
	mov	WORD PTR [rcx+6], si
	mov	rsi, QWORD PTR iend$1$[rsp]
$LN2080@ZSTD_compr:
	add	QWORD PTR [rbx+8], 8
	lea	r14, QWORD PTR [r15+rbp]

; 315  :         anchor = ip;

	lea	rbp, QWORD PTR [rsi-8]
	mov	r15, r14
	cmp	r14, rbp

; 316  : 
; 317  :         if (ip <= ilimit) {

	ja	$LN2062@ZSTD_compr

; 318  :             /* Fill Table */
; 319  :             assert(base+current+2 > istart);  /* check base overflow */
; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	mov	rbp, QWORD PTR base$1$[rsp]
	lea	edi, DWORD PTR [r13+2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 5
	mov	eax, r13d
	lea	rcx, QWORD PTR [rbp+2]
	add	rcx, rax
	call	ZSTD_hashPtr
	mov	r13, QWORD PTR hashTable$1$[rsp]

; 321  :             hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);

	lea	rcx, QWORD PTR [r14-2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, 5
	mov	DWORD PTR [r13+rax*4], edi
	mov	edi, r14d
	sub	edi, ebp
	sub	edi, 2
	call	ZSTD_hashPtr
	mov	DWORD PTR [r13+rax*4], edi
	mov	r13, QWORD PTR dictBase$1$[rsp]
$LL318@ZSTD_compr:

; 322  : 
; 323  :             /* check immediate repcode */
; 324  :             while (ip <= ilimit) {
; 325  :                 U32 const current2 = (U32)(ip-base);
; 326  :                 U32 const repIndex2 = current2 - offset_2;
; 327  :                 const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	edi, r15d
	sub	edi, ebp
	mov	ecx, edi
	sub	ecx, DWORD PTR offset_2$1$[rsp]
	mov	r8d, ecx
	cmp	ecx, r10d
	jae	SHORT $LN334@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	mov	rdx, r13
	sub	rdx, rax
	add	rdx, r8
	jmp	SHORT $LN335@ZSTD_compr
$LN334@ZSTD_compr:
	lea	rdx, QWORD PTR [rcx+rbp]
$LN335@ZSTD_compr:

; 328  :                         dictBase - dictIndexDelta + repIndex2 :
; 329  :                         base + repIndex2;
; 330  :                 if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
; 331  :                    && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN2055@ZSTD_compr
	mov	eax, DWORD PTR [r15]
	cmp	DWORD PTR [rdx], eax
	jne	$LN2055@ZSTD_compr

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	mov	rax, QWORD PTR prefixStart$1$[rsp]
	cmp	ecx, r10d
	mov	r9, rsi
	mov	QWORD PTR [rsp+32], rax
	cmovb	r9, QWORD PTR dictEnd$1$[rsp]
	lea	rcx, QWORD PTR [r15+4]
	add	rdx, 4
	mov	r8, rsi
	call	ZSTD_count_2segments

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	ecx, DWORD PTR offset_2$1$[rsp]
	lea	rbp, QWORD PTR [rax+4]
	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_1$1$[rsp], ecx

; 335  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);

	lea	rsi, QWORD PTR [rbp-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r14, r12
	ja	SHORT $LN749@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN750@ZSTD_compr
$LN749@ZSTD_compr:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);

	mov	r9, r12
	mov	r8, r14
	mov	rdx, r14
	call	ZSTD_safecopyLiterals
$LN750@ZSTD_compr:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax], 1

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN2043@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, QWORD PTR [rbx+8]
	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	mov	DWORD PTR [rbx+76], eax
	mov	DWORD PTR [rbx+72], 2
$LN2043@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	rax, QWORD PTR [rbx+8]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	r8d, 5
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rax+6], si

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbx+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	call	ZSTD_hashPtr
	mov	rcx, QWORD PTR hashTable$1$[rsp]

; 337  :                     ip += repLength2;

	add	r15, rbp
	mov	r14, r15
	mov	rsi, QWORD PTR iend$1$[rsp]
	mov	rbp, QWORD PTR base$1$[rsp]
	mov	DWORD PTR [rcx+rax*4], edi
	cmp	r15, QWORD PTR ilimit$1$[rsp]
	jbe	$LL318@ZSTD_compr
$LN2055@ZSTD_compr:
	mov	rsi, QWORD PTR iend$1$[rsp]
$LN2062@ZSTD_compr:

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	mov	rbp, QWORD PTR dictBase$1$[rsp]
$LN330@ZSTD_compr:
	mov	r12, QWORD PTR prefixStart$1$[rsp]
	lea	rax, QWORD PTR [rsi-8]
	mov	rdi, QWORD PTR base$1$[rsp]
	mov	r13d, DWORD PTR hlog$1$[rsp]
	cmp	r15, rax
	jb	$LL312@ZSTD_compr
$LN313@ZSTD_compr:

; 371  :     }
; 372  : }

	mov	eax, DWORD PTR offset_1$1$[rsp]
	sub	rsi, r14
	mov	rcx, QWORD PTR rep$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR offset_2$1$[rsp]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, rsi
$LN1@ZSTD_compr:
	mov	rbx, QWORD PTR [rsp+248]
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressBlock_fast_dictMatchState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_64bits PROC

; 184  : MEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }

	mov	eax, 1
	ret	0
MEM_64bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
MEM_isLittleEndian PROC

; 188  :     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
; 189  :     return one.c[0];

	mov	eax, 1

; 190  : }

	ret	0
MEM_isLittleEndian ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read16 PROC

; 239  :     U16 val; memcpy(&val, memPtr, sizeof(val)); return val;

	movzx	eax, WORD PTR [rcx]

; 240  : }

	ret	0
MEM_read16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read32 PROC

; 244  :     U32 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	eax, DWORD PTR [rcx]

; 245  : }

	ret	0
MEM_read32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_read64 PROC

; 249  :     U64 val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 250  : }

	ret	0
MEM_read64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readST PROC

; 254  :     size_t val; memcpy(&val, memPtr, sizeof(val)); return val;

	mov	rax, QWORD PTR [rcx]

; 255  : }

	ret	0
MEM_readST ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
in$ = 8
MEM_swap64 PROC

; 291  : #if defined(_MSC_VER)     /* Visual Studio */
; 292  :     return _byteswap_uint64(in);

	bswap	rcx
	mov	rax, rcx

; 293  : #elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
; 294  :   || (defined(__clang__) && __has_builtin(__builtin_bswap64))
; 295  :     return __builtin_bswap64(in);
; 296  : #else
; 297  :     return  ((in << 56) & 0xff00000000000000ULL) |
; 298  :             ((in << 40) & 0x00ff000000000000ULL) |
; 299  :             ((in << 24) & 0x0000ff0000000000ULL) |
; 300  :             ((in << 8)  & 0x000000ff00000000ULL) |
; 301  :             ((in >> 8)  & 0x00000000ff000000ULL) |
; 302  :             ((in >> 24) & 0x0000000000ff0000ULL) |
; 303  :             ((in >> 40) & 0x000000000000ff00ULL) |
; 304  :             ((in >> 56) & 0x00000000000000ffULL);
; 305  : #endif
; 306  : }

	ret	0
MEM_swap64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\mem.h
_TEXT	SEGMENT
memPtr$ = 8
MEM_readLE64 PROC

; 368  :     if (MEM_isLittleEndian())
; 369  :         return MEM_read64(memPtr);

	mov	rax, QWORD PTR [rcx]

; 370  :     else
; 371  :         return MEM_swap64(MEM_read64(memPtr));
; 372  : }

	ret	0
MEM_readLE64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy8 PROC

; 231  : #ifdef __aarch64__
; 232  :     vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));
; 233  : #else
; 234  :     memcpy(dst, src, 8);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 235  : #endif
; 236  : }

	ret	0
ZSTD_copy8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
ZSTD_copy16 PROC

; 240  : #ifdef __aarch64__
; 241  :     vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));
; 242  : #else
; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 244  : #endif
; 245  : }

	ret	0
ZSTD_copy16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\common\zstd_internal.h
_TEXT	SEGMENT
dst$ = 8
src$ = 16
length$ = 24
ovtype$dead$ = 32
ZSTD_wildcopy PROC

; 267  :     ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;
; 268  :     const BYTE* ip = (const BYTE*)src;
; 269  :     BYTE* op = (BYTE*)dst;
; 270  :     BYTE* const oend = op + length;

	lea	rax, QWORD PTR [rcx+r8]
	sub	rdx, rcx
	npad	9
$LL7@ZSTD_wildc:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 271  : 
; 272  :     assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));
; 273  : 
; 274  :     if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {
; 275  :         /* Handle short offset copies. */
; 276  :         do {
; 277  :             COPY8(op, ip)
; 278  :         } while (op < oend);
; 279  :     } else {
; 280  :         assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);
; 281  :         /* Separate out the first COPY16() call because the copy length is
; 282  :          * almost certain to be short, so the branches have different
; 283  :          * probabilities. Since it is almost certain to be short, only do
; 284  :          * one COPY16() in the first call. Then, do two calls per loop since
; 285  :          * at that point it is more likely to have a high trip count.
; 286  :          */
; 287  : #ifndef __aarch64__
; 288  :         do {
; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rax
	jb	SHORT $LL7@ZSTD_wildc

; 292  : #else
; 293  :         COPY16(op, ip);
; 294  :         if (op >= oend) return;
; 295  :         do {
; 296  :             COPY16(op, ip);
; 297  :             COPY16(op, ip);
; 298  :         }
; 299  :         while (op < oend);
; 300  : #endif
; 301  :     }
; 302  : }

	ret	0
ZSTD_wildcopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
op$ = 8
ip$ = 16
iend$ = 24
ilimit_w$ = 32
ZSTD_safecopyLiterals PROC

; 423  :     assert(iend > ilimit_w);
; 424  :     if (ip <= ilimit_w) {

	cmp	rdx, r9
	ja	SHORT $LN19@ZSTD_safec
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r10, rcx
	sub	r10, rdx
	add	r10, r9
	sub	rdx, rcx
	npad	15
$LL12@ZSTD_safec:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdx+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL12@ZSTD_safec
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	mov	rdx, r9
$LN19@ZSTD_safec:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdx, r8
	jae	SHORT $LN3@ZSTD_safec
	npad	5
$LL21@ZSTD_safec:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	BYTE PTR [rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	cmp	rdx, r8
	jb	SHORT $LL21@ZSTD_safec
$LN3@ZSTD_safec:

; 430  : }

	ret	0
ZSTD_safecopyLiterals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
seqStorePtr$ = 8
litLength$ = 16
literals$ = 24
litLimit$ = 32
offCode$ = 40
mlBase$ = 48
ZSTD_storeSeq PROC

; 440  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	r10, rcx

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbx, QWORD PTR [r9-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rcx, QWORD PTR [rdx+r8]
	mov	r11, rdx
	mov	r9, QWORD PTR [r10+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	rcx, rbx
	ja	SHORT $LN2@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r9], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	SHORT $LN24@ZSTD_store

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r10+24]
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rdx-16]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	add	rax, 16
	add	r8, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	add	rcx, rax
	npad	3
$LL16@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8]

; 289  :             COPY16(op, ip);

	lea	r8, QWORD PTR [r8+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL16@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN24@ZSTD_store
$LN2@ZSTD_store:

; 424  :     if (ip <= ilimit_w) {

	cmp	r8, rbx
	ja	SHORT $LN41@ZSTD_store
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, r9
	sub	rdx, r8
	add	rdx, rbx
	sub	r8, r9
	npad	9
$LL33@ZSTD_store:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [r8+r9]
	movups	XMMWORD PTR [r9], xmm0

; 289  :             COPY16(op, ip);

	add	r9, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	r9, rdx
	jb	SHORT $LL33@ZSTD_store
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	r9, rdx
	mov	r8, rbx
$LN41@ZSTD_store:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	r8, rcx
	jae	SHORT $LN24@ZSTD_store
	sub	r9, r8
$LL43@ZSTD_store:
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r9+r8], al
	inc	r8
	cmp	r8, rcx
	jb	SHORT $LL43@ZSTD_store
$LN24@ZSTD_store:

; 466  :         ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);
; 467  :     }
; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r10+24], r11
	mov	rcx, QWORD PTR [r10+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r11, 65535				; 0000ffffH
	jbe	SHORT $LN48@ZSTD_store

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 1
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN48@ZSTD_store:

; 475  :     }
; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;
; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;
; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	mov	rdx, QWORD PTR mlBase$[rsp]
	mov	WORD PTR [rcx+4], r11w
	mov	ecx, DWORD PTR offCode$[rsp]
	mov	rax, QWORD PTR [r10+8]
	inc	ecx
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r10+8]
	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN53@ZSTD_store

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r10+72], 2
	sub	rax, QWORD PTR [r10]
	sar	rax, 3
	mov	DWORD PTR [r10+76], eax
$LN53@ZSTD_store:

; 486  :     }
; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;
; 488  : 
; 489  :     seqStorePtr->sequences++;
; 490  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	WORD PTR [rcx+6], dx
	add	QWORD PTR [r10+8], 8
	ret	0
ZSTD_storeSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
val$ = 8
r$1 = 16
ZSTD_NbCommonBytes PROC

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN9@ZSTD_NbCom
	shr	eax, 3

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
$LN9@ZSTD_NbCom:

; 498  :     if (MEM_isLittleEndian()) {
; 499  :         if (MEM_64bits()) {
; 500  : #       if defined(_MSC_VER) && defined(_WIN64)
; 501  :             unsigned long r = 0;
; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 503  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 504  :             return (__builtin_ctzll((U64)val) >> 3);
; 505  : #       else
; 506  :             static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
; 507  :                                                      0, 3, 1, 3, 1, 4, 2, 7,
; 508  :                                                      0, 2, 3, 6, 1, 5, 3, 5,
; 509  :                                                      1, 3, 4, 4, 2, 5, 6, 7,
; 510  :                                                      7, 0, 1, 2, 3, 3, 4, 6,
; 511  :                                                      2, 6, 5, 5, 3, 4, 5, 6,
; 512  :                                                      7, 1, 2, 4, 6, 4, 4, 5,
; 513  :                                                      7, 2, 6, 5, 7, 6, 7, 7 };
; 514  :             return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
; 515  : #       endif
; 516  :         } else { /* 32 bits */
; 517  : #       if defined(_MSC_VER)
; 518  :             unsigned long r=0;
; 519  :             return _BitScanForward( &r, (U32)val ) ? (unsigned)(r >> 3) : 0;
; 520  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 521  :             return (__builtin_ctz((U32)val) >> 3);
; 522  : #       else
; 523  :             static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
; 524  :                                                      3, 2, 2, 1, 3, 2, 0, 1,
; 525  :                                                      3, 3, 1, 2, 2, 2, 2, 0,
; 526  :                                                      3, 1, 2, 0, 1, 0, 1, 1 };
; 527  :             return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
; 528  : #       endif
; 529  :         }
; 530  :     } else {  /* Big Endian CPU */
; 531  :         if (MEM_64bits()) {
; 532  : #       if defined(_MSC_VER) && defined(_WIN64)
; 533  :             unsigned long r = 0;
; 534  :             return _BitScanReverse64( &r, val ) ? (unsigned)(r >> 3) : 0;
; 535  : #       elif defined(__GNUC__) && (__GNUC__ >= 4)
; 536  :             return (__builtin_clzll(val) >> 3);
; 537  : #       else
; 538  :             unsigned r;
; 539  :             const unsigned n32 = sizeof(size_t)*4;   /* calculate this way due to compiler complaining in 32-bits mode */
; 540  :             if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }
; 541  :             if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
; 542  :             r += (!val);
; 543  :             return r;
; 544  : #       endif
; 545  :         } else { /* 32 bits */
; 546  : #       if defined(_MSC_VER)
; 547  :             unsigned long r = 0;
; 548  :             return _BitScanReverse( &r, (unsigned long)val ) ? (unsigned)(r >> 3) : 0;
; 549  : #       elif defined(__GNUC__) && (__GNUC__ >= 3)
; 550  :             return (__builtin_clz((U32)val) >> 3);
; 551  : #       else
; 552  :             unsigned r;
; 553  :             if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
; 554  :             r += (!val);
; 555  :             return r;
; 556  : #       endif
; 557  :     }   }
; 558  : }

	ret	0
ZSTD_NbCommonBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
r$1 = 8
r$2 = 8
pIn$ = 8
pMatch$ = 16
pInLimit$ = 24
ZSTD_count PROC

; 563  :     const BYTE* const pStart = pIn;
; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r9, QWORD PTR [r8-7]
	mov	r10, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN5@ZSTD_count

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], 0
	je	SHORT $LN20@ZSTD_count
	shr	eax, 3

; 580  : }

	ret	0
$LN20@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	eax, eax

; 580  : }

	ret	0
$LN5@ZSTD_count:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN3@ZSTD_count
$LL2@ZSTD_count:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	SHORT $LN6@ZSTD_count
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r9
	jb	SHORT $LL2@ZSTD_count
$LN3@ZSTD_count:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r8-3]
	cmp	rcx, rax
	jae	SHORT $LN7@ZSTD_count
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN7@ZSTD_count
	add	rcx, 4
	add	rdx, 4
$LN7@ZSTD_count:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r8-1]
	cmp	rcx, rax
	jae	SHORT $LN8@ZSTD_count
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN8@ZSTD_count
	add	rcx, 2
	add	rdx, 2
$LN8@ZSTD_count:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r8
	jae	SHORT $LN9@ZSTD_count
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN9@ZSTD_count
	inc	rcx
$LN9@ZSTD_count:

; 579  :     return (size_t)(pIn - pStart);

	sub	rcx, r10
	mov	rax, rcx

; 580  : }

	ret	0
$LN6@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN36@ZSTD_count
	shr	edx, 3

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
$LN36@ZSTD_count:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 573  :             pIn += ZSTD_NbCommonBytes(diff);

	mov	eax, edx

; 574  :             return (size_t)(pIn - pStart);

	sub	rax, r10
	add	rax, rcx

; 580  : }

	ret	0
ZSTD_count ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ip$ = 48
match$ = 56
iEnd$ = 64
mEnd$ = 72
iStart$ = 80
ZSTD_count_2segments PROC

; 589  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r10, rcx
	mov	rsi, r8
	sub	r10, rdx
	mov	rbx, r9
	add	r10, r9
	mov	r11, rdx
	cmp	r10, r8
	mov	rbp, rcx
	cmovb	r8, r10

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	call	ZSTD_count
	mov	rdi, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	jne	SHORT $LN1@ZSTD_count

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR iStart$[rsp]
	lea	rcx, QWORD PTR [rax+rbp]
	mov	r8, rsi
	call	ZSTD_count
	add	rax, rdi
$LN1@ZSTD_count:

; 599  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ZSTD_count_2segments ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash4 PROC

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, ecx, -1640531535			; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	eax, cl
	ret	0
ZSTD_hash4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ptr$ = 8
h$ = 16
ZSTD_hash4Ptr PROC

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H
	sub	ecx, edx
	shr	rax, cl

; 611  : static size_t ZSTD_hash4Ptr(const void* ptr, U32 h) { return ZSTD_hash4(MEM_read32(ptr), h); }

	ret	0
ZSTD_hash4Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash5 PROC

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash5 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash5Ptr PROC

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 615  : static size_t ZSTD_hash5Ptr(const void* p, U32 h) { return ZSTD_hash5(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash5Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash6 PROC

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash6 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash6Ptr PROC

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 619  : static size_t ZSTD_hash6Ptr(const void* p, U32 h) { return ZSTD_hash6(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash6Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash7 PROC

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash7 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash7Ptr PROC

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 623  : static size_t ZSTD_hash7Ptr(const void* p, U32 h) { return ZSTD_hash7(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash7Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
u$ = 8
h$ = 16
ZSTD_hash8 PROC

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, rcx
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hash8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
h$ = 16
ZSTD_hash8Ptr PROC

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx]
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl

; 627  : static size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h); }

	ret	0
ZSTD_hash8Ptr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
p$ = 8
hBits$ = 16
mls$ = 24
ZSTD_hashPtr PROC

; 631  :     switch(mls)

	sub	r8d, 5
	je	SHORT $LN5@ZSTD_hashP
	sub	r8d, 1
	je	SHORT $LN6@ZSTD_hashP
	sub	r8d, 1
	je	SHORT $LN7@ZSTD_hashP
	cmp	r8d, 1
	je	SHORT $LN8@ZSTD_hashP

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rcx], -1640531535	; 9e3779b1H
	mov	ecx, 32					; 00000020H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN8@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN7@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN6@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
$LN5@ZSTD_hashP:
	mov	rax, QWORD PTR [rcx]

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	r8, -3523014627271114752		; cf1bbcdcbb000000H

; 632  :     {
; 633  :     default:
; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);
; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);
; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);
; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);
; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);
; 639  :     }
; 640  : }

	imul	rax, r8
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	shr	rax, cl
	ret	0
ZSTD_hashPtr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 8
current$ = 16
windowLog$ = 24
ZSTD_getLowestMatchIndex PROC

; 977  : {

	mov	rax, rcx

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r8d
	mov	r8d, 1
	shl	r8d, cl

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	r9d, DWORD PTR [rax+28]

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;
; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, DWORD PTR [rax+32]
	mov	eax, edx
	sub	edx, r8d
	sub	eax, r9d
	cmp	eax, r8d
	cmovbe	edx, r9d
	test	ecx, ecx

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	edx, r9d

; 983  :     return matchLowest;

	mov	eax, edx

; 984  : }

	ret	0
ZSTD_getLowestMatchIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
_TEXT	SEGMENT
ms$ = 8
current$ = 16
windowLog$ = 24
ZSTD_getLowestPrefixIndex PROC

; 990  : {

	mov	rax, rcx

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, r8d
	mov	r8d, 1
	shl	r8d, cl

; 992  :     U32    const lowestValid = ms->window.dictLimit;

	mov	r9d, DWORD PTR [rax+24]

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;
; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, DWORD PTR [rax+32]
	mov	eax, edx
	sub	edx, r8d
	sub	eax, r9d
	cmp	eax, r8d
	cmovbe	edx, r9d
	test	ecx, ecx

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	edx, r9d

; 996  :     return matchLowest;

	mov	eax, edx

; 997  : }

	ret	0
ZSTD_getLowestPrefixIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
hashTable$1$ = 0
val1$1$ = 8
r$1 = 8
r$2 = 8
base$1$ = 16
prefixStartIndex$1$ = 24
current0$1$ = 28
tv2513 = 32
tv2041 = 40
iend$1$ = 48
prefixStart$1$ = 56
stepSize$1$ = 64
offset_1$1$ = 144
ms$ = 144
seqStore$ = 152
rep$ = 160
offset_2$1$ = 168
r$3 = 168
r$4 = 168
src$ = 168
tv2060 = 176
srcSize$ = 176
mls$ = 184
ZSTD_compressBlock_fast_generic PROC

; 51   : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 52   :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 53   :     U32* const hashTable = ms->hashTable;
; 54   :     U32 const hlog = cParams->hashLog;
; 55   :     /* support stepSize of 0 */
; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	mov	r11d, DWORD PTR [rcx+204]
	mov	rbx, rcx
	mov	r12, QWORD PTR [rcx+48]
	mov	eax, r11d
	mov	r15d, DWORD PTR [rcx+192]
	neg	eax
	mov	r14, r8
	mov	QWORD PTR hashTable$1$[rsp], r12

; 57   :     const BYTE* const base = ms->window.base;

	mov	r8, QWORD PTR [rcx+8]
	sbb	r10d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [rcx+184]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 51   : {

	mov	rsi, r9
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 992  :     U32    const lowestValid = ms->window.dictLimit;

	mov	edi, DWORD PTR [rbx+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 51   : {

	mov	rbp, rdx

; 63   :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	mov	rdx, QWORD PTR srcSize$[rsp]
	lea	eax, DWORD PTR [r10+2]
	mov	QWORD PTR base$1$[rsp], r8
	add	eax, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 991  :     U32    const maxDistance = 1U << windowLog;

	mov	r10d, 1
	shl	r10d, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 63   :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	mov	r11d, edx
	sub	r11d, r8d
	mov	QWORD PTR stepSize$1$[rsp], rax
	add	r11d, r9d

; 66   :     const BYTE* const iend = istart + srcSize;

	lea	r13, QWORD PTR [rsi+rdx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r9d, DWORD PTR [rbx+32]
	mov	eax, r11d
	sub	eax, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 66   :     const BYTE* const iend = istart + srcSize;

	mov	QWORD PTR iend$1$[rsp], r13
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	sub	r11d, r10d
	cmp	eax, r10d
	cmovbe	r11d, edi
	test	r9d, r9d

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r11d, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 73   :     ip0 += (ip0 == prefixStart);

	xor	eax, eax
	mov	ecx, r11d
	add	rcx, r8
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR prefixStartIndex$1$[rsp], r11d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 68   :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	r8d, DWORD PTR [r14+4]

; 69   :     U32 offsetSaved = 0;

	cmp	rsi, rcx
	mov	r11d, DWORD PTR [r14]

; 73   :     ip0 += (ip0 == prefixStart);

	sete	al
	mov	QWORD PTR prefixStart$1$[rsp], rcx
	lea	rbx, QWORD PTR [rax+rsi]

; 74   :     ip1 = ip0 + 1;
; 75   :     {   U32 const current = (U32)(ip0 - base);

	mov	edx, ebx
	lea	r14, QWORD PTR [rbx+1]
	sub	edx, DWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, edx

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, edx
	sub	ecx, r10d
	sub	eax, edi
	cmp	eax, r10d
	cmovbe	ecx, edi
	test	r9d, r9d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r9d, r11d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, edi
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	xor	eax, eax
	sub	edx, ecx
	mov	r10d, eax
	cmp	r8d, edx
	cmovbe	r10d, r8d
	cmovbe	r8d, eax

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	cmp	r11d, edx
	cmovbe	r9d, r8d
	mov	r8d, eax
	lea	rax, QWORD PTR [r13-8]
	mov	DWORD PTR tv2513[rsp], r9d
	cmovbe	r8d, r11d
	cmp	r14, rax
	jae	$LN3@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r11d, DWORD PTR mls$[rsp]

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	sub	ecx, r15d

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	DWORD PTR offset_2$1$[rsp], r10d
	mov	r9d, 64					; 00000040H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	QWORD PTR tv2041[rsp], rcx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	sub	r9d, r15d
	mov	DWORD PTR offset_1$1$[rsp], r8d
	mov	DWORD PTR tv2060[rsp], r9d
	mov	rdi, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r15, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r10, -3523014627271114752		; cf1bbcdcbb000000H
	npad	7
$LL383@ZSTD_compr:

; 631  :     switch(mls)

	mov	eax, r11d
	mov	r8, -3523014627193847808		; cf1bbcdcbf9b0000H
	sub	eax, 5
	je	$LN29@ZSTD_compr
	mov	r10d, DWORD PTR [rbx]
	sub	eax, 1
	je	SHORT $LN30@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN31@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN32@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, r10d, -1640531535			; 9e3779b1H

; 631  :     switch(mls)

	mov	eax, r11d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl

; 631  :     switch(mls)

	sub	eax, 5
	je	SHORT $LN58@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN59@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN60@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN61@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	r8d, DWORD PTR [r14], -1640531535	; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN384@ZSTD_compr
$LN32@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	mov	ecx, r9d
	imul	rdx, rdi
	shr	rdx, cl
$LN61@ZSTD_compr:
	mov	r8, QWORD PTR [r14]
	imul	r8, rdi

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN385@ZSTD_compr
$LN31@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	mov	ecx, r9d
	imul	rdx, r15
	shr	rdx, cl
$LN60@ZSTD_compr:
	mov	r8, QWORD PTR [r14]
	imul	r8, r15

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN385@ZSTD_compr
$LN30@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	mov	ecx, r9d
	imul	rdx, r8
	shr	rdx, cl
$LN59@ZSTD_compr:
	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN386@ZSTD_compr
$LN29@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx]
	mov	ecx, r9d
	imul	rdx, r10

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	mov	r10d, DWORD PTR [rbx]

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	shr	rdx, cl
$LN58@ZSTD_compr:
	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN386@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 96   :         U32 const val1 = MEM_read32(ip1);

	mov	r8, QWORD PTR [r14]
	imul	r8, rax
$LN385@ZSTD_compr:
	mov	ecx, r9d
$LN384@ZSTD_compr:

; 97   :         U32 const current0 = (U32)(ip0-base);
; 98   :         U32 const current1 = (U32)(ip1-base);
; 99   :         U32 const matchIndex0 = hashTable[h0];

	mov	r15d, DWORD PTR [r12+rdx*4]

; 100  :         U32 const matchIndex1 = hashTable[h1];
; 101  :         BYTE const* repMatch = ip2 - offset_1;

	lea	r11, QWORD PTR [rbx+2]
	mov	eax, DWORD PTR [r14]

; 102  :         const BYTE* match0 = base + matchIndex0;

	mov	r9d, r15d
	add	r9, QWORD PTR base$1$[rsp]
	shr	r8, cl
	mov	ecx, ebx
	sub	ecx, DWORD PTR base$1$[rsp]
	mov	DWORD PTR val1$1$[rsp], eax
	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	r12d, DWORD PTR [r12+r8*4]
	sub	r11, rax

; 103  :         const BYTE* match1 = base + matchIndex1;
; 104  :         U32 offcode;
; 105  : 
; 106  : #if defined(__aarch64__)
; 107  :         PREFETCH_L1(ip0+256);
; 108  : #endif
; 109  : 
; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	rax, QWORD PTR hashTable$1$[rsp]
	mov	edi, r12d
	add	rdi, QWORD PTR base$1$[rsp]
	mov	DWORD PTR current0$1$[rsp], ecx
	mov	DWORD PTR [rax+rdx*4], ecx

; 111  :         hashTable[h1] = current1;   /* update hash table */
; 112  : 
; 113  :         assert(ip0 + 1 == ip1);
; 114  : 
; 115  :         if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {

	xor	edx, edx
	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	eax, r14d
	sub	eax, DWORD PTR base$1$[rsp]
	mov	DWORD PTR [rcx+r8*4], eax
	mov	ecx, edx
	mov	eax, DWORD PTR [rbx+2]
	cmp	DWORD PTR [r11], eax
	mov	eax, edx
	mov	r8d, DWORD PTR offset_1$1$[rsp]
	sete	cl
	test	r8d, r8d
	setne	al
	test	ecx, eax
	je	SHORT $LN10@ZSTD_compr

; 116  :             mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;

	movzx	eax, BYTE PTR [r11-1]
	xor	edi, edi
	cmp	BYTE PTR [rbx+1], al
	mov	r10d, edi

; 117  :             ip0 = ip2 - mLength;
; 118  :             match0 = repMatch - mLength;
; 119  :             mLength += 4;
; 120  :             offcode = 0;
; 121  :             goto _match;

	mov	r12d, DWORD PTR offset_2$1$[rsp]
	mov	r9, r11
	sete	r10b
	mov	r14d, edi
	add	rbx, 2
	sub	r9, r10
	sub	rbx, r10
	add	r10, 4
	jmp	$_match$393
$LN10@ZSTD_compr:

; 122  :         }
; 123  :         if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	r15d, eax
	jbe	SHORT $LN11@ZSTD_compr
	cmp	DWORD PTR [r9], r10d
	je	SHORT $_offset$394
$LN11@ZSTD_compr:

; 124  :             /* found a regular match */
; 125  :             goto _offset;
; 126  :         }
; 127  :         if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {

	cmp	r12d, eax
	jbe	$LN12@ZSTD_compr
	mov	eax, DWORD PTR val1$1$[rsp]
	cmp	DWORD PTR [rdi], eax
	jne	$LN12@ZSTD_compr

; 128  :             /* found a regular match after one literal */
; 129  :             ip0 = ip1;

	mov	rbx, r14

; 130  :             match0 = match1;

	mov	r9, rdi
$_offset$394:

; 137  :             continue;
; 138  :         }
; 139  : _offset: /* Requires: ip0, match0 */
; 140  :         /* Compute the offset code */
; 141  :         offset_2 = offset_1;
; 142  :         offset_1 = (U32)(ip0-match0);
; 143  :         offcode = offset_1 + ZSTD_REP_MOVE;
; 144  :         mLength = 4;
; 145  :         /* Count the backwards match length */
; 146  :         while (((ip0>anchor) & (match0>prefixStart))
; 147  :              && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; } /* catch up */

	mov	r11, QWORD PTR prefixStart$1$[rsp]
	xor	edi, edi
	mov	ecx, edi
	mov	DWORD PTR offset_2$1$[rsp], r8d
	mov	eax, ebx
	mov	r12d, r8d
	sub	eax, r9d
	cmp	r9, r11
	mov	DWORD PTR offset_1$1$[rsp], eax
	lea	r10d, QWORD PTR [rdi+4]
	seta	cl
	cmp	rbx, rsi
	lea	r14d, DWORD PTR [rax+2]
	mov	eax, edi
	seta	al
	test	ecx, eax
	je	SHORT $_match$393
	npad	15
$LL4@ZSTD_compr:
	movzx	eax, BYTE PTR [r9-1]
	lea	rdx, QWORD PTR [r9-1]
	cmp	BYTE PTR [rbx-1], al
	lea	r8, QWORD PTR [rbx-1]
	jne	SHORT $_match$393
	inc	r10
	mov	ecx, edi
	cmp	rdx, r11
	mov	eax, edi
	mov	rbx, r8
	mov	r9, rdx
	seta	cl
	cmp	r8, rsi
	seta	al
	test	ecx, eax
	jne	SHORT $LL4@ZSTD_compr
$_match$393:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	mov	r13, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	lea	rcx, QWORD PTR [r10+rbx]
	lea	rdx, QWORD PTR [r10+r9]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r11, QWORD PTR [r13-7]

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r11
	jae	SHORT $LN85@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN87@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], edi
	je	SHORT $LN102@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN83@ZSTD_compr
$LN102@ZSTD_compr:
	mov	eax, edi

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN83@ZSTD_compr
$LN87@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r11
	jae	SHORT $LN85@ZSTD_compr
$LL84@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN88@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r11
	jb	SHORT $LL84@ZSTD_compr
$LN85@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r13-3]
	cmp	rcx, rax
	jae	SHORT $LN89@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN89@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN89@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r13-1]
	cmp	rcx, rax
	jae	SHORT $LN90@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN90@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN90@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r13
	jae	SHORT $LN91@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN91@ZSTD_compr
	inc	rcx
$LN91@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r8
$LN83@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
	lea	r15, QWORD PTR [r13-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	add	r10, rax

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	mov	rdx, rbx
	sub	rdx, rsi
	lea	rdi, QWORD PTR [r10-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [rdx+rsi]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, r15
	ja	SHORT $LN127@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	rdx, 16
	jbe	$LN149@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
	add	rsi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, rdx
	npad	1
$LL141@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]

; 289  :             COPY16(op, ip);

	lea	rsi, QWORD PTR [rsi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL141@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN149@ZSTD_compr
$LN88@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], edi
	je	SHORT $LN118@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN83@ZSTD_compr
$LN118@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, edi

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN83@ZSTD_compr
$LN127@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rsi, r15
	ja	SHORT $LN338@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r9, rcx
	sub	r9, rsi
	add	r9, r15
	sub	rsi, rcx
	npad	7
$LL158@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi+rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r9
	jb	SHORT $LL158@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r9
	mov	rsi, r15
$LN338@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rsi, r8
	jae	SHORT $LN149@ZSTD_compr
	sub	rcx, rsi
	npad	2
$LL350@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR [rcx+rsi], al
	inc	rsi
	cmp	rsi, r8
	jb	SHORT $LL350@ZSTD_compr
$LN149@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], rdx
	mov	rcx, QWORD PTR [rbp+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN364@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN364@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], dx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdi, 65535				; 0000ffffH
	jbe	SHORT $LN365@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN365@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 154  :         ip0 += mLength;

	add	rbx, r10
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], di

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 155  :         anchor = ip0;

	lea	r10, QWORD PTR [r13-8]
	mov	rsi, rbx
	cmp	rbx, r10

; 156  : 
; 157  :         if (ip0 <= ilimit) {

	ja	$LN7@ZSTD_compr

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	edx, DWORD PTR current0$1$[rsp]
	mov	r14, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	r9d, DWORD PTR mls$[rsp]
	mov	eax, r9d
	mov	rdi, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	rcx, QWORD PTR [r14+rdx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	$LN168@ZSTD_compr
	sub	eax, 1
	je	$LN169@ZSTD_compr
	sub	eax, 1
	je	$LN170@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN171@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	r8d, DWORD PTR [rdx+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, r9d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rcx+2], -1640531535	; 9e3779b1H
	mov	rcx, QWORD PTR tv2041[rsp]

; 631  :     switch(mls)

	mov	r9d, DWORD PTR tv2060[rsp]

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [rdi+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	$LN197@ZSTD_compr
	sub	eax, 1
	je	$LN198@ZSTD_compr
	sub	eax, 1
	je	$LN381@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN382@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rbx-2], -1640531535	; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	$LN387@ZSTD_compr
$LN171@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	add	edx, 2

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r9d, DWORD PTR tv2060[rsp]
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, r8
	mov	ecx, r9d
	shr	rax, cl

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx-2]
	imul	rdx, r8

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	$LN388@ZSTD_compr
$LN382@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx-2]

; 631  :     switch(mls)

	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	imul	rdx, r8

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	$LN388@ZSTD_compr
$LN170@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	add	edx, 2

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	r9d, DWORD PTR tv2060[rsp]
	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, r8
	mov	ecx, r9d
	shr	rax, cl

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx-2]
	imul	rdx, r8

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN388@ZSTD_compr
$LN381@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rbx-2]

; 631  :     switch(mls)

	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	imul	rdx, r8

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN388@ZSTD_compr
$LN169@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	add	edx, 2

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	r9d, DWORD PTR tv2060[rsp]
	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, r9d
	shr	rax, cl

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx
$LN198@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN389@ZSTD_compr
$LN168@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	add	edx, 2

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	r9d, DWORD PTR tv2060[rsp]
	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, rcx
	mov	ecx, r9d
	shr	rax, cl

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx
$LN197@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN389@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	mov	rdx, QWORD PTR [rbx-2]
	imul	rdx, rax
$LN388@ZSTD_compr:
	mov	ecx, r9d
$LN387@ZSTD_compr:
	shr	rdx, cl
	mov	eax, ebx
	sub	eax, r14d
	sub	eax, 2
	mov	DWORD PTR [rdi+rdx*4], eax

; 162  : 
; 163  :             if (offset_2 > 0) { /* offset_2==0 means offset_2 is invalidated */

	test	r12d, r12d
	je	$LN7@ZSTD_compr

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	cmp	rbx, r10
	ja	$LN7@ZSTD_compr
	npad	11
$LL6@ZSTD_compr:
	mov	r10d, DWORD PTR [rbx]
	mov	rdx, rbx
	mov	eax, r12d
	sub	rdx, rax
	cmp	r10d, DWORD PTR [rdx]
	jne	$LN378@ZSTD_compr

; 165  :                     /* store sequence */
; 166  :                     size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;

	lea	rax, QWORD PTR [rbx+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rax

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, r11
	jae	SHORT $LN224@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN226@ZSTD_compr

; 501  :             unsigned long r = 0;

	xor	edx, edx

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$4[rsp], edx
	je	SHORT $LN241@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN222@ZSTD_compr
$LN241@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, edx

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, edx
	jmp	SHORT $LN222@ZSTD_compr
$LN226@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, r11
	jae	SHORT $LN224@ZSTD_compr
	npad	10
$LL223@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN227@ZSTD_compr
	add	rax, 8
	add	rdx, 8
	cmp	rax, r11
	jb	SHORT $LL223@ZSTD_compr
$LN224@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r13-3]
	cmp	rax, rcx
	jae	SHORT $LN228@ZSTD_compr
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN228@ZSTD_compr
	add	rax, 4
	add	rdx, 4
$LN228@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r13-1]
	cmp	rax, rcx
	jae	SHORT $LN229@ZSTD_compr
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN229@ZSTD_compr
	add	rax, 2
	add	rdx, 2
$LN229@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r13
	jae	SHORT $LN230@ZSTD_compr
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN230@ZSTD_compr
	inc	rax
$LN230@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r8
$LN222@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 167  :                     { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; } /* swap offset_2 <=> offset_1 */

	mov	eax, r12d
	lea	r8, QWORD PTR [rcx+4]
	mov	r12d, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, DWORD PTR mls$[rsp]
	sub	eax, 5
	je	SHORT $LN269@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN270@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN271@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN272@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, QWORD PTR tv2041[rsp]
	imul	edx, r10d, -1640531535			; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN390@ZSTD_compr
$LN227@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$3[rsp], 0
	je	SHORT $LN257@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r8
	add	rcx, rax
	jmp	SHORT $LN222@ZSTD_compr
$LN257@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r8
	add	rcx, rax
	jmp	SHORT $LN222@ZSTD_compr
$LN272@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN391@ZSTD_compr
$LN271@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN391@ZSTD_compr
$LN270@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN391@ZSTD_compr
$LN269@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN391@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	rdx, QWORD PTR [rbx]
	mov	ecx, r9d
	imul	rdx, rax
$LN390@ZSTD_compr:
	shr	rdx, cl
	mov	eax, ebx
	sub	eax, r14d

; 169  :                     ip0 += rLength;

	add	rbx, r8
	mov	DWORD PTR [rdi+rdx*4], eax

; 170  :                     ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, 0 /*offCode*/, rLength-MINMATCH);

	lea	rdx, QWORD PTR [r8-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [rbp+24]

; 443  : #if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
; 444  :     static const BYTE* g_start = NULL;
; 445  :     if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
; 446  :     {   U32 const pos = (U32)((const BYTE*)literals - g_start);
; 447  :         DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offCode%7u",
; 448  :                pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode);
; 449  :     }
; 450  : #endif
; 451  :     assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
; 452  :     /* copy Literals */
; 453  :     assert(seqStorePtr->maxNbLit <= 128 KB);
; 454  :     assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
; 455  :     assert(literals + litLength <= litLimit);
; 456  :     if (litEnd <= litLimit_w) {

	cmp	rsi, r15
	ja	SHORT $LL326@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rax], xmm0
$LL326@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN366@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN366@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	lea	r10, QWORD PTR [r13-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 171  :                     anchor = ip0;

	mov	rsi, rbx
	cmp	rbx, r10
	jbe	$LL6@ZSTD_compr
$LN378@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], r12d
$LN7@ZSTD_compr:

; 172  :                     continue;   /* faster when present (confirmed on gcc-8) ... (?) */
; 173  :         }   }   }
; 174  :         ip1 = ip0 + 1;
; 175  :     }

	mov	r8d, DWORD PTR offset_1$1$[rsp]
	lea	r14, QWORD PTR [rbx+1]
	jmp	SHORT $LN349@ZSTD_compr
$LN12@ZSTD_compr:
	mov	r13, QWORD PTR iend$1$[rsp]

; 131  :             goto _offset;
; 132  :         }
; 133  :         {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;

	mov	rax, rbx
	sub	rax, rsi
	shr	rax, 7
	add	rax, QWORD PTR stepSize$1$[rsp]

; 134  :             assert(step >= 2);
; 135  :             ip0 += step;

	add	rbx, rax

; 136  :             ip1 += step;

	add	r14, rax
$LN349@ZSTD_compr:

; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r9d, DWORD PTR tv2060[rsp]
	lea	rax, QWORD PTR [r13-8]
	mov	r12, QWORD PTR hashTable$1$[rsp]
	mov	rdi, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	rcx, QWORD PTR tv2041[rsp]
	mov	r15, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r11d, DWORD PTR mls$[rsp]
	mov	r10, -3523014627271114752		; cf1bbcdcbb000000H
	cmp	r14, rax
	jb	$LL383@ZSTD_compr
	mov	r10d, DWORD PTR offset_2$1$[rsp]
	mov	r9d, DWORD PTR tv2513[rsp]
$LN3@ZSTD_compr:

; 176  : 
; 177  :     /* save reps for next block */
; 178  :     rep[0] = offset_1 ? offset_1 : offsetSaved;

	mov	rax, QWORD PTR rep$[rsp]
	test	r8d, r8d

; 179  :     rep[1] = offset_2 ? offset_2 : offsetSaved;
; 180  : 
; 181  :     /* Return the last literals size */
; 182  :     return (size_t)(iend - anchor);
; 183  : }

	mov	rbx, QWORD PTR [rsp+152]
	mov	ecx, r9d
	cmovne	ecx, r8d
	test	r10d, r10d
	cmovne	r9d, r10d
	mov	DWORD PTR [rax], ecx
	sub	r13, rsi
	mov	DWORD PTR [rax+4], r9d
	mov	rax, r13
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressBlock_fast_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
iend$1$ = 32
tv2808 = 40
hashTable$1$ = 48
dictIndexDelta$1$ = 56
prefixStartIndex$1$ = 60
stepSize$1$ = 64
dictEnd$1$ = 72
prefixStart$1$ = 80
dictStartIndex$1$ = 88
litLimit_w$1$ = 96
dictBase$1$ = 104
base$1$ = 112
tv2811 = 120
ilimit$1$ = 128
tv2809 = 136
dictHashTable$1$ = 144
dictStart$1$ = 152
offset_2$1$ = 224
r$1 = 224
r$2 = 224
ms$ = 224
seqStore$ = 232
rep$ = 240
tv2831 = 248
src$ = 248
offset_1$1$ = 256
srcSize$ = 256
mls$ = 264
ZSTD_compressBlock_fast_dictMatchState_generic PROC

; 210  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H

; 211  :     const ZSTD_compressionParameters* const cParams = &ms->cParams;
; 212  :     U32* const hashTable = ms->hashTable;
; 213  :     U32 const hlog = cParams->hashLog;
; 214  :     /* support stepSize of 0 */
; 215  :     U32 const stepSize = cParams->targetLength + !(cParams->targetLength);

	mov	eax, DWORD PTR [rcx+204]
	mov	r15, rdx

; 216  :     const BYTE* const base = ms->window.base;

	mov	rbp, QWORD PTR [rcx+8]
	xor	edx, edx

; 217  :     const BYTE* const istart = (const BYTE*)src;
; 218  :     const BYTE* ip = istart;
; 219  :     const BYTE* anchor = istart;
; 220  :     const U32   prefixStartIndex = ms->window.dictLimit;

	mov	r10d, DWORD PTR [rcx+24]
	test	eax, eax
	mov	r11, QWORD PTR [rcx+48]
	mov	rdi, r9
	mov	r9d, DWORD PTR [rcx+192]
	sete	dl

; 221  :     const BYTE* const prefixStart = base + prefixStartIndex;
; 222  :     const BYTE* const iend = istart + srcSize;

	mov	r14, QWORD PTR srcSize$[rsp]
	add	edx, eax
	add	r14, rdi
	mov	DWORD PTR stepSize$1$[rsp], edx
	mov	rbx, r8
	mov	QWORD PTR hashTable$1$[rsp], r11
	lea	r8, QWORD PTR [r10+rbp]
	mov	QWORD PTR base$1$[rsp], rbp
	mov	DWORD PTR prefixStartIndex$1$[rsp], r10d

; 223  :     const BYTE* const ilimit = iend - HASH_READ_SIZE;

	lea	r12, QWORD PTR [r14-8]
	mov	QWORD PTR prefixStart$1$[rsp], r8

; 224  :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	eax, DWORD PTR [rbx]
	mov	ebx, DWORD PTR [rbx+4]
	mov	DWORD PTR offset_1$1$[rsp], eax

; 225  :     U32 offsetSaved = 0;
; 226  : 
; 227  :     const ZSTD_matchState_t* const dms = ms->dictMatchState;

	mov	rax, QWORD PTR [rcx+176]
	mov	QWORD PTR iend$1$[rsp], r14
	mov	QWORD PTR ilimit$1$[rsp], r12
	mov	DWORD PTR offset_2$1$[rsp], ebx

; 228  :     const ZSTD_compressionParameters* const dictCParams = &dms->cParams ;
; 229  :     const U32* const dictHashTable = dms->hashTable;
; 230  :     const U32 dictStartIndex       = dms->window.dictLimit;

	mov	edx, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR [rax+48]

; 231  :     const BYTE* const dictBase     = dms->window.base;
; 232  :     const BYTE* const dictStart    = dictBase + dictStartIndex;
; 233  :     const BYTE* const dictEnd      = dms->window.nextSrc;

	mov	r13, QWORD PTR [rax]
	mov	QWORD PTR dictHashTable$1$[rsp], rcx
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR dictBase$1$[rsp], rcx
	mov	DWORD PTR dictStartIndex$1$[rsp], edx
	mov	QWORD PTR dictEnd$1$[rsp], r13
	lea	rsi, QWORD PTR [rcx+rdx]

; 234  :     const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);
; 235  :     const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);
; 236  :     const U32 dictHLog             = dictCParams->hashLog;

	mov	edx, DWORD PTR [rax+192]
	sub	ecx, r13d
	mov	QWORD PTR dictStart$1$[rsp], rsi
	add	ecx, r10d

; 237  : 
; 238  :     /* if a dictionary is still attached, it necessarily means that
; 239  :      * it is within window size. So we just check it. */
; 240  :     const U32 maxDistance = 1U << cParams->windowLog;
; 241  :     const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);
; 242  :     assert(endIndex - prefixStartIndex <= maxDistance);
; 243  :     (void)maxDistance; (void)endIndex;   /* these variables are not used when assert() is disabled */
; 244  : 
; 245  :     /* ensure there will be no no underflow
; 246  :      * when translating a dict index into a local index */
; 247  :     assert(prefixStartIndex >= (U32)(dictEnd - dictBase));
; 248  : 
; 249  :     /* init */
; 250  :     DEBUGLOG(5, "ZSTD_compressBlock_fast_dictMatchState_generic");
; 251  :     ip += (dictAndPrefixLength == 0);

	mov	eax, r13d
	sub	eax, r8d
	mov	DWORD PTR dictIndexDelta$1$[rsp], ecx
	sub	eax, esi
	add	eax, edi
	mov	eax, 0
	sete	al
	lea	rsi, QWORD PTR [rax+rdi]
	cmp	rsi, r12

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	jae	$LN3@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	eax, 64					; 00000040H

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	r8d, ecx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r13d, eax

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	sub	r8d, r9d

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	sub	r13d, r9d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	sub	ecx, edx

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	QWORD PTR tv2811[rsp], r8

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	sub	eax, edx

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	QWORD PTR tv2809[rsp], rcx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	DWORD PTR tv2808[rsp], eax
	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	DWORD PTR tv2831[rsp], r13d
	mov	r9, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r12, -3523014627193847808		; cf1bbcdcbf9b0000H
	npad	7
$LL2@ZSTD_compr:

; 631  :     switch(mls)

	mov	eax, DWORD PTR mls$[rsp]
	sub	eax, 5
	je	SHORT $LN31@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN32@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN33@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN34@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rsi], -1640531535	; 9e3779b1H
	mov	rcx, r8

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN460@ZSTD_compr
$LN34@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rsi]
	imul	rdx, rcx

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN461@ZSTD_compr
$LN33@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rsi]
	imul	rdx, r9

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN461@ZSTD_compr
$LN32@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rsi]
	imul	rdx, r12

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN461@ZSTD_compr
$LN31@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rsi]
	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rdx, rax
$LN461@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 261  :         U32 const current = (U32)(ip-base);

	mov	ecx, r13d
$LN460@ZSTD_compr:
	shr	rdx, cl
	mov	r12d, esi
	sub	r12d, ebp

; 262  :         U32 const matchIndex = hashTable[h];
; 263  :         const BYTE* match = base + matchIndex;
; 264  :         const U32 repIndex = current + 1 - offset_1;

	mov	ecx, r12d
	sub	ecx, DWORD PTR offset_1$1$[rsp]
	mov	r9d, DWORD PTR [r11+rdx*4]
	inc	ecx
	lea	r8, QWORD PTR [r9+rbp]

; 265  :         const BYTE* repMatch = (repIndex < prefixStartIndex) ?

	cmp	ecx, r10d
	jae	SHORT $LN22@ZSTD_compr
	mov	r11d, ecx
	sub	r11d, DWORD PTR dictIndexDelta$1$[rsp]
	add	r11, QWORD PTR dictBase$1$[rsp]
	jmp	SHORT $LN23@ZSTD_compr
$LN22@ZSTD_compr:
	mov	r11d, ecx
	add	r11, rbp
$LN23@ZSTD_compr:

; 266  :                                dictBase + (repIndex - dictIndexDelta) :
; 267  :                                base + repIndex;
; 268  :         hashTable[h] = current;   /* update hash table */

	mov	rax, QWORD PTR hashTable$1$[rsp]
	mov	DWORD PTR [rax+rdx*4], r12d

; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN10@ZSTD_compr
	mov	eax, DWORD PTR [rsi+1]
	lea	r14, QWORD PTR [rsi+1]
	cmp	DWORD PTR [r11], eax
	jne	$LN458@ZSTD_compr

; 272  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	mov	rdx, QWORD PTR iend$1$[rsp]

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	lea	rbp, QWORD PTR [rsi+5]
	cmp	ecx, r10d
	mov	rbx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdx
	mov	rcx, rbp
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 272  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rsp]

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11
	add	rcx, rbx
	cmp	rcx, rdx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rsi, rax
	add	rax, r11
	cmp	rax, rbx
	jne	SHORT $LN56@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rsi+rbp]
	call	ZSTD_count
	add	rsi, rax
$LN56@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
	lea	rbp, QWORD PTR [r8-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 273  :             mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;

	lea	r11, QWORD PTR [rsi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	QWORD PTR litLimit_w$1$[rsp], rbp
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 274  :             ip++;

	mov	rsi, r14

; 275  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);

	lea	r9, QWORD PTR [r11-3]
	sub	r14, rdi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r14+rdi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rbp
	ja	SHORT $LN62@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r14, 16
	jbe	SHORT $LN84@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r15+24]
	add	rdi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r14
$LL76@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]

; 289  :             COPY16(op, ip);

	lea	rdi, QWORD PTR [rdi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL76@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN84@ZSTD_compr
$LN62@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rdi, rbp
	ja	SHORT $LN387@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, rcx
	sub	rdx, rdi
	add	rdx, rbp
	sub	rdi, rcx
	npad	10
$LL93@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rdi]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rdx
	jb	SHORT $LL93@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, rdx
	mov	rdi, rbp
$LN387@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdi, r8
	jae	SHORT $LN84@ZSTD_compr
	sub	rcx, rdi
	npad	2
$LL408@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [rdi+rcx], al
	inc	rdi
	cmp	rdi, r8
	jb	SHORT $LL408@ZSTD_compr
$LN84@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r15+24], r14
	mov	rcx, QWORD PTR [r15+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r14, 65535				; 0000ffffH
	jbe	SHORT $LN432@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 1
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN432@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r14w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r9, 65535				; 0000ffffH
	jbe	SHORT $LN433@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN433@ZSTD_compr:

; 490  : }

	mov	r14, QWORD PTR iend$1$[rsp]
	mov	WORD PTR [rcx+6], r9w
	jmp	$LN462@ZSTD_compr
$LN458@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 271  :           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	r14, QWORD PTR iend$1$[rsp]
$LN10@ZSTD_compr:

; 276  :         } else if ( (matchIndex <= prefixStartIndex) ) {

	cmp	r9d, r10d
	ja	$LN12@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, DWORD PTR mls$[rsp]
	sub	eax, 5
	je	SHORT $LN103@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN104@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN105@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN106@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rsi], -1640531535	; 9e3779b1H
	mov	rcx, QWORD PTR tv2809[rsp]

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN463@ZSTD_compr
$LN106@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN464@ZSTD_compr
$LN105@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN464@ZSTD_compr
$LN104@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN464@ZSTD_compr
$LN103@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN464@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 278  :             U32 const dictMatchIndex = dictHashTable[dictHash];

	mov	rdx, QWORD PTR [rsi]
	mov	ecx, DWORD PTR tv2808[rsp]
	imul	rdx, rax
$LN463@ZSTD_compr:
	mov	rax, QWORD PTR dictHashTable$1$[rsp]
	shr	rdx, cl
	mov	ecx, DWORD PTR [rax+rdx*4]

; 279  :             const BYTE* dictMatch = dictBase + dictMatchIndex;

	mov	ebx, ecx
	add	rbx, QWORD PTR dictBase$1$[rsp]

; 280  :             if (dictMatchIndex <= dictStartIndex ||

	cmp	ecx, DWORD PTR dictStartIndex$1$[rsp]
	jbe	$LN16@ZSTD_compr
	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR [rbx], eax
	jne	$LN16@ZSTD_compr

; 288  :                 mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;

	lea	rbp, QWORD PTR [rsi+4]
	mov	r13d, r12d
	sub	r13d, ecx
	lea	r11, QWORD PTR [rbx+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, QWORD PTR dictEnd$1$[rsp]
	mov	rax, rbp
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 287  :                 U32 const offset = (U32)(current-dictMatchIndex-dictIndexDelta);

	sub	r13d, DWORD PTR dictIndexDelta$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rax, r11
	add	rcx, rax
	mov	r8, r14
	cmp	rcx, r14

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, QWORD PTR dictEnd$1$[rsp]
	jne	SHORT $LN128@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+rbp]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN128@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 290  :                      && (ip[-1] == dictMatch[-1])) {

	mov	r8, QWORD PTR dictStart$1$[rsp]
	lea	r11, QWORD PTR [r14+4]
	xor	r9d, r9d
	cmp	rbx, r8
	mov	ecx, r9d
	mov	eax, r9d
	seta	cl
	cmp	rsi, rdi
	seta	al
	test	ecx, eax
	je	SHORT $LN455@ZSTD_compr
	npad	1
$LL4@ZSTD_compr:
	movzx	eax, BYTE PTR [rbx-1]
	lea	rdx, QWORD PTR [rsi-1]
	dec	rbx
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN455@ZSTD_compr

; 291  :                     ip--; dictMatch--; mLength++;

	inc	r11
	mov	ecx, r9d
	cmp	rdx, rdi
	mov	eax, r9d
	mov	rsi, rdx
	seta	cl
	cmp	rbx, r8
	seta	al
	test	ecx, eax
	jne	SHORT $LL4@ZSTD_compr
$LN455@ZSTD_compr:

; 292  :                 } /* catch up */
; 293  :                 offset_2 = offset_1;

	mov	ebx, DWORD PTR offset_1$1$[rsp]

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	r10, QWORD PTR [r11-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	r14, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	r9, rsi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 295  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	sub	r9, rdi
	mov	DWORD PTR offset_2$1$[rsp], ebx
	mov	DWORD PTR offset_1$1$[rsp], r13d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbp, QWORD PTR [r14-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r9+rdi]
	mov	QWORD PTR litLimit_w$1$[rsp], rbp

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rbp
	ja	SHORT $LN134@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r9, 16
	jbe	SHORT $LN156@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r15+24]
	add	rdi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r9
	npad	11
$LL148@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]

; 289  :             COPY16(op, ip);

	lea	rdi, QWORD PTR [rdi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL148@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN156@ZSTD_compr
$LN134@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rdi, rbp
	ja	SHORT $LN391@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, rcx
	sub	rdx, rdi
	add	rdx, rbp
	sub	rdi, rcx
	npad	10
$LL165@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rdi]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rdx
	jb	SHORT $LL165@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, rdx
	mov	rdi, rbp
$LN391@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdi, r8
	jae	SHORT $LN156@ZSTD_compr
	sub	rcx, rdi
	npad	2
$LL410@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [rdi+rcx], al
	inc	rdi
	cmp	rdi, r8
	jb	SHORT $LL410@ZSTD_compr
$LN156@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r15+24], r9
	mov	rcx, QWORD PTR [r15+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r9, 65535				; 0000ffffH
	jbe	SHORT $LN434@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 1
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN434@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r9w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r13+3]
	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r10, 65535				; 0000ffffH
	jbe	SHORT $LN435@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN435@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 296  :             }

	mov	r13d, DWORD PTR tv2831[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r10w
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 296  :             }

	jmp	$LN465@ZSTD_compr
$LN16@ZSTD_compr:

; 281  :                 MEM_read32(dictMatch) != MEM_read32(ip)) {
; 282  :                 assert(stepSize >= 1);
; 283  :                 ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, rsi

; 284  :                 continue;

	mov	ebx, DWORD PTR offset_2$1$[rsp]
	sub	rcx, rdi
	sar	rcx, 8
	add	rsi, rax
	add	rsi, rcx
	jmp	$LN20@ZSTD_compr
$LN12@ZSTD_compr:

; 297  :         } else if (MEM_read32(match) != MEM_read32(ip)) {

	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR [r8], eax
	je	SHORT $LN17@ZSTD_compr

; 298  :             /* it's not a match, and we're not going to check the dictionary */
; 299  :             assert(stepSize >= 1);
; 300  :             ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, rsi
	sub	rcx, rdi
	add	rsi, rax
	sar	rcx, 8
	add	rsi, rcx

; 301  :             continue;

	jmp	$LN20@ZSTD_compr
$LN17@ZSTD_compr:

; 305  :             mLength = ZSTD_count(ip+4, match+4, iend) + 4;

	lea	rcx, QWORD PTR [rsi+4]
	mov	ebx, esi
	sub	ebx, r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	r9, QWORD PTR [r14-7]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 304  :             U32 const offset = (U32)(ip-match);

	lea	rdx, QWORD PTR [r8+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r10, rcx

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN173@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN175@ZSTD_compr

; 501  :             unsigned long r = 0;

	xor	ebp, ebp

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	mov	DWORD PTR r$2[rsp], ebp
	je	SHORT $LN190@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN171@ZSTD_compr
$LN190@ZSTD_compr:
	mov	eax, ebp

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN171@ZSTD_compr
$LN175@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, r9
	jae	SHORT $LN173@ZSTD_compr
	npad	1
$LL172@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN176@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, r9
	jb	SHORT $LL172@ZSTD_compr
$LN173@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r14-3]
	cmp	rcx, rax
	jae	SHORT $LN177@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN177@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN177@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r14-1]
	cmp	rcx, rax
	jae	SHORT $LN178@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN178@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN178@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r14
	jae	SHORT $LN179@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN179@ZSTD_compr
	inc	rcx
$LN179@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r10
	xor	ebp, ebp
$LN171@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 307  :                  && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */

	mov	r9, QWORD PTR prefixStart$1$[rsp]
	lea	r11, QWORD PTR [rax+4]
	cmp	r8, r9
	mov	ecx, ebp
	mov	eax, ebp
	seta	cl
	cmp	rsi, rdi
	seta	al
	test	ecx, eax
	je	SHORT $LN456@ZSTD_compr
	npad	3
$LL6@ZSTD_compr:
	movzx	eax, BYTE PTR [r8-1]
	lea	rdx, QWORD PTR [rsi-1]
	dec	r8
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN456@ZSTD_compr
	inc	r11
	mov	ecx, ebp
	cmp	rdx, rdi
	mov	eax, ebp
	mov	rsi, rdx
	seta	cl
	cmp	r8, r9
	seta	al
	test	ecx, eax
	jne	SHORT $LL6@ZSTD_compr
$LN456@ZSTD_compr:

; 308  :             offset_2 = offset_1;

	mov	eax, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	rbp, QWORD PTR [r14-32]

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 310  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	r10, QWORD PTR [r11-3]
	mov	r9, rsi
	mov	DWORD PTR offset_2$1$[rsp], eax
	sub	r9, rdi
	mov	DWORD PTR offset_1$1$[rsp], ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	mov	QWORD PTR litLimit_w$1$[rsp], rbp

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	r8, QWORD PTR [r9+rdi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	r8, rbp
	ja	SHORT $LN215@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r9, 16
	jbe	$LN237@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [r15+24]
	add	rdi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r9
$LL229@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]

; 289  :             COPY16(op, ip);

	lea	rdi, QWORD PTR [rdi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL229@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN237@ZSTD_compr
$LN176@ZSTD_compr:

; 501  :             unsigned long r = 0;

	xor	ebp, ebp

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	mov	DWORD PTR r$1[rsp], ebp
	je	SHORT $LN206@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r10
	add	rax, rcx
	jmp	$LN171@ZSTD_compr
$LN206@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, ebp

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r10
	add	rax, rcx
	jmp	$LN171@ZSTD_compr
$LN215@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rdi, rbp
	ja	SHORT $LN396@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	rdx, rcx
	sub	rdx, rdi
	add	rdx, rbp
	sub	rdi, rcx
	npad	10
$LL246@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rdi]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, rdx
	jb	SHORT $LL246@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, rdx
	mov	rdi, rbp
$LN396@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdi, r8
	jae	SHORT $LN237@ZSTD_compr
	sub	rcx, rdi
	npad	2
$LL412@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [rdi+rcx], al
	inc	rdi
	cmp	rdi, r8
	jb	SHORT $LL412@ZSTD_compr
$LN237@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [r15+24], r9
	mov	rcx, QWORD PTR [r15+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r9, 65535				; 0000ffffH
	jbe	SHORT $LN436@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 1
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN436@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r9w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rbx+3]
	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r10, 65535				; 0000ffffH
	jbe	SHORT $LN437@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN437@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r10w
$LN462@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 314  :         ip += mLength;

	mov	ebx, DWORD PTR offset_2$1$[rsp]
$LN465@ZSTD_compr:
	add	QWORD PTR [r15+8], 8
	lea	rdi, QWORD PTR [r11+rsi]

; 315  :         anchor = ip;
; 316  : 
; 317  :         if (ip <= ilimit) {

	mov	rbp, QWORD PTR base$1$[rsp]
	lea	r10, QWORD PTR [r14-8]
	mov	rsi, rdi
	cmp	rdi, r10
	ja	$LN459@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	r10d, DWORD PTR mls$[rsp]
	mov	eax, r10d
	mov	r9, QWORD PTR hashTable$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	mov	ecx, r12d
	add	rcx, rbp
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	$LN256@ZSTD_compr
	sub	eax, 1
	je	$LN257@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN258@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN259@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rcx+2], -1640531535	; 9e3779b1H
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	lea	r8d, DWORD PTR [r12+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	rcx, QWORD PTR tv2811[rsp]

; 631  :     switch(mls)

	mov	eax, r10d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 320  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [r9+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	$LN285@ZSTD_compr
	sub	eax, 1
	je	$LN286@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN287@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN288@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rdi-2], -1640531535	; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	$LN466@ZSTD_compr
$LN259@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	lea	edx, DWORD PTR [r12+2]

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H
	imul	rax, rcx
	mov	ecx, r13d
	shr	rax, cl

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	mov	DWORD PTR [r9+rax*4], edx
$LN288@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	$LN467@ZSTD_compr
$LN258@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	lea	edx, DWORD PTR [r12+2]

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193167104		; cf1bbcdcbfa56300H
	imul	rax, rcx
	mov	ecx, r13d
	shr	rax, cl

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	mov	DWORD PTR [r9+rax*4], edx
$LN287@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN467@ZSTD_compr
$LN257@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	lea	edx, DWORD PTR [r12+2]

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, r13d
	shr	rax, cl

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	mov	DWORD PTR [r9+rax*4], edx
$LN286@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN467@ZSTD_compr
$LN256@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	lea	edx, DWORD PTR [r12+2]

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, rcx
	mov	ecx, r13d
	shr	rax, cl

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	mov	DWORD PTR [r9+rax*4], edx
$LN285@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN467@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 321  :             hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);

	mov	rdx, QWORD PTR [rdi-2]
	mov	ecx, r13d
	imul	rdx, rax
$LN466@ZSTD_compr:
	mov	r13, QWORD PTR litLimit_w$1$[rsp]
	mov	eax, edi
	shr	rdx, cl
	sub	eax, ebp
	sub	eax, 2
	mov	DWORD PTR [r9+rdx*4], eax
	npad	8
$LL8@ZSTD_compr:

; 322  : 
; 323  :             /* check immediate repcode */
; 324  :             while (ip <= ilimit) {
; 325  :                 U32 const current2 = (U32)(ip-base);
; 326  :                 U32 const repIndex2 = current2 - offset_2;
; 327  :                 const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	r12d, esi
	sub	r12d, ebp
	mov	ecx, r12d
	sub	ecx, ebx
	mov	edx, ecx
	cmp	ecx, r10d
	jae	SHORT $LN24@ZSTD_compr
	mov	eax, DWORD PTR dictIndexDelta$1$[rsp]
	mov	r11, QWORD PTR dictBase$1$[rsp]
	sub	r11, rax
	add	r11, rdx
	jmp	SHORT $LN25@ZSTD_compr
$LN24@ZSTD_compr:
	lea	r11, QWORD PTR [rcx+rbp]
$LN25@ZSTD_compr:

; 328  :                         dictBase - dictIndexDelta + repIndex2 :
; 329  :                         base + repIndex2;
; 330  :                 if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
; 331  :                    && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {

	mov	eax, r10d
	sub	eax, ecx
	dec	eax
	cmp	eax, 3
	jb	$LN20@ZSTD_compr
	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR [r11], eax
	jne	$LN20@ZSTD_compr

; 332  :                     const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;

	cmp	ecx, r10d

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	lea	rbp, QWORD PTR [rsi+4]
	mov	rbx, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, rbp
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 332  :                     const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r14
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 333  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rbx
	cmp	rcx, r14
	cmovb	r8, rcx
	mov	rcx, rbp
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	add	rax, r11
	cmp	rax, rbx
	jne	SHORT $LN310@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [r14+rbp]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN310@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	eax, DWORD PTR offset_2$1$[rsp]
	add	r14, 4
	mov	ebx, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [r15+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 334  :                     U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_2$1$[rsp], ebx

; 335  :                     ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);

	lea	rdx, QWORD PTR [r14-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdi, r13
	ja	SHORT $LL347@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
	npad	3
$LL347@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [r15+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [r15+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN438@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [r15+72], 2
	sub	rax, QWORD PTR [r15]
	sar	rax, 3
	mov	DWORD PTR [r15+76], eax
$LN438@ZSTD_compr:

; 631  :     switch(mls)

	mov	eax, DWORD PTR mls$[rsp]

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx

; 488  : 
; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [r15+8], 8

; 631  :     switch(mls)

	sub	eax, 5
	je	SHORT $LN357@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN358@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN359@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN360@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	eax, DWORD PTR [rsi], -1640531535	; 9e3779b1H
	mov	rcx, QWORD PTR tv2811[rsp]

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN468@ZSTD_compr
$LN360@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN469@ZSTD_compr
$LN359@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193167104		; cf1bbcdcbfa56300H

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN469@ZSTD_compr
$LN358@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN469@ZSTD_compr
$LN357@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
$LN469@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 336  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	rax, QWORD PTR [rsi]
	imul	rax, rcx
	mov	ecx, DWORD PTR tv2831[rsp]
$LN468@ZSTD_compr:
	mov	r9, QWORD PTR hashTable$1$[rsp]

; 337  :                     ip += repLength2;

	add	rsi, r14
	mov	r14, QWORD PTR iend$1$[rsp]
	mov	rdi, rsi
	mov	rbp, QWORD PTR base$1$[rsp]
	shr	rax, cl
	mov	DWORD PTR [r9+rax*4], r12d
	cmp	rsi, QWORD PTR ilimit$1$[rsp]
	jbe	$LL8@ZSTD_compr
$LN459@ZSTD_compr:

; 252  :     /* dictMatchState repCode checks don't currently handle repCode == 0
; 253  :      * disabling. */
; 254  :     assert(offset_1 <= dictAndPrefixLength);
; 255  :     assert(offset_2 <= dictAndPrefixLength);
; 256  : 
; 257  :     /* Main Search Loop */
; 258  :     while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */

	mov	r10d, DWORD PTR prefixStartIndex$1$[rsp]
$LN20@ZSTD_compr:
	mov	rcx, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r13d, DWORD PTR tv2831[rsp]
	mov	r9, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r14, QWORD PTR iend$1$[rsp]
	mov	r12, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	r11, QWORD PTR hashTable$1$[rsp]
	mov	r8, QWORD PTR tv2811[rsp]
	cmp	rsi, QWORD PTR ilimit$1$[rsp]
	jb	$LL2@ZSTD_compr
$LN3@ZSTD_compr:

; 338  :                     anchor = ip;
; 339  :                     continue;
; 340  :                 }
; 341  :                 break;
; 342  :             }
; 343  :         }
; 344  :     }
; 345  : 
; 346  :     /* save reps for next block */
; 347  :     rep[0] = offset_1 ? offset_1 : offsetSaved;

	mov	rcx, QWORD PTR rep$[rsp]

; 348  :     rep[1] = offset_2 ? offset_2 : offsetSaved;
; 349  : 
; 350  :     /* Return the last literals size */
; 351  :     return (size_t)(iend - anchor);

	sub	r14, rdi
	mov	eax, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, r14
	mov	DWORD PTR [rcx+4], ebx

; 352  : }

	mov	rbx, QWORD PTR [rsp+232]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressBlock_fast_dictMatchState_generic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\common\zstd_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h
; File E:\dev\pyzstd\lib\compress\zstd_fast.c
_TEXT	SEGMENT
offset_2$1$ = 32
tv4506 = 32
hashTable$1$ = 40
iend$1$ = 48
prefixStartIndex$1$ = 56
offset$1$ = 56
hlog$1$ = 64
tv3920 = 64
current0$1$ = 72
lowLimit$1$ = 72
val1$1$ = 76
stepSize$1$ = 76
base$1$ = 80
current$1$ = 88
prefixStart$1$ = 96
ilimit$1$ = 104
stepSize$1$ = 104
prefixStart$1$ = 112
tv3899 = 112
dictEnd$1$ = 120
dictBase$1$ = 128
dictStart$1$ = 136
offset_1$1$ = 208
offset_1$1$ = 208
ms$ = 208
seqStore$ = 216
rep$ = 224
prefixStartIndex$1$ = 232
offset_2$1$ = 232
r$1 = 232
r$2 = 232
src$ = 232
tv3898 = 240
srcSize$ = 240
mls$ = 248
ZSTD_compressBlock_fast_extDict_generic PROC

; 378  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H

; 385  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	r14, QWORD PTR [rcx+16]
	mov	r11, rcx
	mov	rax, QWORD PTR [rcx+48]

; 386  :     const BYTE* const istart = (const BYTE*)src;
; 387  :     const BYTE* ip = istart;
; 388  :     const BYTE* anchor = istart;

	mov	rsi, r9
	mov	r10d, DWORD PTR [rcx+204]
	mov	rdi, r9
	mov	r13, QWORD PTR [rcx+8]
	mov	rbp, rdx

; 389  :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	mov	rdx, QWORD PTR srcSize$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	r8d, 1

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ebx, DWORD PTR [r11+32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 389  :     const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);

	mov	r9d, edx
	mov	QWORD PTR hashTable$1$[rsp], rax
	mov	eax, DWORD PTR [rcx+192]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	mov	ecx, DWORD PTR [rcx+184]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 381  :     U32 const hlog = cParams->hashLog;

	mov	DWORD PTR hlog$1$[rsp], eax

; 383  :     U32 const stepSize = cParams->targetLength + !(cParams->targetLength);

	xor	eax, eax
	test	r10d, r10d

; 384  :     const BYTE* const base = ms->window.base;

	mov	QWORD PTR base$1$[rsp], r13

; 385  :     const BYTE* const dictBase = ms->window.dictBase;

	mov	QWORD PTR dictBase$1$[rsp], r14
	sete	al
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 978  :     U32    const maxDistance = 1U << windowLog;

	shl	r8d, cl

; 979  :     U32    const lowestValid = ms->window.lowLimit;

	mov	ecx, DWORD PTR [r11+28]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 383  :     U32 const stepSize = cParams->targetLength + !(cParams->targetLength);

	add	eax, r10d

; 393  :     const U32   dictLimit = ms->window.dictLimit;

	mov	r10d, DWORD PTR [r11+24]
	sub	r9d, r13d
	mov	DWORD PTR stepSize$1$[rsp], eax
	add	r9d, edi
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	mov	eax, r9d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 394  :     const U32   prefixStartIndex = dictLimit < lowLimit ? lowLimit : dictLimit;

	mov	r15d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 980  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	eax, ecx

; 981  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	r12d, r9d
	sub	r12d, r8d
	cmp	eax, r8d
	mov	DWORD PTR prefixStartIndex$1$[rsp], r12d
	cmovbe	r12d, ecx
	test	ebx, ebx

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	r12d, ecx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 392  :     const BYTE* const dictStart = dictBase + dictStartIndex;

	mov	eax, r12d
	add	rax, r14
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 982  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR lowLimit$1$[rsp], r12d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 392  :     const BYTE* const dictStart = dictBase + dictStartIndex;

	mov	QWORD PTR dictStart$1$[rsp], rax

; 394  :     const U32   prefixStartIndex = dictLimit < lowLimit ? lowLimit : dictLimit;

	cmp	r10d, r12d
	cmovb	r15d, r12d

; 395  :     const BYTE* const prefixStart = base + prefixStartIndex;

	mov	eax, r15d

; 396  :     const BYTE* const dictEnd = dictBase + prefixStartIndex;

	add	rax, r14
	mov	DWORD PTR prefixStartIndex$1$[rsp], r15d
	mov	QWORD PTR dictEnd$1$[rsp], rax
	lea	rcx, QWORD PTR [r15+r13]
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 397  :     const BYTE* const iend = istart + srcSize;

	lea	r13, QWORD PTR [rsi+rdx]

; 398  :     const BYTE* const ilimit = iend - 8;

	mov	rcx, QWORD PTR rep$[rsp]
	lea	rax, QWORD PTR [r13-8]
	mov	QWORD PTR iend$1$[rsp], r13
	mov	QWORD PTR ilimit$1$[rsp], rax
	mov	r11d, DWORD PTR [rcx]

; 399  :     U32 offset_1=rep[0], offset_2=rep[1];

	mov	r14d, DWORD PTR [rcx+4]
	mov	DWORD PTR offset_1$1$[rsp], r11d
	mov	DWORD PTR offset_2$1$[rsp], r14d

; 400  : 
; 401  :     DEBUGLOG(5, "ZSTD_compressBlock_fast_extDict_generic (offset_1=%u)", offset_1);
; 402  : 
; 403  :     /* switch to "regular" variant if extDict is invalidated due to maxDistance */
; 404  :     if (prefixStartIndex == dictStartIndex)

	cmp	r15d, r12d
	jne	$LN553@ZSTD_compr

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	mov	eax, DWORD PTR stepSize$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 993  :     U32    const withinWindow = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;

	sub	r9d, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 65   :     const BYTE* const prefixStart = base + prefixStartIndex;

	mov	r12, QWORD PTR base$1$[rsp]
	inc	eax

; 80   :     }
; 81   : 
; 82   :     /* Main Search Loop */
; 83   : #ifdef __INTEL_COMPILER
; 84   :     /* From intel 'The vector pragma indicates that the loop should be
; 85   :      * vectorized if it is legal to do so'. Can be used together with
; 86   :      * #pragma ivdep (but have opted to exclude that because intel
; 87   :      * warns against using it).*/
; 88   :     #pragma vector always
; 89   : #endif
; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r15d, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmp	r9d, r8d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 56   :     size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;

	mov	QWORD PTR stepSize$1$[rsp], rax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmovbe	eax, r10d
	test	ebx, ebx

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	eax, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 73   :     ip0 += (ip0 == prefixStart);

	xor	esi, esi
	mov	ecx, eax
	add	rcx, r12
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	mov	DWORD PTR prefixStartIndex$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 69   :     U32 offsetSaved = 0;

	cmp	rdi, rcx
	mov	QWORD PTR prefixStart$1$[rsp], rcx

; 73   :     ip0 += (ip0 == prefixStart);

	mov	eax, esi
	sete	al
	lea	r9, QWORD PTR [rax+rdi]

; 74   :     ip1 = ip0 + 1;
; 75   :     {   U32 const current = (U32)(ip0 - base);

	mov	edx, r9d
	lea	r11, QWORD PTR [r9+1]
	sub	edx, r12d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	mov	ecx, edx
	mov	eax, edx
	sub	ecx, r8d
	sub	eax, r10d
	cmp	eax, r8d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 79   :         if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;

	mov	r8d, esi

; 80   :     }
; 81   : 
; 82   :     /* Main Search Loop */
; 83   : #ifdef __INTEL_COMPILER
; 84   :     /* From intel 'The vector pragma indicates that the loop should be
; 85   :      * vectorized if it is legal to do so'. Can be used together with
; 86   :      * #pragma ivdep (but have opted to exclude that because intel
; 87   :      * warns against using it).*/
; 88   :     #pragma vector always
; 89   : #endif
; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	eax, r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 994  :     U32    const isDictionary = (ms->loadedDictEnd != 0);

	cmovbe	ecx, r10d
	test	ebx, ebx

; 995  :     U32    const matchLowest = isDictionary ? lowestValid : withinWindow;

	cmovne	ecx, r10d
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 77   :         U32 const maxRep = current - windowLow;

	sub	edx, ecx

; 80   :     }
; 81   : 
; 82   :     /* Main Search Loop */
; 83   : #ifdef __INTEL_COMPILER
; 84   :     /* From intel 'The vector pragma indicates that the loop should be
; 85   :      * vectorized if it is legal to do so'. Can be used together with
; 86   :      * #pragma ivdep (but have opted to exclude that because intel
; 87   :      * warns against using it).*/
; 88   :     #pragma vector always
; 89   : #endif
; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	lea	rcx, QWORD PTR [r13-8]
	cmp	r14d, edx
	cmovbe	r8d, r14d
	cmovbe	r14d, esi
	cmp	r15d, edx
	cmovbe	eax, r14d
	cmovbe	esi, r15d
	mov	DWORD PTR tv4506[rsp], eax
	cmp	r11, rcx
	jae	$LN25@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	ecx, 32					; 00000020H
	sub	ecx, edx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	DWORD PTR offset_2$1$[rsp], r8d
	mov	r8d, DWORD PTR mls$[rsp]
	mov	r10d, 64				; 00000040H
	sub	r10d, edx

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	QWORD PTR tv3920[rsp], rcx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	DWORD PTR tv3898[rsp], r10d
	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	DWORD PTR offset_1$1$[rsp], esi
	mov	r14, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r15, -3523014627193167104		; cf1bbcdcbfa56300H
	npad	3
$LL24@ZSTD_compr:

; 631  :     switch(mls)

	mov	eax, r8d
	sub	eax, 5
	je	$LN51@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN52@ZSTD_compr
	mov	ebx, DWORD PTR [r9]
	sub	eax, 1
	je	SHORT $LN53@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN54@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, ebx, -1640531535			; 9e3779b1H

; 631  :     switch(mls)

	mov	eax, r8d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	shr	rdx, cl

; 631  :     switch(mls)

	sub	eax, 5
	je	SHORT $LN648@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN81@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN82@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN83@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	r8d, DWORD PTR [r11], -1640531535	; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN649@ZSTD_compr
$LN54@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9]
	mov	ecx, r10d
	imul	rdx, r14
	shr	rdx, cl
$LN83@ZSTD_compr:
	mov	r8, QWORD PTR [r11]
	imul	r8, r14

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN650@ZSTD_compr
$LN53@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9]
	mov	ecx, r10d
	imul	rdx, r15
	shr	rdx, cl
$LN82@ZSTD_compr:
	mov	r8, QWORD PTR [r11]
	imul	r8, r15

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN650@ZSTD_compr
$LN52@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9]
	mov	ecx, r10d
	imul	rdx, rbx

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	mov	ebx, DWORD PTR [r9]

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	shr	rdx, cl
$LN81@ZSTD_compr:
	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN80@ZSTD_compr
$LN51@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9]
	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	mov	ebx, DWORD PTR [r9]

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	ecx, r10d
	imul	rdx, rax
	shr	rdx, cl

; 631  :     switch(mls)

	jmp	SHORT $LN80@ZSTD_compr
$LN648@ZSTD_compr:
	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN80@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 96   :         U32 const val1 = MEM_read32(ip1);

	mov	r8, QWORD PTR [r11]
	imul	r8, rax
$LN650@ZSTD_compr:
	mov	ecx, r10d
$LN649@ZSTD_compr:
	mov	eax, DWORD PTR [r11]
	shr	r8, cl

; 97   :         U32 const current0 = (U32)(ip0-base);

	mov	ecx, r9d
	sub	ecx, r12d
	mov	DWORD PTR val1$1$[rsp], eax

; 98   :         U32 const current1 = (U32)(ip1-base);
; 99   :         U32 const matchIndex0 = hashTable[h0];

	mov	rax, QWORD PTR hashTable$1$[rsp]
	mov	DWORD PTR current0$1$[rsp], ecx
	mov	r15d, DWORD PTR [rax+rdx*4]

; 100  :         U32 const matchIndex1 = hashTable[h1];

	mov	r12d, DWORD PTR [rax+r8*4]

; 101  :         BYTE const* repMatch = ip2 - offset_1;
; 102  :         const BYTE* match0 = base + matchIndex0;

	mov	r10d, r15d
	add	r10, QWORD PTR base$1$[rsp]

; 103  :         const BYTE* match1 = base + matchIndex1;

	mov	r14d, r12d
	add	r14, QWORD PTR base$1$[rsp]
	mov	eax, esi
	lea	rsi, QWORD PTR [r9+2]
	sub	rsi, rax

; 104  :         U32 offcode;
; 105  : 
; 106  : #if defined(__aarch64__)
; 107  :         PREFETCH_L1(ip0+256);
; 108  : #endif
; 109  : 
; 110  :         hashTable[h0] = current0;   /* update hash table */

	mov	rax, QWORD PTR hashTable$1$[rsp]
	mov	DWORD PTR [rax+rdx*4], ecx

; 111  :         hashTable[h1] = current1;   /* update hash table */
; 112  : 
; 113  :         assert(ip0 + 1 == ip1);
; 114  : 
; 115  :         if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {

	xor	edx, edx
	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	eax, r11d
	sub	eax, DWORD PTR base$1$[rsp]
	mov	DWORD PTR [rcx+r8*4], eax
	mov	ecx, edx
	mov	eax, DWORD PTR [r9+2]
	cmp	DWORD PTR [rsi], eax
	mov	eax, edx
	mov	edx, DWORD PTR offset_1$1$[rsp]
	sete	cl
	test	edx, edx
	setne	al
	test	ecx, eax
	je	SHORT $LN32@ZSTD_compr

; 116  :             mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;

	movzx	eax, BYTE PTR [rsi-1]
	xor	r15d, r15d
	cmp	BYTE PTR [r9+1], al
	mov	r11d, r15d

; 117  :             ip0 = ip2 - mLength;
; 118  :             match0 = repMatch - mLength;
; 119  :             mLength += 4;
; 120  :             offcode = 0;
; 121  :             goto _match;

	mov	r12d, DWORD PTR offset_2$1$[rsp]
	mov	r10, rsi
	sete	r11b
	mov	r14d, r15d
	add	r9, 2
	sub	r10, r11
	sub	r9, r11
	add	r11, 4
	jmp	$_match$663
$LN32@ZSTD_compr:

; 122  :         }
; 123  :         if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {

	mov	eax, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	r15d, eax
	jbe	SHORT $LN33@ZSTD_compr
	cmp	DWORD PTR [r10], ebx
	je	SHORT $_offset$664
$LN33@ZSTD_compr:

; 124  :             /* found a regular match */
; 125  :             goto _offset;
; 126  :         }
; 127  :         if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {

	cmp	r12d, eax
	jbe	$LN34@ZSTD_compr
	mov	eax, DWORD PTR val1$1$[rsp]
	cmp	DWORD PTR [r14], eax
	jne	$LN34@ZSTD_compr

; 128  :             /* found a regular match after one literal */
; 129  :             ip0 = ip1;

	mov	r9, r11

; 130  :             match0 = match1;

	mov	r10, r14
$_offset$664:

; 137  :             continue;
; 138  :         }
; 139  : _offset: /* Requires: ip0, match0 */
; 140  :         /* Compute the offset code */
; 141  :         offset_2 = offset_1;
; 142  :         offset_1 = (U32)(ip0-match0);
; 143  :         offcode = offset_1 + ZSTD_REP_MOVE;
; 144  :         mLength = 4;
; 145  :         /* Count the backwards match length */
; 146  :         while (((ip0>anchor) & (match0>prefixStart))
; 147  :              && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; } /* catch up */

	mov	rbx, QWORD PTR prefixStart$1$[rsp]
	xor	r15d, r15d
	mov	ecx, r15d
	mov	DWORD PTR offset_2$1$[rsp], edx
	mov	eax, r9d
	mov	r12d, edx
	sub	eax, r10d
	mov	r11d, 4
	cmp	r10, rbx
	mov	DWORD PTR offset_1$1$[rsp], eax
	seta	cl
	cmp	r9, rdi
	lea	r14d, DWORD PTR [rax+2]
	mov	eax, r15d
	seta	al
	test	ecx, eax
	je	SHORT $_match$663
	npad	4
$LL26@ZSTD_compr:
	movzx	eax, BYTE PTR [r10-1]
	lea	rdx, QWORD PTR [r10-1]
	cmp	BYTE PTR [r9-1], al
	lea	r8, QWORD PTR [r9-1]
	jne	SHORT $_match$663
	inc	r11
	mov	ecx, r15d
	cmp	rdx, rbx
	mov	eax, r15d
	mov	r9, r8
	mov	r10, rdx
	seta	cl
	cmp	r8, rdi
	seta	al
	test	ecx, eax
	jne	SHORT $LL26@ZSTD_compr
$_match$663:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	mov	r13, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	lea	rcx, QWORD PTR [r11+r9]
	lea	rdx, QWORD PTR [r11+r10]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rcx

; 564  :     const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);

	lea	rbx, QWORD PTR [r13-7]

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rcx, rbx
	jae	SHORT $LN107@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN109@ZSTD_compr

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rax
	je	SHORT $LN124@ZSTD_compr
	shr	eax, 3
	jmp	SHORT $LN105@ZSTD_compr
$LN124@ZSTD_compr:
	mov	eax, r15d

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	jmp	SHORT $LN105@ZSTD_compr
$LN109@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rcx, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rcx, rbx
	jae	SHORT $LN107@ZSTD_compr
$LL106@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rax, QWORD PTR [rcx]
	xor	rax, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN110@ZSTD_compr
	add	rcx, 8
	add	rdx, 8
	cmp	rcx, rbx
	jb	SHORT $LL106@ZSTD_compr
$LN107@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rax, QWORD PTR [r13-3]
	cmp	rcx, rax
	jae	SHORT $LN111@ZSTD_compr
	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
	jne	SHORT $LN111@ZSTD_compr
	add	rcx, 4
	add	rdx, 4
$LN111@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rax, QWORD PTR [r13-1]
	cmp	rcx, rax
	jae	SHORT $LN112@ZSTD_compr
	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN112@ZSTD_compr
	add	rcx, 2
	add	rdx, 2
$LN112@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rcx, r13
	jae	SHORT $LN113@ZSTD_compr
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN113@ZSTD_compr
	inc	rcx
$LN113@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rax, rcx
	sub	rax, r8
$LN105@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
	lea	r15, QWORD PTR [r13-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 151  :         mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);

	add	r11, rax

; 152  :         ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);

	mov	r8, r9
	sub	r8, rdi
	lea	rsi, QWORD PTR [r11-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rdx, QWORD PTR [r8+rdi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdx, r15
	ja	SHORT $LN149@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r8, 16
	jbe	$LN171@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
	add	rdi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r8
	npad	1
$LL163@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]

; 289  :             COPY16(op, ip);

	lea	rdi, QWORD PTR [rdi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL163@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN171@ZSTD_compr
$LN110@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rax
	je	SHORT $LN140@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN105@ZSTD_compr
$LN140@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	edx, r15d

; 574  :             return (size_t)(pIn - pStart);

	mov	eax, edx
	sub	rax, r8
	add	rax, rcx
	jmp	SHORT $LN105@ZSTD_compr
$LN149@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rdi, r15
	ja	SHORT $LN548@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r10, rcx
	sub	r10, rdi
	add	r10, r15
	sub	rdi, rcx
	npad	10
$LL180@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rdi]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL180@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	mov	rdi, r15
$LN548@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rdi, rdx
	jae	SHORT $LN171@ZSTD_compr
	sub	rcx, rdi
	npad	2
$LL577@ZSTD_compr:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [rdi+rcx], al
	inc	rdi
	cmp	rdi, rdx
	jb	SHORT $LL577@ZSTD_compr
$LN171@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], r8
	mov	rcx, QWORD PTR [rbp+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r8, 65535				; 0000ffffH
	jbe	SHORT $LN608@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN608@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r8w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [r14+1]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rsi, 65535				; 0000ffffH
	jbe	SHORT $LN609@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN609@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 154  :         ip0 += mLength;

	add	r9, r11
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], si

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 155  :         anchor = ip0;

	lea	rax, QWORD PTR [r13-8]
	mov	rdi, r9
	cmp	r9, rax

; 156  : 
; 157  :         if (ip0 <= ilimit) {

	ja	$LN29@ZSTD_compr

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	edx, DWORD PTR current0$1$[rsp]
	mov	r11, QWORD PTR base$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	r14d, DWORD PTR mls$[rsp]
	mov	eax, r14d
	mov	rsi, QWORD PTR tv3920[rsp]
	mov	rdi, QWORD PTR hashTable$1$[rsp]
	mov	r10d, DWORD PTR tv3898[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	rcx, QWORD PTR [r11+rdx]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	$LN190@ZSTD_compr
	sub	eax, 1
	je	$LN191@ZSTD_compr
	sub	eax, 1
	je	$LN192@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN193@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	lea	r8d, DWORD PTR [rdx+2]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, r14d

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rcx+2], -1640531535	; 9e3779b1H
	mov	rcx, rsi
	shr	rdx, cl
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 160  :             hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */

	mov	DWORD PTR [rdi+rdx*4], r8d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	sub	eax, 5
	je	$LN219@ZSTD_compr
	sub	eax, 1
	je	$LN220@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN642@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN643@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [r9-2], -1640531535	; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	$LN651@ZSTD_compr
$LN193@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	add	edx, 2

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	ecx, r10d
	imul	rax, r8
	shr	rax, cl

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9-2]
	imul	rdx, r8

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	$LN652@ZSTD_compr
$LN643@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9-2]

; 631  :     switch(mls)

	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	imul	rdx, r8

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	$LN652@ZSTD_compr
$LN192@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	add	edx, 2

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	ecx, r10d
	imul	rax, r8
	shr	rax, cl

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9-2]
	imul	rdx, r8

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN652@ZSTD_compr
$LN642@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [r9-2]

; 631  :     switch(mls)

	mov	r8, -3523014627193167104		; cf1bbcdcbfa56300H

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	imul	rdx, r8

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN652@ZSTD_compr
$LN191@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	add	edx, 2

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rcx, -3523014627193847808		; cf1bbcdcbf9b0000H
	imul	rax, rcx
	mov	ecx, r10d
	shr	rax, cl

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx
$LN220@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN653@ZSTD_compr
$LN190@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, QWORD PTR [rcx+2]

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	add	edx, 2

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rcx, -3523014627271114752		; cf1bbcdcbb000000H
	imul	rax, rcx
	mov	ecx, r10d
	shr	rax, cl

; 635  :     case 5: return ZSTD_hash5Ptr(p, hBits);

	mov	DWORD PTR [rdi+rax*4], edx
$LN219@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN653@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 161  :             hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);

	mov	rdx, QWORD PTR [r9-2]
	imul	rdx, rax
$LN652@ZSTD_compr:
	mov	ecx, r10d
$LN651@ZSTD_compr:
	shr	rdx, cl
	mov	eax, r9d
	sub	eax, r11d
	sub	eax, 2
	mov	DWORD PTR [rdi+rdx*4], eax
	mov	rdi, r9

; 162  : 
; 163  :             if (offset_2 > 0) { /* offset_2==0 means offset_2 is invalidated */

	test	r12d, r12d
	je	$LN29@ZSTD_compr

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	lea	rax, QWORD PTR [r13-8]
	cmp	r9, rax
	ja	$LN29@ZSTD_compr
	npad	1
$LL28@ZSTD_compr:
	mov	r11d, DWORD PTR [r9]
	mov	rdx, r9
	mov	eax, r12d
	sub	rdx, rax
	cmp	r11d, DWORD PTR [rdx]
	jne	$LN638@ZSTD_compr

; 165  :                     /* store sequence */
; 166  :                     size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;

	lea	rax, QWORD PTR [r9+4]
	add	rdx, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 563  :     const BYTE* const pStart = pIn;

	mov	r8, rax

; 565  : 
; 566  :     if (pIn < pInLoopLimit) {

	cmp	rax, rbx
	jae	SHORT $LN246@ZSTD_compr

; 567  :         { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	je	SHORT $LN248@ZSTD_compr

; 501  :             unsigned long r = 0;

	xor	edx, edx

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rax, rcx
	mov	DWORD PTR r$2[rsp], edx
	je	SHORT $LN263@ZSTD_compr
	shr	eax, 3

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, eax
	jmp	SHORT $LN244@ZSTD_compr
$LN263@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	mov	eax, edx

; 568  :           if (diff) return ZSTD_NbCommonBytes(diff); }

	mov	ecx, edx
	jmp	SHORT $LN244@ZSTD_compr
$LN248@ZSTD_compr:

; 569  :         pIn+=sizeof(size_t); pMatch+=sizeof(size_t);

	add	rax, 8
	add	rdx, 8

; 570  :         while (pIn < pInLoopLimit) {

	cmp	rax, rbx
	jae	SHORT $LN246@ZSTD_compr
	npad	10
$LL245@ZSTD_compr:

; 571  :             size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);

	mov	rcx, QWORD PTR [rax]
	xor	rcx, QWORD PTR [rdx]

; 572  :             if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }

	jne	$LN249@ZSTD_compr
	add	rax, 8
	add	rdx, 8
	cmp	rax, rbx
	jb	SHORT $LL245@ZSTD_compr
$LN246@ZSTD_compr:

; 575  :     }   }
; 576  :     if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }

	lea	rcx, QWORD PTR [r13-3]
	cmp	rax, rcx
	jae	SHORT $LN250@ZSTD_compr
	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdx], ecx
	jne	SHORT $LN250@ZSTD_compr
	add	rax, 4
	add	rdx, 4
$LN250@ZSTD_compr:

; 577  :     if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }

	lea	rcx, QWORD PTR [r13-1]
	cmp	rax, rcx
	jae	SHORT $LN251@ZSTD_compr
	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [rdx], cx
	jne	SHORT $LN251@ZSTD_compr
	add	rax, 2
	add	rdx, 2
$LN251@ZSTD_compr:

; 578  :     if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;

	cmp	rax, r13
	jae	SHORT $LN252@ZSTD_compr
	movzx	ecx, BYTE PTR [rax]
	cmp	BYTE PTR [rdx], cl
	jne	SHORT $LN252@ZSTD_compr
	inc	rax
$LN252@ZSTD_compr:

; 579  :     return (size_t)(pIn - pStart);

	mov	rcx, rax
	sub	rcx, r8
$LN244@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 167  :                     { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; } /* swap offset_2 <=> offset_1 */

	mov	eax, r12d
	lea	r8, QWORD PTR [rcx+4]
	mov	r12d, DWORD PTR offset_1$1$[rsp]
	mov	DWORD PTR offset_1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 631  :     switch(mls)

	mov	eax, r14d
	sub	eax, 5
	je	SHORT $LN291@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN292@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN293@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN294@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, r11d, -1640531535			; 9e3779b1H
	mov	rcx, rsi

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN654@ZSTD_compr
$LN249@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	bsf	rdx, rcx
	mov	DWORD PTR r$1[rsp], 0
	je	SHORT $LN279@ZSTD_compr
	shr	edx, 3

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r8
	add	rcx, rax
	jmp	SHORT $LN244@ZSTD_compr
$LN279@ZSTD_compr:

; 502  :             return _BitScanForward64( &r, (U64)val ) ? (unsigned)(r >> 3) : 0;

	xor	edx, edx

; 574  :             return (size_t)(pIn - pStart);

	mov	ecx, edx
	sub	rcx, r8
	add	rcx, rax
	jmp	SHORT $LN244@ZSTD_compr
$LN294@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN655@ZSTD_compr
$LN293@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN655@ZSTD_compr
$LN292@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN655@ZSTD_compr
$LN291@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN655@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 168  :                     hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);

	mov	rdx, QWORD PTR [r9]
	mov	ecx, r10d
	imul	rdx, rax
$LN654@ZSTD_compr:
	shr	rdx, cl
	mov	eax, r9d
	sub	eax, DWORD PTR base$1$[rsp]

; 169  :                     ip0 += rLength;

	add	r9, r8
	mov	rcx, QWORD PTR hashTable$1$[rsp]
	mov	DWORD PTR [rcx+rdx*4], eax

; 170  :                     ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, 0 /*offCode*/, rLength-MINMATCH);

	lea	rdx, QWORD PTR [r8-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [rbp+24]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdi, r15
	ja	SHORT $LL348@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
$LL348@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	ecx, ecx
	mov	WORD PTR [rax+4], cx

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN610@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN610@ZSTD_compr:

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 164  :                 while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {

	lea	rax, QWORD PTR [r13-8]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 171  :                     anchor = ip0;

	mov	rdi, r9
	cmp	r9, rax
	jbe	$LL28@ZSTD_compr
$LN638@ZSTD_compr:
	mov	DWORD PTR offset_2$1$[rsp], r12d
$LN29@ZSTD_compr:

; 172  :                     continue;   /* faster when present (confirmed on gcc-8) ... (?) */
; 173  :         }   }   }
; 174  :         ip1 = ip0 + 1;

	lea	r11, QWORD PTR [r9+1]

; 175  :     }

	jmp	SHORT $LN570@ZSTD_compr
$LN34@ZSTD_compr:
	mov	r13, QWORD PTR iend$1$[rsp]

; 131  :             goto _offset;
; 132  :         }
; 133  :         {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;

	mov	rax, r9
	sub	rax, rdi
	shr	rax, 7
	add	rax, QWORD PTR stepSize$1$[rsp]

; 134  :             assert(step >= 2);
; 135  :             ip0 += step;

	add	r9, rax

; 136  :             ip1 += step;

	add	r11, rax
$LN570@ZSTD_compr:

; 80   :     }
; 81   : 
; 82   :     /* Main Search Loop */
; 83   : #ifdef __INTEL_COMPILER
; 84   :     /* From intel 'The vector pragma indicates that the loop should be
; 85   :      * vectorized if it is legal to do so'. Can be used together with
; 86   :      * #pragma ivdep (but have opted to exclude that because intel
; 87   :      * warns against using it).*/
; 88   :     #pragma vector always
; 89   : #endif
; 90   :     while (ip1 < ilimit) {   /* < instead of <=, because check at ip0+2 */

	mov	r10d, DWORD PTR tv3898[rsp]
	lea	rax, QWORD PTR [r13-8]
	mov	esi, DWORD PTR offset_1$1$[rsp]
	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	rcx, QWORD PTR tv3920[rsp]
	mov	r14, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r8d, DWORD PTR mls$[rsp]
	mov	r15, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r12, QWORD PTR base$1$[rsp]
	cmp	r11, rax
	jb	$LL24@ZSTD_compr
	mov	r8d, DWORD PTR offset_2$1$[rsp]
	mov	eax, DWORD PTR tv4506[rsp]
$LN25@ZSTD_compr:

; 176  : 
; 177  :     /* save reps for next block */
; 178  :     rep[0] = offset_1 ? offset_1 : offsetSaved;

	mov	r9, QWORD PTR rep$[rsp]
	test	esi, esi
	mov	ecx, eax
	cmovne	ecx, esi

; 179  :     rep[1] = offset_2 ? offset_2 : offsetSaved;

	test	r8d, r8d
	cmovne	eax, r8d
	mov	DWORD PTR [r9], ecx
	mov	DWORD PTR [r9+4], eax

; 180  : 
; 181  :     /* Return the last literals size */
; 182  :     return (size_t)(iend - anchor);

	sub	r13, rdi

; 405  :         return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, mls);

	jmp	$LN656@ZSTD_compr
$LN553@ZSTD_compr:

; 406  : 
; 407  :     /* Search Loop */
; 408  :     while (ip < ilimit) {  /* < instead of <=, because (ip+1) */

	cmp	rdi, rax
	jae	$LN3@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r10d, DWORD PTR mls$[rsp]

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR hlog$1$[rsp]

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r13d, 64				; 00000040H
	sub	r13d, DWORD PTR hlog$1$[rsp]
	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	DWORD PTR tv3898[rsp], r13d
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	mov	QWORD PTR tv3899[rsp], rcx

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	r9, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r14, -3523014627271114752		; cf1bbcdcbb000000H
	npad	1
$LL2@ZSTD_compr:

; 631  :     switch(mls)

	mov	eax, r10d
	sub	eax, 5
	je	SHORT $LN358@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN359@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN360@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN361@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rdi], -1640531535	; 9e3779b1H

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN657@ZSTD_compr
$LN361@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rdi]
	imul	rdx, r8

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN658@ZSTD_compr
$LN360@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rdi]
	imul	rdx, r9

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN658@ZSTD_compr
$LN359@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rdi]
	imul	rdx, rbx

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN658@ZSTD_compr
$LN358@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rdx, QWORD PTR [rdi]
	imul	rdx, r14
$LN658@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 410  :         const U32    matchIndex = hashTable[h];

	mov	ecx, r13d
$LN657@ZSTD_compr:

; 411  :         const BYTE* const matchBase = matchIndex < prefixStartIndex ? dictBase : base;

	mov	rbx, QWORD PTR base$1$[rsp]

; 412  :         const BYTE*  match = matchBase + matchIndex;
; 413  :         const U32    current = (U32)(ip-base);

	mov	r12d, edi
	mov	rax, QWORD PTR hashTable$1$[rsp]
	mov	r14, rbx
	shr	rdx, cl
	mov	r9d, DWORD PTR [rax+rdx*4]
	cmp	r9d, r15d
	cmovb	r14, QWORD PTR dictBase$1$[rsp]
	sub	r12d, ebx
	add	r14, r9
	mov	DWORD PTR current$1$[rsp], r12d

; 414  :         const U32    repIndex = current + 1 - offset_1;

	mov	r8d, r12d
	sub	r8d, r11d

; 415  :         const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;

	mov	r11, rbx
	inc	r8d
	cmp	r8d, r15d

; 416  :         const BYTE* const repMatch = repBase + repIndex;

	mov	eax, r8d
	cmovb	r11, QWORD PTR dictBase$1$[rsp]
	add	r11, rax

; 417  :         hashTable[h] = current;   /* update hash table */

	mov	rax, QWORD PTR hashTable$1$[rsp]
	mov	DWORD PTR [rax+rdx*4], r12d

; 418  :         DEBUGLOG(7, "offset_1 = %u , current = %u", offset_1, current);
; 419  :         assert(offset_1 <= current +1);   /* check repIndex */
; 420  : 
; 421  :         if ( (((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow */ & (repIndex > dictStartIndex))
; 422  :            && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	xor	edx, edx
	mov	ecx, edx
	mov	eax, r15d
	sub	eax, r8d
	dec	eax
	cmp	eax, 3
	mov	eax, edx
	mov	edx, DWORD PTR lowLimit$1$[rsp]
	setae	cl
	cmp	r8d, edx
	seta	al
	test	ecx, eax
	je	$LN9@ZSTD_compr
	mov	eax, DWORD PTR [rdi+1]
	lea	r15, QWORD PTR [rdi+1]
	cmp	DWORD PTR [r11], eax
	jne	$LN645@ZSTD_compr

; 423  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	mov	rdx, QWORD PTR iend$1$[rsp]

; 424  :             size_t const rLength = ZSTD_count_2segments(ip+1 +4, repMatch +4, iend, repMatchEnd, prefixStart) + 4;

	lea	r14, QWORD PTR [rdi+5]
	cmp	r8d, DWORD PTR prefixStartIndex$1$[rsp]
	mov	rbx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdx
	mov	rcx, r14
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 423  :             const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rsp]

; 424  :             size_t const rLength = ZSTD_count_2segments(ip+1 +4, repMatch +4, iend, repMatchEnd, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11
	add	rcx, rbx
	cmp	rcx, rdx

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmovb	r8, rcx
	mov	rcx, r14
	call	ZSTD_count

; 592  :     if (match + matchLength != mEnd) return matchLength;

	mov	r8, QWORD PTR iend$1$[rsp]
	mov	rdi, rax
	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	jne	SHORT $LN383@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r14]
	call	ZSTD_count
	add	rdi, rax
$LN383@ZSTD_compr:

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 424  :             size_t const rLength = ZSTD_count_2segments(ip+1 +4, repMatch +4, iend, repMatchEnd, prefixStart) + 4;

	lea	r10, QWORD PTR [rdi+4]

; 425  :             ip++;

	mov	rdi, r15
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	r14, QWORD PTR [r8-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 426  :             ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, rLength-MINMATCH);

	sub	r15, rsi
	lea	r9, QWORD PTR [r10-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rdx, QWORD PTR [r15+rsi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdx, r14
	ja	SHORT $LN389@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r15, 16
	jbe	SHORT $LN411@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
	add	rsi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r15
	npad	5
$LL403@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]

; 289  :             COPY16(op, ip);

	lea	rsi, QWORD PTR [rsi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL403@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN411@ZSTD_compr
$LN389@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rsi, r14
	ja	SHORT $LN556@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r8, rcx
	sub	r8, rsi
	add	r8, r14
	sub	rsi, rcx
	npad	10
$LL420@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rsi]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r8
	jb	SHORT $LL420@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r8
	mov	rsi, r14
$LN556@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rsi, rdx
	jae	SHORT $LN411@ZSTD_compr
	sub	rcx, rsi
	npad	2
$LL581@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR [rsi+rcx], al
	inc	rsi
	cmp	rsi, rdx
	jb	SHORT $LL581@ZSTD_compr
$LN411@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], r15
	mov	rcx, QWORD PTR [rbp+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r15, 65535				; 0000ffffH
	jbe	SHORT $LN611@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN611@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r15w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r9, 65535				; 0000ffffH
	jbe	SHORT $LN612@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN612@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 429  :         } else {

	mov	r15d, DWORD PTR offset_2$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r9w

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 427  :             ip += rLength;

	add	rdi, r10

; 429  :         } else {

	jmp	$LN659@ZSTD_compr
$LN645@ZSTD_compr:

; 418  :         DEBUGLOG(7, "offset_1 = %u , current = %u", offset_1, current);
; 419  :         assert(offset_1 <= current +1);   /* check repIndex */
; 420  : 
; 421  :         if ( (((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow */ & (repIndex > dictStartIndex))
; 422  :            && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {

	mov	r15d, DWORD PTR prefixStartIndex$1$[rsp]
$LN9@ZSTD_compr:

; 430  :             if ( (matchIndex < dictStartIndex) ||

	cmp	r9d, edx
	jb	$LN12@ZSTD_compr
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r14], eax
	jne	$LN12@ZSTD_compr

; 434  :                 continue;
; 435  :             }
; 436  :             {   const BYTE* const matchEnd = matchIndex < prefixStartIndex ? dictEnd : iend;

	mov	rdx, QWORD PTR iend$1$[rsp]

; 439  :                 size_t mLength = ZSTD_count_2segments(ip+4, match+4, iend, matchEnd, prefixStart) + 4;

	lea	r13, QWORD PTR [rdi+4]
	cmp	r9d, r15d
	lea	r11, QWORD PTR [r14+4]
	mov	r15, QWORD PTR prefixStart$1$[rsp]
	mov	rbx, rdx
	cmovb	rbx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, rdx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 437  :                 const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;

	cmp	r9d, DWORD PTR prefixStartIndex$1$[rsp]

; 438  :                 U32 const offset = current - matchIndex;

	mov	eax, r12d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r13
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 437  :                 const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;

	cmovb	r15, QWORD PTR dictStart$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11
	add	rcx, rbx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 438  :                 U32 const offset = current - matchIndex;

	sub	eax, r9d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	cmp	rcx, rdx
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 438  :                 U32 const offset = current - matchIndex;

	mov	DWORD PTR offset$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	cmovb	r8, rcx
	mov	rcx, r13
	call	ZSTD_count
	mov	r12, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	je	SHORT $LN427@ZSTD_compr
	mov	r13, QWORD PTR iend$1$[rsp]
	jmp	SHORT $LN426@ZSTD_compr
$LN427@ZSTD_compr:

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	lea	rcx, QWORD PTR [rax+r13]
	mov	r13, QWORD PTR iend$1$[rsp]
	mov	r8, r13
	call	ZSTD_count
	add	r12, rax
$LN426@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 440  :                 while (((ip>anchor) & (match>lowMatchPtr)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }   /* catch up */

	xor	r9d, r9d
	lea	r8, QWORD PTR [r12+4]
	cmp	r14, r15
	mov	ecx, r9d
	mov	eax, r9d
	seta	cl
	cmp	rdi, rsi
	seta	al
	test	ecx, eax
	je	SHORT $LN639@ZSTD_compr
	npad	7
$LL4@ZSTD_compr:
	movzx	eax, BYTE PTR [r14-1]
	lea	rdx, QWORD PTR [rdi-1]
	dec	r14
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN639@ZSTD_compr
	inc	r8
	mov	ecx, r9d
	cmp	rdx, rsi
	mov	eax, r9d
	mov	rdi, rdx
	seta	cl
	cmp	r14, r15
	seta	al
	test	ecx, eax
	jne	SHORT $LL4@ZSTD_compr
$LN639@ZSTD_compr:

; 441  :                 offset_2 = offset_1; offset_1 = offset;  /* update offset history */

	mov	r15d, DWORD PTR offset_1$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 441  :     BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;

	lea	r14, QWORD PTR [r13-32]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 441  :                 offset_2 = offset_1; offset_1 = offset;  /* update offset history */

	mov	ebx, DWORD PTR offset$1$[rsp]

; 442  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	lea	r11, QWORD PTR [r8-3]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rcx, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 442  :                 ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);

	mov	r9, rdi
	sub	r9, rsi
	mov	DWORD PTR offset_2$1$[rsp], r15d
	mov	DWORD PTR offset_1$1$[rsp], ebx
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	lea	rdx, QWORD PTR [r9+rsi]

; 456  :     if (litEnd <= litLimit_w) {

	cmp	rdx, r14
	ja	SHORT $LN432@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rcx], xmm0
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 462  :         if (litLength > 16) {

	cmp	r9, 16
	jbe	SHORT $LN454@ZSTD_compr

; 463  :             ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);

	mov	rax, QWORD PTR [rbp+24]
	add	rsi, 16
	add	rax, 16
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	lea	rcx, QWORD PTR [rax-16]
	add	rcx, r9
	npad	2
$LL446@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]

; 289  :             COPY16(op, ip);

	lea	rsi, QWORD PTR [rsi+16]

; 243  :     memcpy(dst, src, 16);

	movups	XMMWORD PTR [rax], xmm0

; 289  :             COPY16(op, ip);

	add	rax, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rax, rcx
	jb	SHORT $LL446@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 465  :     } else {

	jmp	SHORT $LN454@ZSTD_compr
$LN432@ZSTD_compr:

; 424  :     if (ip <= ilimit_w) {

	cmp	rsi, r14
	ja	SHORT $LN560@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 270  :     BYTE* const oend = op + length;

	mov	r10, rcx
	sub	r10, rsi
	add	r10, r14
	sub	rsi, rcx
	npad	10
$LL463@ZSTD_compr:

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rcx+rsi]
	movups	XMMWORD PTR [rcx], xmm0

; 289  :             COPY16(op, ip);

	add	rcx, 16

; 290  :         }
; 291  :         while (op < oend);

	cmp	rcx, r10
	jb	SHORT $LL463@ZSTD_compr
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 427  :         ip = ilimit_w;

	mov	rcx, r10
	mov	rsi, r14
$LN560@ZSTD_compr:

; 428  :     }
; 429  :     while (ip < iend) *op++ = *ip++;

	cmp	rsi, rdx
	jae	SHORT $LN454@ZSTD_compr
	sub	rcx, rsi
	npad	2
$LL583@ZSTD_compr:
	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR [rsi+rcx], al
	inc	rsi
	cmp	rsi, rdx
	jb	SHORT $LL583@ZSTD_compr
$LN454@ZSTD_compr:

; 468  :     seqStorePtr->lit += litLength;

	add	QWORD PTR [rbp+24], r9
	mov	rcx, QWORD PTR [rbp+8]

; 469  : 
; 470  :     /* literal Length */
; 471  :     if (litLength>0xFFFF) {

	cmp	r9, 65535				; 0000ffffH
	jbe	SHORT $LN613@ZSTD_compr

; 472  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 473  :         seqStorePtr->longLengthID = 1;
; 474  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 1
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN613@ZSTD_compr:

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	WORD PTR [rcx+4], r9w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	lea	ecx, DWORD PTR [rbx+3]
	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], ecx
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	r11, 65535				; 0000ffffH
	jbe	SHORT $LN614@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN614@ZSTD_compr:
	mov	r13d, DWORD PTR tv3898[rsp]
	mov	r12d, DWORD PTR current$1$[rsp]

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], r11w

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 443  :                 ip += mLength;

	add	rdi, r8
$LN659@ZSTD_compr:

; 444  :                 anchor = ip;
; 445  :         }   }
; 446  : 
; 447  :         if (ip <= ilimit) {

	mov	rsi, rdi
	mov	r10d, DWORD PTR mls$[rsp]
	cmp	rdi, QWORD PTR ilimit$1$[rsp]
	ja	$LN644@ZSTD_compr

; 448  :             /* Fill Table */
; 449  :             hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;

	mov	r14, QWORD PTR base$1$[rsp]
	lea	r9d, DWORD PTR [r12+2]
	mov	edx, DWORD PTR hlog$1$[rsp]
	mov	r8d, r10d
	mov	eax, r12d
	lea	rcx, QWORD PTR [r14+2]
	add	rcx, rax
	call	ZSTD_hashPtr
	mov	r11, QWORD PTR hashTable$1$[rsp]

; 450  :             hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);

	lea	rcx, QWORD PTR [rdi-2]
	mov	r8d, r10d
	mov	DWORD PTR [r11+rax*4], r9d
	mov	r9d, edi
	sub	r9d, r14d
	sub	r9d, 2
	call	ZSTD_hashPtr
	xor	r8d, r8d
	mov	DWORD PTR [r11+rax*4], r9d
	mov	r9, QWORD PTR iend$1$[rsp]
	npad	1
$LL6@ZSTD_compr:

; 451  :             /* check immediate repcode */
; 452  :             while (ip <= ilimit) {
; 453  :                 U32 const current2 = (U32)(ip-base);
; 454  :                 U32 const repIndex2 = current2 - offset_2;
; 455  :                 const BYTE* const repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;
; 456  :                 if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3) & (repIndex2 > dictStartIndex))  /* intentional overflow */
; 457  :                    && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {

	mov	r11, QWORD PTR dictBase$1$[rsp]
	mov	ecx, r8d
	mov	r12d, edi
	sub	r12d, r14d
	mov	edx, r12d
	sub	edx, r15d
	mov	r15d, DWORD PTR prefixStartIndex$1$[rsp]
	cmp	edx, r15d
	mov	eax, edx
	cmovae	r11, r14
	add	r11, rax
	mov	eax, r15d
	sub	eax, edx
	dec	eax
	cmp	eax, 3
	mov	eax, r8d
	setae	cl
	cmp	edx, DWORD PTR lowLimit$1$[rsp]
	seta	al
	test	ecx, eax
	je	$LN647@ZSTD_compr
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [r11], eax
	jne	$LN647@ZSTD_compr

; 458  :                     const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;

	cmp	edx, r15d
	mov	rbx, r9

; 459  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	lea	r15, QWORD PTR [rdi+4]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	r8, r9
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 458  :                     const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;

	cmovb	rbx, QWORD PTR dictEnd$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	mov	rcx, r15
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 459  :                     size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;

	add	r11, 4
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 590  :     const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);

	sub	rcx, r11

; 591  :     size_t const matchLength = ZSTD_count(ip, match, vEnd);

	mov	rdx, r11
	add	rcx, rbx
	cmp	rcx, r9
	cmovb	r8, rcx
	mov	rcx, r15
	call	ZSTD_count
	mov	r14, rax

; 592  :     if (match + matchLength != mEnd) return matchLength;

	lea	rcx, QWORD PTR [rax+r11]
	cmp	rcx, rbx
	jne	SHORT $LN469@ZSTD_compr

; 593  :     DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
; 594  :     DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
; 595  :     DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
; 596  :     DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
; 597  :     DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
; 598  :     return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);

	mov	r8, QWORD PTR iend$1$[rsp]
	lea	rcx, QWORD PTR [rax+r15]
	mov	rdx, QWORD PTR prefixStart$1$[rsp]
	call	ZSTD_count
	add	r14, rax
$LN469@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 460  :                     { U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset; }  /* swap offset_2 <=> offset_1 */

	mov	eax, DWORD PTR offset_2$1$[rsp]
	add	r14, 4
	mov	r15d, DWORD PTR offset_1$1$[rsp]
	mov	r11d, eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	mov	r9, QWORD PTR iend$1$[rsp]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 460  :                     { U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset; }  /* swap offset_2 <=> offset_1 */

	mov	DWORD PTR offset_1$1$[rsp], eax
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 442  :     BYTE const* const litEnd = literals + litLength;

	mov	rax, QWORD PTR [rbp+24]
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 461  :                     ZSTD_storeSeq(seqStore, 0 /*litlen*/, anchor, iend, 0 /*offcode*/, repLength2-MINMATCH);

	lea	rdx, QWORD PTR [r14-3]
	mov	DWORD PTR offset_2$1$[rsp], r15d
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 456  :     if (litEnd <= litLimit_w) {

	lea	rcx, QWORD PTR [r9-32]
	cmp	rsi, rcx
	ja	SHORT $LL506@ZSTD_compr
; File E:\dev\pyzstd\lib\common\zstd_internal.h

; 243  :     memcpy(dst, src, 16);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rax], xmm0
	npad	12
$LL506@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_compress_internal.h

; 476  :     seqStorePtr->sequences[0].litLength = (U16)litLength;

	mov	rax, QWORD PTR [rbp+8]
	xor	r8d, r8d
	mov	WORD PTR [rax+4], r8w

; 477  : 
; 478  :     /* match offset */
; 479  :     seqStorePtr->sequences[0].offset = offCode + 1;

	mov	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR [rax], 1
	mov	rcx, QWORD PTR [rbp+8]

; 480  : 
; 481  :     /* match Length */
; 482  :     if (mlBase>0xFFFF) {

	cmp	rdx, 65535				; 0000ffffH
	jbe	SHORT $LN615@ZSTD_compr

; 483  :         assert(seqStorePtr->longLengthID == 0); /* there can only be a single long length */
; 484  :         seqStorePtr->longLengthID = 2;
; 485  :         seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);

	mov	rax, rcx
	mov	DWORD PTR [rbp+72], 2
	sub	rax, QWORD PTR [rbp]
	sar	rax, 3
	mov	DWORD PTR [rbp+76], eax
$LN615@ZSTD_compr:

; 631  :     switch(mls)

	mov	r10d, DWORD PTR mls$[rsp]
	mov	eax, r10d

; 487  :     seqStorePtr->sequences[0].matchLength = (U16)mlBase;

	mov	WORD PTR [rcx+6], dx

; 489  :     seqStorePtr->sequences++;

	add	QWORD PTR [rbp+8], 8

; 631  :     switch(mls)

	sub	eax, 5
	je	SHORT $LN516@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN517@ZSTD_compr
	sub	eax, 1
	je	SHORT $LN518@ZSTD_compr
	cmp	eax, 1
	je	SHORT $LN519@ZSTD_compr

; 610  : static U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }

	imul	edx, DWORD PTR [rdi], -1640531535	; 9e3779b1H
	mov	rcx, QWORD PTR tv3899[rsp]

; 634  :     case 4: return ZSTD_hash4Ptr(p, hBits);

	jmp	SHORT $LN660@ZSTD_compr
$LN519@ZSTD_compr:

; 626  : static size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }

	mov	rax, -3523014627327384477		; cf1bbcdcb7a56463H

; 638  :     case 8: return ZSTD_hash8Ptr(p, hBits);

	jmp	SHORT $LN661@ZSTD_compr
$LN518@ZSTD_compr:

; 622  : static size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }

	mov	rax, -3523014627193167104		; cf1bbcdcbfa56300H

; 637  :     case 7: return ZSTD_hash7Ptr(p, hBits);

	jmp	SHORT $LN661@ZSTD_compr
$LN517@ZSTD_compr:

; 618  : static size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }

	mov	rax, -3523014627193847808		; cf1bbcdcbf9b0000H

; 636  :     case 6: return ZSTD_hash6Ptr(p, hBits);

	jmp	SHORT $LN661@ZSTD_compr
$LN516@ZSTD_compr:

; 614  : static size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }

	mov	rax, -3523014627271114752		; cf1bbcdcbb000000H
$LN661@ZSTD_compr:
; File E:\dev\pyzstd\lib\compress\zstd_fast.c

; 462  :                     hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;

	mov	rdx, QWORD PTR [rdi]
	mov	ecx, r13d
	imul	rdx, rax
$LN660@ZSTD_compr:
	mov	rax, QWORD PTR hashTable$1$[rsp]

; 463  :                     ip += repLength2;

	add	rdi, r14
	mov	r14, QWORD PTR base$1$[rsp]
	mov	rsi, rdi
	shr	rdx, cl
	mov	DWORD PTR [rax+rdx*4], r12d
	lea	rax, QWORD PTR [r9-8]
	cmp	rdi, rax
	jbe	$LL6@ZSTD_compr

; 464  :                     anchor = ip;
; 465  :                     continue;
; 466  :                 }
; 467  :                 break;
; 468  :     }   }   }

	mov	r15d, DWORD PTR prefixStartIndex$1$[rsp]
	jmp	SHORT $LN576@ZSTD_compr
$LN12@ZSTD_compr:

; 431  :                  (MEM_read32(match) != MEM_read32(ip)) ) {
; 432  :                 assert(stepSize >= 1);
; 433  :                 ip += ((ip-anchor) >> kSearchStrength) + stepSize;

	mov	eax, DWORD PTR stepSize$1$[rsp]
	mov	rcx, rdi
	sub	rcx, rsi
	add	rdi, rax
	sar	rcx, 8
	add	rdi, rcx

; 444  :                 anchor = ip;
; 445  :         }   }
; 446  : 
; 447  :         if (ip <= ilimit) {

	jmp	SHORT $LN647@ZSTD_compr
$LN644@ZSTD_compr:
	mov	r15d, DWORD PTR prefixStartIndex$1$[rsp]
$LN647@ZSTD_compr:

; 406  : 
; 407  :     /* Search Loop */
; 408  :     while (ip < ilimit) {  /* < instead of <=, because (ip+1) */

	mov	r11d, DWORD PTR offset_1$1$[rsp]
$LN576@ZSTD_compr:
	mov	rbx, -3523014627193847808		; cf1bbcdcbf9b0000H
	mov	rcx, QWORD PTR tv3899[rsp]
	mov	r8, -3523014627327384477		; cf1bbcdcb7a56463H
	mov	r9, -3523014627193167104		; cf1bbcdcbfa56300H
	mov	r14, -3523014627271114752		; cf1bbcdcbb000000H
	cmp	rdi, QWORD PTR ilimit$1$[rsp]
	jb	$LL2@ZSTD_compr
	mov	r14d, DWORD PTR offset_2$1$[rsp]
	mov	r13, QWORD PTR iend$1$[rsp]
	mov	rcx, QWORD PTR rep$[rsp]
$LN3@ZSTD_compr:

; 469  : 
; 470  :     /* save reps for next block */
; 471  :     rep[0] = offset_1;

	mov	DWORD PTR [rcx], r11d

; 472  :     rep[1] = offset_2;
; 473  : 
; 474  :     /* Return the last literals size */
; 475  :     return (size_t)(iend - anchor);

	sub	r13, rsi
	mov	DWORD PTR [rcx+4], r14d
$LN656@ZSTD_compr:

; 476  : }

	mov	rbx, QWORD PTR [rsp+216]
	mov	rax, r13
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ZSTD_compressBlock_fast_extDict_generic ENDP
_TEXT	ENDS
END
